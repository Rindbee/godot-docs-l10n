:github_url: hide

.. _class_Node:

Node
====

**Наследует:** :ref:`Object<class_Object>`

**Наследуется от:** :ref:`AnimationMixer<class_AnimationMixer>`, :ref:`AudioStreamPlayer<class_AudioStreamPlayer>`, :ref:`CanvasItem<class_CanvasItem>`, :ref:`CanvasLayer<class_CanvasLayer>`, :ref:`EditorFileSystem<class_EditorFileSystem>`, :ref:`EditorPlugin<class_EditorPlugin>`, :ref:`EditorResourcePreview<class_EditorResourcePreview>`, :ref:`HTTPRequest<class_HTTPRequest>`, :ref:`InstancePlaceholder<class_InstancePlaceholder>`, :ref:`MissingNode<class_MissingNode>`, :ref:`MultiplayerSpawner<class_MultiplayerSpawner>`, :ref:`MultiplayerSynchronizer<class_MultiplayerSynchronizer>`, :ref:`NavigationAgent2D<class_NavigationAgent2D>`, :ref:`NavigationAgent3D<class_NavigationAgent3D>`, :ref:`Node3D<class_Node3D>`, :ref:`ResourcePreloader<class_ResourcePreloader>`, :ref:`ShaderGlobalsOverride<class_ShaderGlobalsOverride>`, :ref:`StatusIndicator<class_StatusIndicator>`, :ref:`Timer<class_Timer>`, :ref:`Viewport<class_Viewport>`, :ref:`WorldEnvironment<class_WorldEnvironment>`

Базовый класс для всех объектов.

.. rst-class:: classref-introduction-group

Описание
----------------

Узлы — это строительные блоки Godot. Их можно назначать в качестве дочерних узлов другого узла, что приводит к древовидной структуре. Указанный узел может содержать любое количество узлов в качестве дочерних с требованием, чтобы все родственные элементы (прямые дочерние элементы узла) имели уникальные имена.

Дерево узлов называется *сценой*. Сцены можно сохранять на диске, а затем создавать экземпляры в других сценах. Это обеспечивает очень высокую гибкость в архитектуре и модели данных проектов Godot.

\ **Scene tree:** :ref:`SceneTree<class_SceneTree>` содержит активное дерево узлов. Когда узел добавляется в дерево сцен, он получает уведомление :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>`, и запускается его обратный вызов :ref:`_enter_tree()<class_Node_private_method__enter_tree>`. Дочерние узлы всегда добавляются *после* их родительского узла, т. е. обратный вызов :ref:`_enter_tree()<class_Node_private_method__enter_tree>` родительского узла будет запущен раньше, чем у его дочернего узла.

После добавления всех узлов в дерево сцены они получают уведомление :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>` и запускаются их соответствующие обратные вызовы :ref:`_ready()<class_Node_private_method__ready>`. Для групп узлов обратный вызов :ref:`_ready()<class_Node_private_method__ready>` вызывается в обратном порядке, начиная с дочерних и продвигаясь к родительским узлам.

Это означает, что при добавлении узла в дерево сцены для обратных вызовов будет использоваться следующий порядок: :ref:`_enter_tree()<class_Node_private_method__enter_tree>` родителя, :ref:`_enter_tree()<class_Node_private_method__enter_tree>` дочерних узлов, :ref:`_ready()<class_Node_private_method__ready>` дочерних узлов и, наконец, :ref:`_ready()<class_Node_private_method__ready>` родителя (рекурсивно для всего дерева сцены).

\ **Обработка:** Узлы могут переопределять состояние «process», чтобы получать обратный вызов в каждом кадре, запрашивающий их обработку (что-либо сделать). Обычная обработка (callback :ref:`_process()<class_Node_private_method__process>`, переключаемая с помощью :ref:`set_process()<class_Node_method_set_process>`) происходит максимально быстро и зависит от частоты кадров, поэтому время обработки *delta* (в секундах) передается как аргумент. Обработка физики (callback :ref:`_physics_process()<class_Node_private_method__physics_process>`, переключаемая с помощью :ref:`set_physics_process()<class_Node_method_set_physics_process>`) происходит фиксированное количество раз в секунду (по умолчанию 60) и полезна для кода, связанного с физическим движком.

Узлы также могут обрабатывать входные события. При наличии функция :ref:`_input()<class_Node_private_method__input>` будет вызываться для каждого входного сигнала, который получает программа. Во многих случаях это может быть излишним (если только не используется для простых проектов), и функция :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` может быть предпочтительнее; она вызывается, когда входное событие не было обработано никем другим (обычно узлами GUI :ref:`Control<class_Control>`), гарантируя, что узел получает только те события, которые ему предназначены. 

Чтобы отслеживать иерархию сцен (особенно при создании экземпляров сцен в других сценах), можно задать «владельца» для узла с помощью свойства :ref:`owner<class_Node_property_owner>`. Это отслеживает, кто что создал. Однако это в основном полезно при написании редакторов и инструментов.

Наконец, когда узел освобождается с помощью :ref:`Object.free()<class_Object_method_free>` или :ref:`queue_free()<class_Node_method_queue_free>`, он также освобождает всех своих дочерних элементов.

\ **Группы:** Узлы можно добавлять в столько групп, сколько вам нужно, чтобы ими было легко управлять, вы можете создавать группы, например, «enemies» или «collectables», в зависимости от вашей игры. См. :ref:`add_to_group()<class_Node_method_add_to_group>`, :ref:`is_in_group()<class_Node_method_is_in_group>` и :ref:`remove_from_group()<class_Node_method_remove_from_group>`. Затем вы можете извлекать все узлы в этих группах, перебирать их и даже вызывать методы для групп с помощью методов на :ref:`SceneTree<class_SceneTree>`.

\ **Сетевое взаимодействие с узлами:** После подключения к серверу (или его создания, см. :ref:`ENetMultiplayerPeer<class_ENetMultiplayerPeer>`) можно использовать встроенную систему RPC (вызов удаленных процедур) для связи по сети. Вызывая :ref:`rpc()<class_Node_method_rpc>` с именем метода, он будет вызван локально и во всех подключенных одноранговых узлах (одноранговые узлы = клиенты и сервер, который принимает соединения). Чтобы определить, какой узел получает вызов RPC, Godot будет использовать свой :ref:`NodePath<class_NodePath>` (убедитесь, что имена узлов одинаковы на всех одноранговых узлах). Также ознакомьтесь с руководством по высокоуровневым сетям и соответствующими демонстрациями.

\ **Примечание:** Свойство ``script`` является частью класса :ref:`Object<class_Object>`, а не **Node**. Оно не отображается, как большинство свойств, но имеет сеттер и геттер (см. :ref:`Object.set_script()<class_Object_method_set_script>` и :ref:`Object.get_script()<class_Object_method_get_script>`).

.. rst-class:: classref-introduction-group

Обучающие материалы
--------------------------------------

- :doc:`Узлы и сцены <../getting_started/step_by_step/nodes_and_scenes>`

- `Все демонстрации <https://github.com/godotengine/godot-demo-projects/>`__

.. rst-class:: classref-reftable-group

Свойства
----------------

.. table::
   :widths: auto

   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>`                       | :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`               | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`String<class_String>`                                                 | :ref:`editor_description<class_Node_property_editor_description>`                 | ``""``    |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`MultiplayerAPI<class_MultiplayerAPI>`                                 | :ref:`multiplayer<class_Node_property_multiplayer>`                               |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`StringName<class_StringName>`                                         | :ref:`name<class_Node_property_name>`                                             |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`Node<class_Node>`                                                     | :ref:`owner<class_Node_property_owner>`                                           |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>`         | :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`ProcessMode<enum_Node_ProcessMode>`                                   | :ref:`process_mode<class_Node_property_process_mode>`                             | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_physics_priority<class_Node_property_process_physics_priority>`     | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_priority<class_Node_property_process_priority>`                     | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>`                     | :ref:`process_thread_group<class_Node_property_process_thread_group>`             | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_thread_group_order<class_Node_property_process_thread_group_order>` |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] | :ref:`process_thread_messages<class_Node_property_process_thread_messages>`       |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`String<class_String>`                                                 | :ref:`scene_file_path<class_Node_property_scene_file_path>`                       |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`bool<class_bool>`                                                     | :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`             | ``false`` |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+

.. rst-class:: classref-reftable-group

Методы
------------

.. table::
   :widths: auto

   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_enter_tree<class_Node_private_method__enter_tree>`\ (\ ) |virtual|                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_exit_tree<class_Node_private_method__exit_tree>`\ (\ ) |virtual|                                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedStringArray<class_PackedStringArray>`                | :ref:`_get_accessibility_configuration_warnings<class_Node_private_method__get_accessibility_configuration_warnings>`\ (\ ) |virtual| |const|                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedStringArray<class_PackedStringArray>`                | :ref:`_get_configuration_warnings<class_Node_private_method__get_configuration_warnings>`\ (\ ) |virtual| |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`RID<class_RID>`                                            | :ref:`_get_focused_accessibility_element<class_Node_private_method__get_focused_accessibility_element>`\ (\ ) |virtual| |const|                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_input<class_Node_private_method__input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_physics_process<class_Node_private_method__physics_process>`\ (\ delta\: :ref:`float<class_float>`\ ) |virtual|                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_process<class_Node_private_method__process>`\ (\ delta\: :ref:`float<class_float>`\ ) |virtual|                                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_ready<class_Node_private_method__ready>`\ (\ ) |virtual|                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_shortcut_input<class_Node_private_method__shortcut_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                          |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_unhandled_input<class_Node_private_method__unhandled_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_unhandled_key_input<class_Node_private_method__unhandled_key_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_child<class_Node_method_add_child>`\ (\ node\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false, internal\: :ref:`InternalMode<enum_Node_InternalMode>` = 0\ )                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_sibling<class_Node_method_add_sibling>`\ (\ sibling\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false\ )                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_to_group<class_Node_method_add_to_group>`\ (\ group\: :ref:`StringName<class_StringName>`, persistent\: :ref:`bool<class_bool>` = false\ )                                                                                    |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`atr<class_Node_method_atr>`\ (\ message\: :ref:`String<class_String>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const|                                                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`atr_n<class_Node_method_atr_n>`\ (\ message\: :ref:`String<class_String>`, plural_message\: :ref:`StringName<class_StringName>`, n\: :ref:`int<class_int>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const|         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`call_deferred_thread_group<class_Node_method_call_deferred_thread_group>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`call_thread_safe<class_Node_method_call_thread_safe>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`can_auto_translate<class_Node_method_can_auto_translate>`\ (\ ) |const|                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`can_process<class_Node_method_can_process>`\ (\ ) |const|                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Tween<class_Tween>`                                        | :ref:`create_tween<class_Node_method_create_tween>`\ (\ )                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`duplicate<class_Node_method_duplicate>`\ (\ flags\: :ref:`int<class_int>` = 15\ ) |const|                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`find_child<class_Node_method_find_child>`\ (\ pattern\: :ref:`String<class_String>`, recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const|                                                |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\]             | :ref:`find_children<class_Node_method_find_children>`\ (\ pattern\: :ref:`String<class_String>`, type\: :ref:`String<class_String>` = "", recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`find_parent<class_Node_method_find_parent>`\ (\ pattern\: :ref:`String<class_String>`\ ) |const|                                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`RID<class_RID>`                                            | :ref:`get_accessibility_element<class_Node_method_get_accessibility_element>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_child<class_Node_method_get_child>`\ (\ idx\: :ref:`int<class_int>`, include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_child_count<class_Node_method_get_child_count>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\]             | :ref:`get_children<class_Node_method_get_children>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`StringName<class_StringName>`\] | :ref:`get_groups<class_Node_method_get_groups>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_index<class_Node_method_get_index>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Window<class_Window>`                                      | :ref:`get_last_exclusive_window<class_Node_method_get_last_exclusive_window>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_multiplayer_authority<class_Node_method_get_multiplayer_authority>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_node<class_Node_method_get_node>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`                                        | :ref:`get_node_and_resource<class_Node_method_get_node_and_resource>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ )                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_node_or_null<class_Node_method_get_node_or_null>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`get_node_rpc_config<class_Node_method_get_node_rpc_config>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`int<class_int>`\]               | :ref:`get_orphan_node_ids<class_Node_method_get_orphan_node_ids>`\ (\ ) |static|                                                                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_parent<class_Node_method_get_parent>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`NodePath<class_NodePath>`                                  | :ref:`get_path<class_Node_method_get_path>`\ (\ ) |const|                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`NodePath<class_NodePath>`                                  | :ref:`get_path_to<class_Node_method_get_path_to>`\ (\ node\: :ref:`Node<class_Node>`, use_unique_path\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`float<class_float>`                                        | :ref:`get_physics_process_delta_time<class_Node_method_get_physics_process_delta_time>`\ (\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`float<class_float>`                                        | :ref:`get_process_delta_time<class_Node_method_get_process_delta_time>`\ (\ ) |const|                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`get_scene_instance_load_placeholder<class_Node_method_get_scene_instance_load_placeholder>`\ (\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`SceneTree<class_SceneTree>`                                | :ref:`get_tree<class_Node_method_get_tree>`\ (\ ) |const|                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`get_tree_string<class_Node_method_get_tree_string>`\ (\ )                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`get_tree_string_pretty<class_Node_method_get_tree_string_pretty>`\ (\ )                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Viewport<class_Viewport>`                                  | :ref:`get_viewport<class_Node_method_get_viewport>`\ (\ ) |const|                                                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Window<class_Window>`                                      | :ref:`get_window<class_Node_method_get_window>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`has_node<class_Node_method_has_node>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`has_node_and_resource<class_Node_method_has_node_and_resource>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_ancestor_of<class_Node_method_is_ancestor_of>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_displayed_folded<class_Node_method_is_displayed_folded>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_editable_instance<class_Node_method_is_editable_instance>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_greater_than<class_Node_method_is_greater_than>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_in_group<class_Node_method_is_in_group>`\ (\ group\: :ref:`StringName<class_StringName>`\ ) |const|                                                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_inside_tree<class_Node_method_is_inside_tree>`\ (\ ) |const|                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_multiplayer_authority<class_Node_method_is_multiplayer_authority>`\ (\ ) |const|                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_node_ready<class_Node_method_is_node_ready>`\ (\ ) |const|                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_part_of_edited_scene<class_Node_method_is_part_of_edited_scene>`\ (\ ) |const|                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_interpolated<class_Node_method_is_physics_interpolated>`\ (\ ) |const|                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_interpolated_and_enabled<class_Node_method_is_physics_interpolated_and_enabled>`\ (\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_processing<class_Node_method_is_physics_processing>`\ (\ ) |const|                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_processing_internal<class_Node_method_is_physics_processing_internal>`\ (\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing<class_Node_method_is_processing>`\ (\ ) |const|                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_input<class_Node_method_is_processing_input>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_internal<class_Node_method_is_processing_internal>`\ (\ ) |const|                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_shortcut_input<class_Node_method_is_processing_shortcut_input>`\ (\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_unhandled_input<class_Node_method_is_processing_unhandled_input>`\ (\ ) |const|                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_unhandled_key_input<class_Node_method_is_processing_unhandled_key_input>`\ (\ ) |const|                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`move_child<class_Node_method_move_child>`\ (\ child_node\: :ref:`Node<class_Node>`, to_index\: :ref:`int<class_int>`\ )                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`notify_deferred_thread_group<class_Node_method_notify_deferred_thread_group>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`notify_thread_safe<class_Node_method_notify_thread_safe>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_orphan_nodes<class_Node_method_print_orphan_nodes>`\ (\ ) |static|                                                                                                                                                          |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_tree<class_Node_method_print_tree>`\ (\ )                                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_tree_pretty<class_Node_method_print_tree_pretty>`\ (\ )                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`propagate_call<class_Node_method_propagate_call>`\ (\ method\: :ref:`StringName<class_StringName>`, args\: :ref:`Array<class_Array>` = [], parent_first\: :ref:`bool<class_bool>` = false\ )                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`propagate_notification<class_Node_method_propagate_notification>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`queue_accessibility_update<class_Node_method_queue_accessibility_update>`\ (\ )                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`queue_free<class_Node_method_queue_free>`\ (\ )                                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`remove_child<class_Node_method_remove_child>`\ (\ node\: :ref:`Node<class_Node>`\ )                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`remove_from_group<class_Node_method_remove_from_group>`\ (\ group\: :ref:`StringName<class_StringName>`\ )                                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`reparent<class_Node_method_reparent>`\ (\ new_parent\: :ref:`Node<class_Node>`, keep_global_transform\: :ref:`bool<class_bool>` = true\ )                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`replace_by<class_Node_method_replace_by>`\ (\ node\: :ref:`Node<class_Node>`, keep_groups\: :ref:`bool<class_bool>` = false\ )                                                                                                    |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`request_ready<class_Node_method_request_ready>`\ (\ )                                                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`\ (\ )                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`                            | :ref:`rpc<class_Node_method_rpc>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`rpc_config<class_Node_method_rpc_config>`\ (\ method\: :ref:`StringName<class_StringName>`, config\: :ref:`Variant<class_Variant>`\ )                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`                            | :ref:`rpc_id<class_Node_method_rpc_id>`\ (\ peer_id\: :ref:`int<class_int>`, method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_deferred_thread_group<class_Node_method_set_deferred_thread_group>`\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ )                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_display_folded<class_Node_method_set_display_folded>`\ (\ fold\: :ref:`bool<class_bool>`\ )                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_editable_instance<class_Node_method_set_editable_instance>`\ (\ node\: :ref:`Node<class_Node>`, is_editable\: :ref:`bool<class_bool>`\ )                                                                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_multiplayer_authority<class_Node_method_set_multiplayer_authority>`\ (\ id\: :ref:`int<class_int>`, recursive\: :ref:`bool<class_bool>` = true\ )                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_physics_process<class_Node_method_set_physics_process>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_physics_process_internal<class_Node_method_set_physics_process_internal>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process<class_Node_method_set_process>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_input<class_Node_method_set_process_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_internal<class_Node_method_set_process_internal>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_shortcut_input<class_Node_method_set_process_shortcut_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_unhandled_input<class_Node_method_set_process_unhandled_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_unhandled_key_input<class_Node_method_set_process_unhandled_key_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_scene_instance_load_placeholder<class_Node_method_set_scene_instance_load_placeholder>`\ (\ load_placeholder\: :ref:`bool<class_bool>`\ )                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_thread_safe<class_Node_method_set_thread_safe>`\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ )                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_translation_domain_inherited<class_Node_method_set_translation_domain_inherited>`\ (\ )                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`update_configuration_warnings<class_Node_method_update_configuration_warnings>`\ (\ )                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Сигналы
--------------

.. _class_Node_signal_child_entered_tree:

.. rst-class:: classref-signal

**child_entered_tree**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_child_entered_tree>`

Выдается, когда дочерний ``node`` входит в :ref:`SceneTree<class_SceneTree>`, обычно потому, что этот узел вошел в дерево (см. :ref:`tree_entered<class_Node_signal_tree_entered>`) или был вызван :ref:`add_child()<class_Node_method_add_child>`.

Этот сигнал выдается *после* собственных :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` и :ref:`tree_entered<class_Node_signal_tree_entered>` дочернего узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_child_exiting_tree:

.. rst-class:: classref-signal

**child_exiting_tree**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_child_exiting_tree>`

Выдается, когда дочерний ``node`` собирается выйти из :ref:`SceneTree<class_SceneTree>`, обычно потому что этот узел выходит из дерева (см. :ref:`tree_exiting<class_Node_signal_tree_exiting>`) или потому что дочерний ``node`` удаляется или освобождается.

Когда этот сигнал получен, дочерний ``node`` все еще доступен внутри дерева. Этот сигнал выдается *после* собственного :ref:`tree_exiting<class_Node_signal_tree_exiting>` и :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>` дочернего узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_child_order_changed:

.. rst-class:: classref-signal

**child_order_changed**\ (\ ) :ref:`🔗<class_Node_signal_child_order_changed>`

Выдается при изменении списка дочерних узлов. Это происходит при добавлении, перемещении или удалении дочерних узлов.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_editor_description_changed:

.. rst-class:: classref-signal

**editor_description_changed**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_editor_description_changed>`

Генерируется при изменении поля описания узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_editor_state_changed:

.. rst-class:: classref-signal

**editor_state_changed**\ (\ ) :ref:`🔗<class_Node_signal_editor_state_changed>`

Выдается при изменении атрибута узла, который имеет отношение к редактору. Выдается только в редакторе.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_ready:

.. rst-class:: classref-signal

**ready**\ (\ ) :ref:`🔗<class_Node_signal_ready>`

Вызывается, когда узел считается готовым, после вызова :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_renamed:

.. rst-class:: classref-signal

**renamed**\ (\ ) :ref:`🔗<class_Node_signal_renamed>`

Выдается при изменении :ref:`name<class_Node_property_name>` узла, если узел находится внутри дерева.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_replacing_by:

.. rst-class:: classref-signal

**replacing_by**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_replacing_by>`

Выдается, когда этот узел заменяется на ``node``, см. :ref:`replace_by()<class_Node_method_replace_by>`.

Этот сигнал выдается *после* добавления ``node`` в качестве дочернего элемента исходного родительского узла, но *до* того, как все исходные дочерние узлы были переименованы в ``node``.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_entered:

.. rst-class:: classref-signal

**tree_entered**\ (\ ) :ref:`🔗<class_Node_signal_tree_entered>`

Выдается, когда узел входит в дерево.

Этот сигнал выдается *после* связанного :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` уведомления.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_exited:

.. rst-class:: classref-signal

**tree_exited**\ (\ ) :ref:`🔗<class_Node_signal_tree_exited>`

Выдается после того, как узел выходит из дерева и больше не активен.

Этот сигнал выдается *после* связанного :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>` уведомления.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_exiting:

.. rst-class:: classref-signal

**tree_exiting**\ (\ ) :ref:`🔗<class_Node_signal_tree_exiting>`

Выдается, когда узел вот-вот выйдет из дерева. Узел все еще действителен. Таким образом, это правильное место для деинициализации (или «деструктора», если хотите).

Этот сигнал выдается *после* :ref:`_exit_tree()<class_Node_private_method__exit_tree>` узла и *до* связанной :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>`.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Перечисления
------------------------

.. _enum_Node_ProcessMode:

.. rst-class:: classref-enumeration

enum **ProcessMode**: :ref:`🔗<enum_Node_ProcessMode>`

.. _class_Node_constant_PROCESS_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_INHERIT** = ``0``

Наследует :ref:`process_mode<class_Node_property_process_mode>` от родителя узла. Это значение по умолчанию для любого вновь созданного узла.

.. _class_Node_constant_PROCESS_MODE_PAUSABLE:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_PAUSABLE** = ``1``

Останавливает обработку, когда :ref:`SceneTree.paused<class_SceneTree_property_paused>` равен ``true``. Это обратная :ref:`PROCESS_MODE_WHEN_PAUSED<class_Node_constant_PROCESS_MODE_WHEN_PAUSED>` операция и значение по умолчанию для корневого узла.

.. _class_Node_constant_PROCESS_MODE_WHEN_PAUSED:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_WHEN_PAUSED** = ``2``

Обрабатывать **только**, когда :ref:`SceneTree.paused<class_SceneTree_property_paused>` равен ``true``. Это обратная :ref:`PROCESS_MODE_PAUSABLE<class_Node_constant_PROCESS_MODE_PAUSABLE>`.

.. _class_Node_constant_PROCESS_MODE_ALWAYS:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_ALWAYS** = ``3``

Всегда обрабатывать. Продолжает обработку, игнорируя :ref:`SceneTree.paused<class_SceneTree_property_paused>`. Это обратная :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_PROCESS_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_DISABLED** = ``4``

Никогда не обрабатывать. Полностью отключает обработку, игнорируя :ref:`SceneTree.paused<class_SceneTree_property_paused>`. Это обратная сторона :ref:`PROCESS_MODE_ALWAYS<class_Node_constant_PROCESS_MODE_ALWAYS>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_ProcessThreadGroup:

.. rst-class:: classref-enumeration

enum **ProcessThreadGroup**: :ref:`🔗<enum_Node_ProcessThreadGroup>`

.. _class_Node_constant_PROCESS_THREAD_GROUP_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_INHERIT** = ``0``

Обработать этот узел на основе режима группы потоков первого родительского (или прародительского) узла, который имеет режим группы потоков, который не наследуется. Для получения дополнительной информации см. :ref:`process_thread_group<class_Node_property_process_thread_group>`.

.. _class_Node_constant_PROCESS_THREAD_GROUP_MAIN_THREAD:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_MAIN_THREAD** = ``1``

Обработать этот узел (и дочерние узлы, настроенные на наследование) в основном потоке. См. :ref:`process_thread_group<class_Node_property_process_thread_group>` для получения дополнительной информации.

.. _class_Node_constant_PROCESS_THREAD_GROUP_SUB_THREAD:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_SUB_THREAD** = ``2``

Обработать этот узел (и дочерние узлы, настроенные на наследование) в подпотоке. Для получения дополнительной информации см. :ref:`process_thread_group<class_Node_property_process_thread_group>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_ProcessThreadMessages:

.. rst-class:: classref-enumeration

flags **ProcessThreadMessages**: :ref:`🔗<enum_Node_ProcessThreadMessages>`

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES** = ``1``

Позволяет этому узлу обрабатывать потоковые сообщения, созданные с помощью :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` непосредственно перед вызовом :ref:`_process()<class_Node_private_method__process>`.

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES_PHYSICS:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES_PHYSICS** = ``2``

Позволяет этому узлу обрабатывать потоковые сообщения, созданные с помощью :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` непосредственно перед вызовом :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES_ALL:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES_ALL** = ``3``

Позволяет этому узлу обрабатывать потоковые сообщения, созданные с помощью :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` непосредственно перед вызовом :ref:`_process()<class_Node_private_method__process>` или :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_PhysicsInterpolationMode:

.. rst-class:: classref-enumeration

enum **PhysicsInterpolationMode**: :ref:`🔗<enum_Node_PhysicsInterpolationMode>`

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_INHERIT** = ``0``

Наследует :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` от родителя узла. Это значение по умолчанию для любого вновь созданного узла.

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_ON:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_ON** = ``1``

Включает интерполяцию физики для этого узла и для дочерних элементов, заданных как :ref:`PHYSICS_INTERPOLATION_MODE_INHERIT<class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT>`. Это значение по умолчанию для корневого узла.

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_OFF:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_OFF** = ``2``

Отключает интерполяцию физики для этого узла и для дочерних элементов, для которых задано значение :ref:`PHYSICS_INTERPOLATION_MODE_INHERIT<class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_DuplicateFlags:

.. rst-class:: classref-enumeration

enum **DuplicateFlags**: :ref:`🔗<enum_Node_DuplicateFlags>`

.. _class_Node_constant_DUPLICATE_SIGNALS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_SIGNALS** = ``1``

Дублируйте сигнальные соединения узла, которые связаны с флагом :ref:`Object.CONNECT_PERSIST<class_Object_constant_CONNECT_PERSIST>`.

.. _class_Node_constant_DUPLICATE_GROUPS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_GROUPS** = ``2``

Дублируйте группы узлов.

.. _class_Node_constant_DUPLICATE_SCRIPTS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_SCRIPTS** = ``4``

Дублировать скрипт узла (также переопределяя дублированные дочерние скрипты, если это объединено с :ref:`DUPLICATE_USE_INSTANTIATION<class_Node_constant_DUPLICATE_USE_INSTANTIATION>`).

.. _class_Node_constant_DUPLICATE_USE_INSTANTIATION:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_USE_INSTANTIATION** = ``8``

Дублировать с помощью :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>`. Если узел взят из сцены, сохраненной на диске, повторно использует :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>` в качестве основы для дублированного узла и его дочерних элементов.

.. rst-class:: classref-item-separator

----

.. _enum_Node_InternalMode:

.. rst-class:: classref-enumeration

enum **InternalMode**: :ref:`🔗<enum_Node_InternalMode>`

.. _class_Node_constant_INTERNAL_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_DISABLED** = ``0``

Узел не будет внутренним.

.. _class_Node_constant_INTERNAL_MODE_FRONT:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_FRONT** = ``1``

Узел будет помещен в начало дочерних узлов родителя, перед любым невнутренним узлом-братьем.

.. _class_Node_constant_INTERNAL_MODE_BACK:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_BACK** = ``2``

Узел будет помещен в конец дочерних узлов родителя, после любого невнутреннего родственного узла.

.. rst-class:: classref-item-separator

----

.. _enum_Node_AutoTranslateMode:

.. rst-class:: classref-enumeration

enum **AutoTranslateMode**: :ref:`🔗<enum_Node_AutoTranslateMode>`

.. _class_Node_constant_AUTO_TRANSLATE_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_INHERIT** = ``0``

Наследует :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>` от родителя узла. Это значение по умолчанию для любого вновь созданного узла.

.. _class_Node_constant_AUTO_TRANSLATE_MODE_ALWAYS:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_ALWAYS** = ``1``

Всегда автоматически переводить. Это обратная :ref:`AUTO_TRANSLATE_MODE_DISABLED<class_Node_constant_AUTO_TRANSLATE_MODE_DISABLED>` и значение по умолчанию для корневого узла.

.. _class_Node_constant_AUTO_TRANSLATE_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_DISABLED** = ``2``

Никогда не переводить автоматически. Это обратная :ref:`AUTO_TRANSLATE_MODE_ALWAYS<class_Node_constant_AUTO_TRANSLATE_MODE_ALWAYS>`.

Анализ строки для генерации POT будет пропущен для этого узла и дочерних элементов, для которых задано :ref:`AUTO_TRANSLATE_MODE_INHERIT<class_Node_constant_AUTO_TRANSLATE_MODE_INHERIT>`.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Константы
------------------

.. _class_Node_constant_NOTIFICATION_ENTER_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_ENTER_TREE** = ``10`` :ref:`🔗<class_Node_constant_NOTIFICATION_ENTER_TREE>`

Уведомление получено, когда узел входит в :ref:`SceneTree<class_SceneTree>`. См. :ref:`_enter_tree()<class_Node_private_method__enter_tree>`.

Это уведомление получено *до* связанного сигнала :ref:`tree_entered<class_Node_signal_tree_entered>`.

.. _class_Node_constant_NOTIFICATION_EXIT_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_EXIT_TREE** = ``11`` :ref:`🔗<class_Node_constant_NOTIFICATION_EXIT_TREE>`

Уведомление получено, когда узел собирается выйти из :ref:`SceneTree<class_SceneTree>`. См. :ref:`_exit_tree()<class_Node_private_method__exit_tree>`.

Это уведомление получено *после* связанного сигнала :ref:`tree_exiting<class_Node_signal_tree_exiting>`.

.. _class_Node_constant_NOTIFICATION_MOVED_IN_PARENT:

.. rst-class:: classref-constant

**NOTIFICATION_MOVED_IN_PARENT** = ``12`` :ref:`🔗<class_Node_constant_NOTIFICATION_MOVED_IN_PARENT>`

**Устарело:** This notification is no longer sent by the engine. Use :ref:`NOTIFICATION_CHILD_ORDER_CHANGED<class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED>` instead.



.. _class_Node_constant_NOTIFICATION_READY:

.. rst-class:: classref-constant

**NOTIFICATION_READY** = ``13`` :ref:`🔗<class_Node_constant_NOTIFICATION_READY>`

Уведомление получено, когда узел готов. См. :ref:`_ready()<class_Node_private_method__ready>`.

.. _class_Node_constant_NOTIFICATION_PAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_PAUSED** = ``14`` :ref:`🔗<class_Node_constant_NOTIFICATION_PAUSED>`

Уведомление получено, когда узел приостановлен. См. :ref:`process_mode<class_Node_property_process_mode>`.

.. _class_Node_constant_NOTIFICATION_UNPAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_UNPAUSED** = ``15`` :ref:`🔗<class_Node_constant_NOTIFICATION_UNPAUSED>`

Уведомление получено, когда узел снят с паузы. См. :ref:`process_mode<class_Node_property_process_mode>`.

.. _class_Node_constant_NOTIFICATION_PHYSICS_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_PHYSICS_PROCESS** = ``16`` :ref:`🔗<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`

Уведомление, полученное от дерева в каждом кадре физики, когда :ref:`is_physics_processing()<class_Node_method_is_physics_processing>` возвращает ``true``. См. :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. _class_Node_constant_NOTIFICATION_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_PROCESS** = ``17`` :ref:`🔗<class_Node_constant_NOTIFICATION_PROCESS>`

Уведомление, полученное от дерева для каждого отрисованного кадра, когда :ref:`is_processing()<class_Node_method_is_processing>` возвращает ``true``. См. :ref:`_process()<class_Node_private_method__process>`.

.. _class_Node_constant_NOTIFICATION_PARENTED:

.. rst-class:: classref-constant

**NOTIFICATION_PARENTED** = ``18`` :ref:`🔗<class_Node_constant_NOTIFICATION_PARENTED>`

Уведомление получено, когда узел установлен как дочерний для другого узла (см. :ref:`add_child()<class_Node_method_add_child>` и :ref:`add_sibling()<class_Node_method_add_sibling>`).

\ **Примечание:** Это *не* означает, что узел вошел в :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_UNPARENTED:

.. rst-class:: classref-constant

**NOTIFICATION_UNPARENTED** = ``19`` :ref:`🔗<class_Node_constant_NOTIFICATION_UNPARENTED>`

Уведомление получено, когда родительский узел вызывает :ref:`remove_child()<class_Node_method_remove_child>` на этом узле.

\ **Примечание:** Это *не* означает, что узел вышел из :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_SCENE_INSTANTIATED:

.. rst-class:: classref-constant

**NOTIFICATION_SCENE_INSTANTIATED** = ``20`` :ref:`🔗<class_Node_constant_NOTIFICATION_SCENE_INSTANTIATED>`

Уведомление получено *только* вновь созданным корневым узлом сцены, когда :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>` завершен.

.. _class_Node_constant_NOTIFICATION_DRAG_BEGIN:

.. rst-class:: classref-constant

**NOTIFICATION_DRAG_BEGIN** = ``21`` :ref:`🔗<class_Node_constant_NOTIFICATION_DRAG_BEGIN>`

Уведомление получено, когда начинается операция перетаскивания. Все узлы получают это уведомление, а не только перетаскиваемый.

Может быть вызвано либо перетаскиванием :ref:`Control<class_Control>`, который предоставляет данные перетаскивания (см. :ref:`Control._get_drag_data()<class_Control_private_method__get_drag_data>`), либо использованием :ref:`Control.force_drag()<class_Control_method_force_drag>`.

Используйте :ref:`Viewport.gui_get_drag_data()<class_Viewport_method_gui_get_drag_data>` для получения перетаскиваемых данных.

.. _class_Node_constant_NOTIFICATION_DRAG_END:

.. rst-class:: classref-constant

**NOTIFICATION_DRAG_END** = ``22`` :ref:`🔗<class_Node_constant_NOTIFICATION_DRAG_END>`

Получено уведомление, когда операция перетаскивания завершена.

Используйте :ref:`Viewport.gui_is_drag_successful()<class_Viewport_method_gui_is_drag_successful>`, чтобы проверить, успешно ли перетаскивание.

.. _class_Node_constant_NOTIFICATION_PATH_RENAMED:

.. rst-class:: classref-constant

**NOTIFICATION_PATH_RENAMED** = ``23`` :ref:`🔗<class_Node_constant_NOTIFICATION_PATH_RENAMED>`

Уведомление получено, когда :ref:`name<class_Node_property_name>` узла или одного из его предков :ref:`name<class_Node_property_name>` изменено. Это уведомление *не* получено, когда узел удален из :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_CHILD_ORDER_CHANGED** = ``24`` :ref:`🔗<class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED>`

Уведомление получено при изменении списка дочерних узлов. Это происходит при добавлении, перемещении или удалении дочерних узлов.

.. _class_Node_constant_NOTIFICATION_INTERNAL_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_INTERNAL_PROCESS** = ``25`` :ref:`🔗<class_Node_constant_NOTIFICATION_INTERNAL_PROCESS>`

Уведомление, полученное от дерева для каждого отрисованного кадра, когда :ref:`is_processing_internal()<class_Node_method_is_processing_internal>` возвращает ``true``.

.. _class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_INTERNAL_PHYSICS_PROCESS** = ``26`` :ref:`🔗<class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS>`

Уведомление от дерева получено каждый физический кадр, когда :ref:`is_physics_processing_internal()<class_Node_method_is_physics_processing_internal>` возвращает ``true``.

.. _class_Node_constant_NOTIFICATION_POST_ENTER_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_POST_ENTER_TREE** = ``27`` :ref:`🔗<class_Node_constant_NOTIFICATION_POST_ENTER_TREE>`

Уведомление получено, когда узел входит в дерево, непосредственно перед тем, как может быть получено :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>`. В отличие от последнего, оно отправляется каждый раз, когда узел входит в дерево, а не только один раз.

.. _class_Node_constant_NOTIFICATION_DISABLED:

.. rst-class:: classref-constant

**NOTIFICATION_DISABLED** = ``28`` :ref:`🔗<class_Node_constant_NOTIFICATION_DISABLED>`

Уведомление получено, когда узел отключен. См. :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_NOTIFICATION_ENABLED:

.. rst-class:: classref-constant

**NOTIFICATION_ENABLED** = ``29`` :ref:`🔗<class_Node_constant_NOTIFICATION_ENABLED>`

Уведомление получено, когда узел снова включается после отключения. См. :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION:

.. rst-class:: classref-constant

**NOTIFICATION_RESET_PHYSICS_INTERPOLATION** = ``2001`` :ref:`🔗<class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION>`

Уведомление получено при вызове :ref:`reset_physics_interpolation()<class_Node_method_reset_physics_interpolation>` на узле или его предках.

.. _class_Node_constant_NOTIFICATION_EDITOR_PRE_SAVE:

.. rst-class:: classref-constant

**NOTIFICATION_EDITOR_PRE_SAVE** = ``9001`` :ref:`🔗<class_Node_constant_NOTIFICATION_EDITOR_PRE_SAVE>`

Уведомление, полученное непосредственно перед сохранением сцены с узлом в редакторе. Это уведомление отправляется только в редакторе Godot и не будет появляться в экспортированных проектах.

.. _class_Node_constant_NOTIFICATION_EDITOR_POST_SAVE:

.. rst-class:: classref-constant

**NOTIFICATION_EDITOR_POST_SAVE** = ``9002`` :ref:`🔗<class_Node_constant_NOTIFICATION_EDITOR_POST_SAVE>`

Уведомление, полученное сразу после сохранения сцены с узлом в редакторе. Это уведомление отправляется только в редакторе Godot и не будет появляться в экспортированных проектах.

.. _class_Node_constant_NOTIFICATION_WM_MOUSE_ENTER:

.. rst-class:: classref-constant

**NOTIFICATION_WM_MOUSE_ENTER** = ``1002`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_MOUSE_ENTER>`

Уведомление получено, когда мышь попадает в окно.

Реализовано для встроенных окон и на настольных и веб-платформах.

.. _class_Node_constant_NOTIFICATION_WM_MOUSE_EXIT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_MOUSE_EXIT** = ``1003`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_MOUSE_EXIT>`

Уведомление получено, когда мышь покидает окно.

Реализовано для встроенных окон и на настольных и веб-платформах.

.. _class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_IN:

.. rst-class:: classref-constant

**NOTIFICATION_WM_WINDOW_FOCUS_IN** = ``1004`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_IN>`

Уведомление, полученное от ОС, когда фокусируется предок узла :ref:`Window<class_Window>`. Это может быть изменение фокуса между двумя окнами одного и того же экземпляра движка или с рабочего стола ОС или стороннего приложения на окно игры (в этом случае также принимается :ref:`NOTIFICATION_APPLICATION_FOCUS_IN<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN>`).

Узел :ref:`Window<class_Window>` получает это уведомление, когда он фокусируется.

.. _class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_OUT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_WINDOW_FOCUS_OUT** = ``1005`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_OUT>`

Уведомление, полученное от ОС, когда предок узла :ref:`Window<class_Window>` расфокусирован. Это может быть изменение фокуса между двумя окнами одного и того же экземпляра движка или с окна игры на рабочий стол ОС или стороннее приложение (в этом случае также получено :ref:`NOTIFICATION_APPLICATION_FOCUS_OUT<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT>`).

Узел :ref:`Window<class_Window>` получает это уведомление, когда он расфокусирован.

.. _class_Node_constant_NOTIFICATION_WM_CLOSE_REQUEST:

.. rst-class:: classref-constant

**NOTIFICATION_WM_CLOSE_REQUEST** = ``1006`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_CLOSE_REQUEST>`

Уведомление, полученное от ОС при отправке запроса на закрытие (например, закрытие окна кнопкой «Закрыть» или :kbd:`Alt + F4`).

Реализовано на настольных платформах.

.. _class_Node_constant_NOTIFICATION_WM_GO_BACK_REQUEST:

.. rst-class:: classref-constant

**NOTIFICATION_WM_GO_BACK_REQUEST** = ``1007`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_GO_BACK_REQUEST>`

Уведомление, полученное от ОС при отправке запроса на возврат (например, нажатие кнопки «Назад» на Android).

Реализовано только на Android.

.. _class_Node_constant_NOTIFICATION_WM_SIZE_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_WM_SIZE_CHANGED** = ``1008`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_SIZE_CHANGED>`

Уведомление получено при изменении размера окна.

\ **Примечание:** Это уведомление получает только узел :ref:`Window<class_Window>` с измененным размером, и оно не распространяется на дочерние узлы.

.. _class_Node_constant_NOTIFICATION_WM_DPI_CHANGE:

.. rst-class:: classref-constant

**NOTIFICATION_WM_DPI_CHANGE** = ``1009`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_DPI_CHANGE>`

Уведомление от ОС при изменении масштаба точек на дюйм (DPI) экрана. Реализовано только на macOS.

.. _class_Node_constant_NOTIFICATION_VP_MOUSE_ENTER:

.. rst-class:: classref-constant

**NOTIFICATION_VP_MOUSE_ENTER** = ``1010`` :ref:`🔗<class_Node_constant_NOTIFICATION_VP_MOUSE_ENTER>`

Уведомление получено, когда курсор мыши входит в видимую область :ref:`Viewport<class_Viewport>`, которая не перекрыта другими :ref:`Control<class_Control>` или :ref:`Window<class_Window>`, при условии, что его :ref:`Viewport.gui_disable_input<class_Viewport_property_gui_disable_input>` имеет значение ``false`` и независимо от того, находится ли он в данный момент в фокусе или нет.

.. _class_Node_constant_NOTIFICATION_VP_MOUSE_EXIT:

.. rst-class:: classref-constant

**NOTIFICATION_VP_MOUSE_EXIT** = ``1011`` :ref:`🔗<class_Node_constant_NOTIFICATION_VP_MOUSE_EXIT>`

Уведомление получено, когда курсор мыши покидает видимую область :ref:`Viewport<class_Viewport>`, которая не перекрыта другими :ref:`Control<class_Control>` или :ref:`Window<class_Window>`, при условии, что его :ref:`Viewport.gui_disable_input<class_Viewport_property_gui_disable_input>` имеет значение ``false`` и независимо от того, находится ли он в данный момент в фокусе или нет.

.. _class_Node_constant_NOTIFICATION_WM_POSITION_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_WM_POSITION_CHANGED** = ``1012`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_POSITION_CHANGED>`

Полученное уведомление при перемещении окна.

.. _class_Node_constant_NOTIFICATION_OS_MEMORY_WARNING:

.. rst-class:: classref-constant

**NOTIFICATION_OS_MEMORY_WARNING** = ``2009`` :ref:`🔗<class_Node_constant_NOTIFICATION_OS_MEMORY_WARNING>`

Уведомление от ОС, когда приложение превышает выделенную ему память.

Реализовано только на iOS.

.. _class_Node_constant_NOTIFICATION_TRANSLATION_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_TRANSLATION_CHANGED** = ``2010`` :ref:`🔗<class_Node_constant_NOTIFICATION_TRANSLATION_CHANGED>`

Уведомление получено, когда переводы могли измениться. Может быть вызвано изменением пользователем локали, изменением :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>` или когда узел входит в дерево сцены. Может использоваться для реагирования на изменения языка, например, для изменения строк пользовательского интерфейса на лету. Полезно при работе со встроенной поддержкой перевода, например :ref:`Object.tr()<class_Object_method_tr>`.

\ **Примечание:** Это уведомление получено вместе с :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>`, поэтому, если вы создаете сцену, дочерние узлы еще не будут инициализированы. Вы можете использовать его для настройки переводов для этого узла, дочерних узлов, созданных из скрипта, или если вы хотите получить доступ к дочерним узлам, добавленным в редакторе, убедитесь, что узел готов, используя :ref:`is_node_ready()<class_Node_method_is_node_ready>`.

::

    func _notification(what):
        if what == NOTIFICATION_TRANSLATION_CHANGED:
            if not is_node_ready():
                await ready # Дождитесь сигнала готовности.
            $Label.text = atr("%d Bananas") % banana_counter

.. _class_Node_constant_NOTIFICATION_WM_ABOUT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_ABOUT** = ``2011`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_ABOUT>`

Уведомление, полученное от ОС при отправке запроса на информацию «О программе».

Реализовано только на macOS.

.. _class_Node_constant_NOTIFICATION_CRASH:

.. rst-class:: classref-constant

**NOTIFICATION_CRASH** = ``2012`` :ref:`🔗<class_Node_constant_NOTIFICATION_CRASH>`

Уведомление получено от обработчика сбоев Godot, когда движок вот-вот рухнет.

Реализовано на настольных платформах, если обработчик сбоев включен.

.. _class_Node_constant_NOTIFICATION_OS_IME_UPDATE:

.. rst-class:: classref-constant

**NOTIFICATION_OS_IME_UPDATE** = ``2013`` :ref:`🔗<class_Node_constant_NOTIFICATION_OS_IME_UPDATE>`

Уведомление, полученное от ОС при обновлении Input Method Engine (например, изменение положения курсора IME или строки композиции).

Реализовано только на macOS.

.. _class_Node_constant_NOTIFICATION_APPLICATION_RESUMED:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_RESUMED** = ``2014`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_RESUMED>`

Уведомление, полученное от ОС при возобновлении работы приложения.

Специально для платформ Android и iOS.

.. _class_Node_constant_NOTIFICATION_APPLICATION_PAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_PAUSED** = ``2015`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_PAUSED>`

Уведомление, полученное от ОС, когда приложение приостановлено.

Специально для платформ Android и iOS.

\ **Примечание:** В iOS у вас есть всего около 5 секунд, чтобы завершить задачу, запущенную этим сигналом. Если вы превысите это время, iOS завершит приложение вместо того, чтобы приостановить его.

.. _class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_FOCUS_IN** = ``2016`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN>`

Уведомление, полученное от ОС, когда приложение находится в фокусе, т. е. при изменении фокуса с рабочего стола ОС или стороннего приложения на любое открытое окно экземпляра Godot.

Реализовано на настольных и мобильных платформах.

.. _class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_FOCUS_OUT** = ``2017`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT>`

Уведомление, полученное от ОС, когда приложение расфокусировано, т. е. при изменении фокуса с любого открытого окна экземпляра Godot на рабочий стол ОС или стороннее приложение.

Реализовано на настольных и мобильных платформах.

.. _class_Node_constant_NOTIFICATION_TEXT_SERVER_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_TEXT_SERVER_CHANGED** = ``2018`` :ref:`🔗<class_Node_constant_NOTIFICATION_TEXT_SERVER_CHANGED>`

Получено уведомление при изменении :ref:`TextServer<class_TextServer>`.

.. _class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE:

.. rst-class:: classref-constant

**NOTIFICATION_ACCESSIBILITY_UPDATE** = ``3000`` :ref:`🔗<class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE>`

Уведомление получено, когда требуется обновление информации о доступности.

.. _class_Node_constant_NOTIFICATION_ACCESSIBILITY_INVALIDATE:

.. rst-class:: classref-constant

**NOTIFICATION_ACCESSIBILITY_INVALIDATE** = ``3001`` :ref:`🔗<class_Node_constant_NOTIFICATION_ACCESSIBILITY_INVALIDATE>`

Уведомление получено, когда элементы доступности становятся недействительными. Все элементы доступности узла автоматически удаляются после получения этого сообщения, поэтому все существующие ссылки на такие элементы должны быть отброшены.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Описания свойств
--------------------------------

.. _class_Node_property_auto_translate_mode:

.. rst-class:: classref-property

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **auto_translate_mode** = ``0`` :ref:`🔗<class_Node_property_auto_translate_mode>`

.. rst-class:: classref-property-setget

- |void| **set_auto_translate_mode**\ (\ value\: :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>`\ )
- :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **get_auto_translate_mode**\ (\ )

Определяет, должен ли текст автоматически меняться на переведенную версию в зависимости от текущей локали (для таких узлов, как :ref:`Label<class_Label>`, :ref:`RichTextLabel<class_RichTextLabel>`, :ref:`Window<class_Window>` и т. д.). Также решает, должны ли строки узла анализироваться для генерации POT.

\ **Примечание:** Для корневого узла режим автоматического перевода также можно установить через :ref:`ProjectSettings.internationalization/rendering/root_node_auto_translate<class_ProjectSettings_property_internationalization/rendering/root_node_auto_translate>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_editor_description:

.. rst-class:: classref-property

:ref:`String<class_String>` **editor_description** = ``""`` :ref:`🔗<class_Node_property_editor_description>`

.. rst-class:: classref-property-setget

- |void| **set_editor_description**\ (\ value\: :ref:`String<class_String>`\ )
- :ref:`String<class_String>` **get_editor_description**\ (\ )

Необязательное описание узла. Оно будет отображаться как подсказка при наведении курсора на узел в доке сцены редактора.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_multiplayer:

.. rst-class:: classref-property

:ref:`MultiplayerAPI<class_MultiplayerAPI>` **multiplayer** :ref:`🔗<class_Node_property_multiplayer>`

.. rst-class:: classref-property-setget

- :ref:`MultiplayerAPI<class_MultiplayerAPI>` **get_multiplayer**\ (\ )

Экземпляр :ref:`MultiplayerAPI<class_MultiplayerAPI>`, связанный с этим узлом. См. :ref:`SceneTree.get_multiplayer()<class_SceneTree_method_get_multiplayer>`.

\ **Примечание:** Переименование узла или перемещение его в дереве не переместит :ref:`MultiplayerAPI<class_MultiplayerAPI>` на новый путь, вам придется обновить его вручную.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_name:

.. rst-class:: classref-property

:ref:`StringName<class_StringName>` **name** :ref:`🔗<class_Node_property_name>`

.. rst-class:: classref-property-setget

- |void| **set_name**\ (\ value\: :ref:`StringName<class_StringName>`\ )
- :ref:`StringName<class_StringName>` **get_name**\ (\ )

Имя узла. Это имя должно быть уникальным среди сестринских узлов (других дочерних узлов того же родителя). При установке на имя существующего сестринского узла узел автоматически переименовывается.

\ **Примечание:** При изменении имени следующие символы будут заменены подчеркиванием: (``.`` ``:`` ``@`` ``/`` ``"`` ``%``). В частности, символ ``@`` зарезервирован для автоматически сгенерированных имен. См. также :ref:`String.validate_node_name()<class_String_method_validate_node_name>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_owner:

.. rst-class:: classref-property

:ref:`Node<class_Node>` **owner** :ref:`🔗<class_Node_property_owner>`

.. rst-class:: classref-property-setget

- |void| **set_owner**\ (\ value\: :ref:`Node<class_Node>`\ )
- :ref:`Node<class_Node>` **get_owner**\ (\ )

Владелец этого узла. Владелец должен быть предком этого узла. При упаковке узла-владельца в :ref:`PackedScene<class_PackedScene>` все узлы, которыми он владеет, также сохраняются вместе с ним. См. также :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`.

\ **Примечание:** В редакторе узлы, не принадлежащие корневому элементу сцены, обычно не отображаются в доке сцены и **не** сохраняются. Чтобы предотвратить это, не забудьте задать владельца после вызова :ref:`add_child()<class_Node_method_add_child>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_physics_interpolation_mode:

.. rst-class:: classref-property

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **physics_interpolation_mode** = ``0`` :ref:`🔗<class_Node_property_physics_interpolation_mode>`

.. rst-class:: classref-property-setget

- |void| **set_physics_interpolation_mode**\ (\ value\: :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>`\ )
- :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **get_physics_interpolation_mode**\ (\ )

Режим интерполяции физики для данного узла. Действует только в том случае, если :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>` или :ref:`SceneTree.physics_interpolation<class_SceneTree_property_physics_interpolation>` имеет значение ``true``.

По умолчанию узлы наследуют режим интерполяции физики от своего родителя. Это свойство может включать или отключать интерполяцию физики индивидуально для каждого узла, независимо от режима интерполяции физики их родителей.

\ **Примечание:** В некоторых типах узлов, таких как :ref:`VehicleWheel3D<class_VehicleWheel3D>`, интерполяция физики отключена по умолчанию, поскольку они используют собственное решение.

\ **Примечание:** При телепортации узла в удалённое положение рекомендуется временно отключить интерполяцию с помощью :ref:`reset_physics_interpolation()<class_Node_method_reset_physics_interpolation>` *после* перемещения узла. Это позволит избежать визуального перехода между старым и новым положением.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_mode:

.. rst-class:: classref-property

:ref:`ProcessMode<enum_Node_ProcessMode>` **process_mode** = ``0`` :ref:`🔗<class_Node_property_process_mode>`

.. rst-class:: classref-property-setget

- |void| **set_process_mode**\ (\ value\: :ref:`ProcessMode<enum_Node_ProcessMode>`\ )
- :ref:`ProcessMode<enum_Node_ProcessMode>` **get_process_mode**\ (\ )

Поведение обработки узла. Чтобы проверить, может ли узел обрабатывать в текущем режиме, используйте :ref:`can_process()<class_Node_method_can_process>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_physics_priority:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_physics_priority** = ``0`` :ref:`🔗<class_Node_property_process_physics_priority>`

.. rst-class:: classref-property-setget

- |void| **set_physics_process_priority**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_physics_process_priority**\ (\ )

Аналогично :ref:`process_priority<class_Node_property_process_priority>`, но для :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_physics_process()<class_Node_private_method__physics_process>` или :ref:`NOTIFICATION_INTERNAL_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_priority:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_priority** = ``0`` :ref:`🔗<class_Node_property_process_priority>`

.. rst-class:: classref-property-setget

- |void| **set_process_priority**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_process_priority**\ (\ )

Порядок выполнения обратных вызовов процесса узла (:ref:`_process()<class_Node_private_method__process>`, :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` и :ref:`NOTIFICATION_INTERNAL_PROCESS<class_Node_constant_NOTIFICATION_INTERNAL_PROCESS>`). Узлы, приоритет которых *ниже*, вызывают обратные вызовы своего процесса в первую очередь, независимо от порядка дерева.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_group:

.. rst-class:: classref-property

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **process_thread_group** = ``0`` :ref:`🔗<class_Node_property_process_thread_group>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_group**\ (\ value\: :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>`\ )
- :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **get_process_thread_group**\ (\ )

Установите группу потоков процесса для этого узла (в основном, получает ли он :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`, :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_process()<class_Node_private_method__process>` или :ref:`_physics_process()<class_Node_private_method__physics_process>` (и внутренние версии) в основном потоке или в подпотоке.

По умолчанию группа потоков — :ref:`PROCESS_THREAD_GROUP_INHERIT<class_Node_constant_PROCESS_THREAD_GROUP_INHERIT>`, что означает, что этот узел принадлежит к той же группе потоков, что и родительский узел. Группы потоков означают, что узлы в определенной группе потоков будут обрабатываться вместе, отдельно от других групп потоков (в зависимости от :ref:`process_thread_group_order<class_Node_property_process_thread_group_order>`). Если установлено значение :ref:`PROCESS_THREAD_GROUP_SUB_THREAD<class_Node_constant_PROCESS_THREAD_GROUP_SUB_THREAD>`, эта группа потоков будет выполняться в подпотоке (не в основном потоке), в противном случае, если установлено значение :ref:`PROCESS_THREAD_GROUP_MAIN_THREAD<class_Node_constant_PROCESS_THREAD_GROUP_MAIN_THREAD>`, она будет обрабатываться в основном потоке. Если есть не родительский или прародительский узел, для которого установлено значение, отличное от inheritage, узел будет принадлежать *группе потоков по умолчанию*. Эта группа по умолчанию будет обрабатываться в главном потоке, а ее порядок группы равен 0.

Во время обработки в подпотоке доступ к большинству функций в узлах за пределами группы потоков запрещен (и это приведет к ошибке в режиме отладки). Используйте :ref:`Object.call_deferred()<class_Object_method_call_deferred>`, :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` и тому подобное для связи из групп потоков с основным потоком (или с другими группами потоков).

Чтобы лучше понять группы потоков процесса, идея заключается в том, что любой узел, установленный на любое другое значение, чем :ref:`PROCESS_THREAD_GROUP_INHERIT<class_Node_constant_PROCESS_THREAD_GROUP_INHERIT>`, включит любые дочерние (и внучатые) узлы, установленные для наследования в его группу потоков процесса. Это означает, что обработка всех узлов в группе будет происходить вместе, в то же время, когда узел включает их.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_group_order:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_thread_group_order** :ref:`🔗<class_Node_property_process_thread_group_order>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_group_order**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_process_thread_group_order**\ (\ )

Измените порядок групп потоков процесса. Группы с меньшим порядком будут обрабатываться до групп с большим порядком. Это полезно, когда большое количество узлов обрабатывается в подпотоке, а затем другая группа хочет собрать свой результат в главном потоке, например.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_messages:

.. rst-class:: classref-property

|bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] **process_thread_messages** :ref:`🔗<class_Node_property_process_thread_messages>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_messages**\ (\ value\: |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\]\ )
- |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] **get_process_thread_messages**\ (\ )

Установите, будет ли текущая группа потоков обрабатывать сообщения (вызовы :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` в потоках), и хочет ли она получать их во время обычных процессов или обратных вызовов физических процессов.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_scene_file_path:

.. rst-class:: classref-property

:ref:`String<class_String>` **scene_file_path** :ref:`🔗<class_Node_property_scene_file_path>`

.. rst-class:: classref-property-setget

- |void| **set_scene_file_path**\ (\ value\: :ref:`String<class_String>`\ )
- :ref:`String<class_String>` **get_scene_file_path**\ (\ )

Путь к файлу исходной сцены, если узел был создан из файла :ref:`PackedScene<class_PackedScene>`. Только корневые узлы сцены содержат это.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_unique_name_in_owner:

.. rst-class:: classref-property

:ref:`bool<class_bool>` **unique_name_in_owner** = ``false`` :ref:`🔗<class_Node_property_unique_name_in_owner>`

.. rst-class:: classref-property-setget

- |void| **set_unique_name_in_owner**\ (\ value\: :ref:`bool<class_bool>`\ )
- :ref:`bool<class_bool>` **is_unique_name_in_owner**\ (\ )

Если ``true``, к узлу можно получить доступ из любого узла, имеющего того же :ref:`owner<class_Node_property_owner>`, или из самого :ref:`owner<class_Node_property_owner>`, используя специальный синтаксис ``%Name`` в :ref:`get_node()<class_Node_method_get_node>`.

\ **Примечание:** Если другой узел с тем же :ref:`owner<class_Node_property_owner>` имеет то же :ref:`name<class_Node_property_name>`, что и этот узел, другой узел больше не будет доступен как уникальный.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Описания метода
------------------------------

.. _class_Node_private_method__enter_tree:

.. rst-class:: classref-method

|void| **_enter_tree**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__enter_tree>`

Вызывается, когда узел входит в :ref:`SceneTree<class_SceneTree>` (например, при создании экземпляра, смене сцены или после вызова :ref:`add_child()<class_Node_method_add_child>` в скрипте). Если у узла есть дочерние элементы, его обратный вызов :ref:`_enter_tree()<class_Node_private_method__enter_tree>` будет вызван первым, а затем обратный вызов дочерних элементов.

Соответствует уведомлению :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__exit_tree:

.. rst-class:: classref-method

|void| **_exit_tree**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__exit_tree>`

Вызывается, когда узел собирается покинуть :ref:`SceneTree<class_SceneTree>` (например, при освобождении, смене сцены или после вызова :ref:`remove_child()<class_Node_method_remove_child>` в скрипте). Если у узла есть дочерние элементы, его обратный вызов :ref:`_exit_tree()<class_Node_private_method__exit_tree>` будет вызван последним, после того, как все его дочерние элементы покинут дерево.

Соответствует уведомлению :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>` в :ref:`Object._notification()<class_Object_private_method__notification>` и сигналу :ref:`tree_exiting<class_Node_signal_tree_exiting>`. Чтобы получить уведомление, когда узел уже покинул активное дерево, подключитесь к :ref:`tree_exited<class_Node_signal_tree_exited>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_accessibility_configuration_warnings:

.. rst-class:: classref-method

:ref:`PackedStringArray<class_PackedStringArray>` **_get_accessibility_configuration_warnings**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_accessibility_configuration_warnings>`

Элементы в массиве, возвращаемые этим методом, отображаются как предупреждения в доке сцены, если скрипт, который его переопределяет, является скриптом ``tool``, а предупреждения о доступности включены в настройках редактора.

Возврат пустого массива не приводит к появлению предупреждений.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_configuration_warnings:

.. rst-class:: classref-method

:ref:`PackedStringArray<class_PackedStringArray>` **_get_configuration_warnings**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_configuration_warnings>`

Элементы в массиве, возвращаемые этим методом, отображаются как предупреждения в доке сцены, если скрипт, который его переопределяет, является скриптом ``tool``.

Возврат пустого массива не приводит к появлению предупреждений.

Вызовите :ref:`update_configuration_warnings()<class_Node_method_update_configuration_warnings>`, когда предупреждения необходимо обновить для этого узла.

::

    @export var energy = 0:
        set(value):
            energy = value
            update_configuration_warnings()

    func _get_configuration_warnings():
        if energy < 0:
            return ["Энергия должна быть равна 0 или больше."]
        else:
            return []

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_focused_accessibility_element:

.. rst-class:: classref-method

:ref:`RID<class_RID>` **_get_focused_accessibility_element**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_focused_accessibility_element>`

Вызывается во время обновления информации о доступности для определения текущего сфокусированного подэлемента, должен возвращать RID подэлемента или значение, возвращаемое :ref:`get_accessibility_element()<class_Node_method_get_accessibility_element>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__input:

.. rst-class:: classref-method

|void| **_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__input>`

Вызывается при наличии события ввода. Событие ввода распространяется вверх по дереву узлов, пока узел не потребит его.

Вызывается только в том случае, если включена обработка ввода, что выполняется автоматически, если этот метод переопределен, и может быть переключено с помощью :ref:`set_process_input()<class_Node_method_set_process_input>`.

Чтобы потребить событие ввода и остановить его дальнейшее распространение на другие узлы, можно вызвать :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Для игрового ввода обычно лучше подходят :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` и :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`, поскольку они позволяют графическому интерфейсу сначала перехватывать события.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т. е. если он не является сиротой).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__physics_process:

.. rst-class:: classref-method

|void| **_physics_process**\ (\ delta\: :ref:`float<class_float>`\ ) |virtual| :ref:`🔗<class_Node_private_method__physics_process>`

Вызывается один раз на каждом физическом тике и позволяет узлам синхронизировать свою логику с физическими тиками. ``delta`` — это логическое время между физическими тиками в секундах, равное :ref:`Engine.time_scale<class_Engine_property_time_scale>` / :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>`.

Вызывается только если для данного узла включена обработка физики, что происходит автоматически при переопределении этого метода и может быть переключено с помощью :ref:`set_physics_process()<class_Node_method_set_physics_process>`.

Обработка выполняется в порядке :ref:`process_physics_priority<class_Node_property_process_physics_priority>`, значения с более низким приоритетом вызываются первыми. Узлы с одинаковым приоритетом обрабатываются в порядке дерева, или сверху вниз, как показано в редакторе (также известно как предварительный обход).

Соответствует уведомлению :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. не является сиротой).

\ **Примечание:** Накопленное значение ``delta`` может отличаться от реального значения в секундах.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__process:

.. rst-class:: classref-method

|void| **_process**\ (\ delta\: :ref:`float<class_float>`\ ) |virtual| :ref:`🔗<class_Node_private_method__process>`

Вызывается в каждом кадре бездействия, перед рендерингом и после обработки физических тиков. ``delta`` — это время между кадрами в секундах.

Вызывается только в том случае, если обработка включена для данного узла, что происходит автоматически при переопределении этого метода и может быть переключено с помощью :ref:`set_process()<class_Node_method_set_process>`.

Обработка выполняется в порядке :ref:`process_priority<class_Node_property_process_priority>`, значения с более низким приоритетом вызываются первыми. Узлы с одинаковым приоритетом обрабатываются в порядке дерева, или сверху вниз, как показано в редакторе (также известно как предварительный обход).

Соответствует уведомлению :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т.е. не является «сиротой»).

\ **Примечание:** При возникновении проблем с движком и снижении частоты кадров значение ``delta`` увеличивается. При увеличении ``delta`` он ограничивается максимальным значением :ref:`Engine.time_scale<class_Engine_property_time_scale>` \* :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` / :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>`. В результате накопленное ``delta`` может не отражать реальное время.

\ **Примечание:** Если включен параметр ``--fixed-fps`` или движок работает в режиме Movie Maker (см. :ref:`MovieWriter<class_MovieWriter>`), значение ``delta`` всегда будет одинаковым для каждого кадра, независимо от времени, затраченного на рендеринг кадра.

\ **Примечание:** Дельта кадра может быть обработана с помощью :ref:`OS.delta_smoothing<class_OS_property_delta_smoothing>`, если эта функция включена для проекта.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__ready:

.. rst-class:: classref-method

|void| **_ready**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__ready>`

Вызывается, когда узел «готов», т. е. когда и узел, и его потомки вошли в дерево сцены. Если у узла есть потомки, их обратные вызовы :ref:`_ready()<class_Node_private_method__ready>` срабатывают первыми, а родительский узел получит уведомление о готовности позже.

Соответствует уведомлению :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>` в :ref:`Object._notification()<class_Object_private_method__notification>`. См. также аннотацию ``@onready`` для переменных.

Обычно используется для инициализации. Для еще более ранней инициализации можно использовать :ref:`Object._init()<class_Object_private_method__init>`. См. также :ref:`_enter_tree()<class_Node_private_method__enter_tree>`.

\ **Примечание:** Этот метод может быть вызван только один раз для каждого узла. После удаления узла из дерева сцены и его повторного добавления :ref:`_ready()<class_Node_private_method__ready>` **не** будет вызван во второй раз. Это можно обойти, запросив другой вызов с помощью :ref:`request_ready()<class_Node_method_request_ready>`, который может быть вызван в любом месте перед повторным добавлением узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__shortcut_input:

.. rst-class:: classref-method

|void| **_shortcut_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__shortcut_input>`

Вызывается, когда :ref:`InputEventKey<class_InputEventKey>`, :ref:`InputEventShortcut<class_InputEventShortcut>` или :ref:`InputEventJoypadButton<class_InputEventJoypadButton>` не были использованы :ref:`_input()<class_Node_private_method__input>` или любым элементом GUI :ref:`Control<class_Control>`. Вызывается до :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` и :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`. Событие ввода распространяется вверх по дереву узлов, пока узел не потребит его.

Вызывается только в том случае, если включена обработка сочетаний клавиш, что выполняется автоматически, если этот метод переопределен, и может быть переключено с помощью :ref:`set_process_shortcut_input()<class_Node_method_set_process_shortcut_input>`.

Чтобы использовать событие ввода и остановить его дальнейшее распространение на другие узлы, можно вызвать :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Этот метод можно использовать для обработки сочетаний клавиш. Для общих событий GUI используйте вместо этого :ref:`_input()<class_Node_private_method__input>`. События игрового процесса обычно следует обрабатывать с помощью :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` или :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т. е. если он не является сиротским).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__unhandled_input:

.. rst-class:: classref-method

|void| **_unhandled_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__unhandled_input>`

Вызывается, когда :ref:`InputEvent<class_InputEvent>` не был использован :ref:`_input()<class_Node_private_method__input>` или любым элементом GUI :ref:`Control<class_Control>`. Он вызывается после :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>` и после :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`. Событие ввода распространяется вверх по дереву узлов, пока узел не использует его.

Он вызывается только в том случае, если включена обработка необработанного ввода, что выполняется автоматически, если этот метод переопределен, и может быть переключено с помощью :ref:`set_process_unhandled_input()<class_Node_method_set_process_unhandled_input>`.

Чтобы использовать событие ввода и остановить его дальнейшее распространение на другие узлы, можно вызвать :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Для игрового ввода этот метод обычно подходит лучше, чем :ref:`_input()<class_Node_private_method__input>`, так как событиям GUI требуется более высокий приоритет. Для сочетаний клавиш рассмотрите возможность использования :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>`, так как он вызывается перед этим методом. Наконец, для обработки событий клавиатуры рассмотрите возможность использования :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` из соображений производительности.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т. е. если он не является сиротой).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__unhandled_key_input:

.. rst-class:: classref-method

|void| **_unhandled_key_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__unhandled_key_input>`

Вызывается, когда :ref:`InputEventKey<class_InputEventKey>` не был использован :ref:`_input()<class_Node_private_method__input>` или любым элементом GUI :ref:`Control<class_Control>`. Вызывается после :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>`, но до :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`. Событие ввода распространяется вверх по дереву узлов, пока узел не потребит его.

Вызывается только в том случае, если включена обработка необработанного ввода клавиш, что выполняется автоматически, если этот метод переопределен, и может быть переключено с помощью :ref:`set_process_unhandled_key_input()<class_Node_method_set_process_unhandled_key_input>`.

Чтобы использовать событие ввода и остановить его дальнейшее распространение на другие узлы, можно вызвать :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Этот метод можно использовать для обработки ввода символов Unicode с модификаторами :kbd:`Alt`, :kbd:`Alt + Ctrl` и :kbd:`Alt + Shift` после обработки сочетаний клавиш.

Для игрового ввода этот и :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` обычно подходят лучше, чем :ref:`_input()<class_Node_private_method__input>`, так как события GUI должны обрабатываться в первую очередь. Этот метод также работает лучше, чем :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`, так как несвязанные события, такие как :ref:`InputEventMouseMotion<class_InputEventMouseMotion>`, автоматически фильтруются. Для сочетаний клавиш рассмотрите возможность использования :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>`.

\ **Примечание:** Этот метод вызывается только в том случае, если узел присутствует в дереве сцены (т. е. если он не является сиротой).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_child:

.. rst-class:: classref-method

|void| **add_child**\ (\ node\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false, internal\: :ref:`InternalMode<enum_Node_InternalMode>` = 0\ ) :ref:`🔗<class_Node_method_add_child>`

Добавляет дочерний ``node``. Узлы могут иметь любое количество дочерних узлов, но каждый дочерний узел должен иметь уникальное имя. Дочерние узлы автоматически удаляются при удалении родительского узла, поэтому всю сцену можно удалить, удалив ее самый верхний узел.

Если ``force_readable_name`` равно ``true``, улучшается читаемость добавленного ``node``. Если не указано имя, ``node`` переименовывается в свой тип, и если он разделяет :ref:`name<class_Node_property_name>` с родственным узлом, то добавляется более подходящий суффикс. Эта операция очень медленная. Поэтому рекомендуется оставить это ``false``, что присваивает фиктивное имя с ``@`` в обеих ситуациях.

Если ``internal`` отличается от :ref:`INTERNAL_MODE_DISABLED<class_Node_constant_INTERNAL_MODE_DISABLED>`, дочерний узел будет добавлен как внутренний узел. Эти узлы игнорируются такими методами, как :ref:`get_children()<class_Node_method_get_children>`, если только их параметр ``include_internal`` не равен ``true``. Он также предотвращает дублирование этих узлов с их родителем. Предполагаемое использование — скрыть внутренние узлы от пользователя, чтобы пользователь случайно не удалил или не изменил их. Используется некоторыми узлами GUI, например :ref:`ColorPicker<class_ColorPicker>`.

\ **Примечание:** Если у ``node`` уже есть родитель, этот метод не сработает. Сначала используйте :ref:`remove_child()<class_Node_method_remove_child>`, чтобы удалить ``node`` из его текущего родителя. Например:


.. tabs::

 .. code-tab:: gdscript

    var child_node = get_child(0)
    if child_node.get_parent():
        child_node.get_parent().remove_child(child_node)
    add_child(child_node)

 .. code-tab:: csharp

    Node childNode = GetChild(0);
    if (childNode.GetParent() != null)
    {
        childNode.GetParent().RemoveChild(childNode);
    }
    AddChild(childNode);



Если вам нужно, чтобы дочерний узел был добавлен под определенным узлом в списке дочерних узлов, используйте :ref:`add_sibling()<class_Node_method_add_sibling>` вместо этого метода.

\ **Примечание:** Если вы хотите, чтобы дочерний узел сохранялся в :ref:`PackedScene<class_PackedScene>`, вы должны установить :ref:`owner<class_Node_property_owner>` в дополнение к вызову :ref:`add_child()<class_Node_method_add_child>`. Это обычно актуально для :doc:`скриптов инструментов <../tutorials/plugins/running_code_in_the_editor>` и :doc:`плагинов редактора <../tutorials/plugins/editor/index>`. Если :ref:`add_child()<class_Node_method_add_child>` вызывается без установки :ref:`owner<class_Node_property_owner>`, недавно добавленный **Node** не будет виден в дереве сцены, хотя он будет виден в 2D/3D-виде.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_sibling:

.. rst-class:: classref-method

|void| **add_sibling**\ (\ sibling\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_add_sibling>`

Добавляет узел ``sibling`` к родительскому узлу этого узла и перемещает добавленный сестринский узел прямо под этот узел.

Если ``force_readable_name`` равно ``true``, улучшается читаемость добавленного ``sibling``. Если не указано, ``sibling`` переименовывается в свой тип, и если он разделяет :ref:`name<class_Node_property_name>` с сестринским узлом, то добавляется более подходящий суффикс. Эта операция очень медленная. Поэтому рекомендуется оставить это ``false``, что присваивает фиктивное имя с ``@`` в обеих ситуациях.

Используйте :ref:`add_child()<class_Node_method_add_child>` вместо этого метода, если вам не нужно, чтобы дочерний узел добавлялся под определенный узел в списке дочерних узлов.

\ **Примечание:** Если этот узел является внутренним, добавленный родственный узел также будет внутренним (см. параметр ``internal`` :ref:`add_child()<class_Node_method_add_child>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_to_group:

.. rst-class:: classref-method

|void| **add_to_group**\ (\ group\: :ref:`StringName<class_StringName>`, persistent\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_add_to_group>`

Добавляет узел в ``group``. Группы могут быть полезны для организации подмножества узлов, например ``"enemies"`` или ``"collectables"``. См. примечания в описании и методы групп в :ref:`SceneTree<class_SceneTree>`.

Если ``persistent`` равно ``true``, группа будет сохранена при сохранении внутри :ref:`PackedScene<class_PackedScene>`. Все группы, созданные и отображаемые в доке Node, являются постоянными.

\ **Примечание:** Для повышения производительности порядок имен групп *не* гарантирован и может меняться между запусками проекта. Поэтому не полагайтесь на порядок групп.

\ **Примечание:** Методы групп :ref:`SceneTree<class_SceneTree>` *не* будут работать на этом узле, если он не находится внутри дерева (см. :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_atr:

.. rst-class:: classref-method

:ref:`String<class_String>` **atr**\ (\ message\: :ref:`String<class_String>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const| :ref:`🔗<class_Node_method_atr>`

Переводит ``message``, используя каталоги перевода, настроенные в настройках проекта. Для помощи с переводом можно указать дополнительный ``context``. Обратите внимание, что большинство узлов :ref:`Control<class_Control>` автоматически переводят свои строки, поэтому этот метод в основном полезен для форматированных строк или пользовательского нарисованного текста.

Этот метод работает так же, как :ref:`Object.tr()<class_Object_method_tr>`, с добавлением соблюдения состояния :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`.

Если :ref:`Object.can_translate_messages()<class_Object_method_can_translate_messages>` равен ``false`` или перевод недоступен, этот метод возвращает ``message`` без изменений. См. :ref:`Object.set_message_translation()<class_Object_method_set_message_translation>`.

Подробные примеры см. в :doc:`Интернационализация игр <../tutorials/i18n/internationalizing_games>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_atr_n:

.. rst-class:: classref-method

:ref:`String<class_String>` **atr_n**\ (\ message\: :ref:`String<class_String>`, plural_message\: :ref:`StringName<class_StringName>`, n\: :ref:`int<class_int>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const| :ref:`🔗<class_Node_method_atr_n>`

Переводит ``message`` или ``plural_message``, используя каталоги перевода, настроенные в настройках проекта. Для помощи с переводом можно указать дополнительный ``context``.

Этот метод работает так же, как :ref:`Object.tr_n()<class_Object_method_tr_n>`, с добавлением соблюдения состояния :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`.

Если :ref:`Object.can_translate_messages()<class_Object_method_can_translate_messages>` имеет значение ``false`` или перевод недоступен, этот метод возвращает ``message`` или ``plural_message`` без изменений. См. :ref:`Object.set_message_translation()<class_Object_method_set_message_translation>`.

\ ``n`` — это номер или количество темы сообщения. Он используется системой перевода для получения правильной формы множественного числа для текущего языка.

Подробные примеры см. в :doc:`Локализация с использованием gettext <../tutorials/i18n/localization_using_gettext>`.

\ **Примечание:** Отрицательные и :ref:`float<class_float>` числа могут некорректно применяться к некоторым исчисляемым субъектам. Рекомендуется обрабатывать такие случаи с помощью :ref:`atr()<class_Node_method_atr>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_call_deferred_thread_group:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **call_deferred_thread_group**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_call_deferred_thread_group>`

Эта функция похожа на :ref:`Object.call_deferred()<class_Object_method_call_deferred>`, за исключением того, что вызов будет иметь место, когда обрабатывается группа потоков узла. Если группа потоков узла обрабатывается в подпотоках, то вызов будет сделан в этом потоке, прямо перед вызовом :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` или :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_process()<class_Node_private_method__process>` или :ref:`_physics_process()<class_Node_private_method__physics_process>` или их внутренних версий.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_call_thread_safe:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **call_thread_safe**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_call_thread_safe>`

Эта функция гарантирует, что вызов этой функции будет успешным, независимо от того, выполняется ли он из потока или нет. Если он вызван из потока, которому не разрешено вызывать функцию, вызов станет отложенным. В противном случае вызов будет выполнен напрямую.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_can_auto_translate:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **can_auto_translate**\ (\ ) |const| :ref:`🔗<class_Node_method_can_auto_translate>`

Возвращает ``true``, если этот узел может автоматически переводить сообщения в зависимости от текущей локали. См. :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`, :ref:`atr()<class_Node_method_atr>` и :ref:`atr_n()<class_Node_method_atr_n>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_can_process:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **can_process**\ (\ ) |const| :ref:`🔗<class_Node_method_can_process>`

Возвращает ``true``, если узел может получать уведомления об обработке и обратные вызовы ввода (:ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`, :ref:`_input()<class_Node_private_method__input>` и т. д.) из :ref:`SceneTree<class_SceneTree>` и :ref:`Viewport<class_Viewport>`. Возвращаемое значение зависит от :ref:`process_mode<class_Node_property_process_mode>`:

- Если установлено значение :ref:`PROCESS_MODE_PAUSABLE<class_Node_constant_PROCESS_MODE_PAUSABLE>`, возвращает ``true``, когда игра обрабатывается, т. е. :ref:`SceneTree.paused<class_SceneTree_property_paused>` равно ``false``;

- Если установлено значение :ref:`PROCESS_MODE_WHEN_PAUSED<class_Node_constant_PROCESS_MODE_WHEN_PAUSED>`, возвращает ``true``, когда игра приостановлена, т. е. :ref:`SceneTree.paused<class_SceneTree_property_paused>` равно ``true``;

- Если установлено значение :ref:`PROCESS_MODE_ALWAYS<class_Node_constant_PROCESS_MODE_ALWAYS>`, всегда возвращает ``true``;

- Если установлено значение :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`, всегда возвращает ``false``;

- Если установлено значение :ref:`PROCESS_MODE_INHERIT<class_Node_constant_PROCESS_MODE_INHERIT>`, используйте :ref:`process_mode<class_Node_property_process_mode>` родительского узла для определения результата.

Если узел не находится внутри дерева, возвращает ``false`` независимо от значения :ref:`process_mode<class_Node_property_process_mode>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_create_tween:

.. rst-class:: classref-method

:ref:`Tween<class_Tween>` **create_tween**\ (\ ) :ref:`🔗<class_Node_method_create_tween>`

Создает новый :ref:`Tween<class_Tween>` и привязывает его к этому узлу.

Это эквивалентно выполнению:


.. tabs::

 .. code-tab:: gdscript

    get_tree().create_tween().bind_node(self)

 .. code-tab:: csharp

    GetTree().CreateTween().BindNode(this);



Tween автоматически запустится на следующем кадре процесса или физическом кадре (в зависимости от :ref:`TweenProcessMode<enum_Tween_TweenProcessMode>`). См. :ref:`Tween.bind_node()<class_Tween_method_bind_node>` для получения дополнительной информации о Tween, привязанных к узлам.

\ **Примечание:** Метод все еще можно использовать, когда узел не находится внутри :ref:`SceneTree<class_SceneTree>`. Он может дать сбой в маловероятном случае использования пользовательского :ref:`MainLoop<class_MainLoop>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_duplicate:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **duplicate**\ (\ flags\: :ref:`int<class_int>` = 15\ ) |const| :ref:`🔗<class_Node_method_duplicate>`

Дублирует узел, возвращая новый узел со всеми его свойствами, сигналами, группами и дочерними элементами, скопированными из оригинала. Поведение можно настроить с помощью ``flags`` (см. :ref:`DuplicateFlags<enum_Node_DuplicateFlags>`). Внутренние узлы не дублируются.

\ **Примечание:** Для узлов с присоединенным :ref:`Script<class_Script>`, если :ref:`Object._init()<class_Object_private_method__init>` был определен с требуемыми параметрами, дублированный узел не будет иметь :ref:`Script<class_Script>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_child:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **find_child**\ (\ pattern\: :ref:`String<class_String>`, recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| :ref:`🔗<class_Node_method_find_child>`

Находит первого потомка этого узла, чье :ref:`name<class_Node_property_name>` соответствует ``pattern``, возвращая ``null``, если совпадений не найдено. Сопоставление выполняется с именами узлов, *не* их путями, через :ref:`String.match()<class_String_method_match>`. Таким образом, он чувствителен к регистру, ``"*"`` соответствует нулю или более символов, а ``"?"`` соответствует любому одному символу.

Если ``recursive`` равен ``false``, проверяются только прямые потомки этого узла. Узлы проверяются в порядке дерева, поэтому сначала проверяется первый прямой потомок этого узла, затем его собственные прямые потомки и т. д., прежде чем перейти ко второму прямому потомку и т. д. Внутренние потомки также включаются в поиск (см. параметр ``internal`` в :ref:`add_child()<class_Node_method_add_child>`).

Если ``owned`` равен ``true``, проверяются только потомки с допустимым узлом :ref:`owner<class_Node_property_owner>`.

\ **Примечание:** Этот метод может быть очень медленным. Рассмотрите возможность сохранения ссылки на найденный узел в переменной. В качестве альтернативы используйте :ref:`get_node()<class_Node_method_get_node>` с уникальными именами (см. :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`).

\ **Примечание:** Чтобы найти все узлы-потомки, соответствующие шаблону или типу класса, см. :ref:`find_children()<class_Node_method_find_children>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_children:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\] **find_children**\ (\ pattern\: :ref:`String<class_String>`, type\: :ref:`String<class_String>` = "", recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| :ref:`🔗<class_Node_method_find_children>`

Находит всех потомков этого узла, имена которых соответствуют ``pattern``, возвращая пустой :ref:`Array<class_Array>`, если совпадений не найдено. Сопоставление выполняется по именам узлов, *не* их путям, через :ref:`String.match()<class_String_method_match>`. Таким образом, он чувствителен к регистру, ``"*"`` соответствует нулю или более символов, а ``"?"`` соответствует любому одному символу.

Если ``type`` не пуст, включаются только предки, наследующие от ``type`` (см. :ref:`Object.is_class()<class_Object_method_is_class>`).

Если ``recursive`` равен ``false``, проверяются только прямые потомки этого узла. Узлы проверяются в порядке дерева, поэтому сначала проверяется первый прямой потомок этого узла, затем его собственные прямые потомки и т. д., прежде чем перейти ко второму прямому потомку и т. д. Внутренние потомки также включаются в поиск (см. параметр ``internal`` в :ref:`add_child()<class_Node_method_add_child>`).

Если ``owned`` равен ``true``, проверяются только потомки с допустимым узлом :ref:`owner<class_Node_property_owner>`.

\ **Примечание:** Этот метод может быть очень медленным. Рассмотрите возможность сохранения ссылок на найденные узлы в переменной.

\ **Примечание:** Чтобы найти один узел-потомок, соответствующий шаблону, см. :ref:`find_child()<class_Node_method_find_child>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_parent:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **find_parent**\ (\ pattern\: :ref:`String<class_String>`\ ) |const| :ref:`🔗<class_Node_method_find_parent>`

Находит первого предка этого узла, чье :ref:`name<class_Node_property_name>` соответствует ``pattern``, возвращая ``null``, если совпадений не найдено. Сопоставление выполняется с помощью :ref:`String.match()<class_String_method_match>`. Таким образом, он чувствителен к регистру, ``"*"`` соответствует нулю или более символов, а ``"?"`` соответствует любому отдельному символу. См. также :ref:`find_child()<class_Node_method_find_child>` и :ref:`find_children()<class_Node_method_find_children>`.

\ **Примечание:** Поскольку этот метод идет вверх по дереву сцены, он может быть медленным в больших, глубоко вложенных узлах. Рассмотрите возможность сохранения ссылки на найденный узел в переменной. В качестве альтернативы используйте :ref:`get_node()<class_Node_method_get_node>` с уникальными именами (см. :ref:`unique_name_in_owner()<class_Node_method_unique_name_in_owner>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_accessibility_element:

.. rst-class:: classref-method

:ref:`RID<class_RID>` **get_accessibility_element**\ (\ ) |const| :ref:`🔗<class_Node_method_get_accessibility_element>`

Возвращает основной элемент доступности RID.

\ **Примечание:** Этот метод следует вызывать только во время обновлений информации о доступности (:ref:`NOTIFICATION_ACCESSIBILITY_UPDATE<class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_child:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_child**\ (\ idx\: :ref:`int<class_int>`, include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_child>`

Извлекает дочерний узел по его индексу. Каждый дочерний узел имеет индекс относительно своих братьев и сестер (см. :ref:`get_index()<class_Node_method_get_index>`). Первый дочерний узел имеет индекс 0. Отрицательные значения также могут использоваться для начала с конца списка. Этот метод можно использовать в сочетании с :ref:`get_child_count()<class_Node_method_get_child_count>` для итерации по дочерним узлам этого узла. Если по указанному индексу дочерний узел не существует, этот метод возвращает ``null`` и генерируется ошибка.

Если ``include_internal`` равен ``false``, внутренние дочерние узлы игнорируются (см. параметр :ref:`add_child()<class_Node_method_add_child>` ``internal``).

::

    # Предположим, что следующие элементы являются дочерними элементами этого узла (по порядку):
    # Первый, Средний, Последний.

    var a = get_child(0).name  # a это "Первый"
    var b = get_child(1).name  # b это "Средний"
    var b = get_child(2).name  # b это "Последний"
    var c = get_child(-1).name # c это "Последний"

\ **Примечание:** Чтобы получить узел по :ref:`NodePath<class_NodePath>`, используйте :ref:`get_node()<class_Node_method_get_node>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_child_count:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_child_count**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_child_count>`

Возвращает количество дочерних элементов этого узла.

Если ``include_internal`` равен ``false``, внутренние дочерние элементы не учитываются (см. параметр ``internal`` :ref:`add_child()<class_Node_method_add_child>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_children:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\] **get_children**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_children>`

Возвращает все дочерние элементы этого узла внутри :ref:`Array<class_Array>`.

Если ``include_internal`` равен ``false``, исключает внутренние дочерние элементы из возвращаемого массива (см. параметр ``internal`` :ref:`add_child()<class_Node_method_add_child>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_groups:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`StringName<class_StringName>`\] **get_groups**\ (\ ) |const| :ref:`🔗<class_Node_method_get_groups>`

Возвращает :ref:`Array<class_Array>` имен групп, в которые был добавлен узел.

\ **Примечание:** Для повышения производительности порядок имен групп *не* гарантирован и может меняться между запусками проекта. Поэтому не полагайтесь на порядок групп.

\ **Примечание:** Этот метод также может возвращать некоторые имена групп, начинающиеся с подчеркивания (``_``). Они используются движком внутри. Чтобы избежать конфликтов, не используйте пользовательские группы, начинающиеся с подчеркивания. Чтобы исключить внутренние группы, см. следующий фрагмент кода:


.. tabs::

 .. code-tab:: gdscript

    # Сохраняет только невнутренние группы узла (в виде массива StringNames).
    var non_internal_groups = []
    for group in get_groups():
        if not str(group).begins_with("_"):
            non_internal_groups.push_back(group)

 .. code-tab:: csharp

    // Сохраняет только невнутренние группы узла (в виде массива StringNames).
    List<string> nonInternalGroups = new List<string>();
    foreach (string group in GetGroups())
    {
        if (!group.BeginsWith("_"))
            nonInternalGroups.Add(group);
    }



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_index:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_index**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_index>`

Возвращает порядок этого узла среди его братьев и сестер. Индекс первого узла — ``0``. См. также :ref:`get_child()<class_Node_method_get_child>`.

Если ``include_internal`` — ``false``, возвращает индекс, игнорируя внутренние дочерние элементы. Первый, не внутренний дочерний элемент будет иметь индекс ``0`` (см. параметр :ref:`add_child()<class_Node_method_add_child>` ``internal``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_last_exclusive_window:

.. rst-class:: classref-method

:ref:`Window<class_Window>` **get_last_exclusive_window**\ (\ ) |const| :ref:`🔗<class_Node_method_get_last_exclusive_window>`

Возвращает :ref:`Window<class_Window>`, содержащее этот узел, или последний исключительный дочерний элемент в цепочке окон, начиная с того, которое содержит этот узел.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_multiplayer_authority:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_multiplayer_authority**\ (\ ) |const| :ref:`🔗<class_Node_method_get_multiplayer_authority>`

Возвращает идентификатор пира многопользовательского органа для этого узла. См. :ref:`set_multiplayer_authority()<class_Node_method_set_multiplayer_authority>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_node**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_get_node>`

Извлекает узел. :ref:`NodePath<class_NodePath>` может быть относительным путем (от этого узла) или абсолютным путем (от :ref:`SceneTree.root<class_SceneTree_property_root>`) к узлу. Если ``path`` не указывает на допустимый узел, генерирует ошибку и возвращает ``null``. Попытки доступа к методам возвращаемого значения приведут к ошибке *"Попытка вызвать <method> для пустого экземпляра."*.

\ **Примечание:** Извлечение по абсолютному пути работает только тогда, когда узел находится внутри дерева сцены (см. :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`).

\ **Пример:** Предположим, что этот метод вызывается из узла Character внутри следующего дерева:

.. code:: text

     ┖╴root
        ┠╴Character (Вы здесь!)
        ┃  ┠╴Sword
        ┃  ┖╴Backpack
        ┃     ┖╴Dagger
        ┠╴MyGame
        ┖╴Swamp
           ┠╴Alligator
           ┠╴Mosquito
           ┖╴Goblin

Следующие вызовы вернут действительный узел:


.. tabs::

 .. code-tab:: gdscript

    get_node("Sword")
    get_node("Backpack/Dagger")
    get_node("../Swamp/Alligator")
    get_node("/root/MyGame")

 .. code-tab:: csharp

    GetNode("Sword");
    GetNode("Backpack/Dagger");
    GetNode("../Swamp/Alligator");
    GetNode("/root/MyGame");



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_and_resource:

.. rst-class:: classref-method

:ref:`Array<class_Array>` **get_node_and_resource**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) :ref:`🔗<class_Node_method_get_node_and_resource>`

Извлекает узел и его наиболее вложенный ресурс, указанный в под имени :ref:`NodePath<class_NodePath>`. Возвращает :ref:`Array<class_Array>` размером ``3``, где:

- Элемент ``0`` — это **Node**, или ``null``, если не найден;

- Элемент ``1`` — это последний вложенный в под имени :ref:`Resource<class_Resource>` или ``null``, если не найден;

- Элемент ``2`` — это оставшийся :ref:`NodePath<class_NodePath>`, ссылающийся на существующее свойство, отличное от :ref:`Resource<class_Resource>` (см. :ref:`Object.get_indexed()<class_Object_method_get_indexed>`).

\ **Пример:** Предположим, что дочернему элементу ``Member Sprite2D.texture`` присвоена :ref:`AtlasTexture<class_AtlasTexture>`:


.. tabs::

 .. code-tab:: gdscript

    var a = get_node_and_resource("Area2D/Sprite2D")
    print(a[0].name) # Выводит Sprite2D
    print(a[1])      # Выводит <null>
    print(a[2])      # Выводит ^""

    var b = get_node_and_resource("Area2D/Sprite2D:texture:atlas")
    print(b[0].name)        # Выводит Sprite2D
    print(b[1].get_class()) # Выводит AtlasTexture
    print(b[2])             # Выводит ^""

    var c = get_node_and_resource("Area2D/Sprite2D:texture:atlas:region")
    print(c[0].name)        # Выводит Sprite2D
    print(c[1].get_class()) # Выводит AtlasTexture
    print(c[2])             # Выводит ^":region"

 .. code-tab:: csharp

    var a = GetNodeAndResource(NodePath("Area2D/Sprite2D"));
    GD.Print(a[0].Name); // Выводит Sprite2D
    GD.Print(a[1]);      // Выводит <null>
    GD.Print(a[2]);      // Выводит ^"

    var b = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas"));
    GD.Print(b[0].name);        // Выводит Sprite2D
    GD.Print(b[1].get_class()); // Выводит AtlasTexture
    GD.Print(b[2]);             // Выводит ^""

    var c = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas:region"));
    GD.Print(c[0].name);        // Выводит Sprite2D
    GD.Print(c[1].get_class()); // Выводит AtlasTexture
    GD.Print(c[2]);             // Выводит ^":region"



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_or_null:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_node_or_null**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_get_node_or_null>`

Извлекает узел по :ref:`NodePath<class_NodePath>`. Аналогично :ref:`get_node()<class_Node_method_get_node>`, но не генерирует ошибку, если ``path`` не указывает на допустимый узел.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_rpc_config:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **get_node_rpc_config**\ (\ ) |const| :ref:`🔗<class_Node_method_get_node_rpc_config>`

Возвращает :ref:`Dictionary<class_Dictionary>`, сопоставляющий имена методов с их конфигурацией RPC, определенной для этого узла, с помощью :ref:`rpc_config()<class_Node_method_rpc_config>`.

\ **Примечание:** Этот метод возвращает только конфигурацию RPC, назначенную с помощью :ref:`rpc_config()<class_Node_method_rpc_config>`. См. :ref:`Script.get_rpc_config()<class_Script_method_get_rpc_config>`, чтобы получить RPC, определенным в :ref:`Script<class_Script>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_orphan_node_ids:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`int<class_int>`\] **get_orphan_node_ids**\ (\ ) |static| :ref:`🔗<class_Node_method_get_orphan_node_ids>`

Возвращает ID идентификаторы объектов всех узлов-сирот (узлов вне :ref:`SceneTree<class_SceneTree>`). Используется для отладки.

\ **Примечание:** :ref:`get_orphan_node_ids()<class_Node_method_get_orphan_node_ids>` работает только в отладочных сборках. При вызове в проекте, экспортированном в режиме выпуска, :ref:`get_orphan_node_ids()<class_Node_method_get_orphan_node_ids>` вернет пустой массив.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_parent:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_parent**\ (\ ) |const| :ref:`🔗<class_Node_method_get_parent>`

Возвращает родительский узел данного узла или ``null``, если у узла нет родителя.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_path:

.. rst-class:: classref-method

:ref:`NodePath<class_NodePath>` **get_path**\ (\ ) |const| :ref:`🔗<class_Node_method_get_path>`

Возвращает абсолютный путь узла относительно :ref:`SceneTree.root<class_SceneTree_property_root>`. Если узел не находится внутри дерева сцены, этот метод завершается ошибкой и возвращает пустой :ref:`NodePath<class_NodePath>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_path_to:

.. rst-class:: classref-method

:ref:`NodePath<class_NodePath>` **get_path_to**\ (\ node\: :ref:`Node<class_Node>`, use_unique_path\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_path_to>`

Возвращает относительный :ref:`NodePath<class_NodePath>` от этого узла до указанного ``node``. Оба узла должны находиться в одной и той же :ref:`SceneTree<class_SceneTree>` или иерархии сцены, в противном случае этот метод завершается ошибкой и возвращает пустой :ref:`NodePath<class_NodePath>`.

Если ``use_unique_path`` равен ``true``, возвращает кратчайший путь с учетом уникального имени этого узла (см. :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`).

\ **Примечание:** Если вы получаете относительный путь, который начинается с уникального узла, путь может быть длиннее обычного относительного пути из-за добавления имени уникального узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_physics_process_delta_time:

.. rst-class:: classref-method

:ref:`float<class_float>` **get_physics_process_delta_time**\ (\ ) |const| :ref:`🔗<class_Node_method_get_physics_process_delta_time>`

Возвращает время, прошедшее (в секундах) с момента последнего обратного вызова физики. Это значение идентично параметру ``delta`` :ref:`_physics_process()<class_Node_private_method__physics_process>` и часто является постоянным во время выполнения, если :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` не изменен. См. также :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`.

\ **Примечание:** Возвращаемое значение будет больше ожидаемого, если частота кадров ниже, чем :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` / :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` FPS. Это делается для того, чтобы избежать сценариев «спирали смерти», когда производительность резко падает из-за постоянно растущего числа шагов физики на кадр. Такое поведение влияет как на :ref:`_process()<class_Node_private_method__process>`, так и на :ref:`_physics_process()<class_Node_private_method__physics_process>`. В результате избегайте использования ``delta`` для измерения времени в реальных секундах. Вместо этого используйте для этой цели методы синглтона :ref:`Time<class_Time>`, например :ref:`Time.get_ticks_usec()<class_Time_method_get_ticks_usec>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_process_delta_time:

.. rst-class:: classref-method

:ref:`float<class_float>` **get_process_delta_time**\ (\ ) |const| :ref:`🔗<class_Node_method_get_process_delta_time>`

Возвращает время, прошедшее (в секундах) с момента последнего обратного вызова процесса. Это значение идентично параметру ``delta`` :ref:`_process()<class_Node_private_method__process>` и может меняться от кадра к кадру. См. также :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`.

\ **Примечание:** Возвращаемое значение будет больше ожидаемого, если частота кадров ниже, чем :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` / :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` FPS. Это делается для того, чтобы избежать сценариев «спирали смерти», когда производительность резко падает из-за постоянно растущего числа шагов физики на кадр. Такое поведение влияет как на :ref:`_process()<class_Node_private_method__process>`, так и на :ref:`_physics_process()<class_Node_private_method__physics_process>`. В результате избегайте использования ``delta`` для измерения времени в реальных секундах. Вместо этого используйте для этой цели методы синглтона :ref:`Time<class_Time>`, например :ref:`Time.get_ticks_usec()<class_Time_method_get_ticks_usec>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_scene_instance_load_placeholder:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **get_scene_instance_load_placeholder**\ (\ ) |const| :ref:`🔗<class_Node_method_get_scene_instance_load_placeholder>`

Возвращает ``true``, если этот узел является заполнителем загрузки экземпляра. См. :ref:`InstancePlaceholder<class_InstancePlaceholder>` и :ref:`set_scene_instance_load_placeholder()<class_Node_method_set_scene_instance_load_placeholder>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree:

.. rst-class:: classref-method

:ref:`SceneTree<class_SceneTree>` **get_tree**\ (\ ) |const| :ref:`🔗<class_Node_method_get_tree>`

Возвращает :ref:`SceneTree<class_SceneTree>`, содержащий этот узел. Если этот узел не находится внутри дерева, генерирует ошибку и возвращает ``null``. См. также :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree_string:

.. rst-class:: classref-method

:ref:`String<class_String>` **get_tree_string**\ (\ ) :ref:`🔗<class_Node_method_get_tree_string>`

Возвращает дерево как :ref:`String<class_String>`. Используется в основном для отладки. Эта версия отображает путь относительно текущего узла и подходит для копирования/вставки в функцию :ref:`get_node()<class_Node_method_get_node>`. Также может использоваться в игровом UI/UX.

Может выводить, например:

.. code:: text

    TheGame
    TheGame/Menu
    TheGame/Menu/Label
    TheGame/Menu/Camera2D
    TheGame/SplashScreen
    TheGame/SplashScreen/Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree_string_pretty:

.. rst-class:: classref-method

:ref:`String<class_String>` **get_tree_string_pretty**\ (\ ) :ref:`🔗<class_Node_method_get_tree_string_pretty>`

Подобно :ref:`get_tree_string()<class_Node_method_get_tree_string>`, это возвращает дерево как :ref:`String<class_String>`. Эта версия отображает более графическое представление, похожее на то, что отображается в Scene Dock. Это полезно для проверки больших деревьев.

Может печатать, например:

.. code:: text

     ┖╴TheGame
        ┠╴Menu
        ┃  ┠╴Label
        ┃  ┖╴Camera2D
        ┖╴SplashScreen
           ┖╴Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_viewport:

.. rst-class:: classref-method

:ref:`Viewport<class_Viewport>` **get_viewport**\ (\ ) |const| :ref:`🔗<class_Node_method_get_viewport>`

Возвращает ближайшего предка :ref:`Viewport<class_Viewport>` узла, если узел находится внутри дерева. В противном случае возвращает ``null``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_window:

.. rst-class:: classref-method

:ref:`Window<class_Window>` **get_window**\ (\ ) |const| :ref:`🔗<class_Node_method_get_window>`

Возвращает :ref:`Window<class_Window>`, содержащее этот узел. Если узел находится в главном окне, это эквивалентно получению корневого узла (``get_tree().get_root()``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_has_node:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **has_node**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_has_node>`

Возвращает ``true``, если ``path`` указывает на допустимый узел. См. также :ref:`get_node()<class_Node_method_get_node>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_has_node_and_resource:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **has_node_and_resource**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_has_node_and_resource>`

Возвращает ``true``, если ``path`` указывает на допустимый узел, а его подимена указывают на допустимый :ref:`Resource<class_Resource>`, например, ``Area2D/CollisionShape2D:shape``. Свойства, которые не являются типами :ref:`Resource<class_Resource>` (например, узлы или другие типы :ref:`Variant<class_Variant>`), не рассматриваются. См. также :ref:`get_node_and_resource()<class_Node_method_get_node_and_resource>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_ancestor_of:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_ancestor_of**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_ancestor_of>`

Возвращает ``true``, если заданный ``node`` является прямым или косвенным дочерним элементом этого узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_displayed_folded:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_displayed_folded**\ (\ ) |const| :ref:`🔗<class_Node_method_is_displayed_folded>`

Возвращает ``true``, если узел свёрнут в доке сцены. Этот метод предназначен для использования в плагинах и инструментах редактора. См. также :ref:`set_display_folded()<class_Node_method_set_display_folded>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_editable_instance:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_editable_instance**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_editable_instance>`

Возвращает ``true``, если ``node`` имеет редактируемые дочерние элементы, включенные относительно этого узла. Этот метод предназначен для использования в плагинах и инструментах редактора. См. также :ref:`set_editable_instance()<class_Node_method_set_editable_instance>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_greater_than:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_greater_than**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_greater_than>`

Возвращает ``true``, если заданный ``node`` встречается позже в иерархии сцены, чем этот узел. Узел, встречающийся позже, обычно обрабатывается последним.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_in_group:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_in_group**\ (\ group\: :ref:`StringName<class_StringName>`\ ) |const| :ref:`🔗<class_Node_method_is_in_group>`

Возвращает ``true``, если этот узел был добавлен в заданную ``group``. См. :ref:`add_to_group()<class_Node_method_add_to_group>` и :ref:`remove_from_group()<class_Node_method_remove_from_group>`. См. также примечания в описании и методы группы :ref:`SceneTree<class_SceneTree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_inside_tree:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_inside_tree**\ (\ ) |const| :ref:`🔗<class_Node_method_is_inside_tree>`

Возвращает ``true``, если этот узел в данный момент находится внутри :ref:`SceneTree<class_SceneTree>`. См. также :ref:`get_tree()<class_Node_method_get_tree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_multiplayer_authority:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_multiplayer_authority**\ (\ ) |const| :ref:`🔗<class_Node_method_is_multiplayer_authority>`

Возвращает ``true``, если локальная система является многопользовательским центром этого узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_node_ready:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_node_ready**\ (\ ) |const| :ref:`🔗<class_Node_method_is_node_ready>`

Возвращает ``true``, если узел готов, т. е. он находится внутри дерева сцены и все его дочерние элементы инициализированы.

\ :ref:`request_ready()<class_Node_method_request_ready>` сбрасывает его обратно в ``false``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_part_of_edited_scene:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_part_of_edited_scene**\ (\ ) |const| :ref:`🔗<class_Node_method_is_part_of_edited_scene>`

Возвращает ``true``, если узел является частью сцены, открытой в данный момент в редакторе.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_interpolated:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_interpolated**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_interpolated>`

Возвращает ``true``, если физическая интерполяция включена для этого узла (см. :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`).

\ **Примечание:** Интерполяция будет активна только если и флаг установлен **и** физическая интерполяция включена в :ref:`SceneTree<class_SceneTree>`. Это можно проверить с помощью :ref:`is_physics_interpolated_and_enabled()<class_Node_method_is_physics_interpolated_and_enabled>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_interpolated_and_enabled:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_interpolated_and_enabled**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_interpolated_and_enabled>`

Возвращает ``true``, если включена интерполяция физики (см. :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) **и** включена в :ref:`SceneTree<class_SceneTree>`.

Это удобная версия :ref:`is_physics_interpolated()<class_Node_method_is_physics_interpolated>`, которая также проверяет, включена ли интерполяция физики глобально.

См. :ref:`SceneTree.physics_interpolation<class_SceneTree_property_physics_interpolation>` и :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_processing:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_processing**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_processing>`

Возвращает ``true``, если обработка физики включена (см. :ref:`set_physics_process()<class_Node_method_set_physics_process>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_processing_internal:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_processing_internal**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_processing_internal>`

Возвращает ``true``, если включена внутренняя обработка физики (см. :ref:`set_physics_process_internal()<class_Node_method_set_physics_process_internal>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing>`

Возвращает ``true``, если обработка включена (см. :ref:`set_process()<class_Node_method_set_process>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_input>`

Возвращает ``true``, если узел обрабатывает входные данные (см. :ref:`set_process_input()<class_Node_method_set_process_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_internal:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_internal**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_internal>`

Возвращает ``true``, если включена внутренняя обработка (см. :ref:`set_process_internal()<class_Node_method_set_process_internal>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_shortcut_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_shortcut_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_shortcut_input>`

Возвращает ``true``, если узел обрабатывает сочетания клавиш (см. :ref:`set_process_shortcut_input()<class_Node_method_set_process_shortcut_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_unhandled_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_unhandled_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_unhandled_input>`

Возвращает ``true``, если узел обрабатывает необработанный ввод (см. :ref:`set_process_unhandled_input()<class_Node_method_set_process_unhandled_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_unhandled_key_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_unhandled_key_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_unhandled_key_input>`

Возвращает ``true``, если узел обрабатывает необработанный ввод с клавиатуры (см. :ref:`set_process_unhandled_key_input()<class_Node_method_set_process_unhandled_key_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_move_child:

.. rst-class:: classref-method

|void| **move_child**\ (\ child_node\: :ref:`Node<class_Node>`, to_index\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_move_child>`

Перемещает ``child_node`` в указанный индекс. Индекс узла — это порядок среди его братьев и сестер. Если ``to_index`` отрицательный, индекс отсчитывается с конца списка. См. также :ref:`get_child()<class_Node_method_get_child>` и :ref:`get_index()<class_Node_method_get_index>`.

\ **Примечание:** Порядок обработки нескольких обратных вызовов движка (:ref:`_ready()<class_Node_private_method__ready>`, :ref:`_process()<class_Node_private_method__process>` и т. д.) и уведомлений, отправленных через :ref:`propagate_notification()<class_Node_method_propagate_notification>`, зависит от порядка дерева. Узлы :ref:`CanvasItem<class_CanvasItem>` также отображаются в порядке дерева. См. также :ref:`process_priority<class_Node_property_process_priority>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_notify_deferred_thread_group:

.. rst-class:: classref-method

|void| **notify_deferred_thread_group**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_notify_deferred_thread_group>`

Аналогично :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>`, но для уведомлений.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_notify_thread_safe:

.. rst-class:: classref-method

|void| **notify_thread_safe**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_notify_thread_safe>`

Аналогично :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, но для уведомлений.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_orphan_nodes:

.. rst-class:: classref-method

|void| **print_orphan_nodes**\ (\ ) |static| :ref:`🔗<class_Node_method_print_orphan_nodes>`

Выводит все сиротские узлы (узлы за пределами :ref:`SceneTree<class_SceneTree>`). Полезно для отладки.

\ **Примечание:** Этот метод работает только в отладочных сборках. Ничего не делает в проекте, экспортированном в режиме выпуска.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_tree:

.. rst-class:: classref-method

|void| **print_tree**\ (\ ) :ref:`🔗<class_Node_method_print_tree>`

Выводит узел и его дочерние элементы на консоль рекурсивно. Узел не обязательно должен находиться внутри дерева. Этот метод выводит :ref:`NodePath<class_NodePath>` относительно этого узла и подходит для копирования/вставки в :ref:`get_node()<class_Node_method_get_node>`. См. также :ref:`print_tree_pretty()<class_Node_method_print_tree_pretty>`.

Может выводить, например:

.. code:: text

    .
    Menu
    Menu/Label
    Menu/Camera2D
    SplashScreen
    SplashScreen/Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_tree_pretty:

.. rst-class:: classref-method

|void| **print_tree_pretty**\ (\ ) :ref:`🔗<class_Node_method_print_tree_pretty>`

Выводит узел и его дочерние элементы на консоль, рекурсивно. Узел не обязательно должен находиться внутри дерева. Аналогично :ref:`print_tree()<class_Node_method_print_tree>`, но графическое представление выглядит так, как отображается в редакторе Scene dock. Это полезно для проверки больших деревьев.

Например, может вывести:

.. code:: text

     ┖╴TheGame
        ┠╴Menu
        ┃  ┠╴Label
        ┃  ┖╴Camera2D
        ┖╴SplashScreen
           ┖╴Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_propagate_call:

.. rst-class:: classref-method

|void| **propagate_call**\ (\ method\: :ref:`StringName<class_StringName>`, args\: :ref:`Array<class_Array>` = [], parent_first\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_propagate_call>`

Вызывает заданное имя ``method``, передавая ``args`` в качестве аргументов, на этом узле и всех его дочерних узлах, рекурсивно.

Если ``parent_first`` равен ``true``, метод сначала вызывается на этом узле, затем на всех его дочерних узлах. Если ``false``, сначала вызываются методы дочерних узлов.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_propagate_notification:

.. rst-class:: classref-method

|void| **propagate_notification**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_propagate_notification>`

Вызывает :ref:`Object.notification()<class_Object_method_notification>` с ``what`` для данного узла и всех его дочерних узлов, рекурсивно.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_queue_accessibility_update:

.. rst-class:: classref-method

|void| **queue_accessibility_update**\ (\ ) :ref:`🔗<class_Node_method_queue_accessibility_update>`

Ставит в очередь обновление информации о доступности для этого узла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_queue_free:

.. rst-class:: classref-method

|void| **queue_free**\ (\ ) :ref:`🔗<class_Node_method_queue_free>`

Ставит этот узел в очередь на удаление в конце текущего кадра. При удалении все его дочерние элементы также удаляются, и все ссылки на узел и его дочерние элементы становятся недействительными.

В отличие от :ref:`Object.free()<class_Object_method_free>`, узел не удаляется мгновенно, и к нему все еще можно получить доступ до удаления. Также безопасно вызывать :ref:`queue_free()<class_Node_method_queue_free>` несколько раз. Используйте :ref:`Object.is_queued_for_deletion()<class_Object_method_is_queued_for_deletion>`, чтобы проверить, будет ли узел удален в конце кадра.

\ **Примечание:** Узел будет освобожден только после завершения всех других отложенных вызовов. Использование этого метода не всегда то же самое, что и вызов :ref:`Object.free()<class_Object_method_free>` через :ref:`Object.call_deferred()<class_Object_method_call_deferred>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_remove_child:

.. rst-class:: classref-method

|void| **remove_child**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_method_remove_child>`

Удаляет дочерний ``node``. ``node`` вместе со своими дочерними элементами **не** удаляется. Чтобы удалить узел, см. :ref:`queue_free()<class_Node_method_queue_free>`.

\ **Примечание:** Когда этот узел находится внутри дерева, этот метод устанавливает :ref:`owner<class_Node_property_owner>` удаленного ``node`` (или его потомков) в ``null``, если их :ref:`owner<class_Node_property_owner>` больше не является предком (см. :ref:`is_ancestor_of()<class_Node_method_is_ancestor_of>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_remove_from_group:

.. rst-class:: classref-method

|void| **remove_from_group**\ (\ group\: :ref:`StringName<class_StringName>`\ ) :ref:`🔗<class_Node_method_remove_from_group>`

Удаляет узел из заданной ``group``. Ничего не делает, если узел не находится в ``group``. См. также примечания в описании и методы группы :ref:`SceneTree<class_SceneTree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_reparent:

.. rst-class:: classref-method

|void| **reparent**\ (\ new_parent\: :ref:`Node<class_Node>`, keep_global_transform\: :ref:`bool<class_bool>` = true\ ) :ref:`🔗<class_Node_method_reparent>`

Изменяет родителя этого **Node** на ``new_parent``. Узел должен уже иметь родителя. ``Member owner`` узла сохраняется, если его владелец все еще доступен из нового местоположения (т. е. узел все еще является потомком нового родителя после операции).

Если ``keep_global_transform`` равен ``true``, глобальное преобразование узла будет сохранено, если поддерживается. :ref:`Node2D<class_Node2D>`, :ref:`Node3D<class_Node3D>` и :ref:`Control<class_Control>` поддерживают этот аргумент (но :ref:`Control<class_Control>` сохраняет только позицию).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_replace_by:

.. rst-class:: classref-method

|void| **replace_by**\ (\ node\: :ref:`Node<class_Node>`, keep_groups\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_replace_by>`

Заменяет этот узел заданным ``node``. Все дочерние элементы этого узла перемещаются в ``node``.

Если ``keep_groups`` равно ``true``, ``node`` добавляется в те же группы, в которых находится замененный узел (см. :ref:`add_to_group()<class_Node_method_add_to_group>`).

\ **Предупреждение:** Замененный узел удаляется из дерева, но он **не** удаляется сам. Чтобы предотвратить утечки памяти, сохраните ссылку на узел в переменной или используйте :ref:`Object.free()<class_Object_method_free>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_request_ready:

.. rst-class:: classref-method

|void| **request_ready**\ (\ ) :ref:`🔗<class_Node_method_request_ready>`

Запрашивает вызов :ref:`_ready()<class_Node_private_method__ready>` снова при следующем входе узла в дерево. **Не** немедленно вызывает :ref:`_ready()<class_Node_private_method__ready>`.

\ **Примечание:** Этот метод влияет только на текущий узел. Если дочерние элементы узла также должны запросить готовность, этот метод необходимо вызвать для каждого из них. Когда узел и его дочерние элементы снова входят в дерево, порядок обратных вызовов :ref:`_ready()<class_Node_private_method__ready>` будет таким же, как обычно.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_reset_physics_interpolation:

.. rst-class:: classref-method

|void| **reset_physics_interpolation**\ (\ ) :ref:`🔗<class_Node_method_reset_physics_interpolation>`

Когда активна интерполяция физики, перемещение узла в радикально иное преобразование (например, размещение на уровне) может привести к видимому сбою, поскольку объект отображается перемещающимся из старой позиции в новую за физический тик.

Этот сбой можно предотвратить, вызвав этот метод, который временно отключает интерполяцию до завершения физического тика.

Уведомление :ref:`NOTIFICATION_RESET_PHYSICS_INTERPOLATION<class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION>` будет получено узлом и всеми дочерними элементами рекурсивно.

\ **Примечание:** Эту функцию следует вызывать **после** перемещения узла, а не до него.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **rpc**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_rpc>`

Отправляет запрос на вызов удаленной процедуры для указанного ``method`` одноранговым узлам в сети (и локально), отправляя дополнительные аргументы методу, вызываемому RPC. Запрос на вызов будет получен только узлами с тем же :ref:`NodePath<class_NodePath>`, включая точно такое же :ref:`name<class_Node_property_name>`. Поведение зависит от конфигурации RPC для указанного ``method`` (см. :ref:`rpc_config()<class_Node_method_rpc_config>` и :ref:`@GDScript.@rpc<class_@GDScript_annotation_@rpc>`). По умолчанию методы не подвергаются RPC.

Может возвращать :ref:`@GlobalScope.OK<class_@GlobalScope_constant_OK>`, если вызов успешен, :ref:`@GlobalScope.ERR_INVALID_PARAMETER<class_@GlobalScope_constant_ERR_INVALID_PARAMETER>`, если аргументы, переданные в ``method``, не совпадают, :ref:`@GlobalScope.ERR_UNCONFIGURED<class_@GlobalScope_constant_ERR_UNCONFIGURED>`, если :ref:`multiplayer<class_Node_property_multiplayer>` узла не может быть извлечен (например, когда узел не находится внутри дерева), :ref:`@GlobalScope.ERR_CONNECTION_ERROR<class_@GlobalScope_constant_ERR_CONNECTION_ERROR>`, если соединение :ref:`multiplayer<class_Node_property_multiplayer>` недоступно.

\ **Примечание:** Вы можете безопасно использовать RPC на клиентах только после получения сигнала :ref:`MultiplayerAPI.connected_to_server<class_MultiplayerAPI_signal_connected_to_server>` от :ref:`MultiplayerAPI<class_MultiplayerAPI>`. Вам также необходимо отслеживать состояние соединения, либо по сигналам :ref:`MultiplayerAPI<class_MultiplayerAPI>`, таким как :ref:`MultiplayerAPI.server_disconnected<class_MultiplayerAPI_signal_server_disconnected>`, либо путем проверки (``get_multiplayer().peer.get_connection_status() == CONNECTION_CONNECTED``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc_config:

.. rst-class:: classref-method

|void| **rpc_config**\ (\ method\: :ref:`StringName<class_StringName>`, config\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_rpc_config>`

Изменяет конфигурацию RPC для указанного ``method``. ``config`` должен быть либо ``null``, чтобы отключить функцию (как по умолчанию), либо :ref:`Dictionary<class_Dictionary>`, содержащий следующие записи:

- ``rpc_mode``: см. :ref:`RPCMode<enum_MultiplayerAPI_RPCMode>`;

- ``transfer_mode``: см. :ref:`TransferMode<enum_MultiplayerPeer_TransferMode>`;

- ``call_local``: если ``true``, метод также будет вызван локально;

- ``channel``: :ref:`int<class_int>`, представляющий канал для отправки RPC.

\ **Примечание:** В GDScript этот метод соответствует аннотации :ref:`@GDScript.@rpc<class_@GDScript_annotation_@rpc>` с различными переданными параметрами (``@rpc(any)``, ``@rpc(authority)``...). См. также учебник :doc:`высокоуровневый многопользовательский режим <../tutorials/networking/high_level_multiplayer>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc_id:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **rpc_id**\ (\ peer_id\: :ref:`int<class_int>`, method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_rpc_id>`

Отправляет :ref:`rpc()<class_Node_method_rpc>` определенному одноранговому узлу, идентифицированному ``peer_id`` (см. :ref:`MultiplayerPeer.set_target_peer()<class_MultiplayerPeer_method_set_target_peer>`).

Может возвращать :ref:`@GlobalScope.OK<class_@GlobalScope_constant_OK>`, если вызов успешен, :ref:`@GlobalScope.ERR_INVALID_PARAMETER<class_@GlobalScope_constant_ERR_INVALID_PARAMETER>`, если аргументы, переданные в ``method``, не совпадают, :ref:`@GlobalScope.ERR_UNCONFIGURED<class_@GlobalScope_constant_ERR_UNCONFIGURED>`, если :ref:`multiplayer<class_Node_property_multiplayer>` узла не может быть извлечен (например, когда узел не находится внутри дерева), :ref:`@GlobalScope.ERR_CONNECTION_ERROR<class_@GlobalScope_constant_ERR_CONNECTION_ERROR>`, если соединение :ref:`multiplayer<class_Node_property_multiplayer>` недоступно.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_deferred_thread_group:

.. rst-class:: classref-method

|void| **set_deferred_thread_group**\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_set_deferred_thread_group>`

Аналогично :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>`, но для настройки свойств.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_display_folded:

.. rst-class:: classref-method

|void| **set_display_folded**\ (\ fold\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_display_folded>`

Если установлено значение ``true``, узел отображается свернутым в Scene dock. В результате все его дочерние элементы скрыты. Этот метод предназначен для использования в плагинах и инструментах редактора, но он также работает в сборках релиза. См. также :ref:`is_displayed_folded()<class_Node_method_is_displayed_folded>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_editable_instance:

.. rst-class:: classref-method

|void| **set_editable_instance**\ (\ node\: :ref:`Node<class_Node>`, is_editable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_editable_instance>`

Установите значение ``true``, чтобы разрешить всем узлам, принадлежащим ``node``, быть доступными и редактируемыми в доке сцены, даже если их :ref:`owner<class_Node_property_owner>` не является корнем сцены. Этот метод предназначен для использования в плагинах и инструментах редактора, но он также работает в сборках релиза. См. также :ref:`is_editable_instance()<class_Node_method_is_editable_instance>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_multiplayer_authority:

.. rst-class:: classref-method

|void| **set_multiplayer_authority**\ (\ id\: :ref:`int<class_int>`, recursive\: :ref:`bool<class_bool>` = true\ ) :ref:`🔗<class_Node_method_set_multiplayer_authority>`

Устанавливает многопользовательские полномочия узла на одноранговый узел с заданным одноранговым узлом ``id``. Многопользовательские полномочия — это одноранговый узел, который имеет полномочия над узлом в сети. По умолчанию равно peer ID 1 (сервер). Полезно в сочетании с :ref:`rpc_config()<class_Node_method_rpc_config>` и :ref:`MultiplayerAPI<class_MultiplayerAPI>`.

Если ``recursive`` равно ``true``, заданный одноранговый узел рекурсивно устанавливается как полномочный для всех дочерних узлов этого узла.

\ **Предупреждение:** Это **не** автоматически реплицирует новые полномочия на другие одноранговые узлы. Это обязанность разработчика. Вы можете реплицировать информацию о новых полномочиях с помощью :ref:`MultiplayerSpawner.spawn_function<class_MultiplayerSpawner_property_spawn_function>`, RPC или :ref:`MultiplayerSynchronizer<class_MultiplayerSynchronizer>`. Кроме того, полномочия родителя **не** распространяются на вновь добавленные дочерние узлы.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_physics_process:

.. rst-class:: classref-method

|void| **set_physics_process**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_physics_process>`

Если установлено значение ``true``, включает обработку физики (фиксированная частота кадров). Когда узел обрабатывается, он получит :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>` с фиксированным (обычно 60 FPS, см. :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` для изменения) интервалом (и будет вызван обратный вызов :ref:`_physics_process()<class_Node_private_method__physics_process>`, если он существует).

\ **Примечание:** Если :ref:`_physics_process()<class_Node_private_method__physics_process>` переопределен, он будет автоматически включен перед вызовом :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_physics_process_internal:

.. rst-class:: classref-method

|void| **set_physics_process_internal**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_physics_process_internal>`

Если установлено значение ``true``, включает внутреннюю физику для этого узла. Внутренняя обработка физики происходит изолированно от обычных вызовов :ref:`_physics_process()<class_Node_private_method__physics_process>` и используется некоторыми узлами внутренне, чтобы гарантировать правильное функционирование, даже если узел приостановлен или обработка физики отключена для скриптинга (:ref:`set_physics_process()<class_Node_method_set_physics_process>`).

\ **Предупреждение:** Встроенные узлы полагаются на внутреннюю обработку для своей внутренней логики. Отключение ее небезопасно и может привести к неожиданному поведению. Используйте этот метод, если вы знаете, что делаете.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process:

.. rst-class:: classref-method

|void| **set_process**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process>`

Если установлено значение ``true``, включает обработку. Когда узел обрабатывается, он будет получать :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` на каждом отрисованном кадре (и будет вызван обратный вызов :ref:`_process()<class_Node_private_method__process>`, если он существует).

\ **Примечание:** Если :ref:`_process()<class_Node_private_method__process>` переопределен, он будет автоматически включен до вызова :ref:`_ready()<class_Node_private_method__ready>`.

\ **Примечание:** Этот метод влияет только на обратный вызов :ref:`_process()<class_Node_private_method__process>`, т. е. он не влияет на другие обратные вызовы, такие как :ref:`_physics_process()<class_Node_private_method__physics_process>`. Если вы хотите отключить всю обработку для узла, установите :ref:`process_mode<class_Node_property_process_mode>` на :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_input:

.. rst-class:: classref-method

|void| **set_process_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_input>`

Если установлено значение ``true``, включает обработку ввода.

\ **Примечание:** Если :ref:`_input()<class_Node_private_method__input>` переопределен, он будет автоматически включен до вызова :ref:`_ready()<class_Node_private_method__ready>`. Обработка ввода также уже включена для элементов управления GUI, таких как :ref:`Button<class_Button>` и :ref:`TextEdit<class_TextEdit>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_internal:

.. rst-class:: classref-method

|void| **set_process_internal**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_internal>`

Если установлено значение ``true``, включает внутреннюю обработку для этого узла. Внутренняя обработка происходит изолированно от обычных вызовов :ref:`_process()<class_Node_private_method__process>` и используется некоторыми узлами внутренне, чтобы гарантировать надлежащую работу, даже если узел приостановлен или обработка отключена для скриптинга (:ref:`set_process()<class_Node_method_set_process>`).

\ **Предупреждение:** Встроенные узлы полагаются на внутреннюю обработку для своей внутренней логики. Отключение ее небезопасно и может привести к неожиданному поведению. Используйте этот метод, если вы знаете, что делаете.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_shortcut_input:

.. rst-class:: classref-method

|void| **set_process_shortcut_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_shortcut_input>`

Если установлено значение ``true``, включает обработку сокращений для этого узла.

\ **Примечание:** Если :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>` переопределен, он будет автоматически включен перед вызовом :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_unhandled_input:

.. rst-class:: classref-method

|void| **set_process_unhandled_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_unhandled_input>`

Если установлено значение ``true``, включается обработка необработанного ввода. Это позволяет узлу получать весь ввод, который ранее не был обработан (обычно :ref:`Control<class_Control>`).

\ **Примечание:** Если :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` переопределен, он будет автоматически включен до вызова :ref:`_ready()<class_Node_private_method__ready>`. Обработка необработанного ввода также уже включена для элементов управления GUI, таких как :ref:`Button<class_Button>` и :ref:`TextEdit<class_TextEdit>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_unhandled_key_input:

.. rst-class:: classref-method

|void| **set_process_unhandled_key_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_unhandled_key_input>`

Если установлено значение ``true``, включается обработка необработанного ввода клавиш.

\ **Примечание:** Если :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` переопределен, он будет автоматически включен перед вызовом :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_scene_instance_load_placeholder:

.. rst-class:: classref-method

|void| **set_scene_instance_load_placeholder**\ (\ load_placeholder\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_scene_instance_load_placeholder>`

Если установлено значение ``true``, узел становится :ref:`InstancePlaceholder<class_InstancePlaceholder>` при упаковке и создании экземпляра из :ref:`PackedScene<class_PackedScene>`. См. также :ref:`get_scene_instance_load_placeholder()<class_Node_method_get_scene_instance_load_placeholder>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_thread_safe:

.. rst-class:: classref-method

|void| **set_thread_safe**\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_set_thread_safe>`

Аналогично :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, но для настройки свойств.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_translation_domain_inherited:

.. rst-class:: classref-method

|void| **set_translation_domain_inherited**\ (\ ) :ref:`🔗<class_Node_method_set_translation_domain_inherited>`

Делает так, чтобы этот узел наследовал домен перевода от своего родительского узла. Если у этого узла нет родителя, будет использоваться основной домен перевода. 

Это поведение по умолчанию для всех узлов. Вызов :ref:`Object.set_translation_domain()<class_Object_method_set_translation_domain>` отключает это поведение.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_update_configuration_warnings:

.. rst-class:: classref-method

|void| **update_configuration_warnings**\ (\ ) :ref:`🔗<class_Node_method_update_configuration_warnings>`

Обновляет предупреждения, отображаемые для этого узла в доке сцены. Используйте :ref:`_get_configuration_warnings()<class_Node_private_method__get_configuration_warnings>` для настройки отображаемых предупреждающих сообщений.

.. |virtual| replace:: :abbr:`virtual (Этот метод обычно должен быть переопределен пользователем, чтобы иметь какой-либо эффект.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (Этот метод не имеет побочных эффектов. Он не изменяет ни одну из переменных-членов экземпляра.)`
.. |vararg| replace:: :abbr:`vararg (Этот метод принимает любое количество аргументов после описанных здесь.)`
.. |constructor| replace:: :abbr:`constructor (Этот метод используется для создания типа.)`
.. |static| replace:: :abbr:`static (Этот метод не нуждается в вызове экземпляра, поэтому его можно вызвать напрямую, используя имя класса.)`
.. |operator| replace:: :abbr:`operator (Этот метод описывает допустимый оператор для использования с этим типом в качестве левого операнда.)`
.. |bitfield| replace:: :abbr:`BitField (Это значение является целым числом, составленным как битовая маска следующих флагов.)`
.. |void| replace:: :abbr:`void (Нет возвращаемого значения.)`
