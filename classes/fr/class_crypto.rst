:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Crypto.xml.

.. _class_Crypto:

Crypto
======

**H√©rite de‚ÄØ:** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

Fournit un acc√®s √† des fonctionnalit√©s cryptographiques avanc√©es.

.. rst-class:: classref-introduction-group

Description
-----------

La classe Crypto permet d'acc√©der √† des fonctionnalit√©s cryptographiques plus avanc√©es.

Pour l'instant, cela inclut l'encryptage/d√©cryptage de cl√© asym√©trique, la signature/v√©rification, et la g√©n√©ration cryptographique s√©curis√©e de bytes al√©atoires, de cl√©s RSA, de HMAC et de :ref:`X509Certificate<class_X509Certificate>`\ s auto-sign√©s.


.. tabs::

 .. code-tab:: gdscript

    var crypto = Crypto.new()

    # G√©n√©rer une nouvelle cl√© RSA.
    var key = crypto.generate_rsa(4096)

    # G√©n√©rer un nouveau certificat auto-sign√© avec le cl√©.
    var cert = crypto.generate_self_signed_certificate(key, "CN=mydomain.com,O=My Game Company,C=IT")

    # Enregistrer la cl√© et le certificat dans le dossier utilisateur.
    key.save("user://generated.key")
    cert.save("user://generated.crt")

    # Cryptage
    var data = "Some data"
    var encrypted = crypto.encrypt(key, data.to_utf8_buffer())

    # D√©cryptage
    var decrypted = crypto.decrypt(key, encrypted)

    # Signature
    var signature = crypto.sign(HashingContext.HASH_SHA256, data.sha256_buffer(), key)

    # V√©rification
    var verified = crypto.verify(HashingContext.HASH_SHA256, data.sha256_buffer(), signature, key)

    # Tests
    assert(verified)
    assert(data.to_utf8_buffer() == decrypted)

 .. code-tab:: csharp

    using Godot;
    using System.Diagnostics;

    Crypto crypto = new Crypto();

    // G√©n√©rer une nouvelle cl√© RSA.
    CryptoKey key = crypto.GenerateRsa(4096);

    // G√©n√©rer un nouveau certificat auto-sign√© avec le cl√©.
    X509Certificate cert = crypto.GenerateSelfSignedCertificate(key, "CN=mydomain.com,O=My Game Company,C=IT");

    // Enregistrer la cl√© et le certificat dans le dossier utilisateur.
    key.Save("user://generated.key");
    cert.Save("user://generated.crt");

    // Cryptage
    string data = "Some data";
    byte[] encrypted = crypto.Encrypt(key, data.ToUtf8Buffer());

    // D√©cryptage
    byte[] decrypted = crypto.Decrypt(key, encrypted);

    // Signature
    byte[] signature = crypto.Sign(HashingContext.HashType.Sha256, Data.Sha256Buffer(), key);

    // V√©rification
    bool verified = crypto.Verify(HashingContext.HashType.Sha256, Data.Sha256Buffer(), signature, key);

    // Tests
    Debug.Assert(verified);
    Debug.Assert(data.ToUtf8Buffer() == decrypted);



.. rst-class:: classref-reftable-group

M√©thodes
----------------

.. table::
   :widths: auto

   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                       | :ref:`constant_time_compare<class_Crypto_method_constant_time_compare>`\ (\ trusted\: :ref:`PackedByteArray<class_PackedByteArray>`, received\: :ref:`PackedByteArray<class_PackedByteArray>`\ )                                                                                                                                                       |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`decrypt<class_Crypto_method_decrypt>`\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, ciphertext\: :ref:`PackedByteArray<class_PackedByteArray>`\ )                                                                                                                                                                                                 |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`encrypt<class_Crypto_method_encrypt>`\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, plaintext\: :ref:`PackedByteArray<class_PackedByteArray>`\ )                                                                                                                                                                                                  |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`generate_random_bytes<class_Crypto_method_generate_random_bytes>`\ (\ size\: :ref:`int<class_int>`\ )                                                                                                                                                                                                                                            |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`CryptoKey<class_CryptoKey>`             | :ref:`generate_rsa<class_Crypto_method_generate_rsa>`\ (\ size\: :ref:`int<class_int>`\ )                                                                                                                                                                                                                                                              |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`X509Certificate<class_X509Certificate>` | :ref:`generate_self_signed_certificate<class_Crypto_method_generate_self_signed_certificate>`\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, issuer_name\: :ref:`String<class_String>` = "CN=myserver,O=myorganisation,C=IT", not_before\: :ref:`String<class_String>` = "20140101000000", not_after\: :ref:`String<class_String>` = "20340101000000"\ ) |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`hmac_digest<class_Crypto_method_hmac_digest>`\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, key\: :ref:`PackedByteArray<class_PackedByteArray>`, msg\: :ref:`PackedByteArray<class_PackedByteArray>`\ )                                                                                                                         |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`sign<class_Crypto_method_sign>`\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, hash\: :ref:`PackedByteArray<class_PackedByteArray>`, key\: :ref:`CryptoKey<class_CryptoKey>`\ )                                                                                                                                                  |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                       | :ref:`verify<class_Crypto_method_verify>`\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, hash\: :ref:`PackedByteArray<class_PackedByteArray>`, signature\: :ref:`PackedByteArray<class_PackedByteArray>`, key\: :ref:`CryptoKey<class_CryptoKey>`\ )                                                                                   |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Descriptions des m√©thodes
--------------------------------------------------

.. _class_Crypto_method_constant_time_compare:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **constant_time_compare**\ (\ trusted\: :ref:`PackedByteArray<class_PackedByteArray>`, received\: :ref:`PackedByteArray<class_PackedByteArray>`\ ) :ref:`üîó<class_Crypto_method_constant_time_compare>`

Compare deux :ref:`PackedByteArray<class_PackedByteArray>`\ s pour l'√©galit√© sans fuite temporelle d'informations afin de pr√©venir les attaques temporelles.

Voir `ce post de blog <https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy>`__ pour plus d'informations.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_decrypt:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **decrypt**\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, ciphertext\: :ref:`PackedByteArray<class_PackedByteArray>`\ ) :ref:`üîó<class_Crypto_method_decrypt>`

D√©chiffre le texte crypt√© ``ciphertext`` donn√© avec le cl√© priv√©e ``key`` fournie.

\ **Note¬†:** La taille maximale pour le texte crypt√© est limit√©e par la taille de la cl√©.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_encrypt:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **encrypt**\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, plaintext\: :ref:`PackedByteArray<class_PackedByteArray>`\ ) :ref:`üîó<class_Crypto_method_encrypt>`

Encrypte le texte brut ``plaintext`` donn√© avec le cl√© publique ``key`` fournie.

\ **Note¬†:** La taille maximale pour le texte brut est limit√©e par la taille de la cl√©.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_generate_random_bytes:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **generate_random_bytes**\ (\ size\: :ref:`int<class_int>`\ ) :ref:`üîó<class_Crypto_method_generate_random_bytes>`

G√©n√®re un :ref:`PackedByteArray<class_PackedByteArray>` d'octets al√©atoires de mani√®re cryptographiquement s√©curis√©e avec la taille ``size`` donn√©e.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_generate_rsa:

.. rst-class:: classref-method

:ref:`CryptoKey<class_CryptoKey>` **generate_rsa**\ (\ size\: :ref:`int<class_int>`\ ) :ref:`üîó<class_Crypto_method_generate_rsa>`

G√©n√®re une :ref:`CryptoKey<class_CryptoKey>` RSA qui peut √™tre utilis√© pour cr√©er des certificats autosign√©s et transmis √† :ref:`StreamPeerTLS.accept_stream()<class_StreamPeerTLS_method_accept_stream>`.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_generate_self_signed_certificate:

.. rst-class:: classref-method

:ref:`X509Certificate<class_X509Certificate>` **generate_self_signed_certificate**\ (\ key\: :ref:`CryptoKey<class_CryptoKey>`, issuer_name\: :ref:`String<class_String>` = "CN=myserver,O=myorganisation,C=IT", not_before\: :ref:`String<class_String>` = "20140101000000", not_after\: :ref:`String<class_String>` = "20340101000000"\ ) :ref:`üîó<class_Crypto_method_generate_self_signed_certificate>`

G√©n√®re un :ref:`X509Certificate<class_X509Certificate>` auto-sign√© avec la cl√© :ref:`CryptoKey<class_CryptoKey>` et le nom d'√©metteur ``issuer_name`` donn√©s. La date de validit√© du certificat est d√©finie par ``not_before`` et ``not_after`` (la date de d√©but et de fin de validit√©). Le nom ``issuer_name`` doit contenir au moins "CN=" (le nom commun, c.√†.d. le nom de domaine), "O=" (l'organisation, c.√†.d. le nom de votre entreprise) et "C=" (le pays, c.√†.d. un code ISO-3166 √† deux lettres du pays o√π l'entreprise est situ√©e).

Un court exemple pour g√©n√©rer une cl√© RSA et un certificat X509 auto-sign√©.


.. tabs::

 .. code-tab:: gdscript

    var crypto = Crypto.new()
    # G√©n√©rer un cl√© RSA 4096 bits.
    var cle = crypto.generate_rsa(4096)
    # G√©n√©rer un certificat auto-sign√© √† partir de la cl√© donn√©e.
    var cert = crypto.generate_self_signed_certificate(cle, "CN=example.com,O=Mon Studio de Jeux,C=FR")

 .. code-tab:: csharp

    var crypto = new Crypto();
    // G√©n√©rer un cl√© RSA 4096 bits.
    CryptoKey cle = crypto.GenerateRsa(4096);
    // G√©n√©rer un certificat auto-sign√© √† partir de la cl√© donn√©e.
    X509Certificate cert = crypto.GenerateSelfSignedCertificate(cle, "CN=example.com,O=Mon Studio de Jeux, C=FR");



.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_hmac_digest:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **hmac_digest**\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, key\: :ref:`PackedByteArray<class_PackedByteArray>`, msg\: :ref:`PackedByteArray<class_PackedByteArray>`\ ) :ref:`üîó<class_Crypto_method_hmac_digest>`

G√©n√®re un r√©sum√© `HMAC <https://fr.wikipedia.org/wiki/HMAC>`__ du message ``msg`` √† partir de la cl√© ``key``. Le param√®tre ``hash_type`` est l'algorithme de hachage utilis√© pour les hachages int√©rieurs et ext√©rieurs.

Actuellement, seuls les algorithmes :ref:`HashingContext.HASH_SHA256<class_HashingContext_constant_HASH_SHA256>` et :ref:`HashingContext.HASH_SHA1<class_HashingContext_constant_HASH_SHA1>` sont support√©s.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_sign:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **sign**\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, hash\: :ref:`PackedByteArray<class_PackedByteArray>`, key\: :ref:`CryptoKey<class_CryptoKey>`\ ) :ref:`üîó<class_Crypto_method_sign>`

Signe le hachage ``hash`` donn√© de type ``hash_type`` avec la cl√© priv√©e ``key`` fournie.

.. rst-class:: classref-item-separator

----

.. _class_Crypto_method_verify:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **verify**\ (\ hash_type\: :ref:`HashType<enum_HashingContext_HashType>`, hash\: :ref:`PackedByteArray<class_PackedByteArray>`, signature\: :ref:`PackedByteArray<class_PackedByteArray>`, key\: :ref:`CryptoKey<class_CryptoKey>`\ ) :ref:`üîó<class_Crypto_method_verify>`

V√©rifie la ``signature`` donn√©e pour le hachage ``hash`` du type ``hash_type`` avec la cl√© publique ``key`` fournie.

.. |virtual| replace:: :abbr:`virtual (Cette m√©thode doit typiquement √™tre red√©finie par l'utilisateur pour avoir un effet.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (Cette m√©thode n'a pas d'effets de bord. Elle ne modifie aucune des variables membres de l'instance.)`
.. |vararg| replace:: :abbr:`vararg (Cette m√©thode accepte n'importe quel nombre d'arguments apr√®s ceux d√©cris ici.)`
.. |constructor| replace:: :abbr:`constructor (Cette m√©thode est utilis√©e pour construire un type.)`
.. |static| replace:: :abbr:`static (Cette m√©thode n'a pas besoin d'instance pour √™tre appel√©e, elle peut donc √™tre directement appel√©e en utilisant le nom de la classe.)`
.. |operator| replace:: :abbr:`operator (Cette m√©thode d√©crit un op√©rateur valide √† utiliser avec ce type en tant qu'op√©rande gauche.)`
.. |bitfield| replace:: :abbr:`BitField (Cette valeur est un nombre entier compos√© d'un masque de bits des options suivantes.)`
.. |void| replace:: :abbr:`void (Aucune valeur de retour.)`
