:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Transform3D.xml.

.. _class_Transform3D:

Transform3D
===========

Une matrice 3√ó4 repr√©sentant une transformation 3D.

.. rst-class:: classref-introduction-group

Description
-----------

Le type :ref:`Variant<class_Variant>` int√©gr√© **Transform3D** est une matrice 3√ó4 repr√©sentant une transformation dans l'espace 3D. Elle contient une :ref:`Basis<class_Basis>` qui, √† elle seule peut repr√©senter la rotation, l'√©chelle et le cisaillement. En plus, combin√©e √† sa propre origine :ref:`origin<class_Transform3D_property_origin>`, la transformation peut √©galement repr√©senter une translation.

Pour une introduction g√©n√©rale, voir le tutoriel :doc:`Matrices et transformations <../tutorials/math/matrices_and_transforms>`.

\ **Note¬†:** Godot utilise un `syst√®me de coordonn√©es main-droite <https://fr.wikipedia.org/wiki/R%C3%A8gle_de_la_main_droite>`__, qui est une norme habituelle. Pour les directions, la convention pour les types int√©gr√©s comme :ref:`Camera3D<class_Camera3D>` est que -Z pointe vers l'avant (+X vers la droite, +Y vers le haut, et +Z vers l'arri√®re). D'autres objets peuvent utiliser des conventions de direction diff√©rentes. Pour plus d'informations, voir le tutoriel `Conventions de direction de ressource 3D <../tutorials/assets_pipeline/importing_3d_scenes/model_export_considerations.html#d-asset-direction-conventions>`__.

.. note::

	Il y a des diff√©rences notables dans l'utilisation de cette API en C#. Voir ref:`doc_c_sharp_differences` pour plus d'informations.

.. rst-class:: classref-introduction-group

Tutoriels
------------------

- :doc:`Index de la documentation sur les math√©matiques <../tutorials/math/index>`

- :doc:`Matrices et transformations <../tutorials/math/matrices_and_transforms>`

- :doc:`Utiliser les transformations 3D <../tutorials/3d/using_transforms>`

- `D√©mo de transformation matricielle <https://godotengine.org/asset-library/asset/2787>`__

- `D√©mo de jeu de plateforme en 3D <https://godotengine.org/asset-library/asset/2748>`__

- `D√©mo de jeu 2,5D <https://godotengine.org/asset-library/asset/2783>`__

.. rst-class:: classref-reftable-group

Propri√©t√©s
--------------------

.. table::
   :widths: auto

   +-------------------------------+--------------------------------------------------+--------------------------------------+
   | :ref:`Basis<class_Basis>`     | :ref:`basis<class_Transform3D_property_basis>`   | ``Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)`` |
   +-------------------------------+--------------------------------------------------+--------------------------------------+
   | :ref:`Vector3<class_Vector3>` | :ref:`origin<class_Transform3D_property_origin>` | ``Vector3(0, 0, 0)``                 |
   +-------------------------------+--------------------------------------------------+--------------------------------------+

.. rst-class:: classref-reftable-group

Constructeurs
--------------------------

.. table::
   :widths: auto

   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`Transform3D<class_Transform3D_constructor_Transform3D>`\ (\ )                                                                                                                                                                 |
   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`Transform3D<class_Transform3D_constructor_Transform3D>`\ (\ from\: :ref:`Transform3D<class_Transform3D>`\ )                                                                                                                   |
   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`Transform3D<class_Transform3D_constructor_Transform3D>`\ (\ basis\: :ref:`Basis<class_Basis>`, origin\: :ref:`Vector3<class_Vector3>`\ )                                                                                      |
   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`Transform3D<class_Transform3D_constructor_Transform3D>`\ (\ from\: :ref:`Projection<class_Projection>`\ )                                                                                                                     |
   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`Transform3D<class_Transform3D_constructor_Transform3D>`\ (\ x_axis\: :ref:`Vector3<class_Vector3>`, y_axis\: :ref:`Vector3<class_Vector3>`, z_axis\: :ref:`Vector3<class_Vector3>`, origin\: :ref:`Vector3<class_Vector3>`\ ) |
   +---------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-reftable-group

M√©thodes
----------------

.. table::
   :widths: auto

   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`affine_inverse<class_Transform3D_method_affine_inverse>`\ (\ ) |const|                                                                                                                                           |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`interpolate_with<class_Transform3D_method_interpolate_with>`\ (\ xform\: :ref:`Transform3D<class_Transform3D>`, weight\: :ref:`float<class_float>`\ ) |const|                                                    |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`inverse<class_Transform3D_method_inverse>`\ (\ ) |const|                                                                                                                                                         |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`               | :ref:`is_equal_approx<class_Transform3D_method_is_equal_approx>`\ (\ xform\: :ref:`Transform3D<class_Transform3D>`\ ) |const|                                                                                          |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`               | :ref:`is_finite<class_Transform3D_method_is_finite>`\ (\ ) |const|                                                                                                                                                     |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`looking_at<class_Transform3D_method_looking_at>`\ (\ target\: :ref:`Vector3<class_Vector3>`, up\: :ref:`Vector3<class_Vector3>` = Vector3(0, 1, 0), use_model_front\: :ref:`bool<class_bool>` = false\ ) |const| |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`orthonormalized<class_Transform3D_method_orthonormalized>`\ (\ ) |const|                                                                                                                                         |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`rotated<class_Transform3D_method_rotated>`\ (\ axis\: :ref:`Vector3<class_Vector3>`, angle\: :ref:`float<class_float>`\ ) |const|                                                                                |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`rotated_local<class_Transform3D_method_rotated_local>`\ (\ axis\: :ref:`Vector3<class_Vector3>`, angle\: :ref:`float<class_float>`\ ) |const|                                                                    |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`scaled<class_Transform3D_method_scaled>`\ (\ scale\: :ref:`Vector3<class_Vector3>`\ ) |const|                                                                                                                    |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`scaled_local<class_Transform3D_method_scaled_local>`\ (\ scale\: :ref:`Vector3<class_Vector3>`\ ) |const|                                                                                                        |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`translated<class_Transform3D_method_translated>`\ (\ offset\: :ref:`Vector3<class_Vector3>`\ ) |const|                                                                                                           |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>` | :ref:`translated_local<class_Transform3D_method_translated_local>`\ (\ offset\: :ref:`Vector3<class_Vector3>`\ ) |const|                                                                                               |
   +---------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-reftable-group

Op√©rateurs
--------------------

.. table::
   :widths: auto

   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                             | :ref:`operator !=<class_Transform3D_operator_neq_Transform3D>`\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ )                     |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`AABB<class_AABB>`                             | :ref:`operator *<class_Transform3D_operator_mul_AABB>`\ (\ right\: :ref:`AABB<class_AABB>`\ )                                           |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedVector3Array<class_PackedVector3Array>` | :ref:`operator *<class_Transform3D_operator_mul_PackedVector3Array>`\ (\ right\: :ref:`PackedVector3Array<class_PackedVector3Array>`\ ) |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Plane<class_Plane>`                           | :ref:`operator *<class_Transform3D_operator_mul_Plane>`\ (\ right\: :ref:`Plane<class_Plane>`\ )                                        |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>`               | :ref:`operator *<class_Transform3D_operator_mul_Transform3D>`\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ )                      |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Vector3<class_Vector3>`                       | :ref:`operator *<class_Transform3D_operator_mul_Vector3>`\ (\ right\: :ref:`Vector3<class_Vector3>`\ )                                  |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>`               | :ref:`operator *<class_Transform3D_operator_mul_float>`\ (\ right\: :ref:`float<class_float>`\ )                                        |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>`               | :ref:`operator *<class_Transform3D_operator_mul_int>`\ (\ right\: :ref:`int<class_int>`\ )                                              |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>`               | :ref:`operator /<class_Transform3D_operator_div_float>`\ (\ right\: :ref:`float<class_float>`\ )                                        |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Transform3D<class_Transform3D>`               | :ref:`operator /<class_Transform3D_operator_div_int>`\ (\ right\: :ref:`int<class_int>`\ )                                              |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                             | :ref:`operator ==<class_Transform3D_operator_eq_Transform3D>`\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ )                      |
   +-----------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Constantes
--------------------

.. _class_Transform3D_constant_IDENTITY:

.. rst-class:: classref-constant

**IDENTITY** = ``Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)`` :ref:`üîó<class_Transform3D_constant_IDENTITY>`

La **Transform3D** identit√©. Il s'agit d'une transformation sans translation, sans rotation, et une √©chelle de :ref:`Vector3.ONE<class_Vector3_constant_ONE>`. Sa :ref:`basis<class_Transform3D_property_basis>` est √©gale √† :ref:`Basis.IDENTITY<class_Basis_constant_IDENTITY>`. Cela signifie √©galement que¬†:

- Son :ref:`Basis.x<class_Basis_property_x>` pointe vers la droite (:ref:`Vector3.RIGHT<class_Vector3_constant_RIGHT>`);

- Son :ref:`Basis.y<class_Basis_property_y>` pointe vers le haut (:ref:`Vector3.UP<class_Vector3_constant_UP>`);

- Son :ref:`Basis.z<class_Basis_property_z>` pointe vers l'arri√®re(:ref:`Vector3.BACK<class_Vector3_constant_BACK>`).

::

    var transformation = Transform3D.IDENTITY
    var base = transformation.basis
    print("| X | Y | Z | Origine")
    print("| %.f | %.f | %.f | %.f" % [base.x.x, base.y.x, base.z.x, transform.origin.x])
    print("| %.f | %.f | %.f | %.f" % [base.x.y, base.y.y, base.z.y, transform.origin.y])
    print("| %.f | %.f | %.f | %.f" % [base.x.z, base.y.z, base.z.z, transform.origin.z])
    # Affiche¬†:
    # | X | Y | Z | Origin
    # | 1 | 0 | 0 | 0
    # | 0 | 1 | 0 | 0
    # | 0 | 0 | 1 | 0

Si un :ref:`Vector3<class_Vector3>`, un :ref:`AABB<class_AABB>`, un :ref:`Plane<class_Plane>`, un :ref:`PackedVector3Array<class_PackedVector3Array>`, ou une autre **Transform3D** est transform√© (multipli√©) par cette constante, aucune transformation ne se produit.

\ **Note¬†:** En GDScript, cette constante est √©quivalente √† la cr√©ation d'une :ref:`Transform3D<class_Transform3D_constructor_Transform3D>` sans aucun argument. Elle peut √™tre utilis√©e pour rendre votre code plus clair, et pour la coh√©rence avec le C#.

.. _class_Transform3D_constant_FLIP_X:

.. rst-class:: classref-constant

**FLIP_X** = ``Transform3D(-1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)`` :ref:`üîó<class_Transform3D_constant_FLIP_X>`

**Transform3D** avec effet miroir appliqu√© perpendiculairement au plan YZ. Sa base :ref:`basis<class_Transform3D_property_basis>` est √©gale √† :ref:`Basis.FLIP_X<class_Basis_constant_FLIP_X>`.

.. _class_Transform3D_constant_FLIP_Y:

.. rst-class:: classref-constant

**FLIP_Y** = ``Transform3D(1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0)`` :ref:`üîó<class_Transform3D_constant_FLIP_Y>`

**Transform3D** avec effet miroir appliqu√© perpendiculairement au plan XZ. Sa base :ref:`basis<class_Transform3D_property_basis>` est √©gale √† :ref:`Basis.FLIP_Y<class_Basis_constant_FLIP_Y>`.

.. _class_Transform3D_constant_FLIP_Z:

.. rst-class:: classref-constant

**FLIP_Z** = ``Transform3D(1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0)`` :ref:`üîó<class_Transform3D_constant_FLIP_Z>`

**Transform3D** avec effet miroir appliqu√© perpendiculairement au plan XY. Sa base :ref:`basis<class_Transform3D_property_basis>` est √©gale √† :ref:`Basis.FLIP_Z<class_Basis_constant_FLIP_Z>`.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Descriptions des propri√©t√©s
------------------------------------------------------

.. _class_Transform3D_property_basis:

.. rst-class:: classref-property

:ref:`Basis<class_Basis>` **basis** = ``Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)`` :ref:`üîó<class_Transform3D_property_basis>`

La :ref:`Basis<class_Basis>` de cette transformation. Elle est compos√©e de 3 axes (:ref:`Basis.x<class_Basis_property_x>`, :ref:`Basis.y<class_Basis_property_y>`, et :ref:`Basis.z<class_Basis_property_z>`). Ensemble, ils repr√©sentent la rotation, l'√©chelle et le cisaillement de la transformation.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_property_origin:

.. rst-class:: classref-property

:ref:`Vector3<class_Vector3>` **origin** = ``Vector3(0, 0, 0)`` :ref:`üîó<class_Transform3D_property_origin>`

Le d√©calage de translation de la transformation. Dans l'espace 3D, cela peut √™tre vu comme la position.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Descriptions des constructeurs
------------------------------------------------------------

.. _class_Transform3D_constructor_Transform3D:

.. rst-class:: classref-constructor

:ref:`Transform3D<class_Transform3D>` **Transform3D**\ (\ ) :ref:`üîó<class_Transform3D_constructor_Transform3D>`

Construit une **Transform3D** identique √† :ref:`IDENTITY<class_Transform3D_constant_IDENTITY>`.

\ **Note¬†:** En C#, cela construit une **Transform3D** avec son :ref:`origin<class_Transform3D_property_origin>` et les composantes de sa :ref:`basis<class_Transform3D_property_basis>` d√©finis √† :ref:`Vector3.ZERO<class_Vector3_constant_ZERO>`.

.. rst-class:: classref-item-separator

----

.. rst-class:: classref-constructor

:ref:`Transform3D<class_Transform3D>` **Transform3D**\ (\ from\: :ref:`Transform3D<class_Transform3D>`\ )

Construit une **Transform3D** √† partir de la **Transform3D** donn√©e.

.. rst-class:: classref-item-separator

----

.. rst-class:: classref-constructor

:ref:`Transform3D<class_Transform3D>` **Transform3D**\ (\ basis\: :ref:`Basis<class_Basis>`, origin\: :ref:`Vector3<class_Vector3>`\ )

Construit une **Transform3D** √† partir de la :ref:`Basis<class_Basis>` et du :ref:`Vector3<class_Vector3>` (la position) donn√©s.

.. rst-class:: classref-item-separator

----

.. rst-class:: classref-constructor

:ref:`Transform3D<class_Transform3D>` **Transform3D**\ (\ from\: :ref:`Projection<class_Projection>`\ )

Construit une **Transform3D** depuis une :ref:`Projection<class_Projection>`. Comme **Transform3D** est une matrice 3√ó4 et :ref:`Projection<class_Projection>` est une matrice 4√ó4, cette op√©ration coupe la derni√®re ligne de la matrice de projection (``from.x.w``, ``from.y.w``, ``from.z.w``, et ``from.w.w`` ne sont pas inclus dans la nouvelle transformation).

.. rst-class:: classref-item-separator

----

.. rst-class:: classref-constructor

:ref:`Transform3D<class_Transform3D>` **Transform3D**\ (\ x_axis\: :ref:`Vector3<class_Vector3>`, y_axis\: :ref:`Vector3<class_Vector3>`, z_axis\: :ref:`Vector3<class_Vector3>`, origin\: :ref:`Vector3<class_Vector3>`\ )

Construit une **Transform3D** √† partir de quatre valeurs :ref:`Vector3<class_Vector3>` (√©galement appel√©es colonnes de la matrice).

Les trois premiers arguments sont les axes de :ref:`basis<class_Transform3D_property_basis>` (:ref:`Basis.x<class_Basis_property_x>`, :ref:`Basis.y<class_Basis_property_y>` et :ref:`Basis.z<class_Basis_property_z>`).

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Descriptions des m√©thodes
--------------------------------------------------

.. _class_Transform3D_method_affine_inverse:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **affine_inverse**\ (\ ) |const| :ref:`üîó<class_Transform3D_method_affine_inverse>`

Renvoie la version invers√©e de cette transformation. Contrairement √† :ref:`inverse()<class_Transform3D_method_inverse>`, cette m√©thode fonctionne avec presque n'importe quelle base, y compris les non-uniformes, mais est plus lent. Voir aussi :ref:`Basis.inverse()<class_Basis_method_inverse>`.

\ **Note¬†:** Pour que cette m√©thode puisse se finir correctement, la :ref:`basis<class_Transform3D_property_basis>` de la transformation doit avoir un d√©terminant qui ne vaut pas exactement ``0.0`` (voir :ref:`Basis.determinant()<class_Basis_method_determinant>`).

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_interpolate_with:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **interpolate_with**\ (\ xform\: :ref:`Transform3D<class_Transform3D>`, weight\: :ref:`float<class_float>`\ ) |const| :ref:`üîó<class_Transform3D_method_interpolate_with>`

Renvoie le r√©sultat de l'interpolation lin√©aire entre cette transformation et ``xform`` selon le poids ``weight`` donn√©.

Le poids ``weight`` devrait √™tre compris entre ``0.0`` et ``1.0`` (inclusifs). Les valeurs en dehors de cette plage sont permises et peuvent √™tre utilis√©es pour effectuer √† la place une *extrapolation*.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_inverse:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **inverse**\ (\ ) |const| :ref:`üîó<class_Transform3D_method_inverse>`

Renvoie la `version invers√©e de cette transformation <https://fr.wikipedia.org/wiki/Matrice_inversible>`__. Voir aussi :ref:`Basis.inverse()<class_Basis_method_inverse>`.

\ **Note¬†:** Pour que cette m√©thode puisse se finir correctement, la :ref:`basis<class_Transform3D_property_basis>` de la transformation doit √™tre *orthonorm√©e* (voir :ref:`orthonormalized()<class_Transform3D_method_orthonormalized>`). Cela signifie que la base ne devrait repr√©senter qu'une rotation. Si ce n'est pas le cas, utilisez plut√¥t :ref:`affine_inverse()<class_Transform3D_method_affine_inverse>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_is_equal_approx:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_equal_approx**\ (\ xform\: :ref:`Transform3D<class_Transform3D>`\ ) |const| :ref:`üîó<class_Transform3D_method_is_equal_approx>`

Renvoie ``true`` si cette transformation et ``xform`` sont approximativement √©gales, en utilisant :ref:`@GlobalScope.is_equal_approx()<class_@GlobalScope_method_is_equal_approx>` sur chaque composante.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_is_finite:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_finite**\ (\ ) |const| :ref:`üîó<class_Transform3D_method_is_finite>`

Renvoie ``true`` si cette transformation est finie, en appelant :ref:`@GlobalScope.is_finite()<class_@GlobalScope_method_is_finite>` sur chaque composante.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_looking_at:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **looking_at**\ (\ target\: :ref:`Vector3<class_Vector3>`, up\: :ref:`Vector3<class_Vector3>` = Vector3(0, 1, 0), use_model_front\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`üîó<class_Transform3D_method_looking_at>`

Renvoie une copie de cette transformation tourn√©e de sorte que l'axe avant (-Z) pointe vers la position cible ``target``.

L'axe vers le haut (+Y) pointe aussi pr√®s du vecteur ``up`` que possible tout en restant perpendiculaire √† l'axe avant. La transformation r√©sultante est orthonormalis√©e. L'information existante de rotation, d'√©chelle et de cisaillement de la transformation originale est supprim√©e. Les vecteurs ``target`` et ``up`` ne peuvent √™tre nuls, ne peuvent √™tre parall√®les entre eux, et sont d√©finis dans l'espace global/parent.

Si ``use_model_front`` vaut ``true``, l'axe +Z (axe avant des ressources) est trait√© comme l'avant (implique que +X est la gauche) et pointe vers la position cible ``target``. Par d√©faut, l'axe -Z (avant de la cam√©ra) est trait√© comme l'avant (implique que +X est la droite).

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_orthonormalized:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **orthonormalized**\ (\ ) |const| :ref:`üîó<class_Transform3D_method_orthonormalized>`

Renvoie une copie de cette transformation avec sa :ref:`basis<class_Transform3D_property_basis>` orthonormalis√©e. Une base orthonormale est √† la fois *orthogonale* (les axes sont perpendiculaires les uns aux autres) et *normalis√©e* (les axes ont une longueur de ``1.0``), ce qui signifie √©galement qu'elle ne peut repr√©senter qu'une rotation. Voir aussi :ref:`Basis.orthonormalized()<class_Basis_method_orthonormalized>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_rotated:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **rotated**\ (\ axis\: :ref:`Vector3<class_Vector3>`, angle\: :ref:`float<class_float>`\ ) |const| :ref:`üîó<class_Transform3D_method_rotated>`

Renvoie une copie de cette transformation tourn√©e autour de l'axe ``axis`` donn√© d'un angle ``angle`` donn√© (en radians).

L'axe ``axis`` doit √™tre un vecteur normalis√© (voir :ref:`Vector3.normalized()<class_Vector3_method_normalized>`). Si ``angle`` est positif, la base est tourn√©e dans le sens antihoraire autour de l'axe.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation de rotation ``R`` correspondante sur la gauche, c'est-√†-dire ``R * X``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re global/parent.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_rotated_local:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **rotated_local**\ (\ axis\: :ref:`Vector3<class_Vector3>`, angle\: :ref:`float<class_float>`\ ) |const| :ref:`üîó<class_Transform3D_method_rotated_local>`

Renvoie une copie de cette transformation tourn√©e autour de l'axe ``axis`` donn√© de l'angle ``angle`` donn√© (en radians).

L'axe ``axis`` doit √™tre un vecteur normalis√© dans le syst√®me de coordonn√©es local de la transformation. Par exemple, pour tourner autour de l'axe X local, utilisez :ref:`Vector3.RIGHT<class_Vector3_constant_RIGHT>`.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation de rotation ``R`` correspondante sur la droite, c'est-√†-dire ``X * R``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re local.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_scaled:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **scaled**\ (\ scale\: :ref:`Vector3<class_Vector3>`\ ) |const| :ref:`üîó<class_Transform3D_method_scaled>`

Renvoie une copie de cette transformation redimensionn√©e d'un facteur ``scale`` donn√©.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation d'√©chelle ``S`` correspondante sur la gauche, c'est-√†-dire ``S * X``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re global/parent.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_scaled_local:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **scaled_local**\ (\ scale\: :ref:`Vector3<class_Vector3>`\ ) |const| :ref:`üîó<class_Transform3D_method_scaled_local>`

Renvoie une copie de cette transformation redimensionn√©e d'un facteur ``scale`` donn√©.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation d'√©chelle ``S`` correspondante sur la droite, c'est-√†-dire ``X * S``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re local.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_translated:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **translated**\ (\ offset\: :ref:`Vector3<class_Vector3>`\ ) |const| :ref:`üîó<class_Transform3D_method_translated>`

Renvoie une copie de cette transformation translat√©e d'un d√©calage ``offset`` donn√©.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation de translation ``T`` correspondante sur la gauche, c'est-√†-dire ``T * X``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re global/parent.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_method_translated_local:

.. rst-class:: classref-method

:ref:`Transform3D<class_Transform3D>` **translated_local**\ (\ offset\: :ref:`Vector3<class_Vector3>`\ ) |const| :ref:`üîó<class_Transform3D_method_translated_local>`

Renvoie une copie de cette transformation translat√©e d'un d√©calage ``offset`` donn√©.

Cette m√©thode est une version optimis√©e de la multiplication de la transformation ``X`` donn√©e avec une transformation de translation ``T`` correspondante sur la droite, c'est-√†-dire ``X* T``.

Cela peut √™tre consid√©r√© comme une transformation par rapport au rep√®re local.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Descriptions des op√©rateurs
------------------------------------------------------

.. _class_Transform3D_operator_neq_Transform3D:

.. rst-class:: classref-operator

:ref:`bool<class_bool>` **operator !=**\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ ) :ref:`üîó<class_Transform3D_operator_neq_Transform3D>`

Renvoie ``true`` si les composantes des deux transformations ne sont pas √©gales.

\ **Note¬†:** En raison des erreurs de pr√©cision des flottants, envisagez d'utiliser :ref:`is_equal_approx()<class_Transform3D_method_is_equal_approx>` qui est plus fiable.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_AABB:

.. rst-class:: classref-operator

:ref:`AABB<class_AABB>` **operator ***\ (\ right\: :ref:`AABB<class_AABB>`\ ) :ref:`üîó<class_Transform3D_operator_mul_AABB>`

Transforme (multiplie) cette :ref:`AABB<class_AABB>` par cette matrice de transformation.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_PackedVector3Array:

.. rst-class:: classref-operator

:ref:`PackedVector3Array<class_PackedVector3Array>` **operator ***\ (\ right\: :ref:`PackedVector3Array<class_PackedVector3Array>`\ ) :ref:`üîó<class_Transform3D_operator_mul_PackedVector3Array>`

Transforme (multiplie) chaque √©l√©ment :ref:`Vector3<class_Vector3>` du :ref:`PackedVector3Array<class_PackedVector3Array>` donn√© par cette matrice de transformation.

Sur de plus grands tableaux, cette op√©ration est beaucoup plus rapide que de transformer chaque :ref:`Vector3<class_Vector3>` individuellement.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_Plane:

.. rst-class:: classref-operator

:ref:`Plane<class_Plane>` **operator ***\ (\ right\: :ref:`Plane<class_Plane>`\ ) :ref:`üîó<class_Transform3D_operator_mul_Plane>`

Transforme (multiplie) ce :ref:`Plane<class_Plane>` par cette matrice de transformation.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_Transform3D:

.. rst-class:: classref-operator

:ref:`Transform3D<class_Transform3D>` **operator ***\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ ) :ref:`üîó<class_Transform3D_operator_mul_Transform3D>`

Transforme (multiplie) cette transformation par la transformation ``right``.

C'est l'op√©ration effectu√©e entre les :ref:`Node3D<class_Node3D>`\ s parent et enfant.

\ **Note¬†:** Si vous devez seulement modifier un attribut de cette transformation, envisagez √† la place d'utiliser l'une des m√©thodes suivantes¬†::

- Pour la translation, voir :ref:`translated()<class_Transform3D_method_translated>` ou :ref:`translated_local()<class_Transform3D_method_translated_local>`.

- Pour la rotation, voir :ref:`rotated()<class_Transform3D_method_rotated>` ou :ref:`rotated_local()<class_Transform3D_method_rotated_local>`.

- Pour l'√©chelle, voir :ref:`scaled()<class_Transform3D_method_scaled>` ou :ref:`scaled_local()<class_Transform3D_method_scaled_local>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_Vector3:

.. rst-class:: classref-operator

:ref:`Vector3<class_Vector3>` **operator ***\ (\ right\: :ref:`Vector3<class_Vector3>`\ ) :ref:`üîó<class_Transform3D_operator_mul_Vector3>`

Transforme (multiplie) ce :ref:`Vector3<class_Vector3>` par cette matrice de transformation.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_float:

.. rst-class:: classref-operator

:ref:`Transform3D<class_Transform3D>` **operator ***\ (\ right\: :ref:`float<class_float>`\ ) :ref:`üîó<class_Transform3D_operator_mul_float>`

Multiplie tous les composantes de la **Transform3D** par le :ref:`float<class_float>` donn√©, y compris l'origine :ref:`origin<class_Transform3D_property_origin>`. Cela affecte uniform√©ment l'√©chelle de la transformation, en redimensionnant la :ref:`basis<class_Transform3D_property_basis>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_mul_int:

.. rst-class:: classref-operator

:ref:`Transform3D<class_Transform3D>` **operator ***\ (\ right\: :ref:`int<class_int>`\ ) :ref:`üîó<class_Transform3D_operator_mul_int>`

Multiplie tous les composantes de la **Transform3D** par l':ref:`int<class_int>` donn√©, y compris l'origine :ref:`origin<class_Transform3D_property_origin>`. Cela affecte uniform√©ment l'√©chelle de la transformation, en redimensionnant la :ref:`basis<class_Transform3D_property_basis>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_div_float:

.. rst-class:: classref-operator

:ref:`Transform3D<class_Transform3D>` **operator /**\ (\ right\: :ref:`float<class_float>`\ ) :ref:`üîó<class_Transform3D_operator_div_float>`

Divise tous les composantes de la **Transform3D** par le :ref:`float<class_float>` donn√©, y compris l'origine :ref:`origin<class_Transform3D_property_origin>`. Cela affecte uniform√©ment l'√©chelle de la transformation, en redimensionnant la :ref:`basis<class_Transform3D_property_basis>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_div_int:

.. rst-class:: classref-operator

:ref:`Transform3D<class_Transform3D>` **operator /**\ (\ right\: :ref:`int<class_int>`\ ) :ref:`üîó<class_Transform3D_operator_div_int>`

Divise tous les composantes de la **Transform3D** par le :ref:`int<class_int>` donn√©, y compris l'origine :ref:`origin<class_Transform3D_property_origin>`. Cela affecte uniform√©ment l'√©chelle de la transformation, en redimensionnant la :ref:`basis<class_Transform3D_property_basis>`.

.. rst-class:: classref-item-separator

----

.. _class_Transform3D_operator_eq_Transform3D:

.. rst-class:: classref-operator

:ref:`bool<class_bool>` **operator ==**\ (\ right\: :ref:`Transform3D<class_Transform3D>`\ ) :ref:`üîó<class_Transform3D_operator_eq_Transform3D>`

Renvoie ``true`` si les composantes des deux transformations sont exactement √©gales.

\ **Note¬†:** En raison des erreurs de pr√©cision des flottants, envisagez d'utiliser :ref:`is_equal_approx()<class_Transform3D_method_is_equal_approx>` qui est plus fiable.

.. |virtual| replace:: :abbr:`virtual (Cette m√©thode doit typiquement √™tre red√©finie par l'utilisateur pour avoir un effet.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (Cette m√©thode n'a pas d'effets de bord. Elle ne modifie aucune des variables membres de l'instance.)`
.. |vararg| replace:: :abbr:`vararg (Cette m√©thode accepte n'importe quel nombre d'arguments apr√®s ceux d√©cris ici.)`
.. |constructor| replace:: :abbr:`constructor (Cette m√©thode est utilis√©e pour construire un type.)`
.. |static| replace:: :abbr:`static (Cette m√©thode n'a pas besoin d'instance pour √™tre appel√©e, elle peut donc √™tre directement appel√©e en utilisant le nom de la classe.)`
.. |operator| replace:: :abbr:`operator (Cette m√©thode d√©crit un op√©rateur valide √† utiliser avec ce type en tant qu'op√©rande gauche.)`
.. |bitfield| replace:: :abbr:`BitField (Cette valeur est un nombre entier compos√© d'un masque de bits des options suivantes.)`
.. |void| replace:: :abbr:`void (Aucune valeur de retour.)`
