:github_url: hide

.. _class_Node:

Node
====

**Успадковує:** :ref:`Object<class_Object>`

**Успадковано від:** :ref:`AnimationMixer<class_AnimationMixer>`, :ref:`AudioStreamPlayer<class_AudioStreamPlayer>`, :ref:`CanvasItem<class_CanvasItem>`, :ref:`CanvasLayer<class_CanvasLayer>`, :ref:`EditorFileSystem<class_EditorFileSystem>`, :ref:`EditorPlugin<class_EditorPlugin>`, :ref:`EditorResourcePreview<class_EditorResourcePreview>`, :ref:`HTTPRequest<class_HTTPRequest>`, :ref:`InstancePlaceholder<class_InstancePlaceholder>`, :ref:`MissingNode<class_MissingNode>`, :ref:`MultiplayerSpawner<class_MultiplayerSpawner>`, :ref:`MultiplayerSynchronizer<class_MultiplayerSynchronizer>`, :ref:`NavigationAgent2D<class_NavigationAgent2D>`, :ref:`NavigationAgent3D<class_NavigationAgent3D>`, :ref:`Node3D<class_Node3D>`, :ref:`ResourcePreloader<class_ResourcePreloader>`, :ref:`ShaderGlobalsOverride<class_ShaderGlobalsOverride>`, :ref:`StatusIndicator<class_StatusIndicator>`, :ref:`Timer<class_Timer>`, :ref:`Viewport<class_Viewport>`, :ref:`WorldEnvironment<class_WorldEnvironment>`

Базовий клас для всіх об'єктів сцени.

.. rst-class:: classref-introduction-group

Опис
--------

Вузли є будівельними блоками Godot. Вони можуть бути призначені дочірніми елементами іншого вузла, що призводить до розташування дерева. Даний вузол може містити будь-яку кількість дочірніх вузлів з вимогою, щоб усі рідні вузли (прямі дочірні вузли) мали унікальні імена.

Дерево вузлів називається *сценою*. Сцени можна зберегти на диску, а потім створити екземпляри інших сцен. Це забезпечує дуже високу гнучкість архітектури та моделі даних проектів Godot.

\ **Дерево сцени: ** ``Дерево сцени`` містить активне дерево вузлів. Коли вузол додається до дерева сцени, він отримує сповіщення :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` і запускається його зворотній виклик :ref:`_enter_tree()<class_Node_private_method__enter_tree>`. Дочірні вузли завжди додаються *після* їхнього батьківського вузла, тобто зворотний виклик :ref:`_enter_tree()<class_Node_private_method__enter_tree>` батьківського вузла буде запущено перед дочірнім.

Після додавання всіх вузлів у дерево сцени вони отримують сповіщення :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>` і запускаються відповідні зворотні виклики :ref:`_ready()<class_Node_private_method__ready>`. Для груп вузлів зворотний виклик :ref:`_ready()<class_Node_private_method__ready>` викликається у зворотному порядку, починаючи з дочірніх і просуваючись до батьківських вузлів.

Це означає, що під час додавання вузла до дерева сцени такий порядок буде використано для зворотних викликів: :ref:`_enter_tree()<class_Node_private_method__enter_tree>` батьківського, :ref:`_enter_tree()<class_Node_private_method__enter_tree>` дочірніх, :ref:`_ready()<class_Node_private_method__ready>` дочірніх і, нарешті, :ref:`_ready()<class_Node_private_method__ready>` батьківського (рекурсивно для всього дерева сцени).

\ **Обробка:** Вузли можуть перевизначати стан «процес», щоб вони отримували зворотний виклик у кожному кадрі із запитом на обробку (щось зробити). Звичайна обробка (зворотний виклик :ref:`_process()<class_Node_private_method__process>`, перемикається за допомогою :ref:`set_process()<class_Node_method_set_process>`) відбувається якомога швидше та залежить від частоти кадрів, тому час обробки *delta* (у секундах) передається як аргумент . Фізична обробка (зворотний виклик :ref:`_physics_process()<class_Node_private_method__physics_process>`, перемикається за допомогою :ref:`set_physics_process()<class_Node_method_set_physics_process>`) відбувається фіксовану кількість разів на секунду (за замовчуванням 60) і корисна для коду, пов’язаного з фізичною системою.

Вузли також можуть обробляти вхідні події. Якщо присутня, функція :ref:`_input()<class_Node_private_method__input>` буде викликана для кожного введення, яке отримує програма. У багатьох випадках це може бути надмірним (якщо не використовується для простих проектів), і функція :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` може бути кращою; він викликається, коли вхідна подія не була оброблена ніким іншим (як правило, вузлами GUI :ref:`Control<class_Control>`), гарантуючи, що вузол отримує лише ті події, які призначені для нього.

Щоб відстежувати ієрархію сцен (особливо під час інстанціювання сцен в інші сцени), можна встановити «власника» для вузла за допомогою властивості :ref:`owner<class_Node_property_owner>`. Це відстежує, хто що створив. Однак це здебільшого корисно під час написання редакторів та інструментів.

Нарешті, коли вузол звільняється за допомогою :ref:`Object.free()<class_Object_method_free>` або :ref:`queue_free()<class_Node_method_queue_free>`, він також звільняє всіх своїх дочірніх елементів.

\ **Групи:** Вузли можна додавати до будь-якої кількості груп, щоб ними було легко керувати, ви можете створювати групи, наприклад, «вороги» або «предмети колекціонування», залежно від вашої гри. Див. :ref:`add_to_group()<class_Node_method_add_to_group>`, :ref:`is_in_group()<class_Node_method_is_in_group>` і :ref:`remove_from_group()<class_Node_method_remove_from_group>`. Потім ви можете отримати всі вузли в цих групах, повторити їх і навіть викликати методи в групах за допомогою методів у :ref:`SceneTree<class_SceneTree>`.

\ **Мережа з вузлами:** Після підключення до сервера (або створення такого, див. :ref:`ENetMultiplayerPeer<class_ENetMultiplayerPeer>`) можна використовувати вбудовану систему RPC (віддаленого виклику процедури) для спілкування через мережу. Викликаючи :ref:`rpc()<class_Node_method_rpc>` із назвою методу, він буде викликаний локально та в усіх підключених однорангових вузлах (рівні = клієнти та сервер, який приймає з’єднання). Щоб визначити, який вузол отримує виклик RPC, Godot використовуватиме свій :ref:`NodePath<class_NodePath>` (переконайтеся, що імена вузлів однакові на всіх вузлах). Також перегляньте підручник високого рівня з мереж і відповідні демонстрації.

\ **Примітка.** Властивість ``script`` є частиною класу :ref:`Object<class_Object>`, а не **Node**. Він не відкритий, як більшість властивостей, але має сеттер і геттер (див. :ref:`Object.set_script()<class_Object_method_set_script>` і :ref:`Object.get_script()<class_Object_method_get_script>`).

.. rst-class:: classref-introduction-group

Посібники
------------------

- :doc:`Вузли та сцени <../getting_started/step_by_step/nodes_and_scenes>`

- `Всі демо <https://github.com/godotengine/godot-demo-projects/>`__

.. rst-class:: classref-reftable-group

Властивості
----------------------

.. table::
   :widths: auto

   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>`                       | :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`               | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`String<class_String>`                                                 | :ref:`editor_description<class_Node_property_editor_description>`                 | ``""``    |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`MultiplayerAPI<class_MultiplayerAPI>`                                 | :ref:`multiplayer<class_Node_property_multiplayer>`                               |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`StringName<class_StringName>`                                         | :ref:`name<class_Node_property_name>`                                             |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`Node<class_Node>`                                                     | :ref:`owner<class_Node_property_owner>`                                           |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>`         | :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`ProcessMode<enum_Node_ProcessMode>`                                   | :ref:`process_mode<class_Node_property_process_mode>`                             | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_physics_priority<class_Node_property_process_physics_priority>`     | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_priority<class_Node_property_process_priority>`                     | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>`                     | :ref:`process_thread_group<class_Node_property_process_thread_group>`             | ``0``     |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`int<class_int>`                                                       | :ref:`process_thread_group_order<class_Node_property_process_thread_group_order>` |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] | :ref:`process_thread_messages<class_Node_property_process_thread_messages>`       |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`String<class_String>`                                                 | :ref:`scene_file_path<class_Node_property_scene_file_path>`                       |           |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+
   | :ref:`bool<class_bool>`                                                     | :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`             | ``false`` |
   +-----------------------------------------------------------------------------+-----------------------------------------------------------------------------------+-----------+

.. rst-class:: classref-reftable-group

Методи
------------

.. table::
   :widths: auto

   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_enter_tree<class_Node_private_method__enter_tree>`\ (\ ) |virtual|                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_exit_tree<class_Node_private_method__exit_tree>`\ (\ ) |virtual|                                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedStringArray<class_PackedStringArray>`                | :ref:`_get_accessibility_configuration_warnings<class_Node_private_method__get_accessibility_configuration_warnings>`\ (\ ) |virtual| |const|                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedStringArray<class_PackedStringArray>`                | :ref:`_get_configuration_warnings<class_Node_private_method__get_configuration_warnings>`\ (\ ) |virtual| |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`RID<class_RID>`                                            | :ref:`_get_focused_accessibility_element<class_Node_private_method__get_focused_accessibility_element>`\ (\ ) |virtual| |const|                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_input<class_Node_private_method__input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_physics_process<class_Node_private_method__physics_process>`\ (\ delta\: :ref:`float<class_float>`\ ) |virtual|                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_process<class_Node_private_method__process>`\ (\ delta\: :ref:`float<class_float>`\ ) |virtual|                                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_ready<class_Node_private_method__ready>`\ (\ ) |virtual|                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_shortcut_input<class_Node_private_method__shortcut_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                          |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_unhandled_input<class_Node_private_method__unhandled_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`_unhandled_key_input<class_Node_private_method__unhandled_key_input>`\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual|                                                                                                |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_child<class_Node_method_add_child>`\ (\ node\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false, internal\: :ref:`InternalMode<enum_Node_InternalMode>` = 0\ )                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_sibling<class_Node_method_add_sibling>`\ (\ sibling\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false\ )                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`add_to_group<class_Node_method_add_to_group>`\ (\ group\: :ref:`StringName<class_StringName>`, persistent\: :ref:`bool<class_bool>` = false\ )                                                                                    |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`atr<class_Node_method_atr>`\ (\ message\: :ref:`String<class_String>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const|                                                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`atr_n<class_Node_method_atr_n>`\ (\ message\: :ref:`String<class_String>`, plural_message\: :ref:`StringName<class_StringName>`, n\: :ref:`int<class_int>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const|         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`call_deferred_thread_group<class_Node_method_call_deferred_thread_group>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`call_thread_safe<class_Node_method_call_thread_safe>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`can_auto_translate<class_Node_method_can_auto_translate>`\ (\ ) |const|                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`can_process<class_Node_method_can_process>`\ (\ ) |const|                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Tween<class_Tween>`                                        | :ref:`create_tween<class_Node_method_create_tween>`\ (\ )                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`duplicate<class_Node_method_duplicate>`\ (\ flags\: :ref:`int<class_int>` = 15\ ) |const|                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`find_child<class_Node_method_find_child>`\ (\ pattern\: :ref:`String<class_String>`, recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const|                                                |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\]             | :ref:`find_children<class_Node_method_find_children>`\ (\ pattern\: :ref:`String<class_String>`, type\: :ref:`String<class_String>` = "", recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`find_parent<class_Node_method_find_parent>`\ (\ pattern\: :ref:`String<class_String>`\ ) |const|                                                                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`RID<class_RID>`                                            | :ref:`get_accessibility_element<class_Node_method_get_accessibility_element>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_child<class_Node_method_get_child>`\ (\ idx\: :ref:`int<class_int>`, include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_child_count<class_Node_method_get_child_count>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\]             | :ref:`get_children<class_Node_method_get_children>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`StringName<class_StringName>`\] | :ref:`get_groups<class_Node_method_get_groups>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_index<class_Node_method_get_index>`\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Window<class_Window>`                                      | :ref:`get_last_exclusive_window<class_Node_method_get_last_exclusive_window>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`int<class_int>`                                            | :ref:`get_multiplayer_authority<class_Node_method_get_multiplayer_authority>`\ (\ ) |const|                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_node<class_Node_method_get_node>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`                                        | :ref:`get_node_and_resource<class_Node_method_get_node_and_resource>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ )                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_node_or_null<class_Node_method_get_node_or_null>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Variant<class_Variant>`                                    | :ref:`get_node_rpc_config<class_Node_method_get_node_rpc_config>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Array<class_Array>`\[:ref:`int<class_int>`\]               | :ref:`get_orphan_node_ids<class_Node_method_get_orphan_node_ids>`\ (\ ) |static|                                                                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Node<class_Node>`                                          | :ref:`get_parent<class_Node_method_get_parent>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`NodePath<class_NodePath>`                                  | :ref:`get_path<class_Node_method_get_path>`\ (\ ) |const|                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`NodePath<class_NodePath>`                                  | :ref:`get_path_to<class_Node_method_get_path_to>`\ (\ node\: :ref:`Node<class_Node>`, use_unique_path\: :ref:`bool<class_bool>` = false\ ) |const|                                                                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`float<class_float>`                                        | :ref:`get_physics_process_delta_time<class_Node_method_get_physics_process_delta_time>`\ (\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`float<class_float>`                                        | :ref:`get_process_delta_time<class_Node_method_get_process_delta_time>`\ (\ ) |const|                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`get_scene_instance_load_placeholder<class_Node_method_get_scene_instance_load_placeholder>`\ (\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`SceneTree<class_SceneTree>`                                | :ref:`get_tree<class_Node_method_get_tree>`\ (\ ) |const|                                                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`get_tree_string<class_Node_method_get_tree_string>`\ (\ )                                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`String<class_String>`                                      | :ref:`get_tree_string_pretty<class_Node_method_get_tree_string_pretty>`\ (\ )                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Viewport<class_Viewport>`                                  | :ref:`get_viewport<class_Node_method_get_viewport>`\ (\ ) |const|                                                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Window<class_Window>`                                      | :ref:`get_window<class_Node_method_get_window>`\ (\ ) |const|                                                                                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`has_node<class_Node_method_has_node>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`has_node_and_resource<class_Node_method_has_node_and_resource>`\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const|                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_ancestor_of<class_Node_method_is_ancestor_of>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_displayed_folded<class_Node_method_is_displayed_folded>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_editable_instance<class_Node_method_is_editable_instance>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_greater_than<class_Node_method_is_greater_than>`\ (\ node\: :ref:`Node<class_Node>`\ ) |const|                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_in_group<class_Node_method_is_in_group>`\ (\ group\: :ref:`StringName<class_StringName>`\ ) |const|                                                                                                                            |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_inside_tree<class_Node_method_is_inside_tree>`\ (\ ) |const|                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_multiplayer_authority<class_Node_method_is_multiplayer_authority>`\ (\ ) |const|                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_node_ready<class_Node_method_is_node_ready>`\ (\ ) |const|                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_part_of_edited_scene<class_Node_method_is_part_of_edited_scene>`\ (\ ) |const|                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_interpolated<class_Node_method_is_physics_interpolated>`\ (\ ) |const|                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_interpolated_and_enabled<class_Node_method_is_physics_interpolated_and_enabled>`\ (\ ) |const|                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_processing<class_Node_method_is_physics_processing>`\ (\ ) |const|                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_physics_processing_internal<class_Node_method_is_physics_processing_internal>`\ (\ ) |const|                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing<class_Node_method_is_processing>`\ (\ ) |const|                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_input<class_Node_method_is_processing_input>`\ (\ ) |const|                                                                                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_internal<class_Node_method_is_processing_internal>`\ (\ ) |const|                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_shortcut_input<class_Node_method_is_processing_shortcut_input>`\ (\ ) |const|                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_unhandled_input<class_Node_method_is_processing_unhandled_input>`\ (\ ) |const|                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`bool<class_bool>`                                          | :ref:`is_processing_unhandled_key_input<class_Node_method_is_processing_unhandled_key_input>`\ (\ ) |const|                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`move_child<class_Node_method_move_child>`\ (\ child_node\: :ref:`Node<class_Node>`, to_index\: :ref:`int<class_int>`\ )                                                                                                           |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`notify_deferred_thread_group<class_Node_method_notify_deferred_thread_group>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`notify_thread_safe<class_Node_method_notify_thread_safe>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_orphan_nodes<class_Node_method_print_orphan_nodes>`\ (\ ) |static|                                                                                                                                                          |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_tree<class_Node_method_print_tree>`\ (\ )                                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`print_tree_pretty<class_Node_method_print_tree_pretty>`\ (\ )                                                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`propagate_call<class_Node_method_propagate_call>`\ (\ method\: :ref:`StringName<class_StringName>`, args\: :ref:`Array<class_Array>` = [], parent_first\: :ref:`bool<class_bool>` = false\ )                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`propagate_notification<class_Node_method_propagate_notification>`\ (\ what\: :ref:`int<class_int>`\ )                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`queue_accessibility_update<class_Node_method_queue_accessibility_update>`\ (\ )                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`queue_free<class_Node_method_queue_free>`\ (\ )                                                                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`remove_child<class_Node_method_remove_child>`\ (\ node\: :ref:`Node<class_Node>`\ )                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`remove_from_group<class_Node_method_remove_from_group>`\ (\ group\: :ref:`StringName<class_StringName>`\ )                                                                                                                        |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`reparent<class_Node_method_reparent>`\ (\ new_parent\: :ref:`Node<class_Node>`, keep_global_transform\: :ref:`bool<class_bool>` = true\ )                                                                                         |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`replace_by<class_Node_method_replace_by>`\ (\ node\: :ref:`Node<class_Node>`, keep_groups\: :ref:`bool<class_bool>` = false\ )                                                                                                    |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`request_ready<class_Node_method_request_ready>`\ (\ )                                                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`\ (\ )                                                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`                            | :ref:`rpc<class_Node_method_rpc>`\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`rpc_config<class_Node_method_rpc_config>`\ (\ method\: :ref:`StringName<class_StringName>`, config\: :ref:`Variant<class_Variant>`\ )                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`                            | :ref:`rpc_id<class_Node_method_rpc_id>`\ (\ peer_id\: :ref:`int<class_int>`, method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg|                                                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_deferred_thread_group<class_Node_method_set_deferred_thread_group>`\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ )                                                              |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_display_folded<class_Node_method_set_display_folded>`\ (\ fold\: :ref:`bool<class_bool>`\ )                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_editable_instance<class_Node_method_set_editable_instance>`\ (\ node\: :ref:`Node<class_Node>`, is_editable\: :ref:`bool<class_bool>`\ )                                                                                      |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_multiplayer_authority<class_Node_method_set_multiplayer_authority>`\ (\ id\: :ref:`int<class_int>`, recursive\: :ref:`bool<class_bool>` = true\ )                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_physics_process<class_Node_method_set_physics_process>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_physics_process_internal<class_Node_method_set_physics_process_internal>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process<class_Node_method_set_process>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_input<class_Node_method_set_process_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                                   |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_internal<class_Node_method_set_process_internal>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_shortcut_input<class_Node_method_set_process_shortcut_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                                 |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_unhandled_input<class_Node_method_set_process_unhandled_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                               |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_process_unhandled_key_input<class_Node_method_set_process_unhandled_key_input>`\ (\ enable\: :ref:`bool<class_bool>`\ )                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_scene_instance_load_placeholder<class_Node_method_set_scene_instance_load_placeholder>`\ (\ load_placeholder\: :ref:`bool<class_bool>`\ )                                                                                     |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_thread_safe<class_Node_method_set_thread_safe>`\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ )                                                                                  |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`set_translation_domain_inherited<class_Node_method_set_translation_domain_inherited>`\ (\ )                                                                                                                                       |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                                           | :ref:`update_configuration_warnings<class_Node_method_update_configuration_warnings>`\ (\ )                                                                                                                                             |
   +------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Сигнали
--------------

.. _class_Node_signal_child_entered_tree:

.. rst-class:: classref-signal

**child_entered_tree**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_child_entered_tree>`

Випробувано, коли дитина ``node`` входить до :ref:`SceneTree<class_SceneTree>`, як правило, тому що цей вузол увійшов в дерево (див. :ref:`Tree_entered<class_Node_signal_Tree_entered>`), або :ref:`add_child()<class_Node_method_add_child>` був викликаний.

Цей сигнал видається *після*, власне дочірня вершина :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` і :ref:`Tree_entered<class_Node_signal_Tree_entered>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_child_exiting_tree:

.. rst-class:: classref-signal

**child_exiting_tree**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_child_exiting_tree>`

Припустимо, коли дитина ``node`` є про вихід :ref:`SceneTree<class_SceneTree>`, як правило, тому що цей вузол виходить на дерево (див. :ref:`tree_exiting<class_Node_signal_tree_exiting>`), або тому що дитина ``node`` видаляється або звільняється.

При отриманні цього сигналу дитина ``node`` ще доступна всередині дерева. Цей сигнал видається *після*, власне дочірня вершина :ref:`tree_exiting<class_Node_signal_tree_exiting>` і :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_child_order_changed:

.. rst-class:: classref-signal

**child_order_changed**\ (\ ) :ref:`🔗<class_Node_signal_child_order_changed>`

При зміні переліку дітей. Це відбувається при додаванні дочірніх вузлів, переміщення або видаленні.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_editor_description_changed:

.. rst-class:: classref-signal

**editor_description_changed**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_editor_description_changed>`

Увімкнено, коли поле опису вершини змінено.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_editor_state_changed:

.. rst-class:: classref-signal

**editor_state_changed**\ (\ ) :ref:`🔗<class_Node_signal_editor_state_changed>`

Видається, коли змінюється атрибут вузла, який має відношення до редактора. Видається тільки в редакторі.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_ready:

.. rst-class:: classref-signal

**ready**\ (\ ) :ref:`🔗<class_Node_signal_ready>`

Увімкнено, коли вузол вважається готовим, після :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_renamed:

.. rst-class:: classref-signal

**renamed**\ (\ ) :ref:`🔗<class_Node_signal_renamed>`

Увімкнено, якщо вершина знаходиться всередині дерева.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_replacing_by:

.. rst-class:: classref-signal

**replacing_by**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_signal_replacing_by>`

Увімкнено, коли цей вузол замінюється ``node``, див. :ref:`replace_by()<class_Node_method_replace_by>`.

Цей сигнал видається *після* ``node`` був доданий як дитина оригінального материнського вузла, але *before* всі оригінальні дочірні вершини були відремонтовані до ``node``.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_entered:

.. rst-class:: classref-signal

**tree_entered**\ (\ ) :ref:`🔗<class_Node_signal_tree_entered>`

Випробувано, коли вершина надходить в дерево.

Цей сигнал видається * після * пов'язаний :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` повідомлення.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_exited:

.. rst-class:: classref-signal

**tree_exited**\ (\ ) :ref:`🔗<class_Node_signal_tree_exited>`

Випробувано після виходу вершини дерева і більше не діє.

Цей сигнал видається *після* пов'язаний :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>` повідомлення.

.. rst-class:: classref-item-separator

----

.. _class_Node_signal_tree_exiting:

.. rst-class:: classref-signal

**tree_exiting**\ (\ ) :ref:`🔗<class_Node_signal_tree_exiting>`

Випробувано, коли вершина просто про вихід з дерева. вузол все ще діє. Так, це правильне місце для деінтиціалізації (або «деструктор», якщо ви будете).

Цей сигнал видається *після* вершина :ref:`_exit_tree()<class_Node_private_method__exit_tree>`, і *before* пов'язаний :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>`.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Переліки
----------------

.. _enum_Node_ProcessMode:

.. rst-class:: classref-enumeration

enum **ProcessMode**: :ref:`🔗<enum_Node_ProcessMode>`

.. _class_Node_constant_PROCESS_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_INHERIT** = ``0``

Досліди ``пам'ятний процес_mode`` з батька вершини. Це за замовчуванням для будь-якого новоствореного вузла.

.. _class_Node_constant_PROCESS_MODE_PAUSABLE:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_PAUSABLE** = ``1``

``true``. Це інверс :ref:`PROCESS_MODE_WHEN_PAUSED<class_Node_constant_PROCESS_MODE_WHEN_PAUSED>`, і за замовчуванням для кореневого вузла.

.. _class_Node_constant_PROCESS_MODE_WHEN_PAUSED:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_WHEN_PAUSED** = ``2``

Обробляти **тільки** тоді, коли :ref:`SceneTree.paused<class_SceneTree_property_paused>` має значення ``true``. Це інверсія :ref:`PROCESS_MODE_PAUSABLE<class_Node_constant_PROCESS_MODE_PAUSABLE>`.

.. _class_Node_constant_PROCESS_MODE_ALWAYS:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_ALWAYS** = ``3``

Завжди обробляти. Продовжує обробку, ігноруючи :ref:`SceneTree.paused<class_SceneTree_property_paused>`. Це інверсія до :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_PROCESS_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessMode<enum_Node_ProcessMode>` **PROCESS_MODE_DISABLED** = ``4``

Ніколи не обробляти. Повністю вимикає обробку, ігноруючи :ref:`SceneTree.paused<class_SceneTree_property_paused>`. Це інверсія до :ref:`PROCESS_MODE_ALWAYS<class_Node_constant_PROCESS_MODE_ALWAYS>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_ProcessThreadGroup:

.. rst-class:: classref-enumeration

enum **ProcessThreadGroup**: :ref:`🔗<enum_Node_ProcessThreadGroup>`

.. _class_Node_constant_PROCESS_THREAD_GROUP_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_INHERIT** = ``0``

Обробляємо цю вершину на основі групового режиму першої батьківської (або грандіозної) вершини, яка має режим групи ниток, який не спадкоємний. Див. :ref:`process_thread_group<class_Node_property_process_thread_group>` для отримання додаткової інформації.

.. _class_Node_constant_PROCESS_THREAD_GROUP_MAIN_THREAD:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_MAIN_THREAD** = ``1``

Обробляємо цей вузол (і дочірні вузли встановлюються до спадку) на головній нитки. Див. :ref:`process_thread_group<class_Node_property_process_thread_group>` для отримання додаткової інформації.

.. _class_Node_constant_PROCESS_THREAD_GROUP_SUB_THREAD:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **PROCESS_THREAD_GROUP_SUB_THREAD** = ``2``

Обробляємо цей вузол (і дочірні вузли, встановлені до спадку) на підзаголовку. Див. :ref:`process_thread_group<class_Node_property_process_thread_group>` для отримання додаткової інформації.

.. rst-class:: classref-item-separator

----

.. _enum_Node_ProcessThreadMessages:

.. rst-class:: classref-enumeration

flags **ProcessThreadMessages**: :ref:`🔗<enum_Node_ProcessThreadMessages>`

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES** = ``1``

Дозволяє цю вершину обробляти різьблені повідомлення, створені за допомогою :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` прямо перед :ref:`_process()<class_Node_private_method__process>`.

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES_PHYSICS:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES_PHYSICS** = ``2``

Дозволяє цьому вузлу обробляти потокові повідомлення, створені за допомогою методу :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` безпосередньо перед викликом методу :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. _class_Node_constant_FLAG_PROCESS_THREAD_MESSAGES_ALL:

.. rst-class:: classref-enumeration-constant

:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>` **FLAG_PROCESS_THREAD_MESSAGES_ALL** = ``3``

Дозволяє цьому вузлу обробляти потокові повідомлення, створені за допомогою методу :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` безпосередньо перед викликом методу :ref:`_process()<class_Node_private_method__process>` або методу :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_PhysicsInterpolationMode:

.. rst-class:: classref-enumeration

enum **PhysicsInterpolationMode**: :ref:`🔗<enum_Node_PhysicsInterpolationMode>`

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_INHERIT** = ``0``

Успадковує :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` від батьківського вузла. Це значення за замовчуванням для будь-якого щойно створеного вузла.

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_ON:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_ON** = ``1``

Вмикає інтерполяцію фізики для цього вузла та для дочірніх вузлів, встановлених на :ref:`PHYSICS_INTERPOLATION_MODE_INHERIT<class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT>`. Це значення за замовчуванням для кореневого вузла.

.. _class_Node_constant_PHYSICS_INTERPOLATION_MODE_OFF:

.. rst-class:: classref-enumeration-constant

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **PHYSICS_INTERPOLATION_MODE_OFF** = ``2``

Вимикає інтерполяцію фізики для цього вузла та для дочірніх вузлів, встановлених на :ref:`PHYSICS_INTERPOLATION_MODE_INHERIT<class_Node_constant_PHYSICS_INTERPOLATION_MODE_INHERIT>`.

.. rst-class:: classref-item-separator

----

.. _enum_Node_DuplicateFlags:

.. rst-class:: classref-enumeration

enum **DuplicateFlags**: :ref:`🔗<enum_Node_DuplicateFlags>`

.. _class_Node_constant_DUPLICATE_SIGNALS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_SIGNALS** = ``1``

Продублювати сигнальні з'єднання вузла, які підключені за допомогою прапорця :ref:`Object.CONNECT_PERSIST<class_Object_constant_CONNECT_PERSIST>`.

.. _class_Node_constant_DUPLICATE_GROUPS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_GROUPS** = ``2``

Дублюйте групи вузлів.

.. _class_Node_constant_DUPLICATE_SCRIPTS:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_SCRIPTS** = ``4``

Дублікат сценарію вершини (також переймаючи дубліковані дитячі скрипти, якщо поєднується з :ref:`DUPLICATE_USE_INSTANTIATION<class_Node_constant_DUPLICATE_USE_INSTANTIATION>`).

.. _class_Node_constant_DUPLICATE_USE_INSTANTIATION:

.. rst-class:: classref-enumeration-constant

:ref:`DuplicateFlags<enum_Node_DuplicateFlags>` **DUPLICATE_USE_INSTANTIATION** = ``8``

Дублюйте за допомогою :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>`. Якщо вузол походить зі сцени, збереженої на диску, повторно використовує :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>` як основу для дубльованого вузла та його дочірніх елементів.

.. rst-class:: classref-item-separator

----

.. _enum_Node_InternalMode:

.. rst-class:: classref-enumeration

enum **InternalMode**: :ref:`🔗<enum_Node_InternalMode>`

.. _class_Node_constant_INTERNAL_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_DISABLED** = ``0``

Вузол не буде внутрішнім.

.. _class_Node_constant_INTERNAL_MODE_FRONT:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_FRONT** = ``1``

На початку батьківських дітей буде розміщено вершину, перед будь-яким незворотним рухом.

.. _class_Node_constant_INTERNAL_MODE_BACK:

.. rst-class:: classref-enumeration-constant

:ref:`InternalMode<enum_Node_InternalMode>` **INTERNAL_MODE_BACK** = ``2``

Наприкінці батьківських дітей буде розміщено вершину, після будь-яких неінтерналних дробів.

.. rst-class:: classref-item-separator

----

.. _enum_Node_AutoTranslateMode:

.. rst-class:: classref-enumeration

enum **AutoTranslateMode**: :ref:`🔗<enum_Node_AutoTranslateMode>`

.. _class_Node_constant_AUTO_TRANSLATE_MODE_INHERIT:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_INHERIT** = ``0``

Довідники :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>` з батька вершини. Це за замовчуванням для будь-якого новоствореного вузла.

.. _class_Node_constant_AUTO_TRANSLATE_MODE_ALWAYS:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_ALWAYS** = ``1``

Завжди автоматично перевести. Це інверс :ref:`AUTO_TRANSLATE_MODE_DISABLED<class_Node_constant_AUTO_TRANSLATE_MODE_DISABLED>`, і за замовчуванням для кореневого вузла.

.. _class_Node_constant_AUTO_TRANSLATE_MODE_DISABLED:

.. rst-class:: classref-enumeration-constant

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **AUTO_TRANSLATE_MODE_DISABLED** = ``2``

Ніколи не перевести. :ref:`AUTO_TRANSLATE_MODE_ALWAYS<class_Node_constant_AUTO_TRANSLATE_MODE_ALWAYS>`.

Для цього вузла та дітей, які встановлюються до :ref:`AUTO_TRANSLATE_MODE_INHERIT<class_Node_constant_AUTO_TRANSLATE_MODE_INHERIT>`.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Константи
------------------

.. _class_Node_constant_NOTIFICATION_ENTER_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_ENTER_TREE** = ``10`` :ref:`🔗<class_Node_constant_NOTIFICATION_ENTER_TREE>`

Повідомлення отримано при вході в вузол :ref:`SceneTree<class_SceneTree>`. Див. :ref:`_enter_tree()<class_Node_private_method__enter_tree>`.

Це повідомлення надійшло *before* пов'язаного :ref:`tree_entered<class_Node_signal_tree_entered>` сигналу.

.. _class_Node_constant_NOTIFICATION_EXIT_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_EXIT_TREE** = ``11`` :ref:`🔗<class_Node_constant_NOTIFICATION_EXIT_TREE>`

Повідомлення отримано при виході з вузла :ref:`SceneTree<class_SceneTree>`. Див. :ref:`_enter_tree()<class_Node_private_method__enter_tree>`\ 

Це повідомлення надійшло *після* пов'язаного :ref:`tree_exiting<class_Node_signal_tree_exiting>` сигналу.

.. _class_Node_constant_NOTIFICATION_MOVED_IN_PARENT:

.. rst-class:: classref-constant

**NOTIFICATION_MOVED_IN_PARENT** = ``12`` :ref:`🔗<class_Node_constant_NOTIFICATION_MOVED_IN_PARENT>`

**Застаріло:** This notification is no longer sent by the engine. Use :ref:`NOTIFICATION_CHILD_ORDER_CHANGED<class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED>` instead.



.. _class_Node_constant_NOTIFICATION_READY:

.. rst-class:: classref-constant

**NOTIFICATION_READY** = ``13`` :ref:`🔗<class_Node_constant_NOTIFICATION_READY>`

Сповіщення отримано, коли вузол готовий. Див. :ref:`_ready()<class_Node_private_method__ready>`.

.. _class_Node_constant_NOTIFICATION_PAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_PAUSED** = ``14`` :ref:`🔗<class_Node_constant_NOTIFICATION_PAUSED>`

Сповіщення отримано, коли вузол призупинено. Див. :ref:`process_mode<class_Node_property_process_mode>`.

.. _class_Node_constant_NOTIFICATION_UNPAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_UNPAUSED** = ``15`` :ref:`🔗<class_Node_constant_NOTIFICATION_UNPAUSED>`

Сповіщення отримано, коли вузол відновлено. Див. :ref:`process_mode<class_Node_property_process_mode>`.

.. _class_Node_constant_NOTIFICATION_PHYSICS_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_PHYSICS_PROCESS** = ``16`` :ref:`🔗<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`

Сповіщення, отримане від дерева, надходить у кожному фізичному кадрі, коли :ref:`is_physics_processing()<class_Node_method_is_physics_processing>` повертає ``true``. Див. :ref:`_physics_process()<class_Node_private_method__physics_process>`.

.. _class_Node_constant_NOTIFICATION_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_PROCESS** = ``17`` :ref:`🔗<class_Node_constant_NOTIFICATION_PROCESS>`

Сповіщення, отримане від дерева, надходить у кожному відрендереному кадрі, коли :ref:`is_processing()<class_Node_method_is_processing>` повертає ``true``. Див. :ref:`_process()<class_Node_private_method__process>`.

.. _class_Node_constant_NOTIFICATION_PARENTED:

.. rst-class:: classref-constant

**NOTIFICATION_PARENTED** = ``18`` :ref:`🔗<class_Node_constant_NOTIFICATION_PARENTED>`

Сповіщення отримано, коли вузол встановлено як дочірній елемент іншого вузла (див. :ref:`add_child()<class_Node_method_add_child>` та :ref:`add_sibling()<class_Node_method_add_sibling>`).

\ **Примітка:** Це *не* означає, що вузол увійшов до :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_UNPARENTED:

.. rst-class:: classref-constant

**NOTIFICATION_UNPARENTED** = ``19`` :ref:`🔗<class_Node_constant_NOTIFICATION_UNPARENTED>`

Сповіщення отримано, коли батьківський вузол викликає метод :ref:`remove_child()<class_Node_method_remove_child>` на цьому вузлі.

\ **Примітка:** Це *не* означає, що вузол вийшов з :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_SCENE_INSTANTIATED:

.. rst-class:: classref-constant

**NOTIFICATION_SCENE_INSTANTIATED** = ``20`` :ref:`🔗<class_Node_constant_NOTIFICATION_SCENE_INSTANTIATED>`

Повідомлення отримано *only* за допомогою нововведеньої кореневої вершини сцени, коли :ref:`PackedScene.instantiate()<class_PackedScene_method_instantiate>` завершено.

.. _class_Node_constant_NOTIFICATION_DRAG_BEGIN:

.. rst-class:: classref-constant

**NOTIFICATION_DRAG_BEGIN** = ``21`` :ref:`🔗<class_Node_constant_NOTIFICATION_DRAG_BEGIN>`

Повідомлення, отримане при старті перетягування. Всі вузли отримують це повідомлення, не тільки перетягування.

Може бути запущений як шляхом перетягування :ref:`Control<class_Control>`, що забезпечує перетягування даних (див. :ref:`Control._get_drag_data()<class_Control_private_method__get_drag_data>`) або за допомогою :ref:`Control.force_drag()<class_Control_method_force_drag>`.

Використовуйте :ref:`Viewport.gui_get_drag_data()<class_Viewport_method_gui_get_drag_data>` для отримання перетягування даних.

.. _class_Node_constant_NOTIFICATION_DRAG_END:

.. rst-class:: classref-constant

**NOTIFICATION_DRAG_END** = ``22`` :ref:`🔗<class_Node_constant_NOTIFICATION_DRAG_END>`

Повідомлення отримано після закінчення операції перетягування.

Використовуйте :ref:`Viewport.gui_is_drag_successful()<class_Viewport_method_gui_is_drag_successful>`, щоб перевірити, чи вдалося перетягнути.

.. _class_Node_constant_NOTIFICATION_PATH_RENAMED:

.. rst-class:: classref-constant

**NOTIFICATION_PATH_RENAMED** = ``23`` :ref:`🔗<class_Node_constant_NOTIFICATION_PATH_RENAMED>`

Сповіщення надходить, коли змінюється :ref:`name<class_Node_property_name>` вузла або :ref:`name<class_Node_property_name>` одного з його предків. Це сповіщення *ні* надходить, коли вузол видаляється з :ref:`SceneTree<class_SceneTree>`.

.. _class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_CHILD_ORDER_CHANGED** = ``24`` :ref:`🔗<class_Node_constant_NOTIFICATION_CHILD_ORDER_CHANGED>`

Повідомлення, отримане при зміні списку дітей. Це відбувається при додаванні дочірніх вузлів, переміщення або видаленні.

.. _class_Node_constant_NOTIFICATION_INTERNAL_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_INTERNAL_PROCESS** = ``25`` :ref:`🔗<class_Node_constant_NOTIFICATION_INTERNAL_PROCESS>`

Повідомлення, отримане з дерева, кожен рендер, коли :ref:`is_processing_internal()<class_Node_method_is_processing_internal>` повертає ``true``.

.. _class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS:

.. rst-class:: classref-constant

**NOTIFICATION_INTERNAL_PHYSICS_PROCESS** = ``26`` :ref:`🔗<class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS>`

Повідомлення отримано з дерева, коли :ref:`is_physics_processing_internal()<class_Node_method_is_physics_processing_internal>` повертає ``true``.

.. _class_Node_constant_NOTIFICATION_POST_ENTER_TREE:

.. rst-class:: classref-constant

**NOTIFICATION_POST_ENTER_TREE** = ``27`` :ref:`🔗<class_Node_constant_NOTIFICATION_POST_ENTER_TREE>`

Після того, як вершина надходить в дерево, перед тим як :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>` можна отримати. На відміну від останнього, він надіслав кожен раз вершину надходить дерево, не просто один раз.

.. _class_Node_constant_NOTIFICATION_DISABLED:

.. rst-class:: classref-constant

**NOTIFICATION_DISABLED** = ``28`` :ref:`🔗<class_Node_constant_NOTIFICATION_DISABLED>`

Повідомлення отримано при вимкненні вузла. Див. :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_NOTIFICATION_ENABLED:

.. rst-class:: classref-constant

**NOTIFICATION_ENABLED** = ``29`` :ref:`🔗<class_Node_constant_NOTIFICATION_ENABLED>`

Після вимкнення ввімкнено сповіщення. Див. :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. _class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION:

.. rst-class:: classref-constant

**NOTIFICATION_RESET_PHYSICS_INTERPOLATION** = ``2001`` :ref:`🔗<class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION>`

Сповіщення отримано, коли метод :ref:`reset_physics_interpolation()<class_Node_method_reset_physics_interpolation>` викликається на вузлі або його предках.

.. _class_Node_constant_NOTIFICATION_EDITOR_PRE_SAVE:

.. rst-class:: classref-constant

**NOTIFICATION_EDITOR_PRE_SAVE** = ``9001`` :ref:`🔗<class_Node_constant_NOTIFICATION_EDITOR_PRE_SAVE>`

Повідомлення надійшло прямо перед сценою з вершиною зберігається в редакторі. Таке повідомлення надіслано лише в редакторі Godot і не буде відбуватися в експортованих проектах.

.. _class_Node_constant_NOTIFICATION_EDITOR_POST_SAVE:

.. rst-class:: classref-constant

**NOTIFICATION_EDITOR_POST_SAVE** = ``9002`` :ref:`🔗<class_Node_constant_NOTIFICATION_EDITOR_POST_SAVE>`

Після того, як в редакторі зберігаються сповіщення, надійшло праве повідомлення. Таке повідомлення надіслано лише в редакторі Godot і не буде відбуватися в експортованих проектах.

.. _class_Node_constant_NOTIFICATION_WM_MOUSE_ENTER:

.. rst-class:: classref-constant

**NOTIFICATION_WM_MOUSE_ENTER** = ``1002`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_MOUSE_ENTER>`

Після того, як миша надходить у вікно.

Реалізовано для вбудованих вікон і на настільних і веб-платформах.

.. _class_Node_constant_NOTIFICATION_WM_MOUSE_EXIT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_MOUSE_EXIT** = ``1003`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_MOUSE_EXIT>`

Після того, як миша залишає вікно.

Реалізовано для вбудованих вікон і на настільних і веб-платформах.

.. _class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_IN:

.. rst-class:: classref-constant

**NOTIFICATION_WM_WINDOW_FOCUS_IN** = ``1004`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_IN>`

Повідомлення, отримане з ОС при фокусуванні вузла :ref:`Window<class_Window>`. Це може стати зміною фокусу між двома вікнами тієї ж моторної інстанції, або з робочого столу або сторонніх додатків до вікна гри (в якому випадку :ref:`NOTIFICATION_APPLICATION_FOCUS_IN<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN>` також отримано).

\ :ref:`Window<class_Window>` вузол отримує це повідомлення, коли він фокусується.

.. _class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_OUT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_WINDOW_FOCUS_OUT** = ``1005`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_WINDOW_FOCUS_OUT>`

Повідомлення, отримане з ОС при дефокусуванні вершини :ref:`Window<class_Window>`. Це може стати зміною фокусу між двома вікнами тієї ж моторної інстанції, або з вікна гри на робочий стіл або сторонньою заявкою (в якому випадку :ref:`NOTIFICATION_APPLICATION_FOCUS_OUT<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT>`.

\ :ref:`Window<class_Window>` вершина отримує це повідомлення, коли він дефокусований.

.. _class_Node_constant_NOTIFICATION_WM_CLOSE_REQUEST:

.. rst-class:: classref-constant

**NOTIFICATION_WM_CLOSE_REQUEST** = ``1006`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_CLOSE_REQUEST>`

Повідомлення отримано з ОС при відправці близького запиту (наприклад, закриття вікна з кнопкою «Клоза» або :kbd:`Alt + F4`).

Реалізовано на настільних платформах.

.. _class_Node_constant_NOTIFICATION_WM_GO_BACK_REQUEST:

.. rst-class:: classref-constant

**NOTIFICATION_WM_GO_BACK_REQUEST** = ``1007`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_GO_BACK_REQUEST>`

Повідомлення, отримане з ОС при відправці запиту назад (наприклад, натиснення кнопки "Назад" на Андроїд).

Реалізовано тільки на Андроїд.

.. _class_Node_constant_NOTIFICATION_WM_SIZE_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_WM_SIZE_CHANGED** = ``1008`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_SIZE_CHANGED>`

Повідомлення отримано при перерахуванні вікна.

\ **Примітка:** Тільки негабаритний вузол :ref:`Window<class_Window>` отримує це повідомлення, і воно не пропаговано до дочірньих вузлів.

.. _class_Node_constant_NOTIFICATION_WM_DPI_CHANGE:

.. rst-class:: classref-constant

**NOTIFICATION_WM_DPI_CHANGE** = ``1009`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_DPI_CHANGE>`

Повідомлення, отримане з ОС при зміні міток екрана на дюйм (DPI). Тільки реалізовані на macOS.

.. _class_Node_constant_NOTIFICATION_VP_MOUSE_ENTER:

.. rst-class:: classref-constant

**NOTIFICATION_VP_MOUSE_ENTER** = ``1010`` :ref:`🔗<class_Node_constant_NOTIFICATION_VP_MOUSE_ENTER>`

Після того, як курсор мишки надходить до видимої області :ref:`Viewport<class_Viewport>` ``false`` і незалежно від того, чи зараз він зосередився або ні.

.. _class_Node_constant_NOTIFICATION_VP_MOUSE_EXIT:

.. rst-class:: classref-constant

**NOTIFICATION_VP_MOUSE_EXIT** = ``1011`` :ref:`🔗<class_Node_constant_NOTIFICATION_VP_MOUSE_EXIT>`

Повідомлення отримано, коли курсор мишки залишає видиму площу :ref:`Viewport<class_Viewport>`, яка не входить до інших :ref:`Control<class_Control>`\ s або :ref:`Window<class_Window>`\ s, наданий його :ref:`Viewport._disable_input<class_Viewport_property__disable_input>` ``false`` і незалежно від того, чи зараз він зосередився або ні.

.. _class_Node_constant_NOTIFICATION_WM_POSITION_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_WM_POSITION_CHANGED** = ``1012`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_POSITION_CHANGED>`

Отримано сповіщення, коли вікно переміщено.

.. _class_Node_constant_NOTIFICATION_OS_MEMORY_WARNING:

.. rst-class:: classref-constant

**NOTIFICATION_OS_MEMORY_WARNING** = ``2009`` :ref:`🔗<class_Node_constant_NOTIFICATION_OS_MEMORY_WARNING>`

Повідомлення отримано від ОС при перевищенні його виділеної пам'яті.

Реалізовано тільки на iOS.

.. _class_Node_constant_NOTIFICATION_TRANSLATION_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_TRANSLATION_CHANGED** = ``2010`` :ref:`🔗<class_Node_constant_NOTIFICATION_TRANSLATION_CHANGED>`

Отримано сповіщення, коли переклади могли змінитися. Може бути викликано зміною користувачем локалі, зміною :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>` або коли вузол входить у дерево сцени. Може використовуватися для реагування на зміни мови, наприклад, для зміни рядків інтерфейсу користувача на льоту. Корисно під час роботи з вбудованою підтримкою перекладу, наприклад :ref:`Object.tr()<class_Object_method_tr>`. 

\ **Примітка:** це сповіщення отримано разом із :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>`, тому, якщо ви створюєте екземпляр сцени, дочірні вузли ще не буде ініціалізовано. Ви можете використовувати його, щоб налаштувати переклади для цього вузла, дочірніх вузлів, створених зі сценарію, або якщо ви хочете отримати доступ до дочірніх вузлів, доданих у редакторі, переконайтеся, що вузол готовий за допомогою :ref:`is_node_ready()<class_Node_method_is_node_ready>`. 

::
 
    func _notification(що): 
        if what == NOTIFICATION_TRANSLATION_CHANGED: 
            if not is_node_ready(): 
                await ready # Зачекайте до сигналу готовності. 
            $Label.text = atr("%d Bananas") % banana_counter 

.. _class_Node_constant_NOTIFICATION_WM_ABOUT:

.. rst-class:: classref-constant

**NOTIFICATION_WM_ABOUT** = ``2011`` :ref:`🔗<class_Node_constant_NOTIFICATION_WM_ABOUT>`

Повідомлення отримано від ОС при надсиланні запиту на "Про" інформацію.

Реалізовано тільки на macOS.

.. _class_Node_constant_NOTIFICATION_CRASH:

.. rst-class:: classref-constant

**NOTIFICATION_CRASH** = ``2012`` :ref:`🔗<class_Node_constant_NOTIFICATION_CRASH>`

Увімкнення отримано з аварійного керма Godot, коли двигун знаходиться на збій.

Реалізовано на настільних платформах, якщо увімкнено аварійний обробник.

.. _class_Node_constant_NOTIFICATION_OS_IME_UPDATE:

.. rst-class:: classref-constant

**NOTIFICATION_OS_IME_UPDATE** = ``2013`` :ref:`🔗<class_Node_constant_NOTIFICATION_OS_IME_UPDATE>`

Повідомлення отримано від ОС при оновленні Вступного методу двигуна (наприклад, зміна позиції курсора IME або рядка композицій).

Реалізовано тільки на macOS.

.. _class_Node_constant_NOTIFICATION_APPLICATION_RESUMED:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_RESUMED** = ``2014`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_RESUMED>`

Повідомлення отримано від ОС при відновленні програми.

Специфіка для платформ Android та iOS.

.. _class_Node_constant_NOTIFICATION_APPLICATION_PAUSED:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_PAUSED** = ``2015`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_PAUSED>`

Повідомлення, отримане від ОС, коли заявка призупинена.

Специфічні для платформ Android та iOS.

\ **Примітка:** На iOS, у вас є лише приблизно 5 секунд, щоб закінчити завдання, розпочате цей сигнал. Якщо ви переживаєте цей розподіл, iOS вб'є додаток, а не призупинити його.

.. _class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_FOCUS_IN** = ``2016`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_IN>`

Повідомлення отримано від ОС, коли додаток зосереджено, тобто при зміні фокусу з робочого столу OS або додатку сторонніх до будь-якого відкритого вікна екземпляра Godot.

Реалізовано на настільних і мобільних платформах.

.. _class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT:

.. rst-class:: classref-constant

**NOTIFICATION_APPLICATION_FOCUS_OUT** = ``2017`` :ref:`🔗<class_Node_constant_NOTIFICATION_APPLICATION_FOCUS_OUT>`

Повідомлення отримано від ОС при дефокусованій програмі, тобто при зміні фокусу з будь-якого відкритого вікна екземпляра Godot на робочий стіл або додатку сторонніх осіб.

Реалізовано на настільних і мобільних платформах.

.. _class_Node_constant_NOTIFICATION_TEXT_SERVER_CHANGED:

.. rst-class:: classref-constant

**NOTIFICATION_TEXT_SERVER_CHANGED** = ``2018`` :ref:`🔗<class_Node_constant_NOTIFICATION_TEXT_SERVER_CHANGED>`

Повідомлення, отримано при зміні :ref:`TextServer<class_TextServer>`.

.. _class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE:

.. rst-class:: classref-constant

**NOTIFICATION_ACCESSIBILITY_UPDATE** = ``3000`` :ref:`🔗<class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE>`

Сповіщення, отримане, коли потрібне оновлення інформації про доступність.

.. _class_Node_constant_NOTIFICATION_ACCESSIBILITY_INVALIDATE:

.. rst-class:: classref-constant

**NOTIFICATION_ACCESSIBILITY_INVALIDATE** = ``3001`` :ref:`🔗<class_Node_constant_NOTIFICATION_ACCESSIBILITY_INVALIDATE>`

Сповіщення отримано, коли елементи доступності визнано недійсними. Усі елементи доступності вузла автоматично видаляються після отримання цього повідомлення, тому всі існуючі посилання на такі елементи слід відкинути.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Описи властивостей
------------------------------------

.. _class_Node_property_auto_translate_mode:

.. rst-class:: classref-property

:ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **auto_translate_mode** = ``0`` :ref:`🔗<class_Node_property_auto_translate_mode>`

.. rst-class:: classref-property-setget

- |void| **set_auto_translate_mode**\ (\ value\: :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>`\ )
- :ref:`AutoTranslateMode<enum_Node_AutoTranslateMode>` **get_auto_translate_mode**\ (\ )

Якщо будь-який текст повинен автоматично змінюватися до його перекладеної версії залежно від поточного локального (для вузлів, таких як :ref:`Label<class_Label>`, :ref:`RichTextLabel<class_RichTextLabel>`, :ref:`Window<class_Window>` та ін.). Також вирішується, якщо рядок вершини повинні бути принесені до покоління POT.

\ **Примітка:** Для кореневої вершини режим автоматичного перекладу можна встановити за допомогою :ref:`ProjectSettings.internationalization/rendering/root_node_auto_translate<class_ProjectSettings_property_internationalization/rendering/root_node_auto_translate>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_editor_description:

.. rst-class:: classref-property

:ref:`String<class_String>` **editor_description** = ``""`` :ref:`🔗<class_Node_property_editor_description>`

.. rst-class:: classref-property-setget

- |void| **set_editor_description**\ (\ value\: :ref:`String<class_String>`\ )
- :ref:`String<class_String>` **get_editor_description**\ (\ )

Додатковий опис до вершини. Він буде відображатися як інструмент, коли перебуваючи над вершиною в докці редактора.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_multiplayer:

.. rst-class:: classref-property

:ref:`MultiplayerAPI<class_MultiplayerAPI>` **multiplayer** :ref:`🔗<class_Node_property_multiplayer>`

.. rst-class:: classref-property-setget

- :ref:`MultiplayerAPI<class_MultiplayerAPI>` **get_multiplayer**\ (\ )

:ref:`MultiplayerAPI<class_MultiplayerAPI>` екземпляр, пов'язаний з цією вершиною. Подивитися :ref:`SceneTree.get_multiplayer()<class_SceneTree_method_get_multiplayer>`.

\ **Примітка:** Перейменування вершини, або переміщення його в дерево, не перейде :ref:`MultiplayerAPI<class_MultiplayerAPI>` на новий шлях, вам доведеться оновити це вручну.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_name:

.. rst-class:: classref-property

:ref:`StringName<class_StringName>` **name** :ref:`🔗<class_Node_property_name>`

.. rst-class:: classref-property-setget

- |void| **set_name**\ (\ value\: :ref:`StringName<class_StringName>`\ )
- :ref:`StringName<class_StringName>` **get_name**\ (\ )

Назва вузла. Ця назва повинна бути унікальною серед муфт (інші дочірні вузли з одного батька). При налаштуванні до існуючої ім'я зв'язку вузол автоматично перейменований.

\ **Примітка:** При зміні назви будуть замінені наступні символи: (`` `` ``:`` `` @`` ``/`` ``"`` ``%``). ```` символ зарезервований для автоматично сформованих імен. Дивись також :ref:`string.validate_node_name()<class_string_method_validate_node_name>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_owner:

.. rst-class:: classref-property

:ref:`Node<class_Node>` **owner** :ref:`🔗<class_Node_property_owner>`

.. rst-class:: classref-property-setget

- |void| **set_owner**\ (\ value\: :ref:`Node<class_Node>`\ )
- :ref:`Node<class_Node>` **get_owner**\ (\ )

Власник цього вузла. Власник має бути предком цього вузла. Під час упаковки вузла власника в :ref:`PackedScene<class_PackedScene>` усі вузли, якими він володіє, також зберігаються разом із ним. Дивіться також :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`. 

\ **Примітка:** У редакторі вузли, які не належать кореневій частині сцени, зазвичай не відображаються в доку сцени та **ні** зберігаються. Щоб запобігти цьому, не забудьте встановити власника після виклику :ref:`add_child()<class_Node_method_add_child>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_physics_interpolation_mode:

.. rst-class:: classref-property

:ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **physics_interpolation_mode** = ``0`` :ref:`🔗<class_Node_property_physics_interpolation_mode>`

.. rst-class:: classref-property-setget

- |void| **set_physics_interpolation_mode**\ (\ value\: :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>`\ )
- :ref:`PhysicsInterpolationMode<enum_Node_PhysicsInterpolationMode>` **get_physics_interpolation_mode**\ (\ )

Режим фізичної інтерполяції, який слід використовувати для цього вузла. Діє лише тоді, коли :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>` або :ref:`SceneTree.physics_interpolation<class_SceneTree_property_physics_interpolation>` має значення ``true``.

За замовчуванням вузли успадковують режим фізичної інтерполяції від свого батьківського вузла. Ця властивість може вмикати або вимикати фізичну інтерполяцію окремо для кожного вузла, незалежно від режиму фізичної інтерполяції їхніх батьків.

\ **Примітка:** Деякі типи вузлів, такі як :ref:`VehicleWheel3D<class_VehicleWheel3D>`, мають фізичну інтерполяцію вимкнену за замовчуванням, оскільки вони покладаються на власне користувацьке рішення.

\ **Примітка:** Під час телепортації вузла у віддалену позицію рекомендується тимчасово вимкнути інтерполяцію за допомогою методу :ref:`reset_physics_interpolation()<class_Node_method_reset_physics_interpolation>` *після* переміщення вузла. Це дозволяє уникнути створення візуальної смуги між старою та новою позиціями.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_mode:

.. rst-class:: classref-property

:ref:`ProcessMode<enum_Node_ProcessMode>` **process_mode** = ``0`` :ref:`🔗<class_Node_property_process_mode>`

.. rst-class:: classref-property-setget

- |void| **set_process_mode**\ (\ value\: :ref:`ProcessMode<enum_Node_ProcessMode>`\ )
- :ref:`ProcessMode<enum_Node_ProcessMode>` **get_process_mode**\ (\ )

Поведінка обробки вузла. Щоб перевірити, чи може вузол обробляти дані в поточному режимі, використовуйте :ref:`can_process()<class_Node_method_can_process>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_physics_priority:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_physics_priority** = ``0`` :ref:`🔗<class_Node_property_process_physics_priority>`

.. rst-class:: classref-property-setget

- |void| **set_physics_process_priority**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_physics_process_priority**\ (\ )

Подібно до :ref:`process_priority<class_Node_property_process_priority>`, але для :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_physics_process()<class_Node_private_method__physics_process>` або :ref:`NOTIFICATION_INTERNAL_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_INTERNAL_PHYSICS_PROCESS>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_priority:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_priority** = ``0`` :ref:`🔗<class_Node_property_process_priority>`

.. rst-class:: classref-property-setget

- |void| **set_process_priority**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_process_priority**\ (\ )

Порядок виконання вузлом зворотних викликів процесу (:ref:`_process()<class_Node_private_method__process>`, :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` і :ref:`NOTIFICATION_INTERNAL_PROCESS<class_Node_constant_NOTIFICATION_INTERNAL_PROCESS>`). Вузли, значення пріоритету яких *нижче*, викликають зворотні виклики своїх процесів першими, незалежно від порядку дерева.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_group:

.. rst-class:: classref-property

:ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **process_thread_group** = ``0`` :ref:`🔗<class_Node_property_process_thread_group>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_group**\ (\ value\: :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>`\ )
- :ref:`ProcessThreadGroup<enum_Node_ProcessThreadGroup>` **get_process_thread_group**\ (\ )

Встановіть групу потоків процесу для цього вузла (загалом, незалежно від того, чи отримує він :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`, :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_process()<class_Node_private_method__process>` або :ref:`_physics_process()<class_Node_private_method__physics_process>` (і внутрішні версії) у головному потоці чи у підпотоці.

За замовчуванням групою потоків є :ref:`PROCESS_THREAD_GROUP_INHERIT<class_Node_constant_PROCESS_THREAD_GROUP_INHERIT>`, що означає, що цей вузол належить до тієї ж групи потоків, що й батьківський вузол. Групи потоків означають, що вузли в певній групі потоків оброблятимуть разом, окремо від інших груп потоків (залежно від :ref:`process_thread_group_order<class_Node_property_process_thread_group_order>`). Якщо встановлено значення :ref:`PROCESS_THREAD_GROUP_SUB_THREAD<class_Node_constant_PROCESS_THREAD_GROUP_SUB_THREAD>`, ця група потоків відбуватиметься у підпотоці (а не в основному потоці), інакше, якщо встановлено значення :ref:`PROCESS_THREAD_GROUP_MAIN_THREAD<class_Node_constant_PROCESS_THREAD_GROUP_MAIN_THREAD>`, вона оброблятиметься в основному потоці. Якщо немає батьківського або дідуся вузла, налаштованого на щось інше, ніж успадкування, вузол належатиме до *групи потоків за замовчуванням*. Ця група за замовчуванням оброблятиметься в основному потоці, її порядок груп дорівнює 0.

Під час обробки у підпотоці доступ до більшості функцій у вузлах поза групою потоку заборонено (і це призведе до помилки в режимі налагодження). Використовуйте :ref:`Object.call_deferred()<class_Object_method_call_deferred>`, :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` тощо, щоб спілкуватися від груп потоків до основного потоку (або до інших груп потоків).

Щоб краще зрозуміти групи потоків процесів, ідея полягає в тому, що будь-який вузол, для якого встановлено значення, відмінне від :ref:`PROCESS_THREAD_GROUP_INHERIT<class_Node_constant_PROCESS_THREAD_GROUP_INHERIT>`, включатиме будь-які дочірні (і дочірні) вузли, налаштовані для успадкування, у свою групу потоків процесу. Це означає, що обробка всіх вузлів у групі відбуватиметься разом, одночасно з вузлом, що включає їх.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_group_order:

.. rst-class:: classref-property

:ref:`int<class_int>` **process_thread_group_order** :ref:`🔗<class_Node_property_process_thread_group_order>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_group_order**\ (\ value\: :ref:`int<class_int>`\ )
- :ref:`int<class_int>` **get_process_thread_group_order**\ (\ )

Зміна порядку групового процесу. Група з меншим замовленням обробляється до груп з більшим замовленням. Це корисно, коли велика кількість вузлів обробляється під ниткою і, навпаки, інша група хоче зібрати їх результат в основну нитку, як приклад.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_process_thread_messages:

.. rst-class:: classref-property

|bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] **process_thread_messages** :ref:`🔗<class_Node_property_process_thread_messages>`

.. rst-class:: classref-property-setget

- |void| **set_process_thread_messages**\ (\ value\: |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\]\ )
- |bitfield|\[:ref:`ProcessThreadMessages<enum_Node_ProcessThreadMessages>`\] **get_process_thread_messages**\ (\ )

Встановити, чи поточна група ниток оброблятиме повідомлення (розрахунку на :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>` на нитках), і чи потрібно отримувати їх під час регулярного процесу або фізичного процесу зворотнього зв'язку.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_scene_file_path:

.. rst-class:: classref-property

:ref:`String<class_String>` **scene_file_path** :ref:`🔗<class_Node_property_scene_file_path>`

.. rst-class:: classref-property-setget

- |void| **set_scene_file_path**\ (\ value\: :ref:`String<class_String>`\ )
- :ref:`String<class_String>` **get_scene_file_path**\ (\ )

Оригінальний шлях файлу сцени, якщо вершина була миттєва від файлу :ref:`PackedScene<class_PackedScene>`. Тільки кореневі вузли сцени містять це.

.. rst-class:: classref-item-separator

----

.. _class_Node_property_unique_name_in_owner:

.. rst-class:: classref-property

:ref:`bool<class_bool>` **unique_name_in_owner** = ``false`` :ref:`🔗<class_Node_property_unique_name_in_owner>`

.. rst-class:: classref-property-setget

- |void| **set_unique_name_in_owner**\ (\ value\: :ref:`bool<class_bool>`\ )
- :ref:`bool<class_bool>` **is_unique_name_in_owner**\ (\ )

Якщо ``true``, до вузла можна отримати доступ з будь-якого вузла, що має спільного власника :ref:`owner<class_Node_property_owner>`, або з самого :ref:`owner<class_Node_property_owner>`, використовуючи спеціальний синтаксис ``%Name`` у :ref:`get_node()<class_Node_method_get_node>`.

\ **Примітка:** Якщо інший вузол з тим самим :ref:`owne<class_Node_property_owne>` має спільний доступ до того ж :ref:`name<class_Node_property_name>`, що й цей вузол, інший вузол більше не буде доступним як унікальний.

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

Описи методів
--------------------------

.. _class_Node_private_method__enter_tree:

.. rst-class:: classref-method

|void| **_enter_tree**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__enter_tree>`

Увімкніть, коли вершина надходить на :ref:`SceneTree<class_SceneTree>` (наприклад, при миттєвих змінах сцени, або після виклику :ref:`add_child()<class_Node_method_add_child>` у скрипті). Якщо вершина має дітей, його :ref:`_enter_tree()<class_Node_private_method__enter_tree>` виклик буде називатися першим, а потім тим, що діти.

Кореспонденти до повідомлення :ref:`NOTIFICATION_ENTER_TREE<class_Node_constant_NOTIFICATION_ENTER_TREE>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__exit_tree:

.. rst-class:: classref-method

|void| **_exit_tree**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__exit_tree>`

Увімкніть, коли вершина про те, щоб залишити :ref:`SceneTree<class_SceneTree>` (наприклад, при звільненні, зміні сцени або після виклику :ref:`remove_child()<class_Node_method_remove_child>` в скрипті). Якщо у вершині є діти, його :ref:`_exit_tree()<class_Node_private_method__exit_tree>` запобіжник буде називатися останнім, після того, як всі його діти залишили дерево.

Відповіді на :ref:`NOTIFICATION_EXIT_TREE<class_Node_constant_NOTIFICATION_EXIT_TREE>` повідомлення в :ref:`Object._notification()<class_Object_private_method__notification>` та сигнал :ref:`Tree_exiting<class_Node_signal_Tree_exiting>`. Щоб отримати сповіщення, коли вершина вже залишила активне дерево, підключіть до :ref:`tree_exited<class_Node_signal_tree_exited>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_accessibility_configuration_warnings:

.. rst-class:: classref-method

:ref:`PackedStringArray<class_PackedStringArray>` **_get_accessibility_configuration_warnings**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_accessibility_configuration_warnings>`

Елементи масиву, що повертаються цим методом, відображаються як попередження в панелі сцени, якщо скрипт, який його перевизначає, є скриптом ``tool``, а попередження про доступність увімкнено в налаштуваннях редактора.

Повернення порожнього масиву не створює попереджень.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_configuration_warnings:

.. rst-class:: classref-method

:ref:`PackedStringArray<class_PackedStringArray>` **_get_configuration_warnings**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_configuration_warnings>`

Елементи в масиві, який повертає цей метод, відображаються як попередження в доку Scene, якщо сценарій, який замінює його, є сценарієм ``інструмента``.

Повернення порожнього масиву не створює попереджень.

Викличте :ref:`update_configuration_warnings()<class_Node_method_update_configuration_warnings>`, коли потрібно оновити попередження для цього вузла.

::

    @export var energy = 0:
        set(value):
            energy = value
            update_configuration_warnings()

    func _get_configuration_warnings():
        if energy < 0:
            return ["Energy must be 0 or greater."]
        else:
            return []

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__get_focused_accessibility_element:

.. rst-class:: classref-method

:ref:`RID<class_RID>` **_get_focused_accessibility_element**\ (\ ) |virtual| |const| :ref:`🔗<class_Node_private_method__get_focused_accessibility_element>`

Викликається під час оновлення інформації про доступність для визначення поточного піделементу, має повертати RID піделементу або значення, повернене :ref:`get_accessibility_element()<class_Node_method_get_accessibility_element>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__input:

.. rst-class:: classref-method

|void| **_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__input>`

Викликається, коли є вхідний захід. Вступний захід пропагує через дерево вершин, поки вузол споживає його.

Це тільки називається, якщо ввімкнена обробка вхідних даних, яка здійснюється автоматично, якщо цей метод перейде, і може бути використані :ref:`set_process_input()<class_Node_method_set_process_input>`.

Щоб споживати вхідний захід і зупинити його пропагування додатково до інших вузлів, можна назвати :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Для введення гри :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` і :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` зазвичай краще підходять, оскільки вони дозволяють GUI перехоплювати події першими.

\ **Примітка:** Цей метод називається лише якщо вершина присутній на ялинці (тобто якщо це не дитячий будинок).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__physics_process:

.. rst-class:: classref-method

|void| **_physics_process**\ (\ delta\: :ref:`float<class_float>`\ ) |virtual| :ref:`🔗<class_Node_private_method__physics_process>`

Викликається один раз на кожен фізичний такт і дозволяє вузлам синхронізувати свою логіку з фізичними тактами. ``delta`` — це логічний час між фізичними тактами в секундах, який дорівнює :ref:`Engine.time_scale<class_Engine_property_time_scale>` / :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>`.

Викликається тільки в тому випадку, якщо для цього вузла ввімкнено обробку фізики, що робиться автоматично, якщо цей метод перезаписано, і може бути ввімкнено або вимкнено за допомогою :ref:`set_physics_process()<class_Node_method_set_physics_process>`.

Обробка відбувається в порядку :ref:`process_physics_priority<class_Node_property_process_physics_priority>`, спочатку викликаються значення з нижчим пріоритетом. Вузли з однаковим пріоритетом обробляються в порядку дерева, або зверху вниз, як це видно в редакторі (також відоме як обхід в порядку).

Відповідає повідомленню :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

\ **Примітка:** Цей метод викликається тільки в тому випадку, якщо вузол присутній в дереві сцени (тобто якщо він не є сиротою).

\ **Примітка:** Накопичене ``delta`` може відрізнятися від реальних секунд.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__process:

.. rst-class:: classref-method

|void| **_process**\ (\ delta\: :ref:`float<class_float>`\ ) |virtual| :ref:`🔗<class_Node_private_method__process>`

Викликається на кожному кадрі в режимі очікування, перед рендерингом і після обробки фізичних тиків. ``delta`` — це час між кадрами в секундах.

Викликається тільки в тому випадку, якщо для цього вузла ввімкнено обробку, що відбувається автоматично, якщо цей метод перезаписано, і може бути ввімкнено або вимкнено за допомогою :ref:`set_process()<class_Node_method_set_process>`.

Обробка відбувається в порядку :ref:`process_priority<class_Node_property_process_priority>`, спочатку викликаються значення з нижчим пріоритетом. Вузли з однаковим пріоритетом обробляються в порядку дерева або зверху вниз, як показано в редакторі (також відоме як обхід у порядку).

Відповідає повідомленню :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` в :ref:`Object._notification()<class_Object_private_method__notification>`.

\ **Примітка:** Цей метод викликається тільки якщо вузол присутній в дереві сцени (тобто якщо він не є сиротою) .

\ **Примітка:** Коли движок працює з перебоями і частота кадрів знижується, ``delta`` збільшується. Коли ``delta`` збільшується, його максимальне значення обмежується :ref:`Engine.time_scale<class_Engine_property_time_scale>` \* :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` / :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>`. Як результат, накопичений ``delta`` може не відповідати реальному часу.

\ **Примітка:** Коли ``--fixed-fps`` увімкнено або движок працює в режимі Movie Maker (див. :ref:`MovieWriter<class_MovieWriter>`), процес ``delta`` завжди буде однаковим для кожного кадру, незалежно від того, скільки часу знадобилося для його рендерингу.

\ **Примітка:** Дельта кадру може бути оброблена :ref:`OS.delta_smoothing<class_OS_property_delta_smoothing>`, якщо це ввімкнено для проекту.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__ready:

.. rst-class:: classref-method

|void| **_ready**\ (\ ) |virtual| :ref:`🔗<class_Node_private_method__ready>`

Викликається, коли вершина «читає», тобто коли і вершина, і її діти вступили в дерево сцени. Якщо вершина має дітей, їх :ref:`_ready()<class_Node_private_method__ready>` виклики запускаються першими, а материнська вершина отримає готове повідомлення після

Відповіді на :ref:`NOTIFICATION_READY<class_Node_constant_NOTIFICATION_READY>` повідомлення в :ref:`Object._notification()<class_Object_private_method__notification>`. ``@onready`` анотація для змінних.

Зазвичай використовується для ініціалізації. Для ще раніше ініціалізації можна використовувати :ref:`Object._init()<class_Object_private_method__init>`. Дивись ще :ref:`_enter_tree()<class_Node_private_method__enter_tree>`\ 

\ **Примітка:** Цей метод може бути викликаний тільки один раз для кожного вузла. Після видалення вузла з дерева сцени і додавання його знову, :ref:`_ready()<class_Node_private_method__ready>` буде ** не** буде називатися другим раз. Це може бути обходитися запитом іншого виклику з :ref:`request_ready()<class_Node_method_request_ready>`, який може бути викликаний будь-яким, перш ніж додати вузол знову.

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__shortcut_input:

.. rst-class:: classref-method

|void| **_shortcut_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__shortcut_input>`

Увімкніть, коли :ref:`InputEventKey<class_InputEventKey>`, :ref:`InputEventShortcut<class_InputEventShortcut>`, або ``InputEventJoypad`` не споживали :ref:`_input()<class_Node_private_method__input>` або будь-який графічний інтерфейс :ref:`Control<class_Control>` пункт. Це називається до :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` і :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`. Вступний захід пропагує через дерево вершин, поки вузол споживає його.

Якщо увімкнено обробку ярликів, що здійснюється автоматично, якщо цей метод перейменований, і може бути використана :ref:`set_process_shortcut_input()<class_Node_method_set_process_shortcut_input>`.

Щоб споживати вхідний захід і зупинити його пропагування додатково до інших вузлів, можна назвати :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Цей метод можна використовувати для обробки ярликів. Для генеричних подій, використання :ref:`_input()<class_Node_private_method__input>`. Gameplay події, як правило, повинні оброблятися як :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` або :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`.

\ **Примітка:** Цей метод називається лише якщо вершина присутній на ялинці (тобто якщо це не дитячий будинок).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__unhandled_input:

.. rst-class:: classref-method

|void| **_unhandled_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__unhandled_input>`

Викликається, коли :ref:`InputEvent<class_InputEvent>` не було використано методом :ref:`_input()<class_Node_private_method__input>` або будь-яким елементом графічного інтерфейсу :ref:`Control<class_Control>`. Викликається після методу :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>` та після методу :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`. Вхідна подія поширюється вгору по дереву вузлів, доки вузол не споживає її.

Він викликається лише тоді, коли ввімкнено обробку необроблених вхідних даних, що відбувається автоматично, якщо цей метод перевизначено, і його можна перемкнути за допомогою :ref:`set_process_unhandled_input()<class_Node_method_set_process_unhandled_input>`.

Щоб використати подію введення та зупинити її подальше поширення на інші вузли, можна викликати :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Для введення даних у ігровий процес цей метод зазвичай краще підходить, ніж :ref:`_input()<class_Node_private_method__input>`, оскільки події графічного інтерфейсу потребують вищого пріоритету. Для комбінацій клавіш розгляньте використання :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>` замість цього, як це викликається перед цим методом. Нарешті, для обробки подій клавіатури, з міркувань продуктивності, розгляньте можливість використання :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>`.

\ **Примітка:** Цей метод викликається лише тоді, коли вузол присутній у дереві сцени (тобто, якщо він не є сиротою).

.. rst-class:: classref-item-separator

----

.. _class_Node_private_method__unhandled_key_input:

.. rst-class:: classref-method

|void| **_unhandled_key_input**\ (\ event\: :ref:`InputEvent<class_InputEvent>`\ ) |virtual| :ref:`🔗<class_Node_private_method__unhandled_key_input>`

Викликається, коли :ref:`InputEventKey<class_InputEventKey>` не використовується :ref:`_input()<class_Node_private_method__input>` або будь-яким елементом GUI :ref:`Control<class_Control>`. Він викликається після :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>`, але перед :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`. Вхідна подія поширюється вгору по дереву вузлів, доки вузол не споживає її.

Він викликається, лише якщо ввімкнено обробку необробленого введення ключа, яка виконується автоматично, якщо цей метод перевизначено, і її можна перемикати за допомогою :ref:`set_process_unhandled_key_input()<class_Node_method_set_process_unhandled_key_input>`.

Щоб використати вхідну подію та зупинити її подальше поширення на інші вузли, можна викликати :ref:`Viewport.set_input_as_handled()<class_Viewport_method_set_input_as_handled>`.

Цей метод можна використовувати для обробки введення символів Unicode за допомогою модифікаторів :kbd:`Alt`, :kbd:`Alt + Ctrl` і :kbd:`Alt + Shift` після обробки комбінацій клавіш.

Для введення в ігровий процес це та :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` зазвичай краще підходять, ніж :ref:`_input()<class_Node_private_method__input>`, оскільки події графічного інтерфейсу повинні оброблятися першими. Цей метод також працює краще, ніж :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>`, оскільки непов’язані події, такі як :ref:`InputEventMouseMotion<class_InputEventMouseMotion>`, автоматично фільтруються. Для ярликів краще використовувати :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>`.

\ **Примітка:** Цей метод викликається, лише якщо вузол присутній у дереві сцени (тобто якщо він не є сиротою).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_child:

.. rst-class:: classref-method

|void| **add_child**\ (\ node\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false, internal\: :ref:`InternalMode<enum_Node_InternalMode>` = 0\ ) :ref:`🔗<class_Node_method_add_child>`

Додає дочірній вузол ``node``. Вузли можуть мати будь-яку кількість дочірніх вузлів, але кожен дочірній вузол повинен мати унікальне ім'я. Дочірні вузли автоматично видаляються, коли батьківський вузол видаляється, тому всю сцену можна видалити, видаливши його найвищий вузол.

Якщо ``force_readable_name`` має значення ``true``, покращується читабельність доданого вузла ``node``. Якщо не має імені, вузол ``node`` перейменовується на свій тип, і якщо він має спільне значення :ref:`name<class_Node_property_name>` з вузлом-братом, до нього додається суфікс числа, що є більш відповідним. Ця операція дуже повільна. Тому рекомендується залишити це значення на ``false``, що призначає фіктивне ім'я з ``@`` в обох випадках.

Якщо ``internal`` відрізняється від :ref:`INTERNAL_MODE_DISABLED<class_Node_constant_INTERNAL_MODE_DISABLED>`, дочірній вузол буде додано як внутрішній вузол. Ці вузли ігноруються методами, такими як :ref:`get_children()<class_Node_method_get_children>`, якщо їхній параметр ``include_internal`` не має значення ``true``. Це також запобігає дублюванню цих вузлів з їхнім батьківським вузлом. Призначене для приховування внутрішніх вузлів від користувача, щоб користувач випадково не видалив або не змінив їх. Використовується деякими вузлами графічного інтерфейсу, наприклад, :ref:`ColorPicker<class_ColorPicker>`.

\ **Примітка:** Якщо ``node`` вже має батьківський вузол, цей метод не спрацює. Спочатку використовуйте :ref:`remove_child()<class_Node_method_remove_child>`, щоб видалити ``node`` з його поточного батьківського вузла. Наприклад:


.. tabs::

 .. code-tab:: gdscript

    var child_node = get_child(0)
    if child_node.get_parent():
    child_node.get_parent().remove_child(child_node)
    add_child(child_node)

 .. code-tab:: csharp

    Node childNode = GetChild(0);
    if (childNode.GetParent() != null)
    {
    childNode.GetParent().RemoveChild(childNode);
    }
    AddChild(childNode); 



Якщо вам потрібно додати дочірній вузол під певним вузлом у списку дочірніх вузлів, використовуйте :ref:`add_sibling()<class_Node_method_add_sibling>` замість цього методу.

\ **Примітка:** Якщо ви хочете, щоб дочірній вузол зберігався в :ref:`PackedScene<class_PackedScene>`, вам потрібно встановити :ref:`owner<class_Node_property_owner>` на додаток до виклику :ref:`add_child()<class_Node_method_add_child>`. Зазвичай це стосується :doc:`скриптів інструментів <../tutorials/plugins/running_code_in_the_editor>` та :doc:`плагінів редактора <../tutorials/plugins/editor/index>`. Якщо :ref:`add_child()<class_Node_method_add_child>` викликається без встановлення :ref:`owner<class_Node_property_owner>`, щойно доданий **Node** не буде видно в дереві сцени, хоча він буде видно в 2D/3D-вигляді.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_sibling:

.. rst-class:: classref-method

|void| **add_sibling**\ (\ sibling\: :ref:`Node<class_Node>`, force_readable_name\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_add_sibling>`

Додає вершину ``sibling`` до батька цього вузла, а також переміщує додану муфту прямо нижче цього вузла.

Якщо ``parampower_readable_name`` є ``true``, покращує читабельність доданої ``sibling``. Якщо не названо, то ``sibling`` перейменовано на його тип, і якщо його акції :ref:`name<class_Node_property_name>` з муфтою, то число буде пропущено більш доцільно. Ця операція дуже повільно. Так, рекомендується залишити це на ``false``, який призначає ім'я мумії, що містить ``@`` в обох ситуаціях.

Використовуйте :ref:`add_child()<class_Node_method_add_child>` замість цього способу, якщо вам не потрібно вузол дитини, щоб додати нижче конкретного вузла в списку дітей.

\ **Примітка:** Якщо це вершина є внутрішнім, додана муфта буде занадто внутрішнім (див. :ref:`add_child()<class_Node_method_add_child>` ``інтернал`` параметр.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_add_to_group:

.. rst-class:: classref-method

|void| **add_to_group**\ (\ group\: :ref:`StringName<class_StringName>`, persistent\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_add_to_group>`

Додає вершину до ``group``. Групи можуть бути корисними для організації підмножини вузлів, наприклад ``"enemies"`` або ``"collectables""``. Дивіться ноти в описі, а також групові методи :ref:`SceneTree<class_SceneTree>`.

Якщо ``persistent`` є ``true``, група буде зберігатися при збереженні всередині :ref:`PackedScene<class_PackedScene>`. Всі групи, створені та відображаються в додатку Node, стійкі.

\ **Примітка:** Щоб підвищити продуктивність, замовлення назв груп * не* гарантовано і може відрізнятися між проектами. Тому не покладайтеся на групове замовлення.

\ **Примітка:** :ref:`SceneTree<class_SceneTree>` методами групи *not* працюють на цьому вершині, якщо не всередині дерева (див. :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_atr:

.. rst-class:: classref-method

:ref:`String<class_String>` **atr**\ (\ message\: :ref:`String<class_String>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const| :ref:`🔗<class_Node_method_atr>`

Перекладає ``message``, використовуючи каталоги перекладу, налаштовані в налаштуваннях проекту. Далі можна уточнити, щоб допомогти з перекладом. Зауважте, що більшість :ref:`Control<class_Control>` вузів автоматично переводять свої рядки, тому цей метод в основному корисний для форматованих рядків або настроюється текст.

Цей метод працює так само, як :ref:`Object.tr()<class_Object_method_tr>`, з додаванням поваги стану :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`.

Якщо :ref:`Object.can_translate_messages()<class_Object_method_can_translate_messages>` є ``false``, або немає перекладу, цей метод повертає ``message`` без змін. Див. :ref:`Object.set_message_translation()<class_Object_method_set_message_translation>`.

Для докладних прикладів див. :doc:`Міжнародні ігри <../tutorials/i18n/internationalizing_games>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_atr_n:

.. rst-class:: classref-method

:ref:`String<class_String>` **atr_n**\ (\ message\: :ref:`String<class_String>`, plural_message\: :ref:`StringName<class_StringName>`, n\: :ref:`int<class_int>`, context\: :ref:`StringName<class_StringName>` = ""\ ) |const| :ref:`🔗<class_Node_method_atr_n>`

Перекладає ``message`` або ``plural_message``, використовуючи каталоги перекладу, налаштовані в налаштуваннях проекту. Далі можна уточнити, щоб допомогти з перекладом.

Цей метод працює таким же чином, як :ref:`Object.tr()<class_Object_method_tr>`, з додаванням поваги стану :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`.

Якщо :ref:`Object.can_translate_messages()<class_Object_method_can_translate_messages>` є ``false``, або немає перекладу, цей метод повертає ``message`` або ``plural_message``, без змін. Див. :ref:`Object.set_message_translation()<class_Object_method_set_message_translation>`.

\ ``n`` - номер, або сума, суб'єкт повідомлення. Застосовується системою перекладів для викопування правильної форми для поточної мови.

Для докладних прикладів див. :doc:` Локалізація з використанням gettext <../tutorials/i18n/localization_using_gettext>`.

\ **Примітка:** Негативний і :ref:`float<class_float>` номери не можуть застосовуватися до деяких підзвітних предметів. Рекомендовано обробляти ці випадки з :ref:`atr()<class_Node_method_atr>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_call_deferred_thread_group:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **call_deferred_thread_group**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_call_deferred_thread_group>`

Ця функція схожа на :ref:`Object.call_deferred()<class_Object_method_call_deferred>` крім того, що виклик відбудеться, коли обробляється група ниток вузла. Якщо обробляється групові процеси вузла в піддослідних роботах, то виклик буде здійснюватися на цій нитки, прямо перед :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` або :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`, :ref:`_process()<class_Node_private_method__process>` або :ref:`_physics_process()<class_Node_private_method__physics_process>` або їх внутрішні версії.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_call_thread_safe:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **call_thread_safe**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_call_thread_safe>`

Ця функція забезпечує, що виклик цієї функції буде успішним, незалежно від того, чи це робиться з ниток або ні. Якщо називається з ниток, що не дозволено викликати функцію, виклик стане відкладений. В іншому випадку виклик буде проходити безпосередньо.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_can_auto_translate:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **can_auto_translate**\ (\ ) |const| :ref:`🔗<class_Node_method_can_auto_translate>`

Повертає ``true``, якщо цей вузол може автоматично перекладати повідомлення залежно від поточної локалізації. Див. :ref:`auto_translate_mode<class_Node_property_auto_translate_mode>`, :ref:`atr()<class_Node_method_atr>` та :ref:`atr_n()<class_Node_method_atr_n>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_can_process:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **can_process**\ (\ ) |const| :ref:`🔗<class_Node_method_can_process>`

Повертає ``true``, якщо вершина може отримувати повідомлення про обробку і вхідні виклики (:ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`, :ref:`_input()<class_Node_private_method__input>` і т.д.) з :ref:`SceneTree<class_SceneTree>` і :ref:`Viewport<class_Viewport>`. Повернуте значення залежить від ``пам'ятний процес_mode``:

до Якщо встановити до :ref:`PROCESS_MODE_PAUSABLE<class_Node_constant_PROCESS_MODE_PAUSABLE>`, повертає ``true``, коли гра переробляється, тобто :ref:`SceneTree.paused<class_SceneTree_property_paused>` ``false``;

до Якщо встановити до :ref:`PROCESS_MODE_WHEN_PAUSED<class_Node_constant_PROCESS_MODE_WHEN_PAUSED>`, повертає ``true``, коли гра паулюється, тобто :ref:`SceneTree.paused<class_SceneTree_property_paused>` ``true``;

до Якщо встановити до :ref:`PROCESS_MODE_ALWAYS<class_Node_constant_PROCESS_MODE_ALWAYS>`, завжди повертає ``true``;

до Якщо встановити до :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`, завжди повертає ``false``;

до Якщо встановити до :ref:`PROCESS_MODE_INHERIT<class_Node_constant_PROCESS_MODE_INHERIT>`, скористайтеся дужкою :ref:`process_mode<class_Node_property_process_mode>` для визначення результату.

Якщо вершина не всередині дерева, повертає ``false`` значення :ref:`process_mode<class_Node_property_process_mode>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_create_tween:

.. rst-class:: classref-method

:ref:`Tween<class_Tween>` **create_tween**\ (\ ) :ref:`🔗<class_Node_method_create_tween>`

Створює новий :ref:`Tween<class_Tween>` і прив’язує його до цього вузла. 

Це еквівалент виконання: 


.. tabs:: 

 .. code-tab:: gdscript
 
    get_tree().create_tween().bind_node(self)  

 .. code-tab:: csharp
 
    GetTree().CreateTween().BindNode(this);  

 

Анімація запуститься автоматично на наступному кадрі процесу або кадрі фізики (залежно від :ref:`TweenProcessMode<enum_Tween_TweenProcessMode>`). Дивіться :ref:`Tween.bind_node()<class_Tween_method_bind_node>`, щоб дізнатися більше про Tween, прив’язаний до вузлів. 

\ **Примітка:** Метод усе ще можна використовувати, якщо вузол не знаходиться всередині :ref:`SceneTree<class_SceneTree>`. Це може вийти з ладу в малоймовірному випадку використання спеціального :ref:`MainLoop<class_MainLoop>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_duplicate:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **duplicate**\ (\ flags\: :ref:`int<class_int>` = 15\ ) |const| :ref:`🔗<class_Node_method_duplicate>`

Дублює вузол, повертаючи новий вузол з усіма його властивостями, сигналами, групами та дочірніми елементами, скопійованими з оригіналу. Поведінку можна налаштувати за допомогою прапорців ``flags`` (див. :ref:`DuplicateFlags<enum_Node_DuplicateFlags>`). Внутрішні вузли не дублюються.

\ **Примітка:** Для вузлів із приєднаним :ref:`Script<class_Script>`, якщо метод ``Object._init`` було визначено з обов'язковими параметрами, дубльований вузол не матиме :ref:`Script<class_Script>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_child:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **find_child**\ (\ pattern\: :ref:`String<class_String>`, recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| :ref:`🔗<class_Node_method_find_child>`

Знаходиться перший нащадок цього вузла, який :ref:`name<class_Node_property_name>` відповідає ``pattern``, повертає ``null``, якщо не знайдено матчу. Відповідача здійснюється на імена вузлів, * не*, через :ref:`String.match()<class_String_method_match>`. Так, це case-sensitive, ``"*"`` відповідає нульовим або більшим символам, і ``"?"`` відповідає будь-якому символу.

Якщо ``recursive`` є ``false``, перевіряються тільки прямі діти цього вузла. Ноди перевіряють в порядку дерева, тому перша безпосередня дитина цього вузла перевіряється спочатку, потім своїми прямими дітьми і т.д., перед переїздом на другу пряму дитину, і так далі. Внутрішні діти також включені в пошук (див. ``інтернал`` параметр :ref:`add_child()<class_Node_method_add_child>`).

Якщо ``owned`` ``true``, перевіряються тільки нащадки з дійсним :ref:`owner<class_Node_property_owner>`.

\ **Примітка:** Цей метод може бути дуже повільно. Розглянемо зберігання посилання на знайдені вершини в змінній. Крім того, використання :ref:`get_node()<class_Node_method_get_node>` з унікальні іменами (див. :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`).

\ **Примітка:** Щоб знайти всі нащадки, що відповідають шаблону або типу класу, див. :ref:`find_children()<class_Node_method_find_children>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_children:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\] **find_children**\ (\ pattern\: :ref:`String<class_String>`, type\: :ref:`String<class_String>` = "", recursive\: :ref:`bool<class_bool>` = true, owned\: :ref:`bool<class_bool>` = true\ ) |const| :ref:`🔗<class_Node_method_find_children>`

Знаходиться всі нащадки цієї вершини, імена яких відповідають ``pattern``, повертає порожній :ref:`Array<class_Array>`, якщо не знайдено матчу. Відповідача здійснюється на імена вузлів, * не*, через :ref:`String.match()<class_String_method_match>`. Таким чином, це case-sensitive, ``"*"`` відповідає нулю або більше символів, і ``"?"`` відповідає будь-якому символу.

Якщо ``type`` не порожній, допускаються тільки предки, які спадаючі від ``type`` (див. :ref:`Object.is_class()<class_Object_method_is_class>`).

Якщо ``recursive`` є ``false``, перевіряються тільки прямі діти цього вузла. Ноди перевіряють в порядку дерева, тому перша безпосередня дитина цього вузла перевіряється спочатку, потім своїми прямими дітьми і т.д., перед переїздом на другу пряму дитину, і так далі. Внутрішні діти також включені в пошук (див. ``інтернал`` параметр :ref:`add_child()<class_Node_method_add_child>`).

Якщо ``owned`` ``true``, перевіряються тільки нащадки з дійсним :ref:`owner<class_Node_property_owner>` вершиною.

\ **Примітка:** Цей метод може бути дуже повільно. Розглянемо зберігання посилань на знайдені вузли в змінній.

\ **Примітка:** Щоб знайти єдиний вузол, що відповідає шаблону, див. :ref:`find_child()<class_Node_method_find_child>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_find_parent:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **find_parent**\ (\ pattern\: :ref:`String<class_String>`\ ) |const| :ref:`🔗<class_Node_method_find_parent>`

``Знаходиться перший представник цього вузла, який [member name] відповідає [param pattern], повертає [code]null``, якщо не знайдено матчу. Відповідача здійснюється через :ref:`String.match()<class_String_method_match>`. Так, це case-sensitive, ``"*"`` відповідає нульовим і більшим символам, і ``"?"`` відповідає будь-якому символу. :ref:`find_child()<class_Node_method_find_child>` і :ref:`find_children()<class_Node_method_find_children>`.

\ **Примітка:** Як цей метод ходить вгору в дерево сцени, він може бути повільним у великих, глибоко відстібаються вузли. Розглянемо зберігання посилання на знайдені вершини в змінній. Крім того, використання :ref:`get_node()<class_Node_method_get_node>` з унікальними іменами (див. :ref:`унікальний_name_in_owner<class_Node_property_унікальний_name_in_owner>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_accessibility_element:

.. rst-class:: classref-method

:ref:`RID<class_RID>` **get_accessibility_element**\ (\ ) |const| :ref:`🔗<class_Node_method_get_accessibility_element>`

Повертає основний елемент доступності RID.

\ **Примітка:** Цей метод слід викликати лише під час оновлення інформації про доступність (:ref:`NOTIFICATION_ACCESSIBILITY_UPDATE<class_Node_constant_NOTIFICATION_ACCESSIBILITY_UPDATE>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_child:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_child**\ (\ idx\: :ref:`int<class_int>`, include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_child>`

Вибирає дочірній вузол за його індексом. Кожен дочірній вузол має індекс відносно своїх братів і сестер (див. :ref:`get_index()<class_Node_method_get_index>`). Перший дочірній вузол має індекс 0. Від'ємні значення також можна використовувати для початку з кінця списку. Цей метод можна використовувати в поєднанні з :ref:`get_child_count()<class_Node_method_get_child_count>` для перебору дочірніх вузлів цього вузла. Якщо дочірній вузол не існує за заданим індексом, цей метод повертає ``null`` та генерується помилка.

Якщо ``include_internal`` має значення ``false``, внутрішні дочірні вузли ігноруються (див. параметр ``internal`` методу [code]method add_child]).
[codeblock]
    # Припускаючи, що наступні дочірні вузли є дочірніми вузлами, по порядку:
    # Ім'я, По батькові, Прізвище.

    var a = get_child(0).name # a – "Ім'я"
    var b = get_child(1).name # b – "По батькові"
    var b = get_child(2).name # b – "Прізвище"
    var c = get_child(-1).name # c – "Прізвище"[/codeblock]

[b]Примітка:[/b] Щоб отримати вузол за допомогою [NodePath], використовуйте [method get_node].

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_child_count:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_child_count**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_child_count>`

Повертає кількість дітей цього вузла.

Якщо ``include_internal`` є ``false``, внутрішні діти не підраховують (див. :ref:`add_child()<class_Node_method_add_child>` `` internal`` параметр.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_children:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`Node<class_Node>`\] **get_children**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_children>`

Повернення всіх дітей цієї вершини всередині ``Аррайон``.

Якщо ``include_internal`` є ``false``, виключає внутрішні діти з повернутого масиву (див. :ref:`add_child()<class_Node_method_add_child>` ``internal``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_groups:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`StringName<class_StringName>`\] **get_groups**\ (\ ) |const| :ref:`🔗<class_Node_method_get_groups>`

Повертає :ref:`Array<class_Array>` імен груп, до яких було додано вузол. 

\ **Примітка:** Щоб покращити продуктивність, порядок назв груп *не* гарантований і може змінюватися між запусками проекту. Тому не покладайтеся на груповий порядок. 

\ **Примітка: ** Цей метод також може повертати назви деяких груп, які починаються з підкреслення (``_``). Вони використовуються внутрішньо двигуном. Щоб уникнути конфліктів, не використовуйте спеціальні групи, які починаються з підкреслення. Щоб виключити внутрішні групи, перегляньте такий фрагмент коду: 


.. tabs:: 

 .. code-tab:: gdscript
 
    # Зберігає лише невнутрішні групи вузла (як масив StringNames). 
    var non_internal_groups = [] 
    for group в get_groups(): 
        if not str(group).begins_with("_"): 
            non_internal_groups.push_back(group)  

 .. code-tab:: csharp
 
    // Зберігає лише невнутрішні групи вузла (як список імен рядків). 
    List<string> nonInternalGroups = new List<string>(); 
    foreach (група рядків у GetGroups()) 
    {
        if (!group.BeginsWith("_")) 
            nonInternalGroups.Add(group); 
    } 



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_index:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_index**\ (\ include_internal\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_index>`

Повертаємо порядок цього вузла серед своїх дробів. Індекс першого вузла ``0``. Дивіться також :ref:`get_child()<class_Node_method_get_child>`.

\ ``false``, повертає індекс ігнорування внутрішніх дітей. Перший, не-внутрішня дитина буде індексом ``0`` (див. :ref:`add_child()<class_Node_method_add_child>` ``інтернал``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_last_exclusive_window:

.. rst-class:: classref-method

:ref:`Window<class_Window>` **get_last_exclusive_window**\ (\ ) |const| :ref:`🔗<class_Node_method_get_last_exclusive_window>`

Повертаємо :ref:`Window<class_Window>`, що містить цей вузол, або останню ексклюзивну дитину в ланцюжку вікон, починаючи з того, що містить цей вузол.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_multiplayer_authority:

.. rst-class:: classref-method

:ref:`int<class_int>` **get_multiplayer_authority**\ (\ ) |const| :ref:`🔗<class_Node_method_get_multiplayer_authority>`

Повернення однолітнього ідентифікатора багатокористувацького органу для цього вузла. Подивитися :ref:`set_multiplayer_authority()<class_Node_method_set_multiplayer_authority>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_node**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_get_node>`

Отримує вузол. :ref:`NodePath<class_NodePath>` може бути або відносним шляхом (від цього вузла), або абсолютним шляхом (від :ref:`SceneTree.root<class_SceneTree_property_root>`) до вузла. Якщо ``path`` не вказує на дійсний вузол, створюється помилка та повертається ``null``. Спроби отримати доступ до методів із значенням, що повертається, призведуть до помилки *"Спроба викликати <method> у нульовому екземплярі."*. 

\ **Примітка:** Отримання за абсолютним шляхом працює лише тоді, коли вузол знаходиться всередині дерева сцени (див. :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`). 

\ **Приклад:** Припустімо, що цей метод викликається з вузла Character у такому дереві: 

.. code:: text

     ┖╴root
        ┠╴Character (you are here!)
        ┃  ┠╴Sword
        ┃  ┖╴Backpack
        ┃     ┖╴Dagger
        ┠╴MyGame
        ┖╴Swamp
           ┠╴Alligator
           ┠╴Mosquito
           ┖╴Goblin 

Наступні виклики повернуть дійсний вузол: 


.. tabs:: 

 .. code-tab:: gdscript
 
    get_node("Sword")
    get_node("Backpack/Dagger")
    get_node("../Swamp/Alligator")
    get_node("/root/MyGame")

 .. code-tab:: csharp

    GetNode("Sword");
    GetNode("Backpack/Dagger");
    GetNode("../Swamp/Alligator");
    GetNode("/root/MyGame"); 



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_and_resource:

.. rst-class:: classref-method

:ref:`Array<class_Array>` **get_node_and_resource**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) :ref:`🔗<class_Node_method_get_node_and_resource>`

Отримує вузол та його найвкладеніший ресурс, як зазначено підіменем :ref:`NodePath<class_NodePath>`. Повертає :ref:`Array<class_Array>` розміром ``3``, де:

- Елемент ``0`` – це **Node**, або ``null``, якщо не знайдено;

- Елемент ``1`` – це останній вкладений :ref:`Resource<class_Resource>` підімені, або ``null``, якщо не знайдено;

- Елемент ``2`` – це залишок :ref:`NodePath<class_NodePath>`, що посилається на існуючу властивість, відмінну від :ref:`Resource<class_Resource>` (див. :ref:`Object.get_indexed()<class_Object_method_get_indexed>`).

\ **Приклад:** Припустимо, що дочірньому елементу :ref:`Sprite2D.texture<class_Sprite2D_property_texture>` було призначено :ref:`AtlasTexture<class_AtlasTexture>`:


.. tabs::

 .. code-tab:: gdscript

    var a = get_node_and_resource("Area2D/Sprite2D")
    print(a[0].name) # Виводить Sprite2D
    print(a[1]) # Виводить <null>
    print(a[2]) # Виводить ^""

    var b = get_node_and_resource("Area2D/Sprite2D:texture:atlas")
    print(b[0].name) # Виводить Sprite2D
    print(b[1].get_class()) # Виводить AtlasTexture
    print(b[2]) # Виводить ^""

    var c = get_node_and_resource("Area2D/Sprite2D:texture:atlas:region")
    print(c[0].name) # Друкує Sprite2D
    print(c[1].get_class()) # Друкує AtlasTexture
    print(c[2]) # Друкує ^":region"

 .. code-tab:: csharp

    var a = GetNodeAndResource(NodePath("Area2D/Sprite2D"));
    GD.Print(a[0].Name); // Друкує Sprite2D
    GD.Print(a[1]); // Друкує <null>
    GD.Print(a[2]); // Друкує ^"

    var b = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas"));
    GD.Print(b[0].name); // Друкує Sprite2D
    GD.Print(b[1].get_class()); // Друкує AtlasTexture
    GD.Print(b[2]); // Друкує ^""

    var c = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas:region"));
    GD.Print(c[0].name); // Друкує Sprite2D
    GD.Print(c[1].get_class()); // Друкує AtlasTexture
    GD.Print(c[2]); // Друкує ^":region"



.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_or_null:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_node_or_null**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_get_node_or_null>`

Fetches a вершина :ref:`NodePath<class_NodePath>`. Подібно до :ref:`get_node()<class_Node_method_get_node>`, але не генерує помилку, якщо ``path`` не вказується на дійсний вузол.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_node_rpc_config:

.. rst-class:: classref-method

:ref:`Variant<class_Variant>` **get_node_rpc_config**\ (\ ) |const| :ref:`🔗<class_Node_method_get_node_rpc_config>`

Повертає :ref:`Dictionary<class_Dictionary>` зіставлення імен методів з їхньою конфігурацією RPC, визначеною для цього вузла за допомогою :ref:`rpc_config()<class_Node_method_rpc_config>`.

\ **Примітка:** Цей метод повертає лише конфігурацію RPC, призначену за допомогою :ref:`rpc_config()<class_Node_method_rpc_config>`. Див. :ref:`Script.get_rpc_config()<class_Script_method_get_rpc_config>` для отримання RPC, визначених за допомогою :ref:`Script<class_Script>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_orphan_node_ids:

.. rst-class:: classref-method

:ref:`Array<class_Array>`\[:ref:`int<class_int>`\] **get_orphan_node_ids**\ (\ ) |static| :ref:`🔗<class_Node_method_get_orphan_node_ids>`

Повертає ідентифікатори об'єктів усіх вузлів-сиріт (вузлів поза :ref:`SceneTree<class_SceneTree>`). Використовується для налагодження.

\ **Примітка:** :ref:`get_orphan_node_ids()<class_Node_method_get_orphan_node_ids>` працює лише в налагоджувальних збірках. Під час виклику в проекті, експортованому в режимі випуску, :ref:`get_orphan_node_ids()<class_Node_method_get_orphan_node_ids>` поверне порожній масив.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_parent:

.. rst-class:: classref-method

:ref:`Node<class_Node>` **get_parent**\ (\ ) |const| :ref:`🔗<class_Node_method_get_parent>`

Повертає материнську вершину цього вузла, або ``null``, якщо вершина не має батька.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_path:

.. rst-class:: classref-method

:ref:`NodePath<class_NodePath>` **get_path**\ (\ ) |const| :ref:`🔗<class_Node_method_get_path>`

Повертає абсолютний шлях вершини, відносно :ref:`SceneTree.root<class_SceneTree_property_root>`. Якщо вершина не всередині дерева сцени, цей метод не виходить і повертає порожній :ref:`NodePath<class_NodePath>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_path_to:

.. rst-class:: classref-method

:ref:`NodePath<class_NodePath>` **get_path_to**\ (\ node\: :ref:`Node<class_Node>`, use_unique_path\: :ref:`bool<class_bool>` = false\ ) |const| :ref:`🔗<class_Node_method_get_path_to>`

Повертає відносну :ref:`NodePath<class_NodePath>` з цієї вершини до вказаного ``node``. Обидва вузли повинні бути в одному :ref:`SceneTree<class_SceneTree>` або сцена ієрархія, інакше цей метод не виходить і повертає порожній :ref:`NodePath<class_NodePath>`.

Якщо ``use_unique_path`` є ``true``, повертає найкоротший плановий облік для унікальної назви вершини (див. :ref:`unique_name_in_owner<class_Node_property_unique_name_in_owner>`).

\ **Примітка:** Якщо ви отримуєте відносний шлях, який починається з унікального вузла, шлях може бути більшим, ніж нормальний відносний шлях, завдяки додаванню імені унікального вузла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_physics_process_delta_time:

.. rst-class:: classref-method

:ref:`float<class_float>` **get_physics_process_delta_time**\ (\ ) |const| :ref:`🔗<class_Node_method_get_physics_process_delta_time>`

Повертає час, що минув (у секундах) з моменту останнього фізичного зворотного виклику. Це значення ідентичне параметру ``delta`` :ref:`_physics_process()<class_Node_private_method__physics_process>` і часто є узгодженим під час виконання, якщо :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` не змінено. Дивіться також :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>`. 

\ **Примітка.** Повернене значення буде більшим за очікуване, якщо частота кадрів буде нижчою за :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` / :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` FPS. Це зроблено, щоб уникнути сценаріїв «спіралі смерті», коли продуктивність різко впаде через постійно зростаючу кількість кроків фізики на кадр. Ця поведінка впливає на :ref:`_process()<class_Node_private_method__process>` і :ref:`_physics_process()<class_Node_private_method__physics_process>`. Тому уникайте використання ``delta`` для вимірювання часу в реальних секундах. Використовуйте для цієї мети натомість методи синглтона :ref:`Time<class_Time>`, наприклад :ref:`Time.get_ticks_usec()<class_Time_method_get_ticks_usec>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_process_delta_time:

.. rst-class:: classref-method

:ref:`float<class_float>` **get_process_delta_time**\ (\ ) |const| :ref:`🔗<class_Node_method_get_process_delta_time>`

Повертає час, що минув (у секундах) з моменту останнього зворотного виклику процесу. Це значення ідентичне параметру ``delta`` :ref:`_process()<class_Node_private_method__process>` і може відрізнятися від кадру до кадру. Дивіться також :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>`. 

\ **Примітка:** Повернене значення буде більшим за очікуване, якщо частота кадрів буде нижчою за :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` / :ref:`Engine.max_physics_steps_per_frame<class_Engine_property_max_physics_steps_per_frame>` FPS. Це зроблено, щоб уникнути сценаріїв «спіралі смерті», коли продуктивність різко впаде через постійно зростаючу кількість кроків фізики на кадр. Ця поведінка впливає на :ref:`_process()<class_Node_private_method__process>` і :ref:`_physics_process()<class_Node_private_method__physics_process>`. Тому уникайте використання ``delta`` для вимірювання часу в реальних секундах. Використовуйте для цієї мети натомість методи синглтона :ref:`Time<class_Time>`, наприклад :ref:`Time.get_ticks_usec()<class_Time_method_get_ticks_usec>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_scene_instance_load_placeholder:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **get_scene_instance_load_placeholder**\ (\ ) |const| :ref:`🔗<class_Node_method_get_scene_instance_load_placeholder>`

Повертає ``true``, якщо цей вузол є власником розміру навантаження екземпляра. Див. :ref:`InstancePlaceholder<class_InstancePlaceholder>` і :ref:`set_scene_instance_load_placeholder()<class_Node_method_set_scene_instance_load_placeholder>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree:

.. rst-class:: classref-method

:ref:`SceneTree<class_SceneTree>` **get_tree**\ (\ ) |const| :ref:`🔗<class_Node_method_get_tree>`

Повертає :ref:`SceneTree<class_SceneTree>`, що містить цей вузол. Якщо це вершина не всередині дерева, генерує помилку і повертає ``null``. Дивись також :ref:`is_inside_tree()<class_Node_method_is_inside_tree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree_string:

.. rst-class:: classref-method

:ref:`String<class_String>` **get_tree_string**\ (\ ) :ref:`🔗<class_Node_method_get_tree_string>`

Повертає дерево як :ref:`String<class_String>`. Використовується в основному для налагодження. Ця версія відображає шлях відносно поточного вузла та підходить для копіювання/вставлення в :ref:`get_node()<class_Node_method_get_node>` функція. Його також можна використовувати в UI/UX гри.

Можна друкувати, наприклад:

.. code:: text

    TheGame
    TheGame/Menu
    TheGame/Menu/Label
    TheGame/Menu/Camera2D
    TheGame/SplashScreen
    TheGame/SplashScreen/Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_tree_string_pretty:

.. rst-class:: classref-method

:ref:`String<class_String>` **get_tree_string_pretty**\ (\ ) :ref:`🔗<class_Node_method_get_tree_string_pretty>`

Подібно до :ref:`get_tree_string()<class_Node_method_get_tree_string>`, це повертає дерево як :ref:`String<class_String>`. Ця версія відображає більш графічне представлення, подібне до того, що відображається в Scene Dock. Це корисно для огляду великих дерев.

Можна друкувати, наприклад:

.. code:: text

     ┖╴TheGame
        ┠╴Menu
        ┃  ┠╴Label
        ┃  ┖╴Camera2D
        ┖╴SplashScreen
           ┖╴Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_viewport:

.. rst-class:: classref-method

:ref:`Viewport<class_Viewport>` **get_viewport**\ (\ ) |const| :ref:`🔗<class_Node_method_get_viewport>`

Повертає найближчого предка вузла :ref:`Viewport<class_Viewport>`, якщо вузол знаходиться всередині дерева. В іншому випадку повертає ``null``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_get_window:

.. rst-class:: classref-method

:ref:`Window<class_Window>` **get_window**\ (\ ) |const| :ref:`🔗<class_Node_method_get_window>`

Повертаємо :ref:`Window<class_Window>`, що містить цей вузол. Якщо вершина знаходиться в головному вікні, це еквівалентно отримання кореневого вузла (``get_tree().get_root()``).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_has_node:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **has_node**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_has_node>`

Повертає ``true``, якщо ``path`` точки до дійсного вузла. Дивитися також :ref:`get_node()<class_Node_method_get_node>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_has_node_and_resource:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **has_node_and_resource**\ (\ path\: :ref:`NodePath<class_NodePath>`\ ) |const| :ref:`🔗<class_Node_method_has_node_and_resource>`

Повертає ``true``, якщо ``path`` точки до дійсного вузла і його субім'ям точки до дії :ref:`Resource<class_Resource>`, наприклад ``Area2D/CollisionShape2D:shape``. Властивості, які не є :ref:`Resource<class_Resource>` типи (наприклад, вузли або інші типи :ref:`Variant<class_Variant>`). Дивись також :ref:`get_node_and_resource()<class_Node_method_get_node_and_resource>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_ancestor_of:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_ancestor_of**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_ancestor_of>`

Повертає ``true``, якщо надана ``node`` є прямою або непрямою дитиною цього вузла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_displayed_folded:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_displayed_folded**\ (\ ) |const| :ref:`🔗<class_Node_method_is_displayed_folded>`

Повертає ``true``, якщо вершина складена (знімається) в Сцену док. Цей метод призначений для використання в додатках редактора та інструментах. Дивись також :ref:`set_display_folded()<class_Node_method_set_display_folded>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_editable_instance:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_editable_instance**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_editable_instance>`

Повертає ``true``, якщо ``node`` має відредаговані діти, що ввімкнули відносно цього вузла. Цей метод призначений для використання в додатках редактора та інструментах. Дивись ще :ref:`set_editable_instance()<class_Node_method_set_editable_instance>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_greater_than:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_greater_than**\ (\ node\: :ref:`Node<class_Node>`\ ) |const| :ref:`🔗<class_Node_method_is_greater_than>`

Повертає ``true``, якщо надана ``node`` відбувається пізніше в ієрархії сцени, ніж цей вузол. Вузол, що виникає пізніше, зазвичай оброблюється останнім.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_in_group:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_in_group**\ (\ group\: :ref:`StringName<class_StringName>`\ ) |const| :ref:`🔗<class_Node_method_is_in_group>`

Повертає ``true``, якщо ця вершина була додана в даній ``group``. Див. :ref:`add_to_group()<class_Node_method_add_to_group>` і :ref:`remove_from_group()<class_Node_method_remove_from_group>`. Дивись також ноти в описі, а також способи групи :ref:`SceneTree<class_SceneTree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_inside_tree:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_inside_tree**\ (\ ) |const| :ref:`🔗<class_Node_method_is_inside_tree>`

Повертає ``true``, якщо цей вузол в даний час знаходиться всередині :ref:`SceneTree<class_SceneTree>`. Дивись також :ref:`get_tree()<class_Node_method_get_tree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_multiplayer_authority:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_multiplayer_authority**\ (\ ) |const| :ref:`🔗<class_Node_method_is_multiplayer_authority>`

Повертає ``true``, якщо локальна система є багатокористувацьким органом цієї вершини.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_node_ready:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_node_ready**\ (\ ) |const| :ref:`🔗<class_Node_method_is_node_ready>`

Повертаємо ``true``, якщо вершина готова, тобто це внутрішня сцена дерево і всі її діти ініціюються.

\ :ref:`request_ready()<class_Node_method_request_ready>` скинути його назад до ``false``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_part_of_edited_scene:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_part_of_edited_scene**\ (\ ) |const| :ref:`🔗<class_Node_method_is_part_of_edited_scene>`

Повертаємо ``true``, якщо вершина є частиною сцени, яка в даний час відкрита в редакторі.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_interpolated:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_interpolated**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_interpolated>`

Повертає ``true``, якщо фізичний інтерполяція включена для цього вузла (див. :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`).

\ **Примітка:** Інтерполяція буде активний, якщо обидва прапори встановлюються ** і** фізика інтерполяції включена в межах :ref:`SceneTree<class_SceneTree>`. Це може бути протестований за допомогою :ref:`is_physics_interpolated_and_enabled()<class_Node_method_is_physics_interpolated_and_enabled>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_interpolated_and_enabled:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_interpolated_and_enabled**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_interpolated_and_enabled>`

``true``, якщо фізичний інтерполяція включена (див. :ref:`physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) ** і** включений в :ref:`SceneTree<class_SceneTree>`.

Це зручна версія :ref:`is_physics_interpolated()<class_Node_method_is_physics_interpolated>`, яка також перевіряє, чи є у світі фізика.

Див. :ref:`SceneTree.physics_interpolation<class_SceneTree_property_physics_interpolation>` та :ref:`ProjectSettings.physics/common/physics_interpolation<class_ProjectSettings_property_physics/common/physics_interpolation>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_processing:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_processing**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_processing>`

Повертає ``true``, якщо обробка фізики ввімкнена (див. :ref:`set_physics_process()<class_Node_method_set_physics_process>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_physics_processing_internal:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_physics_processing_internal**\ (\ ) |const| :ref:`🔗<class_Node_method_is_physics_processing_internal>`

Повертає ``true``, якщо внутрішня обробка фізики увімкнена (див. :ref:`set_physics_process_internal()<class_Node_method_set_physics_process_internal>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing>`

Повертає ``true``, якщо обробка ввімкнена (див. :ref:`set_process()<class_Node_method_set_process>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_input>`

Повертає ``true``, якщо вузол обробляє вхідні дані (див. :ref:`set_process_input()<class_Node_method_set_process_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_internal:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_internal**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_internal>`

Повернення ``true``, якщо ввімкнено внутрішню обробку (див. :ref:`set_process_internal()<class_Node_method_set_process_internal>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_shortcut_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_shortcut_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_shortcut_input>`

Повертає ``true``, якщо вершина обробляє ярлики (див. :ref:`set_process_shortcut_input()<class_Node_method_set_process_shortcut_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_unhandled_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_unhandled_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_unhandled_input>`

Повертає ``true``, якщо вершина обробляється безручним введенням (див. :ref:`set_process_unhandled_input()<class_Node_method_set_process_unhandled_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_is_processing_unhandled_key_input:

.. rst-class:: classref-method

:ref:`bool<class_bool>` **is_processing_unhandled_key_input**\ (\ ) |const| :ref:`🔗<class_Node_method_is_processing_unhandled_key_input>`

Повертає ``true``, якщо вершина обробляється безручним вхідним ключем (див. :ref:`set_process_unhandled_key_input()<class_Node_method_set_process_unhandled_key_input>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_move_child:

.. rst-class:: classref-method

|void| **move_child**\ (\ child_node\: :ref:`Node<class_Node>`, to_index\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_move_child>`

Мовы ``child_node`` до даного індексу. Індекс вузла - це порядок серед своїх дробів. Якщо ``to_index`` є негативним, індекс розраховується з кінця списку. Дивись також :ref:`get_child()<class_Node_method_get_child>` і :ref:`get_index()<class_Node_method_get_index>`.

\ **Примітка:** Порядок обробки декількох зворотньих викликів двигуна (:ref:`_ready()<class_Node_private_method__ready>`, :ref:`_process()<class_Node_private_method__process>` і т.д.) і повідомлень, які надсилаються через :ref:`проагіт_notification()<class_Node_method_проагіт_notification>`, впливає на порядок дерева. :ref:`CanvasItem<class_CanvasItem>` вершини також подаються в порядку дерева. Дивись ще :ref:`process_priority<class_Node_property_process_priority>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_notify_deferred_thread_group:

.. rst-class:: classref-method

|void| **notify_deferred_thread_group**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_notify_deferred_thread_group>`

Подібно до :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>`, але для повідомлень.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_notify_thread_safe:

.. rst-class:: classref-method

|void| **notify_thread_safe**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_notify_thread_safe>`

Подібно до :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, але для сповіщень.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_orphan_nodes:

.. rst-class:: classref-method

|void| **print_orphan_nodes**\ (\ ) |static| :ref:`🔗<class_Node_method_print_orphan_nodes>`

Друкує всі дочірні вершини (безкоштовно з :ref:`SceneTree<class_SceneTree>`). Корисно для видалення.

\ **Примітка:** Цей метод працює тільки в будівельних конструкціях. Чи нічого в проекті, що експортується в режимі релізу.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_tree:

.. rst-class:: classref-method

|void| **print_tree**\ (\ ) :ref:`🔗<class_Node_method_print_tree>`

Виводить вузол і його дочірні елементи на консоль рекурсивно. Вузол не обов'язково повинен бути всередині дерева. Цей метод виводить :ref:`NodePath<class_NodePath>`\ s відносно цього вузла, і добре підходить для копіювання/вставлення в :ref:`get_node()<class_Node_method_get_node>`. Дивіться також :ref:`print_tree_pretty()<class_Node_method_print_tree_pretty>`.

May print, for example:

.. code:: text

    .
    Menu
    Menu/Label
    Menu/Camera2D
    SplashScreen
    SplashScreen/Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_print_tree_pretty:

.. rst-class:: classref-method

|void| **print_tree_pretty**\ (\ ) :ref:`🔗<class_Node_method_print_tree_pretty>`

Виводить вузол і його дочірні елементи на консоль рекурсивно. Вузол не обов'язково повинен бути всередині дерева. Схожий на :ref:`print_tree()<class_Node_method_print_tree>`, але графічний представлення виглядає як те, що відображається в док-станції Scene редактора. Це корисно для огляду великих дерев.

Можна друкувати, наприклад:

.. code:: text

     ┖╴TheGame
        ┠╴Menu
        ┃  ┠╴Label
        ┃  ┖╴Camera2D
        ┖╴SplashScreen
           ┖╴Camera2D

.. rst-class:: classref-item-separator

----

.. _class_Node_method_propagate_call:

.. rst-class:: classref-method

|void| **propagate_call**\ (\ method\: :ref:`StringName<class_StringName>`, args\: :ref:`Array<class_Array>` = [], parent_first\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_propagate_call>`

Дзвінки з вказаною назвою ``method``, проходячи ``args`` як аргументи, на цьому вершині і всіх його дітей, рекурсивно.

Якщо ``parent_first`` є ``true``, метод називається на цьому вершині спочатку, потім на всіх його дітей. Якщо ``false``, перші методи дітей.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_propagate_notification:

.. rst-class:: classref-method

|void| **propagate_notification**\ (\ what\: :ref:`int<class_int>`\ ) :ref:`🔗<class_Node_method_propagate_notification>`

Викликає :ref:`Object.notification()<class_Object_method_notification>` з ``what`` на цьому вузлі та всіх його дочірніх вузлах рекурсивно.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_queue_accessibility_update:

.. rst-class:: classref-method

|void| **queue_accessibility_update**\ (\ ) :ref:`🔗<class_Node_method_queue_accessibility_update>`

Ставить у чергу оновлення інформації про доступність для цього вузла.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_queue_free:

.. rst-class:: classref-method

|void| **queue_free**\ (\ ) :ref:`🔗<class_Node_method_queue_free>`

Прийміть цей вузол, щоб бути видалений в кінці поточного кадру. При видаленні всі його діти видаляються, і всі посилання на вузол і його діти стають недійсними.

На відміну від :ref:`Object.free()<class_Object_method_free>`, вузол не видаляється миттєво, і його ще можна отримати до видалення. Це також безпечно для виклику :ref:`queue_free()<class_Node_method_queue_free>` кілька разів. Використовуйте :ref:`Object.is_queued_for_deletion()<class_Object_method_is_queued_for_deletion>`, щоб перевірити, чи буде видалено вузол в кінці кадру.

\ **Примітка:** Після завершення всіх інших відкладених дзвінків буде безкоштовно вузол. Використовуйте цей метод не завжди так само, як і виклик :ref:`Object.free()<class_Object_method_free>` за допомогою :ref:`Object.call_deferred()<class_Object_method_call_deferred>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_remove_child:

.. rst-class:: classref-method

|void| **remove_child**\ (\ node\: :ref:`Node<class_Node>`\ ) :ref:`🔗<class_Node_method_remove_child>`

Видаліть дитину ``node``. ``node``, разом з дітьми **not** видалено. Щоб видалити вузол, див. :ref:`queue_free()<class_Node_method_queue_free>`.

\ **Примітка:** Коли цей вузол знаходиться всередині дерева, цей метод встановлює :ref:`owner<class_Node_property_owner>` видаленого ``node`` (або його нащадки) до ``нулл``, якщо їх :ref:`owner<class_Node_property_owner>` не більше предків (див. :ref:`is_ancestor_of()<class_Node_method_is_ancestor_of>`).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_remove_from_group:

.. rst-class:: classref-method

|void| **remove_from_group**\ (\ group\: :ref:`StringName<class_StringName>`\ ) :ref:`🔗<class_Node_method_remove_from_group>`

Видаляє вузол із заданої групи ``group``. Нічого не робить, якщо вузол не знаходиться в групі ``group``. Див. також примітки в описі та методи групування :ref:`SceneTree<class_SceneTree>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_reparent:

.. rst-class:: classref-method

|void| **reparent**\ (\ new_parent\: :ref:`Node<class_Node>`, keep_global_transform\: :ref:`bool<class_bool>` = true\ ) :ref:`🔗<class_Node_method_reparent>`

Змінює батьківщину цього **Node** на ``new_parent``. На вершині потрібно вже мати батьківство. При збереженні вершини, якщо його власник ще не досягається від нового місця розташування (тобто вузол ще є спадковим новим батьком після операції).

\ ``true``, глобальна трансформація вершини буде збережена, якщо підтримується. :ref:`Node2D<class_Node2D>`, :ref:`Node3D<class_Node3D>` та :ref:`Control<class_Control>` підтримують цей аргумент (але :ref:`Control<class_Control>` зберігає лише позицію).

.. rst-class:: classref-item-separator

----

.. _class_Node_method_replace_by:

.. rst-class:: classref-method

|void| **replace_by**\ (\ node\: :ref:`Node<class_Node>`, keep_groups\: :ref:`bool<class_bool>` = false\ ) :ref:`🔗<class_Node_method_replace_by>`

Замінює цей вузол за допомогою даної ``node``. Всі діти даного вузла переходять на ``node``.

Якщо ``keep_groups`` є ``true``, ``node`` додається до тих же груп, які замінений вузол знаходиться в (див. :ref:`add_to_group()<class_Node_method_add_to_group>`).

\ **Попередження:** Заміщений вузол знімається з дерева, але це **не** видалено. Щоб запобігти витокам пам'яті, зберігайте посилання на вершину в змінній, або скористайтеся :ref:`Object.free()<class_Object_method_free>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_request_ready:

.. rst-class:: classref-method

|void| **request_ready**\ (\ ) :ref:`🔗<class_Node_method_request_ready>`

Запити :ref:`_ready()<class_Node_private_method__ready>`, щоб називатися знову в наступний раз вершина надходить в дерево. **not** відразу ж виклик :ref:`_ready()<class_Node_private_method__ready>`.

\ **Примітка:** Цей метод тільки впливає на поточний вузол. Якщо діти вершини також повинні запитати готових, цей метод потрібно назвати для кожного з них. Коли вершина і її діти знову вводять дерево, порядок :ref:`_ready()<class_Node_private_method__ready>` викликів буде таким же, як нормально.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_reset_physics_interpolation:

.. rst-class:: classref-method

|void| **reset_physics_interpolation**\ (\ ) :ref:`🔗<class_Node_method_reset_physics_interpolation>`

Коли фізика інтерполяція активна, переміщення вузла до радикально різних трансформацій (наприклад, розміщення в межах рівня) може призвести до видимого блиску, оскільки об'єкт є рухомим від старого до нової позиції над фізикою.

Цей метод може бути попереджений, що тимчасово відключається міжполяція до завершення фізики.

Повідомлення :ref:`NOTIFICATION_RESET_PHYSICS_INTERPOLATION<class_Node_constant_NOTIFICATION_RESET_PHYSICS_INTERPOLATION>` отримає вузол і всі діти рекурсивно.

\ **Примітка:** Ця функція повинна бути викликана **після**, що переміщує вузол, а не раніше.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **rpc**\ (\ method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_rpc>`

Відправляє заявку на віддалений порядок виклику для вказаного ``method`` до однолітків в мережі (і локально), надсилання додаткових аргументів до методу, що називається RPC. Запит виклику буде отримано лише в вузлах з тим же :ref:`NodePath<class_NodePath>`, в тому числі точне же :ref:`name<class_Node_property_name>`. Behavior залежить від конфігурації RPC для даного ``method`` (див. :ref:`rpc_config()<class_Node_method_rpc_config>` і ``анотація @GDScript.@rpc``). За замовчуванням методи не піддаються RPCs.

Може повернутися :ref:`@GlobalScope.OK<class_@GlobalScope_constant_OK>`, якщо виклик успішний, :ref:`@GlobalScope.ERR_INVALID_PARAMETER<class_@GlobalScope_constant_ERR_INVALID_PARAMETER>`, якщо аргументи пропущені в ``method`` не відповідають, :ref:`@GlobalScope.ERR_UNCONFIGURED<class_@GlobalScope_constant_ERR_UNCONFIGURED>`, якщо вершина :ref:`multiplayer<class_Node_property_multiplayer>` не може бути fetched (наприклад, коли вершина не всередині дерева), :ref:`@GlobalScope.ERR_CONNECTION_ERROR<class_@GlobalScope_constant_ERR_CONNECTION_ERROR>` якщо :ref:`multiplayer<class_Node_property_multiplayer>` підключення не доступний.

\ **Примітка:** Ви можете використовувати тільки RPC на клієнтів після отримання :ref:`MultiplayerAPI.connected_to_server<class_MultiplayerAPI_signal_connected_to_server>` сигнал від :ref:`MultiplayerAPI<class_MultiplayerAPI>`. Також потрібно стежити за станом з'єднання, або за сигналами :ref:`MultiplayerAPI<class_MultiplayerAPI>`, такими як :ref:`MultiplayerAPI.server_disconnected<class_MultiplayerAPI_signal_server_disconnected>` або за допомогою перевірки (``get_multiplayer().peer.get_connection_status()==== Коннекція ``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc_config:

.. rst-class:: classref-method

|void| **rpc_config**\ (\ method\: :ref:`StringName<class_StringName>`, config\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_rpc_config>`

Зміна конфігурації RPC для вказаного ``method``. ``config`` повинен бути ``null``, щоб вимкнути функцію (як за замовчуванням), або :ref:`Dictionary<class_Dictionary>`, що містить наступні записи:

- ``rpc_mode``: див. :ref:`RPCMode<enum_MultiplayerAPI_RPCMode>`;

- ``transfer_mode``: див. :ref:`TransferMode<enum_MultiplayerPeer_TransferMode>`;

- ``call_local``: if ``true``, метод також буде називатися локально;

- ``канал``: :ref:`int<class_int>`, що представляє канал для надсилання на RPC.

\ **Note:** У GDScript цей метод відповідає анотаціям :ref:`@GDScript.@rpc<class_@GDScript_annotation_@rpc>` анотація, з різними параметрами, що пройшли (``@rpc(будього)``, ``@rpc(авторитет)``. Дивись також :doc:`Високий рівень мультиплеер <../tutorials/networking/high_level_multiplayer>` підручник.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_rpc_id:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **rpc_id**\ (\ peer_id\: :ref:`int<class_int>`, method\: :ref:`StringName<class_StringName>`, ...\ ) |vararg| :ref:`🔗<class_Node_method_rpc_id>`

Відправляє :ref:`rpc()<class_Node_method_rpc>` на конкретний одноліток, який виділяється ``однолітків`` (див. :ref:`MultiplayerPeer.set_target_peer()<class_MultiplayerPeer_method_set_target_peer>`).

Може повернутися :ref:`@GlobalScope.OK<class_@GlobalScope_constant_OK>`, якщо виклик успішний, :ref:`@GlobalScope.ERR_INVALID_PARAMETER<class_@GlobalScope_constant_ERR_INVALID_PARAMETER>`, якщо аргументи пропущені в ``method`` не відповідають, :ref:`@GlobalScope.ERR_UNCONFIGURED<class_@GlobalScope_constant_ERR_UNCONFIGURED>`, якщо вершина :ref:`multiplayer<class_Node_property_multiplayer>` не може бути fetched (наприклад, коли вершина не всередині дерева), :ref:`@GlobalScope.ERR_CONNECTION_ERROR<class_@GlobalScope_constant_ERR_CONNECTION_ERROR>` якщо :ref:`multiplayer<class_Node_property_multiplayer>` підключення не доступний.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_deferred_thread_group:

.. rst-class:: classref-method

|void| **set_deferred_thread_group**\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_set_deferred_thread_group>`

Подібно до :ref:`call_deferred_thread_group()<class_Node_method_call_deferred_thread_group>`, але для налаштування властивостей.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_display_folded:

.. rst-class:: classref-method

|void| **set_display_folded**\ (\ fold\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_display_folded>`

Якщо встановити до ``true``, вершина з'являється в сцені док. В результаті всі свої діти приховані. Цей метод призначений для використання в додатках редактора та інструментах, але він також працює в конструкторах. Дивись також ``method_displayed_folded``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_editable_instance:

.. rst-class:: classref-method

|void| **set_editable_instance**\ (\ node\: :ref:`Node<class_Node>`, is_editable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_editable_instance>`

Встановити до ``true``, щоб дозволити всі вершини, що належать ``node``, щоб бути доступні і редаговані, в Сцену док, навіть якщо їх :ref:`owner<class_Node_property_owner>` не корінь сцени. Цей метод призначений для використання в додатках редактора та інструментах, але він також працює в конструкторах. Дивись також ``method_editable_instance``.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_multiplayer_authority:

.. rst-class:: classref-method

|void| **set_multiplayer_authority**\ (\ id\: :ref:`int<class_int>`, recursive\: :ref:`bool<class_bool>` = true\ ) :ref:`🔗<class_Node_method_set_multiplayer_authority>`

Налаштовує багатокористувацький орган вузла до однолітків із заданим однолітком ``id``. Багатокористувацька влада є однолітками, які мають повноваження над вершиною на мережі. За замовчуванням до ID 1 (сервер). Корисно в поєднанні з :ref:`rpc_config()<class_Node_method_rpc_config>` і :ref:`MultiplayerAPI<class_MultiplayerAPI>`.

Якщо ``recursive`` є ``true``, заданий одноліток рекурсивно встановлюється як орган для всіх дітей цієї вершини.

\ **Попередження:** Це **не** автоматично реплікує нову владу іншим аналогам. Це відповідальність розробника. Ви можете відреагувати інформацію нової влади за допомогою :ref:`MultiplayerSpawner.spawn_function<class_MultiplayerSpawner_property_spawn_function>`, RPC або :ref:`MultiplayerSynchronizer<class_MultiplayerSynchronizer>`. Крім того, батьківський орган працює ** не**, пропагувати до новостворених дітей.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_physics_process:

.. rst-class:: classref-method

|void| **set_physics_process**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_physics_process>`

Якщо встановити на ``true``, дозволяє фізичну (фіксовану рамурат) обробку. Коли буде оброблено вузол, він отримає :ref:`NOTIFICATION_PHYSICS_PROCESS<class_Node_constant_NOTIFICATION_PHYSICS_PROCESS>` на фіксованій (зазвичай 60 FPS див. :ref:`Engine.physics_ticks_per_second<class_Engine_property_physics_ticks_per_second>` для зміни) інтервал (і :ref:`_physics_process()<class_Node_private_method__physics_process>` виклик буде викликано, якщо він існує).

\ **Примітка:** Якщо :ref:`_physics_process()<class_Node_private_method__physics_process>` перейменувати, це буде автоматично ввімкнено до :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_physics_process_internal:

.. rst-class:: classref-method

|void| **set_physics_process_internal**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_physics_process_internal>`

Якщо встановити до ``true``, дозволяє внутрішню фізику для цього вузла. Внутрішня фізична обробка відбувається в ізоляції від нормальної :ref:`_physics_process()<class_Node_private_method__physics_process>` викликів і використовується деякими вузлами внутрішньо, щоб забезпечити належне функціонування, навіть якщо вершина використовується або фізико-обробка вимкнена для скриптування (:ref:`set_physics_process()<class_Node_method_set_physics_process>`).

\ **Попередження:** Вбудовані вузли спираються на внутрішню обробку для їх внутрішньої логіки. Небезпечний і може призвести до несподіваної поведінки. Використовуйте цей метод, якщо ви знаєте, що ви робите.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process:

.. rst-class:: classref-method

|void| **set_process**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process>`

Якщо встановити до ``true``, дозволяє обробляти. Коли буде оброблено вершину, він отримає :ref:`NOTIFICATION_PROCESS<class_Node_constant_NOTIFICATION_PROCESS>` на кожному зображеному кадрі (і :ref:`_process()<class_Node_private_method__process>` виклик буде викликано, якщо він існує).

\ **Примітка:** Якщо :ref:`_process()<class_Node_private_method__process>` перейдиден, це буде автоматично ввімкнено до :ref:`_ready()<class_Node_private_method__ready>`.

\ **Примітка:** Цей метод тільки впливає на зворотний зв'язок :ref:`_process()<class_Node_private_method__process>`, тобто він не впливає на інші виклики, такі як :ref:`_physics_process()<class_Node_private_method__physics_process>`. Якщо ви хочете вимкнути всю обробку для вузла, встановіть :ref:`process_mode<class_Node_property_process_mode>` до :ref:`PROCESS_MODE_DISABLED<class_Node_constant_PROCESS_MODE_DISABLED>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_input:

.. rst-class:: classref-method

|void| **set_process_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_input>`

Якщо встановити до ``true``, дозволяє обробку вхідних даних.

\ **Примітка:** Якщо :ref:`_input()<class_Node_private_method__input>` перейменування, це буде автоматично ввімкнено до :ref:`_ready()<class_Node_private_method__ready>`. Увімкнути обробку даних також можна для керування GUI, таких як :ref:`Button<class_Button>` та :ref:`TextEdit<class_TextEdit>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_internal:

.. rst-class:: classref-method

|void| **set_process_internal**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_internal>`

Якщо встановити до ``true``, дозволяє внутрішню обробку для цього вузла. Внутрішня обробка відбувається в ізоляції від нормального :ref:`_process()<class_Node_private_method__process>` викликів і використовується деякими вузлами внутрішнє, щоб гарантувати належне функціонування, навіть якщо вершина використовується або обробка вимкнена для сценаріїв (:ref:`set_process()<class_Node_method_set_process>`).

\ **Попередження:** Вбудовані вузли спираються на внутрішню обробку для їх внутрішньої логіки. Небезпечний і може призвести до несподіваної поведінки. Використовуйте цей метод, якщо ви знаєте, що ви робите.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_shortcut_input:

.. rst-class:: classref-method

|void| **set_process_shortcut_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_shortcut_input>`

Якщо встановити до ``true``, дозволяє проводити обробку ярликів для цього вузла.

\ **Примітка:** Якщо :ref:`_shortcut_input()<class_Node_private_method__shortcut_input>` перевизначається, це буде автоматично включений до :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_unhandled_input:

.. rst-class:: classref-method

|void| **set_process_unhandled_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_unhandled_input>`

Якщо встановити на ``true``, дозволяє проводити обробку даних вхідного. Увімкнути вузол, щоб отримати всі вхідні дані, які раніше не були оброблені (зазвичай за допомогою :ref:`Control<class_Control>`).

\ **Примітка:** Якщо :ref:`_unhandled_input()<class_Node_private_method__unhandled_input>` перейменований, це буде автоматично ввімкнено до :ref:`_ready()<class_Node_private_method__ready>`. Увімкнути обробку даних також можна для керування графічними інтерфейсами, такими як :ref:`Button<class_Button>` та :ref:`TextEdit<class_TextEdit>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_process_unhandled_key_input:

.. rst-class:: classref-method

|void| **set_process_unhandled_key_input**\ (\ enable\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_process_unhandled_key_input>`

Якщо встановити до ``true``, що дозволяє обробляти вхідний ключ.

\ **Примітка:** Якщо :ref:`_unhandled_key_input()<class_Node_private_method__unhandled_key_input>` перейменований, це буде автоматично включений до :ref:`_ready()<class_Node_private_method__ready>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_scene_instance_load_placeholder:

.. rst-class:: classref-method

|void| **set_scene_instance_load_placeholder**\ (\ load_placeholder\: :ref:`bool<class_bool>`\ ) :ref:`🔗<class_Node_method_set_scene_instance_load_placeholder>`

Якщо встановлено значення ``true``, вузол стає :ref:`InstancePlaceholder<class_InstancePlaceholder>` після упаковки та створення екземпляра з :ref:`PackedScene<class_PackedScene>`. Див. також :ref:`get_scene_instance_load_placeholder()<class_Node_method_get_scene_instance_load_placeholder>`.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_thread_safe:

.. rst-class:: classref-method

|void| **set_thread_safe**\ (\ property\: :ref:`StringName<class_StringName>`, value\: :ref:`Variant<class_Variant>`\ ) :ref:`🔗<class_Node_method_set_thread_safe>`

Подібно до :ref:`call_thread_safe()<class_Node_method_call_thread_safe>`, але для налаштування властивостей.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_set_translation_domain_inherited:

.. rst-class:: classref-method

|void| **set_translation_domain_inherited**\ (\ ) :ref:`🔗<class_Node_method_set_translation_domain_inherited>`

Цей вузол успадковує домен перекладу від свого батьківського вузла. Якщо цей вузол не має батьківського вузла, буде використано основний домен перекладу. 

Це стандартна поведінка для всіх вузлів. Виклик :ref:`Object.set_translation_domain()<class_Object_method_set_translation_domain>` вимикає цю поведінку.

.. rst-class:: classref-item-separator

----

.. _class_Node_method_update_configuration_warnings:

.. rst-class:: classref-method

|void| **update_configuration_warnings**\ (\ ) :ref:`🔗<class_Node_method_update_configuration_warnings>`

Відновлює попередження, що відображаються для цього вузла в додатку сцени. Використовуйте :ref:`_get_configuration_warnings()<class_Node_private_method__get_configuration_warnings>` для налаштування повідомлень попередження для відображення.

.. |virtual| replace:: :abbr:`virtual (Зазвичай, цей метод перевизначається користувачем, щоб він мав вплив.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (Цей метод не має побічних ефектів. Не змінює ніяку змінну екземпляра об'єкта.)`
.. |vararg| replace:: :abbr:`vararg (Цей метод приймає будь-яке число аргументів після описаних тут.)`
.. |constructor| replace:: :abbr:`constructor (Цей метод використовується для побудови типів.)`
.. |static| replace:: :abbr:`static (Цей метод не потребує екземпляра для виклику, його можна викликати безпосередньо за допомогою назви класу.)`
.. |operator| replace:: :abbr:`operator (Цей метод описує дійсний оператор для взаємодії з цим типом як з лівим операндом.)`
.. |bitfield| replace:: :abbr:`BitField (Це значення є цілим числом, складеним у вигляді бітової маски з наступних прапорів.)`
.. |void| replace:: :abbr:`void (Значення не повертається.)`
