:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Variant.xml.

.. _class_Variant:

Variant
=======

Найголовніший тип даних в Godot.

.. rst-class:: classref-introduction-group

Опис
--------

У комп’ютерному програмуванні клас Variant — це клас, призначений для зберігання ряду інших типів. Мови динамічного програмування, такі як PHP, Lua, JavaScript і GDScript, люблять використовувати їх для зберігання даних змінних на сервері. За допомогою цих варіантів властивості можуть вільно змінювати типи значень.


.. tabs::

 .. code-tab:: gdscript

    var foo = 2 # foo є динамічним цілим числом
    foo = "Тепер foo є рядком!"
    foo = RefCounted.new() # foo є об'єктом
    var bar: int = 2 # bar є статично типізованим цілим числом.
    # bar = "Ой! Я не можу зробити так, щоб статично типізовані змінні стали іншим типом!"

 .. code-tab:: csharp

    // C# має статичний тип. Якщо змінна має тип, її неможливо змінити. Ви можете використовувати ключове слово `var`, щоб дозволити компілятору автоматично визначити тип.
    var foo = 2; // Foo є 32-розрядним цілим числом (int). Будьте обережні, цілі числа в GDScript є 64-розрядними, а прямим еквівалентом C# є `long`.
    // foo = "foo було і завжди буде цілим числом. Його не можна перетворити на рядок!";
    var boo = "Boo - це рядок!";
    var ref = new RefCounted(); // var особливо корисний при використанні разом з конструктором.

    // Godot також надає тип Variant, який працює як об’єднання всіх типів, сумісних з Variant.
    Варіант fooVar = 2; // fooVar є динамічним цілим числом (зберігається як `long` у типі Variant).
    fooVar = "Тепер fooVar є рядком!";
    fooVar = новий RefCounted(); // fooVar є GodotObject.



Godot відстежує всі змінні API сценаріїв у Variants. Навіть не усвідомлюючи цього, ви постійно використовуєте Варіанти. Коли певна мова встановлює власні правила збереження введених даних, тоді ця мова застосовує свою власну спеціальну логіку до базового API сценаріїв Variant.

- GDScript автоматично обгортає значення в них. Він зберігає всі дані у звичайних варіантах за замовчуванням, а потім, за бажанням, застосовує спеціальні правила статичної типізації для типів змінних.

- C# має статичний тип, але використовує власну реалізацію типу Variant замість класу Godot **Variant**, коли йому потрібно представити динамічне значення. C# Variant можна неявно призначити будь-який сумісний тип, але для перетворення потрібне явне приведення.

Глобальна функція :ref:`@GlobalScope.typeof()<class_@GlobalScope_method_typeof>` повертає перераховане значення типу Variant, що зберігається в поточній змінній (див. :ref:`Variant.Type<enum_@GlobalScope_Variant.Type>`).


.. tabs::

 .. code-tab:: gdscript

    var foo = 2
    match typeof(foo):
    TYPE_NIL:
    print("foo є null")
    TYPE_INT:
    print("foo є цілим числом")
    TYPE_OBJECT:
     # Зверніть увагу, що об'єкти є окремою спеціальною категорією.
     # Щоб отримати назву основного типу об’єкта, вам потрібен метод `get_class()`.
    print("foo is a(n) %s" % foo.get_class()) # ввести назву класу у відформатований рядок.
     # Зауважте, що це не отримує глобальний ідентифікатор `class_name` сценарію.
     # Якщо потрібне `class_name`, використовуйте замість нього `foo.get_script().get_global_name()`.

 .. code-tab:: csharp

    Variant foo = 2;
    swich (foo.VariantType)
    {
    case Variant.Type.Nil:
    GD.Print("foo має значення null");
     розрив;
    case Variant.Type.Int:
    GD.Print("foo є цілим числом");
     розрив;
    case Variant.Type.Object:
     // Зауважте, що об'єкти є окремою спеціальною категорією.
     // Ви можете перетворити Variant на GodotObject і використовувати відображення, щоб отримати його назву.
    GD.Print($"foo is a(n) {foo.AsGodotObject().GetType().Name}");
    break;
    }



Варіант займає лише 20 байт і може зберігати в собі майже будь-який тип даних механізму. Варіанти рідко використовуються для зберігання інформації протягом тривалого часу. Натомість вони використовуються в основному для зв’язку, редагування, серіалізації та переміщення даних.

Godot спеціально інвестував у те, щоб зробити свій клас Variant максимально гнучким; настільки, що він використовується для безлічі операцій для полегшення зв’язку між усіма системами Godot.

Варіант:

- Може зберігати майже будь-який тип даних.

- Може виконувати операції між багатьма варіантами. GDScript використовує Variant як атомарний/власний тип даних.

- Можна хешувати, тому його можна швидко порівняти з іншими варіантами.

- Можна використовувати для безпечного перетворення між типами даних.

- Може використовуватися для абстрактного виклику методів та їхніх аргументів. Godot експортує всі свої функції через варіанти.

- Може використовуватися для відкладення викликів або переміщення даних між потоками.

- Може бути серіалізовано як двійковий і збережений на диску або переданий через мережу.

- Можна серіалізувати в текст і використовувати його для друку значень і параметрів, які можна редагувати.

- Може працювати як експортована властивість, тому редактор може редагувати її універсально.

- Можна використовувати для словників, масивів, парсерів тощо.

\ **Контейнери (масив і словник):** обидва реалізовані за допомогою варіантів. :ref:`Dictionary<class_Dictionary>` може відповідати будь-якому типу даних, який використовується як ключ, до будь-якого іншого типу даних. :ref:`Array<class_Array>` містить лише масив варіантів. Звичайно, Variant також може містити всередині :ref:`Dictionary<class_Dictionary>` і :ref:`Array<class_Array>`, що робить його ще більш гнучким.

Внесення змін до контейнера призведе до зміни всіх посилань на нього. Слід створити :ref:`Mutex<class_Mutex>`, щоб заблокувати його, якщо потрібен багатопоточний доступ.

.. note::

	Існують значні відмінності при використанні цього API із С#. Більше інформації: ref:`doc_c_sharp_differences`.

.. rst-class:: classref-introduction-group

Посібники
------------------

- :doc:`Впровадження класного класу <../engine_details/architecture/variant_class>`

.. |virtual| replace:: :abbr:`virtual (Зазвичай, цей метод перевизначається користувачем, щоб він мав вплив.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (Цей метод не має побічних ефектів. Не змінює ніяку змінну екземпляра об'єкта.)`
.. |vararg| replace:: :abbr:`vararg (Цей метод приймає будь-яке число аргументів після описаних тут.)`
.. |constructor| replace:: :abbr:`constructor (Цей метод використовується для побудови типів.)`
.. |static| replace:: :abbr:`static (Цей метод не потребує екземпляра для виклику, його можна викликати безпосередньо за допомогою назви класу.)`
.. |operator| replace:: :abbr:`operator (Цей метод описує дійсний оператор для взаємодії з цим типом як з лівим операндом.)`
.. |bitfield| replace:: :abbr:`BitField (Це значення є цілим числом, складеним у вигляді бітової маски з наступних прапорів.)`
.. |void| replace:: :abbr:`void (Значення не повертається.)`
