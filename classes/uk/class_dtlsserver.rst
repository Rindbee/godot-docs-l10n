:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/DTLSServer.xml.

.. _class_DTLSServer:

DTLSServer
==========

**–£—Å–ø–∞–¥–∫–æ–≤—É—î:** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

–î–æ–ø–æ–º—ñ–∂–Ω–∏–π –∫–ª–∞—Å –¥–ª—è —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Å–µ—Ä–≤–µ—Ä–∞ DTLS.

.. rst-class:: classref-introduction-group

–û–ø–∏—Å
--------

–¶–µ–π –∫–ª–∞—Å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —Å—Ç–∞–Ω—É —Å–µ—Ä–≤–µ—Ä–∞ DTLS. –ü—ñ—Å–ª—è :ref:`setup()<class_DTLSServer_method_setup>` –≤—ñ–Ω –ø–µ—Ä–µ—Ç–≤–æ—Ä—é—î –ø—ñ–¥–∫–ª—é—á–µ–Ω—ñ :ref:`PacketPeerUDP<class_PacketPeerUDP>` –Ω–∞ :ref:`PacketPeerDTLS<class_PacketPeerDTLS>`, –ø—Ä–∏–π–º–∞—é—á–∏ —ó—Ö —á–µ—Ä–µ–∑ :ref:`take_connection()<class_DTLSServer_method_take_connection>` —è–∫ –∫–ª—ñ—î–Ω—Ç—ñ–≤ DTLS. –ü—ñ–¥ –∫–∞–ø–æ—Ç–æ–º —Ü–µ–π –∫–ª–∞—Å –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è —Å—Ç–∞–Ω—É DTLS —ñ —Ñ–∞–π–ª—ñ–≤ cookie —Å–µ—Ä–≤–µ—Ä–∞. –ü—Ä–∏—á–∏–Ω–∞, –∑ —è–∫–æ—ó –ø–æ—Ç—Ä—ñ–±–Ω—ñ —Å—Ç–∞–Ω —ñ —Ñ–∞–π–ª–∏ cookie, –≤–∏—Ö–æ–¥–∏—Ç—å –∑–∞ –º–µ–∂—ñ —Ü—ñ—î—ó –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó.

–ù–∏–∂—á–µ –Ω–∞–≤–µ–¥–µ–Ω–æ –Ω–µ–≤–µ–ª–∏–∫–∏–π –ø—Ä–∏–∫–ª–∞–¥ —Ç–æ–≥–æ, —è–∫ –Ω–∏–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è:


.. tabs::

 .. code-tab:: gdscript

    # server_node.gd
    extends Node

    var dtls := DTLSServer.new()
    var server := UDPServer.new()
    var peers = []

    func _ready():
        server.listen(4242)
        var key = load("key.key") # Your private key.
        var cert = load("cert.crt") # Your X509 certificate.
        dtls.setup(key, cert)

    func _process(delta):
        while server.is_connection_available():
            var peer: PacketPeerUDP = server.take_connection()
            var dtls_peer: PacketPeerDTLS = dtls.take_connection(peer)
            if dtls_peer.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING:
                continue # It is normal that 50% of the connections fails due to cookie exchange.
            print("Peer connected!")
            peers.append(dtls_peer)

        for p in peers:
            p.poll() # Must poll to update the state.
            if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
                while p.get_available_packet_count() > 0:
                    print("Received message from client: %s" % p.get_packet().get_string_from_utf8())
                    p.put_packet("Hello DTLS client".to_utf8_buffer())

 .. code-tab:: csharp

    // ServerNode.cs
    using Godot;

    public partial class ServerNode : Node
    {
        private DtlsServer _dtls = new DtlsServer();
        private UdpServer _server = new UdpServer();
        private Godot.Collections.Array<PacketPeerDtls> _peers = new Godot.Collections.Array<PacketPeerDtls>();

        public override void _Ready()
        {
            _server.Listen(4242);
            var key = GD.Load<CryptoKey>("key.key"); // Your private key.
            var cert = GD.Load<X509Certificate>("cert.crt"); // Your X509 certificate.
            _dtls.Setup(key, cert);
        }

        public override void _Process(double delta)
        {
            while (Server.IsConnectionAvailable())
            {
                PacketPeerUdp peer = _server.TakeConnection();
                PacketPeerDtls dtlsPeer = _dtls.TakeConnection(peer);
                if (dtlsPeer.GetStatus() != PacketPeerDtls.Status.Handshaking)
                {
                    continue; // It is normal that 50% of the connections fails due to cookie exchange.
                }
                GD.Print("Peer connected!");
                _peers.Add(dtlsPeer);
            }

            foreach (var p in _peers)
            {
                p.Poll(); // Must poll to update the state.
                if (p.GetStatus() == PacketPeerDtls.Status.Connected)
                {
                    while (p.GetAvailablePacketCount() > 0)
                    {
                        GD.Print($"Received Message From Client: {p.GetPacket().GetStringFromUtf8()}");
                        p.PutPacket("Hello DTLS Client".ToUtf8Buffer());
                    }
                }
            }
        }
    }




.. tabs::

 .. code-tab:: gdscript

    # client_node.gd
    extends Node

    var dtls := PacketPeerDTLS.new()
    var udp := PacketPeerUDP.new()
    var connected = false

    func _ready():
        udp.connect_to_host("127.0.0.1", 4242)
        dtls.connect_to_peer(udp, false) # Use true in production for certificate validation!

    func _process(delta):
        dtls.poll()
        if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
            if !connected:
                # Try to contact server
                dtls.put_packet("The answer is... 42!".to_utf8_buffer())
            while dtls.get_available_packet_count() > 0:
                print("Connected: %s" % dtls.get_packet().get_string_from_utf8())
                connected = true

 .. code-tab:: csharp

    // ClientNode.cs
    using Godot;
    using System.Text;

    public partial class ClientNode : Node
    {
        private PacketPeerDtls _dtls = new PacketPeerDtls();
        private PacketPeerUdp _udp = new PacketPeerUdp();
        private bool _connected = false;

        public override void _Ready()
        {
            _udp.ConnectToHost("127.0.0.1", 4242);
            _dtls.ConnectToPeer(_udp, validateCerts: false); // Use true in production for certificate validation!
        }

        public override void _Process(double delta)
        {
            _dtls.Poll();
            if (_dtls.GetStatus() == PacketPeerDtls.Status.Connected)
            {
                if (!_connected)
                {
                    // Try to contact server
                    _dtls.PutPacket("The Answer Is..42!".ToUtf8Buffer());
                }
                while (_dtls.GetAvailablePacketCount() > 0)
                {
                    GD.Print($"Connected: {_dtls.GetPacket().GetStringFromUtf8()}");
                    _connected = true;
                }
            }
        }
    }



.. rst-class:: classref-reftable-group

–ú–µ—Ç–æ–¥–∏
------------

.. table::
   :widths: auto

   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`       | :ref:`setup<class_DTLSServer_method_setup>`\ (\ server_options\: :ref:`TLSOptions<class_TLSOptions>`\ )                     |
   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PacketPeerDTLS<class_PacketPeerDTLS>` | :ref:`take_connection<class_DTLSServer_method_take_connection>`\ (\ udp_peer\: :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ) |
   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

–û–ø–∏—Å–∏ –º–µ—Ç–æ–¥—ñ–≤
--------------------------

.. _class_DTLSServer_method_setup:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **setup**\ (\ server_options\: :ref:`TLSOptions<class_TLSOptions>`\ ) :ref:`üîó<class_DTLSServer_method_setup>`

–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–µ—Ä–≤–µ—Ä–∞ DTLS –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –¥–∞–Ω–æ–≥–æ ``server_options``. –î–∏–≤. :ref:`TLSOptions.server()<class_TLSOptions_method_server>`.

.. rst-class:: classref-item-separator

----

.. _class_DTLSServer_method_take_connection:

.. rst-class:: classref-method

:ref:`PacketPeerDTLS<class_PacketPeerDTLS>` **take_connection**\ (\ udp_peer\: :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ) :ref:`üîó<class_DTLSServer_method_take_connection>`

–°–ø—Ä–æ–±—É–π—Ç–µ —Ä–æ–∑–ø–æ—á–∞—Ç–∏ —Ä—É—á–∫—É DTLS —ñ–∑ –∑–∞–¥–∞–Ω–æ—é ``udp_peer``, —è–∫–∞ –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ –≤–∂–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–∞ (–¥–∏–≤. :ref:`PacketPeerUDP.connect_to_host()<class_PacketPeerUDP_method_connect_to_host>`).

\ **–ü—Ä–∏–º—ñ—Ç–∫–∞:** –í–∏ –ø–æ–≤–∏–Ω–Ω—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏, —â–æ —Å—Ç–∞–Ω –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è PacketPeerUDP —î :ref:`PacketPeerDTLS. STATUS_HANDSHAKING<class_PacketPeerDTLS_constant_ STATUS_HANDSHAKING>`, –æ—Å–∫—ñ–ª—å–∫–∏ —Ü–µ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, —â–æ 50% –Ω–æ–≤–∏—Ö –∑'—î–¥–Ω–∞–Ω—å –±—É–¥–µ –Ω–µ–¥—ñ–π—Å–Ω–∏–º —á–µ—Ä–µ–∑ –æ–±–º—ñ–Ω cookie.

.. |virtual| replace:: :abbr:`virtual (–ó–∞–∑–≤–∏—á–∞–π, —Ü–µ–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–µ–º, —â–æ–± –≤—ñ–Ω –º–∞–≤ –≤–ø–ª–∏–≤.)`
.. |required| replace:: :abbr:`required (This method is required to be overridden when extending its base class.)`
.. |const| replace:: :abbr:`const (–¶–µ–π –º–µ—Ç–æ–¥ –Ω–µ –º–∞—î –ø–æ–±—ñ—á–Ω–∏—Ö –µ—Ñ–µ–∫—Ç—ñ–≤. –ù–µ –∑–º—ñ–Ω—é—î –Ω—ñ—è–∫—É –∑–º—ñ–Ω–Ω—É –µ–∫–∑–µ–º–ø–ª—è—Ä–∞ –æ–±'—î–∫—Ç–∞.)`
.. |vararg| replace:: :abbr:`vararg (–¶–µ–π –º–µ—Ç–æ–¥ –ø—Ä–∏–π–º–∞—î –±—É–¥—å-—è–∫–µ —á–∏—Å–ª–æ –∞—Ä–≥—É–º–µ–Ω—Ç—ñ–≤ –ø—ñ—Å–ª—è –æ–ø–∏—Å–∞–Ω–∏—Ö —Ç—É—Ç.)`
.. |constructor| replace:: :abbr:`constructor (–¶–µ–π –º–µ—Ç–æ–¥ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –ø–æ–±—É–¥–æ–≤–∏ —Ç–∏–ø—ñ–≤.)`
.. |static| replace:: :abbr:`static (–¶–µ–π –º–µ—Ç–æ–¥ –Ω–µ –ø–æ—Ç—Ä–µ–±—É—î –µ–∫–∑–µ–º–ø–ª—è—Ä–∞ –¥–ª—è –≤–∏–∫–ª–∏–∫—É, –π–æ–≥–æ –º–æ–∂–Ω–∞ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ –±–µ–∑–ø–æ—Å–µ—Ä–µ–¥–Ω—å–æ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –Ω–∞–∑–≤–∏ –∫–ª–∞—Å—É.)`
.. |operator| replace:: :abbr:`operator (–¶–µ–π –º–µ—Ç–æ–¥ –æ–ø–∏—Å—É—î –¥—ñ–π—Å–Ω–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –≤–∑–∞—î–º–æ–¥—ñ—ó –∑ —Ü–∏–º —Ç–∏–ø–æ–º —è–∫ –∑ –ª—ñ–≤–∏–º –æ–ø–µ—Ä–∞–Ω–¥–æ–º.)`
.. |bitfield| replace:: :abbr:`BitField (–¶–µ –∑–Ω–∞—á–µ–Ω–Ω—è —î —Ü—ñ–ª–∏–º —á–∏—Å–ª–æ–º, —Å–∫–ª–∞–¥–µ–Ω–∏–º —É –≤–∏–≥–ª—è–¥—ñ –±—ñ—Ç–æ–≤–æ—ó –º–∞—Å–∫–∏ –∑ –Ω–∞—Å—Ç—É–ø–Ω–∏—Ö –ø—Ä–∞–ø–æ—Ä—ñ–≤.)`
.. |void| replace:: :abbr:`void (–ó–Ω–∞—á–µ–Ω–Ω—è –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è.)`
