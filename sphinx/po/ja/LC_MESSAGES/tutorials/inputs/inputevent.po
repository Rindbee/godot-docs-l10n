#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "InputEvent (入力イベント)"

msgid "What is it?"
msgstr "それは何ですか？"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"通常、入力の管理は、OSやプラットフォームに関係なく複雑です。これを少し簡単に"
"するために、特別な組み込み型、\\ :ref:`InputEvent <class_InputEvent>` が提供"
"されています。このデータ型は、いくつかのタイプの入力イベントを含むように構成"
"できます。入力イベントはエンジンを通過し、目的に応じて複数の場所で受信できま"
"す。"

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr ""
"以下に簡単な例を示します。エスケープキーが押された場合にゲームを終了します:"

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"ただし、提供されている :ref:`InputMap <class_InputMap>` 機能を使用する方がよ"
"り簡単で柔軟です。InputMapは入力アクションを定義し、それらに異なるキーを割り"
"当てることができます。そうすると同じアクションに対して複数のキーを定義できま"
"す (キーボードのエスケープキーやゲームパッドのスタートボタンなど)。コードを更"
"新せずに、プロジェクト設定でこのマッピングを簡単に変更でき、その上にキー マッ"
"ピング機能を構築してゲーム実行時にキー マッピングを変更できるようにすることも"
"可能です！"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"InputMap は **プロジェクト -> プロジェクト設定 -> インプットマップ** で設定で"
"き、次のようなスクリプトで入力判定を行うことができます:"

msgid "How does it work?"
msgstr "入力が機能する仕組み"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"すべての入力イベントはユーザー/プレーヤーから発生します (ただしInputEventを生"
"成してエンジンにフィードバックすることは可能で、それはジェスチャー入力に役立"
"ちます)。各プラットフォームの DisplayServer はオペレーティングシステムからイ"
"ベントを読み取り、それをルート :ref:`ウインドウ<class_Window>` にフィードしま"
"す。"

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"ウィンドウの :ref:`ビューポート<class_Viewport>` は、受信した入力に対して非常"
"に多くの処理を次の順序で実行します。"

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"ビューポートにウインドウが埋め込まれている場合、ビューポートはウィンドウマ"
"ネージャーの機能でイベントを解釈しようとします (ウィンドウのサイズ変更や移動"
"など)。"

msgid ""
"Next if an embedded Window is focused, the event is sent to that Window and "
"processed in the Windows Viewport and afterwards treated as handled. If no "
"embedded Window is focused, the event is sent to the nodes of the current "
"viewport in the following order."
msgstr ""
"次に埋め込みウィンドウがフォーカスされている場合、イベントはそのウィンドウに"
"送信され、ウインドウビューポートで処理され、その後処理されたものとして処理さ"
"れます。フォーカスされている埋め込みウィンドウがない場合、イベントは次の順序"
"で現在のビューポートのノードに送信されます。"

msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing with :ref:`Node."
"set_process_input() <class_Node_method_set_process_input>`). If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"まず、標準の :ref:`Node._input() <class_Node_private_method__input>` 関数は、"
"それをオーバーライドする (および :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>` で入力処理を無効にしていない) ノードで"
"呼び出されます)。いずれかの関数がイベントを消費する場合、その関数は :ref:"
"`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` を呼び出すことができ、イベント"
"はそれ以上広がりません。これによりGUI の前でも、対象となるすべてのイベントを"
"確実にフィルターできます。ゲームプレイ入力の場合は、GUI がイベントを遮るた"
"め、:ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` の方が一般的に適しています。"

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will call :ref:"
"`Control.accept_event() <class_Control_method_accept_event>` and the event "
"will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether a :ref:"
"`Control <class_Control>` is notified of mouse events via :ref:`Control."
"_gui_input() <class_Control_private_method__gui_input>` callback, and "
"whether these events are propagated further."
msgstr ""
"次に、入力をGUIに送り、コントロールがそれを受信できるかどうかを確認します。そ"
"の場合 :ref:`Control <class_Control>` は仮想関数 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` を介して呼び出され、シグナル "
"\"gui_input\" が発行されます (この関数はスクリプトを継承して作成可能です)。コ"
"ントロールがイベントを「消費」したい場合は、 :ref:`Control.accept_event() "
"<class_Control_method_accept_event>` を呼び出し、イベントはそれ以上広がりませ"
"ん。 :ref:`Control.mouse_filter <class_Control_property_mouse_filter>` プロパ"
"ティを使用して、 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` コールバックを介して :ref:"
"`Control <class_Control>` にマウス イベントを通知するかどうかを制御します。こ"
"れらのイベントはさらに伝播されます。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only for :ref:"
"`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"これまで誰もイベントを消費しなかった場合、 :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` がオーバーライドされていれば呼び"
"出されます (:ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>` で無効になっていない場合)。こ"
"れは :ref:`InputEventKey <class_InputEventKey>` 、 :ref:`InputEventShortcut "
"<class_InputEventShortcut>` 、 :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>` でのみ発生します。いずれかの関数がイベントを"
"消費する場合、その関数は :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` を呼び出すことができ、イベント"
"はそれ以上広がりません。ショートカット入力コールバックは、ショートカットとし"
"て意図されたイベントを処理するのに最適です。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is an :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"これまでに誰もイベントを消費しなかった場合、 :ref:`Node."
"_unhandled_key_input() <class_Node_private_method__unhandled_key_input>` が"
"オーバーライドされていれば呼び出されます (:ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>` で無効になっていない場"
"合)。これはイベントが :ref:`InputEventKey <class_InputEventKey>` の場合にのみ"
"発生します。いずれかの関数がイベントを消費する場合、その関数は :ref:"
"`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` を呼び出すことができ、イベント"
"はそれ以上広がりません。未処理のキー入力コールバックは、キー イベントに最適で"
"す。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"これまで誰もイベントを消費しなかった場合、 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` がオーバーライドされていれば呼"
"び出されます (:ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>` で無効になっていない場合)。"
"いずれかの関数がイベントを消費する場合、その関数は :ref:`Viewport."
"set_input_as_handled() <class_Viewport_method_set_input_as_handled>` を呼び出"
"すことができ、イベントはそれ以上広がりません。未処理の入力コールバックは全画"
"面ゲームプレイ イベントに最適であるため、GUI がアクティブなときはイベントを受"
"信しません。"

msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled in :"
"ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"これまで誰もイベントを望んでおらず :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` がオンになっている場合、イ"
"ベントはオブジェクトの選択に使用されます。ルートビューポートの場合、これは :"
"ref:`プロジェクト設定 <class_ProjectSettings_property_physics/common/"
"enable_object_picking>` でも有効にすることができます。 3Dシーンで :ref:"
"`Camera3D <class_Camera3D>` がビューポートに割り当てられている場合、物理世界"
"へのレイ (クリックからの光線方向) がキャストされます。この光線がオブジェクト"
"に当たると、関連する物理オブジェクトの :ref:`CollisionObject3D."
"_input_event() <class_CollisionObject3D_private_method__input_event>` 関数が"
"呼び出されます。 2D シーンの場合、概念的には同じことが :ref:"
"`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>` で起こります。"

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"イベントを子ノードと子孫ノードに送信する場合、ビューポートは次の図に示すよう"
"に、シーン ツリーの一番下のノードから開始してルート ノードで終わる、深さ優先"
"の逆の順序で送信します。 ウインドウとサブビューポートはこのプロセスから除外さ"
"れます。"

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"ビューポートは他の :ref:`SubViewports <class_SubViewport>` にイベントを送信し"
"ないため、次のいずれかのメソッドを使用する必要があります。"

msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
":ref:`SubViewportContainer <class_SubViewportContainer>` を使用します。これ"
"は :ref:`Node._input() <class_Node_private_method__input>` または :ref:"
"`Control._gui_input()<class_Control_private_method__gui_input>` の後に、その"
"子の :ref:`SubViewports <class_SubViewport>` にイベントを自動的に送信します。"

msgid "Implement event propagation based on the individual requirements."
msgstr "個々の要件に基づいてイベントの伝播を実装します。"

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"Godotのノードベースの設計に従って、特殊な子ノードが特定のイベントを処理および"
"消費できるようになり、祖先や最終的にはシーンルートが必要に応じてより一般化さ"
"れた動作を提供できるようになります。"

msgid "Anatomy of an InputEvent"
msgstr "InputEventの構造"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` は単なる基本組み込み型であり、何も表さ"
"ず、イベントID(イベントごとに増加する)、デバイスインデックスなどの基本情報の"
"みを含みます。"

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr "InputEventにはいくつかの特殊なタイプがあり、次の表で説明します:"

msgid "Event"
msgstr "イベント"

msgid "Description"
msgstr "説明"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr "\\ :ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "空の入力イベント。"

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr "\\ :ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "キーコードとUnicode値、および修飾子が含まれます。"

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr "\\ :ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr "ボタン、モディファイヤなどのクリック情報が含まれます。"

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr "\\ :ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr "相対位置、絶対位置、速度などのモーション情報が含まれます。"

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr "\\ :ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "ジョイスティック/ジョイパッドのアナログ軸情報が含まれています。"

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr "\\ :ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "ジョイスティック/ジョイパッドのボタン情報が含まれます。"

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr "\\ :ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr ""
"マルチタッチのプレス/リリース情報が含まれています。(モバイルデバイスでのみ使"
"用可能)"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr "\\ :ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr ""
"マルチタッチドラッグ情報が含まれています。(モバイルデバイスでのみ使用可能)"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr "\\ :ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "位置、ファクター情報、および修飾子が含まれます。"

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr "\\ :ref:`InputEventPanGesture <class_InputEventPanGesture>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr "位置、差分情報、および修飾子が含まれます。"

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr "\\ :ref:`InputEventMIDI <class_InputEventMIDI>`"

msgid "Contains MIDI-related information."
msgstr "MIDI関連の情報が含まれます。"

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr "\\ :ref:`InputEventShortcut <class_InputEventShortcut>`"

msgid "Contains a shortcut."
msgstr "ショートカット情報が含まれます。"

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr "\\ :ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr ""
"汎用アクションが含まれています。これらのイベントは多くの場合、フィードバック"
"としてプログラマーによって生成されます。(詳細は以下)"

msgid "This allows for:"
msgstr "これにより、次のことが可能になります。"

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"入力が異なるさまざまなデバイス(PCのキーボード、コンソールのゲームパッドなど)"
"で動作する同じコード。"

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr ""
"アクションは プロジェクト設定メニューの **インプットマップ** タブから作成し、"
"入力イベントを割り当てることができます。"

msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."
msgstr ""
"すべてのイベントには、メソッド :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`\\ 、\\ :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` および :ref:`InputEvent "
"<class_InputEvent>` があります。"

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"あるいは、ゲームコードからのアクションをゲームに返すことが望ましい場合があり"
"ます(この良い例は、ジェスチャの検出です)。Inputシングルトンには、次のメソッド"
"があります: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`\\ 。通常は次のように使用します:"

msgid "InputMap"
msgstr "インプットマップ"
