#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Controllers, gamepads, and joysticks"
msgstr "コントローラー、ゲームパッド、ジョイスティック"

msgid ""
"Note that more specialized devices such as steering wheels, rudder pedals "
"and `HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may "
"not always work as expected. Overriding force feedback for those devices is "
"also not implemented yet. If you have access to one of those devices, don't "
"hesitate to `report bugs on GitHub <https://github.com/godotengine/godot/"
"blob/master/CONTRIBUTING.md#reporting-bugs>`__."
msgstr ""
"ステアリングホイール、ラダーペダル、`HOTAS <https://en.wikipedia.org/wiki/"
"HOTAS>`__ などのより特殊なデバイスはあまりテストされておらず、常に期待どおり"
"に動作するとは限らないことに注意してください。これらのデバイスのフォース"
"フィードバックをオーバーライドする機能もまだ実装されていません。これらのデバ"
"イスのいずれかにアクセスできる場合は、ためらわずに `GitHub <https://"
"github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-bugs>`__ "
"でバグ報告をお願いします。"

msgid "In this guide, you will learn:"
msgstr "このガイドでは、次の内容について学習します:"

msgid ""
"**How to write your input logic to support both keyboard and controller "
"inputs.**"
msgstr ""
"**キーボードとコントローラーの両方の入力をサポートする入力ロジックを作成する"
"方法。**"

msgid "**How controllers can behave differently from keyboard/mouse input.**"
msgstr "**コントローラーがキーボード/マウス入力とは異なる動作をさせる方法**"

msgid "**Troubleshooting issues with controllers in Godot.**"
msgstr "**Godotのコントローラーに関する問題のトラブルシューティング**"

msgid "Supporting universal input"
msgstr "ユニバーサル入力のサポート"

msgid ""
"Thanks to Godot's input action system, Godot makes it possible to support "
"both keyboard and controller input without having to write separate code "
"paths. Instead of hardcoding keys or controller buttons in your scripts, you "
"should create *input actions* in the Project Settings which will then refer "
"to specified key and controller inputs."
msgstr ""
"Godotの入力アクション システムのおかげで、Godotは別個のコード パスを記述する"
"ことなく、キーボードとコントローラーの両方の入力をサポートできるようになりま"
"す。スクリプトでキーやコントローラー ボタンをハードコーディングする代わりに、"
"プロジェクト設定で *入力アクション* を作成し、指定されたキーとコントローラー"
"の入力を参照します。"

msgid ""
"Input actions are explained in detail on the :ref:`doc_inputevent` page."
msgstr ""
"入力アクションについては、:ref:`doc_inputevent` ページで詳しく説明されていま"
"す。"

msgid ""
"Unlike keyboard input, supporting both mouse and controller input for an "
"action (such as looking around in a first-person game) will require "
"different code paths since these have to be handled separately."
msgstr ""
"キーボード入力とは異なり、アクション (一人称ゲームで周囲を見回すなど) に対し"
"てマウスとコントローラーの両方の入力をサポートするには、これらを個別に処理す"
"る必要があるため、異なるコード実装が必要になります。"

msgid "Which Input singleton method should I use?"
msgstr "どの入力メソッドを使用すればよいですか？"

msgid "There are 3 ways to get input in an analog-aware way:"
msgstr "アナログに対応した入力を取得するには3つの方法があります。"

msgid ""
"When you have two axes (such as joystick or WASD movement) and want both "
"axes to behave as a single input, use ``Input.get_vector()``:"
msgstr ""
"2つの軸 (ジョイスティックやWASDキーなど) を方向として取得したいときは "
"``Input.get_vector()`` を使用します。"

msgid ""
"When you have one axis that can go both ways (such as a throttle on a flight "
"stick), or when you want to handle separate axes individually, use "
"``Input.get_axis()``:"
msgstr ""
"両方向に移動できる1つの軸 (フライトスティックのスロットルなど) の場合、または"
"別の軸を個別に取得したい場合は ``Input.get_axis()`` を使用します。"

msgid ""
"For other types of analog input, such as handling a trigger or handling one "
"direction at a time, use ``Input.get_action_strength()``:"
msgstr ""
"トリガー入力や一方向の入力など、他のタイプのアナログ入力の場合は "
"``Input.get_action_strength()`` を使用します。"

msgid ""
"For non-analog digital/boolean input (only \"pressed\" or \"not pressed\" "
"values), such as controller buttons, mouse buttons or keyboard keys, use "
"``Input.is_action_pressed()``:"
msgstr ""
"コントローラボタン、マウスボタン、キーボードキーなどのデジタル入力 (\"押され"
"た\" または \"押されていない\") の場合は ``Input.is_action_pressed()`` を使用"
"します。"

msgid ""
"If you need to know whether an input was *just* pressed in the previous "
"frame, use ``Input.is_action_just_pressed()`` instead of "
"``Input.is_action_pressed()``. Unlike ``Input.is_action_pressed()`` which "
"returns ``true`` as long as the input is held, "
"``Input.is_action_just_pressed()`` will only return ``true`` for one frame "
"after the button has been pressed."
msgstr ""
"前のフレームで入力が「ちょうど」押されたかどうかを知る必要がある場合は "
"``Input.is_action_just_pressed()`` を使用してください。入力が保持されている限"
"り ``true`` を返す ``Input.is_action_pressed()`` とは異なり、 "
"``Input.is_action_just_pressed()`` はボタンが押された後の1フレームの間だけ "
"``true`` を返します。"

msgid "Vibration"
msgstr "振動 (バイブレーション)"

msgid ""
"Vibration (also called *haptic feedback*) can be used to enhance the feel of "
"a game. For instance, in a racing game, you can convey the surface the car "
"is currently driving on through vibration, or create a sudden vibration on a "
"crash."
msgstr ""
"振動 (*触覚フィードバック* とも呼ばれます) は、ゲームの感触を高めるために使用"
"できます。たとえばレーシング ゲームでは、車が現在走行している路面を振動で伝え"
"たり、衝突時に突然の振動を発生させたりできます。"

msgid ""
"Use the Input "
"singleton's :ref:`start_joy_vibration<class_Input_method_start_joy_vibration>` "
"method to start vibrating a gamepad. "
"Use :ref:`stop_joy_vibration<class_Input_method_stop_joy_vibration>` to stop "
"vibration early (useful if no duration was specified when starting)."
msgstr ""
"ゲームパッドの振動を開始するに"
"は、 :ref:`Input.start_joy_vibration<class_Input_method_start_joy_vibration>` "
"メソッドを使用します。振動を早期に停止するに"
"は、:ref:`Input.stop_joy_vibration<class_Input_method_stop_joy_vibration>` を"
"使用します (開始時に継続時間が指定されていない場合に便利です)。"

msgid ""
"On mobile devices, you can also "
"use :ref:`vibrate_handheld<class_Input_method_vibrate_handheld>` to vibrate "
"the device itself (independently from the gamepad). On Android, this "
"requires the ``VIBRATE`` permission to be enabled in the Android export "
"preset before exporting the project."
msgstr ""
"モバイル デバイスで"
"は :ref:`Input.vibrate_handheld<class_Input_method_vibrate_handheld>` を使用"
"して、(ゲームパッドとは別に) デバイス自体を振動させることもできます。Android"
"ではプロジェクトをエクスポートする前にAndroidエクスポート プリセットで "
"``VIBRATE`` 権限を有効にする必要があります。"

msgid ""
"Vibration can be uncomfortable for certain players. Make sure to provide an "
"in-game slider to disable vibration or reduce its intensity."
msgstr ""
"振動は特定のプレーヤーにとって不快な場合があります。振動を無効にできるように"
"するか、振動の強度を下げるためのゲーム内スライダーを必ず提供してください。"

msgid "Differences between keyboard/mouse and controller input"
msgstr "キーボード/マウスとコントローラー入力の違い"

msgid ""
"If you're used to handling keyboard and mouse input, you may be surprised by "
"how controllers handle specific situations."
msgstr ""
"キーボードとマウスの入力処理に慣れている方は、コントローラーが特定の状況下で"
"どのように動作するかに驚くかもしれません。"

msgid "Dead zone"
msgstr "デッドゾーン"

msgid ""
"Unlike keyboards and mice, controllers offer axes with *analog* inputs. The "
"upside of analog inputs is that they offer additional flexibility for "
"actions. Unlike digital inputs which can only provide strengths of ``0.0`` "
"and ``1.0``, an analog input can provide *any* strength between ``0.0`` and "
"``1.0``. The downside is that without a deadzone system, an analog axis' "
"strength will never be equal to ``0.0`` due to how the controller is "
"physically built. Instead, it will linger at a low value such as ``0.062``. "
"This phenomenon is known as *drifting* and can be more noticeable on old or "
"faulty controllers."
msgstr ""
"キーボードやマウスとは異なり、コントローラーは *アナログ* 入力を備えた軸"
"(Axis)を提供します。アナログ入力の利点は、アクションの柔軟性がさらに高まるこ"
"とです。 ``0.0`` と ``1.0`` の強度のみを提供できるデジタル入力とは異なり、ア"
"ナログ入力は ``0.0`` と ``1.0`` の間の*任意の*強度を提供できます。しかしデッ"
"ドゾーンがない場合、コントローラーの物理的な構造により、アナログ軸の結果が "
"``0.0`` になることが殆どないことが欠点です。代わりに ``0.062`` などの0に近い"
"値が残ります。この現象は *ドリフト* として知られており、古いコントローラーや"
"故障したコントローラーではより顕著になる可能性があります。"

msgid ""
"Let's take a racing game as a real-world example. Thanks to analog inputs, "
"we can steer the car slowly in one direction or another. However, without a "
"deadzone system, the car would slowly steer by itself even if the player "
"isn't touching the joystick. This is because the directional axis strength "
"won't be equal to ``0.0`` when we expect it to. Since we don't want our car "
"to steer by itself in this case, we define a \"dead zone\" value of ``0.2`` "
"which will ignore all input whose strength is lower than ``0.2``. An ideal "
"dead zone value is high enough to ignore the input caused by joystick "
"drifting, but is low enough to not ignore actual input from the player."
msgstr ""
"実際の例としてレーシングゲームを考えてみましょう。アナログ入力のおかげで、車"
"を一方向または別の方向にゆっくりと操縦できます。ただしデッドゾーンがないと、"
"プレイヤーがジョイスティックに触れていなくても、車は自動的にゆっくりと前進し"
"てしまいます。これは方向軸の強度が期待したときに ``0.0`` にならないためです。"
"このとき車が勝手に前進することを望まないため、 ``デッド ゾーン`` 値に "
"``0.2`` を定義します。これにより強度が ``0.2`` よりも低い入力がすべて無視され"
"ます。理想的なデッド ゾーンは、ジョイスティックのドリフトによって引き起こされ"
"る入力を無視できるほど十分に高い値ですが、プレーヤーからの実際の入力を無視で"
"きないほど十分に低い値です。"

msgid ""
"Godot features a built-in deadzone system to tackle this problem. The "
"default value is ``0.5``, but you can adjust it on a per-action basis in the "
"Project Settings' Input Map tab. For ``Input.get_vector()``, the deadzone "
"can be specified as an optional 5th parameter. If not specified, it will "
"calculate the average deadzone value from all of the actions in the vector."
msgstr ""
"Godot はこの問題に対処するためのデッドゾーンシステムを内蔵しています。デフォ"
"ルト値は ``0.5`` ですが、プロジェクト設定の ``インプットマップ`` タブでアク"
"ションごとに調整できます。 ``Input.get_vector()`` では、オプションの 5 番目の"
"パラメータとしてデッドゾーンを指定できます。指定しない場合、ベクトル内のすべ"
"てのアクションから平均デッドゾーン値が計算されます。"

msgid "\"Echo\" events"
msgstr "\"エコー\"イベント"

msgid ""
"Unlike keyboard input, holding down a controller button such as a D-pad "
"direction will **not** generate repeated input events at fixed intervals "
"(also known as \"echo\" events). This is because the operating system never "
"sends \"echo\" events for controller input in the first place."
msgstr ""
"キーボード入力とは異なり、方向パッドなどのコントローラーボタンを押したままに"
"しても、一定の間隔で繰り返される入力イベント (\"エコー\"イベントとも呼ばれま"
"す) は**生成されません**。これはオペレーティング システムがコントローラー入力"
"の\"エコー\"イベントをそもそも送信しないためです。"

msgid ""
"If you want controller buttons to send echo events, you will have to "
"generate :ref:`class_InputEvent` objects by code and parse them "
"using :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` at regular intervals. This can be "
"accomplished with the help of a :ref:`class_Timer` node."
msgstr ""
"コントローラーのボタンにエコーイベントを送信させたい場合は、コード"
"で :ref:`class_InputEvent` オブジェクトを生成し、定期的"
"に :ref:`Input.parse_input_event() <class_Input_method_parse_input_event>` を"
"使用してそれらを解析する必要があります。これは :ref:`class_Timer` ノードの助"
"けを借りて実現できます。"

msgid "Window focus"
msgstr "ウインドウフォーカス"

msgid ""
"Unlike keyboard input, controller inputs can be seen by **all** windows on "
"the operating system, including unfocused windows."
msgstr ""
"キーボード入力とは異なり、コントローラー入力はフォーカスされていないウィンド"
"ウを含む、オペレーティングシステム上の **すべて** のウィンドウで検出されま"
"す。"

msgid ""
"While this is useful for `third-party split screen functionality <https://"
"nucleus-coop.github.io/>`__, it can also have adverse effects. Players may "
"accidentally send controller inputs to the running project while interacting "
"with another window."
msgstr ""
"これは `サードパーティの分割画面機能 <https://nucleus-coop.github.io/>`__ に"
"は便利ですが、悪影響を与える可能性もあります。プレイヤーが別のウィンドウと対"
"話しているときに、誤ってコントローラー入力を実行中のプロジェクトに送信してし"
"まう可能性があります。"

msgid ""
"If you wish to ignore events when the project window isn't focused, you will "
"need to create an :ref:`autoload <doc_singletons_autoload>` called ``Focus`` "
"with the following script and use it to check all your inputs:"
msgstr ""
"プロジェクトウィンドウにフォーカスがないときにイベントを無視したい場合は、次"
"のスクリプトで ``Focus`` という :ref:`自動読み込みスクリプト "
"<doc_singletons_autoload>` を作成し、それを使用してすべての入力をチェックする"
"必要があります。"

msgid ""
"Then, instead of using ``Input.is_action_pressed(action)``, use "
"``Focus.input_is_action_pressed(action)`` where ``action`` is the name of "
"the input action. Also, instead of using "
"``event.is_action_pressed(action)``, use "
"``Focus.event_is_action_pressed(event, action)`` where ``event`` is an "
"InputEvent reference and ``action`` is the name of the input action."
msgstr ""
"次に ``Input.is_action_pressed(action)`` の代わりに "
"``Focus.input_is_action_pressed(action)`` を使用します。 ``action`` は入力ア"
"クションの名前です。また ``event.is_action_pressed(action)`` の代わりに "
"``Focus.event_is_action_pressed(event, action)`` を使用します。 ``event`` は"
"InputEventの参照、 ``action`` は入力アクションの名前です。"

msgid "Power saving prevention"
msgstr "パワーセーブ防止"

msgid ""
"Unlike keyboard and mouse input, controller inputs do **not** inhibit sleep "
"and power saving measures (such as turning off the screen after a certain "
"amount of time has passed)."
msgstr ""
"キーボードやマウスの入力とは異なり、コントローラーの入力はスリープや省電力"
"モード (一定時間が経過した後に画面をオフにする機能) を**防止しません**。"

msgid ""
"To combat this, Godot enables power saving prevention by default when a "
"project is running. If you notice the system is turning off its display when "
"playing with a gamepad, check the value of **Display > Window > Energy "
"Saving > Keep Screen On** in the Project Settings."
msgstr ""
"これに対処するために、Godot はプロジェクトの実行中にデフォルトで省電力モード"
"の防止を有効にします。ゲームパッドでプレイしているときにシステムのディスプレ"
"イがオフになっていることに気付いた場合は、プロジェクト設定の **表示 > ウィン"
"ドウ > 省エネルギー > 画面を常に点灯** のチェックを確認してください。"

msgid ""
"On Linux, power saving prevention requires the engine to be able to use D-"
"Bus. Check whether D-Bus is installed and reachable if running the project "
"within a Flatpak, as sandboxing restrictions may make this impossible by "
"default."
msgstr ""
"Linux では省電力モードを防止するには、エンジンが D-Bus を使用できる必要があり"
"ます。 Flatpak 内でプロジェクトを実行する場合は、サンドボックスの制限によりデ"
"フォルトでこれが不可能になる可能性があるため、D-Bus がインストールされてお"
"り、到達可能であるかどうかを確認してください。"

msgid "Troubleshooting"
msgstr "トラブルシューティング"

msgid ""
"You can view a list of `known issues with controller support <https://"
"github.com/godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__ on GitHub."
msgstr ""
"GitHubで `コントローラーサポートに関する既知の問題 <https://github.com/"
"godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__ のリストを確認できま"
"す。"

msgid "My controller isn't recognized by Godot."
msgstr "コントローラーが Godot に認識されません。"

msgid ""
"On Windows Godot only supports up to 4 controllers at a time. This is "
"because Godot uses the XInput API, which is limited to supporting 4 "
"controllers at once. Additional controllers above this limit are ignored by "
"Godot."
msgstr ""
"Windows では Godot は一度に最大4つのコントローラのみをサポートします。これは "
"Godot が使用する XInput API が一度にサポートするコントローラーが4つまでに制限"
"されているためです。この制限を超える追加のコントローラーは Godot によって無視"
"されます。"

msgid "My controller has incorrectly mapped buttons or axes."
msgstr "コントローラーにボタンまたは軸が正しくマッピングされません。"

msgid "Linux"
msgstr "Linux"
