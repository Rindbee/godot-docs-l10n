#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "カスタムポストプロセッシング"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described in :ref:"
"`doc_environment_and_post_processing`. However, advanced use cases may "
"require custom effects. This article explains how to write your own custom "
"effects."
msgstr ""
"Godotは、ブルーム、DOF、SSAOを含む多くのポストプロセッシング効果をすぐに利用"
"できます。これらについては :ref:`doc_environment_and_post_processing` で説明"
"されています。でも時々、独自のカスタム効果を作成したい場合もあります。この記"
"事では独自のカスタムエフェクトを作成する方法について説明します。"

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"カスタムのポストプロセッシングシェーダーを実装する最も簡単な方法は、Godotの組"
"み込み機能を使用して画面テクスチャから読み取ることです。これに慣れていない場"
"合は、最初に :ref:`Screen Reading Shaders Tutorial <doc_screen-"
"reading_shaders>` を読む必要があります。"

msgid "Single pass post-processing"
msgstr "シングルパス・ポストプロセッシング"

msgid ""
"Post-processing effects are shaders applied to a frame after Godot has "
"rendered it. To apply a shader to a frame, create a :ref:`CanvasLayer "
"<class_CanvasLayer>`, and give it a :ref:`ColorRect <class_ColorRect>`. "
"Assign a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the newly "
"created ``ColorRect``, and set the ``ColorRect``'s layout to \"Full Rect\"."
msgstr ""
"ポストプロセッシングエフェクトは、Godotがフレームをレンダリングした後に適用さ"
"れるシェーダーです。シェーダーをフレームに適用するには :ref:`CanvasLayer "
"<class_CanvasLayer>` を作成し、それに :ref:`ColorRect <class_ColorRect>` を与"
"えます。新しく作成した ``ColorRect`` に新しい :ref:`Shadermaterial "
"<class_Shadermaterial>` を割り当て、 ``ColorRect`` のレイアウトを \"Full "
"Rect\" に設定します。"

msgid "Your scene tree will look something like this:"
msgstr "シーンツリーは次のようになります。"

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"もう1つのより効率的な方法は、 :ref:`BackBufferCopy <class_BackBufferCopy>` を"
"使用して画面の領域をバッファにコピーし、 ``hint_screen_texture`` を使用して "
"``sampler2D`` を介してシェーダー内でそれにアクセスすることです。"

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"この記事の執筆時点では、Godotは複数のバッファへの同時レンダリングをサポートし"
"ていません。ポストプロセッシングシェーダーは、Godotによって公開されていない他"
"のレンダー パスやバッファ (深度や法線、ラフネスなど) にアクセスできません。 "
"Godotによってサンプラーとして公開されるレンダリングされたフレームとバッファー"
"にのみアクセスできます。"

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr ""
"このデモでは、羊の画像の :ref:`スプライト <class_Sprite2D>` を使用します。"

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"新しい :ref:`Shader <class_Shader>` を ``ColorRect`` の ``ShaderMaterial`` に"
"割り当てます。 ``hint_screen_texture`` が付いた ``sampler2D`` とビルトインの "
"``SCREEN_UV`` を使用してフレームのテクスチャにアクセスできます。"

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"次のコードをシェーダーにコピーします。以下のコードは、`arlez80 <https://"
"bitbucket.org/arlez80/hex-mosaic/src/master/>`_ による六角形化シェーダーです,"

msgid "The sheep will look something like this:"
msgstr "羊の画像は次のようになります。"

msgid "Multi-pass post-processing"
msgstr "マルチパス・ポストプロセッシング"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"ブラーなどのポストプロセッシングエフェクトの中には、リソースを大量に消費する"
"ものがあります。ただし複数のパスに分割するとより速く実行できます。マルチパス"
"のマテリアルでは、各パスが前のパスの結果を入力として受け取り、それを処理しま"
"す。"

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"マルチパスのポストプロセッシングシェーダーを生成するには、 ``CanvasLayer`` "
"ノードと ``ColorRect`` ノードをスタックします。上の例では ``CanvasLayer`` オ"
"ブジェクトを使用して、下のレイヤ上のフレームを使用してシェーダをレンダリング"
"します。ノード構造を除けば、手順はシングルパス・ポストプロセッシングシェー"
"ダーの場合と同じです。"

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"例として、次のコードを各 ``ColorRect`` ノードにアタッチすることで、全画面のガ"
"ウスブラーエフェクトを作成できます。シェーダーを適用する順序は、シーン ツリー"
"内の ``CanvasLayer`` の位置によって異なります。高いほど早く適用されることを意"
"味します。このブラーシェーダの場合、順序は重要ではありません。"

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr ""
"上記のコードを使用すると、次のような全画面ブラーエフェクトが得られます。"
