#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "初めての3Dシェーダー"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"あなたは独自のカスタムSpatialシェーダーの作成を開始することにしました。たぶん"
"シェーダーを使って行われたクールなトリックをオンラインで見たか、あるい"
"は、:ref:`StandardMaterial3D <class_StandardMaterial3D>` が自分のニーズを十分"
"に満たしていないことに気づいたかもしれません。いずれにしても、あなたは独自の"
"コードを作成することに決めたので、どこから始めればいいかを理解する必要があり"
"ます。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"このチュートリアルでは、Spatialシェーダーの作成方法を説明し、"
"\\ :ref:`CanvasItem <doc_your_first_canvasitem_shader>` チュートリアルよりも"
"多くのトピックを扱います。"

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatialシェーダーには、CanvasItemシェーダーよりも多くの機能が組み込まれていま"
"す。Spatialシェーダーで期待されるのは、Godotが一般的なユースケースの機能をす"
"でに提供しており、シェーダーでユーザーが行う必要があるのは、適切なパラメー"
"ターを設定することだけです。これは、特にPBR(物理ベースのレンダリング)ワークフ"
"ローに当てはまります。"

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In "
"the :ref:`second part <doc_your_second_spatial_shader>` we will take the "
"concepts from this tutorial and set up custom materials in a fragment shader "
"by writing an ocean water shader."
msgstr ""
"これは2部構成のチュートリアルです。この最初のパートでは、頂点関数のハイトマッ"
"プからの頂点変位を使用して、簡単な地形を作成する方法を説明します。\\ :ref:`第"
"2部 <doc_your_second_spatial_shader>` では、このチュートリアルの概念を取り入"
"れ、水面シェーダーを作成してフラグメントシェーダーでカスタムマテリアルを設定"
"する方法を説明します。"

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"このチュートリアルでは、タイプ(``vec2``\\ 、\\ ``float``\\ 、\\ "
"``sampler2D``)、関数などのシェーダーの基本的な知識を前提としています。これら"
"の概念に不安がある場合は、このチュートリアルを完了する前に、\\ `The Book of "
"Shaders <https://thebookofshaders.com>`_ のやさしい紹介を読むことをお勧めしま"
"す。"

msgid "Where to assign my material"
msgstr "マテリアルを割り当てる場所"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a "
"few :ref:`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic "
"geometry to a scene without importing Meshes."
msgstr ""
"3Dでは、オブジェクトは :ref:`メッシュ <class_Mesh>` を使用して描画されます。"
"メッシュは、「サーフェス」と呼ばれる単位でジオメトリ(オブジェクトの形状)とマ"
"テリアル(色とオブジェクトが光に反応する方法)を格納するリソースタイプです。"
"メッシュには、複数のサーフェス、または1つのサーフェスを含めることができます。"
"通常、別のプログラム(Blenderなど)からメッシュをインポートします。しかし、"
"Godotには、メッシュをインポートせずにシーンに基本的なジオメトリを追加でき"
"る :ref:`PrimitiveMeshes <class_primitivemesh>` もいくつかあります。"

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also "
"use :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"メッシュの描画に使用できるノードタイプは複数あります。主なもの"
"は :ref:`MeshInstance3D <class_MeshInstance3D>` ですが、"
"\\ :ref:`GPUParticles3D <class_GPUParticles3D>`\\ 、\\ :ref:`MultiMeshes "
"<class_MultiMesh>`(:ref:`MultiMeshInstance3D <class_MultiMeshInstance3D>` を"
"使用することもできます)、またはその他です。"

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常、マテリアルはメッシュ内の特定のサーフェスに関連付けられていますが、"
"MeshInstance3Dなどの一部のノードでは、特定のサーフェスまたはすべてのサーフェ"
"スのマテリアルをオーバーライドできます。"

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"サーフェスまたはメッシュ自体にマテリアルを設定すると、そのメッシュを共有する"
"すべてのMeshInstance3Dはそのマテリアルを共有します。ただし、複数のメッシュイ"
"ンスタンスで同じメッシュを再利用したいが、インスタンスごとに異なるマテリアル"
"を使用する場合は、MeshInstance3Dでマテリアルを設定する必要があります。"

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"このチュートリアルでは、MeshInstance3Dのマテリアルをオーバーライドする機能を"
"利用するのではなく、メッシュ自体にマテリアルを設定します。"

msgid "Setting up"
msgstr "セットアップ"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr ""
"新しい :ref:`MeshInstance3D <class_MeshInstance3D>` ノードをシーンに追加しま"
"す。"

msgid ""
"In the inspector tab, set the MeshInstance3D's **Mesh** property to a "
"new :ref:`PlaneMesh <class_planemesh>` resource, by clicking on ``<empty>`` "
"and choosing **New PlaneMesh**. Then expand the resource by clicking on the "
"image of a plane that appears."
msgstr ""
"インスペクタータブで MeshInstance3D の **Mesh** プロパティに新し"
"い :ref:`PlaneMesh <class_planemesh>` リソースを設定します。そのためには ``<"
"空>`` をクリックし、 **新規 PlaneMesh** を選択します。次に表示される平面の画"
"像をクリックしてリソースを展開します。"

msgid "This adds a plane to our scene."
msgstr "これで、シーンに平面のメッシュが追加されます。"

msgid ""
"Then, in the viewport, click in the upper left corner on the **Perspective** "
"button. In the menu that appears, select **Display Wireframe**."
msgstr ""
"次に、ビューポートの左上隅にある **透視投影** ボタンをクリックします。表示さ"
"れるメニューで **ワイヤーフレーム表示** を選択します。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "これにより、平面を構成する三角形を見ることができます。"

msgid ""
"Now set **Subdivide Width** and **Subdivide Depth** of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"次に :ref:`PlaneMesh <class_planemesh>` の **Subdivide Width** と "
"**Subdivide Depth** を ``32`` に設定します。"

msgid ""
"You can see that there are now many more triangles in "
"the :ref:`MeshInstance3D<class_MeshInstance3D>`. This will give us more "
"vertices to work with and thus allow us to add more detail."
msgstr ""
":ref:`MeshInstance3D<class_MeshInstance3D>` には、さらに多くの三角形があるこ"
"とがわかります。これにより多くの頂点を操作できるようになり、さらに詳細を追加"
"できるようになります。"

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Set the "
"**Material** to a new ShaderMaterial, then expand the material by clicking "
"on the sphere that appears."
msgstr ""
":ref:`PrimitiveMeshes <class_primitivemesh>` は PlaneMesh と同様に、1つのサー"
"フェスしか持たないため、マテリアルは配列ではなく 1 つだけ存在します。"
"**Material** に新しい ShaderMaterial に設定し、表示される球体をクリックしてマ"
"テリアルを展開します。"

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
":ref:`class_Material` リソースを継承するマテリアル"
"（:ref:`class_StandardMaterial3D` や :ref:`class_ParticleProcessMaterial` な"
"ど）は、:ref:`class_ShaderMaterial` に変換できます。その場合、既存のプロパ"
"ティは対応するテキストシェーダーに変換されます。変換するには、ファイルシステ"
"ムドックでマテリアルを右クリックし、「**ShaderMaterialに変換**」を選択しま"
"す。また、インスペクターでマテリアルへの参照を持つプロパティを右クリックして"
"変換することもできます。"

msgid "Shader magic"
msgstr "シェーダーマジック"

msgid "Adding this line, you should get an image like the one below."
msgstr "この行を追加すると、次のような画像が表示されます。"

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr ""
"これは良い感じですが、それでもまだとがりすぎて反復的です。もう少し面白くしま"
"しょう。"

msgid "Noise heightmap"
msgstr "ノイズハイトマップ"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"ノイズは、地形の外観を模倣するための非常に人気のあるツールです。これは、各丘"
"の高さが異なることを除いて、丘が繰り返されるコサイン関数に似ていると考えてく"
"ださい。"

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godotはシェーダーからアクセスできるノイズテクスチャを生成するため"
"の :ref:`NoiseTexture2D <class_noisetexture2D>` リソースを提供します。"

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"シェーダーのテクスチャにアクセスするには、シェーダーの上部近くの "
"``vertex()`` 関数の外側に次のコードを追加します。"

msgid "Once you set it up and should look like this."
msgstr "設定すると、次のようになります。"

msgid "Using this code you can see the texture creates random looking hills."
msgstr ""
"このコードを使用すると、テクスチャがランダムに見える丘を作成することがわかり"
"ます。"

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"現時点では尖りすぎているので、丘を少し柔らかくしたいと考えています。そのため"
"にUniformを使います。ノイズテクスチャを渡すために上記のUniformをすでに使用し"
"ました。次にそれらがどのように機能するかを学びましょう。"

msgid "Uniforms"
msgstr "Uniform(ユニフォーム)"

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "地形の高さを変えるユニフォームを作りましょう。"

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"SpatialベースのノードでUniformを変更することは、CanvasItemベースのノードとは"
"異なります。ここではPlaneMeshリソース内にマテリアルを設定します。他のメッシュ"
"リソースでは、最初に ``surface_get_material()`` を呼び出してマテリアルにアク"
"セスする必要があります。 MeshInstance3Dで ``get_surface_material()`` または "
"``material_override`` を使用してマテリアルにアクセスします。"

msgid "Now it looks much better."
msgstr "今度はずっと良くなりました。"

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"Uniformを使用すると、フレームごとに値を変更して、地形の高さをアニメーション化"
"することもできます。\\ :ref:`Tween <class_Tween>` と組み合わせると、アニメー"
"ションに特に役立ちます。"

msgid "Interacting with light"
msgstr "ライトとの相互作用"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"メッシュの色が平坦になることに注意してください。これは、照明が平坦だからで"
"す。ライトを追加しましょう！"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"ライトが地形に与える影響を見ることができますが、奇妙な見た目です。問題は、ラ"
"イトが平面であるかのように地形に影響していることです。これは、ライトシェー"
"ダーが :ref:`Mesh <class_mesh>` の法線を使用してライトを計算するためです。"

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法線はメッシュに保存されますが、シェーダーでメッシュの形状を変更しているた"
"め、法線は正しくありません。これを修正するには、シェーダーで法線を再計算する"
"か、ノイズに対応する法線テクスチャを使用します。 Godotは両方を簡単におこなえ"
"ます。"

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"頂点関数で新しい法線を手動で計算し、\\ ``NORMAL`` に設定することができます。"
"\\ ``NORMAL`` に設定すると、Godotは面倒な照明計算をすべて行います。この方法に"
"ついては、このチュートリアルの次の部分で説明しますが、今はテクスチャから法線"
"を読み取ります。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"その代わりに、再びNoiseTextureを利用して法線を計算します。これを行うために、2"
"番目のノイズテクスチャで値を渡します。"

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr ""
"そして、\\ ``fragment()`` 関数から ``tex_position`` にアクセスできるようにな"
"りました。"

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法線を設定すると、ライトはメッシュの高さに動的に反応します。"

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "ライトをドラッグすることもでき、照明の状態が自動的に更新されます。"

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"このチュートリアルの完全なコードは次のとおりです。 Godotが面倒な部分のほとん"
"どを処理するので、それほど長くないことがわかります。"

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"これがこの部分のすべてです。 Godotの頂点シェーダーの基本を理解できたと思いま"
"す。このチュートリアルの次の部分では、この頂点関数に付随するフラグメント関数"
"を作成し、この地形を動く波の海に変えるためのより高度なテクニックをカバーしま"
"す。"
