# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "コンピュートシェーダー"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"このチュートリアルでは、最小限のコンピュートシェーダーを作成するプロセスにつ"
"いて説明します。その前にコンピュートシェーダーと、それがGodotとどのように連携"
"するかについて少し説明します。"

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"このチュートリアルは読者がシェーダー全般について精通していることを前提として"
"います。シェーダーを初めて使用する場合は、このチュートリアルに進む前に、:ref:"
"`doc_introduction_to_shaders` と :ref:`初めてのシェーダー <toc-your-first-"
"shader>` をお読みください。"

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"コンピュートシェーダーは、汎用プログラミングを対象とした特別なタイプのシェー"
"ダープログラムです。言い換えればこれらは固定された目的 (頂点の変換や画像への"
"色の書き込みなど) を持たないため、頂点シェーダーやフラグメントシェーダーより"
"も柔軟です。フラグメントシェーダーや頂点シェーダーとは異なり、コンピュート"
"シェーダーは舞台裏でほとんど何も行われません。作成したコードはGPUが実行するも"
"のであり、それ以外ではほとんど実行されません。これは重い計算をGPUにオフロード"
"するための非常に便利なツールになります。"

msgid "Now let's get started by creating a short compute shader."
msgstr "それでは、短いコンピュートシェーダーを作成することから始めましょう。"

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"まず、任意の **外部** テキスト エディターで、プロジェクトフォルダに "
"``compute_example.glsl`` という新しいファイルを作成します。 Godotでコンピュー"
"トシェーダを記述する場合はGLSLで直接記述します。 Godotシェーダ言語はGLSLに基"
"づいています。 Godotの通常のシェーダに慣れている場合は、以下の構文に見覚えが"
"あるでしょう。"

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"コンピュートシェーダーは、RenderingDeviceベースのレンダラー (Forward+ または "
"Mobileレンダラー) からのみ使用できます。このチュートリアルを進めるには、"
"Forward+ または Mobile レンダラーを使用していることを確認してください。この設"
"定はエディターの右上隅にあります。"

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"モバイルデバイスのコンピュートシェーダーのサポートは、技術的にサポートされて"
"いる場合でも(ドライバーのバグなどのため)不十分であることに注意してください。"

msgid "Let's take a look at this compute shader code:"
msgstr "このコンピュートシェーダーのコードを見てみましょう。"

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"このコードはfloatの配列を取得して、各要素を2で乗算し、結果をバッファ配列に格"
"納します。では一行ずつ見てみましょう。"

msgid "These two lines communicate two things:"
msgstr "この2行は、次の2つのことを意味します。"

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"このコードはコンピュートシェーダーです。これはエディタがシェーダーファイルを"
"適切にインポートするために必要なGodot固有のヒントです。"

msgid "The code is using GLSL version 450."
msgstr "このコードはGLSLバージョン450を使用しています。"

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr ""
"コンピュートシェーダーをカスタムする場合も、この2 行を変更する必要はありませ"
"ん。"

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"次に各ワークグループで使用される実行インスタンスの数を伝えます。実行インスタ"
"ンスは同じワークグループ内で実行されるシェーダーのインスタンスです。CPUからコ"
"ンピュートシェーダーを起動するとき、実行するワークグループの数を指示します。"
"複数のワークグループは相互に並列実行されます。1つのワークグループの実行中は、"
"別のワークグループの情報にアクセスできません。しかし同じワークグループ内で"
"は、他の実行インスタンスへのアクセスが制限される場合があります。"

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr ""
"ワークグループと実行インスタンスを、このように入れ子になった巨大な ``for`` "
"ループとして考えてください。"

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"ワークグループと実行インスタンスは高度なトピックです。現時点ではワークグルー"
"プごとに2つの実行インスタンスを実行することに注意してください。"

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"ここではコンピュート シェーダーがアクセスできるメモリに関する情報を提供しま"
"す。 ``layout`` プロパティを使用すると、シェーダーにバッファの参照する場所を"
"指示できます。後でCPU側から ``set`` と ``binding`` の位置を一致させる必要があ"
"ります。"

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"``restrict`` キーワードは、このバッファがこのシェーダ内の1つの場所からのみア"
"クセスされることをシェーダに伝えます。言い換えれば、このバッファを別の "
"``set`` または ``binding`` インデックスにバインドしません。これはシェーダーコ"
"ンパイラがシェーダーコードを最適化できるようにするために重要です。可能な場合"
"は常に ``restrict`` を使用してください。"

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"また、これは *サイズなし* バッファです。つまり任意のサイズにすることができま"
"す。したがってバッファのサイズより大きなインデックスから読み取らないように注"
"意する必要があります。"

msgid ""
"Finally, we write the ``main`` function which is where all the logic "
"happens. We access a position in the storage buffer using the "
"``gl_GlobalInvocationID`` built in variables. ``gl_GlobalInvocationID`` "
"gives you the global unique ID for the current invocation."
msgstr ""
"最後にすべてのロジックが実行される ``main`` 関数を作成します。組み込み変数 "
"``gl_GlobalInvocationID`` を使用して、ストレージバッファ内の位置にアクセスし"
"ます。 ``gl_GlobalInvocationID`` は現在の実行インスタンスに対するグローバルで"
"ユニークなIDを提供します。"

msgid ""
"To continue, write the code above into your newly created ``compute_example."
"glsl`` file."
msgstr ""
"続けるには、新しく作成した ``compute_example.glsl`` ファイルに上記のコードを"
"書き込みます。"

msgid "Create a local RenderingDevice"
msgstr "ローカルの RenderingDevice を作成する"

msgid ""
"To interact with and execute a compute shader, we need a script. Create a "
"new script in the language of your choice and attach it to any Node in your "
"scene."
msgstr ""
"コンピュートシェーダーと対話して実行するにはスクリプトが必要です。好きな言語"
"で新しいスクリプトを作成しシーン内の任意のノードにアタッチします。"

msgid ""
"Now to execute our shader we need a local :ref:`class_RenderingDevice` which "
"can be created using the :ref:`class_RenderingServer`:"
msgstr ""
"ここでコンピュートシェーダーを実行するには、:ref:`class_RenderingServer` を使"
"用して作成できるローカルの :ref:`class_RenderingDevice` が必要です。"

msgid ""
"After that, we can load the newly created shader file ``compute_example."
"glsl`` and create a precompiled version of it using this:"
msgstr ""
"その後、新しく作成したシェーダーファイル ``compute_example.glsl`` をロード"
"し、これを使用してプリコンパイル済みのシェーダー(SPIR-V)を作成できます。"

msgid ""
"Local RenderingDevices cannot be debugged using tools such as `RenderDoc "
"<https://renderdoc.org/>`__."
msgstr ""
"ローカルのRenderingDeviceは、`RenderDoc <https://renderdoc.org/>`__ などの"
"ツールを使用してデバッグすることができません。"

msgid "Provide input data"
msgstr "入力データを指定する"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"念のためやることを確認すると、入力する配列をシェーダーに渡し各要素を2で乗算し"
"て結果を取得したいと考えています。"

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"コンピュートシェーダーに値を渡すためのバッファーを作成する必要があります。 こ"
"の例ではfloatの配列を扱っているためストレージバッファを使用します。ストレージ"
"バッファはバイト配列を受け取り、CPUとGPUの間でデータを転送できるようにしま"
"す。"

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr "それではfloatの配列を初期化し、ストレージ バッファを作成しましょう:"

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"バッファを配置したら、このバッファを使用するようにRenderingDeviceに指示する必"
"要があります。これを行うには(通常のシェーダーと同様に) Uniformを作成し、それ"
"をUniformSetに割り当てる必要があります。これを後でシェーダーに渡します。"

msgid "Defining a compute pipeline"
msgstr "コンピュートパイプラインの定義"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr ""
"次のステップは、GPUが実行できる一連の命令を作成することです。そのためにはパイ"
"プラインとコンピュートリストが必要です。"

msgid "The steps we need to do to compute our result are:"
msgstr "コンピュートシェーダーで結果を得るために必要な手順は次のとおりです:"

msgid "Create a new pipeline."
msgstr "新しいパイプラインの作成。"

msgid "Begin a list of instructions for our GPU to execute."
msgstr "GPUが実行する命令のリストを開始。"

msgid "Bind our compute list to our pipeline"
msgstr "コンピュートリストをパイプラインにバインド"

msgid "Bind our buffer uniform to our pipeline"
msgstr "バッファのUniformをパイプラインにバインド"

msgid "Specify how many workgroups to use"
msgstr "使用するワークグループの数を指定"

msgid "End the list of instructions"
msgstr "命令のリストを終了"

msgid ""
"Note that we are dispatching the compute shader with 5 work groups in the X "
"axis, and one in the others. Since we have 2 local invocations in the X axis "
"(specified in our shader), 10 compute shader invocations will be launched in "
"total. If you read or write to indices outside of the range of your buffer, "
"you may access memory outside of your shaders control or parts of other "
"variables which may cause issues on some hardware."
msgstr ""
"X軸に5つのワーク グループ、その他に1つのワーク グループを含むコンピュート"
"シェーダーをディスパッチしていることに注意してください。 X 軸 (シェーダーで指"
"定) に2つのローカル呼び出しがあるため、合計10個のコンピュートシェーダーの実行"
"コンテキストが起動されます。バッファの範囲外のインデックスの読み取りまたは書"
"き込みを行うと、シェーダー制御下の外側のメモリや他の変数の一部にアクセスする"
"可能性があり、一部のハードウェアで問題が発生する可能性があります。"

msgid "Execute a compute shader"
msgstr "コンピュートシェーダーを実行する"

msgid ""
"After all of this we are almost done, but we still need to execute our "
"pipeline. So far we have only recorded what we would like the GPU to do; we "
"have not actually run the shader program."
msgstr ""
"これでほぼ完了ですが、これからパイプラインを実行する必要があります。これまで"
"GPUに実行させたいことだけを記録しました。まだ実際にシェーダープログラムを実行"
"していません。"

msgid ""
"To execute our compute shader we need to submit the pipeline to the GPU and "
"wait for the execution to finish:"
msgstr ""
"コンピュートシェーダーを実行するには、パイプラインをGPUに送信して実行が完了す"
"るのを待つ必要があります。"

msgid ""
"Ideally, you would not call ``sync()`` to synchronize the RenderingDevice "
"right away as it will cause the CPU to wait for the GPU to finish working. "
"In our example, we synchronize right away because we want our data available "
"for reading right away. In general, you will want to wait *at least* 2 or 3 "
"frames before synchronizing so that the GPU is able to run in parallel with "
"the CPU."
msgstr ""
"すぐに ``sync()`` を呼び出してRenderingDeviceを同期させないほうが理想的にはい"
"いです。これはCPUがGPUの処理を完了するまで待機することになるからです。この例"
"ではデータをすぐに読み取るため直後に同期しています。一般的にはGPUがCPUと並行"
"して実行できるように、同期する前に *少なくとも* 2～3フレーム待機する必要があ"
"ります。"

msgid ""
"Long computations can cause Windows graphics drivers to \"crash\" due to :"
"abbr:`TDR (Timeout Detection and Recovery)` being triggered by Windows. This "
"is a mechanism that reinitializes the graphics driver after a certain amount "
"of time has passed without any activity from the graphics driver (usually 5 "
"to 10 seconds)."
msgstr ""
"コンピュート処理に時間がかかると、WindowsによってトリガーされるTDR (タイムア"
"ウト検出と回復) が原因でWindowsグラフィックスドライバーが \"クラッシュ\" する"
"可能性があります。これはグラフィックスドライバーからのアクティビティがない状"
"態で一定の時間が経過した後 (通常は5～10秒)、グラフィックスドライバーを再初期"
"化するメカニズムです。"

msgid ""
"Depending on the duration your compute shader takes to execute, you may need "
"to split it into multiple dispatches to reduce the time each dispatch takes "
"and reduce the chances of triggering a TDR. Given TDR is time-dependent, "
"slower GPUs may be more prone to TDRs when running a given compute shader "
"compared to a faster GPU."
msgstr ""
"コンピューシェーダーの実行にかかる時間に応じて、各ディスパッチにかかる時間を"
"短縮し、TDR がトリガーされる可能性を減らすため、コンピュートシェーダーを複数"
"のディスパッチに分割する必要がある場合があります。 TDRが時間に依存することを"
"考えると、低速なGPUは高速なGPUに比べて、特定のコンピュートシェーダーを実行す"
"るときにTDRが発生しやすい可能性があります。"

msgid "Retrieving results"
msgstr "結果の取得"

msgid ""
"You may have noticed that, in the example shader, we modified the contents "
"of the storage buffer. In other words, the shader read from our array and "
"stored the data in the same array again so our results are already there. "
"Let's retrieve the data and print the results to our console."
msgstr ""
"この例のシェーダーでは、ストレージバッファの内容を変更していることに気づいた"
"かもしれません。言い換えればシェーダーは配列からデータを読み取り、同じ配列に"
"データを保存しているので結果はそこにあります。データを取得して結果をコンソー"
"ルに出力しましょう。"

msgid ""
"With that, you have everything you need to get started working with compute "
"shaders."
msgstr ""
"これでコンピュートシェーダーの使用を開始するために必要なものがすべて揃いまし"
"た。"

msgid ""
"The demo projects repository contains a `Compute Shader Heightmap demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ This project performs heightmap image "
"generation on the CPU and GPU separately, which lets you compare how a "
"similar algorithm can be implemented in two different ways (with the GPU "
"implementation being faster in most cases)."
msgstr ""
"デモプロジェクトのリポジトリには `Compute Shader Heightmap demo <https://"
"github.com/godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ が含まれています。このプロジェクトはCPUとGPUで個"
"別にハイトマップイメージの生成を実行します。これにより同様のアルゴリズムを2つ"
"の異なる方法で実装する方法を比較できます (ほとんどの場合、GPU実装の方が高速で"
"す)。"

msgid "Translation status"
msgstr "翻訳ステータス"
