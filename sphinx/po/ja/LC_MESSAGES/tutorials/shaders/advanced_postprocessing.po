#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "高度なポストプロセッシング"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"このチュートリアルでは、Godotでのポストプロセッシングを行うための高度な方法に"
"ついて説明します。特に、深度バッファーを使用するポストプロセッシングシェー"
"ダーの作成方法について説明します。ポストプロセッシング全般、特に :ref:`カスタ"
"ムポストプロセッシングチュートリアル <doc_custom_postprocessing>` で概説され"
"ているメソッドに既に精通している必要があります。"

msgid "Full screen quad"
msgstr "フルスクリーン矩形"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"カスタムポストプロセッシングエフェクトを作成する1つの方法は、ビューポートを使"
"用することです。ただしビューポートの使用には主な欠点が2つあります。"

msgid "The depth buffer cannot be accessed"
msgstr "深度バッファにアクセスできません"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "ポストプロセッシングシェーダーの効果はエディタに表示されません"

msgid ""
"To get around the limitation on using the depth buffer, use "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"深度バッファの使用に関する制限を回避するには、\\ :ref:`MeshInstance3D "
"<class_MeshInstance3D>` を :ref:`QuadMesh <class_QuadMesh>` プリミティブとと"
"もに使用します。これにより、シェーダーを使用してシーンの深度テクスチャにアク"
"セスできます。次に頂点シェーダーを使用して、矩形が常に画面を覆うようにし、エ"
"ディタを含むポストプロセッシングエフェクトが常に適用されるようにします。"

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"まず、新しいMeshInstance3Dを作成し、そのメッシュをQuadMeshに設定します。これ"
"により、\\ ``(0, 0, 0)`` の位置を中心とする幅と高さが ``1`` の矩形が作成され"
"ます。そのQuadMeshの幅と高さを ``2`` に設定し、 **Flip Faces** をONにします。"
"現在、矩形はワールド空間の原点の位置を占めています。ただし常に画面全体をカ"
"バーするようにカメラとともに移動させる必要があります。これを行うには、差分座"
"標空間を介して頂点位置を変換する座標変換をバイパスし、既にクリップ空間にある"
"かのように頂点を扱います。"

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position in clip space directly."
msgstr ""
"頂点シェーダーは座標がクリップ空間で出力されることを想定しています。これは画"
"面の左と下の ``-1`` から画面の右上の ``1`` までの座標です。これがQuadMeshの幅"
"と高さを ``2`` にする必要がある理由です。Godot はモデルからビュー空間、クリッ"
"プ空間への変換をシーンの背後で処理するため、Godotの変換の効果を無効にする必要"
"があります。これを行うにはビルトインの ``POSITION`` を目的の位置に設定しま"
"す。 ``POSITION`` はビルトインの変換をバイパスし、クリップ空間内の頂点位置を"
"直接設定します。"

msgid ""
"In versions of Godot earlier than 4.3, this code recommended using "
"``POSITION = vec4(VERTEX, 1.0);`` which implicitly assumed the clip-space "
"near plane was at ``0.0``. That code is now incorrect and will not work in "
"versions 4.3+ as we use a \"reversed-z\" depth buffer now where the near "
"plane is at ``1.0``."
msgstr ""
"Godot 4.3 より前のバージョンでは、このコードは ``POSITION = vec4(VERTEX, "
"1.0);`` を使用することを推奨していましたが、これはクリップ空間のニアプレーン"
"が ``0.0`` であると暗黙的に想定していました。このコードは現在間違っており、"
"バージョン 4.3 以降では動作しません。4.3 以降ではニアプレーンが ``1.0`` であ"
"る ``reversed-z`` 深度バッファを使用しているためです。"

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"この頂点シェーダーを使用しても、矩形は消えたままです。これは、CPUで実行される"
"フラスタム(視錐台)カリングによるものです。フラスタムカリングは、カメラマト"
"リックスとメッシュのAABBを使用して、メッシュをGPUに渡す前にメッシュが表示され"
"るかどうかを決定します。 CPUは頂点の処理内容を認識していないため、指定された"
"座標はクリップスペースの位置ではなくワールドの位置を参照していると想定しま"
"す。矩形がカリングされないようにするには、いくつかのオプションがあります:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr "QuadMeshをカメラの子として追加し、カメラが常にそれを指すようにする"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"QuadMeshでGeometryプロパティ ``extra_cull_margin`` をできるだけ大きく設定しま"
"す"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"2番目のオプションは、エディタでクワッドが表示されることを保証します。一方、最"
"初のオプションは、カメラがカリングマージンの外側に移動しても表示されることを"
"保証します。両方のオプションを使用することもできます。"

msgid "Depth texture"
msgstr "深度テクスチャ"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"深度テクスチャから読み取るには、まず ``hint_depth_texture`` を使用して深度"
"バッファにセットされたテクスチャUniformを作成する必要があります。"

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""
"一度定義すれば、深度テクスチャは ``texture()`` 関数で読み取ることができます。"

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"画面テクスチャへのアクセスと同様に、深度テクスチャへのアクセスは、現在の"
"ビューポートから読み取るときにのみ可能です。深度テクスチャは、レンダリングし"
"た別のビューポートからアクセスできません。"

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"まず、画面空間座標を取得し、正規化デバイス座標 (NDC) に変換します。 NDCは"
"Vulkan バックエンドでは、 ``x``, ``y`` 方向は ``-1.0`` ～ ``1.0`` まで、 "
"``z`` 方向は ``0.0`` ～ ``1.0`` まで実行されます。 x軸とy軸に ``SCREEN_UV`` "
"を使用し、z 軸に深度値を使用してNDCを再構築します。"

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"NDCに ``INV_PROJECTION_MATRIX`` を掛けてビュー空間へ変換します。ビュー空間は"
"カメラからの相対的な位置になるため、 ``z`` 値はその点までの距離になります。"

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"カメラはマイナス ``z`` 方向を向いているため、位置には負の ``z`` 値が設定され"
"ます。有効な深度値を得るには ``view.z`` を符号反転 (-view.z) する必要がありま"
"す。"

msgid "An optimization"
msgstr "最適化"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"However, the benefit is quite small and only beneficial when running "
"especially complex fragment shaders."
msgstr ""
"フルスクリーン矩形を使用するのではなく、単一の大きな三角形を使用することでメ"
"リットが得られます。この理由は `ここ <https://michaldrobot.com/2014/04/01/"
"gcn-execution-patterns-in-full-screen-passes>`_ で説明されています。ただし、"
"この利点は非常に小さく、特に複雑なフラグメントシェーダーを実行する場合にのみ"
"有益です。"

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"MeshInstance3DのMeshを :ref:`ArrayMesh <class_ArrayMesh>` に設定します。 "
"ArrayMeshは頂点、法線、色などの配列からメッシュを簡単に構築できるツールです。"

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr ""
"次にスクリプトをMeshInstance3Dにアタッチします。スクリプトは次のコードを使用"
"します:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"三角形は正規化されたデバイス座標で指定されます。 NDCはX方向とY方向の両方で "
"``-1.0`` ～ ``1.0`` まで実行されることを思い出してください。これにより画面の"
"幅が ``2`` 単位、高さが ``2`` 単位になります。画面全体を1つの三角形で覆うに"
"は、幅が ``4`` 単位、高さが ``4`` 単位の、幅と高さを2倍にした三角形を使用しま"
"す。"

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"上から同じ頂点シェーダーを割り当てると、すべてがまったく同じに見えるはずで"
"す。"

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"QuadMeshを使用するよりもArrayMeshを使用する場合の1つの欠点は、シーンが実行さ"
"れるまで三角形が構築されないため、エディタでArrayMeshが表示されないことです。"
"これを回避するには、モデリングプログラムで単一の三角形メッシュを作成し、代わ"
"りにそれをMeshInstance3Dで使用します。"
