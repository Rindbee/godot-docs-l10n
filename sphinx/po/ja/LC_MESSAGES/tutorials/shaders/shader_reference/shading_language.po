# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shading language"
msgstr "シェーディング言語"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godotは、GLSL ES 3.0と同様のシェーディング言語を使用します。ほとんどのデータ"
"型と関数がサポートされており、残りのいくつかのデータ型は今後追加される可能性"
"があります。"

msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""
"既にGLSLに精通している場合は、:ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` が、通常の GLSL からGodotの"
"シェーディング言語への移行に役立つ資料です。"

msgid "Data types"
msgstr "データ型"

msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "ほとんどのGLSL ES 3.0データ型がサポートされています:"

msgid "Type"
msgstr "タイプ(型)"

msgid "Description"
msgstr "説明"

msgid "**void**"
msgstr "\\ **void**"

msgid "Void datatype, useful only for functions that return nothing."
msgstr "Voidデータ型。何も返さない関数にのみ有用です。"

msgid "**bool**"
msgstr "\\ **bool**"

msgid "Boolean datatype, can only contain ``true`` or ``false``."
msgstr ""
"Boolデータ型には、\\ ``true`` または ``false`` のみを含めることができます。"

msgid "**bvec2**"
msgstr "\\ **bvec2**"

msgid "Two-component vector of booleans."
msgstr "Bool値の2要素ベクトル。"

msgid "**bvec3**"
msgstr "\\ **bvec3**"

msgid "Three-component vector of booleans."
msgstr "Bool値の3要素ベクトル。"

msgid "**bvec4**"
msgstr "\\ **bvec4**"

msgid "Four-component vector of booleans."
msgstr "Bool値の4要素ベクトル。"

msgid "**int**"
msgstr "\\ **int**"

msgid "Signed scalar integer."
msgstr "符号付きスカラー整数。"

msgid "**ivec2**"
msgstr "\\ **ivec2**"

msgid "Two-component vector of signed integers."
msgstr "符号付き整数の2要素ベクトル。"

msgid "**ivec3**"
msgstr "\\ **ivec3**"

msgid "Three-component vector of signed integers."
msgstr "符号付き整数の3要素ベクトル。"

msgid "**ivec4**"
msgstr "\\ **ivec4**"

msgid "Four-component vector of signed integers."
msgstr "符号付き整数の4要素ベクトル。"

msgid "**uint**"
msgstr "\\ **uint**"

msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr "符号なしスカラー整数。負の数を含めることはできません。"

msgid "**uvec2**"
msgstr "\\ **uvec2**"

msgid "Two-component vector of unsigned integers."
msgstr "符号なし整数の2要素ベクトル。"

msgid "**uvec3**"
msgstr "\\ **uvec3**"

msgid "Three-component vector of unsigned integers."
msgstr "符号なし整数の3要素ベクトル。"

msgid "**uvec4**"
msgstr "\\ **uvec4**"

msgid "Four-component vector of unsigned integers."
msgstr "符号なし整数の4要素ベクトル。"

msgid "**float**"
msgstr "\\ **float**"

msgid "Floating-point scalar."
msgstr "浮動小数点のスカラー。"

msgid "**vec2**"
msgstr "\\ **vec2**"

msgid "Two-component vector of floating-point values."
msgstr "浮動小数点の2要素ベクトル。"

msgid "**vec3**"
msgstr "\\ **vec3**"

msgid "Three-component vector of floating-point values."
msgstr "浮動小数点の3要素ベクトル。"

msgid "**vec4**"
msgstr "\\ **vec4**"

msgid "Four-component vector of floating-point values."
msgstr "浮動小数点の4要素ベクトル。"

msgid "**mat2**"
msgstr "\\ **mat2**"

msgid "2x2 matrix, in column major order."
msgstr "列優先順の2x2行列。"

msgid "**mat3**"
msgstr "\\ **mat3**"

msgid "3x3 matrix, in column major order."
msgstr "列優先順の3x3行列。"

msgid "**mat4**"
msgstr "\\ **mat4**"

msgid "4x4 matrix, in column major order."
msgstr "列優先順の4x4行列。"

msgid "**sampler2D**"
msgstr "\\ **sampler2D**"

msgid "Sampler type for binding 2D textures, which are read as float."
msgstr ""
"floatとして読み取られる2Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**isampler2D**"
msgstr "\\ **isampler2D**"

msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr ""
"intとして読み取られる2Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**usampler2D**"
msgstr "\\ **usampler2D**"

msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr ""
"uintとして読み取られる2Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**sampler2DArray**"
msgstr "\\ **sampler2DArray**"

msgid "Sampler type for binding 2D texture arrays, which are read as float."
msgstr ""
"floatとして読み取られる2Dテクスチャ配列をバインドするためのサンプラータイプ。"

msgid "**isampler2DArray**"
msgstr "\\ **isampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as signed integer."
msgstr ""
"intとして読み取られる2Dテクスチャ配列をバインドするためのサンプラータイプ。"

msgid "**usampler2DArray**"
msgstr "\\ **usampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as unsigned "
"integer."
msgstr ""
"uintとして読み取られる2Dテクスチャ配列をバインドするためのサンプラータイプ。"

msgid "**sampler3D**"
msgstr "\\ **sampler3D**"

msgid "Sampler type for binding 3D textures, which are read as float."
msgstr ""
"floatとして読み取られる3Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**isampler3D**"
msgstr "\\ **isampler3D**"

msgid "Sampler type for binding 3D textures, which are read as signed integer."
msgstr ""
"intとして読み取られる3Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**usampler3D**"
msgstr "\\ **usampler3D**"

msgid ""
"Sampler type for binding 3D textures, which are read as unsigned integer."
msgstr ""
"uintとして読み取られる3Dテクスチャをバインドするためのサンプラータイプ。"

msgid "**samplerCube**"
msgstr "\\ **samplerCube**"

msgid "Sampler type for binding Cubemaps, which are read as float."
msgstr ""
"キューブマップテクスチャをバインドするためのサンプラータイプ。floatとして読み"
"込まれます。"

msgid "**samplerCubeArray**"
msgstr "\\ **samplerCubeArray**"

msgid "Sampler type for binding Cubemap arrays, which are read as float."
msgstr ""
"キューブマップテクスチャ配列をバインドするためのサンプラータイプ。floatとして"
"読み込まれます。"

msgid "Comments"
msgstr "コメント"

#, fuzzy
msgid ""
"The shading language supports the same comment syntax as used in C# and C++:"
msgstr ""
"Godotシェーディング言語は、最も一般的なタイプの構文制御をサポートしています:"

msgid ""
"Additionally, you can use documentation comments that are displayed in the "
"inspector when hovering a shader parameter. Documentation comments are "
"currently only supported when placed immediately above a ``uniform`` "
"declaration. These documentation comments only support the **multiline** "
"comment syntax and must use **two** leading asterisks (``/**``) instead of "
"just one (``/*``):"
msgstr ""

msgid ""
"The asterisks on the follow-up lines are not required, but are recommended "
"as per the :ref:`doc_shaders_style_guide`. These asterisks are automatically "
"stripped by the inspector, so they won't appear in the tooltip."
msgstr ""

msgid "Casting"
msgstr "キャスト"

msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""
"GLSL ES 3.0と同様に、同じサイズで異なるタイプのスカラーとベクトル間の暗黙的な"
"キャストは許可されていません。異なるサイズの型のキャストも許可されていませ"
"ん。変換は、コンストラクターを介して明示的に実行する必要があります。"

msgid "Example:"
msgstr "例:"

msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr ""
"デフォルトの整数定数は符号付きなので、符号なしに変換するには常にキャストが必"
"要です:"

msgid "Members"
msgstr "メンバー"

msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""
"ベクタータイプの個々のスカラーメンバーには、\"x\"、\"y\"、\"z\"、\"w\" メン"
"バーを介してアクセスします。あるいは、\"r\"、\"g\"、\"b\" および \"a\" を使用"
"しても機能し、同等です。ニーズに最適なものを使用してください。"

msgid ""
"For matrices, use the ``m[column][row]`` indexing syntax to access each "
"scalar, or ``m[idx]`` to access a vector by row index. For example, for "
"accessing the y position of an object in a mat4 you use ``m[3][1]``."
msgstr ""
"行列の場合、\\ ``m[column][row]`` インデックス構文を使用して各スカラーにアク"
"セスするか、\\ ``m[idx]`` を使用して行インデックスでベクトルにアクセスしま"
"す。たとえば、mat4のオブジェクトのy位置にアクセスするには、\\ ``m[3][1]`` を"
"使用します。"

msgid "Constructing"
msgstr "構築"

msgid "Construction of vector types must always pass:"
msgstr "ベクトル型の構築は常に代入する必要があります:"

msgid ""
"Construction of matrix types requires vectors of the same dimension as the "
"matrix. You can also build a diagonal matrix using ``matx(float)`` syntax. "
"Accordingly, ``mat4(1.0)`` is an identity matrix."
msgstr ""
"行列タイプの構築には、行列と同じ次元のベクトルが必要です。\\ ``matx(float)`` "
"構文を使用して対角行列を構築することもできます。したがって、\\ ``mat4(1.0)`` "
"は単位行列です。"

msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules:"
msgstr ""
"行列は別の次元の行列からも構築することもできます。ルールは 2 つあります:"

msgid ""
"1. If a larger matrix is constructed from a smaller matrix, the additional "
"rows and columns are set to the values they would have in an identity "
"matrix. 2. If a smaller matrix is constructed from a larger matrix, the top, "
"left submatrix of the larger matrix is used."
msgstr ""
"1. 小さな行列から、より大きな行列が構築される場合、追加の行と列は単位行列に含"
"まれる値に設定されます。 2. 大きな行列から、より小さな行列が構築される場合、"
"大きな行列の左上の部分行列が使用されます。"

msgid "Swizzling"
msgstr "\\ Swizzling"

msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""
"結果が別のベクトル型(またはスカラー)である限り、任意の順序で要素の任意の組み"
"合わせを取得することが可能です。これは説明されるよりも簡単に示されます:"

msgid "Precision"
msgstr "精度"

msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr ""
"データ型に精度修飾子を追加することができます。それらをuniform、変数、引数、お"
"よびvaryingに使用します。"

msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""
"一部の操作に低い精度を使用すると、関係する計算が高速化されます(精度は低下しま"
"す)。これは、頂点プロセッサ関数ではほとんど必要ありません(ほとんどの場合、完"
"全な精度が必要です)が、フラグメントプロセッサではしばしば有用です。"

msgid ""
"Some architectures (mainly mobile) can benefit significantly from this, but "
"there are downsides such as the additional overhead of conversion between "
"precisions. Refer to the documentation of the target architecture for "
"further information. In many cases, mobile drivers cause inconsistent or "
"unexpected behavior and it is best to avoid specifying precision unless "
"necessary."
msgstr ""
"一部のアーキテクチャ (主にモバイル) では、これによって大きなメリットが得られ"
"ますが、精度間の変換による追加のオーバーヘッドなどの欠点もあります。詳細につ"
"いては、ターゲットアーキテクチャのドキュメントを参照してください。多くの場"
"合、モバイル環境のドライバーは一貫性のない動作や予期しない動作を引き起こすた"
"め、必要な場合を除いて精度を指定しないことをお勧めします。"

msgid "Arrays"
msgstr "配列"

msgid "Arrays are containers for multiple variables of a similar type."
msgstr "配列は複数の同じ型の変数のコンテナです。"

msgid "Local arrays"
msgstr "ローカル配列"

msgid ""
"Local arrays are declared in functions. They can use all of the allowed "
"datatypes, except samplers. The array declaration follows a C-style syntax: "
"``[const] + [precision] + typename + identifier + [array size]``."
msgstr ""
"ローカル配列は関数内で宣言されます。サンプラーを除くすべての許可されたデータ"
"型を使用できます。配列宣言は、Cスタイルの構文 ``[const] + [precision] + "
"typename + identifier + [array size]`` に従います。"

msgid "They can be initialized at the beginning like:"
msgstr "これらは、最初のように初期化することができます:"

msgid ""
"You can declare multiple arrays (even with different sizes) in one "
"expression:"
msgstr "1つの式で複数の配列(サイズが異なる場合でも)を宣言できます:"

msgid "To access an array element, use the indexing syntax:"
msgstr "配列要素にアクセスするには、インデックス構文を使用します:"

msgid ""
"Arrays also have a built-in function ``.length()`` (not to be confused with "
"the built-in ``length()`` function). It doesn't accept any parameters and "
"will return the array's size."
msgstr ""
"配列には組み込み関数 ``.length()`` もあります(組み込みの ``length()`` 関数と"
"混同しないでください)。パラメーターを受け入れず、配列のサイズを返します。"

msgid ""
"If you use an index either below 0 or greater than array size - the shader "
"will crash and break rendering. To prevent this, use ``length()``, ``if``, "
"or ``clamp()`` functions to ensure the index is between 0 and the array's "
"length. Always carefully test and check your code. If you pass a constant "
"expression or a number, the editor will check its bounds to prevent this "
"crash."
msgstr ""
"0未満または配列サイズより大きいインデックスを使用すると、シェーダーがクラッ"
"シュしてレンダリングが中断します。これを防ぐには、\\ ``length()``\\ 、\\ "
"``if`` または ``clamp()`` 関数を使用して、インデックスが0と配列の長さの間にあ"
"ることを確認してください。コードは常に慎重にテストおよびチェックしてくださ"
"い。定数式または単純な数値を渡すと、エディタはその境界をチェックしてこのク"
"ラッシュを防ぎます。"

msgid "Global arrays"
msgstr "グローバル配列"

msgid "You can declare arrays at global space like:"
msgstr "次のようにグローバルスコープで配列を宣言できます:"

msgid ""
"Global arrays have to be declared as global constants, otherwise they can be "
"declared the same as local arrays."
msgstr ""
"グローバル配列はグローバル定数として宣言する必要があります。それ以外の場合は"
"ローカル配列と同じように宣言できます。"

msgid "Constants"
msgstr "定数"

msgid ""
"Use the ``const`` keyword before the variable declaration to make that "
"variable immutable, which means that it cannot be modified. All basic types, "
"except samplers can be declared as constants. Accessing and using a constant "
"value is slightly faster than using a uniform. Constants must be initialized "
"at their declaration."
msgstr ""
"変数宣言の前に ``const`` キーワードを使用して、その変数を変更できないようにし"
"ます。サンプラーを除くすべての基本型は、定数として宣言できます。定数値へのア"
"クセスと使用は、ユニフォームの使用よりもわずかに高速です。定数は、宣言時に初"
"期化する必要があります。"

msgid ""
"Constants cannot be modified and additionally cannot have hints, but "
"multiple of them (if they have the same type) can be declared in a single "
"expression e.g"
msgstr ""
"定数は変更できず、さらにヒントを持つことはできませんが、複数の(同じ型の場合)"
"を単一の式で宣言できます。例:"

msgid "Similar to variables, arrays can also be declared with ``const``."
msgstr "変数と同様に、配列は ``const`` で宣言することもできます。"

msgid ""
"Constants can be declared both globally (outside of any function) or locally "
"(inside a function). Global constants are useful when you want to have "
"access to a value throughout your shader that does not need to be modified. "
"Like uniforms, global constants are shared between all shader stages, but "
"they are not accessible outside of the shader."
msgstr ""
"定数は、グローバル(関数の外部)またはローカル(関数の内部)の両方で宣言できま"
"す。グローバル定数は、変更する必要のないシェーダー全体の値にアクセスする場合"
"に役立ちます。ユニフォームと同様に、グローバル定数はすべてのシェーダーステー"
"ジ間で共有されますが、シェーダーの外部からはアクセスできません。"

msgid ""
"Constants of the ``float`` type must be initialized using ``.`` notation "
"after the decimal part or by using the scientific notation. The optional "
"``f`` post-suffix is also supported."
msgstr ""
"``float`` 型の定数は整数部の後に ``.`` 表記を使用するか科学表記法を使用して初"
"期化する必要があります。オプションの ``f`` 後置接尾語もサポートされています。"

msgid ""
"Constants of the ``uint`` (unsigned int) type must have a ``u`` suffix to "
"differentiate them from signed integers. Alternatively, this can be done by "
"using the ``uint(x)`` built-in conversion function."
msgstr ""
"``uint`` (unsigned int) 型の定数には、 ``int`` (signed int) 型と区別するため"
"に ``u`` 接尾辞が必要です。もしくは組み込み変換関数 ``uint(x)`` を使用するこ"
"ともできます。"

msgid "Structs"
msgstr "構造体"

msgid ""
"Structs are compound types which can be used for better abstraction of "
"shader code. You can declare them at the global scope like:"
msgstr ""
"構造体はシェーダーコードをより適切に抽象化するために使用できる複合型です。次"
"のようにグローバルスコープで宣言できます。"

msgid "After declaration, you can instantiate and initialize them like:"
msgstr "宣言後、次のようにインスタンス化して初期化できます。"

msgid "Or use struct constructor for same purpose:"
msgstr "また、同じ目的で構造体のコンストラクタを使用できます。"

msgid ""
"Structs may contain other struct or array, you can also instance them as "
"global constant:"
msgstr ""
"構造体には他の構造体や配列を含めることができ、それらをグローバル定数としてイ"
"ンスタンス化することもできます。"

msgid "You can also pass them to functions:"
msgstr "構造体のインスタンスを関数へ渡すこともできます。"

msgid "Operators"
msgstr "オペレーター"

msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""
"Godotシェーディング言語は、GLSL ES 3.0と同じ一連の演算子をサポートしていま"
"す。以下に優先順位のリストを示します:"

msgid "Precedence"
msgstr "優先順位"

msgid "Class"
msgstr "クラス"

msgid "Operator"
msgstr "演算子"

msgid "1 (highest)"
msgstr "1 (最高)"

msgid "parenthetical grouping"
msgstr "カッコ内のグループ化"

msgid "**()**"
msgstr "\\ **()**"

msgid "2"
msgstr "2"

msgid "unary"
msgstr "単項"

msgid "**+, -, !, ~**"
msgstr "**+、-、!、~**"

msgid "3"
msgstr "\\ 3"

msgid "multiplicative"
msgstr "乗除算"

msgid "**/, \\*, %**"
msgstr "**/、\\*、%**"

msgid "4"
msgstr "\\ 4"

msgid "additive"
msgstr "加減算"

msgid "**+, -**"
msgstr "**+、-**"

msgid "5"
msgstr "\\ 5"

msgid "bit-wise shift"
msgstr "ビット単位のシフト"

msgid "**<<, >>**"
msgstr "**<<、>>**"

msgid "6"
msgstr "\\ 6"

msgid "relational"
msgstr "大小比較"

msgid "**<, >, <=, >=**"
msgstr "**<、>、<=、>=**"

msgid "7"
msgstr "\\ 7"

msgid "equality"
msgstr "一致、不一致"

msgid "**==, !=**"
msgstr "**==、!=**"

msgid "8"
msgstr "\\ 8"

msgid "bit-wise AND"
msgstr "ビット単位のAND"

msgid "**&**"
msgstr "\\ **&**"

msgid "9"
msgstr "\\ 9"

msgid "bit-wise exclusive OR"
msgstr "ビット単位の排他的OR"

msgid "**^**"
msgstr "\\ **^**"

msgid "10"
msgstr "10"

msgid "bit-wise inclusive OR"
msgstr "ビット単位の包括的OR"

msgid "**|**"
msgstr "\\ **|**"

msgid "11"
msgstr "\\ 11"

msgid "logical AND"
msgstr "論理AND"

msgid "**&&**"
msgstr "\\ **&&**"

msgid "12 (lowest)"
msgstr "12 (最低)"

msgid "logical inclusive OR"
msgstr "論理OR"

msgid "**||**"
msgstr "\\ **||**"

msgid "Flow control"
msgstr "構文制御"

msgid "Godot Shading language supports the most common types of flow control:"
msgstr ""
"Godotシェーディング言語は、最も一般的なタイプの構文制御をサポートしています:"

msgid ""
"Keep in mind that in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""
"最近のGPUでは無限ループが存在すると、アプリケーション(エディタを含む)がフリー"
"ズする可能性があることに注意してください。 Godotはこれを防ぐことはできないの"
"で、この間違いをしないように注意してください！"

msgid ""
"Also, when comparing floating-point values against a number, make sure to "
"compare them against a *range* instead of an exact number."
msgstr ""
"また、浮動小数点値を比較する場合は、正確な数値ではなく *範囲* と比較してくだ"
"さい。"

msgid ""
"A comparison like ``if (value == 0.3)`` may not evaluate to ``true``. "
"Floating-point math is often approximate and can defy expectations. It can "
"also behave differently depending on the hardware."
msgstr ""
"``if (value == 0.3)`` のような比較は、 ``true`` と評価されない可能性がありま"
"す。浮動小数点演算は近似的なことが多く、期待を裏切る可能性があります。また、"
"ハードウェアに応じて動作が異なる場合もあります。"

msgid "**Don't** do this."
msgstr "これは **書かないでください** 。"

msgid ""
"Instead, always perform a range comparison with an epsilon value. The larger "
"the floating-point number (and the less precise the floating-point number), "
"the larger the epsilon value should be."
msgstr ""
"代わりに、イプシロン値との範囲比較を行います。浮動小数点数が大きいほど (浮動"
"小数点数の精度が低いほど)、イプシロン値も大きくする必要があります。"

msgid ""
"See `floating-point-gui.de <https://floating-point-gui.de/>`__ for more "
"information."
msgstr ""
"詳細については `floating-point-gui.de <https://floating-point-gui.de/>`__ を"
"見てください。"

msgid "Discarding"
msgstr "ピクセルの破棄"

msgid ""
"Fragment and light functions can use the ``discard`` keyword. If used, the "
"fragment is discarded and nothing is written."
msgstr ""
"fragment関数とlight関数では、 ``discard`` キーワードを使用できます。discardが"
"実行されたフラグメントは破棄され、何も書き込まれません。"

msgid ""
"Beware that ``discard`` has a performance cost when used, as it will prevent "
"the depth prepass from being effective on any surfaces using the shader. "
"Also, a discarded pixel still needs to be rendered in the vertex shader, "
"which means a shader that uses ``discard`` on all of its pixels is still "
"more expensive to render compared to not rendering any object in the first "
"place."
msgstr ""
"``discard`` を使用すると、シェーダを使用するサーフェス上で深度プリパスが有効"
"にならなくなるため、使用するとパフォーマンスが低下することに注意してくださ"
"い。また、破棄されたピクセルでも依然として頂点シェーダーで処理する必要があり"
"ます。つまり、すべてのピクセルが ``discard`` で破棄されるとしても、最初からオ"
"ブジェクトをレンダリングしない場合と比較してレンダリングにはコストがかかりま"
"す。"

msgid "Functions"
msgstr "関数"

msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr "Godotシェーダーで関数を定義することが可能です。次の構文を使用します:"

msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them. Redefining a function "
"that has already been defined above (or is a built-in function name) will "
"cause an error."
msgstr ""
"呼び出し元の関数から見て上記(エディタの上方)で定義された関数のみを使用できま"
"す。上記で既に定義されている関数 (または組み込み関数名) を再定義するとエラー"
"が発生します。"

msgid "Function arguments can have special qualifiers:"
msgstr "関数の引数には特別な修飾子を含めることができます:"

msgid "**in**: Means the argument is only for reading (default)."
msgstr "**in**: 引数が読み取り専用であることを意味します(デフォルト)。"

msgid "**out**: Means the argument is only for writing."
msgstr "**out**: 引数が書き込み専用であることを意味します。"

msgid "**inout**: Means the argument is fully passed via reference."
msgstr "**inout**: 引数が参照を介して完全に渡されることを意味します。"

msgid ""
"**const**: Means the argument is a constant and cannot be changed, may be "
"combined with **in** qualifier."
msgstr ""
"**const**: 引数が定数で変更できないことを意味します。 **in** 修飾子と組み合わ"
"せることができます。"

msgid "Example below:"
msgstr "以下はその例です:"

msgid ""
"Unlike GLSL, Godot's shader language does **not** support function "
"overloading. This means that a function cannot be defined several times with "
"different argument types or numbers of arguments. As a workaround, use "
"different names for functions that accept a different number of arguments or "
"arguments of different types."
msgstr ""
"GLSL とは異なり、Godot のシェーダ言語は関数のオーバーロードを**サポートしませ"
"ん**。これは、異なる引数の型や引数の数を受け入れる関数を複数回定義することは"
"できないことを意味します。回避策として、異なる数の引数または異なる型の引数を"
"受け入れる関数には別々の名前を指定します。"

msgid "Varyings"
msgstr "Varying(可変)"

msgid ""
"To send data from the vertex to the fragment (or light) processor function, "
"*varyings* are used. They are set for every primitive vertex in the *vertex "
"processor*, and the value is interpolated for every pixel in the *fragment "
"processor*."
msgstr ""
"頂点からフラグメント (またはライト) プロセッサ関数にデータを送信するには、"
"*varying* が使用されます。それらは *頂点プロセッサ* のすべてのプリミティブ頂"
"点に対して設定され、*フラグメント プロセッサ* のすべてのピクセルに対して値が"
"補間されます。"

msgid "Varying can also be an array:"
msgstr "Varyingは配列にも指定できます:"

msgid ""
"It's also possible to send data from *fragment* to *light* processors using "
"*varying* keyword. To do so you can assign it in the *fragment* and later "
"use it in the *light* function."
msgstr ""
"*variing* キーワードを使用して、*fragment* から *light* プロセッサにデータを"
"送信することもできます。これを行うには、*fragment* で割り当てて、後で "
"*light* 関数で使用します。"

msgid ""
"Note that varying may not be assigned in custom functions or a *light "
"processor* function like:"
msgstr ""
"以下のようなカスタム関数や *light* 関数では、varying に代入することはできない"
"ことに注意してください。"

msgid ""
"This limitation was introduced to prevent incorrect usage before "
"initialization."
msgstr "この制限は、初期化前の誤った使用を防ぐために導入されました。"

msgid "Interpolation qualifiers"
msgstr "補間修飾子"

msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr ""
"特定の値は、シェーディングパイプライン中に補間されます。\\ *補間修飾子* を使"
"用して、これらの補間の実行方法を変更できます。"

msgid "There are two possible interpolation qualifiers:"
msgstr "次の2つの補間修飾子があります:"

msgid "Qualifier"
msgstr "修飾子"

msgid "**flat**"
msgstr "\\ **flat**"

msgid "The value is not interpolated."
msgstr "値は補間されません。"

msgid "**smooth**"
msgstr "\\ **smooth**"

msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr ""
"値は、パースペクティブに応じた方法で補間されます。これがデフォルトです。"

msgid "Uniforms"
msgstr "Uniform(ユニフォーム)"

msgid ""
"Passing values to shaders is possible. These are global to the whole shader "
"and are called *uniforms*. When a shader is later assigned to a material, "
"the uniforms will appear as editable parameters in it. Uniforms can't be "
"written from within the shader."
msgstr ""
"シェーダーに値を渡すことは可能です。これらはシェーダー全体に対してグローバル"
"であり、\\ *uniform* と呼ばれます。シェーダーが後でマテリアルに割り当てられる"
"と、uniformはその中の編集可能なパラメーターとして表示されます。シェーダー内か"
"らuniformを書くことはできません。"

msgid ""
"You can set uniforms in the editor in the material. Or you can set them "
"through GDScript:"
msgstr ""
"マテリアルのエディタでuniformを設定できます。または、GDScriptを使用して設定で"
"きます:"

msgid ""
"The first argument to ``set_shader_parameter`` is the name of the uniform in "
"the shader. It must match *exactly* to the name of the uniform in the shader "
"or else it will not be recognized."
msgstr ""
"``set_shader_parameter`` の最初の引数はシェーダーのuniformの名前です。シェー"
"ダーのuniformの名前と\\ *完全に*\\ 一致する必要があります。一致しない場合、認"
"識されません。"

msgid ""
"Any GLSL type except for *void* can be a uniform. Additionally, Godot "
"provides optional shader hints to make the compiler understand for what the "
"uniform is used, and how the editor should allow users to modify it."
msgstr ""
"*void* を除くすべてのGLSLタイプはuniformにすることができます。さらに、Godot "
"はuniformが何に使用されているか、およびエディターがユーザーにuniformをどのよ"
"うに変更できるようにするかをコンパイラーに理解させるためのオプションとして"
"シェーダーヒントを提供します。"

msgid ""
"It's important to understand that textures *that are supplied as color* "
"require hints for proper sRGB -> linear conversion (i.e. ``source_color``), "
"as Godot's 3D engine renders in linear color space. If this is not done, the "
"texture will appear washed out."
msgstr ""
"Godot の 3D エンジンはリニア色空間でレンダリングするため、*カラーとして提供さ"
"れる* テクスチャには、適切な sRGB -> リニア変換 (すなわち、``source_color``) "
"のためのヒントが必要であることを理解することが重要です。これを行わないとテク"
"スチャが色あせたように見えます。"

msgid ""
"The 2D renderer also renders in linear color space if the **Rendering > "
"Viewport > HDR 2D** project setting is enabled, so ``source_color`` must "
"also be used in ``canvas_item`` shaders. If 2D HDR is disabled, "
"``source_color`` will keep working correctly in ``canvas_item`` shaders, so "
"it's recommend to use it either way."
msgstr ""
"**[レンダリング] > [ビューポート] > [HDR 2D]** プロジェクト設定が有効になって"
"いる場合、2Dレンダラーはリニア 色空間でもレンダリングするため、 "
"``source_color`` も ``canvas_item`` シェーダで使用する必要があります。 2D "
"HDR が無効になっている場合でも、 ``source_color`` は ``canvas_item`` シェーダ"
"で正しく動作し続けるため、どちらの方法でも使用することをお勧めします。"

msgid "Full list of hints below:"
msgstr "以下はヒントの一覧です:"

msgid "Hint"
msgstr "ヒント"

msgid "**vec3, vec4**"
msgstr "\\ **vec3, vec4**"

msgid "source_color"
msgstr "\\ source_color"

msgid "Used as color."
msgstr "色として使用します。"

msgid "**int, float**"
msgstr "\\ **int, float**"

msgid "hint_range(min, max[, step])"
msgstr "\\ hint_range(min, max[, step])"

msgid "Restricted to values in a range (with min/max/step)."
msgstr "値の制限範囲を指定します (min/max/step)。"

msgid "Used as albedo color."
msgstr "アルベド色として使用します。"

msgid "hint_normal"
msgstr "\\ hint_normal"

msgid "Used as normalmap."
msgstr "法線マップとして使用します。"

msgid "hint_default_white"
msgstr "\\ hint_default_white"

msgid "As value or albedo color, default to opaque white."
msgstr "アルベド色として使用します。デフォルトは白色。"

msgid "hint_default_black"
msgstr "\\ hint_default_black"

msgid "As value or albedo color, default to opaque black."
msgstr "アルベド色として使用します。デフォルトは黒色。"

msgid "hint_default_transparent"
msgstr "\\ hint_default_transparent"

msgid "As value or albedo color, default to transparent black."
msgstr "アルベド色として使用します。デフォルトは黒色。"

msgid "hint_anisotropy"
msgstr "\\ hint_anisotropy"

msgid "As flowmap, default to right."
msgstr "フローマップとして使用します。デフォルトは右方向。"

msgid "hint_roughness[_r, _g, _b, _a, _normal, _gray]"
msgstr "\\ hint_roughness[_r, _g, _b, _a, _normal, _gray]"

msgid ""
"Used for roughness limiter on import (attempts reducing specular aliasing). "
"``_normal`` is a normal map that guides the roughness limiter, with "
"roughness increasing in areas that have high-frequency detail."
msgstr ""
"インポート時のラフネスリミッターに使用されます (鏡面反射光エイリアシングの軽"
"減を試みます)。``_normal`` は、ラフネスリミッターをガイドする法線マップであ"
"り、高周波のディテールを持つ領域では粗さが増加します。"

msgid "filter[_nearest, _linear][_mipmap][_anisotropic]"
msgstr "\\ filter[_nearest, _linear][_mipmap][_anisotropic]"

msgid "Enabled specified texture filtering."
msgstr "指定されたテクスチャフィルタリングを有効にします。"

msgid "repeat[_enable, _disable]"
msgstr "\\ repeat[_enable, _disable]"

msgid "Enabled texture repeating."
msgstr "テクスチャのリピートを有効にします。"

msgid "hint_screen_texture"
msgstr "\\ hint_screen_texture"

msgid "Texture is the screen texture."
msgstr "スクリーンのテクスチャを指定します。"

msgid "hint_depth_texture"
msgstr "\\ hint_depth_texture"

msgid "Texture is the depth texture."
msgstr "深度テクスチャを指定します。"

msgid "hint_normal_roughness_texture"
msgstr "\\ hint_normal_roughness_texture"

msgid "Texture is the normal roughness texture (only supported in Forward+)."
msgstr "法線とラフネスのテクスチャです (Forward+ でのみサポートされています)。"

msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""
"GDScriptはGLSLとは異なる変数タイプを使用するため、GDScriptからシェーダーに変"
"数を渡すと、Godotはタイプを自動的に変換します。以下は、対応するタイプの表で"
"す:"

msgid "GLSL type"
msgstr "GLSL型"

msgid "GDScript type"
msgstr "GDScript型"

msgid "Notes"
msgstr "備考"

msgid "Bitwise packed int where bit 0 (LSB) corresponds to x."
msgstr "intに各ビットがパックされます。ビット0(LSB) がxに対応。"

msgid "For example, a bvec2 of (bx, by) could be created in the following way:"
msgstr "たとえば、 (bx, by) の bvec2 は次の方法で作成できます。"

msgid "**Vector2i**"
msgstr "\\ **Vector2i**"

msgid "**Vector3i**"
msgstr "\\ **Vector3i**"

msgid "**Vector4i**"
msgstr "\\ **Vector4i**"

msgid "**Vector2**"
msgstr "\\ **Vector2**"

msgid "**Vector3**, **Color**"
msgstr "\\ **Vector3**, **Color**"

msgid "When Color is used, it will be interpreted as (r, g, b)."
msgstr "Color が使用される場合、(r, g, b) として解釈されます。"

msgid "**Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"
msgstr "\\ **Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"

msgid "When Color is used, it will be interpreted as (r, g, b, a)."
msgstr "Color が使用される場合、(r, g, b, a) として解釈されます。"

msgid ""
"When Rect2 is used, it will be interpreted as (position.x, position.y, size."
"x, size.y)."
msgstr ""
"Rect2 が使用される場合、(position.x, position.y, size.x, size.y) として解釈さ"
"れます。"

msgid ""
"When Plane is used it will be interpreted as (normal.x, normal.y, normal.z, "
"d)."
msgstr ""
"Plane が使用される場合、(normal.x, normal.y, normal.z, d) として解釈されま"
"す。"

msgid "**Transform2D**"
msgstr "\\ **Transform2D**"

#, fuzzy
msgid "**Basis**"
msgstr "Basis(基底)"

msgid "**Projection**, **Transform3D**"
msgstr "\\ **Projection**, **Transform3D**"

msgid "When a Transform3D is used, the w Vector is set to the identity."
msgstr ""
"Transform3D が使用される場合、w Vectorは単位行列になるように設定されます。"

msgid "**Texture2D**"
msgstr "\\ **Texture2D**"

msgid "**Texture2DArray**"
msgstr "\\ **Texture2DArray**"

msgid "**Texture3D**"
msgstr "\\ **Texture3D**"

msgid "**Cubemap**"
msgstr "\\ **Cubemap**"

msgid "**CubemapArray**"
msgstr "\\ **CubemapArray**"

msgid ""
"Be careful when setting shader uniforms from GDScript, no error will be "
"thrown if the type does not match. Your shader will just exhibit undefined "
"behavior."
msgstr ""
"GDScriptからシェーダーのuniformを設定するときは注意してください。タイプが一致"
"しない場合でもエラーはスローされません。シェーダーは未定義の動作を示すだけで"
"す。"

msgid "Uniforms can also be assigned default values:"
msgstr "Uniformにはデフォルト値を割り当てることもできます:"

msgid ""
"Note that when adding a default value and a hint, the default value goes "
"after the hint."
msgstr ""
"デフォルト値とヒントを追加する場合、デフォルト値がヒントの後に来ることに注意"
"してください。"

msgid ""
"If you need to make multiple uniforms to be grouped in the specific category "
"of an inspector, you can use a `group_uniform` keyword like:"
msgstr ""
"複数のUniformをインスペクターの特定のカテゴリにグループ化する必要がある場合"
"は、次のように `group_uniform` キーワードを使用できます。"

msgid "You can close the group by using:"
msgstr "そしてこちらを使用してグループを閉じることができます:"

msgid ""
"The syntax also supports subgroups (it's not mandatory to declare the base "
"group before this):"
msgstr ""
"この構文はサブグループもサポートしています (これより前にベースのグループを宣"
"言することは必須ではありません):"

msgid "Global uniforms"
msgstr "グローバルUniform"

msgid ""
"Sometimes, you want to modify a parameter in many different shaders at once. "
"With a regular uniform, this takes a lot of work as all these shaders need "
"to be tracked and the uniform needs to be set for each of them. Global "
"uniforms allow you to create and update uniforms that will be available in "
"all shaders, in every shader type (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` and ``fog``)."
msgstr ""
"場合によっては多くの異なるシェーダのパラメータを一度に変更したいことがありま"
"す。通常のUniformの場合はすべてのシェーダーを探し、それぞれにUniformを設定す"
"る必要があるため、多くの作業が必要になります。グローバルUniformを使用するとす"
"べてのシェーダーやすべてのシェーダータイプ ( ``canvas_item`` 、 "
"``spatial`` 、 ``particles`` 、 ``sky`` 、 ``fog`` ) で使用できるUniformを作"
"成および更新できます。"

msgid ""
"Global uniforms are especially useful for environmental effects that affect "
"many objects in a scene, like having foliage bend when the player is nearby, "
"or having objects move with the wind."
msgstr ""
"グローバルUniformは、プレイヤーが近くにいるときに葉が曲がったり、オブジェクト"
"が風で動いたりするなど、シーン内の多くのオブジェクトに影響を与えるような効果"
"で特に役立ちます。"

msgid ""
"To create a global uniform, open the **Project Settings** then go to the "
"**Shader Globals** tab. Specify a name for the uniform (case-sensitive) and "
"a type, then click **Add** in the top-right corner of the dialog. You can "
"then edit the value assigned to the uniform by clicking the value in the "
"list of uniforms:"
msgstr ""
"グローバルUniformを作成するには、 **プロジェクト設定** を開き、 **シェーダー"
"グローバル** タブに移動します。uniformの名前 (大文字と小文字を区別に注意) と"
"型を指定し、ダイアログの右上隅にある **追加** ボタンをクリックします。次に"
"uniformのリスト内の項目をクリックして、uniformに割り当てられた値を編集できま"
"す。"

msgid ""
"Adding a global uniform in the Shader Globals tab of the Project Settings"
msgstr ""
"プロジェクト設定のシェーダー グローバル タブにグローバルUniformを追加する"

msgid "After creating a global uniform, you can use it in a shader as follows:"
msgstr "グローバルUniformを作成した後、次のようにシェーダーで使用できます。"

msgid ""
"Note that the global uniform *must* exist in the Project Settings at the "
"time the shader is saved, or compilation will fail. While you can assign a "
"default value using ``global uniform vec4 my_color = ...`` in the shader "
"code, it will be ignored as the global uniform must always be defined in the "
"Project Settings anyway."
msgstr ""
"グローバルUniformはシェーダーの保存時にプロジェクト設定に存在する *必要があり"
"ます* 。存在しない場合はコンパイルは失敗します。シェーダーコードで ``global "
"uniform vec4 my_color = ...`` を使用してデフォルト値を割り当てることはできま"
"すが、グローバルUniformの値は常にプロジェクト設定で指定する必要があるため、こ"
"のデフォルト値は無視されます。"

msgid ""
"To change the value of a global uniform at run-time, use the :ref:"
"`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` method in a "
"script:"
msgstr ""
"実行時にグローバルUniformの値を変更するには、スクリプトで :ref:"
"`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` メソッドを使用し"
"ます。"

msgid ""
"Assigning global uniform values can be done as many times as desired without "
"impacting performance, as setting data doesn't require synchronization "
"between the CPU and GPU."
msgstr ""
"データの設定にはCPUとGPU間の同期が必要ないため、グローバルUniform値のセット"
"は、パフォーマンスに影響を与えることなく何度でも行うことができます。"

msgid "You can also add or remove global uniforms at run-time:"
msgstr "実行時にグローバルUniformを追加または削除することもできます:"

msgid ""
"Adding or removing global uniforms at run-time has a performance cost, "
"although it's not as pronounced compared to getting global uniform values "
"from a script (see the warning below)."
msgstr ""
"実行時にグローバルUniformを追加または削除すると、スクリプトからグローバル"
"Uniform値を取得する場合ほど顕著ではありませんが、パフォーマンスコストが発生し"
"ます (以下の警告を参照)。"

msgid ""
"While you *can* query the value of a global uniform at run-time in a script "
"using ``RenderingServer.global_shader_parameter_get(\"uniform_name\")``, "
"this has a large performance penalty as the rendering thread needs to "
"synchronize with the calling thread."
msgstr ""
"``RenderingServer.global_shader_parameter_get(\"uniform_name\")`` を使用して"
"スクリプトで実行時にグローバルUniformの値を取得することは *できます* が、レン"
"ダリングスレッドは呼び出しスレッドと同期する必要があるため、パフォーマンスが"
"大幅に低下します。"

msgid ""
"Therefore, it's not recommended to read global shader uniform values "
"continuously in a script. If you need to read values in a script after "
"setting them, consider creating an :ref:`autoload <doc_singletons_autoload>` "
"where you store the values you need to query at the same time you're setting "
"them as global uniforms."
msgstr ""
"したがってスクリプト内でグローバルシェーダーのUniform値を連続的に読み取ること"
"はお勧めできません。設定後にスクリプトで値を読み取る必要がある場合は、グロー"
"バルUniformとしてセットすると同時に取得するために値を保存するシングルトンクラ"
"ス :ref:`autoload <doc_singletons_autoload>` を作成することを検討してくださ"
"い。"

msgid "Per-instance uniforms"
msgstr "インスタンス単位のUniform"

msgid "Per-instance uniforms are only available in ``spatial`` (3D) shaders."
msgstr ""
"インスタンス単位のUniformは ``spatial`` (3D) シェーダーでのみ使用できます。"

msgid ""
"Per-instance uniforms are not supported when using the Compatibility "
"renderer."
msgstr ""

msgid ""
"Sometimes, you want to modify a parameter on each node using the material. "
"As an example, in a forest full of trees, when you want each tree to have a "
"slightly different color that is editable by hand. Without per-instance "
"uniforms, this requires creating a unique material for each tree (each with "
"a slightly different hue). This makes material management more complex, and "
"also has a performance overhead due to the scene requiring more unique "
"material instances. Vertex colors could also be used here, but they'd "
"require creating unique copies of the mesh for each different color, which "
"also has a performance overhead."
msgstr ""
"マテリアルを使用して各ノードのパラメータを変更したい場合があります。たとえば"
"木々が生い茂る森で、それぞれの木に手動で編集できるわずかに異なる色を持たせた"
"い場合です。インスタンスごとにUniformを持たない場合、木ごとに固有のマテリア"
"ル (それぞれがわずかに異なる色) を作成する必要があります。これによりマテリア"
"ル管理がより複雑になり、シーンではより固有のマテリアルインスタンスが必要にな"
"るため、パフォーマンスのオーバーヘッドも発生します。ここでは頂点カラーを使用"
"することもできますが、異なる色ごとにメッシュの一意のコピーを作成する必要があ"
"り、パフォーマンスのオーバーヘッドも発生します。"

msgid ""
"Per-instance uniforms are set on each GeometryInstance3D, rather than on "
"each Material instance. Take this into account when working with meshes that "
"have multiple materials assigned to them, or MultiMesh setups."
msgstr ""
"インスタンス単位のUniformは、各マテリアルインスタンスではなく、各 "
"GeometryInstance3D に設定されます。複数のマテリアルが割り当てられているメッ"
"シュ、またはマルチメッシュを操作する場合は、こちらを考慮してください。"

msgid ""
"After saving the shader, you can change the per-instance uniform's value "
"using the inspector:"
msgstr ""
"シェーダーを保存した後、インスペクターを使用してインスタンス単位のUniformの値"
"を変更できます。"

msgid ""
"Setting a per-instance uniform's value in the GeometryInstance3D section of "
"the inspector"
msgstr ""
"インスペクターの GeometryInstance3D セクションでインスタンス単位のUniformの"
"値 (Instance Shader Parameters) を設定する"

msgid ""
"Per-instance uniform values can also be set at run-time using :ref:"
"`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` method on a "
"node that inherits from :ref:`class_GeometryInstance3D`:"
msgstr ""
"インスタンス単位のUniform値は、:ref:`class_GeometryInstance3D` を継承するノー"
"ド上で :ref:`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` メソッドを使"
"用して実行時にセットすることもできます。"

msgid ""
"When using per-instance uniforms, there are some restrictions you should be "
"aware of:"
msgstr ""
"インスタンス単位のUniformを使用する場合は、いくつかの制限事項に注意する必要が"
"あります:"

msgid ""
"**Per-instance uniforms do not support textures**, only regular scalar and "
"vector types. As a workaround, you can pass a texture array as a regular "
"uniform, then pass the index of the texture to be drawn using a per-instance "
"uniform."
msgstr ""
"**インスタンス単位のUniformはテクスチャをサポートしません** 。通常のスカラー"
"型とベクター型のみをサポートします。回避策としてはテクスチャ配列を通常の"
"Uniformとして渡してから、インスタンス単位のUniformを使用して描画されるテクス"
"チャのインデックスを渡すことができます。"

msgid "There is a practical maximum limit of 16 instance uniforms per shader."
msgstr ""
"実際には1シェーダーあたりのインスタンスUniformの最大数は16までに制限されてい"
"ます。"

msgid ""
"If your mesh uses multiple materials, the parameters for the first mesh "
"material found will \"win\" over the subsequent ones, unless they have the "
"same name, index *and* type. In this case, all parameters are affected "
"correctly."
msgstr ""
"メッシュが複数のマテリアルを使用している場合、名前、インデックス、型が同じで"
"ない限り、最初に見つかったメッシュマテリアルのパラメータが後続のメッシュマテ"
"リアルよりも「優先」されます。この場合すべてのパラメータが正しく影響されま"
"す。"

msgid ""
"If you run into the above situation, you can avoid clashes by manually "
"specifying the index (0-15) of the instance uniform by using the "
"``instance_index`` hint:"
msgstr ""
"上記の状況に遭遇した場合は、 ``instance_index`` ヒントを使用してインスタンス"
"Uniformのインデックス (0～15) を手動で指定することで衝突を回避できます。"

msgid "Built-in variables"
msgstr "ビルトイン変数"

msgid ""
"A large number of built-in variables are available, like ``UV``, ``COLOR`` "
"and ``VERTEX``. What variables are available depends on the type of shader "
"(``spatial``, ``canvas_item`` or ``particle``) and the function used "
"(``vertex``, ``fragment`` or ``light``). For a list of the built-in "
"variables that are available, please see the corresponding pages:"
msgstr ""
"``UV`` 、 ``COLOR`` 、 ``VERTEX`` など、多くのビルトイン変数が使用可能です。"
"どの変数が使用できるかは、シェーダのタイプ ( ``spatial`` 、 "
"``canvas_item`` 、 ``particle``) および使用される関数 ( ``vertex`` 、 "
"``fragment`` 、 ``light`` ) によって異なります。使用可能な組み込み変数のリス"
"トについては、対応するページを参照してください。"

msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr "\\ :ref:`Spatial(空間)シェーダー <doc_spatial_shader>`"

msgid ":ref:`Canvas item shaders <doc_canvas_item_shader>`"
msgstr ":ref:`CanvasItemシェーダー <doc_canvas_item_shader>`"

msgid ":ref:`Particle shaders <doc_particle_shader>`"
msgstr "\\ :ref:`パーティクルシェーダ <doc_particle_shader>`"

msgid ":ref:`Sky shaders <doc_sky_shader>`"
msgstr "\\ :ref:`Skyシェーダー <doc_sky_shader>`"

msgid ":ref:`Fog shaders <doc_fog_shader>`"
msgstr "\\ :ref:`Fogシェーダー <doc_fog_shader>`"

msgid "Built-in functions"
msgstr "ビルトイン関数"

msgid ""
"A large number of built-in functions are supported, conforming to GLSL ES "
"3.0. When vec_type (float), vec_int_type, vec_uint_type, vec_bool_type "
"nomenclature is used, it can be scalar or vector."
msgstr ""
"GLSL ES 3.0に準拠した多数のビルトイン関数がサポートされています。 "
"vec_type(float)、vec_int_type、vec_uint_type、vec_bool_type 命名法を使用する"
"場合、スカラーまたはベクトルを使用できます。"

msgid "Function"
msgstr "関数"

msgid "Description / Return value"
msgstr "説明 /返り値"

msgid "vec_type **radians** (vec_type degrees)"
msgstr "\\ vec_type **radians** (vec_type degrees)"

msgid "Convert degrees to radians."
msgstr "度をラジアンに変換する。"

msgid "vec_type **degrees** (vec_type radians)"
msgstr "\\ vec_type **degrees** (vec_type radians)"

msgid "Convert radians to degrees."
msgstr "ラジアンを度に変換する。"

msgid "vec_type **sin** (vec_type x)"
msgstr "\\ vec_type **sin** (vec_type x)"

msgid "Sine."
msgstr "サイン(正弦)。"

msgid "vec_type **cos** (vec_type x)"
msgstr "\\ vec_type **cos** (vec_type x)"

msgid "Cosine."
msgstr "コサイン(余弦)。"

msgid "vec_type **tan** (vec_type x)"
msgstr "\\ vec_type **tan** (vec_type x)"

msgid "Tangent."
msgstr "タンジェント(正接)。"

msgid "vec_type **asin** (vec_type x)"
msgstr "\\ vec_type **asin** (vec_type x)"

msgid "Arcsine."
msgstr "アークコサイン(逆余弦)。"

msgid "vec_type **acos** (vec_type x)"
msgstr "\\ vec_type **acos** (vec_type x)"

msgid "Arccosine."
msgstr "アークコサイン(逆余弦)。"

msgid "vec_type **atan** (vec_type y_over_x)"
msgstr "\\ vec_type **atan** (vec_type y_over_x)"

msgid "Arctangent."
msgstr "アークタンジェント(逆正接)。"

msgid "vec_type **atan** (vec_type y, vec_type x)"
msgstr "\\ vec_type **atan** (vec_type y, vec_type x)"

msgid "vec_type **sinh** (vec_type x)"
msgstr "\\ vec_type **sinh** (vec_type x)"

msgid "Hyperbolic sine."
msgstr "双曲線コサイン。"

msgid "vec_type **cosh** (vec_type x)"
msgstr "\\ vec_type **cosh** (vec_type x)"

msgid "Hyperbolic cosine."
msgstr "双曲線コサイン。"

msgid "vec_type **tanh** (vec_type x)"
msgstr "\\ vec_type **tanh** (vec_type x)"

msgid "Hyperbolic tangent."
msgstr "双曲線タンジェント。"

msgid "vec_type **asinh** (vec_type x)"
msgstr "\\ vec_type **asinh** (vec_type x)"

msgid "Inverse hyperbolic sine."
msgstr "双曲線アークコサイン。"

msgid "vec_type **acosh** (vec_type x)"
msgstr "\\ vec_type **acosh** (vec_type x)"

msgid "Inverse hyperbolic cosine."
msgstr "双曲線アークコサイン。"

msgid "vec_type **atanh** (vec_type x)"
msgstr "\\ vec_type **atanh** (vec_type x)"

msgid "Inverse hyperbolic tangent."
msgstr "双曲線アークタンジェント。"

msgid "vec_type **pow** (vec_type x, vec_type y)"
msgstr "\\ vec_type **pow** (vec_type x, vec_type y)"

msgid "Power (undefined if ``x`` < 0 or if ``x`` == 0 and ``y`` <= 0)."
msgstr "xのy乗 (未定義条件: if ``x`` < 0 or if ``x`` == 0 and ``y`` <= 0)。"

msgid "vec_type **exp** (vec_type x)"
msgstr "\\ vec_type **exp** (vec_type x)"

msgid "Base-e exponential."
msgstr "eを底とする指数。"

msgid "vec_type **exp2** (vec_type x)"
msgstr "\\ vec_type **exp2** (vec_type x)"

msgid "Base-2 exponential."
msgstr "2を底とする指数。"

msgid "vec_type **log** (vec_type x)"
msgstr "\\ vec_type **log** (vec_type x)"

msgid "Natural logarithm."
msgstr "自然対数。"

msgid "vec_type **log2** (vec_type x)"
msgstr "\\ vec_type **log2** (vec_type x)"

msgid "Base-2 logarithm."
msgstr "2を底とする対数。"

msgid "vec_type **sqrt** (vec_type x)"
msgstr "\\ vec_type **sqrt** (vec_type x)"

msgid "Square root."
msgstr "平方根。"

msgid "vec_type **inversesqrt** (vec_type x)"
msgstr "\\ vec_type **inversesqrt** (vec_type x)"

msgid "Inverse square root."
msgstr "逆平方根。"

msgid "vec_type **abs** (vec_type x)"
msgstr "\\ vec_type **abs** (vec_type x)"

msgid "ivec_type **abs** (ivec_type x)"
msgstr "\\ ivec_type **abs** (ivec_type x)"

msgid "Absolute value (returns positive value if negative)."
msgstr "絶対値 (負の場合は正の値を返す)。"

msgid "vec_type **sign** (vec_type x)"
msgstr "\\ vec_type **sign** (vec_type x)"

msgid "ivec_type **sign** (ivec_type x)"
msgstr "\\ ivec_type **sign** (ivec_type x)"

msgid ""
"Sign (returns ``1.0`` if positive, ``-1.0`` if negative, ``0.0`` if zero)."
msgstr ""
"符号 (正の時 ``1.0`` を返し、負の時 ``-1.0`` を返し、ゼロの時 ``0.0`` を返"
"す)。"

msgid "vec_type **floor** (vec_type x)"
msgstr "\\ vec_type **floor** (vec_type x)"

msgid "Round to the integer below."
msgstr "x以下の最も近い整数に丸める。"

msgid "vec_type **round** (vec_type x)"
msgstr "\\ vec_type **round** (vec_type x)"

msgid "Round to the nearest integer."
msgstr "最も近い整数に丸める(四捨五入)。"

msgid "vec_type **roundEven** (vec_type x)"
msgstr "\\ vec_type **roundEven** (vec_type x)"

msgid "Round to the nearest even integer."
msgstr "最も近い偶数の整数に丸める。"

msgid "vec_type **trunc** (vec_type x)"
msgstr "\\ vec_type **trunc** (vec_type x)"

msgid "Truncation."
msgstr "ゼロ方向の整数に丸める(小数点切り捨て)。"

msgid "vec_type **ceil** (vec_type x)"
msgstr "\\ vec_type **ceil** (vec_type x)"

msgid "Round to the integer above."
msgstr "x以上の最も近い整数に丸める。"

msgid "vec_type **fract** (vec_type x)"
msgstr "\\ vec_type **fract** (vec_type x)"

msgid "Fractional (returns ``x - floor(x)``)."
msgstr "小数部 (``x - floor(x)`` を返す)。"

msgid "vec_type **mod** (vec_type x, vec_type y)"
msgstr "\\ vec_type **mod** (vec_type x, vec_type y)"

msgid "vec_type **mod** (vec_type x, float y)"
msgstr "\\ vec_type **mod** (vec_type x, float y)"

msgid "Modulo (division remainder)."
msgstr "剰余 (割り算の余り)。"

msgid "vec_type **modf** (vec_type x, out vec_type i)"
msgstr "\\ vec_type **modf** (vec_type x, out vec_type i)"

msgid "Fractional of ``x``, with ``i`` as integer part."
msgstr "xの小数部を返し、iに整数部が代入される。"

msgid "vec_type  **min** (vec_type a, vec_type b)"
msgstr "\\ vec_type **min** (vec_type a, vec_type b)"

msgid "Lowest value between ``a`` and ``b``."
msgstr "``a`` と ``b`` の小さいほうを返す。"

msgid "vec_type  **max** (vec_type a, vec_type b)"
msgstr "\\ vec_type **max** (vec_type a, vec_type b)"

msgid "Highest value between ``a`` and ``b``."
msgstr "``a`` と ``b`` の大きいほうを返す。"

msgid "vec_type **clamp** (vec_type x, vec_type min, vec_type max)"
msgstr "\\ vec_type **clamp** (vec_type x, vec_type min, vec_type max)"

msgid "Clamp ``x`` between ``min`` and ``max`` (inclusive)."
msgstr "``x`` を範囲内( ``min`` と ``max`` の間)に収めた値を返す。"

msgid "float **mix** (float a, float b, float c)"
msgstr "\\ float **mix** (float a, float b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, float c)"
msgstr "\\ vec_type **mix** (vec_type a, vec_type b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, bvec_type c)"
msgstr "\\ vec_type **mix** (vec_type a, vec_type b, bvec_type c)"

msgid "Linear interpolate between ``a`` and ``b`` by ``c``."
msgstr "``a`` と ``b`` の間を ``c`` で線形補間する。"

msgid "vec_type **fma** (vec_type a, vec_type b, vec_type c)"
msgstr "\\ vec_type **fma** (vec_type a, vec_type b, vec_type c)"

msgid ""
"Performs a fused multiply-add operation: ``(a * b + c)`` (faster than doing "
"it manually)."
msgstr "融合積和演算 ``(a * b + c)`` を行う(手動で書くより高速です)。"

msgid "vec_type **step** (vec_type a, vec_type b)"
msgstr "\\ vec_type **step** (vec_type a, vec_type b)"

msgid "``b[i] < a[i] ? 0.0 : 1.0``."
msgstr "\\ ``b[i] < a[i] ? 0.0 : 1.0`` 。"

msgid "vec_type **step** (float a, vec_type b)"
msgstr "\\ vec_type **step** (float a, vec_type b)"

msgid "``b[i] < a ? 0.0 : 1.0``."
msgstr "\\ ``b[i] < a ? 0.0 : 1.0`` 。"

msgid "vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"
msgstr "\\ vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"

msgid "vec_type **smoothstep** (float a, float b, vec_type c)"
msgstr "\\ vec_type **smoothstep** (float a, float b, vec_type c)"

msgid "Hermite interpolate between ``a`` and ``b`` by ``c``."
msgstr "``a`` と ``b`` の間を ``c`` でエルミート補間する。"

msgid "bvec_type **isnan** (vec_type x)"
msgstr "\\ bvec_type **isnan** (vec_type x)"

msgid "Returns ``true`` if scalar or vector component is ``NaN``."
msgstr "スカラーまたはベクトル要素が ``NaN`` の場合は ``true`` を返す。"

msgid "bvec_type **isinf** (vec_type x)"
msgstr "\\ bvec_type **isinf** (vec_type x)"

msgid "Returns ``true`` if scalar or vector component is ``INF``."
msgstr "スカラーまたはベクトル要素が ``INF`` の場合は、 ``true`` を返す。"

msgid "ivec_type **floatBitsToInt** (vec_type x)"
msgstr "\\ ivec_type **floatBitsToInt** (vec_type x)"

msgid "Float->Int bit copying, no conversion."
msgstr "float型からint型へビットを維持してコピー。"

msgid "uvec_type **floatBitsToUint** (vec_type x)"
msgstr "\\ uvec_type **floatBitsToUint** (vec_type x)"

msgid "Float->UInt bit copying, no conversion."
msgstr "float型からuint型へビットを維持してコピー。"

msgid "vec_type **intBitsToFloat** (ivec_type x)"
msgstr "\\ vec_type **intBitsToFloat** (ivec_type x)"

msgid "Int->Float bit copying, no conversion."
msgstr "int型からfloat型へビットを維持してコピー。"

msgid "vec_type **uintBitsToFloat** (uvec_type x)"
msgstr "\\ vec_type **uintBitsToFloat** (uvec_type x)"

msgid "UInt->Float bit copying, no conversion."
msgstr "uint型からfloat型へビットを維持してコピー。"

msgid "float **length** (vec_type x)"
msgstr "\\ float **length** (vec_type x)"

msgid "Vector length."
msgstr "ベクトルの長さ。"

msgid "float **distance** (vec_type a, vec_type b)"
msgstr "\\ float **distance** (vec_type a, vec_type b)"

msgid "Distance between vectors i.e ``length(a - b)``."
msgstr "2つのベクトル間の距離。つまり ``length(a-b)`` 。"

msgid "float **dot** (vec_type a, vec_type b)"
msgstr "\\ float **dot** (vec_type a, vec_type b)"

msgid "Dot product."
msgstr "内積 (ドット積)。"

msgid "vec3 **cross** (vec3 a, vec3 b)"
msgstr "\\ vec3 **cross** (vec3 a, vec3 b)"

msgid "Cross product."
msgstr "外積 (クロス積)。"

msgid "vec_type **normalize** (vec_type x)"
msgstr "\\ vec_type **normalize** (vec_type x)"

msgid "Normalize to unit length."
msgstr "単位ベクトルに正規化。"

msgid "vec3 **reflect** (vec3 I, vec3 N)"
msgstr "\\ vec3 **reflect** (vec3 I, vec3 N)"

msgid "Reflect."
msgstr "反射。"

msgid "vec3 **refract** (vec3 I, vec3 N, float eta)"
msgstr "\\ vec3 **refract** (vec3 I, vec3 N, float eta)"

msgid "Refract."
msgstr "屈折。"

msgid "vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)"
msgstr "\\ vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)"

msgid "If ``dot(Nref, I)`` < 0, return ``N``, otherwise ``-N``."
msgstr ""
"``dot(Nref, I)`` < 0 の場合は ``N`` を返し、それ以外の場合は ``-N`` を返す。"

msgid "mat_type **matrixCompMult** (mat_type x, mat_type y)"
msgstr "\\ mat_type **matrixCompMult** (mat_type x, mat_type y)"

msgid "Matrix component multiplication."
msgstr "行列要素の乗算。"

msgid "mat_type **outerProduct** (vec_type column, vec_type row)"
msgstr "\\ mat_type **outerProduct** (vec_type column, vec_type row)"

msgid "Matrix outer product."
msgstr "行列の外積。"

msgid "mat_type **transpose** (mat_type m)"
msgstr "\\ mat_type **transpose** (mat_type m)"

msgid "Transpose matrix."
msgstr "転置行列。"

msgid "float **determinant** (mat_type m)"
msgstr "\\ float **determinant** (mat_type m)"

msgid "Matrix determinant."
msgstr "行列式。"

msgid "mat_type **inverse** (mat_type m)"
msgstr "\\ mat_type **inverse** (mat_type m)"

msgid "Inverse matrix."
msgstr "逆行列。"

msgid "bvec_type **lessThan** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **lessThan** (vec_type x, vec_type y)"

msgid "Bool vector comparison on < int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x < y)した結果をboolベクトルとして返す。"

msgid "bvec_type **greaterThan** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **greaterThan** (vec_type x, vec_type y)"

msgid "Bool vector comparison on > int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x > y)した結果をboolベクトルとして返す。"

msgid "bvec_type **lessThanEqual** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **lessThanEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on <= int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x <= y)した結果をboolベクトルとして返"
"す。"

msgid "bvec_type **greaterThanEqual** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **greaterThanEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on >= int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x >= y)した結果をboolベクトルとして返"
"す。"

msgid "bvec_type **equal** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **equal** (vec_type x, vec_type y)"

msgid "Bool vector comparison on == int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x == y)した結果をboolベクトルとして返"
"す。"

msgid "bvec_type **notEqual** (vec_type x, vec_type y)"
msgstr "\\ bvec_type **notEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on != int/uint/float vectors."
msgstr ""
"int/uint/floatベクトルの各要素を比較(x != y)した結果をboolベクトルとして返"
"す。"

msgid "bool **any** (bvec_type x)"
msgstr "\\ bool **any** (bvec_type x)"

msgid "``true`` if any component is ``true``, ``false`` otherwise."
msgstr ""
"いずれかの要素が ``true`` の場合は ``true`` 、それ以外の場合は ``false`` を返"
"す。"

msgid "bool **all** (bvec_type x)"
msgstr "\\ bool **all** (bvec_type x)"

msgid "``true`` if all components are ``true``, ``false`` otherwise."
msgstr ""
"すべての要素が ``true`` の場合は ``true`` 、それ以外の場合は ``false`` を返"
"す。"

msgid "bvec_type **not** (bvec_type x)"
msgstr "\\ bvec_type **not** (bvec_type x)"

msgid "Invert boolean vector."
msgstr "boolベクトルの反転"

msgid "ivec2 **textureSize** (gsampler2D s, int lod)"
msgstr "\\ ivec2 **textureSize** (gsampler2D s, int lod)"

msgid "ivec3 **textureSize** (gsampler2DArray s, int lod)"
msgstr "\\ ivec3 **textureSize** (gsampler2DArray s, int lod)"

msgid "ivec3 **textureSize** (gsampler3D s, int lod)"
msgstr "\\ ivec3 **textureSize** (gsampler3D s, int lod)"

msgid "ivec2 **textureSize** (samplerCube s, int lod)"
msgstr "\\ ivec2 **textureSize** (samplerCube s, int lod)"

msgid "ivec2 **textureSize** (samplerCubeArray s, int lod)"
msgstr "\\ ivec2 **textureSize** (samplerCubeArray s, int lod)"

msgid "Get the size of a texture."
msgstr "テクスチャのサイズを取得する。"

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0`` will use "
"the full resolution texture."
msgstr ""
"LOD はどのミップマップレベルが使用されるかを指定します。 LOD値が ``0`` の場合"
"は、フル解像度のテクスチャが使用されます。"

msgid "vec2 **textureQueryLod** (gsampler2D s, vec2 p)"
msgstr "\\ vec2 **textureQueryLod** (gsampler2D s, vec2 p)"

msgid "vec3 **textureQueryLod** (gsampler2DArray s, vec2 p)"
msgstr "\\ vec3 **textureQueryLod** (gsampler2DArray s, vec2 p)"

msgid "vec2 **textureQueryLod** (gsampler3D s, vec3 p)"
msgstr "\\ vec2 **textureQueryLod** (gsampler3D s, vec3 p)"

msgid "vec2 **textureQueryLod** (samplerCube s, vec3 p)"
msgstr "\\ vec2 **textureQueryLod** (samplerCube s, vec3 p)"

msgid ""
"Compute the level-of-detail that would be used to sample from a texture. The "
"``x`` component of the resulted value is the mipmap array that would be "
"accessed. The ``y`` component is computed level-of-detail relative to the "
"base level (regardless of the mipmap levels of the texture)."
msgstr ""

#, fuzzy
msgid "int **textureQueryLevels** (gsampler2D s)"
msgstr "\\ ivec3 **textureSize** ( sampler3D s, int lod )"

#, fuzzy
msgid "int **textureQueryLevels** (gsampler2DArray s)"
msgstr "\\ ivec3 **textureSize** ( sampler2DArray_type s, int lod )"

#, fuzzy
msgid "int **textureQueryLevels** (gsampler3D s)"
msgstr "\\ ivec3 **textureSize** ( sampler3D s, int lod )"

#, fuzzy
msgid "int **textureQueryLevels** (samplerCube s)"
msgstr "\\ ivec2 **textureSize** ( samplerCube s, int lod )"

msgid "Get the number of accessible mipmap levels of a texture."
msgstr "テクスチャのアクセス可能なミップマップレベルの数を取得する。"

msgid ""
"If the texture is unassigned to a sampler, ``1`` is returned (Godot always "
"internally assigns a texture even to an empty sampler)."
msgstr ""
"テクスチャがサンプラーに割り当てられていない場合は ``1`` が返る。(Godot は空"
"のサンプラーにも常に内部でテクスチャを割り当てます)。"

msgid "gvec4_type **texture** (gsampler2D s, vec2 p [, float bias])"
msgstr "\\ gvec4_type **texture** (gsampler2D s, vec2 p [, float bias])"

msgid "gvec4_type **texture** (gsampler2DArray s, vec3 p [, float bias])"
msgstr "\\ gvec4_type **texture** (gsampler2DArray s, vec3 p [, float bias])"

msgid "gvec4_type **texture** (gsampler3D s, vec3 p [, float bias])"
msgstr "\\ gvec4_type **texture** (gsampler3D s, vec3 p [, float bias])"

msgid "vec4 **texture** (samplerCube s, vec3 p [, float bias])"
msgstr "\\ vec4 **texture** (samplerCube s, vec3 p [, float bias])"

msgid "vec4 **texture** (samplerCubeArray s, vec4 p [, float bias])"
msgstr "\\ vec4 **texture** (samplerCubeArray s, vec4 p [, float bias])"

msgid "Perform a texture read."
msgstr "テクスチャの読み取りを実行する。"

msgid "gvec4_type **textureProj** (gsampler2D s, vec3 p [, float bias])"
msgstr "\\ gvec4_type **textureProj** (gsampler2D s, vec3 p [, float bias])"

msgid "gvec4_type **textureProj** (gsampler2D s, vec4 p [, float bias])"
msgstr "\\ gvec4_type **textureProj** (gsampler2D s, vec4 p [, float bias])"

msgid "gvec4_type **textureProj** (gsampler3D s, vec4 p [, float bias])"
msgstr "\\ gvec4_type **textureProj** (gsampler3D s, vec4 p [, float bias])"

msgid "Perform a texture read with projection."
msgstr "投影を使用して2Dテクスチャの読み取りを実行する。"

msgid "gvec4_type **textureLod** (gsampler2D s, vec2 p, float lod)"
msgstr "\\ gvec4_type **textureLod** (gsampler2D s, vec2 p, float lod)"

msgid "gvec4_type **textureLod** (gsampler2DArray s, vec3 p, float lod)"
msgstr "\\ gvec4_type **textureLod** (gsampler2DArray s, vec3 p, float lod)"

msgid "gvec4_type **textureLod** (gsampler3D s, vec3 p, float lod)"
msgstr "\\ gvec4_type **textureLod** (gsampler3D s, vec3 p, float lod)"

msgid "vec4 **textureLod** (samplerCube s, vec3 p, float lod)"
msgstr "\\ vec4 **textureLod** (samplerCube s, vec3 p, float lod)"

msgid "vec4 **textureLod** (samplerCubeArray s, vec4 p, float lod)"
msgstr "\\ vec4 **textureLod** (samplerCubeArray s, vec4 p, float lod)"

msgid "Perform a texture read at custom mipmap."
msgstr "カスタムミップマップでテクスチャの読み取りを実行する。"

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0.0`` will use "
"the full resolution texture. If the texture lacks mipmaps, all LOD values "
"will act like ``0.0``."
msgstr ""

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler2D s, vec3 p, float lod)"
msgstr ""
"\\ vec4_type **textureProjLod** ( sampler2D_type s, vec3 uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler2D s, vec4 p, float lod)"
msgstr ""
"\\ vec4_type **textureProjLod** ( sampler2D_type s, vec4 uv, float lod )"

#, fuzzy
msgid "gvec4_type **textureProjLod** (gsampler3D s, vec4 p, float lod)"
msgstr ""
"\\ vec4_type **textureProjLod** ( sampler3D_type s, vec4 uv, float lod )"

#, fuzzy
msgid "Performs a texture read with projection/LOD."
msgstr "投影を使用して2Dテクスチャの読み取りを実行する"

#, fuzzy
msgid "gvec4_type **textureGrad** (gsampler2D s, vec2 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid ""
"gvec4_type **textureGrad** (gsampler2DArray s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid "gvec4_type **textureGrad** (gsampler3D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid "vec4 **textureGrad** (samplerCube s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid "vec4 **textureGrad** (samplerCubeArray s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid "Performs a texture read with explicit gradients."
msgstr "投影を使用して2Dテクスチャの読み取りを実行する"

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec4 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid ""
"gvec4_type **textureProjGrad** (gsampler3D s, vec4 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"\\ vec4_type **textureGrad** ( sampler_type s, vec_type uv, vec_type dPdx, "
"vec_type dPdy)"

#, fuzzy
msgid ""
"Performs a texture read with projection/LOD and with explicit gradients."
msgstr "投影を使用して2Dテクスチャの読み取りを実行する"

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler2D s, ivec2 p, int lod)"
msgstr "\\ vec4_type **texelFetch** ( sampler2D_type s, ivec2 uv, int lod )"

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler2DArray s, ivec3 p, int lod)"
msgstr ""
"\\ vec4_type **texelFetch** ( sampler2DArray_type s, ivec3 uv, int lod )"

#, fuzzy
msgid "gvec4_type **texelFetch** (gsampler3D s, ivec3 p, int lod)"
msgstr "\\ vec4_type **texelFetch** ( sampler3D_type s, ivec3 uv, int lod )"

msgid "Fetches a single texel using integer coordinates."
msgstr "整数座標を使用して単一のテクセルを取得する。"

#, fuzzy
msgid "gvec4_type **textureGather** (gsampler2D s, vec2 p [, int comps])"
msgstr "\\ vec4_type **texture** ( sampler2D_type s, vec2 uv [, float bias] )"

msgid "gvec4_type **textureGather** (gsampler2DArray s, vec3 p [, int comps])"
msgstr "gvec4_type **textureGather** (gsampler2DArray s, vec3 p [, int comps])"

#, fuzzy
msgid "vec4 **textureGather** (samplerCube s, vec3 p [, int comps])"
msgstr "\\ vec4 **texture** ( samplerCube s, vec3 uv [, float bias] )"

msgid ""
"Gathers four texels from a texture. Use ``comps`` within range of 0..3 to "
"define which component (x, y, z, w) is returned. If ``comps`` is not "
"provided: 0 (or x-component) is used."
msgstr ""

#, fuzzy
msgid "vec_type **dFdx** (vec_type p)"
msgstr "\\ vec_type **dFdx** ( vec_type p )"

msgid ""
"Derivative in ``x`` using local differencing. Internally, can use either "
"``dFdxCoarse`` or ``dFdxFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""

#, fuzzy
msgid "vec_type **dFdxCoarse** (vec_type p)"
msgstr "\\ vec_type **dFdx** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""

#, fuzzy
msgid "vec_type **dFdxFine** (vec_type p)"
msgstr "\\ vec_type **dFdx** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""

#, fuzzy
msgid "vec_type **dFdy** (vec_type p)"
msgstr "\\ vec_type **dFdy** ( vec_type p )"

msgid ""
"Derivative in ``y`` using local differencing. Internally, can use either "
"``dFdyCoarse`` or ``dFdyFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""

#, fuzzy
msgid "vec_type **dFdyCoarse** (vec_type p)"
msgstr "\\ vec_type **dFdy** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""

#, fuzzy
msgid "vec_type **dFdyFine** (vec_type p)"
msgstr "\\ vec_type **dFdy** ( vec_type p )"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""

#, fuzzy
msgid "vec_type **fwidth** (vec_type p)"
msgstr "\\ vec_type **fwidth** ( vec_type p )"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdx(p)) + abs(dFdy(p))``."
msgstr ""

#, fuzzy
msgid "vec_type **fwidthCoarse** (vec_type p)"
msgstr "\\ vec_type **fwidth** ( vec_type p )"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""

#, fuzzy
msgid "vec_type **fwidthFine** (vec_type p)"
msgstr "\\ vec_type **fwidth** ( vec_type p )"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxFine(p)) + abs(dFdyFine(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""

msgid "uint **packHalf2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackHalf2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers into 16-bit and pack them into a "
"32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packUnorm2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackUnorm2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers (clamped within 0..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packSnorm2x16** (vec2 v)"
msgstr ""

msgid "vec2 **unpackSnorm2x16** (uint v)"
msgstr ""

msgid ""
"Convert two 32-bit floating-point numbers (clamped within -1..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packUnorm4x8** (vec4 v)"
msgstr ""

msgid "vec4 **unpackUnorm4x8** (uint v)"
msgstr ""

msgid ""
"Convert four 32-bit floating-point numbers (clamped within 0..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

msgid "uint **packSnorm4x8** (vec4 v)"
msgstr ""

msgid "vec4 **unpackSnorm4x8** (uint v)"
msgstr ""

msgid ""
"Convert four 32-bit floating-point numbers (clamped within -1..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""

#, fuzzy
msgid "ivec_type **bitfieldExtract** (ivec_type value, int offset, int bits)"
msgstr "\\ vec_type **step** ( vec_type a, vec_type b )"

#, fuzzy
msgid "uvec_type **bitfieldExtract** (uvec_type value, int offset, int bits)"
msgstr "\\ vec_type **step** ( vec_type a, vec_type b )"

msgid "Extracts a range of bits from an integer."
msgstr ""

#, fuzzy
msgid ""
"ivec_type **bitfieldInsert** (ivec_type base, ivec_type insert, int offset, "
"int bits)"
msgstr "\\ vec_type **mix** ( vec_type a, vec_type b, float c )"

#, fuzzy
msgid ""
"uvec_type **bitfieldInsert** (uvec_type base, uvec_type insert, int offset, "
"int bits)"
msgstr "\\ vec_type **mix** ( vec_type a, vec_type b, float c )"

msgid "Insert a range of bits into an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **bitfieldReverse** (ivec_type value)"
msgstr "\\ ivec_type **abs** ( ivec_type x )"

#, fuzzy
msgid "uvec_type **bitfieldReverse** (uvec_type value)"
msgstr "\\ vec_type **inversesqrt** ( vec_type x )"

msgid "Reverse the order of bits in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **bitCount** (ivec_type value)"
msgstr "\\ ivec_type **sign** ( ivec_type x )"

#, fuzzy
msgid "uvec_type **bitCount** (uvec_type value)"
msgstr "\\ vec_type **round** ( vec_type x )"

msgid "Counts the number of 1 bits in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **findLSB** (ivec_type value)"
msgstr "\\ ivec_type **sign** ( ivec_type x )"

#, fuzzy
msgid "uvec_type **findLSB** (uvec_type value)"
msgstr "\\ vec_type **sin** ( vec_type x )"

msgid "Find the index of the least significant bit set to 1 in an integer."
msgstr ""

#, fuzzy
msgid "ivec_type **findMSB** (ivec_type value)"
msgstr "\\ ivec_type **sign** ( ivec_type x )"

#, fuzzy
msgid "uvec_type **findMSB** (uvec_type value)"
msgstr "\\ vec_type **sin** ( vec_type x )"

msgid "Find the index of the most significant bit set to 1 in an integer."
msgstr ""

#, fuzzy
msgid ""
"void **imulExtended** (ivec_type x, ivec_type y, out ivec_type msb, out "
"ivec_type lsb)"
msgstr "\\ vec_type **mix** ( vec_type a, vec_type b, vec_type c )"

#, fuzzy
msgid ""
"void **umulExtended** (uvec_type x, uvec_type y, out uvec_type msb, out "
"uvec_type lsb)"
msgstr "\\ vec_type **mix** ( vec_type a, vec_type b, vec_type c )"

msgid ""
"Multiplies two 32-bit numbers and produce a 64-bit result. ``x`` - the first "
"number. ``y`` - the second number. ``msb`` - will contain the most "
"significant bits. ``lsb`` - will contain the least significant bits."
msgstr ""

#, fuzzy
msgid "uvec_type **uaddCarry** (uvec_type x, uvec_type y, out uvec_type carry)"
msgstr "\\ vec_type **mix** ( vec_type a, vec_type b, vec_type c )"

msgid "Adds two unsigned integers and generates carry."
msgstr ""

#, fuzzy
msgid ""
"uvec_type **usubBorrow** (uvec_type x, uvec_type y, out uvec_type borrow)"
msgstr "\\ vec_type **smoothstep** ( vec_type a, vec_type b, vec_type c )"

msgid "Subtracts two unsigned integers and generates borrow."
msgstr ""

#, fuzzy
msgid "vec_type **ldexp** (vec_type x, out ivec_type exp)"
msgstr "\\ vec_type **modf** ( vec_type x, out vec_type i )"

msgid "Assemble a floating-point number from a value and exponent."
msgstr ""

msgid ""
"If this product is too large to be represented in the floating-point type "
"the result is undefined."
msgstr ""

#, fuzzy
msgid "vec_type **frexp** (vec_type x, out ivec_type exp)"
msgstr "\\ vec_type **modf** ( vec_type x, out vec_type i )"

msgid ""
"Splits a floating-point number(``x``) into significand (in the range of "
"[0.5, 1.0]) and an integral exponent."
msgstr ""

msgid ""
"For ``x`` equals zero the significand and exponent are both zero. For ``x`` "
"of infinity or NaN, the results are undefined."
msgstr ""

msgid "Translation status"
msgstr "翻訳ステータス"
