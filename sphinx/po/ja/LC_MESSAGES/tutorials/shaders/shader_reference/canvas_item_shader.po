# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CanvasItem shaders"
msgstr "CanvasItemシェーダー"

msgid ""
"CanvasItem shaders are used to draw all 2D elements in Godot. These include "
"all nodes that inherit from CanvasItems, and all GUI elements."
msgstr ""
"CanvasItemシェーダーは、Godotですべての2D要素を描画するために使用されます。こ"
"れらには、CanvasItemsから継承するすべてのノード、およびすべてのGUI要素が含ま"
"れます。"

msgid ""
"CanvasItem shaders contain less built-in variables and functionality than "
"Spatial shaders, but they maintain the same basic structure with vertex, "
"fragment, and light processor functions."
msgstr ""
"CanvasItemシェーダーには、Spatialシェーダーよりも少ない組み込み変数と関数が含"
"まれていますが、頂点、フラグメント、およびライトプロセッサー関数と同じ基本構"
"造を維持しています。"

msgid "Render modes"
msgstr "レンダリングモード"

msgid "Render mode"
msgstr "レンダリングモード"

msgid "Description"
msgstr "説明"

msgid "**blend_mix**"
msgstr "\\ **blend_mix**"

msgid "Mix blend mode (alpha is transparency), default."
msgstr "ミックスブレンドモード(アルファは透明度)、デフォルト。"

msgid "**blend_add**"
msgstr "\\ **blend_add**"

msgid "Additive blend mode."
msgstr "加算ブレンドモード。"

msgid "**blend_sub**"
msgstr "\\ **blend_sub**"

msgid "Subtractive blend mode."
msgstr "減算ブレンドモード。"

msgid "**blend_mul**"
msgstr "\\ **blend_mul**"

msgid "Multiplicative blend mode."
msgstr "乗法ブレンドモード。"

msgid "**blend_premul_alpha**"
msgstr "\\ **blend_premul_alpha**"

msgid "Pre-multiplied alpha blend mode."
msgstr "事前乗算されたアルファブレンドモード。"

msgid "**blend_disabled**"
msgstr "\\ **blend_disabled**"

msgid "Disable blending, values (including alpha) are written as-is."
msgstr "ブレンドを無効にすると、値(アルファを含む)がそのまま書き込まれます。"

msgid "**unshaded**"
msgstr "\\ **unshaded**"

msgid "Result is just albedo. No lighting/shading happens in material."
msgstr ""
"**ALBEDO** をそのまま出力します。マテリアルではライティング/シェーディングを"
"行いません。"

msgid "**light_only**"
msgstr "\\ **light_only**"

msgid "Only draw on light pass."
msgstr "ライトパスでのみ描画します。"

msgid "**skip_vertex_transform**"
msgstr "\\ **skip_vertex_transform**"

msgid "VERTEX needs to be transformed manually in vertex function."
msgstr "VERTEX は頂点関数で手動で変換する必要があります。"

msgid "**world_vertex_coords**"
msgstr "\\ **world_vertex_coords**"

msgid "VERTEX is modified in world coordinates instead of local."
msgstr "VERTEX はローカル座標ではなくワールド座標で変更されます。"

msgid "Built-ins"
msgstr "ビルトイン"

msgid ""
"Values marked as \"in\" are read-only. Values marked as \"out\" are for "
"optional writing and will not necessarily contain sensible values. Values "
"marked as \"inout\" provide a sensible default value, and can optionally be "
"written to. Samplers are not subjects of writing and they are not marked."
msgstr ""
"\"in\"としてマークされた変数は読み取り専用です。\"out\"とマークされた変数はオ"
"プションの書き込み用であり、必ずしも適切な値を含むとは限りません。\"inout\"と"
"マークされた変数は、適切なデフォルト値を提供し、オプションで書き込むことがで"
"きます。サンプラーは書込みの対象ではなく、マークされていません。"

msgid "Global built-ins"
msgstr "グローバルビルトイン"

msgid "Global built-ins are available everywhere, including custom functions."
msgstr "グローバルビルトインは、カスタム関数を含め、どこでも使用できます。"

msgid "Built-in"
msgstr "ビルトイン"

msgid "in float **TIME**"
msgstr "\\ in float **TIME**"

msgid ""
"Global time since the engine has started, in seconds (always positive). It's "
"subject to the rollover setting (which is 3,600 seconds by default). It's "
"not affected by :ref:`time_scale<class_Engine_property_time_scale>` or "
"pausing, but you can define a global shader uniform to add a \"scaled\" "
"``TIME`` variable if desired."
msgstr ""
"エンジンが起動してからの秒単位のグローバル時間 (常に正の値)。ロールオーバー設"
"定 (デフォルトでは3600秒) の影響を受けます。 :ref:"
"`time_scale<class_Engine_property_time_scale>` や一時停止の影響を受けません"
"が、必要に応じてグローバルシェーダーUniformを定義して、スケーリングされた "
"``TIME`` 変数を追加できます。"

msgid "in float **PI**"
msgstr "\\ in float **PI**"

msgid ""
"A ``PI`` constant (``3.141592``). A ration of circle's circumference to its "
"diameter and amount of radians in half turn."
msgstr ""
"定数 ``PI`` は円周率 (``3.141592``)。円の円周と直径の比率と、半回転のラジアン"
"量です。"

msgid "in float **TAU**"
msgstr "\\ in float **TAU**"

msgid ""
"A ``TAU`` constant (``6.283185``). An equivalent of ``PI * 2`` and amount of "
"radians in full turn."
msgstr ""
"定数 `TAU`` は円周率の2倍 (``6.283185``)。 ``PI * 2`` と、1回転のラジアン量に"
"相当します。"

msgid "in float **E**"
msgstr "\\ in float **E**"

#, fuzzy
msgid ""
"An ``E`` constant (``2.718281``). Euler's number and a base of the natural "
"logarithm."
msgstr "定数 ``E`` は (``2.718281``)。オイラー数と自然対数の底。"

msgid "Vertex built-ins"
msgstr "頂点プロセッサーのビルトイン"

msgid ""
"Vertex data (``VERTEX``) is presented in local space (pixel coordinates, "
"relative to the Node2D's origin). If not written to, these values will not "
"be modified and be passed through as they came."
msgstr ""
"頂点データ (``VERTEX``) はローカル空間 (Node2D の原点を基準としたピクセル座"
"標) に表示されます。書き込まれない場合、これらの値は変更されずそのまま渡され"
"ます。"

msgid ""
"The user can disable the built-in model to world transform (world to screen "
"and projection will still happen later) and do it manually with the "
"following code:"
msgstr ""
"ユーザーはモデルのワールド変換を無効にし (ワールドからスクリーンへの変換と投"
"影は後で行われます)、次のコードを使用して手動で行うことができます:"

msgid ""
"Other built-ins, such as UV and COLOR, are also passed through to the "
"fragment function if not modified."
msgstr ""
"UVやCOLORなどの他のビルトインも、変更されていない場合はフラグメント関数に渡さ"
"れます。"

msgid ""
"For instancing, the INSTANCE_CUSTOM variable contains the instance custom "
"data. When using particles, this information is usually:"
msgstr ""
"インスタンス化の場合、INSTANCE_CUSTOM変数にはインスタンスのカスタムデータが含"
"まれます。パーティクルを使用する場合、この情報は通常次のとおりです:"

msgid "**x**: Rotation angle in radians."
msgstr "**x**: ラジアン単位の回転角度。"

msgid "**y**: Phase during lifetime (0 to 1)."
msgstr "**y**: ライフタイム中のフェーズ(0〜1)。"

msgid "**z**: Animation frame."
msgstr "**z**: アニメーションフレーム。"

msgid "in mat4 **MODEL_MATRIX**"
msgstr "\\ in mat4 **MODEL_MATRIX**"

msgid ""
"Local space to world space transform. World space is the coordinates you "
"normally use in the editor."
msgstr ""
"ローカル空間からワールド空間への変換。ワールド空間はエディタで通常使用される"
"座標です。"

msgid "in mat4 **CANVAS_MATRIX**"
msgstr "\\ in mat4 **CANVAS_MATRIX**"

msgid ""
"World space to canvas space transform. In canvas space the origin is the "
"upper-left corner of the screen and coordinates ranging from (0, 0) to "
"viewport size."
msgstr ""
"ワールド空間からキャンバス空間への変換。キャンバス空間では原点は画面の左上隅"
"であり、座標の範囲は原点(0, 0)からビューポートのサイズまでです。"

msgid "in mat4 **SCREEN_MATRIX**"
msgstr "\\ in mat4 **SCREEN_MATRIX**"

msgid ""
"Canvas space to clip space. In clip space coordinates ranging from (-1, -1) "
"to (1, 1)."
msgstr ""
"キャンバス空間からクリップ空間への変換。クリップ空間内の座標は (-1, -1) から "
"(1, 1) までの範囲です。"

msgid "in int  **INSTANCE_ID**"
msgstr "\\ in int **INSTANCE_ID**"

msgid "Instance ID for instancing."
msgstr "インスタンス化のためのインスタンスID。"

msgid "in vec4 **INSTANCE_CUSTOM**"
msgstr "\\ in vec4 **INSTANCE_CUSTOM**"

msgid "Instance custom data."
msgstr "インスタンスのカスタムデータ。"

msgid "in bool **AT_LIGHT_PASS**"
msgstr "\\ in bool **AT_LIGHT_PASS**"

msgid "Always ``false``."
msgstr "常に ``false``."

msgid "in vec2 **TEXTURE_PIXEL_SIZE**"
msgstr "\\ in vec2 **TEXTURE_PIXEL_SIZE**"

msgid ""
"Normalized pixel size of default 2D texture. For a Sprite2D with a texture "
"of size 64x32px, **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"
msgstr ""
"デフォルトの2Dテクスチャの正規化されたピクセルサイズ。サイズが64x32pxのテクス"
"チャを持つSprite2Dの場合、\\ **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"

msgid "inout vec2 **VERTEX**"
msgstr "\\ inout vec2 **VERTEX**"

msgid "Vertex, in local space."
msgstr "ローカル空間の頂点。"

msgid "in int **VERTEX_ID**"
msgstr "\\ in int **VERTEX_ID**"

msgid "The index of the current vertex in the vertex buffer."
msgstr "頂点バッファー内の現在の頂点インデックス。"

msgid "inout vec2 **UV**"
msgstr "\\ inout vec2 **UV**"

msgid "Normalized texture coordinates. Range from 0 to 1."
msgstr "正規化されたテクスチャ座標。範囲は 0 から 1 です。"

msgid "inout vec4 **COLOR**"
msgstr "\\ inout vec4 **COLOR**"

msgid "Color from vertex primitive."
msgstr "頂点プリミティブの色。"

msgid "inout float **POINT_SIZE**"
msgstr "\\ inout float **POINT_SIZE**"

msgid "Point size for point drawing."
msgstr "ポイント描画のポイントサイズ。"

msgid "in vec4 **CUSTOM0**"
msgstr "\\ in vec4 **CUSTOM0**"

msgid "in vec4 **CUSTOM1**"
msgstr "\\ in vec4 **CUSTOM1**"

msgid "Fragment built-ins"
msgstr "フラグメントプロセッサーのビルトイン"

msgid ""
"Certain Nodes (for example, :ref:`Sprite2Ds <class_Sprite2D>`) display a "
"texture by default. However, when a custom fragment function is attached to "
"these nodes, the texture lookup needs to be done manually. Godot provides "
"the texture color in the ``COLOR`` built-in variable multiplied by the "
"node's color. To read the texture color by itself, you can use:"
msgstr ""
"特定のノード(たとえば、\\ :ref:`Sprite2Ds <class_Sprite>`)は、デフォルトでテ"
"クスチャを表示します。ただしカスタムフラグメント関数がこれらのノードにアタッ"
"チされている場合、テクスチャルックアップは手動で行う必要があります。 Godotは"
"ビルトインの ``COLOR`` 変数にテクスチャの色を提供しません。そのようなノードの"
"テクスチャカラーを読み取るには、次を使用します:"

msgid ""
"Similarly, if a normal map is used in the :ref:`CanvasTexture "
"<class_CanvasTexture>`, Godot uses it by default and assigns its value to "
"the built-in ``NORMAL`` variable. If you are using a normal map meant for "
"use in 3D, it will appear inverted. In order to use it in your shader, you "
"must assign it to the ``NORMALMAP`` property. Godot will handle converting "
"it for use in 2D and overwriting ``NORMAL``."
msgstr ""
"同様に、法線マップが :ref:`CanvasTexture <class_CanvasTexture>` で使用されて"
"いる場合、Godotはデフォルトでそれを使用し、その値を組み込みの ``NORMAL`` 変数"
"に割り当てます。3Dで使用するための法線マップを使用している場合は、反転して表"
"示されます。シェーダーで使用するには、\\ ``NORMALMAP`` プロパティに割り当てる"
"必要があります。Godotは、2Dで使用するために変換し、\\ ``NORAMAL`` を上書きし"
"ます。"

msgid "in vec4 **FRAGCOORD**"
msgstr "\\ in vec4 **FRAGCOORD**"

#, fuzzy
msgid ""
"Coordinate of pixel center. In screen space. ``xy`` specifies position in "
"window. Origin is upper-left."
msgstr ""
"スクリーン空間内のピクセルの中心の座標。 ``xy`` はウィンドウ内の位置を指定し"
"ます。原点は左下です。"

msgid "in vec2 **SCREEN_PIXEL_SIZE**"
msgstr "\\ in vec2 **SCREEN_PIXEL_SIZE**"

msgid "Size of individual pixels. Equal to inverse of resolution."
msgstr "個々のピクセルのサイズ。解像度の逆数に等しい。"

msgid "in vec2 **POINT_COORD**"
msgstr "\\ in vec2 **POINT_COORD**"

msgid "Coordinate for drawing points."
msgstr "描画ポイントの座標。"

msgid "sampler2D **TEXTURE**"
msgstr "\\ sampler2D **TEXTURE**"

msgid "Default 2D texture."
msgstr "デフォルトの2Dテクスチャ。"

msgid "sampler2D **SPECULAR_SHININESS_TEXTURE**"
msgstr "\\ sampler2D **SPECULAR_SHININESS_TEXTURE**"

msgid "Specular shininess texture of this object."
msgstr "このオブジェクトの鏡面光沢テクスチャ。"

msgid "in vec4 **SPECULAR_SHININESS**"
msgstr "\\ in vec4 **SPECULAR_SHININESS**"

msgid "Specular shininess color, as sampled from the texture."
msgstr "テクスチャからサンプリングされた鏡面光沢色。"

msgid "in vec2 **UV**"
msgstr "\\ in vec2 **UV**"

msgid "UV from vertex function."
msgstr "頂点関数からのUV。"

msgid "in vec2 **SCREEN_UV**"
msgstr "\\ in vec2 **SCREEN_UV**"

msgid "Screen UV coordinate for current pixel."
msgstr "現在のピクセルのスクリーンUV座標。"

msgid "sampler2D **SCREEN_TEXTURE**"
msgstr "\\ sampler2D **SCREEN_TEXTURE**"

msgid ""
"Removed in Godot 4. Use a ``sampler2D`` with ``hint_screen_texture`` instead."
msgstr ""

msgid "inout vec3 **NORMAL**"
msgstr "\\ inout vec3 **NORMAL**"

msgid "Normal read from **NORMAL_TEXTURE**. Writable."
msgstr "**NORMAL_TEXTURE ** からの法線の読み込み。書き込み可能。"

msgid "sampler2D **NORMAL_TEXTURE**"
msgstr "\\ sampler2D **NORMAL_TEXTURE**"

msgid "Default 2D normal texture."
msgstr "デフォルトの2D法線テクスチャ。"

#, fuzzy
msgid "out vec3 **NORMAL_MAP**"
msgstr "\\ out vec3 **NORMALMAP**"

msgid ""
"Configures normal maps meant for 3D for use in 2D. If used, overrides "
"**NORMAL**."
msgstr ""
"3D用の法線マップを2Dで使用できるように構成します。使用すると、**NORMAL** が"
"オーバーライドされます。"

#, fuzzy
msgid "out float **NORMAL_MAP_DEPTH**"
msgstr "\\ out float **NORMALMAP_DEPTH**"

msgid "Normalmap depth for scaling."
msgstr "スケーリングのための法線マップの深さ。"

msgid "Pixel position in screen space."
msgstr "スクリーン空間内のピクセル位置。"

msgid "inout vec2 **SHADOW_VERTEX**"
msgstr "\\ inout vec2 **SHADOW_VERTEX**"

msgid "Same as ``VERTEX`` but can be written to alter shadows."
msgstr "``VERTEX`` と同じですが、影を変更するために書き込むことができます。"

msgid "inout vec3 **LIGHT_VERTEX**"
msgstr "\\ inout vec3 **LIGHT_VERTEX**"

msgid ""
"Same as ``VERTEX`` but can be written to alter lighting. Z component "
"represents height."
msgstr ""
"``VERTEX`` と同じですが、照明を変更するために書き込むことができます。 Z成分は"
"高さを表します。"

msgid ""
"Color from vertex function multiplied by the **TEXTURE** color. Also output "
"color value."
msgstr ""
"頂点関数の色に **TEXTURE** の色が乗算されたもの。出力の色として扱われます。"

msgid "Light built-ins"
msgstr "ライトプロセッサーのビルトイン"

msgid ""
"Light processor functions work differently in Godot 4.x than they did in "
"Godot 3.x. In Godot 4.x all lighting is done during the regular draw pass. "
"In other words, Godot no longer draws the object again for each light."
msgstr ""
"ライトプロセッサー関数は、Godot 4.x と Godot 3.x では動作が異なります。 "
"Godot 4.x では、すべてのライティングは通常の描画パス中に行われます。言い換え"
"れば Godot はライトごとにオブジェクトを再描画しなくなりました。"

msgid ""
"Use render_mode ``unshaded`` if you do not want the light processor function "
"to run. Use render_mode ``light_only`` if you only want to see the impact of "
"lighting on an object; this can be useful when you only want the object "
"visible where it is covered by light."
msgstr ""
"ライトプロセッサー関数を実行したくない場合は ``render_mode unshaded;`` を使用"
"してください。オブジェクトに対する照明の影響だけを確認したい場合は "
"``render_mode light_only;`` を使用します。これはオブジェクトが光で覆われてい"
"る場所のみを表示したい場合に便利です。"

msgid ""
"If you define a light function it will replace the built in light function, "
"even if your light function is empty."
msgstr ""
"ライト関数を定義すると、ライト関数が空であっても組み込みのライト関数が置き換"
"えられます。"

msgid ""
"Below is an example of a light shader that takes a CanvasItem's normal map "
"into account:"
msgstr "以下はCanvasItemの法線マップを考慮したライト シェーダーの例です。"

msgid ""
"Coordinate of pixel center. In screen space. ``xy`` specifies position in "
"window. Origin is lower-left."
msgstr ""
"スクリーン空間内のピクセルの中心の座標。 ``xy`` はウィンドウ内の位置を指定し"
"ます。原点は左下です。"

msgid "in vec3 **NORMAL**"
msgstr "\\ in vec3 **NORMAL**"

msgid "Input Normal."
msgstr "入力された法線。"

msgid "in vec4 **COLOR**"
msgstr "\\ in vec4 **COLOR**"

msgid "Input Color. This is the output of the fragment function."
msgstr "入力された色。これはフラグメント関数の出力です。"

msgid "UV from vertex function, equivalent to the UV in the fragment function."
msgstr "頂点関数からのUV。フラグメント関数のUVと同等です。"

msgid "Current texture in use for CanvasItem."
msgstr "CanvasItemに使用されている現在のテクスチャ。"

msgid ""
"Normalized pixel size of **TEXTURE**. For a Sprite2D with a **TEXTURE** of "
"size 64x32px, **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"
msgstr ""
"**TEXTURE** の正規化されたピクセルサイズ。64x32px の **TEXTURE** を持つ "
"Sprite2D の場合 **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"

msgid "UV for Point Sprite."
msgstr "ポイントスプライトのUV。"

msgid "in vec4 **LIGHT_COLOR**"
msgstr "\\ in vec4 **LIGHT_COLOR**"

msgid "Color of Light multiplied by Light's texture."
msgstr "ライトの色とライトのテクスチャを掛け合わせたもの。"

msgid "in float **LIGHT_ENERGY**"
msgstr "\\ in float **LIGHT_ENERGY**"

msgid "Energy multiplier of Light."
msgstr "ライトのエネルギー倍率。"

msgid "in vec3 **LIGHT_POSITION**"
msgstr "\\ in vec3 **LIGHT_POSITION**"

msgid ""
"Position of Light in screen space. If using a ``DirectionalLight2D`` this is "
"always ``vec3(0,0,0)``."
msgstr ""
"スクリーン空間内のライトの位置。 ``DirectionalLight2D`` を使用する場合は常に "
"``vec3(0,0,0)`` になります。"

msgid "in vec3 **LIGHT_DIRECTION**"
msgstr "\\ in vec3 **LIGHT_DIRECTION**"

msgid "Direction of Light in screen space."
msgstr "スクリーン空間におけるライトの方向。"

msgid "in bool **LIGHT_IS_DIRECTIONAL**"
msgstr "\\ in bool **LIGHT_IS_DIRECTIONAL**"

msgid "``true`` if this pass is a ``DirectionalLight2D``."
msgstr "``DirectionalLight2D`` のパスの場合は ``true`` 。"

msgid "in vec3 **LIGHT_VERTEX**"
msgstr "\\ in vec3 **LIGHT_VERTEX**"

msgid "Pixel position, in screen space as modified in the fragment function."
msgstr "フラグメント関数で変更されたスクリーン空間内のピクセル位置。"

msgid "inout vec4 **LIGHT**"
msgstr "\\ inout vec4 **LIGHT**"

msgid "Output color for this Light."
msgstr "このライトの出力色。"

msgid "Specular shininess, as set in the object's texture."
msgstr "オブジェクトのテクスチャで設定される鏡面光沢率。"

msgid "out vec4 **SHADOW_MODULATE**"
msgstr "\\ out vec4 **SHADOW_MODULATE**"

msgid "Multiply shadows cast at this point by this color."
msgstr "投影される影に掛ける色。"

msgid "SDF functions"
msgstr "SDF関数"

msgid ""
"There are a few additional functions implemented to sample an automatically "
"generated Signed Distance Field texture. These functions available for "
"Fragment and Light functions of CanvasItem shaders."
msgstr ""
"自動生成された、Signed Distance Field テクスチャをサンプリングするために実装"
"された追加関数がいくつかあります。これらの関数はCanvasItemシェーダのフラグメ"
"ント関数とライト関数で使用できます。"

msgid ""
"The signed distance field is generated from :ref:`class_LightOccluder2D` "
"nodes present in the scene with the **SDF Collision** property enabled "
"(which is the default). See the :ref:`2D lights and shadows "
"<doc_2d_lights_and_shadows_setting_up_shadows>` documentation for more "
"information."
msgstr ""
"Signed Distance Field は、**SDF Collision** プロパティが有効(デフォルト設定) "
"になっているシーン内に存在する :ref:`class_LightOccluder2D` ノードから生成さ"
"れます。詳細については、:ref:`2Dライトとシャドウ "
"<doc_2d_lights_and_shadows_setting_up_shadows>` ドキュメントを参照してくださ"
"い。"

msgid "Function"
msgstr "関数"

msgid "float **texture_sdf** (vec2 sdf_pos)"
msgstr "\\ float **texture_sdf** (vec2 sdf_pos)"

msgid "Performs an SDF texture lookup."
msgstr "SDFテクスチャのルックアップを実行します。"

msgid "vec2 **texture_sdf_normal** (vec2 sdf_pos)"
msgstr "\\ vec2 **texture_sdf_normal** (vec2 sdf_pos)"

msgid "Calculates a normal from the SDF texture."
msgstr "SDFテクスチャから法線を計算します。"

msgid "vec2 **sdf_to_screen_uv** (vec2 sdf_pos)"
msgstr "\\ vec2 **sdf_to_screen_uv** (vec2 sdf_pos)"

#, fuzzy
msgid "Converts an SDF to screen UV."
msgstr "SDFをスクリーンUVに変換します。"

msgid "vec2 **screen_uv_to_sdf** (vec2 uv)"
msgstr "\\ vec2 **screen_uv_to_sdf** (vec2 uv)"

#, fuzzy
msgid "Converts screen UV to an SDF."
msgstr "スクリーンUV をSDFに変換します。"

msgid "Translation status"
msgstr "翻訳ステータス"
