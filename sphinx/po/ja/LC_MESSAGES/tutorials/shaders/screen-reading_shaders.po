#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "スクリーン読み取りシェーダー"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"多くの場合、書き込み先と同じ画面から読み取るシェーダーを作成することが望まれ"
"ます。 OpenGLやDirectXなどの3D APIは、内部ハードウェアの制限により、これを非"
"常に困難にします。 GPUは非常に並列であるため、読み取りと書き込みはあらゆる種"
"類のキャッシュと一貫性の問題を引き起こします。その結果、最新のハードウェアで"
"さえこれを適切にサポートしていません。"

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"回避策は、画面または画面の一部をバックバッファにコピーし、描画中にそこから読"
"み取ることです。 Godotには、このプロセスを簡単にするツールがいくつか用意され"
"ています。"

msgid "Screen texture"
msgstr "スクリーンテクスチャ"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_lang` には、すでにレンダリングされた画面のコンテンツ"
"にアクセスするための特別なテクスチャがあります。これは ``sampler2D`` の"
"Uniformを宣言するときに ``hint_screen_texture`` ヒントを指定することで使用さ"
"れます。またビルトイン変数 ``SCREEN_UV`` を使用して、現在のフラグメントの画面"
"を基準としたUVを取得できます。次の2Dフラグメントシェーダーは、結果として背後"
"にあるもののみを表示するため、実質見えないオブジェクトになります:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"ここでは ``textureLod`` を使用して、一番下のミップマップからのみ読み取ってい"
"ます。代わりにぼやけたテクスチャから読み取りたい場合は、 ``textureLod`` の3番"
"目の引数を増やし、ヒント ``filter_nearest`` を ``filter_nearest_mipmap`` (ま"
"たはミップマップが有効になっている他のフィルタ) に変更します。ミップマップ"
"フィルターを使用する場合、Godotはぼやけたテクスチャを自動的に計算します。"

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with an LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""
"フィルタモードの名前に ``mipmap`` を含んでいない場合、 ``textureLod`` のLODパ"
"ラメータに ``0.0`` より大きい値を指定しても ``0.0`` と同じ結果になります。"

msgid "Screen texture example"
msgstr "スクリーンテクスチャの使用例"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"スクリーンテクスチャはさまざまな用途に使用できます。 *Screen Space Shaders* "
"には特別なデモがあり、ダウンロードして見て学ぶことができます。1つの例は、明る"
"さ、コントラスト、彩度を調整するシンプルなシェーダーです:"

msgid "Behind the scenes"
msgstr "舞台裏"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"これは魔法のように思えますが、そうではありません。2Dでは描画しようとしている"
"ノード内で ``hint_screen_texture`` が最初に見つかると、Godot はバックバッファ"
"にフルスクリーンコピーを実行します。シェーダーでこれを使用する後続のノードで"
"は、画面がコピーされません。これは非効率的になるためです。3Dでは画面は不透明"
"なジオメトリパスの後、透明なジオメトリパスの前にコピーされるため、透明なオブ"
"ジェクトはスクリーンテクスチャにキャプチャされません。"

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"その結果、2Dで ``hint_screen_texture`` を使用するシェーダーが重なった場合、2"
"番目のシェーダーは最初のシェーダーの結果を使用せず、予期しないビジュアルにな"
"ります:"

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"上の画像では、2番目の球体 (右上) は下の最初の球体と同じソースをスクリーンテク"
"スチャに使用しているため、最初の球体は「消える」か、表示されません。"

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"2Dでは、これは :ref:`BackBufferCopy <class_BackBufferCopy>` ノードを介して修"
"正できます。これは両方の球の間でインスタンス化できます。 BackBufferCopyは、画"
"面領域または画面全体を指定することで機能します:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "バックバッファを正しくコピーすると、2つの球体が正しくブレンドされます:"

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""
"3Dでは ``hint_screen_texture`` を使用するマテリアルはそれ自体が透明であるとみ"
"なされ、他のマテリアルの結果として得られるスクリーンテクスチャには表示されま"
"せん。 ``hint_screen_texture`` を持つマテリアルを使用するシーンをインスタンス"
"化する場合は、BackBufferCopyノードを使用する必要があります。"

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"3Dではスクリーンテクスチャが1回しかキャプチャされないため、この特定の問題を解"
"決する柔軟性が低くなります。ただしスクリーンテクスチャを3Dで使用する場合は、"
"透明なオブジェクトはキャプチャされない、またスクリーンテクスチャを使用するオ"
"ブジェクトの前面にある不透明なオブジェクトもキャプチャされる可能性がありま"
"す。"

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"オブジェクトと同じ位置にカメラを備えた :ref:`Viewport <class_Viewport>` を作"
"成し、 :ref:`Viewport の <class_Viewport>` テクスチャの代わりに :ref:"
"`Viewport <class_Viewport>` テクスチャを使用することで、スクリーンテクスチャ"
"の代わりにバックバッファロジックを3Dで再現できます。"

msgid "Back-buffer logic"
msgstr "バックバッファロジック"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"分かりやすくするために、Godotの2Dでバックバッファのコピーロジックがどのように"
"動作するかを次に示します。"

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"ノードが ``hint_screen_texture`` を使用する場合、そのノードを描画する前に画面"
"全体がバックバッファにコピーされます。これは初回のみ発生します。後続のノード"
"はこれをトリガーしません。"

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"上記の状況が発生する前に BackBufferCopy ノードが処理された場合 "
"(``hint_screen_texture`` が使用されなかった場合でも)、上記の点で説明した動作"
"は発生しません。言い換えれば、画面全体の自動コピーは、ノードで "
"``hint_screen_texture`` が初めて使用され、ツリー順序で以前に BackBufferCopy "
"ノードが見つからなかった (無効になっていない) 場合にのみ発生します。"

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopyは、画面全体または一部領域をコピーできます。 (画面全体ではなく)"
"領域のみに設定され、シェーダーがコピーされた領域にないピクセルを使用する場"
"合、その読み取りの結果は未定義になります (前のフレームからのガベージである可"
"能性が高くなります)。つまりBackBufferCopyを使用して画面の領域をコピーバック"
"し、別の領域からスクリーンテクスチャを読み取ることができます。このような操作"
"は避けてください！"

msgid "Depth texture"
msgstr "深度テクスチャ"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"3Dシェーダーの場合、スクリーンの深度バッファにアクセスすることもできます。こ"
"のために ``hint_depth_texture`` ヒントが使用されます。このテクスチャは線形で"
"はありません。逆射影行列を使用して変換する必要があります。"

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "次のコードは、描画中のピクセルの下の3D位置を取得します:"

msgid "Normal-roughness texture"
msgstr "法線とラフネスのテクスチャ"

msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr ""
"法線とラフネスのテクスチャは、Forward+レンダリングでのみサポートされており、"
"モバイルまたはGL互換ではサポートされていません。"

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"法線ラフネステクスチャを使用して、深度プリパスでレンダリングされたオブジェク"
"トの法線とラフネス値を読み取ることができます。法線は ``.xyz`` チャネル (0～1"
"の範囲にマッピング) に保存され、ラフネス値は ``.w`` チャネルに保存されます。"

msgid "Redefining screen textures"
msgstr "スクリーンテクスチャの再定義"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"スクリーンテクスチャヒント (``hint_screen_texture`` 、 "
"``hint_depth_texture`` 、 ``hint_normal_roughness_texture``) は複数のUniform"
"で使用できます。たとえば異なる繰り返しフラグやフィルターフラグを使用してテク"
"スチャから複数回読み取りたい場合があります。"

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"次の例は、線形フィルタリングを使用してスクリーン空間の法線を読み取りますが、"
"最近傍フィルタリングを使用してスクリーン空間のラフネス値を読み取るシェーダー"
"を示しています。"
