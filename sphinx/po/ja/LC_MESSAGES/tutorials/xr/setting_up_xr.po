#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "XRのセットアップ"

msgid "Introduction to the XR system in Godot"
msgstr "Godot XRシステムの説明"

msgid ""
"While in Godot 3 most things worked out of the box, Godot 4 needs a little "
"more setup. This is mainly due to the more advanced nature of the Vulkan "
"renderer. There are many rendering features in Vulkan the XR system uses "
"that aren't enabled by default. They are very easy to turn on, simply open "
"up your project settings and tick the XR shaders tickbox in the XR section:"
msgstr ""
"Godot 3 ではほとんどの物がすぐに動きましたが、Godot 4 ではもう少しセットアッ"
"プが必要です。これは主にVulkan レンダラのより高度な性質のためです。Vulkanでは"
"XRシステムが使用する多くの機能がデフォルトで有効になっていません。それらはプ"
"ロジェクト設定を開いてXRセクションのXR shadersチェックボックスを切り替えるだ"
"けで簡単に有効化できます。"

msgid ""
"As Godot 4 is still in development, many post process effects have not yet "
"been updated to support stereoscopic rendering. Using these will have "
"adverse effects."
msgstr ""
"Godot 4 は開発途上のため、多くのポストプロセスエフェクトがまだ立体視レンダリ"
"ングをサポートしていません。それらを使っても思い通りの効果にはならないでしょ"
"う。"

msgid ""
"Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the "
"future XR desktop projects should use Forward+, and projects for stand-alone "
"headsets should use Mobile. However Compatibility is the recommended "
"renderer for now due to it having the best XR performance."
msgstr ""
"Godot 4 にはCompatibility, Mobile, Forward+ の3つのレンダラーオプションがあり"
"ます。将来的にはXRデスクトッププロジェクトではForward+、スタンドアロンヘッド"
"セットではMobile設定を使うべきとされます。しかし、現在のところはCompatibility"
"が最良のXRパフォーマンスを持ち、推奨されます。"

msgid "OpenXR"
msgstr "OpenXR"

msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXRは、標準化されたAPIを用いてXRアプリケーションに様々なXRプラットフォーム"
"を対応させられる新しい規格です。この規格はKhronosグループにより整備されたオー"
"プンな規格であり、そのためGodotの関心に非常によく一致しています。"

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. The required setting can be found in your project "
"settings:"
msgstr ""
"このことは、色々なものが正しくセットアップされるためにはGodotを起動したときに"
"OpenXRが有効化されている必要があることを意味します。必要な設定はプロジェクト"
"設定で行えます。"

msgid "Setting up the XR scene"
msgstr "XRシーンの設定"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have two :ref:"
"`XRController3D <class_xrcontroller3d>`, one for the left hand and one for "
"the right. Keep in mind that the camera and controller nodes should be "
"children of the origin node. Add these nodes to a new scene and rename the "
"controller nodes to ``LeftHand`` and ``RightHand``, your scene should look "
"something like this:"
msgstr ""
"すべてのXRアプリケーションは最低限 :ref:`XROrigin3D <class_xrorigin3d>`ノード"
"と :ref:`XRCamera3D <class_xrcamera3d>`ノードを1つずつ持つ必要があります。大"
"抵の場合は2つの :ref:`XRController3D <class_xrcontroller3d>`（右手と左手）も"
"使うでしょう。cameraとcontrollerノードはoriginノードの子にすることに注意して"
"ください。これらのノードをシーンに追加し、controllerノードの名前を"
"``LeftHand``と``RightHand``変更に変更しましょう。シーンはこのようになります："

msgid ""
"Next you need to configure the controllers, select the left hand and set it "
"up as follows:"
msgstr ""
"次にcontrollerを設定しなければなりません。左手を選択し次のように設定します："

msgid "And the right hand:"
msgstr "右手も同様に："

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"このとき全てのノードが床に置かれた状態になりますが、実行時には正しい位置に動"
"きます。開発の際には、カメラの ``y`` を ``1.7`` 、コントローラの座標を左右そ"
"れぞれ ``-0.5, 1.0, -0.5`` および ``0.5, 1.0, -0.5`` に設定しておくとよいで"
"しょう。"

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr ""
"次にルートノードにスクリプトを追加します。スクリプトに次のコードを追加します:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"このコードではOpenXRを使用することを想定していますが、もし他のインターフェー"
"スを使う場合は ``find_interface`` の引数を変更してください。"

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"上記のコードでv-syncをオフにしています。OpenXRを使用すると描画結果をHMDに送信"
"しますが、多くの場合で90Hz以上のフレームレートを要求されます。もし60Hzのモニ"
"ターを使っていてv-syncがオンになっていると、フレームレート上限が60fpsになって"
"しまいます。"

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "OpenXRなどのXRインターフェースは独自で同期して動作します。"

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set ``Engine."
"physics_ticks_per_second`` to a higher value."
msgstr ""
"また、デフォルトの物理エンジンも60Hzで動作しますが、不安定になる可能性がある"
"ことに注意します。 ``Engine.physics_ticks_per_second`` をより大きく設定してお"
"きましょう。"

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add a :ref:"
"`DirectionalLight3D <class_directionallight3d>` and a :ref:`WorldEnvironment "
"<class_worldenvironment>` node to your scene. You may wish to also add a "
"mesh instance as a child to each controller node just to temporarily "
"visualise them. Make sure you configure a sky in your world environment."
msgstr ""
"この時点でプロジェクトを実行すると、全て動作はしますが暗闇になるでしょう。そ"
"こで、最後に :ref:`DirectionalLight3D <class_directionallight3d>` ノードと :"
"ref:`WorldEnvironment <class_worldenvironment>` ノードをシーンに追加しましょ"
"う。controllerノードの子にメッシュインスタンスを追加して可視化するのもいいで"
"すね。world environment にはskyを設定しておきましょう。"

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr ""
"プロジェクトを実行すると、空間上で浮遊して周囲を見渡せるようになっていると思"
"います。"

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"従来のレベル切り替えも確かにXRアプリケーションで利用できるのですが、セット"
"アップを各レベルで繰り返すことになるため、多くの場合はセットアップを一度だけ"
"行い、サブシーンとしてレベルをロードするほうが簡単です。シーンを切り替えてXR"
"セットアップをそれぞれに複製する場合、 ``initialize`` を複数回呼んではいけま"
"せん。XRインターフェースによってはその影響が予測不可能になるからです。"

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr "残りの基本のチュートリアルでは単一シーンのゲームを作ってみましょう。"
