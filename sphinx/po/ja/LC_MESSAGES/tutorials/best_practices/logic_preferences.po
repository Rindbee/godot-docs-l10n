#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "ロジックの設定"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"問題Xにアプローチするときに、戦略をYにするかZするかについて悩んだことはありま"
"せんか？この記事では、これらのジレンマに関連するさまざまなトピックについて説"
"明します。"

msgid "Adding nodes and changing properties: which first?"
msgstr "ノードの追加とプロパティの変更はどちらが先？"

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""
"実行時にスクリプトからノードを初期化する場合、ノードの名前や位置などのプロパ"
"ティを変更する必要がある場合があります。よくあるジレンマは、いつそれらの値を"
"変更すべきか？"

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""
"シーンツリーに追加する前にノードの値を変更するのがベストプラクティスです。一"
"部のプロパティのセッターには、他の対応する値を更新するコードがあり、そのコー"
"ドは遅くなる可能性があります。ほとんどの場合、このコードはゲームのパフォーマ"
"ンスに影響を与えませんが、プロシージャル生成などの使用頻度の高いケースでは、"
"ゲームが遅くなる可能性があります。"

msgid "Loading vs. preloading"
msgstr "ロード(load) 対 プリロード(preload)"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"GDScript には、グローバル :ref:`preload <class_@GDScript_method_preload>` メ"
"ソッドが存在します。\"読み込み\" 処理を前もって行い、パフォーマンスに敏感な"
"コードの途中で、リソースの読み込が発生することを回避するために、できるだけ早"
"くリソースを読み込みます。"

msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias "
"for :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` "
"which is accessible to *all* scripting languages."
msgstr ""
"対応する :ref:`load <class_@GDScript_method_load>` メソッドは、load ステート"
"メントに到達したときにのみリソースをロードします。つまりリソースをその場で"
"ロードするため、リアルタイム性の高いプロセスの途中で行うと速度低下を引き起こ"
"す可能性があります。 ``load()`` 関数は、すべてのスクリプト言語からアクセスで"
"きる :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` のエ"
"イリアスでもあります。"

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"それでは、load と比較して preload が発生するのは正確にはいつですか？例を見て"
"みましょう:"

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"シーンのエクスポートされた初期化など、他の何かが値を置き換えることができる場"
"合、値をプリロードしても意味がありません。スクリプトを常に独自に作成する場"
"合、この点は重要な要素ではありません。"

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"別のクラスリソース (スクリプトまたはシーン) を「インポート」するだけの場合"
"は、プリロードされた定数を使用するのが最善の策となることがよくあります。ただ"
"し例外的なケースでは、これを行わない方がよい場合があります:"

msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``@export`` or a ``load()`` (and "
"perhaps not even initialized until later)."
msgstr ""
"「インポートされた」クラスが変更される可能性がある場合は、代わりにプロパティ"
"として ``@export`` または ``load()`` を使用して初期化する必要があります (場合"
"によっては、後から初期化されることもあります)。"

msgid "Large levels: static vs. dynamic"
msgstr "大きなレベル(ステージ): 静的レベル 対 動的レベル"

msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"答えは「パフォーマンスが必要な場合」です。この2つのオプションに関連するジレン"
"マは、昔からあるプログラミング上の選択の1つです。速度よりもメモリを最適化する"
"のか、それともその逆なのか？"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"素朴な答えは、すべてを一度にロードする静的レベルを使用することです。ただし、"
"プロジェクトによっては、大量のメモリを消費する可能性があります。ユーザーのRAM"
"を浪費すると、コンピュータが同時に実行しようとする他のすべてのプログラムが、"
"低速化または完全にクラッシュしてしまいます。"

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"何があっても、大きなシーンを小さなシーンに分割する必要があります(資産の再利用"
"性を高めるため)。開発者は、リソースとノードの作成/ロード、削除/アンロードをリ"
"アルタイムで管理するノードを設計できます。大規模で多様な環境や手続き的に生成"
"された要素を持つゲームは、多くの場合、メモリの無駄を避けるためにこれらの戦略"
"を実装します。"

msgid "As such, the best options would be..."
msgstr "そのため、最良のオプションは..."

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"実行時にシーンを入れ替えるさまざまな方法の例については、\\ :ref:`「手動でシー"
"ンを変更する」 <doc_change_scenes_manually>` ドキュメントを参照してください。"
