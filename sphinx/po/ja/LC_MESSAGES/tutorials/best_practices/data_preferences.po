#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Data preferences"
msgstr "データ設定"

msgid ""
"Ever wondered whether one should approach problem X with data structure Y or "
"Z? This article covers a variety of topics related to these dilemmas."
msgstr ""
"問題Xにアプローチするときに、データ構造をYにするかZするかについて悩んだことは"
"ありませんか？この記事では、これらのジレンマに関連するさまざまなトピックにつ"
"いて説明します。"

msgid ""
"This article makes references to \"[something]-time\" operations. This "
"terminology comes from algorithm analysis' `Big O Notation <https://rob-bell."
"net/2009/06/a-beginners-guide-to-big-o-notation/>`_."
msgstr ""
"この記事では、「何らかの-時間」操作への言及を行います。この用語はアルゴリズム"
"分析の `ビッグ・オー記法 <https://rob-bell.net/2009/06/a-beginners-guide-to-"
"big-o-notation/>`_ に由来します。"

msgid ""
"Long-story short, it describes the worst-case scenario of runtime length. In "
"laymen's terms:"
msgstr "手短に言えば、実行時間の最悪のシナリオを説明しています。素人の言葉で:"

msgid ""
"\"As the size of a problem domain increases, the runtime length of the "
"algorithm...\""
msgstr ""
"「問題領域のサイズが大きくなるにつれて、アルゴリズムの実行時間の長さが...」"

msgid "Constant-time, ``O(1)``: \"...does not increase.\""
msgstr "定数時間、\\ ``O(1)``: 「...は増加しません」"

msgid "Logarithmic-time, ``O(log n)``: \"...increases at a slow rate.\""
msgstr "対数時間、\\ ``O(log n)``: 「...はゆっくりと増加します」"

msgid "Linear-time, ``O(n)``: \"...increases at the same rate.\""
msgstr "線形時間、\\ ``O(n)``: 「\"...は同じ割合で増加します」"

msgid "Etc."
msgstr "等。"

msgid ""
"Imagine if one had to process 3 million data points within a single frame. "
"It would be impossible to craft the feature with a linear-time algorithm "
"since the sheer size of the data would increase the runtime far beyond the "
"time allotted. In comparison, using a constant-time algorithm could handle "
"the operation without issue."
msgstr ""
"1つのフレーム内で300万個のデータ ポイントを処理する必要がある場合を想像してく"
"ださい。データのサイズが割り当てられた時間をはるかに超えてランタイムを増加さ"
"せるので、線形時間アルゴリズムを使用して機能を作成することは不可能です。対照"
"的に、定数時間アルゴリズムを使用すると、問題なく操作を処理できます。"

msgid ""
"By and large, developers want to avoid engaging in linear-time operations as "
"much as possible. But, if one keeps the scale of a linear-time operation "
"small, and if one does not need to perform the operation often, then it may "
"be acceptable. Balancing these requirements and choosing the right "
"algorithm / data structure for the job is part of what makes programmers' "
"skills valuable."
msgstr ""
"概して、開発者は線形時間操作に可能な限り関与することを避けたいと考えていま"
"す。ただし、線形時間操作の規模を小さく保ち、操作を頻繁に実行する必要がない場"
"合は、許容できる場合があります。これらの要件のバランスを取り、ジョブに適した"
"アルゴリズム/データ構造を選択することは、プログラマーのスキルを価値あるものに"
"します。"

msgid "Array vs. Dictionary vs. Object"
msgstr "Array(配列) 対 Dictionary(辞書) 対 Object(オブジェクト)"

msgid ""
"Godot implements Array as a ``Vector<Variant>``. The engine stores the Array "
"contents in a contiguous section of memory, i.e. they are in a row adjacent "
"to each other."
msgstr ""
"GodotはArrayを ``Vector <Variant>``として実装します。エンジンは、配列の内容を"
"メモリの連続したセクションに保存します。つまり、それらは互いに隣接する行にあ"
"ります。"

msgid "Contiguous memory stores imply the following operation performance:"
msgstr "連続したメモリ ストアは、次の操作パフォーマンスを意味します:"

msgid "**Iterate:** Fastest. Great for loops."
msgstr "**Iterate(反復):** 最速。ループに最適です。"

msgid "Op: All it does is increment a counter to get to the next record."
msgstr "処理: カウンタをインクリメントして次のレコードに行くだけです。"

msgid "**Insert, Erase, Move:** Position-dependent. Generally slow."
msgstr "**Insert(挿入)、Erase(消去)、Move(移動):** 位置に依存。一般的に遅い。"

msgid ""
"Op: Adding/removing/moving content involves moving the adjacent records over "
"(to make room / fill space)."
msgstr ""
"処理: コンテンツを追加/削除/移動するには、隣接するレコードを移動する必要があ"
"ります(スペースを空ける/スペースを塗りつぶす作業)。"

msgid "Fast add/remove *from the end*."
msgstr "*末尾からは*\\ 追加/削除が速い。"

msgid "Slow add/remove *from an arbitrary position*."
msgstr "*任意の位置からは*\\ 追加/削除が遅い。"

msgid "Slowest add/remove *from the front*."
msgstr "*先頭からは*\\ 追加/削除が最も遅い。"

msgid "If doing many inserts/removals *from the front*, then..."
msgstr "*先頭から*\\ 複数の挿入/削除を行う場合には..."

msgid "invert the array."
msgstr "配列の並びを反転します。"

msgid "do a loop which executes the Array changes *at the end*."
msgstr "*末尾から*\\ 配列の変更をするループ処理を実行します。"

msgid "re-invert the array."
msgstr "配列の並びを再反転します。"

msgid ""
"This makes only 2 copies of the array (still constant time, but slow) versus "
"copying roughly 1/2 of the array, on average, N times (linear time)."
msgstr ""
"この方法なら、操作の最中に配列の約1/2を平均してN回(線形時間)コピーをする代わ"
"りに、配列全体の2回のコピーだけで済みます(依然として一定の時間がかかり、遅い"
"ですが)。"

msgid "Op: 1 addition operation from array start position up to desired index."
msgstr "処理: 配列の開始位置から目的のインデックスまでの1回の追加操作。"

msgid "**Find:** Slowest. Identifies the index/position of a value."
msgstr "**検索:** 最も遅い。値のインデックス/位置を識別します。"

msgid ""
"Op: Must iterate through array and compare values until one finds a match."
msgstr ""
"処理: 配列を反復処理し、一致するものが見つかるまで値を比較する必要がありま"
"す。"

msgid ""
"Performance is also dependent on whether one needs an exhaustive search."
msgstr "パフォーマンスは、徹底的な検索が必要かどうかによっても異なります。"

msgid ""
"If kept ordered, custom search operations can bring it to logarithmic time "
"(relatively fast). Laymen users won't be comfortable with this though. Done "
"by re-sorting the Array after every edit and writing an ordered-aware search "
"algorithm."
msgstr ""
"値が順序付けされている場合、カスタム検索操作によって対数時間 (比較的高速) に"
"なります。しかし、素人のユーザーはこれに不慣れです。編集のたびに配列を再ソー"
"トし、順序に対応した検索アルゴリズムを作成することで完了します。"

msgid ""
"Hashes are to reduce the chance of a key collision. If one occurs, the table "
"must recalculate another index for the value that takes the previous "
"position into account. In all, this results in constant-time access to all "
"records at the expense of memory and some minor operational efficiency."
msgstr ""
"ハッシュは、キーの衝突の可能性を減らすためのものです。発生した場合、テーブル"
"は以前の位置を考慮した値の別のインデックスを再計算する必要があります。これに"
"より、メモリと若干の運用効率が犠牲になりますが、全体として、すべてのレコード"
"に定数時間でアクセスできます。"

msgid "Hashing every key an arbitrary number of times."
msgstr "すべてのキーを任意の回数ハッシュします。"

msgid ""
"Hash operations are constant-time, so even if an algorithm must do more than "
"one, as long as the number of hash calculations doesn't become too dependent "
"on the density of the table, things will stay fast. Which leads to..."
msgstr ""
"ハッシュ操作は定数時間であるため、ハッシュ計算の数がテーブルの密度に依存しす"
"ぎない限り、アルゴリズムで複数の処理を行う必要がある場合でも、処理は高速にな"
"ります。話は続きます..."

msgid "**Iterate:** Fast."
msgstr "**反復処理:** 高速。"

msgid ""
"Op: Iterate over the map's internal vector of hashes. Return each key. "
"Afterwards, users then use the key to jump to and return the desired value."
msgstr ""
"処理: マップのハッシュの内部ベクトルを反復処理し、各キーを返します。その後、"
"ユーザーはキーを使用して目的の値にジャンプしてリターンします。"

msgid "**Insert, Erase, Move:** Fastest."
msgstr "**挿入、消去、移動:** 最速。"

msgid ""
"Op: Hash the given key. Do 1 addition operation to look up the appropriate "
"value (array start + offset). Move is two of these (one insert, one erase). "
"The map must do some maintenance to preserve its capabilities:"
msgstr ""
"処理: 指定されたキーをハッシュします。 1回の追加操作を実行して、適切な値(配列"
"の開始+オフセット)を検索します。移動はこれらの2つです(1つは挿入、1つは消去)。"
"マップは、その機能を維持するためにいくつかのメンテナンスを行う必要があります:"

msgid "update ordered List of records."
msgstr "レコードの順序付きリストを更新します。"

msgid "determine if table density mandates a need to expand table capacity."
msgstr ""
"テーブルの密度により、テーブルの容量を拡張する必要があるかどうかを判断しま"
"す。"

msgid ""
"The Dictionary remembers in what order users inserted its keys. This enables "
"it to execute reliable iterations."
msgstr ""
"Dictionaryは、ユーザーがキーを挿入した順序を記憶しています。これにより、信頼"
"性の高い反復処理を実行できます。"

msgid "**Get, Set:** Fastest. Same as a lookup *by key*."
msgstr "**取得、設定:** 最速。\\ *キーによる検索*\\ と同じです。"

msgid "Op: Same as insert/erase/move."
msgstr "処理: 挿入/消去/移動と同じです。"

msgid "**Find:** Slowest. Identifies the key of a value."
msgstr "**検索:** 最も遅い。値のキーを識別します。"

msgid ""
"Op: Must iterate through records and compare the value until a match is "
"found."
msgstr ""
"処理: レコードを反復処理し、一致が見つかるまで値を比較する必要があります。"

msgid ""
"Note that Godot does not provide this feature out-of-the-box (because they "
"aren't meant for this task)."
msgstr ""
"Godotはすぐにはこの機能を提供しないことに注意してください(これらの機能はこの"
"タスク用ではないため)。"

msgid ""
"Godot implements Objects as stupid, but dynamic containers of data content. "
"Objects query data sources when posed questions. For example, to answer the "
"question, \"do you have a property called, 'position'?\", it might ask its :"
"ref:`script <class_Script>` or the :ref:`ClassDB <class_ClassDB>`. One can "
"find more information about what objects are and how they work in the :ref:"
"`doc_what_are_godot_classes` article."
msgstr ""
"Godotは、Objectをあまり賢くはありませんが、データ コンテンツの動的なコンテ"
"ナーとして実装します。Objectは、質問が行われるとデータソースに対してクエリを"
"実行します。たとえば、「 'position'というプロパティがありますか？」という質問"
"に答えるために、その :ref:`script <class_Script>` または :ref:`ClassDB "
"<class_ClassDB>`を要求します。\\ :ref:`doc_what_are_godot_classes` の記事で、"
"オブジェクトとは何か、そしてそれらがどのように機能するかについての詳細を見つ"
"けることができます。"

msgid ""
"The important detail here is the complexity of the Object's task. Every time "
"it performs one of these multi-source queries, it runs through *several* "
"iteration loops and HashMap lookups. What's more, the queries are linear-"
"time operations dependent on the Object's inheritance hierarchy size. If the "
"class the Object queries (its current class) doesn't find anything, the "
"request defers to the next base class, all the way up until the original "
"Object class. While these are each fast operations in isolation, the fact "
"that it must make so many checks is what makes them slower than both of the "
"alternatives for looking up data."
msgstr ""
"ここで重要な点は、オブジェクトのタスクの複雑さです。これらのマルチソースクエ"
"リの1つを実行するたびに、\\ *複数* の反復ループとHashMapのルックアップを実行"
"します。さらに、クエリはオブジェクトの継承階層サイズに依存する線形時間操作で"
"す。 Objectクエリを実行するクラス(現在のクラス)で何も見つからない場合、リクエ"
"ストはObjectの継承元の基本クラスへと次々に受け渡されます。これらはそれぞれ単"
"独では高速な操作ですが、非常に多くのチェックを行う必要があるという事実が、"
"データを検索するための Array/Dictionary 両方の代替手段よりも遅くなる理由で"
"す。"

msgid ""
"When developers mention how slow the scripting API is, it is this chain of "
"queries they refer to. Compared to compiled C++ code where the application "
"knows exactly where to go to find anything, it is inevitable that scripting "
"API operations will take much longer. They must locate the source of any "
"relevant data before they can attempt to access it."
msgstr ""
"開発者がスクリプトAPIの速度が遅いと言及するのは、この一連のクエリの参照につい"
"てです。アプリケーションが何かを見つける場所を正確に知っているコンパイル済み"
"のC++コードと比較すると、スクリプトAPIでは操作にかかる時間が大幅に長くなるこ"
"とは避けられません。アクセスを行う前に、関連するデータのソースを見つける必要"
"があるからです。"

msgid ""
"The reason GDScript is slow is because every operation it performs passes "
"through this system."
msgstr ""
"GDScriptが遅いのは、実行するすべての操作がこのシステムを通過するためです。"

msgid ""
"C# can process some content at higher speeds via more optimized bytecode. "
"But, if the C# script calls into an engine class' content or if the script "
"tries to access something external to it, it will go through this pipeline."
msgstr ""
"C#は、より最適化されたバイトコードにより、一部のコンテンツをより高速に処理で"
"きます。ただし、C#スクリプトがエンジンクラスのコンテンツを呼び出す場合、また"
"はスクリプトが外部の何かにアクセスしようとする場合、このパイプラインを通過し"
"ます。"

msgid ""
"NativeScript C++ goes even further and keeps everything internal by default. "
"Calls into external structures will go through the scripting API. In "
"NativeScript C++, registering methods to expose them to the scripting API is "
"a manual task. It is at this point that external, non-C++ classes will use "
"the API to locate them."
msgstr ""
"NativeScript C++はさらに進んで、デフォルトですべてを内部に保持します。外部構"
"造への呼び出しは、スクリプトAPIを経由します。 NativeScript C++では、スクリプ"
"トAPIに公開するメソッドを登録するのは手動のタスクです。この時点で、外部の非C+"
"+クラスがAPIを使用してそれらを見つけます。"

msgid ""
"So, assuming one extends from Reference to create a data structure, like an "
"Array or Dictionary, why choose an Object over the other two options?"
msgstr ""
"では、Array や Dictionary などのデータ構造を作成するために Reference から拡張"
"すると仮定すると、なぜ他の2つのオプションよりも Object を選択するのでしょう"
"か？"

msgid ""
"**Control:** With objects comes the ability to create more sophisticated "
"structures. One can layer abstractions over the data to ensure the external "
"API doesn't change in response to internal data structure changes. What's "
"more, Objects can have signals, allowing for reactive behavior."
msgstr ""
"**コントロール:** Object を使用すると、より洗練された構造を作成する機能が提供"
"されます。データを抽象化して、内部データ構造の変更に応じて外部APIが変更されな"
"いようにすることができます。さらに、Object はシグナルを持ち、反応的な動作を可"
"能にします。"

msgid ""
"**Clarity:** Objects are a reliable data source when it comes to the data "
"that scripts and engine classes define for them. Properties may not hold the "
"values one expects, but one doesn't need to worry about whether the property "
"exists in the first place."
msgstr ""
"**明快さ:** Object は、スクリプトとエンジンクラスが定義するデータに関しては信"
"頼できるデータソースです。プロパティは期待する値を保持していない場合がありま"
"すが、プロパティがそもそも存在するかどうかを心配する必要はありません。"

msgid ""
"**Convenience:** If one already has a similar data structure in mind, then "
"extending from an existing class makes the task of building the data "
"structure much easier. In comparison, Arrays and Dictionaries don't fulfill "
"all use cases one might have."
msgstr ""
"**利便性:** 同様のデータ構造をすでに念頭に置いている場合、既存のクラスから拡"
"張すると、データ構造を構築するタスクがはるかに簡単になります。それに比べて、"
"Array と Dictionary はすべてのユースケースを満たしているわけではありません。"

msgid ""
"Objects also give users the opportunity to create even more specialized data "
"structures. With it, one can design their own List, Binary Search Tree, "
"Heap, Splay Tree, Graph, Disjoint Set, and any host of other options."
msgstr ""
"また、Object を使用すると、ユーザーはさらに特殊なデータ構造を作成することもで"
"きます。これを使用して、独自のリスト、バイナリ検索ツリー、ヒープ、スプレー"
"木、グラフ、素集合、およびその他のオプションのホストを設計できます。"

msgid ""
"\"Why not use Node for tree structures?\" one might ask. Well, the Node "
"class contains things that won't be relevant to one's custom data structure. "
"As such, it can be helpful to construct one's own node type when building "
"tree structures."
msgstr ""
"「ツリー構造にNodeを使用しないのはなぜですか？」と尋ねるかもしれません。 Node"
"クラスには、カスタムデータ構造に関係のないものが含まれています。そのため、ツ"
"リー構造を構築するときに、独自のノードタイプを構築すると役立ちます。"

msgid ""
"From here, one can then create their own structures with specific features, "
"limited only by their imagination."
msgstr ""
"ここから、想像力によってのみ制限される特定の機能を備えた独自の構造を作成でき"
"ます。"

msgid "Enumerations: int vs. string"
msgstr "列挙型: int 対 string"

msgid ""
"The short answer is, \"whichever you are more comfortable with.\" This is a "
"feature specific to GDScript and not Godot scripting in general; The "
"languages prioritizes usability over performance."
msgstr ""
"簡単な答えは、「どちらが快適か」です。これは、(C++、C#等の)一般的なGodotスク"
"リプトにはない、GDScript固有の機能です。この言語はパフォーマンスよりも使いや"
"すさを優先しています。"

msgid ""
"On a technical level, integer comparisons (constant-time) will happen faster "
"than string comparisons (linear-time). If one wants to keep up other "
"languages' conventions though, then one should use integers."
msgstr ""
"技術的なレベルでは、整数の比較 (定数時間) は文字列の比較 (線形時間) よりも高"
"速に行われます。しかし、他の言語の規則を維持したい場合は、整数を使用する必要"
"があります。"

msgid ""
"If the primary purpose of using an enum is for printing values and one "
"wishes to group them together as related concepts, then it makes sense to "
"use them as strings. That way, a separate data structure to execute on the "
"printing is unnecessary."
msgstr ""
"列挙型を使用する主な目的が値を出力することであり、それらを関連する概念として"
"グループ化する場合、それらを文字列として使用することは理にかなっています。そ"
"うすれば、印刷で実行するための別個のデータ構造は不要です。"

msgid ""
"Under what circumstances should one use each of Godot's animation classes? "
"The answer may not be immediately clear to new Godot users."
msgstr ""
"どのような状況でGodotの各アニメーションクラスを使用する必要がありますか？ 答"
"えは、新しいGodotユーザーにはすぐにはわからないかもしれません。"

msgid ""
":ref:`AnimatedTexture <class_AnimatedTexture>` is a texture that the engine "
"draws as an animated loop rather than a static image. Users can manipulate..."
msgstr ""
":ref:`AnimatedTexture <class_AnimatedTexture>` は、エンジンが静的イメージでは"
"なくアニメーション ループとして描画するテクスチャです。ユーザーは次の操作がで"
"きます..."

msgid "the number of regions contained within the texture (frames)."
msgstr "テクスチャに含まれる領域の数(フレーム数)。"

msgid ""
"AnimationPlayers are also the tool one will need to use if they wish to "
"design more complex 2D animation systems, such as..."
msgstr ""
"AnimationPlayer は、次のようなより複雑な2Dアニメーションシステムを設計する場"
"合に使用する必要があるツールでもあります。"

msgid ""
"**2D Mesh animations:** defining a region for the sprite's texture and "
"rigging a skeleton to it. Then one animates the bones which stretch and bend "
"the texture in proportion to the bones' relationships to each other."
msgstr ""
"**2Dメッシュアニメーション:** スプライトのテクスチャの領域を定義し、スケルト"
"ンをリギングします。次に、ボーンのアニメーション化を行い、ボーンの相互関係に"
"応じてテクスチャを伸縮させます。"

msgid "A mix of the above."
msgstr "上記のミックス。"

msgid ""
"While one needs an AnimationPlayer to design each of the individual "
"animation sequences for a game, it can also be useful to combine animations "
"for blending, i.e. enabling smooth transitions between these animations. "
"There may also be a hierarchical structure between animations that one plans "
"out for their object. These are the cases where the :ref:`AnimationTree "
"<class_AnimationTree>` shines. One can find an in-depth guide on using the "
"AnimationTree :ref:`here <doc_animation_tree>`."
msgstr ""
"ゲームの個々のアニメーションシーケンスをそれぞれ設計するには AnimationPlayer "
"が必要ですが、アニメーションを組み合わせてブレンドすること、つまり、これらの"
"アニメーション間のスムーズな移行を可能にすることにも役立ちます。アニメーショ"
"ン間には、オブジェクトに対して計画している階層構造もあります。これらは :ref:"
"`AnimationTree <class_AnimationTree>` が脚光を浴びるケースです。 "
"AnimationTree の使用に関する詳細なガイドは :ref:`ここ <doc_animation_tree>` "
"で見つけることができます。"

msgid "Translation status"
msgstr "翻訳ステータス"
