#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (3D)"
msgstr "コリジョン形状(3D)"

msgid "This guide explains:"
msgstr "このガイドでは以下の事を説明します:"

msgid "The types of collision shapes available in 3D in Godot."
msgstr "Godotの3Dで使用できるコリジョン形状です。"

msgid "Using a convex or a concave mesh as a collision shape."
msgstr "凸形状または凹形状のメッシュをコリジョン形状として使用します。"

msgid "Performance considerations regarding 3D collisions."
msgstr "パフォーマンスを考慮した3Dコリジョン形状です。"

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr ""
"Godotはさまざまな種類の衝突形状を提供しており、それぞれにパフォーマンスと精度"
"のトレードオフがあります。"

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody3D` by adding one or "
"more :ref:`CollisionShape3Ds <class_CollisionShape3D>` as child nodes. Note "
"that you must add a :ref:`class_Shape3D` *resource* to collision shape nodes "
"in the Inspector dock."
msgstr ""
"\\ :ref:`class_PhysicsBody3D` の形状は、1つ以上の :ref:`CollisionShape3D "
"<class_CollisionShape3D>` を子ノードとして追加することで定義します。 :ref:"
"`class_Shape3D` *リソース* をインスペクタードックのコリジョン形状ノードに追加"
"する必要があることに注意してください。"

msgid ""
"When you add multiple collision shapes to a single PhysicsBody, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"1つの PhysicsBody 複数のコリジョン形状を追加すると、それらが重なることを心配"
"せずに済みます。それらは互いに \"衝突\" しません。"

msgid "Primitive collision shapes"
msgstr "プリミティブコリジョン形状"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godotは、以下のプリミティブコリジョン形状を提供します:"

msgid ":ref:`class_BoxShape3D`"
msgstr "\\:ref:`class_BoxShape3D`"

msgid ":ref:`class_SphereShape3D`"
msgstr "\\ :ref:`class_SphereShape3D`"

msgid ":ref:`class_CapsuleShape3D`"
msgstr "\\ :ref:`class_CapsuleShape3D`"

msgid ":ref:`class_CylinderShape3D`"
msgstr "\\ :ref:`class_CylinderShape3D`"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"ほとんどの小さなオブジェクトの衝突は、1つまたは複数の基本的な形状を使用して表"
"現できます。しかし、大型の船やレベル全体のような複雑なオブジェクトの場合は、"
"代わりに凸形状や凹形状を使用する必要があるかもしれません。詳細は以下で説明し"
"ます。"

msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"動的オブジェクト、たとえばRigidBody や CharacterBodyの場合は、基本的な形状を"
"使用することをお勧めします。これは挙動が最も安定しているためです。これらの形"
"状はパフォーマンスが優れている場合が多いです。"

msgid "Convex collision shapes"
msgstr "凸形状コリジョン形状"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape3D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
"\\ :ref:`凸形状コリジョン形状 <class_ConvexPolygonShape3D>` は、プリミティブ"
"コリジョン形状と凹型コリジョン形状の折衷的な選択肢です。これらはどんな複雑な"
"形状でも表現できますが、重要な制約があります。その名前が示すように、個々の形"
"状は *凸型* の形状しか表現できません。例えば、ピラミッドは *凸型* ですが、中"
"が空洞の箱は *凹型* です。1つのコリジョン形状で凹型オブジェクトを定義するに"
"は、凹型コリジョン形状を使用する必要があります。"

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"オブジェクトの複雑さによっては、凹型コリジョン形状を使用する代わりに、複数の"
"凸型形状を使用することでパフォーマンスが向上する場合があります。Godotでは、 *"
"凸形状分解* を使用して、中が空洞のオブジェクトに大まかに一致する凸型形状を生"
"成できます。ただし、凸型形状の数が一定量を超えると、このパフォーマンスの利点"
"は失われます。レベル全体のような大きく複雑なオブジェクトの場合は、凹型形状を"
"使用することを推奨します。"

msgid ""
"You can generate one or several convex collision shapes from the editor by "
"selecting a MeshInstance3D and using the **Mesh** menu at the top of the 3D "
"viewport. The editor exposes two generation modes:"
msgstr ""
"エディターでは、MeshInstance3D を選択し、3Dビューポートの上部にある **Mesh** "
"メニューを使用して、1つまたは複数の凸形状のコリジョン形状を生成できます。エ"
"ディターは以下の2つの生成モードを提供しています:"

msgid ""
"**Create Single Convex Collision Sibling** uses the Quickhull algorithm. It "
"creates one CollisionShape node with an automatically generated convex "
"collision shape. Since it only generates a single shape, it provides good "
"performance and is ideal for small objects."
msgstr ""
"**Create Single Convex Collision Sibling** は Quickhull アルゴリズムを使用し"
"ます。このモードでは、自動生成された凸型の衝突形状を持つ 1 つの "
"**CollisionShape** ノードを作成します。単一の形状のみを生成するため、パフォー"
"マンスが良好で、小さなオブジェクトに最適です。"

msgid ""
"**Create Multiple Convex Collision Siblings** uses the V-HACD algorithm. It "
"creates several CollisionShape nodes, each with a convex shape. Since it "
"generates multiple shapes, it is more accurate for concave objects at the "
"cost of performance. For objects with medium complexity, it will likely be "
"faster than using a single concave collision shape."
msgstr ""
"**Create Multiple Convex Collision Siblings** は V-HACD アルゴリズムを使用し"
"ます。このモードでは複数の **CollisionShape** ノードを作成し、それぞれが凸型"
"の形状を持ちます。複数の形状を生成するため、精度が向上し、特に凹型オブジェク"
"トに適していますが、パフォーマンスのコストが伴います。中程度の複雑さを持つオ"
"ブジェクトでは、1つの凹型コリジョン形状を使用するよりも高速である可能性が高い"
"です。"

msgid "Concave or trimesh collision shapes"
msgstr "凹形状または三角形メッシュのコリジョン形状"

msgid ""
":ref:`Concave collision shapes <class_ConcavePolygonShape3D>`, also called "
"trimesh collision shapes, can take any form, from a few triangles to "
"thousands of triangles. Concave shapes are the slowest option but are also "
"the most accurate in Godot. **You can only use concave shapes within "
"StaticBodies.** They will not work with CharacterBodies or RigidBodies "
"unless the RigidBody's mode is Static."
msgstr ""
"\\ :ref:`凹形状コリジョン形状 <class_ConcavePolygonShape3D>` 、または三角メッ"
"シュコリジョン形状は、少数の三角形から数千の三角形まで、あらゆる形状を表現で"
"きます。凹形状は、Godotにおいて最も正確で、最も処理速度が遅いオプションで"
"す。 **凹形状は StaticBody 内でのみ使用可能です** 。CharacterBodyやRigidBody"
"では動作しません。ただし、RigidBodyが Static モードに設定されている場合は例外"
"的に動作します。"

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr ""
"凹形状は最も正確な *衝突* を提供しますが、接触報告の精度はプリミティブ形状よ"
"りも低い場合があります。"

msgid ""
"When not using GridMaps for level design, concave shapes are the best "
"approach for a level's collision. That said, if your level has small "
"details, you may want to exclude those from collision for performance and "
"game feel. To do so, you can build a simplified collision mesh in a 3D "
"modeler and have Godot generate a collision shape for it automatically. More "
"on that below"
msgstr ""
"レベルデザインにGridMapを使用しない場合、凹形状がレベルの衝突判定に最適なアプ"
"ローチです。ただし、レベルに小さな詳細部分が含まれている場合、それらを衝突処"
"理から除外するとパフォーマンスやゲームの操作感が向上することがあります。その"
"ためには、3D モデラーで簡略化されたコリジョンメッシュを作成し、Godot にそれを"
"基に衝突形状を自動生成させる方法があります。詳細については以下をご覧ください"

msgid ""
"Note that unlike primitive and convex shapes, a concave collision shape "
"doesn't have an actual \"volume\". You can place objects both *outside* of "
"the shape as well as *inside*."
msgstr ""
"注意点として、プリミティブ形状や凸型形状とは異なり、凹型衝突形状には実際の "
"\"体積\" が存在しません。そのため、オブジェクトを形状の *外側* だけでなく、 *"
"内側* にも配置することが可能です。"

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"MeshInstance3D and using the **Mesh** menu at the top of the 3D viewport. "
"The editor exposes two options:"
msgstr ""
"エディターで凹型の衝突形状を生成するには、MeshInstance3Dを選択し、3Dビュー"
"ポート上部にある **Mesh** メニューを使用します。エディターには次の2つのオプ"
"ションが用意されています:"

msgid ""
"**Create Trimesh Static Body** is a convenient option. It creates a "
"StaticBody containing a concave shape matching the mesh's geometry."
msgstr ""
"**Create Trimesh Static Body** は便利なオプションです。この機能は、メッシュの"
"形状に一致する凹型のコリジョン形状を持つ StaticBody を作成します。"

msgid ""
"**Create Trimesh Collision Sibling** creates a CollisionShape node with a "
"concave shape matching the mesh's geometry."
msgstr ""
"**Create Trimesh Collision Sibling** は、メッシュの形状に一致する凹型のコリ"
"ジョン形状を持つ CollisionShape ノードを作成します。"

msgid ""
"See :ref:`doc_importing_3d_scenes` for information on how to export models "
"for Godot and automatically generate collision shapes on import."
msgstr ""
"\\ :ref:`doc_importing_3d_scenes` では、モデルをGodot用にエクスポートし、イン"
"ポート時に自動的に衝突形状を生成する方法について説明しています。詳細について"
"はこちらを参照してください。"

msgid "Performance caveats"
msgstr "パフォーマンス注意点"

msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"PhysicsBody につき衝突形状は1つに限定されません。それでも形状の数をできるだけ"
"少なく保つことをお勧めします。これはパフォーマンス向上のためで、特にRigidBody"
"やCharacterBodyのような動的オブジェクトでは重要です。さらに、物理エンジンの内"
"部最適化を活用するために、CollisionShape の移動、回転、スケーリングを避けるべ"
"きです。"

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"単一の非変形コリジョン形状を StaticBody で使用する場合、エンジンの *broad "
"phase* アルゴリズムは非アクティブな PhysicsBody を除外できます。その結果、 "
"*narrow phase* ではアクティブなボディの形状のみを考慮すればよくなります。しか"
"し、StaticBody に多くの衝突形状がある場合、broad phaseは失敗します。より遅い"
"narrow phaseがそれぞれの形状に対して衝突チェックを行うことになります。"

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"パフォーマンスの問題に直面した場合、精度に関して妥協を行う必要があるかもしれ"
"ません。ほとんどのゲームでは、衝突判定が100%正確であることはありません。代わ"
"りにクリエイティブな方法でそれを隠したり、通常のゲームプレイ中に目立たなくさ"
"せたりしています。"
