#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Multiple resolutions"
msgstr "複数の解像度"

msgid "The problem of multiple resolutions"
msgstr "複数の解像度の問題"

msgid ""
"Developers often have trouble understanding how to best support multiple "
"resolutions in their games. For desktop and console games, this is more or "
"less straightforward, as most screen aspect ratios are 16:9 and resolutions "
"are standard (720p, 1080p, 1440p, 4K, …)."
msgstr ""
"開発者は、ゲームで複数の解像度を最適にサポートする方法を理解するのに苦労する"
"ことがよくあります。デスクトップおよびコンソールゲームの場合、ほとんどの画面"
"アスペクト比は16:9であり、解像度は標準化(720p、1080p、1440p、4Kなど)されてい"
"るので、多かれ少なかれこれは簡単です。"

msgid ""
"For mobile games, at first, it was easy. For many years, the iPhone and iPad "
"used the same resolution. When *Retina* was implemented, they just doubled "
"the pixel density; most developers had to supply assets in default and "
"double resolutions."
msgstr ""
"モバイルゲームの場合、最初は簡単でした。長年、iPhoneとiPadは同じ解像度を使用"
"していました。そして *Retina* を実装すると、ピクセル密度が2倍になりました。ほ"
"とんどの開発者は、デフォルトおよび二重解像度でアセットを提供する必要がありま"
"した。"

msgid ""
"Nowadays, this is no longer the case, as there are plenty of different "
"screen sizes, densities, and aspect ratios. Non-conventional sizes are also "
"becoming increasingly popular, such as ultrawide displays."
msgstr ""
"現在では、さまざまな画面サイズ、密度、アスペクト比が存在するため、これはもは"
"や当てはまりません。超ワイドディスプレイなど、従来とは異なるサイズも人気が高"
"まっています。"

msgid ""
"For 3D rendering, there is not much of a need to support multiple "
"resolutions. Thanks to its vector-based nature, 3D geometry will just fill "
"the screen based on the viewport size. For 2D and game UIs, this is a "
"different matter, as art needs to be created using specific pixel sizes in "
"software such as Photoshop, GIMP or Krita."
msgstr ""
"3Dレンダリングにおいては、複数の解像度をサポートする必要性はあまりありませ"
"ん。ベクター形式ベースの性質のおかげで、3Dジオメトリがビューポートのサイズに"
"合わせて画面を埋めるだけだからです。一方2DおよびゲームUIでは、Photoshop、"
"GIMP、Kritaなどのソフトウェアで特定のピクセルサイズを使用してアートを作成する"
"必要があるため、事情が異なります。"

msgid ""
"Since layouts, aspect ratios, resolutions, and pixel densities can change so "
"much, it is no longer possible to design UIs for every specific screen. "
"Another method must be used."
msgstr ""
"レイアウト、アスペクト比、解像度、ピクセル密度は大きく変化する可能性があるた"
"め、特定の画面ごとにUIを設計することはできなくなりました。別の方法を使用する"
"必要があります。"

msgid "One size fits all"
msgstr "ワンサイズですべてに対応"

msgid ""
"The most common approach is to use a single *base* resolution and then fit "
"it to everything else. This resolution is how most players are expected to "
"play the game (given their hardware). For mobile, Google has useful `stats "
"<https://developer.android.com/about/dashboards>`_ online, and for desktop, "
"Steam `also does <https://store.steampowered.com/hwsurvey/>`_."
msgstr ""
"最も一般的なアプローチは、単一の *base* 解像度を使用し、それを他のすべてに適"
"合させることです。この解像度は、ほとんどのプレイヤーがこれでゲームをプレイす"
"ることが期待されます(特定のハードウェアが与えられた場合)。モバイルの場合、"
"Googleには便利な `stats <https://developer.android.com/about/dashboards>`_ が"
"あり、デスクトップの場合、Steamには `<https://store.steampowered.com/"
"hwsurvey/>`_ もあります。"

msgid ""
"As an example, Steam shows that the most common *primary display resolution* "
"is 1920×1080, so a sensible approach is to develop a game for this "
"resolution, then handle scaling for different sizes and aspect ratios."
msgstr ""
"例として、Steamは最も一般的な *プライマリディスプレイ解像度* が1920×1080であ"
"ることを示しているため、賢明なアプローチはこの解像度のゲームを開発し、異なる"
"サイズとアスペクト比にスケーリング処理をすることです。"

msgid "Godot provides several useful tools to do this easily."
msgstr ""
"Godotには、これを簡単に行うための便利なツールがいくつか用意されています。"

msgid ""
"You can see how Godot's support for multiple resolutions works in action "
"using the `Multiple Resolutions and Aspect Ratios demo project <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__."
msgstr ""
"Godotで複数の解像度をサポートする例として、デモプロジェクトは `こちら "
"<https://github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__ で確認できます。"

msgid "Base size"
msgstr "ベースサイズ"

msgid ""
"A base size for the window can be specified in the Project Settings under "
"**Display → Window**."
msgstr ""
"ウィンドウの基本サイズは、[プロジェクト設定]の **Display → Window** で指定で"
"きます。"

msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"ただし、それが何をするのかは完全には明らかではありません。エンジンは、モニ"
"ターをこの解像度に切り替えようとはしません。むしろ、この設定を「設計サイ"
"ズ」、つまりエディタで作業する領域のサイズと考えてください。この設定は、2Dエ"
"ディタの青い長方形のサイズに直接対応しています。"

msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"多くの場合、画面とウィンドウのサイズがこの基本サイズと異なるデバイスをサポー"
"トする必要があります。Godotには、さまざまな画面サイズに合わせてビューポートの"
"サイズを変更および拡大する方法を制御する多くの方法があります。"

msgid ""
"On this page, *window* refers to the screen area allotted to your game by "
"the system, while *viewport* refers to the root object (accessible from "
"``get_tree().root``) which the game controls to fill this screen area. This "
"viewport is a :ref:`Window <class_Window>` instance. Recall from "
"the :ref:`introduction <doc_viewports>` that *all* Window objects are "
"viewports."
msgstr ""
"このページでは、 *ウィンドウ* はシステムによってゲームに割り当てられた画面領"
"域を指し、 *ビューポート* はゲームがこの画面領域を埋めるために制御するルート"
"オブジェクト（ ``get_tree().root`` でアクセス可能）を指します。このビューポー"
"トは :ref:`Window <class_Window>` のインスタンスです。 :ref:`導入"
"<doc_viewports>` で述べたように、*すべての* Window オブジェクトはビューポート"
"です。"

msgid ""
"To configure the stretch base size at runtime from a script, use the "
"``get_tree().root.content_scale_size`` property "
"(see :ref:`Window.content_scale_size "
"<class_Window_property_content_scale_size>`). Changing this value can "
"indirectly change the size of 2D elements. However, to provide a user-"
"accessible scaling option, "
"using :ref:`doc_multiple_resolutions_stretch_scale` is recommended as it's "
"easier to adjust."
msgstr ""
"実行時の伸縮ベースサイズをスクリプトから設定するには、 "
"``get_tree().root.content_scale_size`` プロパティを使用します"
"（ :ref:`Window.content_scale_size "
"<class_Window_property_content_scale_size>` を参照）。この値を変更すると、間"
"接的に2D要素のサイズを変更することができます。ただし、ユーザーがアクセス可能"
"なスケーリングオプションを提供する場合は、調整が容易"
"な :ref:`doc_multiple_resolutions_stretch_scale` の使用が推奨されます。"

msgid ""
"Godot follows a modern approach to multiple resolutions. The engine will "
"never change the monitor's resolution on its own. While changing the "
"monitor's resolution is the most efficient approach, it's also the least "
"reliable approach as it can leave the monitor stuck on a low resolution if "
"the game crashes. This is especially common on macOS or Linux which don't "
"handle resolution changes as well as Windows."
msgstr ""
"Godotは、複数の解像度に対する最新のアプローチに従っています。エンジンが勝手に"
"モニターの解像度を変更することはありません。モニターの解像度を変更するのは最"
"も効率的なアプローチですが、ゲームがクラッシュしたときにモニターが低解像度で"
"止まってしまう可能性があるため、最も信頼性の低いアプローチでもあります。これ"
"は、Windowsほど解像度の変更をうまく処理できないmacOSやLinuxで特によくあること"
"です。"

msgid ""
"Changing the monitor's resolution also removes any control from the game "
"developer over filtering and aspect ratio stretching, which can be important "
"to ensure correct display for pixel art games."
msgstr ""
"また、モニターの解像度を変更すると、ピクセルアートゲームを正しく表示するため"
"に重要なフィルタリングやアスペクト比の伸縮を、ゲーム開発者が制御できなくなり"
"ます。"

msgid ""
"On top of that, changing the monitor's resolution makes alt-tabbing in and "
"out of a game much slower since the monitor has to change resolutions every "
"time this is done."
msgstr ""
"その上、モニターの解像度を変更すると、その都度モニターが解像度を変更しなけれ"
"ばならないため、Alt+Tabでのゲームへの出入りが非常に遅くなるのです。"

msgid "Resizing"
msgstr "サイズ変更"

msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().root`` or ``get_node(\"/root\")``)."
msgstr ""
"デバイスには様々な種類があり、様々な画面があり、それらは異なるピクセル密度と"
"解像度を持っています。それらすべてを処理するのは大変な作業になる可能性がある"
"ため、Godotは開発者の生活を少し楽にするように努めています。 "
"\\ :ref:`Viewport <class_Viewport>` ノードにはサイズ変更を扱う機能がいくつか"
"あり、シーンツリーのルートノードは常にビューポートです(読み込まれたシーンはそ"
"の子としてインスタンス化され、\\ ``get_tree().get_root()`` または "
"``get_node(\"/root\")`` を呼び出すことでいつでもアクセスできます)。"

msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a set of parameters in the project settings to "
"handle multiple resolutions."
msgstr ""
"いずれにせよ、ルートビューポートのパラメーターを変更することがおそらく最も柔"
"軟な解決策ですが、多くの作業、コード、推測が必要になる可能性があるため、Godot"
"はプロジェクト設定において、複数の解像度に対応するためのパラメーターのシンプ"
"ルなセットを提供します。"

msgid ""
"To render 3D at a lower resolution than 2D elements (without needing "
"separate viewports), you can use Godot's :ref:`resolution scaling "
"<doc_resolution_scaling>` support. This is a good way to improve performance "
"significantly in GPU-bottlenecked scenarios. This works with any stretch "
"mode and stretch aspect combination."
msgstr ""
"3D要素を2D要素よりも低い解像度で（別々のビューポートを利用せずに）レンダリン"
"グする場合、Godotの :ref:`解像度スケーリング <doc_resolution_scaling>` 機能を"
"利用できます。GPUがボトルネックとなる状況において、これはパフォーマンスを大幅"
"に向上させる有効な手段となります。あらゆるストレッチモードとアスペクト比の組"
"み合わせで動作します。"

msgid "Stretch settings"
msgstr "ストレッチ設定"

msgid ""
"Stretch settings are located in the project settings and provide several "
"options:"
msgstr ""
"ストレッチ設定はプロジェクト設定の中にあり、いくつかのオプションが用意されて"
"います:"

msgid "Stretch Mode"
msgstr "ストレッチモード(Stretch Mode)"

msgid ""
"The **Stretch Mode** setting defines how the base size is stretched to fit "
"the resolution of the window or screen. The animations below use a \"base "
"size\" of just 16×9 pixels to demonstrate the effect of different stretch "
"modes. A single sprite, also 16×9 pixels in size, covers the entire "
"viewport, and a diagonal :ref:`Line2D <class_Line2D>` is added on top of it:"
msgstr ""
"**Stretch Mode**設定は、ベースサイズがウィンドウや画面の解像度に合わせる際に"
"どのように引き伸ばされるかを定義します。以下のアニメーションでは、さまざまな"
"ストレッチモードの効果を示すために、わずか16×9ピクセルの「ベースサイズ」を使"
"用しています。同じくサイズが16×9ピクセルの単一のスプライトがビューポート全体"
"をカバーし、その上に対角線 :ref:`Line2D <class_Line2D>` が追加されます:"

msgid ""
"**Stretch Mode = Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"**Stretch Aspect** setting has no effect."
msgstr ""
"**Stretch Mode = Disabled** (デフォルト): ストレッチは行われません。シーン内"
"の1単位は、画面上の1ピクセルに対応します。このモードでは、**Stretch Aspect** "
"設定は効果がありません。"

msgid ""
"**Stretch Mode = Canvas Items**: In this mode, the base size specified in "
"width and height in the project settings is stretched to cover the whole "
"screen (taking the **Stretch Aspect** setting into account). This means that "
"everything is rendered directly at the target resolution. 3D is unaffected, "
"while in 2D, there is no longer a 1:1 correspondence between sprite pixels "
"and screen pixels, which may result in scaling artifacts."
msgstr ""
"**Stretch Mode = Canvas Items**: このモードでは、プロジェクト設定の display/"
"width および display/height で指定されたサイズが、画面全体をカバーするように"
"ストレッチされます(**Stretch Aspect** 設定を考慮します)。これは、すべてがター"
"ゲット解像度で直接レンダリングされることを意味します。 3Dはほとんど影響を受け"
"ませんが、2Dでは、スプライトピクセルとスクリーンピクセルが1対1で対応しなくな"
"り、スケーリングのアーティファクトが発生する可能性があります。"

msgid ""
"**Stretch Mode = Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the Project Settings' **Display** section. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the **Stretch Aspect** setting into account)."
msgstr ""
"**Stretch Mode = Viewport**: ビューポートのスケーリングは、ルー"
"ト :ref:`Viewport <class_Viewport>` のサイズがプロジェクト設定の **Display** "
"セクションで指定されたベースサイズに正確に設定されることを意味します。シーン"
"は最初にこのビューポートにレンダリングされます。最後に、このビューポートは画"
"面に収まるように拡大縮小されます(**Stretch Aspect** 設定を考慮します)。"

msgid ""
"To configure the stretch mode at runtime from a script, use the "
"``get_tree().root.content_scale_mode`` property "
"(see :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` and the :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` enum)."
msgstr ""
"実行時にスクリプトからストレッチを設定するには、\\ "
"``get_tree().root.content_scale_mode`` プロパティを使用します"
"(:ref:`Window.content_scale_mode <class_Window_property_content_scale_mode>` "
"および :ref:`ContentScaleMode <enum_Window_ContentScaleMode>` を参照)。"

msgid "Stretch Aspect"
msgstr "ストレッチアスペクト(Stretch Aspect)"

msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if **Stretch Mode** is set to something other than **Disabled**."
msgstr ""
"2番目の設定は Stretch Aspect です。これは、\\ **Stretch Mode** が "
"**Disable** 以外に設定されている場合にのみ有効であることに注意してください。"

msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"以下のアニメーションでは、灰色と黒の領域に気づくでしょう。黒い領域はエンジン"
"によって追加され、描画できません。灰色の領域はシーンの一部であり、描画できま"
"す。灰色の領域は、2Dエディタに表示される青いフレームの外側の領域に対応してい"
"ます。"

msgid ""
"**Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"**Stretch Aspect = Ignore**: 画面をストレッチするときにアスペクト比を無視しま"
"す。これは、幅が広くても狭くても、元の解像度が拡大されて画面全体に表示される"
"ことを意味します。これにより、不均一なストレッチが発生する可能性があります。"
"物体が設計よりも幅が広い、または背が高く見えます。"

msgid ""
"**Stretch Aspect = Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"**Stretch Aspect = Keep**: 画面をストレッチするときにアスペクト比を維持しま"
"す。つまり、ビューポートは画面の解像度に関係なく元のサイズを保持し、画面の上"
"部/下部(「レターボックス化」)または側面(「ピラーボックス化」)に黒いバーが追加"
"されます。"

msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr ""
"これは、ターゲットデバイスのアスペクト比を事前に知っている場合、または異なる"
"アスペクト比を処理したくない場合に適したオプションです。"

msgid ""
"**Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"**Stretch Aspect = Keep Width**: 画面をストレッチするときにアスペクト比を維持"
"します。画面が基本サイズよりも広い場合、黒いバーが左右に追加されます(ピラー"
"ボックス化)。ただし、画面が基本解像度よりも高い場合、ビューポートは垂直方向に"
"拡大されます(そして、より多くのコンテンツが下部に表示されます)。これを「垂直"
"方向に拡張」と考えることもできます。"

msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"これは通常、スケーリングするGUIまたはHUDを作成するのに最適なオプションです。"
"そのため、一部のコントロールを下部に固定できます"
"(:ref:`doc_size_and_anchors`)。"

msgid ""
"**Stretch Aspect = Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"**Stretch Aspect = Keep Height**: 画面を伸ばすときにアスペクト比を保ちます。"
"画面が基本サイズよりも高い場合、黒いバーが上部と下部に追加されます(レターボッ"
"クス化)。ただし、画面が基本解像度よりも広い場合、ビューポートは水平方向に拡大"
"されます(さらに多くのコンテンツが右側に表示されます)。これを「水平方向に拡"
"張」と考えることもできます。"

msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr ""
"これは通常、水平にスクロールする2Dゲーム(ランナーやプラットフォーマーなど)に"
"最適なオプションです。"

msgid ""
"**Stretch Aspect = Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"**Stretch Aspect = Expand**: 画面をストレッチするときはアスペクト比を維持しま"
"すが、ベースの幅も高さも維持しません。画面の縦横比に応じて、ビューポートは水"
"平方向(画面が基本サイズよりも広い場合)または垂直方向(画面が元のサイズよりも高"
"い場合)に大きくなります。"

msgid ""
"To support both portrait and landscape mode with a similar automatically "
"determined scale factor, set your project's base resolution to be a *square* "
"(1:1 aspect ratio) instead of a rectangle. For instance, if you wish to "
"design for 1280×720 as the base resolution but wish to support both portrait "
"and landscape mode, use 720×720 as the project's base window size in the "
"Project Settings."
msgstr ""
"ポートレート(縦長)とランドスケープ(横長)の両方に対応したい場合は、プロジェク"
"トの基本解像度を長方形ではなく*正方形*（縦横比1：1）に設定します。例えば、"
"1280×720を基本解像度としてポートレートとランドスケープの両方のモードに対応し"
"たい場合は、プロジェクト設定で720×720をプロジェクトのベースウィンドウサイズと"
"して設定します。"

msgid ""
"To allow the user to choose their preferred screen orientation at runtime, "
"remember to set **Display > Window > Handheld > Orientation** to ``sensor``."
msgstr ""
"実行時にユーザーが好きな画面の向きを選択できるようにするには、**Display > "
"Window > Handheld > Orientation** を ``sensor`` に設定することを忘れないよう"
"にしてください。"

msgid ""
"To configure the stretch aspect at runtime from a script, use the "
"``get_tree().root.content_scale_aspect`` property "
"(see :ref:`Window.content_scale_aspect "
"<class_Window_property_content_scale_aspect>` and "
"the :ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` enum)."
msgstr ""
"実行時にスクリプトからストレッチを設定するには、\\ "
"``get_tree().root.content_scale_aspect`` プロパティを使用します"
"( :ref:`Window.content_scale_aspect "
"<class_Window_property_content_scale_aspect>` およ"
"び :ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` を参照)。"

msgid "Stretch Scale"
msgstr "ストレッチスケール(Stretch Scale)"

msgid ""
"The **Scale** setting allows you to add an extra scaling factor on top of "
"what the **Stretch** options above already provide. The default value of "
"``1.0`` means that no additional scaling occurs."
msgstr ""
"**Scale** 設定では、上記の **Stretch** オプションが既に提供しているものに加え"
"て、さらにスケーリング係数を追加できます。 デフォルト値の ``1.0`` は、追加の"
"スケーリングが発生しないことを意味します。"

msgid ""
"For example, if you set **Scale** to ``2.0`` and leave **Stretch Mode** on "
"**Disabled**, each unit in your scene will correspond to 2×2 pixels on the "
"screen. This is a good way to provide scaling options for non-game "
"applications."
msgstr ""
"たとえば、\\ **Scale**\\ を ``2.0`` に設定し、\\ **Stretch Mode** を "
"**Disabled** のままにすると、シーンの各ユニットは画面上の2×2ピクセルに対応し"
"ます。これはゲームでないアプリケーションにスケーリング設定を提供するのに適し"
"ています。"

msgid ""
"If **Stretch Mode** is set to **canvas_items**, 2D elements will be scaled "
"relative to the base window size, then multiplied by the **Scale** setting. "
"This can be exposed to players to allow them to adjust the automatically "
"determined scale to their liking, for better accessibility."
msgstr ""
"**Stretch Mode** が **canvas_items** に設定されている場合、2D要素はベースウィ"
"ンドウサイズに伴ってスケーリングされ、その後 **Scale** 設定値が乗算されます。"
"これによりプレイヤーは自動決定されたスケールを好みで調整できるようになり、ア"
"クセシビリティが向上します。"

msgid ""
"If **Stretch Mode** is set to **viewport**, the viewport's resolution is "
"divided by **Scale**. This makes pixels look larger and reduces rendering "
"resolution (with a given window size), which can improve performance."
msgstr ""
"**Stretch Mode** が **viewport** に設定されている場合、ビューポートの解像度"
"は **Scale** で除算されます。これによりピクセルが大きく見え、(ウィンドウサイ"
"ズが一定ならば)レンダリング解像度は低下します。これによりパフォーマンスが向上"
"する可能性があります。"

msgid ""
"To configure the stretch scale at runtime from a script, use the "
"``get_tree().root.content_scale_factor`` property "
"(see :ref:`Window.content_scale_factor "
"<class_Window_property_content_scale_factor>`)."
msgstr ""
"実行時にスクリプトからストレッチを設定するには、\\ "
"``get_tree().root.content_scale_factor`` プロパティを使用します"
"( :ref:`Window.content_scale_factor "
"<class_Window_property_content_scale_factor>` を参照)。"

msgid ""
"You can also adjust the scale at which the default project theme is "
"generated using the **GUI > Theme > Default Theme Scale** project setting. "
"This can be used to create more logically-sized UIs at base resolutions that "
"are significantly higher or lower than the default. However, this project "
"setting cannot be changed at runtime, as its value is only read once when "
"the project starts."
msgstr ""
"プロジェクト設定の **GUI > テーマ > デフォルトのテーマスケール** を変更するこ"
"とで、デフォルトのプロジェクトテーマのスケールを調整可能です。これにより、デ"
"フォルトから大幅に高いまたは低い解像度においても、より理に適ったサイズのUIを"
"作成できます。ただし、このプロジェクト設定は実行中に変更できません。この値は"
"プロジェクト起動時に一度だけ読み込まれるためです。"

msgid "Stretch Scale Mode"
msgstr "ストレッチスケールモード(Stretch Scale Mode)"

msgid ""
"The following settings are recommended to support multiple resolutions and "
"aspect ratios well."
msgstr ""
"複数の解像度やアスペクト比を適切にサポートするには、次の設定をお勧めします。"

msgid "Desktop game"
msgstr "デスクトップゲーム"

msgid "Mobile game in portrait mode"
msgstr "縦向き表示のモバイルゲーム"

msgid "Non-game application"
msgstr "ゲーム以外のアプリケーション"

msgid "Reducing aliasing on downsampling"
msgstr "ダウンサンプリングでのエイリアスの削減"

msgid ""
"If the game has a very high base resolution (e.g. 3840×2160), aliasing might "
"appear when downsampling to something considerably lower like 1280×720."
msgstr ""
"ゲームの基本解像度が非常に高い場合(3840 x 2160など)、1280 x 720などのかなり低"
"い値にダウンサンプリングすると、エイリアスが現れる場合があります。"

msgid "Handling aspect ratios"
msgstr "アスペクト比の処理"

msgid ""
"Once scaling for different resolutions is accounted for, make sure that your "
"*user interface* also scales for different aspect ratios. This can be done "
"using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers "
"<doc_gui_containers>`."
msgstr ""
"さまざまな解像度のスケーリングが考慮されたら、\\ *ユーザーインターフェイス"
"*\\ もさまざまなアスペクト比に合わせてスケーリングするようにしてください。 こ"
"れは :ref:`anchors <doc_size_and_anchors>` および/または :ref:`containers "
"<doc_gui_containers>` を使用して実行できます。"

msgid "Field of view scaling"
msgstr "視野のスケーリング"

msgid ""
"The 3D Camera node's **Keep Aspect** property defaults to the **Keep "
"Height** scaling mode (also called *Hor+*). This is usually the best value "
"for desktop games and mobile games in landscape mode, as widescreen displays "
"will automatically use a wider field of view."
msgstr ""
"3Dカメラノードの **Keep Aspect** プロパティは、デフォルトで **Keep Height** "
"スケーリングモード(*Hor+* とも呼ばれます)になります。 ワイドスクリーンディス"
"プレイは自動的に広い視野を使用するため、これは通常、デスクトップモードや横長"
"モードのモバイルゲームに最適な値です。"

msgid ""
"However, if your 3D game is intended to be played in portrait mode, it may "
"make more sense to use **Keep Width** instead (also called *Vert-*). This "
"way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use "
"a *taller* field of view, which is more logical here."
msgstr ""
"ただし、3Dゲームをポートレートモードでプレイする場合は、代わりに **Keep "
"Width** (*Vert-* とも呼ばれます)を使用する方が合理的です。 このように、アスペ"
"クト比が16:9(例: 19:9)よりも高いスマートフォンは、\\ *taller* の視野を使用し"
"ますが、これはここではより論理的です。"
