#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "最適化"

msgid "Optimizing 3D performance"
msgstr "3Dパフォーマンスの最適化"

msgid "Culling"
msgstr "カリング"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot はビューポート外のオブジェクトがレンダリングされないように、ビューフラ"
"スタムカリングを自動的に実行します。これは狭い領域で行われるゲームではうまく"
"機能しますが、より大きなレベルではすぐに問題が発生する可能性があります。"

msgid "Occlusion culling"
msgstr "オクルージョンカリング"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"たとえば街を歩いていると、自分が歩いている通りにある建物が数棟と、空と頭上を"
"飛ぶ鳥が数羽しか見えないかもしれません。しかし単純なレンダラーでは、街全体を"
"見ることができます。目の前の建物だけでなく、その後ろの通り、その通りの人々、"
"その後ろの建物もレンダリングします。すぐに目に見えるものの 10 倍、100 倍をレ"
"ンダリングしようとする状況に陥ってしまいます。"

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"Z バッファにより、GPU は前面にあるオブジェクトのみをシェーディングできるた"
"め、状況は見た目ほど悪くはありません。これは *深度プレパス* と呼ばれ、Godot "
"で Forward+ または互換性レンダリング方法を使用する場合にデフォルトで有効にな"
"ります。ただし不要なオブジェクトによってパフォーマンスは低下し続けます。"

msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"場合によっては、レベル デザインを調整して、オクルージョンの機会を増やす必要が"
"あります。たとえば、プレイヤーが遠くを見すぎないようにするために壁を追加する"
"必要がある場合がありますが、これにより、オクルージョンカリングの機会が失わ"
"れ、パフォーマンスが低下します。"

msgid "Transparent objects"
msgstr "半透明なオブジェクト"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"前述したように、Godotはパフォーマンスを向上させるために、オブジェクト"
"を :ref:`Material <class_Material>` と :ref:`Shader <class_Shader>` で並べ替"
"えます。ただし、これは半透明なオブジェクトでは実行できません。半透明なオブ"
"ジェクトは後ろから前にレンダリングして、作業の背後にあるものとブレンドしま"
"す。その為、半透明なオブジェクトを最小限に抑えるようにしてください！オブジェ"
"クトに透明度のある小さなセクションがある場合は、そのセクションを別のマテリア"
"ルにしてください。"

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr ""
"詳細については :ref:`GPU optimizations <doc_gpu_optimization>` ページを参照し"
"てください。"

msgid "Level of detail (LOD)"
msgstr "レベルオブディテール (LOD)"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"特に遠くから見たとき **複雑なジオメトリをより単純なバージョンに置き換える** "
"のが、状況によっては良い場合があります。エンド ユーザーは、おそらく大きな違い"
"はわかりません。遠くにある多数の木を眺めてみましょう。さまざまな距離でモデル"
"を置き換えるには、いくつかの戦略があります。低ポリゴンモデルを使用すること"
"も、ビルボードを使用してより複雑なジオメトリをシミュレートすることもできま"
"す。"

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 では、LODを制御する方法がいくつか提供されています。"

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr ":ref:`doc_mesh_lod` を使用したメッシュインポートの自動アプローチ。"

msgid ""
"A manual approach configured in the 3D node "
"using :ref:`doc_visibility_ranges`."
msgstr ""
":ref:`doc_visibility_ranges` を使用して 3D ノードで設定する手動アプローチ。"

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""
":ref:`デカール <doc_using_decals>` と :ref:`ライト <doc_lights_and_shadows>` "
"も、それぞれの **Distance Fade** プロパティを使用してLODの恩恵を受けることが"
"できます。"

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""
"これらのアプローチは個別に使用することもできますが、組み合わせて使用すると最"
"も効果的です。たとえば可視範囲を設定して、プレイヤーから遠すぎて気付かない"
"パーティクルエフェクトを非表示にすることができます。同時にメッシュ LOD を利用"
"して、パーティクル エフェクトのメッシュを離れた場所ではLODを低くしてレンダリ"
"ングすることもできます。"

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr ""
"可視範囲は、遠くのジオメトリの*偽物*を設定するのにも適した方法です (以下を参"
"照)。"

msgid "Billboards and imposters"
msgstr "ビルボードとインポスター"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, "
"see :ref:`doc_gpu_optimization`)."
msgstr ""
"半透明を使用して LOD に対処する最もシンプルな方法はビルボードです。たとえば "
"1 つの透明な四角形を使用して、遠くにある木を表すことができます。もちろん多数"
"の木が互いに正面に並んでいる場合を除き、レンダリングにかかるコストは非常に低"
"くなります。この場合、半透明によってフィル レートが損なわれる可能性がありま"
"す (フィルレートの詳細については、:ref:`doc_gpu_optimization` を参照してくだ"
"さい)。"

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"別の方法としては、1 本の木だけではなく、複数の木をグループとしてレンダリング"
"する方法があります。これはゲーム内でエリアが見えていても物理的に近づくことが"
"できない場合に特に効果的です。"

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"オブジェクトのビューをさまざまな角度で事前にレンダリングすることで、インポス"
"ターを作成できます。またはさらに一歩進んで、オブジェクトのビューをテクスチャ"
"上に定期的に再レンダリングし、インポスターとして使用することもできます。離れ"
"た場所では、ビューの角度を大幅に変更するには、ビューアーをかなりの距離移動さ"
"せる必要があります。これは動作させるのが複雑になる可能性がありますが、作成し"
"ているプロジェクトの種類によっては価値がある場合があります。"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"複数の同一のオブジェクトを同じ場所または近くに描画する必要がある場合は、代わ"
"りに :ref:`MultiMesh <class_MultiMesh>` を使用してみてください。 MultiMesh を"
"使用すると、パフォーマンス コストをほとんどかけずに何千ものオブジェクトを描画"
"できるため、群れ、草、粒子など、何千もの同一オブジェクトがあるあらゆるものに"
"最適です。"

msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr ""
":ref:`MultiMesh の使用 <doc_using_multimesh>` ドキュメントも参照してくださ"
"い。"

msgid "Bake lighting"
msgstr "ライトの焼き込み (ベイク)"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"オブジェクトのライティングは、最もコストのかかるレンダリング操作の 1 つです。"
"リアルタイムライティング、シャドウ (特に複数のライト)、および :ref:`グローバ"
"ルイルミネーション <doc_introduction_to_global_illumination>` は特にコストが"
"かかります。これらは、低電力のモバイル デバイスでは処理しきれないほどの負荷が"
"かかる可能性があります。"

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**ライティングの焼き込みを検討してください** (特にモバイルの場合)。見た目は素"
"晴らしいですが、動的ではないという欠点があります。しかし場合によっては、これ"
"は行う価値のあるトレードオフです。"

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""
"ライトマップの焼き込みについては、:ref:`doc_using_lightmap_gi` を参照してくだ"
"さい。最高のパフォーマンスを得るには、ライトのベイクモードをデフォルトの "
"**Dynamic** ではなく **Static** に設定する必要があります。これにより、ベイク"
"されたライティングを持つメッシュ上のリアルタイムライティングがスキップされま"
"す。"

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for "
"the :ref:`class_DirectionalLight3D` node, and use **Static** for most (if "
"not all) omni and spot lights."
msgstr ""
"**Static** ベイクモードのライトの欠点は、ベイクされたライトのあるメッシュに"
"シャドウを落とすことができないことです。これにより、屋外環境や動的オブジェク"
"トのあるシーンが平坦に見えることがあります。パフォーマンスと品質のバランスを"
"とるには、:ref:`class_DirectionalLight3D` ノードに **Dynamic** を使用し、ほと"
"んど (すべてではないにしても) のオムニライトとスポットライトに **Static** を"
"使用します。"

msgid "Animation and skinning"
msgstr "アニメーションとスキニング"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"アニメーションや頂点アニメーション (スキニングやモーフィングなど) は、一部の"
"プラットフォームでは非常にコストがかかる場合があります。アニメーションモデル"
"のポリゴン数を大幅に減らすか、画面に表示されるアニメーションモデルの数を制限"
"する必要がある場合があります。遠くにあるメッシュや隠れたメッシュのアニメー"
"ションレートを下げるか、プレイヤーに気付かないようにアニメーションを完全に一"
"時停止することもできます。"

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` "
"and :ref:`class_VisibleOnScreenNotifier3D` nodes can be useful for this "
"purpose."
msgstr ""
"この目的には、:ref:`class_VisibleOnScreenEnabler3D` ノード"
"と :ref:`class_VisibleOnScreenNotifier3D` ノードが役立ちます。"

msgid "Large worlds"
msgstr "大規模なワールド"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr ""
"大規模なワールドを作成する場合は、小規模なゲームで慣れ親しんでいるものとは異"
"なる考慮事項があります。"

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大規模なワールドは、ワールド内を移動する際にオンデマンドでロードできるタイル"
"に構築する必要がある場合があります。これにより、メモリの使用が手に負えなくな"
"るのを防ぎ、必要な処理をローカルエリアに制限できます。"

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved "
"using :ref:`doc_large_world_coordinates`. If using large world coordinates "
"is not an option, you may be able to use techniques such as orienting the "
"world around the player (rather than the other way around), or shifting the "
"origin periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"大きなワールドでは浮動小数点エラーが原因でレンダリングや物理の不具合が発生す"
"ることもあります。これは :ref:`doc_large_world_coordinates` を使って解決でき"
"ます。大きなワールド座標を使用できない場合は、プレイヤーを中心にワールドを方"
"向付ける (その逆ではなく) か、定期的に原点を移動して ``Vector3(0, 0, 0)`` を"
"中心に維持するなどのテクニックを使用できる場合があります。"
