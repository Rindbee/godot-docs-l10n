#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "GPUの最適化"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"グラフィックス技術の進化に対する需要により、グラフィックスのボトルネックに遭"
"遇することはほぼ確実です。これらの一部は CPU 側で発生する可能性があり、たとえ"
"ば、Godot エンジン内でのオブジェクトのレンダリング準備のための計算などでも発"
"生します。CPU上のボトルネックは GPU に渡す命令を分類するグラフィックスドライ"
"バーや、これらの命令の転送でも発生する可能性があります。そして最後に、GPU 自"
"体でもボトルネックは発生します。"

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"レンダリングでボトルネックが発生する場所は、ハードウェアによって大きく異なり"
"ます。特にモバイル GPU では、デスクトップでは簡単に実行できるシーンでも問題が"
"発生する可能性があります。"

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"GPU のボトルネックを理解して調査することは、CPU の状況とは少し異なります。こ"
"れは多くの場合、GPU に与える命令を変更することによってのみ間接的にパフォーマ"
"ンスを改善できるからです。また、測定を行うことがより困難な場合があります。多"
"くの場合、パフォーマンスを測定する唯一の方法は、各フレームのレンダリングに費"
"やされる時間の変化を調べることです。"

msgid "Draw calls, state changes, and APIs"
msgstr "ドローコール、ステート変更、API"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"次のセクションはエンドユーザーには関係ありませんが、後のセクションに関連する"
"背景情報を理解するのに役立ちます。"

msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"Godot はグラフィックス API (Vulkan、OpenGL、OpenGL ES、WebGL など) を介して "
"GPU に命令を送信します。関連する通信とドライバーのアクティビティは、特に "
"OpenGL、OpenGL ES、WebGL では、かなりコストがかかる可能性があります。ドライ"
"バーと GPU の最適な方法でこれらの命令を実行できれば、パフォーマンスは大幅に向"
"上できます。"

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"OpenGL のほぼすべての API コマンドでは、GPU が正しい状態で実行されることを確"
"認するために、ある程度の検証が必要です。一見単純なコマンドでも、舞台裏で大量"
"の加工処理が発生する可能性があります。したがって、目標はこれらの命令を最小限"
"に減らし、類似のオブジェクトをできるだけグループ化して、一緒にレンダリングで"
"きるようにするか、これらのコストのかかるステート変更を最小限に抑えることで"
"す。"

msgid "2D batching"
msgstr "2Dバッチ処理"

msgid "3D batching"
msgstr "3Dバッチ処理"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"3D でもドローコールとステート変更を最小限に抑えることを目指しています。ただ"
"し、複数のオブジェクトを 1 回の描画呼び出しにまとめるのは難しくなります。3D "
"メッシュは数百または数千の三角形で構成される傾向があり、大規模なメッシュをリ"
"アルタイムで結合するのは非常に高コストです。メッシュあたりの三角形の数が増え"
"ると、結合にかかるコストがすぐにメリットを上回ります。より優れた代替手段は、"
"**事前にメッシュを結合** (互いに関連した静的メッシュ) することです。これは"
"アーティストが行うことも、アドオンを使用して Godot 内でプログラム的に行うこと"
"もできます。"

msgid ""
"For more information on 3D specific optimizations, "
"see :ref:`doc_optimizing_3d_performance`."
msgstr ""
"3D 固有の最適化の詳細については、 :ref:`doc_optimizing_3d_performance` を参照"
"してください。"

msgid "Reuse shaders and materials"
msgstr "シェーダーとマテリアルの再利用"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"Godot レンダラーは、既存のレンダラーとは少し異なります。GPU の状態変化を可能"
"な限り最小限に抑えるように設計されています。:ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` は、同様のシェーダーを必要とするマテリアルの再利"
"用に優れています。カスタム シェーダーを使用する場合は、可能な限り再利用するよ"
"うにしてください。Godot の優先順位は次のとおりです。"

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**マテリアルの再利用**: シーン内の異なるマテリアルが少ないほど、レンダリング"
"は高速になります。シーンに大量のオブジェクト (数百または数千) がある場合は、"
"マテリアルを再利用するか、アトラスを使用してテクスチャの変更量を減らしましょ"
"う。"

msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**シェーダーの再利用:** マテリアルを再利用できない場合は、少なくともシェー"
"ダーを再利用してみてください。注: StandardMaterial3D は、パラメータが異なって"
"いても、同じ構成 (チェックボックスで有効または無効にされる機能) のシェーダー"
"を自動的に再利用します。"

msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"たとえば、シーンに 20,000 個のオブジェクトがあり、それぞれに 20,000 個の異な"
"るマテリアルがある場合、レンダリングは遅くなります。同じシーンに 20,000 個の"
"オブジェクトがあり、使用するマテリアルが 100 個だけの場合、レンダリングは非常"
"に速くなります。"

msgid "Pixel cost versus vertex cost"
msgstr "ピクセル計算コスト vs 頂点計算コスト"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"モデル内のポリゴン数が少ないほどレンダリングが速くなると聞いたことがあるかも"
"しれません。これは実際には相対的なものであり、多くの要因に影響されます。"

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"現代の PC やコンソールでは、頂点の計算コストは低くなっています。GPU はもとも"
"と三角形のみをレンダリングしていました。つまり、すべてのフレームで次のように"
"なります:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr ""
"すべての頂点は CPU によってトランスフォーム処理される必要がありました (クリッ"
"ピングを含む)。"

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr "すべての頂点をメインメモリから GPU メモリに送信する必要がありました。"

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"現在、これらすべてが GPU 内で処理されるため、パフォーマンスが大幅に向上してい"
"ます。3D アーティストは、ポリゴン数のパフォーマンスについて誤った認識を持って"
"いることがよくあります。これは 3D DCCソフト (Blender、3ds Max など) では、ジ"
"オメトリを編集するために CPU メモリ内に保持する必要があり、実際のパフォーマン"
"スが低下するためです。ゲーム エンジンは GPU に大きく依存するため、多くの三角"
"形をより効率的にレンダリングできます。"

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"モバイル デバイスでは、話は異なります。PC やコンソールの GPU は、電力網から必"
"要なだけの電力を引き出すことができる強力なモンスターです。モバイル GPU は小さ"
"なバッテリーに制限されているため、電力効率を高める必要があります。"

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"モバイル GPU は効率を上げるために、*オーバードロー* を回避しようとします。"
"オーバードローは画面上の同じピクセルが何回もレンダリングされるときに発生しま"
"す。建物がいくつかある町を想像してください。GPU は描画するまで何が見えていて"
"何が隠れているかを知りません。たとえば家が描画された後、その前に別の家が描画"
"されることがあります (つまり、同じピクセルに対して 2 回のレンダリングが行われ"
"たことになります)。PC の GPU は通常、この点をあまり気にせず、ハードウェアにピ"
"クセル プロセッサを追加してパフォーマンスを向上させます (これにより、消費電力"
"も増加します)。"

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"モバイル デバイスでは電力を多く使うことはできないため、画面をグリッドに分割す"
"る *タイル ベースレンダリング* と呼ばれる手法が採用されています。各セルには描"
"画された三角形のリストが保持され、深度によって並べ替えられるため、*オーバード"
"ロー* を最小限に抑えることができます。この手法によりパフォーマンスが向上し、"
"電力消費が削減されますが、頂点のパフォーマンスが低下します。その結果、描画処"
"理できる頂点と三角形の数は少なくなります。"

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"さらにタイルベースのレンダリングは、画面の小さな領域に多くのジオメトリを持つ"
"小さなオブジェクトがある場合に問題が生じます。これにより、モバイル GPU は 1 "
"つの画面タイルに多大な負荷をかけることになり、他のすべてのセルはフレームを表"
"示する前にタイルの完了を待たなければならないため、パフォーマンスが大幅に低下"
"します。"

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"まとめると、モバイルでは頂点の数を気にする必要はありませんが、**画面の小さな"
"部分に頂点が集中しないようにする** 必要があります。キャラクター、NPC、乗り物"
"などが遠くにある場合 (つまり小さく見える場合) は、代わりに小さい詳細レベル "
"(LOD) モデルを使用します。また、デスクトップ GPU でも画面上のピクセル サイズ"
"よりも小さい三角形は避けることをお勧めします。"

msgid "Pay attention to the additional vertex processing required when using:"
msgstr "以下のケースで必要な追加の頂点処理にも注意してください:"

msgid "Skinning (skeletal animation)"
msgstr "スキニング (骨格アニメーション)"

msgid "Morphs (shape keys)"
msgstr "モーフ (シェイプキー)"

msgid "Vertex-lit objects (common on mobile)"
msgstr "頂点ライティング (モバイルでは一般的)"

msgid "Pixel/fragment shaders and fill rate"
msgstr "ピクセル/フラグメントシェーダーとフィルレート"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"頂点処理とは対照的に、フラグメント (ピクセル単位) のシェーディングのコスト"
"は、長年にわたって劇的に増加しています。画面解像度は増加しており、古い "
"640×480 VGA 画面の面積は 307,200 ピクセルですが、4K 画面の面積は 8,294,400 ピ"
"クセルとなり、面積は 27 倍です。また、フラグメント シェーダーの複雑さも爆発的"
"に増加しています。物理ベースのレンダリングでは、フラグメントごとに複雑な計算"
"が必要になります。"

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"プロジェクトがフィルレート制限を受けているかどうかは、非常に簡単なテストで確"
"認できます。V-Sync をオフにして、1 秒あたりのフレーム数が制限されないように"
"し、大きなウィンドウで実行した場合と非常に小さなウィンドウで実行した場合の 1 "
"秒あたりのフレーム数を比較します。シャドウを使用する場合は、同様にシャドウ"
"マップのサイズを小さくするとメリットが得られることもあります。通常、小さな"
"ウィンドウを使用すると FPS がかなり増加します。これはフィルレートがある程度制"
"限されていることを示しています。一方、FPS がほとんどまたはまったく増加しない"
"場合は、ボトルネックは別の場所にあります。"

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the "
"number and size of textures used. Also, when using non-unshaded particles, "
"consider forcing vertex shading in their material to decrease the shading "
"cost."
msgstr ""
"フィルレートが制限されているプロジェクトでは、GPU が行う作業量を減らすことで"
"パフォーマンスを向上させることができます。これを行うには、シェーダーを簡素化"
"するか (:ref:`StandardMaterial3D <class_StandardMaterial3D>` を使用している場"
"合は、コストのかかるオプションをオフにします)、使用するテクスチャの数とサイズ"
"を減らします。またシェーディングされていないパーティクルを使用する場合は、マ"
"テリアルで頂点シェーディングを強制してシェーディングコストを削減することを検"
"討してください。"

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""
":ref:`doc_variable_rate_shading` がサポートされているハードウェアでは、最終画"
"像のエッジの鮮明さに影響を与えずにシェーディング処理コストを削減できます。"

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr ""
"**モバイルデバイスをターゲットにする場合は、合理的に使用できる最もシンプルな"
"シェーダーの使用を検討してください。**"

msgid "Reading textures"
msgstr "テクスチャの読み取り"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"フラグメントシェーダーのもう 1 つの要素は、テクスチャの読み取りコストです。特"
"に1つのフラグメントシェーダーで複数のテクスチャを読み取る場合は、コストのかか"
"る操作です。またフィルタリングによってさらに速度が低下する可能性があることも"
"考慮してください (ミップマップを使ったトリリニアフィルタリングと平均化)。テク"
"スチャの読み取りは電力消費の面でもコストが高く、モバイルでは大きな問題となり"
"ます。"

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**サードパーティのシェーダーを使用する場合、または独自のシェーダーを作成する"
"場合は、テクスチャの読み取りをできるだけ少なくするアルゴリズムを使用するよう"
"にしてください。**"

msgid "Texture compression"
msgstr "テクスチャ圧縮"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"Godotは、3Dモデルをインポートする際にテクスチャを Video RAM (VRAM) 圧縮するこ"
"とができます。Video RAM 圧縮は保存時のサイズの点で PNG や JPG ほど効率的では"
"ありませんが、大きなテクスチャを描画する場合のパフォーマンスが大幅に向上しま"
"す。"

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr ""
"これはテクスチャ圧縮の主な目的がメモリと GPU 間の帯域幅の削減であるためです。"

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"3Dでは、オブジェクトの形状は、テクスチャよりもジオメトリによるところが大きい"
"ので、普通は圧縮しても見分けはつきません。2Dの場合、圧縮はテクスチャ内に描か"
"れた形状も変化させてしまうため、違いがより目立つようになります。"

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"注意すべき点として、Androidデバイスでは透過のあるテクスチャの圧縮はサポートさ"
"れていません(非透過のみ)ので、気をつけてください。"

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"3Dの場合でも、「ピクセルアート」テクスチャではVRAM圧縮を無効にする必要があり"
"ます。解像度が低いとパフォーマンスが大幅に向上するわけでもなく、描画の見た目"
"に悪影響を与えるためです。"

msgid "Post-processing and shadows"
msgstr "ポストプロセッシングとシャドウ"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"ポストプロセスエフェクトとシャドウも、フラグメントシェーディングのアクティビ"
"ティの観点からはコストがかかる可能性があります。常にさまざまなハードウェアで"
"これらの影響をテストしてください。"

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"シャドウマップの書き込みと読み取りの両方において、 **シャドウマップのサイズを"
"小さくするとパフォーマンスが向上します** 。さらにシャドウのパフォーマンスを向"
"上させる最善の方法は、できるだけ多くのライトとオブジェクトのシャドウをオフに"
"することです。小さいまたは遠いオムニライト/スポットライトでは、多くの場合、"
"シャドウを無効にしても視覚的な影響はわずかです。"

msgid "Transparency and blending"
msgstr "半透明とブレンド"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"半透明なオブジェクトは、レンダリング効率に関して特に問題があります。不透明な"
"オブジェクト (特に 3D) は、基本的に任意の順序でレンダリングでき、Z バッファに"
"よって最前面のオブジェクトのみがシェーディングされます。半透明なオブジェクト"
"またはブレンドされるオブジェクトは異なります。ほとんどの場合、Z バッファに依"
"存できず、正しく見えるようにするには「描画の順序」を考慮し、後ろから前へレン"
"ダリングする必要があります。"

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"半透明なオブジェクトは、他の半透明なオブジェクトがその上に描画される場合で"
"も、すべてのアイテムを描画する必要があるため、フィルレートに特に悪影響を及ぼ"
"します。"

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"不透明なオブジェクトは、これを行う必要はありません。最初に Z バッファにのみ書"
"き込み、次に特定のピクセルの最前面にあるオブジェクトのフラグメントに対しての"
"みフラグメントシェーダを実行することができます。"

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"複数の半透明オブジェクトが重なり合う場合に特にコストがかかります。通常これら"
"のフィルレート要件を最小限に抑えるには、半透明領域をできるだけ小さくする方が"
"よいでしょう。特にフィルレートが非常にコストがかかるモバイルではそうです。実"
"際多くの状況では、より複雑な不透明なジオメトリをレンダリングする方が、半透明"
"を使用して「ごまかす」よりも速くなることがあります。"

msgid "Multi-platform advice"
msgstr "マルチプラットフォームのアドバイス"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"複数のプラットフォームでリリースすることを目指している場合は、すべてのプラッ"
"トフォーム、特にモバイルで *早期に* 、そして *頻繁に* テストしてください。デ"
"スクトップでゲームを開発し、最後の瞬間にモバイルに移植しようとすると、大惨事"
"を招くことになります。"

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"一般的にゲームは最低限の共通基準で設計し、その後より強力なプラットフォーム向"
"けにオプションの機能強化を追加する必要があります。たとえばデスクトップ プラッ"
"トフォームとモバイル プラットフォームの両方をターゲットにする場合は、両方に互"
"換性レンダラーを使用するとよいでしょう。"

msgid "Mobile/tiled renderers"
msgstr "モバイル / タイルベースレンダラー"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"上で説明したように、モバイルデバイスの GPU はデスクトップの GPU とは大きく異"
"なる方法で動作します。ほとんどのモバイルデバイスはタイルベースレンダラーを使"
"用します。タイルベースレンダラーは画面を超高速キャッシュ メモリに収まる通常サ"
"イズのタイルに分割し、メインメモリへの読み取り/書き込み操作の回数を減らしま"
"す。"

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"ただし欠点もあります。タイルベースレンダリングでは、特定のテクニックの実行が"
"はるかに複雑になり、コストも高くなります。異なるタイルでのレンダリング結果"
"や、以前の操作の結果が保持されることに依存するタイルは、非常に遅くなる可能性"
"があります。シェーダー、ビューポートテクスチャ、および後処理のパフォーマンス"
"をテストするときは、細心の注意を払ってください。"
