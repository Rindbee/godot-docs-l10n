#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Reducing stutter from shader (pipeline) compilations"
msgstr "シェーダーコンパイルによるスタッターの削減"

msgid ""
"Pipeline compilation, also commonly known as shader compilation, is an "
"expensive operation required by the engine to be able to draw any kind of "
"content with the GPU."
msgstr ""
"パイプラインコンパイル (一般にシェーダーコンパイルとも呼ばれる) は、エンジン"
"が GPU を使用してあらゆる種類のコンテンツを描画できるようにするために必要なコ"
"ストのかかる操作です。"

msgid ""
"Flowchart showing the entire compilation process for a shader: VisualShader "
"and Standard Material to Godot Shading Language to GLSL to Intermediate "
"Format (SPIR-V) to Pipeline. Shader Compilation is the GLSL to Intermediate "
"Format step. Pipeline Compilation is the Intermediate Format to Pipeline "
"step."
msgstr ""
"シェーダーのコンパイルプロセス全体を示すフローチャート: VisualShader, "
"Standard Material → Godot Shading Language → GLSL → 中間形式 (SPIR-V) → パイ"
"プライン。シェーダーのコンパイルは GLSL から中間形式への変換処理です。そして"
"パイプラインのコンパイルは中間形式からパイプラインへの変換処理です。"

msgid ""
"Shaders and materials in Godot go through several steps before they can be "
"run by the GPU."
msgstr ""
"Godot のシェーダーとマテリアルは、GPU で実行される前にいくつかのステップを経"
"ます。"

msgid ""
"In more precise terms, *shader compilation* involves the translation of the "
"GLSL code that Godot generates into an intermediate format that can be "
"shared across systems (such as SPIR-V when using Vulkan). However, this "
"format can't be used by the GPU directly."
msgstr ""
"より正確に言えば *シェーダーコンパイル* では、Godot が生成した GLSL コードを"
"システム間で共有できる中間形式 (Vulkan を使用する場合の SPIR-V など) に変換し"
"ます。ただし、この形式は GPU で直接使用することはできません。"

msgid ""
"*Pipeline compilation* is the step where the GPU driver converts the "
"intermediate shader format (the result from shader compilation) to something "
"the GPU can actually use for rendering. Drivers usually keep a cache of "
"pipelines stored somewhere in the system to avoid repeating the process "
"every time a game is run. This cache is usually deleted when the driver is "
"updated."
msgstr ""
"*パイプラインコンパイル* は、GPU ドライバーが中間シェーダーフォーマット "
"(シェーダーコンパイルの結果) を GPU が実際にレンダリングに使用できる形式に変"
"換するステップです。通常ドライバーはゲームが実行されるたびにプロセスが繰り返"
"されないように、パイプラインのキャッシュをシステムのどこかに保存します。この"
"キャッシュはドライバーが更新されると削除されます。"

msgid ""
"Pipelines contain more information than just the shader code, which means "
"that for each shader, there can be dozens of pipelines or more! This makes "
"it difficult for an engine to compile them ahead of time, both because it "
"would be very slow, and because it would take up a lot of memory. On top of "
"that, this step can only be performed on the user's system and it is very "
"tough to share the result between users unless they have the exact same "
"hardware and driver version."
msgstr ""
"パイプラインにはシェーダーコード以外の情報も含まれているため、各シェーダーに"
"は数十以上のパイプラインが存在する可能性があります。そのため、エンジンが事前"
"にパイプラインをコンパイルするのは困難です。非常に遅くなり、大量のメモリを消"
"費するからです。さらに、この手順はユーザーのシステムでのみ実行でき、ハード"
"ウェアとドライバーのバージョンがまったく同じでない限り、ユーザー間で結果を共"
"有するのは非常に困難です。"

msgid ""
"Before Godot 4.4, there was no solution to pipeline compilation other than "
"generating them when an object shows up inside the camera's view, leading to "
"the infamous *shader stutter* or hitches that only occur during the first "
"playthrough. **With Godot 4.4, new mechanisms have been introduced to "
"mitigate stutters from pipeline compilation.**"
msgstr ""
"Godot 4.4 より前は、オブジェクトがカメラのビュー内に表示されたときにパイプラ"
"インコンパイルを生成する以外にパイプラインコンパイルの解決策はなく、最初のプ"
"レイスルー中にのみ発生する悪名高い *シェーダースタッター* 、またはヒッチにつ"
"ながっていました。**Godot 4.4 ではパイプラインコンパイルによるスタッターを軽"
"減するための新しいメカニズムが導入されました。**"

msgid ""
"**Ubershaders**: Godot makes use of specialization constants, a feature that "
"allows the driver to optimize a pipeline's code around a set of parameters "
"such as lighting, shadow quality, etc. Specialization constants are used to "
"optimize a shader by limiting unnecessary features. Changing a "
"specialization constant requires recompiling the pipeline. Ubershaders are a "
"special version of the shader that are able to change these constants while "
"rendering, which means Godot can precompile just one pipeline ahead of time "
"and compile the more optimized versions on the background during gameplay. "
"This reduces the amount of pipelines that need to be created significantly."
msgstr ""
"**UberShader**: Godot は特殊化定数を使用します。これはドライバーがライト、"
"シャドウの品質などの一連のパラメータを中心にパイプラインのコードを最適化でき"
"るようにする機能です。特殊化定数は、不要な機能を制限してシェーダーを最適化す"
"るために使用されます。特殊化定数を変更するには、パイプラインを再コンパイルす"
"る必要があります。Ubershaders はレンダリング中にこれらの定数を変更できる"
"シェーダーの特別なバージョンです。つまり Godot は事前に 1 つのパイプラインだ"
"けをプリコンパイルし、ゲームプレイ中にバックグラウンドでより最適化されたバー"
"ジョンをコンパイルできます。これにより作成する必要があるパイプラインの量が大"
"幅に削減されます。"

msgid ""
"**Pipeline precompilation**: By using ubershaders, the engine can precompile "
"pipelines ahead of time in multiple places such as when meshes are loaded or "
"when nodes are added to the scene. By being part of the resource loading "
"process, pipelines can even be precompiled in multiple background threads if "
"possible during loading screens or even gameplay."
msgstr ""
"**パイプラインのプリコンパイル**: UberShader を使用することで、エンジンはメッ"
"シュがロードされるときやノードがシーンに追加されるときなど、複数の場所でパイ"
"プラインを事前にプリコンパイルできます。パイプラインはリソースのロード プロセ"
"スの一部であるため、可能であれば、ロード画面中やゲームプレイ中に複数のバック"
"グラウンドスレッドでプリコンパイルすることもできます。"

msgid ""
"Starting in Godot 4.4, Godot will detect which pipelines are needed and "
"precompile them at load-time. This detection system is mostly automatic, but "
"it relies on the RenderingServer seeing evidence of all shaders, meshes, or "
"rendering features at load-time. For example, if you load a mesh and shader "
"while the game is running, the pipeline for that mesh/shader combination "
"won't be compiled until the mesh/shader is loaded. Similarly, things like "
"enabling MSAA, or instancing a VoxelGI node while the game is running will "
"trigger pipeline recompilations."
msgstr ""
"Godot 4.4 以降、Godot は必要なパイプラインを検出し、ロード時にそれらをプリコ"
"ンパイルします。この検出システムはほぼ自動ですが、ロード時にすべてのシェー"
"ダー、メッシュ、またはレンダリング機能の証拠を RenderingServer が確認すること"
"に依存しています。たとえば、ゲームの実行中にメッシュとシェーダーをロードする"
"と、そのメッシュ/シェーダーの組み合わせのパイプラインは、メッシュ/シェーダー"
"がロードされるまでコンパイルされません。同様に MSAA を有効にしたり、ゲームの"
"実行中に VoxelGI ノードをインスタンス化したりすると、パイプラインの再コンパイ"
"ルがトリガーされます。"

msgid "Pipeline precompilation monitors"
msgstr "パイプライン事前コンパイルのモニター"

msgid ""
"Compiling pipelines ahead of time is the main mechanism Godot uses to "
"mitigate shader stutters, but it's not a perfect solution. Being aware of "
"the situations that can lead to pipeline stutters can be very helpful, and "
"the workarounds are pretty straightforward compared to previous versions. "
"These workarounds may be less necessary over time with future versions of "
"Godot as more detection techniques are implemented."
msgstr ""
"パイプラインを事前コンパイルすることは、シェーダーのスタッターを軽減するため"
"に Godot が使用する主なメカニズムですが、完璧な解決策ではありません。パイプラ"
"インのスタッターにつながる可能性のある状況を認識しておくことは非常に役立ち、"
"回避するのは以前のバージョンに比べてかなり簡単です。より多くの検出技術が実装"
"されるにつれて、これらの回避策は、Godot の将来のバージョンでは時間の経過とと"
"もに必要性が低くなっていく可能性があります。"

msgid ""
"The Godot debugger offers monitors for tracking the amount of pipelines "
"created by the game and the step that triggered their compilation. You can "
"keep an eye on these monitors as the game runs to identify potential sources "
"of shader stutters without having to wipe your driver cache every time you "
"wish to test. Sudden increases of these values outside of loading screens "
"can show up as hitches during gameplay the first time someone plays the game "
"on their system. **It is recommended you take a look at these monitors to "
"identify possible sources of stutter for your players**, as you might be "
"unable to experience them yourself without deleting your driver cache or "
"testing on a weaker system."
msgstr ""
"Godot デバッガーはゲームによって作成されたパイプラインの量と、そのコンパイル"
"をトリガーしたステップを追跡するためのモニターを提供します。ゲームの実行中に"
"これらのモニターを監視して、テストするたびにドライバーキャッシュを消去しなく"
"ても、シェーダーのスタッターの潜在的な原因を特定できます。読み込み画面以外で"
"これらの値が突然増加すると、誰かが自分のシステムで初めてゲームをプレイしたと"
"きに、ゲームプレイ中にヒッチとして表示されることがあります。 **これらのモニ"
"ターを確認して、プレーヤーのスタッターの考えられる原因を特定することをお勧め"
"します** 。テストするときはドライバー キャッシュを削除したり、より弱いシステ"
"ムで実行しないと、問題を体感できない可能性があります。"

msgid "Screenshot of the Godot pipeline compilations monitor"
msgstr "Godot パイプラインコンパイルモニターのスクリーンショット"

msgid "Pipeline compilations of one of the demo projects."
msgstr "デモプロジェクトのパイプラインコンパイル。"

msgid ""
"We can see the pipelines compiled during gameplay and verify which steps "
"could possibly cause stuttters. Note that these values will only increase "
"and never go down, as deleted pipelines are not tracked by these monitors "
"and pipelines may be erased and recreated during gameplay."
msgstr ""
"ゲームプレイ中にコンパイルされたパイプラインを確認し、どのステップがスタッ"
"ターの原因になる可能性があるかを検証できます。削除されたパイプラインはこれら"
"のモニターによって追跡されず、パイプラインはゲームプレイ中に消去され再作成さ"
"れる可能性があるため、これらの値は増加するだけで、減少することはないことに注"
"意してください。"

msgid ""
"**Canvas**: Compiled when drawing a 2D node. The engine does not currently "
"feature precompilation for 2D elements and stutters will show up when the 2D "
"node is drawn for the first time."
msgstr ""
"**Canvas**: 2Dノードを描画するときにコンパイルされます。現在のエンジンには "
"2D 要素のプリコンパイル機能がないため、2Dノードが初めて描画されるときにスタッ"
"ターが発生します。"

msgid ""
"**Mesh**: Compiled as part of loading a 3D mesh and identifying what "
"pipelines can be precompiled from its properties. These can lead to stutters "
"if a mesh is loaded during gameplay, but they can be mitigated if the mesh "
"is loaded by using a background thread. **Modifiers that are part of nodes "
"such as material overrides can't be compiled on this step**."
msgstr ""
"**Mesh**: 3D メッシュの読み込みと、そのプロパティから事前コンパイルできるパイ"
"プライン識別の一環としてコンパイルされます。ゲームプレイ中にメッシュが読み込"
"まれると、スタッターが発生する可能性がありますが、バックグラウンドスレッドを"
"使用してメッシュが読み込まれると、スタッターが軽減されます。**マテリアルオー"
"バーライドなどのノードの一部である修飾子は、このステップではコンパイルできま"
"せん**。"

msgid ""
"**Surface**: Compiled when a frame is about to be drawn and 3D objects were "
"instanced on the scene tree for the first time. This can also include "
"compilation for nodes that aren't even visible on the scene tree. The "
"stutter will occur only on the first frame the node is added to the scene, "
"which won't result in an obvious stutter if it happens right after a loading "
"screen."
msgstr ""
"**Surface**: フレームが描画されようとしており、3Dオブジェクトがシーンツリーに"
"初めてインスタンス化されたときにコンパイルされます。これにはシーンツリーに表"
"示されないノードのコンパイルも含まれる場合があります。スタッターはノードが"
"シーンに追加された最初のフレームでのみ発生するため、読み込み画面の直後に発生"
"しても明らかなスタッターにはなりません。"

msgid ""
"**Draw**: Compiled on demand when a 3D object needs to be drawn and an "
"ubershader was not precompiled ahead of time. The engine is unable to "
"precompile this pipeline due to triggering a case that hasn't been covered "
"yet or a modification that was done to the engine's code. Leads to stutters "
"during gameplay. This is identical to Godot versions before 4.4. If you see "
"compilations here, please `let the developers know <https://github.com/"
"godotengine/godot/issues>` as this should never happen with the Ubershader "
"system. Make sure to attach a minimal reproduction project when doing so."
msgstr ""
"**Draw**: 3Dオブジェクトを描画する必要があり、UberShader が事前にプリコンパイ"
"ルされていない場合にオンデマンドでコンパイルされます。エンジンがまだカバーさ"
"れていないケースをトリガーしたか、エンジンのコードに変更が加えられたため、こ"
"のパイプラインをプリコンパイルできません。これが発生するとゲームプレイ中にカ"
"クカクします。これはGodot バージョン 4.4 より前と同じです。ここでコンパイルが"
"表示された場合は、 `Issue で報告してください <https://github.com/godotengine/"
"godot/issues>` 。これは UberShader システムでは発生しないはずです。報告の際は"
"最小限の再現プロジェクトを添付してください。"

msgid ""
"**Specialization**: Compiled in the background during gameplay to optimize "
"the framerate. Unable to cause stutters, but may result in reduced "
"framerates if there are many happening per frame."
msgstr ""
"**Specialization**: ゲームプレイ中にバックグラウンドでコンパイルされ、フレー"
"ムレートを最適化します。スタッターは発生しませんが、フレームごとに多数発生す"
"るとフレームレートが低下する可能性があります。"

msgid "Pipeline precompilation features"
msgstr "パイプラインのプリコンパイル機能"

msgid ""
"Godot offers a lot of rendering features that are not necessarily used by "
"every game. Unfortunately, pipeline precompilation can't know ahead of time "
"if a particular feature is used by a project. Some of these features can "
"only be detected when a user adds a node to the scene or toggles a "
"particular setting in the project or the environment. The pipeline "
"precompilation system will keep track of these features as they're "
"encountered for the first time and enable precompilation of them for any "
"meshes or surfaces that are created afterwards."
msgstr ""
"Godot にはすべてのゲームで使用されるとは限らないレンダリング機能が多数用意さ"
"れています。しかし残念ながら、パイプラインのプリコンパイルでは、特定の機能が"
"プロジェクトで使用されているかどうかを事前に知ることはできません。これらの機"
"能の一部は、ユーザーがシーンにノードを追加したとき、またはプロジェクトまたは"
"環境で特定の設定を切り替えたときにのみ検出できます。パイプラインのプリコンパ"
"イル システムは、これらの機能が初めて検出されたときに追跡し、その後に作成され"
"るメッシュまたはサーフェスに対してそれらのプリコンパイルを有効にします。"

msgid ""
"You should also keep in mind that changing any of these features during "
"gameplay will result in immediate stutters. Make sure to only change these "
"features from configuration screens if necessary and insert loading screens "
"and messages when the changes are applied."
msgstr ""
"またゲームプレイ中にこれらの機能のいずれかを変更すると、すぐにカクツキが発生"
"することにも注意してください。必要な場合にのみ設定画面からこれらの機能を変更"
"し、変更が適用されたときに読み込み画面とメッセージを挿入するようにしてくださ"
"い。"

msgid ""
"**MSAA Level**: Enabled when the level of 3D MSAA is changed on the project "
"settings. Unfortunately, different MSAA levels being used on different "
"viewports will lead to stutters as the engine only keeps track of one level "
"at a time to perform precompilation."
msgstr ""
"**MSAA Level**: プロジェクト設定で 3D MSAA のレベルが変更されると有効になりま"
"す。残念ながら、異なるビューポートで異なる MSAA レベルが使用されていると、エ"
"ンジンがプリコンパイルを実行するために一度に 1 つのレベルのみを追跡するため、"
"スタッターが発生します。"

msgid ""
"**Reflection Probes**: Enabled when a ReflectionProbe node is placed on the "
"scene."
msgstr ""
"**Reflection Probes**: ReflectionProbe ノードがシーン上に配置されている場合に"
"有効になります。"

msgid ""
"**Separate Specular**: Enabled when using effects like sub-surface "
"scattering or a compositor effect that relies on sampling the specularity "
"directly off the screen."
msgstr ""
"**Separate Specular**: サブサーフェススキャタリングなどのエフェクトや、画面か"
"ら直接スペキュラをサンプリングするコンポジター エフェクトを使用する場合に有効"
"になります。"

msgid ""
"**Motion Vectors**: Enabled when using effects such as TAA, FSR2 or a "
"compositor effect that requires motion vectors (such as motion blur)."
msgstr ""
"**Motion Vectors**: TAA、FSR2 などのエフェクトや、モーションベクターを必要と"
"するコンポジターエフェクト (モーション ブラーなど) を使用する場合に有効になり"
"ます。"

msgid ""
"**Normal and Roughness**: Enabled when using SDFGI, VoxelGI, screen-space "
"reflections, SSAO, SSIL, or using the ``normal_roughness_buffer`` in a "
"custom shader or :ref:`class_CompositorEffect`."
msgstr ""
"**Normal and Roughness**: SDFGI、VoxelGI、スクリーンスペース反射、SSAO、SSIL "
"を使用する場合、またはカスタムシェーダーまたは :ref:`class_CompositorEffect` "
"で ``normal_roughness_buffer`` を使用する場合に有効になります。"

msgid ""
"**Lightmaps**: Enabled when a LightmapGI node is placed on the scene and a "
"node uses a baked lightmap."
msgstr ""
"**Lightmaps**: LightmapGI ノードがシーンに配置され、ノードがベイクされたライ"
"トマップを使用する場合に有効になります。"

msgid "**VoxelGI**: Enabled when a VoxelGI node is placed on the scene."
msgstr ""
"**VoxelGI**: VoxelGI ノードがシーン上に配置されている場合に有効になります。"

msgid "**SDFGI**: Enabled when the WorldEnvironment enables SDFGI."
msgstr "**SDFGI**: WorldEnvironment が SDFGI をONにすると有効になります。"

msgid "**Multiview**: Enabled for XR projects."
msgstr "**Multiview**: XR プロジェクトで有効になります。"

msgid ""
"**16/32-bit Shadows**: Enabled when the configuration of the depth precision "
"of shadowmaps is changed on the project settings."
msgstr ""
"**16/32-bit Shadows**: プロジェクト設定でシャドウマップの深度精度の構成が変更"
"された場合に有効になります。"

msgid ""
"**Omni Shadow Dual Paraboloid**: Enabled when an omni light casts shadows "
"and uses the dual paraboloid mode."
msgstr ""
"**Omni Shadow Dual Paraboloid**: オムニ ライトがシャドウを落とし、デュアルパ"
"ラボロイドモードを使用する場合に有効になります。"

msgid ""
"**Omni Shadow Cubemap**: Enabled when an omni light casts shadows and uses "
"the cubemap mode (which is the default)."
msgstr ""
"**Omni Shadow Cubemap**: オムニ ライトがシャドウを落とし、キューブマップモー"
"ド (デフォルト) を使用する場合に有効になります。"

msgid ""
"If you witness stutters during gameplay and the monitors report a sudden "
"increase in compilations during the **Surface** step, it is very likely a "
"feature was not enabled ahead of time. Ensuring that this effect is enabled "
"while loading your game will likely mitigate the issue."
msgstr ""
"ゲームプレイ中にカクツキが発生し、**Surface** ステップ中にモニターがコンパイ"
"ルの突然の増加を報告する場合、機能が事前に有効になっていなかった可能性が非常"
"に高くなります。ゲームの読み込み中にこの効果が有効になっていることを確認する"
"と、問題が軽減される可能性があります。"

msgid "Pipeline precompilation instancing"
msgstr "インスタンシングのパイプラインプリコンパイル"

msgid ""
"One common source of stutters in games is the fact that some effects are "
"only instanced on the scene because of interactions that only happen during "
"gameplay. For example, if you have a particle effect that is only added to "
"the scene through a script when a player does an action. Even if the scene "
"is preloaded, the engine might be unable to precompile the pipelines until "
"the effect is added to the scene at least once."
msgstr ""
"ゲームでスタッターが発生する一般的な原因の 1 つは、ゲームプレイ中にのみ発生す"
"るインタラクションによって、一部のエフェクトがシーンにインスタンス化されると"
"きです。たとえばプレイヤーがアクションを実行したときにスクリプトを通じてシー"
"ンにのみ追加されるパーティクル エフェクトがあるとします。シーンがプリロードさ"
"れている場合でも、エフェクトがシーンに少なくとも 1 回追加されるまで、エンジン"
"はパイプラインをプリコンパイルできない可能性があります。"

msgid ""
"Luckily, it's possible for Godot 4.4 and later to precompile these pipelines "
"as long as the scene is instantiated at least once on the scene, even if "
"it's completely invisible or outside of the camera's view."
msgstr ""
"幸いなことに Godot 4.4 以降では、シーンが完全に見えなかったり、カメラの視野外"
"にあったりしても、シーン上で少なくとも 1 回はインスタンス化されていれば、これ"
"らのパイプラインを事前コンパイルできます。"

msgid "Screenshot of an example of a hidden Node for an effect"
msgstr "非表示ノードのエフェクトの例"

msgid ""
"Hidden bullet node attached to the player in one of the demo projects. This "
"helps the engine precompile the effect's pipelines ahead of time."
msgstr ""
"デモ プロジェクトの 1 つで、プレイヤーにアタッチされた非表示の弾丸ノード。こ"
"れによりエンジンはエフェクトのパイプラインを事前にプリコンパイルできるように"
"なります。"

msgid ""
"If you're aware of any effects that are added to the scene dynamically "
"during gameplay and are seeing sudden increases on the compilations monitor "
"when these effects show up, a workaround is to attach a hidden version of "
"the effect somewhere that is guaranteed to show up."
msgstr ""
"ゲームプレイ中にシーンに動的に追加されるエフェクトがあり、これらのエフェクト"
"が表示されるときにコンパイル モニターで突然の増加が見られる場合、回避策として"
"はエフェクトの非表示バージョンを、確実に表示される場所に添付します。"

msgid ""
"For example, if the player character is able to cause some sort of "
"explosion, you can attach the effect as a child of the player as an "
"invisible node. Make sure to disable the script attached to the hidden node "
"or to hide any other nodes that could cause issues, which can be done by "
"enabling **Editable Children** on the node."
msgstr ""
"たとえばプレイヤーキャラクターが何らかの爆発を引き起こすことができる場合、そ"
"の効果をプレイヤーの子として非表示のノードとしてアタッチできます。非表示の"
"ノードにアタッチされたスクリプトを無効にするか、問題を引き起こす可能性のある"
"他のノードを非表示にしてください。これはノードで **編集可能な子** を有効にす"
"ることで実行できます。"
