#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "CPUの最適化"

msgid "Measuring performance"
msgstr "パフォーマンスの測定"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"プログラムを高速化するには、「ボトルネック」がどこにあるかを知る必要がありま"
"す。ボトルネックとは、プログラムの中で最も遅い部分であり、全体の実行速度を制"
"限します。ボトルネックに焦点を当てることで、わずかなパフォーマンス向上につな"
"がる機能の最適化に多くの時間を費やすのではなく、速度を最大限に向上できる領域"
"の最適化に労力を集中できます。"

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr ""
"CPU の場合、ボトルネックを特定する最も簡単な方法は、プロファイラーを使用する"
"ことです。"

msgid "CPU profilers"
msgstr "CPUプロファイラー"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"プロファイラーはプログラムと並行して実行され、タイミング測定を行って各関数に"
"費やされる時間の割合を計算します。"

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot IDE には便利な組み込みプロファイラーがあります。プロジェクトを開始する"
"たびに実行されるわけではなく、手動で開始および停止する必要があります。これは"
"ほとんどのプロファイラーと同様に、これらのタイミング測定を記録するとプロジェ"
"クトが大幅に遅くなる可能性があるためです。"

msgid "After profiling, you can look back at the results for a frame."
msgstr "プロファイリングの後、フレームの結果を確認することができます。"

msgid "Screenshot of the Godot profiler"
msgstr "Godot プロファイラーのスクリーンショット"

msgid "Results of a profile of one of the demo projects."
msgstr "デモプロジェクトの 1 つのプロファイルの結果。"

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"物理やオーディオなどの組み込みプロセスのコストを確認できるほか、下部には独自"
"のスクリプト関数のコストも表示されます。"

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr ""
"さまざまな組み込みサーバーの待機に費やされた時間は、プロファイラーではカウン"
"トされない可能性があります。これは既知のバグです。"

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"プロジェクトの実行速度が遅い場合、他の機能やプロセスよりも明らかに多くの時間"
"がかかっていることがわかります。これが主なボトルネックであり、通常はこの領域"
"を最適化することで速度を上げることができます。"

msgid ""
"For more info about using Godot's built-in profiler, "
"see :ref:`doc_debugger_panel`."
msgstr ""
"Godot の組み込みプロファイラーの詳細な使用方法について"
"は、 :ref:`doc_debugger_panel` を参照してください。"

msgid "External profilers"
msgstr "外部のプロファイラー"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"Godot IDE プロファイラーは非常に便利で役立ちますが、場合によっては、より強力"
"なプロファイラー機能や、Godot エンジン自体をプロファイリングすることが必要に"
"なることがあります。"

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"これを行うには、いくつかの :ref:`サードパーティ製 C++ プロファイラー "
"<doc_using_cpp_profilers>` を使用できます。"

msgid "Screenshot of Callgrind"
msgstr "Callgrindのスクリーンショット"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "Valgrind の一部である Callgrind の結果。"

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"Callgrind は、左から関数とその子関数内の時間の割合 (Inclusive)、子関数を除い"
"た関数自体内で費やされた時間の割合 (Self)、関数が呼び出された回数、関数名、"
"ファイルまたはモジュールを表示します。"

msgid ""
"In this example, we can see nearly all time is spent under the "
"``Main::iteration()`` function. This is the master function in the Godot "
"source code that is called repeatedly. It causes frames to be drawn, physics "
"ticks to be simulated, and nodes and scripts to be updated. A large "
"proportion of the time is spent in the functions to render a canvas (66%), "
"because this example uses a 2D benchmark. Below this, we see that almost 50% "
"of the time is spent outside Godot code in ``libglapi`` and ``i965_dri`` "
"(the graphics driver). This tells us the a large proportion of CPU time is "
"being spent in the graphics driver."
msgstr ""
"この例では、ほぼすべての時間が ``Main::iteration()`` 関数で費やされていること"
"がわかります。これは Godot ソースコード内で繰り返し呼び出されるマスター関数で"
"す。この関数はフレームの描画、物理ティックのシミュレート、ノードとスクリプト"
"を更新を行います。この例では 2D ベンチマークを使用しているため、時間の大部分 "
"(66%) はキャンバスをレンダリングする関数に費やされています。その下には、時間"
"のほぼ 50% が ``libglapi`` と ``i965_dri`` (グラフィックス ドライバー) といっ"
"た、 Godot コード外で費やされていることがわかります。これは CPU 時間の大部分"
"がグラフィックスドライバーに費やされていることを示しています。"

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"これは興味深い事例です。グラフィックスドライバーに費やされる時間は最小にする"
"のが理想的です。これはグラフィックスAPIで行われる通信や作業が多すぎるという問"
"題があることを示しています。この具体的なプロファイリングが、2Dバッチングの開"
"発につながりました。この分野のボトルネックを減らすことで、2Dレンダリングが大"
"幅に高速化されます。"

msgid "Manually timing functions"
msgstr "タイム関数で実行時間を測定する"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"プロファイラーを使用してボトルネックを特定した後は、テスト対象の関数または"
"コードの実行時間を手動で測定するという便利なテクニックもあります。具体的な方"
"法は言語によって異なりますが、GDScript では次の操作を行います。"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"関数の時間を手動で計測する場合、通常は関数を 1 回だけではなく、何度も (1,000 "
"回以上) 実行することをお勧めします (非常に遅い関数の場合を除く)。これを行う理"
"由はタイマーの精度が限られていることが多く。さらに CPU はプロセスを無計画にス"
"ケジュールするため結果がぶれることが多いためです。一連の実行の平均を取ること"
"で、 1 回だけ測定するよりも正確になります。"

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"関数の最適化を試みる際には、必ず繰り返しプロファイリングするか、実行中に時間"
"を計ってください。これにより、最適化が機能しているかどうかに関する重要な"
"フィードバックが得られます。"

msgid "Caches"
msgstr "CPUキャッシュ"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"CPU キャッシュは、特に関数の 2 つの異なるバージョンのタイミング結果を比較する"
"場合に特に注意する必要があるもう 1 つの要素です。測定結果はデータが CPU "
"キャッシュにあるかどうかに大きく依存する可能性があります。CPU キャッシュと比"
"較してシステム RAM が非常に大きい (数メガバイトではなく数ギガバイト) にもかか"
"わらず、CPU はシステム RAM から直接データをロードしません。これはシステム "
"RAM へのアクセスが非常に遅いためです。代わりに CPU はキャッシュと呼ばれる、よ"
"り小さく、より高速なメモリバンクからデータをロードします。キャッシュからの"
"データのロードは非常に高速ですが、キャッシュに格納されていないメモリ アドレス"
"をロードしようとするたびに、キャッシュはメインメモリにアクセスして、データを"
"ゆっくりとロードする必要があります。この遅延により、CPU が長時間アイドル状態"
"になる可能性があります。これを「キャッシュミス」と呼びます。"

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"つまり、関数を初めて実行すると、データが CPU キャッシュにないため、実行速度が"
"遅くなる可能性があります。2 回目以降は、データがキャッシュにあるため、実行速"
"度が大幅に速くなる可能性があります。このため、実行時間を計測する際は常に平均"
"値を使用し、キャッシュの影響があることに注意してください。"

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"キャッシュを理解することは、CPU の最適化にも重要です。ランダムに分散したメイ"
"ンメモリ領域から小さなデータをロードするアルゴリズム (ルーチン) がある場合、"
"キャッシュミスが頻繁に発生し、CPU が待機する時間が長くなり、何も処理できなく"
"なります。代わりに、データアクセスをローカル化したり、メモリに線形 (連続リス"
"トなど) でアクセスしたりすれば、キャッシュが最適に機能し、CPU は可能な限り高"
"速に処理できるようになります。"

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"Godot は通常このような低レベル事情を考慮して処理しています。たとえば、サー"
"バー API はレンダリングや物理などのために、データがキャッシュ用に最適化されて"
"います。それでも GDExtensions を作成するときは、キャッシュに特に注意する必要"
"があります。"

msgid "Languages"
msgstr "言語"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot はさまざまな言語をサポートしていますが、トレードオフがあることを念頭に"
"置いておく必要があります。一部の言語は速度を犠牲にして使いやすさを重視して設"
"計されており、また他の言語は高速ですが扱いが難しいです。"

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"組み込みエンジン関数は、選択したスクリプト言語に関係なく、同じ速度で実行され"
"ます。プロジェクトで独自のコード内で多くの計算を行っている場合は、それらの計"
"算をより高速な言語に移行することを検討してください。"

msgid "GDScript"
msgstr "GDScript"

msgid "C#"
msgstr "C#"

msgid "Other languages"
msgstr "他の言語"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"サードパーティは `Rust <https://github.com/godot-rust/gdext>`_ を含む、他にも"
"いくつかの言語のサポートを提供しています。"

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"Godot は C++ で書かれています。C++ を使用すると一般的に最も高速なコードになり"
"ます。ただし実用レベルでは、異なるプラットフォーム上のエンドユーザーのマシン"
"に展開するのが最も困難な言語です。C++ を使用する用途には、GDExtensions "
"と :ref:`カスタムモジュール <doc_custom_modules_in_cpp>` があります。"

msgid "Threads"
msgstr "スレッド"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"並列に実行できる計算を大量に行う場合は、スレッドの使用を検討してください。最"
"新の CPU には複数のコアがあり、各コアは限られた量の作業を実行できます。タスク"
"を複数のスレッドに分散することで、CPU の効率をさらに高めることができます。"

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"スレッドの欠点は、非常に注意しなければならないことです。各 CPU コアは独立して"
"動作するため、同時に同じメモリにアクセスしようとする可能性があります。1 つの"
"スレッドが変数を読み込んでいる間に、別のスレッドが書き込みを行っている可能性"
"があります。これは *競合状態* と呼ばれます。スレッドを使用する前に、この危険"
"性と競合状態を防ぐ方法を理解しておく必要があります。スレッドを使用すると、デ"
"バッグがかなり難しくなる可能性があります。"

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr ""
"スレッドの詳細については、:ref:`doc_using_multiple_threads` を参照してくださ"
"い。"

msgid "SceneTree"
msgstr "シーンツリー"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"ノードは非常に強力で多用途な概念ですが、すべてのノードにはコストがかかること"
"に注意してください。 ``_process()`` や ``_physics_process()`` などの組み込み"
"関数はツリー全体に伝播します。この便利な仕組みによりノードの数が非常に多い場"
"合、パフォーマンスが低下する可能性があります (正確な数はターゲットプラット"
"フォームによって異なり、数千から数万の範囲になる可能性があるため、開発中にす"
"べてのターゲットプラットフォームでパフォーマンスプロファイルを行うようにして"
"ください)。"

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"Godot レンダラーでは、各ノードが個別に処理されます。そのため、各ノードの数が"
"少ないほど、パフォーマンスが向上します。"

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later "
"using :ref:`Node.add_child(node) <class_Node_method_add_child>`. This can be "
"very useful for adding and removing areas from a game, for example."
msgstr ""
":ref:`SceneTree <class_SceneTree>` の奇妙な点は、ノードを一時停止したり非表示"
"にしたりするよりも、SceneTree からノードを削除した方がパフォーマンスが大幅に"
"向上する場合があるということです。切り離されたノードを削除する必要はありませ"
"ん。たとえば、ノードへの参照を保持し、:ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>` を使用してシーンツリーから切り離し、後"
"で :ref:`Node.add_child(node) <class_Node_method_add_child>` を使用して再接続"
"することができます。これは例えばゲームのステージにエリアを追加したり削除した"
"りするときに非常に便利です。"

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"サーバー API を使用すると、SceneTree を完全に回避できます。詳細について"
"は :ref:`doc_using_servers` を参照してください。"

msgid "Physics"
msgstr "物理"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"状況によっては、物理がボトルネックになることがあります。これは複雑な世界や、"
"多数の物理オブジェクトがある場合に特に当てはまります。"

msgid "Here are some techniques to speed up physics:"
msgstr "物理を高速化するテクニックをいくつか紹介します。"

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"衝突シェイプはレンダリングされたジオメトリの簡略化されたバージョンを使用して"
"みてください。多くの場合、これはエンドユーザーには気付かれませんが、パフォー"
"マンスを大幅に向上させることができます。"

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"オブジェクトが視界外または現在のエリア外にある場合は物理からオブジェクトを削"
"除するか、物理オブジェクトを再利用してみてください (たとえば、エリアごとに 8 "
"体のモンスターのみ許可し、これらを再利用します)。"

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"物理エンジンのもう 1 つの重要な側面は、物理ティックレートです。ゲームによって"
"はティックレートを大幅に削減して、たとえば物理を 1 秒あたり 60 回更新するので"
"はなく、1 秒あたり 30 回または 20 回だけ更新することもできます。これにより "
"CPU 負荷を大幅に軽減できます。"

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"物理ティックレートを変更することの欠点は、物理更新のレートがレンダリングされ"
"る 1 秒あたりのフレーム数と一致しない場合、ぎくしゃくした動きやジッターが発生"
"する可能性があることです。また物理ティックレートを下げると、入力遅延が増加し"
"ます。リアルタイムのプレイヤー移動を特徴とするほとんどのゲームでは、デフォル"
"トの物理ティックレート (60 Hz) を維持することが推奨されます。"
