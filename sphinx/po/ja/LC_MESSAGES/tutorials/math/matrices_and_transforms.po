#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "行列と変換"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"このチュートリアルを読むには、まずベクトルの知識が必要なので、"
"\\ :ref:`doc_vector_math` チュートリアルをよく読んで理解することをお勧めしま"
"す。"

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"このチュートリアルでは、*変換* と、行列を使用してGodotでそれらを表現する方法"
"について説明します。行列の詳細なガイドではありません。変換はほとんどの場合、"
"平行移動、回転、スケールとして適用されるため、これらを行列で表現する方法に焦"
"点を当てます。"

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` "
"and :ref:`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"このガイドのほとんどは、\\ :ref:`class_Transform2D` と :ref:`class_Vector2` "
"を使用して2Dに焦点を当てていますが、3Dでの動作は非常に似ています。"

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"前のチュートリアルで述べたように、Godotでは、Y軸が2Dで *下* を指していること"
"に注意することが重要です。これは、ほとんどの学校が線形代数を教える方法の反対"
"で、学校の授業ではY軸は上向きです。"

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"慣例では、X軸は赤、Y軸は緑、Z軸は青です。このチュートリアルは、これらの規則に"
"合わせて色分けされていますが、原点ベクトルも青色で表します。"

msgid "Matrix components and the Identity matrix"
msgstr "行列成分と単位行列"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"単位行列は、平行移動、回転、スケールのないtransformを表します。単位行列と、そ"
"の成分が視覚的にどのように表示されるかを確認することから始めましょう。"

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr ""
"行列には行と列があり、変換行列にはそれぞれの動作に関する特定の規則がありま"
"す。"

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"上の画像では、赤のXベクトルは行列の最初の列で表され、緑のYベクトルは同様に2番"
"目の列で表されています。列を変更すると、これらのベクトルが変更されます。次の"
"いくつかの例で、それらの操作方法を説明します。"

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"通常は列を操作するため、行を直接操作することを心配する必要はありません。ただ"
"し、マトリックスの行は、特定の方向への移動に寄与するベクトルを示すものと考え"
"ることができます。"

msgid "Scaling the transformation matrix"
msgstr "変換行列のスケーリング"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"スケールの適用は、理解するのが最も簡単な操作の1つです。まず、ベクトルの下に"
"Godotロゴを配置して、オブジェクトに対する効果を視覚的に確認できるようにしま"
"す:"

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"行列をスケーリングするために必要なことは、各成分に必要なスケールを乗算するこ"
"とだけです。 2倍に拡大しましょう。1 x 2が2になり、0 x 2が0になるため、次のよ"
"うになります:"

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"元のスケールに戻したい場合は、各成分に0.5を掛けます。変換行列のスケーリングは"
"これでほぼすべてです。"

msgid "Rotating the transformation matrix"
msgstr "変換行列の回転"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr "単位行列の下にGodotロゴを配置して、以前と同じ方法で開始します:"

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"例として、Godotロゴを時計回りに90度回転させたいとしましょう。現在、X軸は右向"
"き、Y軸は下向きです。これらを頭の中で回転させると、論理的には新しいX軸が下を"
"向き、新しいY軸が左を指すはずです。"

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"Godotのロゴとそのベクトルの両方をつかみ、それを中央で回転させると想像できま"
"す。回転を終了するたびに、ベクトルの向きによって行列が決まります。"

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or `PI/"
"2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"Godotはすべての回転を度ではなくラジアンで表します。 1回転は `TAU` または "
"`PI*2` ラジアンで、90度の4分の1回転は `TAU/4` または `PI/2` ラジアンです。\\ "
"`TAU` を使用すると、通常、コードが読みやすくなります。"

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"おもしろい事実: GodotではYが *下* であることに加えて、回転は時計回りに表され"
"ます。これにより、これらの違いが「キャンセルされる」ため、すべての数学および"
"トリガ関数が\"Y-is-up CCW\"(Yが上で反時計回り)システムと同じように動作するこ"
"とを意味します。両方のシステムの回転は「XからY」であると考えることができま"
"す。"

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "コードでそれを行う方法を次に示します(スクリプトをNode2Dに配置します):"

msgid "Basis of the transformation matrix"
msgstr "変換行列の基底"

msgid "Translating the transformation matrix"
msgstr "変換行列の平行移動"

msgid ""
"There is also a ``translated_local()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The "
"``translated_local()`` method will translate the object *relative to its own "
"rotation*. For example, an object rotated 90 degrees clockwise will move to "
"the right when ``translated_local()`` with ``Vector2.UP``. To translate "
"*relative to the global/parent frame* use ``translated()`` instead."
msgstr ""
"また、直接 ``origin`` を追加または変更するのとは異なる操作を実行する "
"``translated_local()`` メソッドもあります。 ``translated_local()`` メソッド"
"は、オブジェクトを *自身の回転に相対して* 変換します。たとえば、時計回りに "
"90 度回転したオブジェクトは、 ``translated_local()`` で ``Vector2.UP`` を実行"
"すると右に移動します。 *グローバル/親フレームに相対して* 変換するには、代わり"
"に ``translated()`` を使用します。"

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godotの2Dはピクセルに基づく座標を使用するため、実際のプロジェクトでは数百とい"
"う単位で並行移動を行う必要があります。"

msgid "Putting it all together"
msgstr "すべてをまとめる"

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"平行移動を(350, 150)に設定し、-0.5 radで回転し、3でスケーリングしましょう。ス"
"クリーンショットと再現コードを投稿しましたが、コードを見ずにスクリーンショッ"
"トを再現することをおすすめします！"

msgid "Shearing the transformation matrix (advanced)"
msgstr "変換行列のせん断(高度な内容)"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"変換行列を *使用* する方法のみを探している場合は、チュートリアルのこのセク"
"ションをスキップしてください。このセクションでは、変換行列の理解を深める目的"
"で、一般的に使用されない側面について説明します。"

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"transformは、上記のアクションの組み合わせよりも自由度が高いことに気づいたかも"
"しれません。 2D変換行列の基底には、2つの :ref:`class_Vector2` 値に合計4つの数"
"値がありますが、回転値とスケールのVector2には3つの数値しかありません。欠落し"
"ている自由度の高い概念は、\\ *せん断*\\ と呼ばれます。"

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr ""
"視覚的にどのように見えるかを示すために、グリッドをGodotロゴにオーバーレイしま"
"しょう:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"このグリッド上の各ポイントは、基底ベクトルを加算することにより取得されます。"
"右下隅はX + Y、右上隅はX - Yです。基底ベクトルを変更すると、グリッドが基底ベ"
"クトルで構成されるため、グリッド全体が一緒に移動します。基底ベクトルにどのよ"
"うな変更を加えても、現在平行なグリッド上のすべての線は平行のままです。"

msgid "As an example, let's set Y to (1, 1):"
msgstr "例として、Yを(1, 1)に設定しましょう:"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr ""
"エディタでTransform2Dの生の値を設定することはできません。そのため、オブジェク"
"トをせん断したい場合はコードを使用する *必要* があります。"

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"ベクトルが垂直ではなくなったため、オブジェクトはせん断化されました。グリッド"
"の下部中央は、本体に対して(0, 1)であり、それが(1, 1)のワールド位置に配置され"
"ています。"

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"オブジェクト内の座標は、テクスチャではUV座標と呼ばれます。そのため、ここでは"
"その用語を借用しましょう。相対位置からワールド位置を見つける式はU * X + V * Y"
"です。ここで、UとVは数値で、XとYは基底ベクトルです。"

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"グリッドの右下隅は常に(1, 1)のUV位置にあり、(2, 1)のワールド位置にあります。"
"これは、X*1 + Y*1すなわち (1, 0) + (1, 1)、 (1 + 1, 0 + 1)、または (2, 1)で"
"す。これは、画像の右下隅の位置に関する観察結果と一致します。"

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"同様に、グリッドの右上隅は常に(1, -1)のUV位置にあり、X*1 + Y*-1すなわち(1, "
"0) - (1, 1)、(1 - 1, 0 - 1)、または(0, -1)から計算されるワールド位置(0, -1)に"
"あります。これは、画像の右上隅の位置に関する観察結果と一致します。"

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"Godotでは、すべての変換計算は親ノードを基準にして行われます。 「ワールド位"
"置」を参照する場合、ノードに親がある場合は、そのノードの親に対する相対的な位"
"置になります。"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"追加の説明が必要な場合は、線形変換に関する3Blue1Brownの優れたビデオをご覧くだ"
"さい: https://www.youtube.com/watch?v=kYB8IZa5AuE"

msgid "Practical applications of transforms"
msgstr "変換の実用的な応用"

msgid "Converting positions between transforms"
msgstr "transform間の位置の変換"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"transformの内外で位置を変換したい場合が多くあります。たとえば、プレイヤーに対"
"する相対的な位置があり、そのワールド(親相対)位置を検索する場合、またはワール"
"ド位置があり、そのプレイヤーとの相対的な位置を知りたい場合です。"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"transfomが(0, 0)に配置されていることが事前にわかっている場合は、代わりに"
"\"basis_xform\"または\"basis_xform_inv\"メソッドを使用できます。これらのメ"
"ソッドは、平行移動の処理をスキップします。"

msgid "Moving an object relative to itself"
msgstr "オブジェクトをそれ自身に対して相対的に移動する"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"特に3Dゲームでの一般的な操作は、オブジェクトをそれ自体に対して移動することで"
"す。たとえば、一人称シューティングゲームでは、\\ :kbd:`W` を押すと、キャラク"
"ターが前方(-Z軸)に移動します。"

msgid "This code moves an object 100 units to its own right:"
msgstr "次のコードは、オブジェクトを 100単位右に移動します:"

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "3Dで移動する場合は、\"x\"を\"basis.x\"に置き換える必要があります。"

msgid "Applying transforms onto transforms"
msgstr "transformへの変換の適用"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"transformについて知っておくべき最も重要なことの1つは、transformのいくつかを一"
"緒に使用する方法です。親ノードのtransformは、そのすべての子に影響します。例を"
"見てみましょう。"

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"この図では、子ノードは成分名の後に \"2\" があり、親ノードと区別しています。非"
"常に多くの数字で少し圧倒されるように見えるかもしれませんが、各数字は2回(矢印"
"の横とマトリックスにも)表示され、数字のほぼ半分がゼロであることに注意してくだ"
"さい。"

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"ここで行われている唯一の変換は、親ノードに(2, 1)のスケールが与えられ、子に"
"(0.5, 0.5)のスケールが与えられ、両方のノードに位置が与えられていることです。"

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr ""
"子transformからワールド空間transformへの手動計算には、次のコードを使用します:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "行列を乗算する場合、順序が重要です！それらを混同しないでください。"

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "最後に、恒等変換の適用は常に何も行いません。"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"追加の説明が必要な場合は、行列の構成に関する3Blue1Brownの優れたビデオをご覧く"
"ださい: https://www.youtube.com/watch?v=XkY2DOUCWMU"

msgid "Inverting a transformation matrix"
msgstr "変換行列の反転"

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr ""
"逆transformに通常のtransformを乗算すると、すべての変換が取り消されます:"

msgid "How does it all work in 3D?"
msgstr "3Dではどのように機能しますか？"

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"3Dでの平行移動、回転、拡大縮小、およびせん断の仕組みに関するすべての概念は、"
"2Dと比較してすべて同じです。スケーリングするには、各成分を取得して乗算しま"
"す。回転するには、各基底ベクトルが指す場所を変更します。並行移動するには、原"
"点を操作します。そしてせん断するために、基底ベクトルを非直交に変更します。"

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"必要に応じて、transformを操作して、それらがどのように機能するかを理解すること"
"をお勧めします。Godotを使用すると、インスペクタから直接3D変換行列を編集できま"
"す。\\ :ref:`class_Basis` ベクトルと原点を2Dと3Dの両方で視覚化するのに役立つ"
"色付きの線とキューブを含むこのプロジェクトをダウンロードできます: https://"
"github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"追加の説明が必要な場合は、3Blue1Brownの3D線形変換に関する優れたビデオをご覧く"
"ださい: https://www.youtube.com/watch?v=rHLEWRxRGiM"

msgid "Representing rotation in 3D (advanced)"
msgstr "3Dでの回転の表現(高度な内容)"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"2Dと3D変換行列の最大の違いは、基底ベクトルなしで回転をそれ自体で表現する方法"
"です。"

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"ただし、実際にその仕組みを知っておく必要がある場合は、次の優れたリソースを参"
"照してください:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.youtube.com/watch?v=mvmuCPvRoWQ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.youtube.com/watch?v=d4EgbgTm0Bg"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"
