#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Godotのシーンシステムは、強力で柔軟性がある一方、欠点があります: 複数のシーン"
"に必要とされる情報を保存する為の方法が存在しません(例えばプレイヤーのスコアや"
"インベントリ等)。"

msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr ""
"それを処理出来るにいくつかの代替方法がありますが、それらの方法はそれら自身の"
"制限も伴います:"

msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"あなたは\"master\"シーンを使うことが出来、それの子供の他のシーンをロードもし"
"くはアンロード出来ます。しかし、これの意味する所はこれらのシーンを個別にか"
"つ、期待した様に正しく動作させる事が出来ないという事です。"

msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"情報はディスクの ``user://`` に保存が可能で、シーンが必要とするならばロード出"
"来ますが、頻繁にデータをセーブとロードする事は面倒でさらに遅くもなります。"

msgid ""
"The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case, it's possible to reuse "
"the same scene or class for multiple singletons as long as they have "
"different names."
msgstr ""
"`シングルトンパターン <https://ja.wikipedia.org/wiki/Singleton_パターン>`_\\ "
"は、複数のシーン間で同じ情報を保つ必要があるという、一般的なケースにおいて非"
"常に有用なツールです。私たちの場合では、同じシーンもしくはクラスを複数のシン"
"グルトンにて再利用する事は、それらシングルトンの名前が異なる限り可能です。"

msgid "Using this concept, you can create objects that:"
msgstr "このコンセプトを使うと、オブジェクトを以下のように作る事が出来ます:"

msgid "Are always loaded, no matter which scene is currently running."
msgstr "シーンが現在実行中でも問題なく、いつでもロードされます。"

msgid "Can store global variables such as player information."
msgstr "プレイヤー情報のようなグローバル変数を保管できます。"

msgid "Can handle switching scenes and between-scene transitions."
msgstr "シーンの遷移の切り替えを操作する事ができます。"

msgid ""
"*Act* like a singleton, since GDScript does not support global variables by "
"design."
msgstr ""
"シングルトンのように動作します、デザインによりGDScript はグローバル変数をサ"
"ポートしません。"

msgid "Autoloading nodes and scripts can give us these characteristics."
msgstr "自動読み込みされたノードとスクリプトは我々にこれらの特徴を与えます。"

msgid "Autoload"
msgstr "自動読み込み"

msgid ""
"You can create an Autoload to load a scene or a script that inherits from :"
"ref:`class_Node`."
msgstr ""
"自動読み込みを作成すると、 :ref:`class_Node` を継承したシーンやスクリプトを"
"ロードすることができます。"

msgid ""
"When autoloading a script, a :ref:`class_Node` will be created and the "
"script will be attached to it. This node will be added to the root viewport "
"before any other scenes are loaded."
msgstr ""
"スクリプトを自動読み込みする時、\\ :ref:`class_Node`\\ が作られそれにスクリプ"
"トがアタッチされます。このノードは他のシーンがロードされる前にルートビュー"
"ポートに追加されます。"

msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"自動読み込みオブジェクトはちょうどシーンツリーの中の他のノードの様にアクセス"
"される事を心に留めて下さい。実際には、もし実行中のシーンツリーを見たら、自動"
"読み込みされたノードが現れるでしょう:"

msgid "Custom scene switcher"
msgstr "カスタムシーン・スイッチャー"

msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr ""
"これでスクリプトはプロジェクトのシーンを実行する時は、毎回ロードされる様にな"
"りました。"

msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"今、我々はシーンを遷移させる為の関数を必要としています。この関数はカレント"
"シーンを開放し、要求されたものに置き換える必要があります。"

msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""
"\\ :ref:`Object.call_deferred() <class_Object_method_call_deferred>`\\ の使用"
"時は、カレントシーンが完了してから、2つ目の関数のすべてのコードが1回だけ実行"
"されます。従って、カレントシーンは使用されている間には削除されません (すなわ"
"ち、カレントシーンのコードはまだ実行中です)。"

msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr "最後に、2つのシーンの空のコールバック関数を満たさなければなりません。"

msgid "and"
msgstr "そして"

msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button."
msgstr ""
"プロジェクトの実行とテストをするとボタンを押す事によりシーンの間を切り替えら"
"れます。"

msgid ""
"When scenes are small, the transition is instantaneous. However, if your "
"scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next tutorial: :ref:"
"`doc_background_loading`."
msgstr ""
"シーンが小さい時にはこの遷移は瞬時に行われます。しかし、シーンがより複雑な場"
"合、表示されるのに大量の時間がかかります。これの操作を学ぶには、次のチュート"
"リアルを見て下さい:\\ :ref:`doc_background_loading`\\。"

msgid ""
"Alternatively, if the loading time is relatively short (less than 3 seconds "
"or so), you can display a \"loading plaque\" by showing some kind of 2D "
"element just before changing the scene. You can then hide it just after the "
"scene is changed. This can be used to indicate to the player that a scene is "
"being loaded."
msgstr ""
"また、読み込み時間が比較的短い場合 (3秒以下など) は、シーンが変わる直前に何ら"
"かの2D要素を表示して「ローディング中」画面を表示することもできます。そして、"
"シーンが切り替わった直後にそれを隠すことができます。これは、シーンがロード中"
"であることをプレイヤーに示すために使用できます。"

msgid "Translation status"
msgstr "翻訳ステータス"
