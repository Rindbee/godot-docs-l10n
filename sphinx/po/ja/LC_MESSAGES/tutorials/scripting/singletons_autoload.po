#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Singletons (Autoload)"
msgstr "シングルトン (自動読み込み)"

msgid "Introduction"
msgstr "はじめに"

msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Godotのシーンシステムは、強力で柔軟性がある一方で欠点もあります。たとえば複数"
"のシーンで必要とされる情報を保持する為の方法が存在しません (プレイヤーのスコ"
"アやインベントリを保持すること等)。"

msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr "それに対応するにはいくつかの代替方法がありますが制限も伴います:"

msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"\"master\"シーンを用意して、子供として各シーンをロードもしくはアンロードしま"
"す。しかし、この方法では各シーンを個別に期待したように正しく動作させる事が難"
"しいという事です。"

msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"シーン間の情報をディスクの ``user://`` にセーブして、各シーンが必要なときに"
"ロードします。しかし、この方法はシーン切り替えで頻繁にセーブとロードを行う事"
"になり、実装が面倒でさらに動作が遅くなります。"

msgid ""
"The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case, it's possible to reuse "
"the same scene or class for multiple singletons as long as they have "
"different names."
msgstr ""
"`シングルトンパターン <https://ja.wikipedia.org/wiki/Singleton_パターン>`_\\ "
"は、複数のシーン間で永続的な情報を保持する必要がある一般的なケースを解決する"
"ための便利なツールです。同じシーンもしくはクラスを複数のシングルトンにて再利"
"用する事は、それらシングルトンの名前が異なる限り可能です。"

msgid "Using this concept, you can create objects that:"
msgstr "このコンセプトを使うと、オブジェクトを以下のように作る事が出来ます:"

msgid "Are always loaded, no matter which scene is currently running."
msgstr "どのシーンが現在実行されているかに関係なく、常にロードされます。"

msgid "Can store global variables such as player information."
msgstr "プレイヤー情報のようなグローバル変数を保管できます。"

msgid "Can handle switching scenes and between-scene transitions."
msgstr "シーンの切り替えやシーン間の遷移を処理できます。"

msgid ""
"*Act* like a singleton, since GDScript does not support global variables by "
"design."
msgstr ""
"シングルトンのように*動作*します、GDScript は設計上、グローバル変数をサポート"
"しません。"

msgid "Autoloading nodes and scripts can give us these characteristics."
msgstr "自動読み込みされたノードとスクリプトは我々にこれらの特徴を与えます。"

msgid ""
"Godot won't make an Autoload a \"true\" singleton as per the singleton "
"design pattern. It may still be instanced more than once by the user if "
"desired."
msgstr ""
"Godotは自動読み込みをシングルトンデザインパターンのような「真の」シングルトン"
"にはしていません。必要に応じてユーザーが複数回インスタンス化することもできま"
"す。"

msgid ""
"If you're creating an autoload as part of an editor plugin, "
"consider :ref:`registering it automatically in the Project Settings "
"<doc_making_plugins_autoload>` when the plugin is enabled."
msgstr ""
"エディタプラグインの一部として自動読み込みクラスを作成している場合は、プラグ"
"インが有効になったタイミングで :ref:`プロジェクト設定 "
"<doc_making_plugins_autoload>` に自動読み込みクラスを登録することを検討してく"
"ださい。"

msgid "Autoload"
msgstr "自動読み込み"

msgid ""
"You can create an Autoload to load a scene or a script that inherits "
"from :ref:`class_Node`."
msgstr ""
"自動読み込みを設定すると、 :ref:`class_Node` を継承したシーンやスクリプトを"
"ロードすることができます。"

msgid ""
"When autoloading a script, a :ref:`class_Node` will be created and the "
"script will be attached to it. This node will be added to the root viewport "
"before any other scenes are loaded."
msgstr ""
"スクリプトを自動読み込みする時、\\ :ref:`class_Node`\\ が作られそれにスクリプ"
"トがアタッチされます。このノードは他のシーンがロードされる前にルートビュー"
"ポートに追加されます。"

msgid ""
"To autoload a scene or script, start from the menu and navigate to **Project "
"> Project Settings > Globals > Autoload**."
msgstr ""
"シーンもしくはスクリプトを自動読み込みするには、メニューから **プロジェクト "
"> プロジェクト設定 -> グローバル -> 自動読み込み**に移動します。"

msgid ""
"Here you can add any number of scenes or scripts. Each entry in the list "
"requires a name, which is assigned as the node's ``name`` property. The "
"order of the entries as they are added to the global scene tree can be "
"manipulated using the up/down arrow keys. Like regular scenes, the engine "
"will read these nodes in top-to-bottom order."
msgstr ""
"ここに任意の数のシーンまたはスクリプトを追加できます。リスト内の各エントリに"
"は名前が必要で、その名前はノードの ``name`` プロパティとして割り当てられま"
"す。グローバルシーンツリーに追加されるエントリの順序は、上下の矢印キーを使用"
"して操作できます。通常のシーンと同様にエンジンはこれらのノードを上から下の順"
"序で読み取ります。"

msgid ""
"If the **Enable** column is checked (which is the default), then the "
"singleton can be accessed directly in GDScript:"
msgstr ""
"**有効**列がチェックされている場合 (デフォルトでオン)、GDScriptでシングルトン"
"に直接アクセスできます。"

msgid ""
"The **Enable** column has no effect in C# code. However, if the singleton is "
"a C# script, a similar effect can be achieved by including a static property "
"called ``Instance`` and assigning it in ``_Ready()``:"
msgstr ""
"**有効** 列は C# コードでは効果がありません。ただしシングルトンが C# スクリプ"
"トの場合は、 ``Instance`` という静的プロパティを組み込み、それを "
"``_Ready()`` に割り当てることで、同様の効果を実現できます。"

msgid ""
"This allows the singleton to be accessed from C# code without ``GetNode()`` "
"and without a typecast:"
msgstr ""
"これにより ``GetNode()`` やタイプキャストを使用せずに C# コードからシングルト"
"ンにアクセスできるようになります。"

msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"自動読み込みオブジェクトはちょうどシーンツリーの中の他のノードの様にアクセス"
"される事を心に留めて下さい。実際には、もし実行中のシーンツリーを見たら、自動"
"読み込みされたノードが現れるでしょう:"

msgid ""
"Autoloads must **not** be removed using ``free()`` or ``queue_free()`` at "
"runtime, or the engine will crash."
msgstr ""
"実行時に ``free()`` または ``queue_free()`` を使用して自動読み込みされたイン"
"スタンスを**削除してはいけません**。スクリプトから削除するとエンジンがクラッ"
"シュします。"

msgid "Custom scene switcher"
msgstr "カスタムシーン・スイッチャー"

msgid ""
"This tutorial will demonstrate building a scene switcher using autoloads. "
"For basic scene switching, you can use "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method "
"(see :ref:`doc_scene_tree` for details). However, if you need more complex "
"behavior when changing scenes, this method provides more functionality."
msgstr ""
"このチュートリアルは自動読み込みを使ったシーンスイッチャーの構築する方法を説"
"明します。基本的なシーンの切り替えをする為"
"に :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` メソッドを使う事が出来ます(詳"
"細は\\ :ref:`doc_scene_tree`\\ を見てください)。しかしシーンを変更する際より"
"複雑な動作が必要な場合は、このメソッドは多くの機能が提供されます。"

msgid ""
"To begin, download the template from here: `singleton_autoload_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/singleton_autoload_starter.zip>`_ and open it in Godot."
msgstr ""
"はじめに、こちら `singleton_autoload_starter.zip <https://github.com/"
"godotengine/godot-docs-project-starters/releases/download/latest-4.x/"
"singleton_autoload_starter.zip>`_ からテンプレートをダウンロードしGodotで開い"
"て下さい。"

msgid ""
"A window notifying you that the project was last opened in an older Godot "
"version may appear, that's not an issue. Click *Ok* to open the project."
msgstr ""
"プロジェクトが古いGodotバージョンで最後に開かれたことを通知するウィンドウが表"
"示される場合がありますが、それは問題ではありません。プロジェクトを開くには"
"「OK」をクリックしてください。"

msgid ""
"The project contains two scenes: ``scene_1.tscn`` and ``scene_2.tscn``. Each "
"scene contains a label displaying the scene name and a button with its "
"``pressed()`` signal connected. When you run the project, it starts in "
"``scene_1.tscn``. However, pressing the button does nothing."
msgstr ""
"プロジェクトには ``scene_1.tscn`` と ``scene_2.tscn`` という 2 つのシーンが含"
"まれています。それぞれのシーンはラベル表示されたシーンの名前と ``pressed()`` "
"シグナルを接続されたボタンを含みます。プロジェクトを実行すると、 "
"``scene_1.tscn`` から始まります。ただしボタンを押しても何も起こりません。"

msgid "Creating the script"
msgstr "スクリプトを変更する"

msgid ""
"Open the **Script** window and create a new script called ``global.gd``. "
"Make sure it inherits from ``Node``:"
msgstr ""
"**スクリプト** ウィンドウを開き、 ``global.gd`` という名前の新しいスクリプト"
"を作成します。 ``Node`` から継承するようにしてください。"

msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr ""
"これでスクリプトはプロジェクトのシーンを実行する時は、毎回ロードされる様にな"
"りました。"

msgid ""
"Returning to the script, it needs to fetch the current scene in the "
"`_ready()` function. Both the current scene (the one with the button) and "
"``global.gd`` are children of root, but autoloaded nodes are always first. "
"This means that the last child of root is always the loaded scene."
msgstr ""
"スクリプトに戻り、 `_ready()` 関数内で現在のシーンを持って来る必要がありま"
"す。現在のシーン(ボタンのあるシーン)と ``global.gd`` は両方ともルートの子供で"
"すが、自動読み込みされたノードが常に最初になります。これはルートの最後の子が"
"常にロードされたシーンであることを意味します。"

msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"今、我々はシーンを遷移させる為の関数を必要としています。この関数はカレント"
"シーンを開放し、要求されたものに置き換える必要があります。"

msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""
"\\ :ref:`Object.call_deferred() <class_Object_method_call_deferred>`\\ の使用"
"時は、カレントシーンが完了してから、2つ目の関数のすべてのコードが1回だけ実行"
"されます。従って、カレントシーンは使用されている間には削除されません (すなわ"
"ち、カレントシーンのコードはまだ実行中です)。"

msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr "最後に、2つのシーンの空のコールバック関数を満たさなければなりません。"

msgid "and"
msgstr "そして"

msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button."
msgstr ""
"プロジェクトの実行とテストをするとボタンを押す事によりシーンの間を切り替えら"
"れます。"

msgid ""
"When scenes are small, the transition is instantaneous. However, if your "
"scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next "
"tutorial: :ref:`doc_background_loading`."
msgstr ""
"シーンが小さい時にはこの遷移は瞬時に行われます。しかし、シーンがより複雑な場"
"合、表示されるのに大量の時間がかかります。これの操作を学ぶには、次のチュート"
"リアルを見て下さい:\\ :ref:`doc_background_loading`\\。"

msgid ""
"Alternatively, if the loading time is relatively short (less than 3 seconds "
"or so), you can display a \"loading plaque\" by showing some kind of 2D "
"element just before changing the scene. You can then hide it just after the "
"scene is changed. This can be used to indicate to the player that a scene is "
"being loaded."
msgstr ""
"また、読み込み時間が比較的短い場合 (3秒以下など) は、シーンが変わる直前に何ら"
"かの2D要素を表示して「ローディング中」画面を表示することもできます。そして、"
"シーンが切り替わった直後にそれを隠すことができます。これは、シーンがロード中"
"であることをプレイヤーに示すために使用できます。"
