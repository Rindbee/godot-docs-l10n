#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Nodes and scene instances"
msgstr "ノードとシーンインスタンス"

msgid ""
"This guide explains how to get nodes, create nodes, add them as a child, and "
"instantiate scenes from code."
msgstr ""
"このガイドでは、ノードの取得、ノードの作成、それらを子として追加し、コードか"
"らシーンをインスタンス化する方法について説明します。"

msgid "Getting nodes"
msgstr "ノードの取得"

msgid ""
"You can get a reference to a node by calling the :ref:`Node.get_node() "
"<class_Node_method_get_node>` method. For this to work, the child node must "
"be present in the scene tree. Getting it in the parent node's ``_ready()`` "
"function guarantees that."
msgstr ""
"ノードへの参照を取得するには :ref:`Node.get_node() "
"<class_Node_method_get_node>` メソッドを呼び出します。これが機能するには、子"
"ノードがシーンツリーに存在する必要があります。親ノードの ``_ready()`` 関数で"
"それを取得することで、それが保証されます。"

msgid ""
"If, for example,  you have a scene tree like this, and you want to get a "
"reference to the Sprite2D and Camera2D nodes to access them in your script."
msgstr ""
"たとえばこのようなシーンツリーがあり、Sprite2DノードとCamera2Dノードへの参照"
"を取得してスクリプト内でアクセスしたいとします。"

msgid "To do so, you can use the following code."
msgstr "これを行うには、次のコードを書きます。"

msgid ""
"Note that you get nodes using their name, not their type. Above, "
"\"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene."
msgstr ""
"ノードは型ではなく名前を使用して取得することに注意してください。上の"
"\"Sprite2D\"と\"Camera2D\"はシーン内のノードの名前です。"

msgid ""
"If you rename the Sprite2D node as Skin in the Scene dock, you have to "
"change the line that gets the node to ``get_node(\"Skin\")`` in the script."
msgstr ""
"シーンドックでSprite2Dノードの名前をSkinに変更した場合は、スクリプト内でノー"
"ドを取得する行を ``get_node(\"Skin\")`` に変更する必要があります。"

msgid "Node paths"
msgstr "ノードパス"

msgid ""
"When getting a reference to a node, you're not limited to getting a direct "
"child. The ``get_node()`` function supports paths, a bit like when working "
"with a file browser. Add a slash to separate nodes."
msgstr ""
"ノードへの参照を取得する場合、直接の子を取得することに限定されません。 "
"``get_node()`` 関数はパスをサポートしており、ファイルブラウザを操作する場合と"
"似ています。ノードを区切るにはスラッシュを追加します。"

msgid ""
"Take the following example scene, with the script attached to the "
"UserInterface node."
msgstr ""
"次のシーン例を考えてみましょう。UserInterfacノードにスクリプトがアタッチされ"
"ています。"

msgid "To get the AnimationPlayer node, you would use the following code."
msgstr "AnimationPlayerノードを取得するには、次のコードを使用します。"

msgid ""
"As with file paths, you can use \"..\" to get a parent node. The best "
"practice is to avoid doing that though not to break encapsulation. You can "
"also start the path with a forward slash to make it absolute, in which case "
"your topmost node would be \"/root\", the application's predefined root "
"viewport."
msgstr ""
"ファイル パスと同様に \"..\" を使用して親ノードを取得できますが、なるべくカプ"
"セル化を壊さないようにするためにこれを避けたほうがいいです。パスをスラッシュ"
"で開始して絶対パスにすることもできます。その場合、最上位のノードはアプリケー"
"ションの事前定義されたルートビューポートである \"/root\" になります。"

msgid "Syntactic sugar"
msgstr "シンタックスシュガー"

msgid ""
"You can use two shorthands to shorten your code in GDScript. Firstly, "
"putting the ``@onready`` annotation before a member variable makes it "
"initialize right before the ``_ready()`` callback."
msgstr ""
"2つの短縮表現を使用して、GDScriptのコードを短縮できます。まずメンバー変数の前"
"に ``@onready`` アノテーションを置くと、 ``_ready()`` コールバックの直前に初"
"期化されます。"

msgid ""
"There is also a short notation for ``get_node()``: the dollar sign, \"$\". "
"You place it before the name or path of the node you want to get."
msgstr ""
"``get_node()`` には、ドル記号\"$\"という短い表記法もあります。これを取得する"
"ノードの名前またはパスの前に置きます。"

msgid "Creating nodes"
msgstr "ノード作成"

msgid ""
"To create a node from code, call its ``new()`` method like for any other "
"class-based datatype."
msgstr ""
"コードからノードを作成するには、他のクラスベースのデータ型と同様に、\\ "
"``new()``\\ メソッドを呼び出します。"

msgid ""
"You can store the newly created node's reference in a variable and call "
"``add_child()`` to add it as a child of the node to which you attached the "
"script."
msgstr ""
"スクリプトから新しく作成したノードの参照を変数にセットし、add_child() を呼び"
"出すと自分のノードの子として追加できます。"

msgid ""
"To delete a node and free it from memory, you can call its ``queue_free()`` "
"method. Doing so queues the node for deletion at the end of the current "
"frame after it has finished processing. At that point, the engine removes "
"the node from the scene and frees the object in memory."
msgstr ""
"ノードを削除してメモリから解放するには、ノードの ``queue_free()`` メソッドを"
"呼び出します。これを行うとノードの処理が完了した後、ノードが削除キューに入れ"
"られます。削除キューに入れられたノードは現在のフレームの最後に実際に削除され"
"ます。その時点でエンジンはシーンからノードを削除し、メモリ内のオブジェクトを"
"解放します。"

msgid ""
"Before calling ``sprite2d.queue_free()``, the remote scene tree looks like "
"this."
msgstr ""
"``sprite2d.queue_free()`` を呼び出す前のリモートシーンツリーは次のようになり"
"ます。"

msgid ""
"After the engine freed the node, the remote scene tree doesn't display the "
"sprite anymore."
msgstr ""
"エンジンがノードを解放すると、リモートシーンツリーにはスプライトが表示されな"
"くなります。"

msgid ""
"You can alternatively call ``free()`` to immediately destroy the node. You "
"should do this with care as any reference to it will instantly become "
"``null``. We recommend using ``queue_free()`` unless you know what you're "
"doing."
msgstr ""
"あるいは ``free()`` を呼び出してノードを即座に破棄することもできます。この参"
"照は即座に ``null`` になるため、扱いに注意する必要があります。これが何をして"
"いるのかわからない場合は ``queue_free()`` を使用することをお勧めします。"

msgid ""
"When you free a node, it also frees all its children. Thanks to this, to "
"delete an entire branch of the scene tree, you only have to free the topmost "
"parent node."
msgstr ""
"ノードを解放すると、そのノードのすべての子も解放されます。このおかげでシーン"
"ツリーのブランチ全体を削除するには、最上位の親ノードを解放するだけで済みま"
"す。"

msgid "Instancing scenes"
msgstr "シーンのインスタンス化"

msgid ""
"Scenes are templates from which you can create as many reproductions as "
"you'd like. This operation is called instancing, and doing it from code "
"happens in two steps:"
msgstr ""
"シーンは必要なだけ複製を作成できるいわゆるテンプレートです。この操作はインス"
"タンス化と呼ばれ、コードからの実行は次の2つの順序で行われます。"

msgid "Loading the scene from the local drive."
msgstr "ローカルドライブからシーンをロードします。"

msgid ""
"Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>` "
"resource."
msgstr ""
"ロードされた :ref:`PackedScene <class_PackedScene>` リソースのインスタンスを"
"作成します。"

msgid ""
"Preloading the scene can improve the user's experience as the load operation "
"happens when the compiler reads the script and not at runtime. This feature "
"is only available with GDScript."
msgstr ""
"シーンをプリロードすると、ロード操作は実行時ではなくコンパイラがスクリプトを"
"読み取るときに実行されるため、ユーザー エクスペリエンスが向上します。この機能"
"は GDScript でのみ使用できます。"

msgid ""
"At that point, ``scene`` is a packed scene resource, not a node. To create "
"the actual node, you need to call :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>`. It returns a tree of nodes that you "
"can use as a child of your current node."
msgstr ""
"その時点で ``scene`` はまだノードではなく、パックされたシーンのリソースです。"
"実際のノードを作成するには、 :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` 関数を呼び出す必要があります。これに"
"より現在のノードの子として使用できるノードのツリーが返されます。"

msgid ""
"The advantage of this two-step process is you can keep a packed scene loaded "
"and create new instances on the fly. For example, to quickly instance "
"several enemies or bullets."
msgstr ""
"この2段階のプロセスの利点は、パックされたシーンをロードしたままにして、その場"
"で新しいインスタンスを作成できることです。たとえば複数の敵や弾丸を素早くイン"
"スタンス化します。"
