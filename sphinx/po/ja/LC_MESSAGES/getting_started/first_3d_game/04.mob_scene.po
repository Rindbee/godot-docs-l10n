#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Designing the mob scene"
msgstr "モブシーンをデザイン"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"このパートでは、モンスター（ここではモブと呼びます）のコードを作成します。次"
"のレッスンでは、モンスターをプレイエリアのあちこちにランダムに配置します。"

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the ``player.tscn`` scene."
msgstr ""
"新しいシーンでモンスター自体を設計しましょう。ノード構造は ``player.tscn`` "
"シーンに似ています。"

msgid ""
"Create a scene with, once again, a :ref:`CharacterBody3D "
"<class_CharacterBody3D>` node as its root. Name it ``Mob``. Add a child "
"node :ref:`Node3D <class_Node3D>`, name it ``Pivot``. And drag and drop the "
"file ``mob.glb`` from the *FileSystem* dock onto the ``Pivot`` to add the "
"monster's 3D model to the scene."
msgstr ""
"もう一度 :ref:`CharacterBody3D <class_CharacterBody3D>` ノードをルートとして"
"シーンを作ります。このノードを ``Mob`` と名付けます。次に、その子ノードとし"
"て :ref:`Node3D <class_Node3D>` ノードを追加し、 ``Pivot`` と名付けます。そし"
"て、 *ファイルシステム* ドックから ``mob.glb`` ファイルを ``Pivot`` にドラッ"
"グ＆ドロップすることで、モンスターの3Dモデルがシーンに追加されます。"

msgid "You can rename the newly created ``mob`` node into ``Character``."
msgstr "新たに作成された ``mob`` ノードの名前を ``Character`` に変更できます。"

msgid "|image0|"
msgstr "\\ |image0|"

msgid "image0"
msgstr "image0"

msgid ""
"We need a collision shape for our body to work. Right-click on the ``Mob`` "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"体が機能するために衝突形状を追加する必要があります。シーンのルートノード "
"``Mob`` を右クリックし、 *子ノードを追加* をクリックしてください。"

msgid "|image1|"
msgstr "\\ |image1|"

msgid "image1"
msgstr "image1"

msgid "Add a :ref:`CollisionShape3D <class_CollisionShape3D>`."
msgstr ":ref:`CollisionShape3D <class_CollisionShape3D>`\\ を追加します。"

msgid "|image2|"
msgstr "\\ |image2|"

msgid "image2"
msgstr "image2"

msgid "In the *Inspector*, assign a *BoxShape3D* to the *Shape* property."
msgstr "*Inspector* で、 *Shape* プロパティに *BoxShape3D* を割り当てます。"

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"3 Dモデルによりよく適応するために、そのサイズを変更しなければなりません。オレ"
"ンジ色の点をクリックしてドラッグすることで、インタラクティブに操作できます。"

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"衝突ボックスは地面に接触していて、モデルより少し小さくする必要があります。物"
"理エンジンは、プレイヤーの衝突球体がこの衝突ボックスの端に触れただけでも、衝"
"突したと判定します。もし衝突ボックスが 3D モデルより少し大きかった場合、モン"
"スターからまだ距離があるのに死んでしまい、プレイヤーは不公平だと感じるでしょ"
"う。"

msgid "|image4|"
msgstr "\\ |image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"ボックスがモンスターより高さがあることに注意してください。このゲームでは、"
"シーンを上から見て、固定されたパースペクティブを使っているので、大丈夫です。"
"コリジョン形状は、モデルと完全に一致する必要はありません。ゲームをテストした"
"ときの感触で、形や大きさを決めるといいでしょう。"

msgid "Removing monsters off-screen"
msgstr "古い「モンスター」を削除する"

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob is outside the screen."
msgstr ""
"私たちはこのゲームレベルで一定時間ごとにモンスターを生成します。もし私たちが"
"うっかりしていたら、それらの数は無限大に増えるかもしれませんが、私たちはそれ"
"を望んでいません。モブの各インスタンスにはメモリと処理コストがあり、モブが画"
"面の外にいるときは、私たちはそのためにコストを払いたくありません。"

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we should "
"delete it. Godot has a node that detects when objects leave the "
"screen, :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, "
"and we're going to use it to destroy our mobs."
msgstr ""
"モンスターが画面から離れたら、もう必要ないので、削除してしまいましょう。Godot"
"には、 :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` と"
"いう、ノードが画面から離れるのを検知するノードがあるので、それを使ってモブを"
"破壊することにします。"

msgid ""
"When you keep instancing an object, there's a technique you can use to avoid "
"the cost of creating and destroying instances all the time called pooling. "
"It consists of pre-creating an array of objects and reusing them over and "
"over."
msgstr ""
"オブジェクトのインスタンスを生成し続ける場合に、インスタンスを常に生成・破棄"
"するコストを回避するための手法にプーリングというものがあります。これは、オブ"
"ジェクトの配列をあらかじめ作成しておき、それを何度も再利用するというもので"
"す。"

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here: :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"GDScript で作業する場合、このことを気にする必要はありません。プールを使用する"
"主な理由は、C# や Lua のようなガベージコレクション言語でのフリーズを回避する"
"ためです。GDScriptでは、参照カウントという別の手法でメモリを管理しており、こ"
"の手法はフリーズに注意する必要はありません。メモリ管理の詳細について"
"は :ref:`doc_gdscript_basics_memory_management` で学ぶことができます。"

msgid ""
"Select the ``Mob`` node and add a child node :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`. Another box, pink this time, appears. "
"When this box completely leaves the screen, the node will emit a signal."
msgstr ""
"``Mob`` ノードを選択し、\\ :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`\\ をその子として追加してください。すると、"
"今度はピンク色のボックスが現れます。このボックスが完全に画面から消えると、"
"ノードがシグナルを発信します。"

msgid "|image5|"
msgstr "\\ |image5|"

msgid "image5"
msgstr "image5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr "3D モデル全体を覆うように、オレンジのドットでサイズを変更します。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "\\ image6"

msgid "Coding the mob's movement"
msgstr "モブの動きをコード化する"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the ``Mob`` that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the ``main.tscn`` scene and call the function from there."
msgstr ""
"それでは、モンスターの動きを組み込んでみましょう。2ステップに分けて行います。"
"まず、モンスターを初期化する関数を含むスクリプトを、 ``Mob`` ノードに作成しま"
"す。次に、ランダム生成メカニズムを ``main.tscn`` シーン内に作成し、モンスター"
"を初期化する関数を実行します。"

msgid "Attach a script to the ``Mob``."
msgstr "``Mob`` ノードにスクリプトを追加します。"

msgid "|image7|"
msgstr "\\ |image7|"

msgid "image7"
msgstr "\\ image7"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range, which we "
"will later use to define ``CharacterBody3D.velocity``."
msgstr ""
"これが最初の動きのコードです。 ``min_speed`` と ``max_speed`` の２つのプロパ"
"ティを定義し、ランダムな速度範囲を定義します。これは後で "
"``CharacterBody3D.velocity`` で使います。"

msgid ""
"Similarly to the player, we move the mob every frame by calling the function "
"``CharacterBody3D.move_and_slide()``. This time, we don't update the "
"``velocity`` every frame; we want the monster to move at a constant speed "
"and leave the screen, even if it were to hit an obstacle."
msgstr ""
"プレイヤーと同様に、 ``CharacterBody3D.move_and_slide()`` 関数を呼び出してモ"
"ブを毎フレーム動かします。このとき、 ``velocity`` は毎フレーム更新しません。"
"たとえ障害物に当たったとしても、モンスターが画面外に出るまで等速で動かすので"
"す。"

msgid ""
"We need to define another function to calculate the "
"``CharacterBody3D.velocity``. This function will turn the monster towards "
"the player and randomize both its angle of motion and its velocity."
msgstr ""
"他に ``CharacterBody3D.velocity`` を計算する関数を定義する必要があります。こ"
"の関数はモンスターをプレイヤーの方へ向かせ動きの角度と速度をランダムにしま"
"す。"

msgid ""
"The function will take a ``start_position``,the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"この関数は引数に ``start_position`` （モブの出現位置）と ``player_position`` "
"（プレイヤーの位置）をとります。"

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``randf_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"モブを ``start_position`` に置いて ``look_at_from_position()`` を使いプレイ"
"ヤーの方に向かせ、Y軸を中心にランダムなだけ回転させて角度をランダムにします。"
"以下の ``randf_range()`` は ``-PI / 4`` から ``PI / 4`` までのランダムな角度"
"を出力します。"

msgid ""
"We got a random position, now we need a ``random_speed``. ``randi_range()`` "
"will be useful as it gives random int values, and we will use ``min_speed`` "
"and ``max_speed``. ``random_speed`` is just an integer, and we just use it "
"to multiply our ``CharacterBody3D.velocity``. After ``random_speed`` is "
"applied, we rotate ``CharacterBody3D.velocity`` Vector3 towards the player."
msgstr ""
"ランダムな場所を得て、次は ``random_speed`` が必要です。 ``randi_range()`` が"
"ランダムな整数範囲を得るのに有用で、これに ``min_speed`` と ``max_speed`` を"
"使います。 ``random_speed`` はただの整数で、 ``CharacterBody3D.velocity`` に"
"掛けるだけです。 ``random_speed`` が適用された後、 "
"``CharacterBody3D.velocity`` Vector3をプレイヤーの方へ回転させます。"

msgid "Leaving the screen"
msgstr "画面から離れる"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node's ``screen_exited`` signal to the "
"``Mob``."
msgstr ""
"画面を離れた時にモブを破壊する必要があります。 そのために"
"は、 :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` ノー"
"ドの ```screen_exited`` シグナルを ``Mob`` に接続します。"

msgid ""
"Head back to the 3D viewport by clicking on the *3D* label at the top of the "
"editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Opt + 2` on macOS)."
msgstr ""
"エディタ上部の\\ *3D*\\ ラベルをクリックして、3D ビューポートに戻ります。また"
"\\ :kbd:`Ctrl + F2`\\ (macOSでは\\ :kbd:`Opt + 2`\\ )を押すこともできます。"

msgid "|image8|"
msgstr "\\ |image8|"

msgid "image8"
msgstr "\\ image8"

msgid ""
"Select the :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node and on the right side of the "
"interface, navigate to the *Node* dock. Double-click the ``screen_exited()`` "
"signal."
msgstr ""
":ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` ノードを選"
"択し、インターフェースの右側で * ノード * ドックを開きます。 "
"``screen_exited()`` シグナルをダブルクリックしましょう。"

msgid "|image9|"
msgstr "\\ |image9|"

msgid "image9"
msgstr "\\ image9"

msgid "Connect the signal to the ``Mob``"
msgstr "シグナルを\\ ``Mob``\\ へ接続します"

msgid "|image10|"
msgstr "\\ |image10|"

msgid "image10"
msgstr "\\ image10"

msgid ""
"This will add a new function for you in your mob script, "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. From it, call the "
"``queue_free()`` method. This function destroys the instance it's called on."
msgstr ""
"これでモブスクリプトに ``_on_visible_on_screen_notifier_3d_screen_exited()`` "
"という新しい関数が追加されます。ここから ``queue_free()`` メソッドを呼びま"
"す。この関数はこれが呼ばれたインスタンスを破壊します。"

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"私たちのモンスターがゲームに参加する準備ができました。次のパートでは、ゲーム"
"レベルにモンスターを出現させます。"

msgid "Here is the complete ``mob.gd`` script for reference."
msgstr "参考までに、\\ ``mob.gd``\\ スクリプトの完成版を以下に示します。"
