#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Jumping and squashing monsters"
msgstr "モンスターをジャンプして踏みつける"

msgid ""
"In this part, we'll add the ability to jump and squash the monsters. In the "
"next lesson, we'll make the player die when a monster hits them on the "
"ground."
msgstr ""
"このパートでは、モンスターをジャンプして踏みつける機能を追加します。次のレッ"
"スンでは、モンスターが地面でプレイヤーに当たったときにプレイヤーが死亡するよ"
"うにします。"

msgid ""
"First, we have to change a few settings related to physics interactions. "
"Enter the world of :ref:`physics layers "
"<doc_physics_introduction_collision_layers_and_masks>`."
msgstr ""
"まず、物理的な相互作用に関連するいくつかの設定を変更する必要がありま"
"す。 :ref:`物理レイヤー "
"<doc_physics_introduction_collision_layers_and_masks>` の世界に入りましょう。"

msgid "Controlling physics interactions"
msgstr "物理的相互作用のコントロール"

msgid ""
"Physics bodies have access to two complementary properties: layers and "
"masks. Layers define on which physics layer(s) an object is."
msgstr ""
"物理ボディには、レイヤーとマスクという2つの補完的なプロパティが用意されていま"
"す。レイヤーは、オブジェクトがどの物理レイヤー上に存在するかを定義します。"

msgid ""
"Masks control the layers that a body will listen to and detect. This affects "
"collision detection. When you want two bodies to interact, you need at least "
"one to have a mask corresponding to the other."
msgstr ""
"マスクは、物体が反応して検出するレイヤーを制御します。これは衝突検出に影響を"
"与えます。2つの物体を相互作用させたい場合、少なくとも一方のマスクがもう一方の"
"レイヤーに対応している必要があります。"

msgid "If that's confusing, don't worry, we'll see three examples in a second."
msgstr ""
"もしこれが分かりにくい場合でも心配しないでください。すぐに3つの例を見ていきま"
"しょう。"

msgid ""
"The important point is that you can use layers and masks to filter physics "
"interactions, control performance, and remove the need for extra conditions "
"in your code."
msgstr ""
"重要なポイントは、レイヤーとマスクを使用して物理的な相互作用をフィルタリング"
"し、パフォーマンスを制御し、コード内で追加の条件を不要にできることです。"

msgid ""
"By default, all physics bodies and areas are set to both layer and mask "
"``1``. This means they all collide with each other."
msgstr ""
"デフォルトでは、すべての物理ボディとエリアはレイヤーとマスクのどちらも ``1`` "
"に設定されています。これは全てお互いに接触することを意味します。"

msgid ""
"Physics layers are represented by numbers, but we can give them names to "
"keep track of what's what."
msgstr ""
"物理レイヤーは数字で表現されますが、名前をつけることで何が何なのかの経過を追"
"うことができます。"

msgid "Setting layer names"
msgstr "レイヤー名の設定"

msgid ""
"Let's give our physics layers a name. Go to *Project -> Project Settings*."
msgstr ""
"物理レイヤーに名前を付けましょう。\\ *プロジェクト -> プロジェクト設定...*\\ "
"(Project -> Project Settings)に移動してください。"

msgid "|image0|"
msgstr "\\ |image0|"

msgid "image0"
msgstr "image0"

msgid ""
"In the left menu, navigate down to *Layer Names -> 3D Physics*. You can see "
"a list of layers with a field next to each of them on the right. You can set "
"their names there. Name the first three layers *player*, *enemies*, and "
"*world*, respectively."
msgstr ""
"左のメニューで、\\ *Layer Names -> 3D Physics (3D物理)*\\ のところまで移動し"
"ます。右側に、それぞれのレイヤーの右横にフィールドがあるレイヤーのリストが表"
"示されます。そこでレイヤーの名前を設定することができます。最初の3つのレイヤー"
"にそれぞれ \\ *player*\\ , \\ *enemies*\\ , \\ *world*\\ と名前を付けてくださ"
"い。"

msgid "|image1|"
msgstr "\\ |image1|"

msgid "image1"
msgstr "image1"

msgid "Now, we can assign them to our physics nodes."
msgstr "これで、物理ノードにそれらを割り当てることができます。"

msgid "Assigning layers and masks"
msgstr "レイヤーとマスクの割り当て"

msgid ""
"In the *Main* scene, select the ``Ground`` node. In the *Inspector*, expand "
"the *Collision* section. There, you can see the node's layers and masks as a "
"grid of buttons."
msgstr ""
"*Main* シーンで ``Ground`` ノードを選択します。 *インスペクター* 内の "
"*Collision* セクションを展開すると、ノードのレイヤーとマスクがボタンのグリッ"
"ドとして表示されているのが確認できます。"

msgid "|image2|"
msgstr "\\ |image2|"

msgid "image2"
msgstr "image2"

msgid ""
"The ground is part of the world, so we want it to be part of the third "
"layer. Click the lit button to toggle **off** the first *Layer* and toggle "
"**on** the third one. Then, toggle **off** the *Mask* by clicking on it."
msgstr ""
"Ground は world の一部で、3つ目のレイヤーなのがふさわしいです。*Layer* の最初"
"の点灯しているボタンをクリックして **off** に切り替え、3つ目を **on** に切り"
"替えます。そして、 **Mask** をクリックして **off** に切り替えます。"

msgid "|image3|"
msgstr "\\ |image3|"

msgid "image3"
msgstr "image3"

msgid ""
"As mentioned before, the *Mask* property allows a node to listen to "
"interaction with other physics objects, but we don't need it to have "
"collisions. ``Ground`` doesn't need to listen to anything; it's just there "
"to prevent creatures from falling."
msgstr ""
"前に言及した通り、 *Mask* プロパティはノードが他の物理オブジェクトとの相互作"
"用をリッスンできるようにするものですが、今はコリジョンは必要ありません。 "
"``Ground`` は何もリッスンする必要がありません; ただクリーチャー達が落ちないよ"
"うにするためだけにあります。"

msgid ""
"Note that you can click the \"...\" button on the right side of the "
"properties to see a list of named checkboxes."
msgstr ""
"なお、プロパティの右側にある \"...\" ボタンをクリックするとで名前付きチェック"
"ボックスのリストが表示されます。"

msgid "|image4|"
msgstr "\\ |image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Next up are the ``Player`` and the ``Mob``. Open ``player.tscn`` by double-"
"clicking the file in the *FileSystem* dock."
msgstr ""
"次は ``Player`` と ``Mob`` です。 *ファイルシステム* ドックのファイルを ダブ"
"ルクリックして ``player.tscn`` を開きましょう。"

msgid ""
"Select the *Player* node and set its *Collision -> Mask* to both \"enemies\" "
"and \"world\". You can leave the default *Layer* property as it is, because "
"the first layer is the \"player\" layer."
msgstr ""
"\\ *Player*\\ ノードを選び、 *Collision -> Mask* を \"enemies\" と \"world\" "
"両方に設定しましょう。最初のレイヤーは \"player\" なので、デフォルトの "
"*Layer* プロパティはそのままで大丈夫です。"

msgid "|image5|"
msgstr "\\ |image5|"

msgid "image5"
msgstr "image5"

msgid ""
"Then, open the *Mob* scene by double-clicking on ``mob.tscn`` and select the "
"``Mob`` node."
msgstr ""
"そして、 ``mob.tscn`` をダブルクリックして *Mob* シーンを開き、 ``Mob`` ノー"
"ドを選択しましょう。"

msgid ""
"Set its *Collision -> Layer* to \"enemies\" and unset its *Collision -> "
"Mask*, leaving the mask empty."
msgstr ""
"これの\\ *Collision -> Layer*\\ を \"enemies\" に設定し、\\ *Collision -> "
"Mask*\\ を解除してマスクを空にします。"

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "\\ image6"

msgid ""
"These settings mean the monsters will move through one another. If you want "
"the monsters to collide with and slide against each other, turn **on** the "
"\"enemies\" mask."
msgstr ""
"これらの設定はモンスターが互いをすり抜けることを意味します。もしモンスターを"
"互いにぶつかりスライドさせたいなら、\"enemies\" マスクを *on* にします。"

msgid ""
"The mobs don't need to mask the \"world\" layer because they only move on "
"the XZ plane. We don't apply any gravity to them by design."
msgstr ""
"モブはXZ平面上でしか動かないので\"world\"レイヤーをマスクする必要はありませ"
"ん。また、デザイン上、モブには重力をかけません。"

msgid "Jumping"
msgstr "ジャンプ"

msgid ""
"The jumping mechanic itself requires only two lines of code. Open the "
"*Player* script. We need a value to control the jump's strength and update "
"``_physics_process()`` to code the jump."
msgstr ""
"ジャンプに必要なコードは 2 行のみです。 *Player* スクリプトを開きます。ジャン"
"プの強さを制御する値が必要で ``_physics_process()`` にジャンプのコードを記述"
"します。"

msgid ""
"After the line that defines ``fall_acceleration``, at the top of the script, "
"add the ``jump_impulse``."
msgstr ""
"スクリプトの一番上、\\ ``fall_acceleration``\\ を定義した行の後に、\\ "
"``jump_impulse``\\ を追加してください。"

msgid ""
"Inside ``_physics_process()``, add the following code before the "
"``move_and_slide()`` codeblock."
msgstr ""
"\\ ``_physics_process()`` 内で、 ``move_and_slide()`` コードブロックの前に、"
"以下のコードを追加します。"

msgid "That's all you need to jump!"
msgstr "ジャンプに必要なのはこれだけです！"

msgid ""
"The ``is_on_floor()`` method is a tool from the ``CharacterBody3D`` class. "
"It returns ``true`` if the body collided with the floor in this frame. "
"That's why we apply gravity to the *Player*: so we collide with the floor "
"instead of floating over it like the monsters."
msgstr ""
"\\ ``is_on_floor()`` メソッドは ``CharacterBody3D`` クラスのためのツールで"
"す。これはこのフレーム中にボディが床と衝突していた場合に ``true`` を返しま"
"す。これが *Player* に重力を適用した理由です: モンスターのように浮遊させず床"
"と接触させるためです。"

msgid ""
"If the character is on the floor and the player presses \"jump\", we "
"instantly give them a lot of vertical speed. In games, you really want "
"controls to be responsive and giving instant speed boosts like these, while "
"unrealistic, feels great."
msgstr ""
"キャラクターが床にいてプレイヤーが \"jump\" を押せば、即座に垂直方向の速度を"
"付与します。ゲームでは、操作は即座に反応するのがとても重要で、またこのような"
"瞬間的な加速は不自然でも気持ちがいい物です。"

msgid ""
"Notice that the Y axis is positive upwards. That's unlike 2D, where the Y "
"axis is positive downwards."
msgstr ""
"Y軸は上向きが正になることに注意してください。2Dでは下向きが正だったのとは異な"
"ります。"

msgid "Squashing monsters"
msgstr "モブを踏みつける"

msgid ""
"Let's add the squash mechanic next. We're going to make the character bounce "
"over monsters and kill them at the same time."
msgstr ""
"次に押しつぶしの仕組みを追加してみましょう。キャラクターをモンスターの上で跳"
"ねさせながら、同時にモンスターを倒せるようにするのです。"

msgid ""
"We need to detect collisions with a monster and to differentiate them from "
"collisions with the floor. To do so, we can use Godot's :ref:`group "
"<doc_groups>` tagging feature."
msgstr ""
"モンスターとの衝突を検出し、それを床との衝突と区別する必要があります。そうす"
"るには、Godotの :ref:`group <doc_groups>` タグ機能を使用します。"

msgid ""
"Open the scene ``mob.tscn`` again and select the *Mob* node. Go to the "
"*Node* dock on the right to see a list of signals. The *Node* dock has two "
"tabs: *Signals*, which you've already used, and *Groups*, which allows you "
"to assign tags to nodes."
msgstr ""
"\\ ``mob.tscn`` シーンを再度開き *Mob* ノードを選択しましょう。 シグナルリス"
"トの右にある *ノード* ドックに行きます。 *ノード* ドックには2つのタブがありま"
"す。 *シグナル* は既に使った通りで、 *グループ* はノードにタグを割り当てるこ"
"とができます。"

msgid ""
"Click on it to reveal a field where you can write a tag name. Enter \"mob\" "
"in the field and click the *Add* button."
msgstr ""
"それをクリックしてタグ名を記入するフィールドを出しましょう。フィールドに "
"\"mob\" と入力し、\\ *追加*\\ (Add) ボタンをクリックします。"

msgid "|image7|"
msgstr "\\ |image7|"

msgid "image7"
msgstr "\\ image7"

msgid ""
"An icon appears in the *Scene* dock to indicate the node is part of at least "
"one group."
msgstr ""
"\\ *シーン*\\ (Scene) ドックに、ノードが少なくとも1つのグループに属しているこ"
"とを示すアイコンが表示されます。"

msgid "|image8|"
msgstr "\\ |image8|"

msgid "image8"
msgstr "\\ image8"

msgid ""
"We can now use the group from the code to distinguish collisions with "
"monsters from collisions with the floor."
msgstr ""
"これで、コード上からグループを使用して床との衝突とモンスターとの衝突とを区別"
"することができるようになりました。"

msgid "Coding the squash mechanic"
msgstr "押しつぶしの仕組みをコーディングする"

msgid "Head back to the *Player* script to code the squash and bounce."
msgstr ""
"\\ *Player*\\ スクリプトに戻り、押しつぶしと跳ね返りをコーディングします。"

msgid ""
"At the top of the script, we need another property, ``bounce_impulse``. When "
"squashing an enemy, we don't necessarily want the character to go as high up "
"as when jumping."
msgstr ""
"スクリプトの先頭には、\\ ``bounce_impulse``\\ という別のプロパティが必要で"
"す。敵を潰したとき、キャラクターをジャンプするときほど高く上げる必要はありま"
"せん。"

msgid ""
"Then, after the **Jumping** codeblock we added above in "
"``_physics_process()``, add the following loop. With ``move_and_slide()``, "
"Godot makes the body move sometimes multiple times in a row to smooth out "
"the character's motion. So we have to loop over all collisions that may have "
"happened."
msgstr ""
"次に、\\ ``_physics_process()`` に追加した上記の** ジャンプ ** コードブロック"
"の後に、以下のループを追加します。Godotエンジンは ``move_and_slide()`` を使う"
"時、キャラクターを滑らかに動かすためにボディを複数回連続的に動かすことがあり"
"ます。そのため起こっただろう全ての衝突についてループしなければなりません。"

msgid ""
"In every iteration of the loop, we check if we landed on a mob. If so, we "
"kill it and bounce."
msgstr ""
"ループの各反復で、モブに着地したかどうかをチェックします。着地した場合、その"
"モブを倒して跳ね返します。"

msgid ""
"With this code, if no collisions occurred on a given frame, the loop won't "
"run."
msgstr ""
"このコードでは、与えられたフレームで衝突が発生しなかった場合、ループは実行さ"
"れません。"

msgid "That's a lot of new functions. Here's some more information about them."
msgstr "たくさんの新機能があります。それらの詳細について説明します。"

msgid ""
"The functions ``get_slide_collision_count()`` and ``get_slide_collision()`` "
"both come from the :ref:`CharacterBody3D <class_CharacterBody3D>` class and "
"are related to ``move_and_slide()``."
msgstr ""
"関数 ``get_slide_collision_count()`` と ``get_slide_collision()`` はどちら"
"も :ref:`CharacterBody3D <class_CharacterBody3D>` クラスのもので "
"``move_and_slide()`` に関連します。"

msgid ""
"``get_slide_collision()`` returns "
"a :ref:`KinematicCollision3D<class_KinematicCollision3D>` object that holds "
"information about where and how the collision occurred. For example, we use "
"its ``get_collider`` property to check if we collided with a \"mob\" by "
"calling ``is_in_group()`` on it: "
"``collision.get_collider().is_in_group(\"mob\")``."
msgstr ""
"\\ ``get_slide_collision()`` "
"は :ref:`KinematicCollision3D<class_KinematicCollision3D>` オブジェクトを返"
"し、このオブジェクトは衝突がどこでどのように起こったかの情報を持っています。"
"例えば、\"mob\"と衝突したかを 確認するためにはこのオブジェクトの "
"``get_collider`` プロパティを使用して、さらにそれの ``is_in_group()`` を呼び"
"ます: ``collision.get_collider().is_in_group(\"mob\")``。"

msgid ""
"The method ``is_in_group()`` is available on every :ref:`Node<class_Node>`."
msgstr ""
"\\ ``is_in_group()``\\ メソッドはすべての :ref:`Node<class_Node>` で利用可能"
"です。"

msgid ""
"To check that we are landing on the monster, we use the vector dot product: "
"``Vector3.UP.dot(collision.get_normal()) > 0.1``. The collision normal is a "
"3D vector that is perpendicular to the plane where the collision occurred. "
"The dot product allows us to compare it to the up direction."
msgstr ""
"モンスターに着地したかを確認するためにベクトル内積を使います: "
"``Vector3.UP.dot(collision.get_normal()) > 0.1`` 。衝突の方線(normal)は衝突が"
"起きた平面に対して垂直な3Dベクトルです。内積によってこのベクトルを上方向と比"
"べることができます。"

msgid ""
"With dot products, when the result is greater than ``0``, the two vectors "
"are at an angle of fewer than 90 degrees. A value higher than ``0.1`` tells "
"us that we are roughly above the monster."
msgstr ""
"内積では、結果が \\ ``0``\\ より大きいとき、2つのベクトルは90度未満の角度にあ"
"ります。値が\\ ``0.1``\\ より高いなら、モンスターのほぼ上にいることが分かりま"
"す。"

msgid ""
"After handling the squash and bounce logic, we terminate the loop early via "
"the ``break`` statement to prevent further duplicate calls to "
"``mob.squash()``, which may otherwise result in unintended bugs such as "
"counting the score multiple times for one kill."
msgstr ""
"押しつぶしと跳ね返りを処理するロジックの後、 ``mob.squash()`` が重複して呼ば"
"れないよう ``break`` 文でループを早めに終了させます、そうしなければ一度のキル"
"でスコアを重複してカウントしてしまうような意図しないバグが起きてしまいます。"

msgid ""
"We are calling one undefined function, ``mob.squash()``, so we have to add "
"it to the Mob class."
msgstr ""
"今は ``mob.squash()`` という未定義の関数を呼んでいるので、これをモブクラスに"
"追加しなければなりません。"

msgid ""
"Open the script ``mob.gd`` by double-clicking on it in the *FileSystem* "
"dock. At the top of the script, we want to define a new signal named "
"``squashed``. And at the bottom, you can add the squash function, where we "
"emit the signal and destroy the mob."
msgstr ""
"\\ *ファイルシステム*\\ にある\\ ``mob.gd``\\ スクリプトをダブルクリックして"
"開きましょう。スクリプトの先頭で、\\ ``squashed``\\ というシグナルを定義しま"
"す。そしてスクリプトの最後に、シグナルを発信しモブを破棄する squash 関数を追"
"加しましょう。"

msgid ""
"When using C#, Godot will create the appropriate events automatically for "
"all Signals ending with `EventHandler`, see :ref:`C# Signals "
"<doc_c_sharp_signals>`."
msgstr ""
"C#を使用している場合、Godotは `EventHandler` で終わるすべてのシグナルに対して"
"適切なイベントを自動的に作成します。 :ref:`C# Signals <doc_c_sharp_signals>` "
"を参照してください。"

msgid "We will use the signal to add points to the score in the next lesson."
msgstr ""
"次のレッスンではスコアにポイントを加算するためにこのシグナルを使います。"

msgid ""
"With that, you should be able to kill monsters by jumping on them. You can "
"press :kbd:`F5` to try the game and set ``main.tscn`` as your project's main "
"scene."
msgstr ""
"これで、モンスターにジャンプしてキルできるようになっているはずで"
"す。 :kbd:`F5` を押してゲームを試し、 ``main.tscn`` をプロジェクトのメイン"
"シーンに設定することができます。"

msgid "However, the player won't die yet. We'll work on that in the next part."
msgstr ""
"しかし、プレイヤーはまだ死にません。次のパートでは、この点を取り組みます。"
