#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Moving the player with code"
msgstr "Двигаем игрока с помощью кода"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr ""
"Пришло время для написания кода! Мы собираемся использовать действия ввода, "
"который мы уже создали в предыдущих частях, чтобы персонаж двигался."

msgid "For this project, we will be following the Godot naming conventions."
msgstr "Для этого проекта мы будем следовать правилам именования Godot."

msgid ""
"**GDScript**: Classes (nodes) use PascalCase, variables and functions use "
"snake_case, and constants use ALL_CAPS (See :ref:`doc_gdscript_styleguide`)."
msgstr ""
"**GDScript**: Классы (узлы) используют PascalCase, переменные и функции - "
"snake_case, константы - ALL_CAPS (см. :ref:`doc_gdscript_styleguide`)."

msgid ""
"**C#**: Classes, export variables and methods use PascalCase, private fields "
"use _camelCase, local variables and parameters use camelCase "
"(See :ref:`doc_c_sharp_styleguide`). Be careful to type the method names "
"precisely when connecting signals."
msgstr ""
"**C#**: Классы, экспортные переменные и методы используют PascalCase, "
"приватные поля используют _camelCase, локальные переменные и параметры "
"используют camelCase (См. :ref:`doc_c_sharp_styleguide`). Будьте "
"внимательны, чтобы точно набирать имена методов при подключении сигналов."

msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button. We set it to *Empty* because we want to write our own "
"code for player movement."
msgstr ""
"Нажмите правой кнопкой мыши на узел ``Player`` и выберите *Attach Script*, "
"чтобы добавить к нему новый скрипт. Во всплывающем окне настройте *Шаблон* "
"на *Empty* перед тем, как нажать кнопку *Создать*."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "изображение0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"Давайте начнем со свойств класса. Мы собираемся определить скорость "
"движения, ускорение свободного падения, представляющее гравитацию, и "
"скорость, которую мы будем использовать для движений персонажа."

msgid ""
"These are common properties for a moving body. The ``target_velocity`` is "
"a :ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, "
"we define it as a property because we want to update and reuse its value "
"across frames."
msgstr ""
"Это свойства, характерные для тела в движении. ``target_velocity`` - "
"это :ref:`3D vector <class_Vector3>`, совмещающий в себе скорость с "
"направлением. Здесь мы определяем его, как свойство, потому что хотим "
"обновлять и использовать повторно его значения."

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"Значения довольно сильно отличаются от 2D-кода, потому что расстояние здесь "
"измеряется в метрах. В то время как в 2D тысяча единиц (пикселей) может "
"соответствовать только половине ширины вашего экрана, в 3D же это будет "
"равняться километру."

msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"А сейчас давайте напишем код движения. Мы начинаем с вычисления ввода "
"вектора направления, используя глобальный объект ``Input`` в "
"``_physics_process()``."

msgid ""
"Here, instead of ``_process()``, we're going to make all calculations using "
"the ``_physics_process()`` virtual function. It's designed specifically for "
"physics-related code like moving a kinematic or rigid body. It updates the "
"node using fixed time intervals."
msgstr ""
"Здесь мы собираемся сделать расчёт, используя виртуальную функцию "
"``_physics_process()``вместо ``_process()``. Она создана специально для "
"кода, связанного с физикой, например, кода движения кинематического или "
"твёрдого тела. Она обновляет узел через фиксированные интервалы времени."

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"Для получения дополнительной информации о разнице между ``_process()`` и "
"``_physics_process()``, прочитайте :ref:`doc_idle_and_physics_processing`."

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"Сперва инициализируем переменную ``direction`` со значением "
"``Vector3.ZERO``. После этого мы проверяем, использует ли игрок один или "
"больше вводов ``move_*`` и обновляем ``x`` и ``z`` векторов. Они "
"соответствуют осям плоскости земли."

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr ""
"Эти четыре условия дают нам восемь возможных вариантов и восемь возможных "
"направлений."

msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"В случае, если игрок нажмет, например, обе клавиши W и D одновременно, "
"вектор будет иметь длину около ``1.4``. Но если он нажимает одну клавишу, то "
"вектор будет иметь длину ``1``. Мы хотим, чтобы длина вектора была "
"неизменной и чтобы игрок не двигался быстрей по диагонали. Чтобы сделать "
"это, мы можем вызвать его метод ``normalize()``."

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"Здесь мы нормализуем вектор, только если направление имеет длину больше "
"нуля, что означает, что игрок нажимает клавишу направления."

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""
"Мы вычисляем направление, в котором смотрит ``$Pivot``, создавая :ref:`Basis "
"<class_Basis>`, который смотрит в направлении ``direction``."

msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"Затем мы обновляем скорость. Мы должны вычислить скорость на земле и "
"скорость падения отдельно. Обязательно вернитесь на одну вкладку назад, "
"чтобы строки находились внутри функции ``_physics_process()``, но вне "
"условия, которое мы только что написали."

msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"Метод ``CharacterBody3D.is_on_floor()`` возвращает ``true`` если тело "
"столкнулось с землей. Именно поэтому мы применяем гравитацию только в "
"ситуации, когда игрок находится в воздухе."

msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"Для вертикальной скорости мы вычитаем ускорение свободного падения, "
"умноженное на дельту времени, в каждом кадре. Эта строчка кода заставляет "
"игрока падать каждый кадр, до тех пор пока он не столкнулся с землей."

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"Физический движок может только распознавать взаимодействия со стенами, полом "
"или другими телами во время кадра, если происходит движение и столкновение. "
"Позже мы будем использовать это свойство, чтобы написать код прыжка."

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"В последней строке мы вызываем ``CharacterBody3D.move_and_slide()``, который "
"является мощным методом класса ``CharacterBody3D``, позволяющим плавно "
"перемещать персонажа. Если во время движения автомобиль столкнется со "
"стеной, двигатель попытается сгладить удар. Он использует значение "
"*velocity*, присущее :ref:`CharacterBody3D <class_CharacterBody3D>`"

msgid "And that's all the code you need to move the character on the floor."
msgstr "Вот и весь код, необходимый для перемещения персонажа по полу."

msgid "Here is the complete ``player.gd`` code for reference."
msgstr "Вот так выглядит завершенный код ``player.gd``."

msgid "Testing our player's movement"
msgstr "Проверка движения нашего игрока"

msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"Мы поместим нашего игрока в сцену ``Main``, чтобы протестировать её. Чтобы "
"это сделать, нам необходимо инстанцировать игрока и затем добавить камеру. В "
"отличие от 2D, в 3D вы ничего не увидите, если в вашем окне просмотра нет "
"камеры, указывающей на что-то."

msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"Сохраните вашу сцену ``Player`` и откройте сцену ``Main``. Вы можете нажать "
"на вкладку *Main* вверху редактора и сделать это."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "изображение1"

msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"Если вы закрыли сцену до того, как сделать это, направьтесь во вкладку "
"*Файловая система* и двойным нажатием щелкните на ``main.tscn``, чтобы снова "
"её открыть."

msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"Для инстанцирования ``Player`` нажмите правой кнопкой мыши на узел ``Main`` "
"и выберите *Инстанцировать дочернюю сцену*."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "изображение2"

msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr ""
"Во всплывающем окне двойным щелчком нажмите на *player.tscn*. Персонаж "
"должен появиться в центре окна просмотра."

msgid "Adding a camera"
msgstr "Добавление камеры"

msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child "
"node :ref:`Camera3D <class_Camera3D>` to it. Your scene tree should look "
"similar to this."
msgstr ""
"Теперь давайте добавим камеру. Точно так же, как мы сделали с *Pivot* "
"принадлежащему *Player*, мы создадим основной каркас. Снова нажмите правой "
"кнопкой мыши на узел *Main* и выберите в этот раз *Добавить дочерний узел*. "
"Создайте новый :ref:`Marker3D <class_Marker3D>`, назовите его "
"``CameraPivot`` и добавьте к нему дочерний узел :ref:`Camera3D "
"<class_Camera3D>`. Ваше дерево сцены должно выглядеть таким образом."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "изображение3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left of the 3D view "
"when you have the *Camera* selected. You can click it to preview the in-game "
"camera projection."
msgstr ""
"Обратите внимание на флажок *Preview*, который появляется в левом верхнем "
"углу, при выбранной узле *Camera*. Вы можете нажать на него, чтобы "
"просмотреть проекцию камеры в игре."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "изображение4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"Мы будем использовать *Pivot* для поворота камеры, как будто она находится "
"на кране. Сначала давайте разделим 3D-вид, чтобы иметь возможность свободно "
"перемещаться по сцене и видеть то, что видит камера."

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"На панели инструментов прямо над окном просмотра нажмите *Вид*, затем *2 "
"окна*. Вы также можете нажать :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` на macOS)."

msgid "|image11|"
msgstr "|image11|"

msgid "image11"
msgstr "изображение11"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "изображение5"

msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"В нижнем окне выберите :ref:`Camera3D <class_Camera3D>` и включите "
"предварительный просмотр камеры, нажав на флажок."

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "изображение6"

msgid ""
"In the top view, make sure your *Camera3D* is selected and move the camera "
"about ``19`` units on the Z axis (drag the blue arrow)."
msgstr ""
"На виде сверху, убедитесь, что выбрана *Camera3D* и переместите ее примерно "
"на ``19`` единиц по оси Z (синяя стрелка)."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "изображение7"

msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"Вот где происходит волшебство. Выберите *CameraPivot* и поверните его на "
"``45`` градусов вокруг оси X (с помощью красного круга). Вы увидите, что "
"камера движется так, как будто она прикреплена к крану."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "изображение8"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr ""
"Вы можете запустить сцену, нажав :kbd:`F6` и нажимать клавиши со стрелками "
"для перемещения персонажа."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "изображение9"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"Мы можем видеть пустое пространство вокруг персонажа из-за перспективы. В "
"этой игре мы наоборот собираемся использовать орфографическую проекцию, "
"чтобы лучше структурировать область геймплея и упростить для игрока "
"считывание дистанций."

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"Снова выберите *Camera* и в *инспекторе* установите *Projection* на "
"*Orthogonal* и *Size* на ``19``. Теперь персонаж должен выглядеть более "
"плоским и поверхность должна заполнять задний план."

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""
"При использовании ортогональной камеры в Godot 4 качество направленных теней "
"зависит от значения *Far* камеры. Чем выше значение *Far*, тем дальше камера "
"может видеть. Однако более высокие значения *Far* также снижают качество "
"тени, так как рендеринг тени должен покрывать большее расстояние."

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""
"Если направленные тени выглядят слишком размытыми после переключения на "
"ортогональную камеру, уменьшите свойство *Far* камеры до более низкого "
"значения, например ``100``. Не уменьшайте свойство *Far* слишком сильно, "
"иначе объекты вдали начнут исчезать."

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "изображение10"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""
"Протестируйте вашу сцену: теперь вы должны иметь возможность двигаться во "
"всех 8 направлениях и не проваливаться сквозь пол!"

msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr ""
"Таким образом, у нас есть и движение игрока, и вид. Далее мы будем работать "
"над монстрами."
