#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Designing the mob scene"
msgstr "Разработка сцены с мобом"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"В этой части вы будете программировать монстров, которых мы будем называть "
"мобами. В следующем уроке мы будем распределять их случайным образом по всей "
"игровой области."

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the ``player.tscn`` scene."
msgstr ""
"Давайте разработаем самих монстров в новой сцене. Структура узлов будет "
"похожа на сцену ``player.tscn``."

msgid ""
"Create a scene with, once again, a :ref:`CharacterBody3D "
"<class_CharacterBody3D>` node as its root. Name it ``Mob``. Add a child "
"node :ref:`Node3D <class_Node3D>`, name it ``Pivot``. And drag and drop the "
"file ``mob.glb`` from the *FileSystem* dock onto the ``Pivot`` to add the "
"monster's 3D model to the scene."
msgstr ""
"Создайте сцену, корнем которой снова является узел :ref:`CharacterBody3D "
"<class_CharacterBody3D>`. Назовите его ``Mob``. Добавьте узел :ref:`Node3D "
"<class_Node3D>` в качестве его дочернего узла, назовите его ``Pivot``. "
"Перетащите файл ``mob.glb`` из панели *Файловая система* на узел ``Pivot``, "
"чтобы добавить 3D-модель монстра в сцену."

msgid "You can rename the newly created ``mob`` node into ``Character``."
msgstr ""
"Вы можете переименовать только что созданный узел ``mob`` в ``Character``."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "изображение0"

msgid ""
"We need a collision shape for our body to work. Right-click on the ``Mob`` "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"Нам нужна форма столкновения, чтобы наше тело работало. Щёлкните правой "
"кнопкой мыши на узле ``Mob``, корне сцены, и выберите *Добавить дочерний "
"узел*."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "изображение1"

msgid "Add a :ref:`CollisionShape3D <class_CollisionShape3D>`."
msgstr "Добавьте :ref:`CollisionShape3D <class_CollisionShape3D>`."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "изображение2"

msgid "In the *Inspector*, assign a *BoxShape3D* to the *Shape* property."
msgstr "В *инспекторе* назначьте *BoxShape3D* свойству *Shape*."

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"Мы должны изменить его размер, чтобы он лучше соответствовал 3D-модели. Вы "
"можете сделать это интерактивно, щёлкая и перетаскивая оранжевые точки."

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"Параллелепипед должен касаться пола и быть немного тоньше, чем модель. "
"Физические движки работают таким образом, что если сфера игрока коснется "
"даже угла параллепипеда, произойдет столкновение. Если параллепипед будет "
"слишком большой по сравнению с 3D-моделью, вы можете умереть на расстоянии "
"от монстра, и игра будет казаться несправедливой по отношению к игрокам."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "изображение4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"Обратите внимание, что мой габаритный контейнер выше, чем монстр. В этой "
"игре это нормально, потому что мы смотрим на сцену сверху и используем "
"фиксированную перспективу. Формы столкновений не обязательно должны точно "
"соответствовать модели. Их форма и размер должны определяться тем, как игра "
"ощущается при тестировании."

msgid "Removing monsters off-screen"
msgstr "Удаление монстров за пределами экрана"

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob is outside the screen."
msgstr ""
"Мы собираемся порождать монстров через регулярные промежутки времени на "
"игровом уровне. Если мы не будем осторожны, их количество может увеличиться "
"до бесконечности, а мы этого не хотим. Каждый экземпляр монстра требует "
"памяти и времени на обработку, и мы не хотим зря тратить ресурсы "
"используемого устройства, когда монстр находится за пределами экрана."

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we should "
"delete it. Godot has a node that detects when objects leave the screen, :ref:"
"`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, and we're "
"going to use it to destroy our mobs."
msgstr ""
"Как только монстр покидает экран, он нам больше не нужен, поэтому мы можем "
"его удалить. В Godot есть узел, который определяет, когда объекты покидают "
"экран, :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, и "
"мы собираемся использовать его для уничтожения наших мобов."

msgid ""
"When you keep instancing an object, there's a technique you can use to avoid "
"the cost of creating and destroying instances all the time called pooling. "
"It consists of pre-creating an array of objects and reusing them over and "
"over."
msgstr ""
"Когда вы постоянно создаёте экземпляр объекта в играх, существует техника, "
"которую можно использовать, чтобы избежать затрат на постоянное создание и "
"уничтожение экземпляров, называемая пулингом. Она заключается в "
"предварительном создании массива объектов и повторном их использовании."

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here: :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"При работе с GDScript вам не нужно беспокоиться об этом. Основная причина "
"использования пулов заключается в том, чтобы избежать зависания в языках со "
"сборщиком мусора, таких как C# или Lua. GDScript использует другую технику "
"управления памятью, подсчет ссылок, которая не имеют такой проблемы. Вы "
"можете узнать больше об этом здесь :ref:"
"`doc_gdscript_basics_memory_management`."

msgid ""
"Select the ``Mob`` node and add a child node :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`. Another box, pink this time, appears. "
"When this box completely leaves the screen, the node will emit a signal."
msgstr ""
"Выберите узел ``Mob`` и добавьте :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` в качестве его дочернего элемента. "
"Появится еще один параллелепипед, на этот раз розовый. Когда этоn "
"параллелепипед полностью покинет экран, узел отправит сигнал."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "изображение5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr ""
"Измените его размер с помощью оранжевых точек, пока он не покроет всю 3D-"
"модель."

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "изображение6"

msgid "Coding the mob's movement"
msgstr "Программирование движения мобов"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the ``Mob`` that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the ``main.tscn`` scene and call the function from there."
msgstr ""
"Давайте реализуем движение монстра. Мы сделаем это в два этапа. Сначала мы "
"напишем скрипт для узла ``Mob``, который определит функцию для инициализации "
"монстра. Затем мы запрограммируем механизм случайного появления в сцене "
"``main.tscn`` и вызовем функцию оттуда."

msgid "Attach a script to the ``Mob``."
msgstr "Добавьте скрипт к ``Mob``."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "изображение7"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range, which we "
"will later use to define ``CharacterBody3D.velocity``."
msgstr ""
"Вот код движения для начала. Мы определяем два свойства, ``min_speed`` и "
"``max_speed``, чтобы определить случайный диапазон скорости, который мы в "
"будущем используем для задания значения ``CharacterBody3D.velocity``."

msgid ""
"Similarly to the player, we move the mob every frame by calling the function "
"``CharacterBody3D.move_and_slide()``. This time, we don't update the "
"``velocity`` every frame; we want the monster to move at a constant speed "
"and leave the screen, even if it were to hit an obstacle."
msgstr ""
"Аналогично игроку, мы перемещаем моба каждый кадр, вызывая метод "
"``CharacterBody3D.move_and_slide()``. На этот раз мы не обновляем "
"``velocity`` каждый кадр: мы хотим, чтобы монстр двигался с постоянной "
"скоростью и покинул экран, даже если он врежется в препятствие."

msgid ""
"We need to define another function to calculate the ``CharacterBody3D."
"velocity``. This function will turn the monster towards the player and "
"randomize both its angle of motion and its velocity."
msgstr ""
"Нам нужно определить ещё одну функцию для расчёта ``CharacterBody3D."
"velocity``. Эта функция повернёт монстра в сторону игрока и случайным "
"образом вычислит угол его движения и скорость."

msgid ""
"The function will take a ``start_position``,the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"В качестве аргументов функция принимает ``start_position``, позицию "
"появления моба, и ``player_position``."

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``randf_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"Мы расположим моба с помощью ``start_position`` и повернем его к игроку с "
"помощью метода ``look_at_from_position()``, а также вычисляем угол, "
"поворачивая его на случайную величину вокруг оси Y. Ниже, ``randf_range()`` "
"выводит случайное значение между ``-PI / 4`` радианами и ``PI / 4`` "
"радианами."

msgid ""
"We got a random position, now we need a ``random_speed``. ``randi_range()`` "
"will be useful as it gives random int values, and we will use ``min_speed`` "
"and ``max_speed``. ``random_speed`` is just an integer, and we just use it "
"to multiply our ``CharacterBody3D.velocity``. After ``random_speed`` is "
"applied, we rotate ``CharacterBody3D.velocity`` Vector3 towards the player."
msgstr ""
"Мы получили случайную позицию, теперь нам нужно получить ``random_speed``. В "
"данном случае пригодится функция ``randi_range()``, так как она возвращает "
"случайные целые числа в определённом диапазоне, поэтому мы используем "
"``min_speed`` и ``max_speed`` в качестве предельных значений. "
"``random_speed`` просто является целым числом, и мы просто используем его "
"для умножения на ``CharacterBody3D.velocity``. После умножения "
"``random_speed`` на ``CharacterBody3D.velocity``, мы поворачиваем Vector3 "
"``CharacterBody3D.velocity`` в сторону игрока."

msgid "Leaving the screen"
msgstr "Уход с экрана"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node's ``screen_exited`` signal to the "
"``Mob``."
msgstr ""
"Нам всё еще нужно уничтожать мобов, когда они покидают экран. Для этого мы "
"подключим сигнал нашего узла :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` ``screen_exited`` к ``Mob``."

msgid ""
"Head back to the 3D viewport by clicking on the *3D* label at the top of the "
"editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Opt + 2` on macOS)."
msgstr ""
"Вернитесь в 3D окно просмотра, нажав на ярлык *3D* в верхней части "
"редактора. Вы также можете нажать :kbd:`Ctrl + F2` (:kbd:`Opt + 2` на macOS)."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "изображение8"

msgid ""
"Select the :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node and on the right side of the "
"interface, navigate to the *Node* dock. Double-click the ``screen_exited()`` "
"signal."
msgstr ""
"Выберите узел :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` и в правой части интерфейса перейдите во "
"вкладку *Узел*. Дважды щёлкните на сигнале ``screen_exited()``."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "изображение9"

msgid "Connect the signal to the ``Mob``"
msgstr "Подключите сигнал к ``Mob``"

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "изображение10"

msgid ""
"This will add a new function for you in your mob script, "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. From it, call the "
"``queue_free()`` method. This function destroys the instance it's called on."
msgstr ""
"Это добавит новую функцию "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. Из неё вызовите метод "
"``queue_free()``. Это уничтожит экземпляр моба, который его вызвал."

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"Наш монстр готов вступить в игру! В следующей части вы будете порождать "
"монстров на игровом уровне."

msgid "Here is the complete ``mob.gd`` script for reference."
msgstr "Вот, для справки, полный сценарий ``mob.gd``."
