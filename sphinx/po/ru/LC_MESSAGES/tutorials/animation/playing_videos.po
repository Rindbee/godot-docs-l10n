#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Playing videos"
msgstr "Воспроизведение видео"

msgid ""
"Godot supports video playback with the :ref:`class_VideoStreamPlayer` node."
msgstr ""
"Godot поддерживает воспроизведение видео с помощью "
"узла :ref:`class_VideoStreamPlayer`."

msgid "Supported playback formats"
msgstr "Поддерживаемые форматы воспроизведения"

msgid ""
"H.264 and H.265 cannot be supported in core Godot, as they are both "
"encumbered by software patents. AV1 is royalty-free, but it remains slow to "
"decode on the CPU and hardware decoding support isn't readily available on "
"all GPUs in use yet."
msgstr ""
"H.264 и H.265 не могут поддерживаться в ядре Godot, поскольку оба они "
"обременены патентами на программное обеспечение. AV1 не требует авторских "
"отчислений, но он по-прежнему медленно декодируется на CPU, а аппаратная "
"поддержка декодирования пока доступна не на всех используемых GPU."

msgid ""
"WebM was supported in core in Godot 3.x, but support for it was removed in "
"4.0 as it was too buggy and difficult to maintain."
msgstr ""
"WebM поддерживался в ядре Godot 3.x, но в версии 4.0 его поддержка была "
"удалена, так как он был слишком глючным и сложным в обслуживании."

msgid ""
"You may find videos with an ``.ogg`` or ``.ogx`` extensions, which are "
"generic extensions for data within an Ogg container."
msgstr ""
"Вы можете найти видео с расширениями ``.ogg`` или ``.ogx``, которые являются "
"общими расширениями для данных внутри контейнера Ogg."

msgid ""
"Renaming these file extensions to ``.ogv`` *may* allow the videos to be "
"imported in Godot. However, not all files with ``.ogg`` or ``.ogx`` "
"extensions are videos - some of them may only contain audio."
msgstr ""
"Переименование расширений этих файлов в ``.ogv`` *может* позволить "
"импортировать видео в Godot. Однако не все файлы с расширениями ``.ogg`` или "
"``.ogx`` являются видео - некоторые из них могут содержать только аудио."

msgid "Setting up VideoStreamPlayer"
msgstr "Настройка VideoStreamPlayer"

msgid "Create a VideoStreamPlayer node using the Create New Node dialog."
msgstr ""
"Создайте узел VideoStreamPlayer, используя диалоговое окно \"Создать новый "
"узел\"."

msgid ""
"Select the VideoStreamPlayer node in the scene tree dock, go to the "
"inspector and load an ``.ogv`` file in the Stream property."
msgstr ""
"В дереве сцен выберите узел VideoStreamPlayer, откройте нспектор и загрузите "
"файл ``.ogv`` в свойство Поток."

msgid ""
"If you don't have your video in Ogg Theora format yet, jump "
"to :ref:`doc_playing_videos_recommended_theora_encoding_settings`."
msgstr ""
"Если у вас еще нет видео в формате Ogg Theora, перейдите "
"к :ref:`doc_playing_videos_recommended_theora_encoding_settings`."

msgid ""
"If you want the video to play as soon as the scene is loaded, check "
"**Autoplay** in the inspector. If not, leave **Autoplay** disabled and call "
"``play()`` on the VideoStreamPlayer node in a script to start playback when "
"desired."
msgstr ""
"Если вы хотите, чтобы видео воспроизводилось сразу после загрузки сцены, "
"установите флажок **Автозапуск** в инспекторе. Если нет, оставьте "
"**Автозапуск** отключенным и вызовите ``play()`` на узле VideoStreamPlayer в "
"скрипте, чтобы начать воспроизведение по желанию."

msgid "Handling resizing and different aspect ratios"
msgstr "Управление изменением размера и различных соотношений сторон"

msgid ""
"By default in Godot 4.0, the VideoStreamPlayer will automatically be resized "
"to match the video's resolution. You can make it follow "
"usual :ref:`class_Control` sizing by enabling **Expand** on the "
"VideoStreamPlayer node."
msgstr ""
"По умолчанию в Godot 4.0 размер VideoStreamPlayer будет автоматически "
"изменен в соответствии с разрешением видео. Вы можете привести его к "
"обычному размеру :ref:`class_Control`, включив **Expand** на узле "
"VideoStreamPlayer."

msgid ""
"To adjust how the VideoStreamPlayer node resizes depending on window size, "
"adjust the anchors using the **Layout** menu at the top of the 2D editor "
"viewport. However, this setup may not be powerful enough to handle all use "
"cases, such as playing fullscreen videos without distorting the video (but "
"with empty space on the edges instead). For more control, you can use "
"an :ref:`class_AspectRatioContainer` node, which is designed to handle this "
"kind of use case:"
msgstr ""
"Чтобы настроить изменение размера узла VideoStreamPlayer в зависимости от "
"размера окна, отрегулируйте привязки с помощью меню **Layout** в верхней "
"части окна просмотра 2D-редактора. Однако эта настройка может оказаться "
"недостаточно мощной для обработки всех вариантов использования, таких как "
"воспроизведение полноэкранных видеороликов без искажения видео (но с пустым "
"пространством по краям). Для большего контроля вы можете использовать "
"узел :ref:`class_AspectRatioContainer`, который предназначен для обработки "
"такого рода вариантов использования:"

msgid ""
"Add an AspectRatioContainer node. Make sure it is not a child of any other "
"container node. Select the AspectRatioContainer node, then set its "
"**Layout** at the top of the 2D editor to **Full Rect**. Set **Ratio** in "
"the AspectRatioContainer node to match your video's aspect ratio. You can "
"use math formulas in the inspector to help yourself. Remember to make one of "
"the operands a float. Otherwise, the division's result will always be an "
"integer."
msgstr ""
"Добавьте узел AspectRatioContainer. Убедитесь, что он не является дочерним "
"узлом какого-либо другого узла контейнера. Выберите узел "
"AspectRatioContainer, затем установите для его **Layout** в верхней части 2D-"
"редактора значение **Full Rect**. Установите **Ratio** в узле "
"AspectRatioContainer в соответствии с соотношением сторон вашего видео. Вы "
"можете использовать математические формулы в инспекторе, чтобы помочь себе. "
"Не забудьте сделать один из операндов плавающей величиной. В противном "
"случае результатом деления всегда будет целое число."

msgid ""
"AspectRatioContainer's Ratio property being modified in the editor inspector"
msgstr ""
"Изменение свойства Ratio контейнера AspectRatioContainer в инспекторе "
"редактора"

msgid "This will evaluate to (approximately) 1.777778"
msgstr "Это составит (приблизительно) 1,777778"

msgid ""
"Once you've configured the AspectRatioContainer, reparent your "
"VideoStreamPlayer node to be a child of the AspectRatioContainer node. Make "
"sure **Expand** is enabled on the VideoStreamPlayer. Your video should now "
"scale automatically to fit the whole screen while avoiding distortion."
msgstr ""
"После настройки AspectRatioContainer измените родительский статус узла "
"VideoStreamPlayer на дочерний для узла AspectRatioContainer. Убедитесь, что "
"**Expand** отключен в VideoStreamPlayer. Теперь ваше видео должно "
"автоматически масштабироваться так, чтобы поместиться на весь экран, избегая "
"при этом искажений."

msgid ""
"See :ref:`doc_multiple_resolutions` for more tips on supporting multiple "
"aspect ratios in your project."
msgstr ""
"Смотрите :ref:`doc_multiple_resolutions` для получения дополнительных "
"советов по поддержке нескольких соотношений сторон в вашем проекте."

msgid "Displaying a video on a 3D surface"
msgstr "Отображение видео на 3D-поверхности"

msgid ""
"Using a VideoStreamPlayer node as a child of a :ref:`class_SubViewport` "
"node, it's possible to display any 2D node on a 3D surface. For example, "
"this can be used to display animated billboards when frame-by-frame "
"animation would require too much memory."
msgstr ""
"Используя узел VideoStreamPlayer как дочерний по отношению к "
"узлу :ref:`class_SubViewport`, можно отобразить любой 2D-узел на 3D-"
"поверхности. Например, это может быть использовано для отображения "
"анимированных рекламных щитов(animated billboard), когда покадровая анимация "
"требует слишком много памяти."

msgid "This can be done with the following steps:"
msgstr "Это можно сделать, выполнив следующие действия:"

msgid ""
"Create a :ref:`class_SubViewport` node. Set its size to match your video's "
"size in pixels."
msgstr ""
"Создайте узел :ref:`class_SubViewport`. Установите его размер таким образом, "
"чтобы он соответствовал размеру вашего видео в пикселях."

msgid ""
"Create a VideoStreamPlayer node *as a child of the SubViewport node* and "
"specify a video path in it. Make sure **Expand** is disabled, and enable "
"**Autoplay** if needed."
msgstr ""
"Создайте узел VideoStreamPlayer *как дочерний по отношению к узлу "
"SubViewport* и укажите в нем путь к видео. Убедитесь, что функция "
"**Развернуть** отключена, и при необходимости включите функцию "
"**Автозапуск**."

msgid ""
"Create a MeshInstance3D node with a PlaneMesh or QuadMesh resource in its "
"Mesh property. Resize the mesh to match the video's aspect ratio (otherwise, "
"it will appear distorted)."
msgstr ""
"Создайте узел MeshInstance3D с ресурсом Plane Mesh или QuadMesh в свойстве "
"Mesh. Измените размер сетки в соответствии с соотношением сторон видео (в "
"противном случае оно будет выглядеть искаженным)."

msgid ""
"Create a new StandardMaterial3D resource in the **Material Override** "
"property in the GeometryInstance3D section."
msgstr ""
"Создайте новый стандартный ресурс Material 3D в свойстве **Material "
"Override** в разделе GeometryInstance3D."

msgid ""
"Enable **Local To Scene** in the StandardMaterial3D's Resource section (at "
"the bottom). This is *required* before you can use a ViewportTexture in its "
"Albedo Texture property."
msgstr ""
"Включите функцию **Локально для сцены** в разделе ресурсов "
"StandardMaterial3D (внизу). Это необходимо для того, чтобы вы могли "
"использовать ViewportTexture в свойстве текстуры альбедо."

msgid ""
"In the StandardMaterial3D, set the **Albedo > Texture** property to **New "
"ViewportTexture**. Edit the new resource by clicking it, then specify the "
"path to the SubViewport node in the **Viewport Path** property."
msgstr ""
"В StandardMaterial3D установите для свойства **Albedo > Texture** значение "
"**New ViewportTexture**. Отредактируйте новый ресурс, щелкнув по нему, затем "
"укажите путь к узлу SubViewport в свойстве **Viewport Path**."

msgid ""
"Enable **Albedo Texture Force sRGB** in the StandardMaterial3D to prevent "
"colors from being washed out."
msgstr ""
"Включите **Albedo Texture Force sRGB** в StandardMaterial3D, чтобы "
"предотвратить размывание цветов."

msgid ""
"If the billboard is supposed to emit its own light, set **Shading Mode** to "
"**Unshaded** to improve rendering performance."
msgstr ""
"Если предполагается, что рекламный щит излучает свой собственный свет, "
"установите **Режим затенения** на **режим без затенения**, чтобы повысить "
"производительность рендеринга."

msgid ""
"See :ref:`doc_viewports` and the `GUI in 3D demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__ for more "
"information on setting this up."
msgstr ""
"Смотрите = :ref:`doc_viewports` и `Демо GUI в 3D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__ для "
"получения дополнительной информации о настройке."

msgid "Looping a video"
msgstr "Зацикливание видео"

msgid ""
"For looping a video, the **Loop** property can be enabled. This will "
"seamlessly restart the video when it reaches its end."
msgstr ""
"Для зацикливания видео можно включить свойство **Loop**. Это позволит плавно "
"перезапустить видео, когда оно дойдет до конца."

msgid ""
"Note that setting the project setting **Video Delay Compensation** to a non-"
"zero value might cause your loop to not be seamless, because the "
"synchronization of audio and video takes place at the start of each loop "
"causing occasional missed frames. Set **Video Delay Compensation** in your "
"project settings to **0** to avoid frame drop issues."
msgstr ""
"Обратите внимание, что установка ненулевого значения параметра проекта "
"**Компенсация задержки видеосигнала** может привести к тому, что ваш цикл не "
"будет непрерывным, поскольку синхронизация аудио и видео происходит в начале "
"каждого цикла, что иногда приводит к пропущенным кадрам. Установите "
"**Компенсацию задержки видео** в настройках вашего проекта на значение "
"**0**, чтобы избежать проблем с выпадением кадров."

msgid "Video decoding conditions and recommended resolutions"
msgstr "Условия декодирования видео и рекомендуемые разрешения"

msgid ""
"Video decoding is performed on the CPU, as GPUs don't have hardware "
"acceleration for decoding Theora videos. Modern desktop CPUs can decode Ogg "
"Theora videos at 1440p @ 60 FPS or more, but low-end mobile CPUs will likely "
"struggle with high-resolution videos."
msgstr ""
"Декодирование видео выполняется на CPU, поскольку GPU не имеют аппаратного "
"ускорения для декодирования видео Theora. Современные настольные процессоры "
"могут декодировать видео Ogg Theora с разрешением 1440p @ 60 FPS или более, "
"но мобильные процессоры низкого класса, скорее всего, не справятся с видео "
"высокого разрешения."

msgid "To ensure your videos decode smoothly on varied hardware:"
msgstr ""
"Чтобы обеспечить плавное декодирование ваших видео на различном оборудовании:"

msgid ""
"When developing games for desktop platforms, it's recommended to encode in "
"1080p at most (preferably at 30 FPS). Most people are still using 1080p or "
"lower resolution displays, so encoding higher-resolution videos may not be "
"worth the increased file size and CPU requirements."
msgstr ""
"При разработке игр для настольных платформ рекомендуется кодировать видео в "
"формате 1080p (желательно с частотой 30 кадров в секунду). Большинство людей "
"по-прежнему используют дисплеи с разрешением 1080p или ниже, поэтому "
"кодирование видео с более высоким разрешением может не стоить увеличения "
"размера файла и требований к процессору."

msgid ""
"When developing games for mobile or web platforms, it's recommended to "
"encode in 720p at most (preferably at 30 FPS or even lower). The visual "
"difference between 720p and 1080p videos on a mobile device is usually not "
"that noticeable."
msgstr ""
"При разработке игр для мобильных или веб-платформ рекомендуется кодировать в "
"формате 720p (предпочтительно с частотой 30 кадров в секунду или даже ниже). "
"Визуальная разница между видео 720p и 1080p на мобильном устройстве обычно "
"не так заметна."

msgid "Playback limitations"
msgstr "Ограничения воспроизведения"

msgid ""
"There are several limitations with the current implementation of video "
"playback in Godot:"
msgstr ""
"Текущая реализация воспроизведения видео в Godot имеет несколько ограничений:"

msgid "Seeking a video to a certain point is not supported."
msgstr "Досмотр видео до определенной точки не поддерживается."

msgid ""
"Changing playback speed is not supported. VideoStreamPlayer also won't "
"follow :ref:`Engine.time_scale<class_Engine_property_time_scale>`."
msgstr ""
"Изменение скорости воспроизведения не поддерживается. VideoStreamPlayer "
"также не будет "
"следовать :ref:`Engine.time_scale<class_Engine_property_time_scale>`."

msgid "Streaming a video from a URL is not supported."
msgstr "Потоковая передача видео из URL-адреса не поддерживается."

msgid "Recommended Theora encoding settings"
msgstr "Рекомендуемые параметры кодировки Theora"

msgid ""
"A word of advice is to **avoid relying on built-in Ogg Theora exporters** "
"(most of the time). There are 2 reasons you may want to favor using an "
"external program to encode your video:"
msgstr ""
"Небольшой совет: **Не полагайтесь на встроенные программы экспортирования "
"Ogg Theora** (в большинстве случаев). Есть 2 причины, по которым вы, "
"возможно, захотите использовать внешнюю программу для кодирования вашего "
"видео:"

msgid ""
"Some programs such as Blender can render to Ogg Theora. However, the default "
"quality presets are usually very low by today's standards. You may be able "
"to increase the quality options in the software you're using, but you may "
"find the output quality to remain less than ideal (given the increased file "
"size). This usually means that the software only supports encoding to "
"constant bit rate (CBR), instead of variable bit rate (VBR). VBR encoding "
"should be preferred in most scenarios as it provides a better quality to "
"file size ratio."
msgstr ""
"Некоторые программы, такие как Blender, могут выполнять рендеринг в Ogg "
"Theora. Однако предустановки качества по умолчанию обычно очень низкие по "
"современным стандартам. Возможно, вы сможете увеличить параметры качества в "
"используемой программе, но качество на выходе может оказаться ниже "
"идеального (учитывая увеличенный размер файла). Обычно это означает, что "
"программное обеспечение поддерживает кодирование только с постоянной "
"скоростью передачи данных (CBR), а не с переменной скоростью передачи данных "
"(VBR). В большинстве сценариев предпочтение следует отдавать кодированию "
"VBR, поскольку оно обеспечивает лучшее соотношение качества и размера файла."

msgid "Some other programs can't render to Ogg Theora at all."
msgstr "Другие программы совсем не могут рендерить в Ogg Theora."

msgid ""
"In this case, you can **render the video to an intermediate high-quality "
"format** (such as a high-bitrate H.264 video) then re-encode it to Ogg "
"Theora. Ideally, you should use a lossless or uncompressed format as an "
"intermediate format to maximize the quality of the output Ogg Theora video, "
"but this can require a lot of disk space."
msgstr ""
"В этом случае можно **преобразовать видео в промежуточный высококачественный "
"формат** (например, высокобитрейтный H.264), а затем повторно закодировать "
"его в Ogg Theora. В идеале для достижения максимального качества выходного "
"видео Ogg Theora следует использовать в качестве промежуточного формата "
"формат без потерь или без сжатия, но это может потребовать большого объема "
"дискового пространства."

msgid ""
"Here are example FFmpeg commands to convert an MP4 video to Ogg Theora. "
"Since FFmpeg supports a lot of input formats, you should be able to use the "
"commands below with almost any input video format (AVI, MOV, WebM, …)."
msgstr ""
"Вот примеры команд FFmpeg для преобразования видео MP4 в Ogg Theora. "
"Поскольку FFmpeg поддерживает множество входных форматов, вы сможете "
"использовать приведенные ниже команды практически с любым входным "
"видеоформатом (AVI, MOV, WebM, ...)."

msgid ""
"Make sure your copy of FFmpeg is compiled with libtheora and libvorbis "
"support. You can check this by running ``ffmpeg`` without any arguments, "
"then looking at the ``configuration:`` line in the command output."
msgstr ""
"Убедитесь, что ваша копия FFmpeg скомпилирована с поддержкой libtheora и "
"libvorbis. Вы можете проверить это, запустив ``ffmpeg`` без каких-либо "
"аргументов, а затем просмотрев строку ``configuration:`` в выходных данных "
"команды."

msgid "Balancing quality and file size"
msgstr "Балансирует между качеством и размером файла"

msgid ""
"The **video quality** level (``-q:v``) must be between ``1`` and ``10``. "
"Quality ``6`` is a good compromise between quality and file size. If "
"encoding at a high resolution (such as 1440p or 4K), you will probably want "
"to decrease ``-q:v`` to ``5`` to keep file sizes reasonable. Since pixel "
"density is higher on a 1440p or 4K video, lower quality presets at higher "
"resolutions will look as good or better compared to low-resolution videos."
msgstr ""
"Уровень **качества видео** (``-q:v``) должен находиться в диапазоне от ``1`` "
"до ``10``. Качество ``6`` является хорошим компромиссом между качеством и "
"размером файла. При кодировании в высоком разрешении (например, 1440p или "
"4K) для сохранения приемлемого размера файла, вероятно, потребуется "
"уменьшить ``-q:v`` до ``5``. Поскольку плотность пикселей на видео с "
"разрешением 1440p или 4K выше, пресеты с более низким качеством при высоком "
"разрешении будут выглядеть так же или даже лучше, чем видео с низким "
"разрешением."

msgid ""
"The **audio quality** level (``-q:a``) must be between ``-1`` and ``10``. "
"Quality ``6`` provides a good compromise between quality and file size. In "
"contrast to video quality, increasing audio quality doesn't increase the "
"output file size nearly as much. Therefore, if you want the cleanest audio "
"possible, you can increase this to ``9`` to get *perceptually lossless* "
"audio. This is especially valuable if your input file already uses lossy "
"audio compression. Higher quality audio does increase the CPU usage of the "
"decoder, so it might lead to audio dropouts in case of high system load. See "
"`this page <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__ for a table "
"listing Ogg Vorbis audio quality presets and their respective variable "
"bitrates."
msgstr ""
"Уровень **качества аудио** (``-q:a``) должен находиться диапазоне от ``-1`` "
"до ``10``. Качество ``6`` обеспечивает хороший компромисс между качеством и "
"размером файла. В отличие от качества видео, повышение качества звука не "
"приводит к значительному увеличению размера выходного файла. Поэтому, если "
"вы хотите получить максимально чистый звук, вы можете увеличить это значение "
"до ``9``, чтобы получить звук без потерь восприятия. Это особенно ценно, "
"если во входном файле уже используется сжатие звука с потерями. Более "
"высокое качество звука увеличивает нагрузку на процессор декодера, поэтому "
"при высокой нагрузке на систему это может привести к отключению звука. "
"Смотрите таблицу с настройками качества звука Ogg Vorbis и соответствующими "
"им переменными битрейтами на `этой странице <https://wiki.hydrogenaud.io/"
"index.php?title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__."

msgid "FFmpeg: Convert while preserving original video resolution"
msgstr "FFmpeg: Конвертирование с сохранением исходного разрешения видео"

msgid ""
"The following command converts the video while keeping its original "
"resolution. The video and audio's bitrate will be variable to maximize "
"quality while saving space in parts of the video/audio that don't require a "
"high bitrate (such as static scenes)."
msgstr ""
"Следующая команда преобразует видео с сохранением его исходного разрешения. "
"Битрейт видео и аудио будет изменяться, чтобы обеспечить максимальное "
"качество и одновременно сэкономить место в тех частях видео/аудио, которые "
"не требуют высокого битрейта (например, в статичных сценах)."

msgid "FFmpeg: Resize the video then convert it"
msgstr "FFmpeg: Изменить размер видео, затем конвертировать"

msgid ""
"The following command resizes a video to be 720 pixels tall (720p), while "
"preserving its existing aspect ratio. This helps decrease the file size "
"significantly if the source is recorded at a higher resolution than 720p:"
msgstr ""
"Следующая команда изменяет разрешение видео до 720 пикселей в высоту(720p), "
"при сохранении существующего соотношения сторон. Это поможет значительно "
"снизить размер файла, если он записан с разрешением выше чем 720p:"

msgid "Chroma Key Videos"
msgstr "Видео с хромакеем"

msgid ""
"Chroma key, commonly known as the \"green screen\" or \"blue screen\" "
"effect, allows you to remove a specific color from an image or video and "
"replace it with another background. This effect is widely used in video "
"production to composite different elements together seamlessly."
msgstr ""
"Хромакей(chroma key), широко известный как эффект \"зеленого экрана\" или "
"\"синего экрана\", позволяет удалить определенный цвет из изображения или "
"видео и заменить его другим фоном. Этот эффект широко используется в "
"видеопроизводстве для плавного объединения различных элементов."

msgid ""
"We will achieve the chroma key effect by writing a custom shader in GDScript "
"and using a `VideoStreamPlayer` node to display the video content."
msgstr ""
"Мы добьемся эффекта хромакея, написав пользовательский шейдер на GDScript и "
"используя узел `VideoStreamPlayer` для отображения видеоконтента."

msgid "Scene Setup"
msgstr "Настройка сцены"

msgid ""
"Ensure that the scene contains a `VideoStreamPlayer` node to play the video "
"and a `Control` node to hold the UI elements for controlling the chroma key "
"effect."
msgstr ""
"Убедитесь, что сцена содержит узел `VideoStreamPlayer` для воспроизведения "
"видео и узел `Control` для размещения элементов пользовательского интерфейса "
"для управления эффектом хромакея."

msgid "Writing the Custom Shader"
msgstr "Написание пользовательского шейдера"

msgid "To implement the chroma key effect, follow these steps:"
msgstr "Чтобы реализовать эффект хромакея, выполните следующие действия:"

msgid ""
"Select the `VideoStreamPlayer` node in the scene and go to its properties. "
"Under `CanvasItem > Material`, create a new shader named "
"\"ChromaKeyShader.gdshader.\""
msgstr ""
"Выберите узел `VideoStreamPlayer` в сцене и перейдите к его свойствам. В "
"разделе `CanvasItem > Material` создайте новый шейдер с именем "
"\"ChromaKeyShader.gdshader.\""

msgid ""
"In the \"ChromaKeyShader.gdshader\" file, write the custom shader code as "
"shown below:"
msgstr ""
"В файле \"ChromaKeyShader.gdshader\" напишите пользовательский код шейдера, "
"как показано ниже:"

msgid ""
"The shader uses the distance calculation to identify pixels close to the "
"chroma key color and discards them, effectively removing the selected color. "
"Pixels that are slightly further away from the chroma key color are faded "
"based on the fade_factor, blending them smoothly with the surrounding "
"colors. This process creates the desired chroma key effect, making it appear "
"as if the background has been replaced with another image or video."
msgstr ""
"Шейдер использует вычисление расстояния для определения пикселей, близких к "
"цвету хромакея, и отбрасывает их, эффективно удаляя выбранный цвет. Пиксели, "
"которые находятся немного дальше от цвета цветовой гаммы, затемняются в "
"соответствии с параметром fade_factor, что позволяет плавно смешивать их с "
"окружающими цветами. Этот процесс создает желаемый эффект цветности, "
"создавая впечатление, что фон был заменен другим изображением или видео."

msgid ""
"The code above represents a simple demonstration of the Chroma Key shader, "
"and users can customize it according to their specific requirements."
msgstr ""
"Приведенный выше код представляет собой простую демонстрацию шейдера "
"хромакея, и пользователи могут настроить его в соответствии со своими "
"конкретными требованиями."

msgid "UI Controls"
msgstr "Элементы управления пользовательским интерфейсом"

msgid ""
"To allow users to manipulate the chroma key effect in real-time, we created "
"sliders in the `Control` node. The `Control` node's script contains the "
"following functions:"
msgstr ""
"Чтобы пользователи могли управлять эффектом хромакея в режиме реального "
"времени, мы создали ползунки в `Control`. Скрипт узла `Control` содержит "
"следующие функции:"

msgid ""
"also make sure that the range of the sliders are appropriate, our settings "
"are :"
msgstr ""
"также убедитесь, что диапазон ползунков соответствующий, наши настройки "
"следующие :"

msgid "Signal Handling"
msgstr "Обработка сигналов"

msgid ""
"Connect the appropriate signal from the UI elements to the `Control` node's "
"script. you created in the `Control` node's script to control the chroma key "
"effect. These signal handlers will update the shader's uniform variables in "
"response to user input."
msgstr ""
"Подключите соответствующий сигнал от элементов пользовательского интерфейса "
"к скрипту узла `Control`. Вы создали в скрипте узла `Control` скрипт для "
"управления эффектом хромакея. Эти обработчики сигналов будут обновлять "
"переменные формы шейдера в ответ на вводимые пользователем данные."

msgid ""
"Save and run the scene to see the chroma key effect in action! With the "
"provided UI controls, you can now adjust the chroma key color, pickup range, "
"and fade amount in real-time, achieving the desired chroma key functionality "
"for your video content."
msgstr ""
"Сохраните и запустите сцену, чтобы увидеть эффект хромакея в действии! С "
"помощью встроенных элементов управления пользовательского интерфейса теперь "
"вы можете настраивать цвет хромакея, диапазон захвата и степень затухания в "
"режиме реального времени, добиваясь желаемой функциональности хромакея для "
"вашего видеоконтента."
