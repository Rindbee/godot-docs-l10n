#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "Использование InputEvent"

msgid "What is it?"
msgstr "Что это?"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"Управлять вводом обычно сложно, независимо от ОС или платформы. Чтобы "
"немного упростить это, предоставляется специальный встроенный "
"тип :ref:`InputEvent <class_InputEvent>`. Этот тип данных может быть "
"настроен на несколько типов входных событий. Входные события проходят через "
"движок и могут быть получены в нескольких местах, в зависимости от цели."

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr ""
"Вот короткий пример, закрывающий вашу игру, если нажата клавиша Escape:"

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"Однако более чистым и гибким является использование предоставляемой "
"функции :ref:`InputMap <class_InputMap>`, которая позволяет определить "
"действия ввода и назначить им различные клавиши. Таким образом, вы можете "
"определить несколько клавиш для одного и того же действия (например, клавиша "
"\"escape\" на клавиатуре и кнопка \"start\" на геймпаде). Затем вы можете "
"легко изменить это сопоставление в настройках проекта, не обновляя код, и "
"даже создать функцию сопоставления клавиш поверх этой функции, чтобы ваша "
"игра могла изменять сопоставление клавиш во время выполнения!"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"Вы можете настроить свою InputMap в разделе **Project > Project Settings > "
"Input Map**, а затем использовать эти действия следующим образом:"

msgid "How does it work?"
msgstr "Как это работает?"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"Каждое событие ввода инициируется пользователем/игроком (хотя можно "
"сгенерировать событие InputEvent и передать его обратно движку, что полезно "
"для жестов). DisplayServer для каждой платформы будет считывать события из "
"операционной системы и передавать их корневому объекту :ref:`Window "
"<class_Window>`."

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"Окно :ref:`Viewport <class_Viewport>` выполняет довольно много действий с "
"полученными входными данными, в следующем порядке:"

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"Если Viewport внедряет Windows, Viewport пытается интерпретировать событие с "
"точки зрения своих возможностей как оконного менеджера (например, для "
"изменения размера или перемещения окон)."

msgid ""
"Next if an embedded Window is focused, the event is sent to that Window and "
"processed in the Windows Viewport and afterwards treated as handled. If no "
"embedded Window is focused, the event is sent to the nodes of the current "
"viewport in the following order."
msgstr ""
"Далее, если фокус установлен на встроенном окне, событие отправляется этому "
"окну и обрабатывается в области просмотра Windows, после чего считается "
"обработанным. Если фокус не установлен ни на одном встроенном окне, событие "
"отправляется узлам текущей области просмотра в следующем порядке."

msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing "
"with :ref:`Node.set_process_input() <class_Node_method_set_process_input>`). "
"If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"Прежде всего, стандартная функция :ref:`Node._input() "
"<class_Node_private_method__input>` будет вызвана в любом узле, который ее "
"переопределяет (и не отключил обработку ввода с "
"помощью :ref:`Node.set_process_input() "
"<class_Node_method_set_process_input>`). Если какая-либо функция использует "
"событие, она может вызвать :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, и событие больше не будет "
"распространяться. Это гарантирует, что вы сможете фильтровать все "
"интересующие вас события, даже до того, как графический интерфейс. Для ввода "
"игрового процесса, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` , как правило, подходит лучше, "
"поскольку позволяет графическому интерфейсу перехватывать события."

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will "
"call :ref:`Control.accept_event() <class_Control_method_accept_event>` and "
"the event will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether "
"a :ref:`Control <class_Control>` is notified of mouse events "
"via :ref:`Control._gui_input() <class_Control_private_method__gui_input>` "
"callback, and whether these events are propagated further."
msgstr ""
"Во-вторых, он попытается передать входные данные в графический интерфейс и "
"проверить, сможет ли какой-либо элемент управления их принять. Если это так, "
"то :ref:`Control <class_Control>` будет вызван через виртуальную "
"функцию :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` будет подан сигнал \"gui_input\" "
"(эта функция может быть повторно реализована скриптом путем наследования от "
"него). Если элемент управления хочет \"потребить\" событие, он "
"вызовет :ref:`Control.accept_event() <class_Control_method_accept_event>`, и "
"событие больше не будет распространяться. Используйте "
"свойство :ref:`Control.mouse_filter <class_Control_property_mouse_filter>` "
"чтобы управлять тем, будет ли :ref:`Control <class_Control>` уведомляться о "
"событиях мыши с помощью обратного вызова :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, а также тем, будут ли эти "
"события распространяться дальше."

msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only "
"for :ref:`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"Если до сих пор никто не воспользовался событием, будет вызван обратный "
"вызов :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` , если он переопределен (и не "
"отключен с помощью :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). Это происходит только "
"для :ref:`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` и :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. Если какая-либо функция использует событие, "
"она может вызвать :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, и событие больше не будет "
"распространяться. Обратный вызов ввода сокращенного кода идеально подходит "
"для обработки событий, которые предназначены для сокращенного кода."

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled "
"with :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is an :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"Если до сих пор никто не воспользовался событием, будет вызван обратный "
"вызов :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>`, если он переопределен (и "
"не отключен с помощью :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). Это происходит только "
"в том случае, если событие является :ref:`InputEventKey "
"<class_InputEventKey>`. Если какая-либо функция использует событие, она "
"может вызвать :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, и событие больше не будет "
"распространяться. Обратный вызов необработанного ввода с клавиатуры идеально "
"подходит для событий с клавишами."

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"Если до сих пор никто не воспользовался событием, будет вызван обратный "
"вызов :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` , если он переопределен (и не "
"отключен с помощью :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). Если какая-либо функция "
"использует событие, она может вызвать :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, и событие больше не будет "
"распространяться. Обратный вызов необработанного ввода идеально подходит для "
"событий полноэкранного игрового процесса, поэтому они не поступают, когда "
"активен графический интерфейс."

msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled "
"in :ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"Если событие пока никому не нужно и :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` включено, событие "
"используется для выбора объекта. Для корневого окна просмотра это также "
"можно включить в :ref:`Project Settings "
"<class_ProjectSettings_property_physics/common/enable_object_picking>`. В "
"случае 3D-сцены, если :ref:`Camera3D <class_Camera3D>` назначено окну "
"просмотра, будет проложен луч в физический мир (в направлении от точки "
"щелчка). Если этот луч попадает на объект, он вызовет "
"функцию :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` в соответствующем "
"физическом объекте. В случае 2D-сцены концептуально то же самое происходит "
"с :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"При отправке событий в свои дочерние и подчиненные узлы окна просмотра будет "
"делать это, как показано на следующем рисунке, в обратном порядке глубины, "
"начиная с узла в нижней части дерева сцены и заканчивая корневым узлом. Из "
"этого процесса исключены Windows и SubViewports."

msgid ""
"This order doesn't apply to :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, which uses a different method "
"based on event location or focused Control. GUI **mouse** events also travel "
"up the scene tree, subject to the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` restrictions described above. "
"However, since these events target specific Controls, only direct ancestors "
"of the targeted Control node receive the event. GUI **keyboard and joypad** "
"events *do not* travel up the scene tree, and can only be handled by the "
"Control that received them. Otherwise, they will be propagated as non-GUI "
"events through :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`."
msgstr ""
"Этот порядок не применяется к :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, который использует другой метод "
"в зависимости от местоположения события или сфокусированного элемента "
"Control. События GUI (графического интерфейса) **mouse** также перемещаются "
"вверх по дереву сцены в соответствии с "
"ограничениями :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>`, описанными выше. Однако, поскольку "
"эти события направлены на конкретные элементы Control, только прямые предки "
"целевого узла управления получают событие. События графического интерфейса "
"**keyboard and joypad** *не* перемещаются по дереву сцены и могут быть "
"обработаны только тем элементом управления, который их получил. В противном "
"случае они будут распространяться как события, не связанные с графическим "
"интерфейсом пользователя :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`."

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"Поскольку Viewports не отправляют события другим :ref:`SubViewports "
"<class_SubViewport>`, необходимо использовать один из следующих методов:"

msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
"Используйте :ref:`SubViewportContainer <class_SubViewportContainer>`, "
"который автоматически отправляет события своему дочернему "
"элементу :ref:`SubViewports <class_SubViewport>` после :ref:`Node._input() "
"<class_Node_private_method__input>` или :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."

msgid "Implement event propagation based on the individual requirements."
msgstr ""
"Реализовать распространение событий на основе индивидуальных требований."

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"В соответствии с node-дизайном Godot это позволяет специализированным "
"дочерним узлам обрабатывать и потреблять определенные события, в то время "
"как их предки и, в конечном счете, корень сцены могут обеспечить более "
"обобщенное поведение, если это необходимо."

msgid "Anatomy of an InputEvent"
msgstr "Анатомия InputEvent"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` - это просто базовый встроенный тип, он "
"ничего не представляет и содержит только некоторую базовую информацию, такую "
"как ID события (который увеличивается для каждого события), индекс "
"устройства и т. д."

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr ""
"Существует несколько специализированных типов InputEvent, описанных в "
"таблице ниже:"

msgid "Event"
msgstr "Событие"

msgid "Description"
msgstr "Описание"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "Пустое входное событие."

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "Содержит код ключа и значение Unicode, а также модификаторы."

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr "Содержит информацию о щелчке, такую как кнопка, модификаторы и т. д."

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr ""
"Содержит информацию о движении, такую как относительное и абсолютное "
"положение и скорость."

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "Содержит информацию об аналоговой оси Joystick/Joypad."

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "Содержит информацию о кнопке Joystick/Joypad."

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr ""
"Содержит информацию о нажатии/отпускании с несколькими касаниями. (доступно "
"только на мобильных устройствах)"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr ""
"Содержит информацию о перетаскивании с помощью мультисенсорного ввода. "
"(доступно только на мобильных устройствах)"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "Содержит позицию, фактор, а также модификаторы."

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr ""
"Содержит позицию (position), дельту (delta), а также модификаторы "
"(modifiers)."

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr ":ref:`InputEventMIDI <class_InputEventMIDI>`"

msgid "Contains MIDI-related information."
msgstr "Содержит информацию, связанную с MIDI."

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr ":ref:`InputEventShortcut <class_InputEventShortcut>`"

msgid "Contains a shortcut."
msgstr "Содержит ярлык."

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr ""
"Содержит общее действие. Эти события часто генерируются программистом в виде "
"обратной связи. (подробнее об этом ниже)"

msgid "Input actions"
msgstr "Действия ввода"

msgid ""
"Input actions are a grouping of zero or more InputEvents into a commonly "
"understood title (for example, the default \"ui_left\" action grouping both "
"joypad-left input and a keyboard's left arrow key). They are not required to "
"represent an InputEvent but are useful because they abstract various inputs "
"when programming the game logic."
msgstr ""
"Input actions (Действия ввода) представляют собой группировку нуля или более "
"событий InputEvent в общепонятное название (например, действие по умолчанию "
"\"ui_left\", объединяющее как нажатие левой кнопки джойстика, так и нажатие "
"клавиши «стрелка влево» на клавиатуре). Они не обязательно должны "
"представлять событие InputEvent, но полезны, поскольку абстрагируют "
"различные входные данные при программировании игровой логики."

msgid "This allows for:"
msgstr "Это позволяет:"

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"Один и тот же код работать на разных устройствах с разным вводом (например, "
"клавиатура на ПК, джойстик на консоли)."

msgid "Input to be reconfigured at runtime."
msgstr "Входные данные подлежат перенастройке во время выполнения."

msgid "Actions to be triggered programmatically at runtime."
msgstr "Действия, которые должны быть запущены программно во время выполнения."

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr ""
"Действия можно создавать в меню Project Settings на вкладке **Input Map** и "
"назначать входные события."

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"В качестве альтернативы может потребоваться вернуть в игру действие из "
"игрового кода (хорошим примером этого является обнаружение жестов). Входной "
"синглтон имеет для этого метод: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. Обычно вы использовали бы это так:"

msgid ""
"See :ref:`doc_first_3d_game_input_actions` for a tutorial on adding input "
"actions in the project settings."
msgstr ""
"Инструкцию по добавлению действий ввода в настройках проекта см. "
"в :ref:`doc_first_3d_game_input_actions`."

msgid "InputMap"
msgstr "InputMаp"

msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at runtime. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"Часто требуется настройка и переназначение входных данных из кода. Если весь "
"ваш рабочий процесс зависит от действий, синглтон :ref:`InputMap "
"<class_InputMap>` идеально подходит для переназначения или создания "
"различных действий во время выполнения. Этот синглтон не сохраняется (должен "
"быть изменен вручную), а его состояние определяется настройками проекта "
"(project.godot). Поэтому любая динамическая система такого типа должна "
"хранить настройки так, как считает нужным программист."
