#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "Высокоуровневый мультиплеер"

msgid "High-level vs low-level API"
msgstr "Высокоуровневый API против низкоуровнего"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"Ниже объясняются различия между высоко- и низкоуровневых сетей в Godot, а "
"также некоторые базовые основы. Если вы хотите перейти сразу к делу и "
"добавить сеть в свои первые узлы, перейдите к разделу `Инициализация сети`_ "
"ниже. Но не забудьте прочитать остальные разделы позже!"

msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot всегда поддерживал стандартные низкоуровневые сетевые "
"протоколы: :abbr:`UDP (User Datagram Protocol)`, :abbr:`TCP (Transmission "
"Control Protocol)` и высокоуровневые протоколы вроде :abbr:`HTTP (Hypertext "
"Transfer Protocol)` и :abbr:`SSL (Secure Sockets Layer)`. Эти протоколы "
"гибки и применимы практически для любых задач. Однако ручная синхронизация "
"игрового состояния с их помощью требует значительных усилий. Иногда это "
"неизбежно или оправдано, например при работе с кастомной серверной "
"реализацией. Но в большинстве случаев стоит использовать высокоуровневый "
"сетевой API Godot, который жертвует частью детального контроля ради удобства "
"разработки."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "Это связано с присущими ему ограничениями протоколов низкого уровня:"

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP гарантирует, что пакеты всегда будут поступать надежно и в правильном "
"порядке, но задержка обычно выше из-за исправления ошибок. Это также "
"довольно сложный протокол, потому что он понимает, что такое \"соединение\", "
"и оптимизируется для целей, которые часто не подходят для приложений, таких "
"как многопользовательские игры. Пакеты буферизуются для отправки большими "
"партиями, что снижает накладные расходы на пакеты для увеличения задержки. "
"Это может быть полезно для таких вещей, как HTTP, но обычно не для игр. "
"Некоторые из них можно настроить и отключить (например, отключив \"алгоритм "
"Nagle\" для TCP-подключения)."

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP - это более простой протокол, который только отправляет пакеты (и не "
"имеет понятия \"соединение\"). Отсутствие коррекции ошибок делает его "
"довольно быстрым (низкая задержка), но пакеты могут быть потеряны по пути "
"или получены в неправильном порядке. Кроме того, MTU (максимальный размер "
"пакета) для UDP обычно невелик (всего несколько сотен байт), поэтому "
"передача больших пакетов означает их разделение, реорганизацию и повторную "
"попытку в случае неудачи."

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"В целом, TCP можно считать надежным, упорядоченным и медленным; UDP - "
"ненадежным, неупорядоченным и быстрым. Из-за большой разницы в "
"производительности часто имеет смысл перестроить те части TCP, которые нужны "
"для игр (необязательная надежность и порядок пакетов), избегая при этом "
"ненужных частей (функции контроля перегрузок/трафика, алгоритм Нагла и "
"т.д.). В связи с этим большинство игровых движков поставляются с такой "
"реализацией, и Godot не является исключением."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"В итоге вы можете использовать низкоуровневый сетевой API для максимального "
"контроля и реализации всего поверх базовых сетевых протоколов или "
"использовать высокоуровневый API на основе :ref:`SceneTree "
"<class_SceneTree>`, который выполняет основную сложную работу за кулисами "
"оптимальным образом."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Большинство поддерживаемых Godot платформ предлагают все или большинство из "
"перечисленных высоко- и низкоуровневых сетевых функций. Однако, поскольку "
"сетевое взаимодействие всегда в значительной степени зависит от аппаратного "
"обеспечения и операционной системы, некоторые функции могут быть изменены "
"или недоступны на некоторых целевых платформах. В частности, платформа HTML5 "
"в настоящее время предлагает поддержку WebSockets и WebRTC, но не имеет "
"некоторых высокоуровневых функций, а также необработанного доступа к "
"низкоуровневым протоколам, таким как TCP и UDP."

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"Подробнее о TCP/IP, UDP и сети: https://gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"На сайте Gaffer On Games представлено множество полезных статей о сетевых "
"технологиях в играх (`здесь <https://gafferongames.com/categories/game-"
"networking/>`__), включая исчерпывающее `введение в сетевые модели для игр "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"Добавление сетевых функций в игру накладывает на вас ответственность. При "
"неправильной реализации это может сделать ваше приложение уязвимым и "
"привести к читам или эксплойтам. Более того, злоумышленники могут "
"скомпрометировать машины, на которых работает ваше приложение, и "
"использовать ваши серверы для рассылки спама, атак на других или кражи "
"данных пользователей вашей игры."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"Это тот случай, когда сеть существует и не имеет ничего общего с Godot. "
"Конечно, вы можете экспериментировать, но когда вы выпускаете сетевое "
"приложение, всегда заботьтесь о любых возможных проблемах безопасности."

msgid "Mid-level abstraction"
msgstr "Среднеуровневая абстракция"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"Прежде чем перейти к тому, как синхронизировать игру по сети, может быть "
"полезно понять, как работает базовый сетевой API для синхронизации."

msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot использует среднеуровневый объект :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. Этот объект не предназначен для прямого создания, "
"а спроектирован так, чтобы различные реализации на C++ могли его "
"предоставлять."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"Этот объект простирается от :ref:`PacketPeer <class_PacketPeer>` таким "
"образом, он наследует все полезные методы сериализации, отправки и получения "
"данных. Кроме того, он добавляет методы для установки однорангового узла, "
"режима передачи и т. д. Она также включает в себя сигналы, которые позволят "
"вам знать, когда участник сети подключается или отключается."

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet "
"(:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on "
"WebRTC (:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one "
"based on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this "
"could be used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or "
"custom device/console-specific networking APIs."
msgstr ""
"Интерфейс этого класса может абстрагировать большинство типов сетевых "
"уровней, топологий и библиотек. По умолчанию Godot предоставляет реализацию "
"на основе ENet (:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), на "
"основе WebRTC (:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`) и "
"на основе WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), но его "
"также можно использовать для реализации мобильных API (для ad hoc Wi-Fi, "
"Bluetooth) или пользовательских сетевых API, специфичных для устройств/"
"консолей."

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"В большинстве случаев прямое использование этого объекта не рекомендуется, "
"так как Godot предоставляет ещё более высокоуровневые сетевые возможности. "
"Этот объект остаётся доступным на случай, если игре потребуются "
"специфические функции низкоуровневого API."

msgid "Hosting considerations"
msgstr "Размышления о хостинге"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form "
"``192.168.*.*``. This internal IP address is **not** reachable by non-LAN/"
"Internet clients."
msgstr ""
"При запуске сервера клиенты в вашей :abbr:`локальной сети (LAN)` могут "
"подключиться, используя внутренний IP-адрес, обычно вида ``192.168.*.*``. "
"Этот внутренний IP-адрес **не** доступен для клиентов вне локальной сети/"
"интернета."

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""
"В Windows вы можете найти свой внутренний IP-адрес, открыв командную строку "
"и введя ``ipconfig``. В macOS откройте Терминал и введите ``ifconfig``. В "
"Linux откройте терминал и введите ``ip addr``."

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""
"Если вы размещаете сервер на своём компьютере и хотите, чтобы клиенты вне "
"локальной сети могли к нему подключиться, вам, вероятно, потребуется "
"*пробросить* порт сервера на вашем роутере. Это необходимо для доступности "
"сервера из интернета, так как большинство домашних подключений используют "
"`NAT <https://en.wikipedia.org/wiki/Network_address_translation>`__. "
"Высокоуровневый мультиплеерный API Godot использует только UDP, поэтому вы "
"должны пробросить порт именно для UDP, а не только для TCP."

msgid ""
"After forwarding a UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""
"После проброски UDP-порта и подтверждения, что ваш сервер использует этот "
"порт, вы можете определить ваш публичный IP-адрес с помощью `этого сайта "
"<https://icanhazip.com/>`__. Затем сообщите этот публичный IP-адрес интернет-"
"клиентам, желающим подключиться к вашему серверу."

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr ""
"Высокоуровневый мультиплеерный API Godot использует модифицированную версию "
"ENet с полной поддержкой IPv6."

msgid "Initializing the network"
msgstr "Инициализация сети"

msgid ""
"High-level networking in Godot is managed by the :ref:`SceneTree "
"<class_SceneTree>`."
msgstr ""
"Высокоуровневое сетевое взаимодействие в Godot управляется :ref:`SceneTree "
"<class_SceneTree>`."

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""
"Каждый узел имеет свойство ``multiplayer``, которое ссылается на экземпляр "
"``MultiplayerAPI``, настроенный для него деревом сцен. Изначально каждый "
"узел использует один и тот же объект ``MultiplayerAPI`` по умолчанию."

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""
"Для инициализации сетевого взаимодействия необходимо создать объект "
"``MultiplayerPeer``, настроить его как сервер/клиент и передать его в "
"``MultiplayerAPI``."

msgid "To terminate networking:"
msgstr "Закрытие сетевых функции :"

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"При экспорте под Android обязательно включите разрешение ``INTERNET`` в "
"пресете экспорта Android до экспорта проекта или использования "
"одноразвёртывания. Иначе любое сетевое взаимодействие будет заблокировано "
"системой Android."

msgid "Managing connections"
msgstr "Управление соединениями"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""
"Каждому пиру присваивается уникальный ID. ID сервера всегда равен 1, а "
"клиентам назначаются случайные положительные целые числа."

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr ""
"Реагировать на подключения и отключения можно через подключение к сигналам "
"``MultiplayerAPI``:"

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""
"``peer_connected(id: int)`` Этот сигнал испускается с ID новоподключённого "
"пира на каждом другом пире, а на новом пире - несколько раз, по одному разу "
"для каждого другого пира с его ID."

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""
"``peer_disconnected(id: int)`` Этот сигнал испускается на каждом оставшемся "
"пире при отключении одного из участников."

msgid "The rest are only emitted on clients:"
msgstr "Остальные сигналы испускаются только на клиентах:"

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr "Чтобы получить уникальный ID ассоциированного пира:"

msgid "To check whether the peer is server or client:"
msgstr "Чтобы проверить, является ли пир сервером или клиентом:"

msgid "Remote procedure calls"
msgstr "Удалённые вызовы процедур (RPC)"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""
"Удалённые вызовы процедур (RPC) — это функции, которые можно вызывать на "
"других пирах. Для создания RPC используйте аннотацию ``@rpc`` перед "
"определением функции. Чтобы вызвать RPC, используйте метод ``rpc()`` объекта "
"``Callable`` для вызова на всех пирах или ``rpc_id()`` для вызова на "
"определённом пире."

msgid "RPCs will not serialize objects or callables."
msgstr "RPC не могут сериализовать объекты или вызываемые объекты (callables)."

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""
"Для успешного удалённого вызова узел-отправитель и узел-получатель должны "
"иметь одинаковый ``NodePath``, что подразумевает одинаковые имена. При "
"использовании ``add_child()`` для узлов, которые будут использовать RPC, "
"установите аргумент ``force_readable_name`` в ``true``."

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""
"Если функция помечена как ``@rpc`` в клиентском скрипте (или соответственно "
"в серверном скрипте), то она должна быть объявлена и в серверном скрипте "
"(соответственно в клиентском). Обе RPC-функции должны иметь **идентичную "
"сигнатуру**, которая проверяется по контрольной сумме **всех RPC в "
"скрипте**. Все RPC в скрипте проверяются одновременно, и все RPC должны быть "
"объявлены как в клиентских, так и в серверных скриптах, **даже если функции "
"в данный момент не используются**."

msgid ""
"The signature of the RPC includes the ``@rpc()`` declaration, the function, "
"return type, **and** the NodePath. If an RPC resides in a script attached to "
"``/root/Main/Node1``, then it must reside in precisely the same path and "
"node on both the client script and the server script. Function arguments are "
"not checked for matching between the server and client code (example: ``func "
"sendstuff():`` and ``func sendstuff(arg1, arg2):`` **will pass** signature "
"matching)."
msgstr ""
"Сигнатура RPC включает объявление ``@rpc()``, функцию, тип возврата **и** "
"NodePath. Если RPC находится в скрипте, прикреплённом к ``/root/Main/"
"Node1``, то он должен находиться по точно такому же пути на узле как в "
"клиентском, так и в серверном скрипте. Аргументы функции **не проверяются** "
"на совпадение между серверным и клиентским кодом (пример: ``func "
"sendstuff():`` и ``func sendstuff(arg1, arg2):`` **пройдут** проверку "
"сигнатуры)."

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""
"Если эти условия не соблюдены (если все RPC не проходят сверку сигнатур), "
"скрипт может вывести ошибку или вызвать нежелательное поведение. Сообщение "
"об ошибке может быть не связано с функцией RPC, которую вы в данный момент "
"разрабатываете и тестируете."

msgid ""
"See further explanation and troubleshooting on `this post <https://"
"github.com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""
"Дополнительные пояснения и способы устранения неполадок см. в `этой "
"публикации <https://github.com/godotengine/godot/issues/"
"57869#issuecomment-1034215138>`__."

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr ""
"Аннотация может принимать несколько аргументов, которые имеют значения по "
"умолчанию. ``@rpc`` эквивалентно:"

msgid "The parameters and their functions are as follows:"
msgstr "Параметры и их функции приведены ниже:"

msgid "``mode``:"
msgstr "``mode``:"

msgid ""
"``\"authority\"``: Only the multiplayer authority can call remotely. The "
"authority is the server by default, but can be changed per-node "
"using :ref:`Node.set_multiplayer_authority "
"<class_Node_method_set_multiplayer_authority>`."
msgstr ""
"``\"authority\"``: Только мультиплеерный авторитет может вызывать удалённо. "
"По умолчанию авторитетом является сервер, но его можно изменить для каждого "
"узла с помощью :ref:`Node.set_multiplayer_authority "
"<class_Node_method_set_multiplayer_authority>`."

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr ""
"``\"any_peer\"``: Клиентам разрешено вызывать удалённо. Полезно для передачи "
"пользовательского ввода."

msgid "``sync``:"
msgstr "``sync``:"

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "``\"call_remote\"``: Функция не будет вызываться на локальном пире."

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""
"``\"call_local\"``: Функция может вызываться на локальном пире. Полезно, "
"когда сервер также является игроком."

msgid "``transfer_mode``:"
msgstr "``transfer_mode``:"

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr ""
"``\"unreliable\"`` Пакеты не подтверждаются, могут теряться и приходить в "
"произвольном порядке."

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""
"``\"unreliable_ordered\"`` Пакеты принимаются в порядке их отправки. Это "
"достигается игнорированием пакетов, приходящих позже, если пакет, "
"отправленный после них, уже получен. Может вызывать потерю пакетов при "
"неправильном использовании."

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""
"``\"reliable\"``: Предпринимаются попытки повторной отправки до "
"подтверждения получения пакетов, и их порядок сохраняется. Это приводит к "
"**значительному** снижению производительности."

msgid "``transfer_channel`` is the channel index."
msgstr "``transfer_channel`` — это индекс канала."

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr ""
"Первые три можно передавать в любом порядке, но ``transfer_channel`` всегда "
"должен быть последним."

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""
"Функцию ``multiplayer.get_remote_sender_id()`` можно использовать для "
"получения уникального идентификатора отправителя RPC, при использовании "
"внутри метода, вызванного через RPC."

msgid "Channels"
msgstr "Каналы"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""
"Современные сетевые протоколы поддерживают каналы — это отдельные соединения "
"**внутри** подключения. Это позволяет создавать несколько независимых "
"потоков пакетов, которые не создают помех друг другу."

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""
"Например, сообщения чата и важные сообщения игрового процесса должны "
"отправляться надёжно (`reliable`), но сообщение геймплея не должно ожидать "
"подтверждения сообщения чата. Этого можно достичь, используя разные каналы."

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""
"Каналы также полезны при использовании с ненадёжным упорядоченным режимом "
"передачи. Отправка пакетов переменного размера в этом режиме может вызывать "
"потерю пакетов, поскольку более медленные пакеты игнорируются. Разделение на "
"несколько потоков однородных пакетов через разные каналы позволяет "
"обеспечить упорядоченную передачу с минимальными потерями и без задержек, "
"характерных для надёжного режима."

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr ""
"Канал по умолчанию с индексом 0 фактически представляет собой три разных "
"канала — по одному для каждого режима передачи."

msgid "Example lobby implementation"
msgstr "Пример реализации лобби"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""
"Это пример лобби, которое может обрабатывать подключение и отключение пиров, "
"уведомлять UI-сцены через сигналы и запускать игру после того, как все "
"клиенты загрузили игровую сцену."

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr ""
"Корневой узел игровой сцены должен называться ``Game``. В прикреплённом к "
"нему скрипте:"

msgid "Exporting for dedicated servers"
msgstr "Экспортирование на выделенные серверы"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. "
"See :ref:`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"После создания многопользовательской игры вы можете экспортировать её для "
"запуска на выделенном сервере без доступного GPU. Дополнительную информацию "
"см. в :ref:`doc_exporting_for_dedicated_servers`."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"Примеры кода на этой странице не предназначены для запуска на выделенном "
"сервере. Вам потребуется их модифицировать, чтобы сервер не считался "
"игроком. Также необходимо изменить механизм начала игры, чтобы первый "
"присоединившийся игрок мог её запустить."
