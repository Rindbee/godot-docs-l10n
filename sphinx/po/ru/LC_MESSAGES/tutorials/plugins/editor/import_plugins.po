#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Import plugins"
msgstr "Импорт плагинов"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page. This also assumes you "
"are acquainted with Godot's import system."
msgstr ""
"В этом руководстве предполагается, что вы уже умеете создавать универсальные "
"плагины. Если у вас возникли сомнения, обратитесь к "
"странице :ref:`doc_making_plugins`. Также предполагается, что вы знакомы с "
"системой импорта Godot."

msgid "Introduction"
msgstr "Введение"

msgid ""
"An import plugin is a special type of editor tool that allows custom "
"resources to be imported by Godot and be treated as first-class resources. "
"The editor itself comes bundled with a lot of import plugins to handle the "
"common resources like PNG images, Collada and glTF models, Ogg Vorbis "
"sounds, and many more."
msgstr ""
"Плагин импорта — это особый тип инструмента редактора, который позволяет "
"Godot импортировать пользовательские ресурсы и обрабатывать их как ресурсы "
"первого класса. Сам редактор поставляется с множеством плагинов импорта для "
"работы с распространёнными ресурсами, такими как изображения PNG, модели "
"Collada и glTF, звуки Ogg Vorbis и многое другое."

msgid ""
"This tutorial shows how to create an import plugin to load a custom text "
"file as a material resource. This text file will contain three numeric "
"values separated by comma, which represents the three channels of a color, "
"and the resulting color will be used as the albedo (main color) of the "
"imported material. In this example it contains the pure blue color (zero "
"red, zero green, and full blue):"
msgstr ""
"В этом руководстве показано, как создать плагин импорта для загрузки "
"пользовательского текстового файла в качестве ресурса материала. Этот "
"текстовый файл будет содержать три числовых значения, разделённых запятой, "
"которые представляют три канала цвета, а полученный цвет будет "
"использоваться в качестве альбедо (основного цвета) импортируемого "
"материала. В этом примере он содержит чистый синий цвет (без красного, без "
"зелёного и полностью синий):"

msgid "Configuration"
msgstr "Конфигурация"

msgid ""
"First we need a generic plugin that will handle the initialization and "
"destruction of our import plugin. Let's add the ``plugin.cfg`` file first:"
msgstr ""
"Для начала нам нужен универсальный плагин, который будет управлять "
"инициализацией и удалением нашего импортируемого плагина. Сначала добавим "
"файл ``plugin.cfg``:"

msgid ""
"Then we need the ``material_import.gd`` file to add and remove the import "
"plugin when needed:"
msgstr ""
"Затем нам понадобится файл ``material_import.gd`` для добавления и удаления "
"плагина импорта при необходимости:"

msgid ""
"When this plugin is activated, it will create a new instance of the import "
"plugin (which we'll soon make) and add it to the editor using "
"the :ref:`add_import_plugin() <class_EditorPlugin_method_add_import_plugin>` "
"method. We store a reference to it in a class member ``import_plugin`` so we "
"can refer to it later when removing it. The :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` method is called when the "
"plugin is deactivated to clean up the memory and let the editor know the "
"import plugin isn't available anymore."
msgstr ""
"Когда этот плагин активируется, он создаст новый экземпляр плагина импорта "
"(который мы скоро сделаем) и добавит его в редактор с помощью "
"метода :ref:`add_import_plugin() "
"<class_EditorPlugin_method_add_import_plugin>`. Мы храним ссылку на него в "
"члене класса ``import_plugin``, чтобы впоследствии ссылаться на него при "
"удалении. Метод :ref:`remove_import_plugin() "
"<class_EditorPlugin_method_remove_import_plugin>` вызывается при деактивации "
"плагина, чтобы очистить память и сообщить редактору, что плагин импорта "
"больше не доступен."

msgid ""
"Note that the import plugin is a reference type, so it doesn't need to be "
"explicitly released from memory with the ``free()`` function. It will be "
"released automatically by the engine when it goes out of scope."
msgstr ""
"Обратите внимание, что плагин импорта относится к ссылочному типу, поэтому "
"его не нужно явно освобождать из памяти с помощью функции ``free()``. Он "
"будет автоматически освобожден движком, когда выйдет из области действия."

msgid "The EditorImportPlugin class"
msgstr "Класс EditorImportPlugin"

msgid ""
"The main character of the show is the :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`. It is responsible for implementing the methods "
"that are called by Godot when it needs to know how to deal with files."
msgstr ""
"Главный герой шоу — :ref:`EditorImportPlugin class "
"<class_EditorImportPlugin>`. Он отвечает за реализацию методов, вызываемых "
"Godot, когда ему требуется информация о том, как работать с файлами."

msgid "Let's begin to code our plugin, one method at time:"
msgstr "Давайте начнем кодировать наш плагин, по одному методу за раз:"

msgid ""
"The first method is "
"the :ref:`_get_importer_name()<class_EditorImportPlugin_private_method__get_importer_name>`. "
"This is a unique name for your plugin that is used by Godot to know which "
"import was used in a certain file. When the files needs to be reimported, "
"the editor will know which plugin to call."
msgstr ""
"Первый метод — "
"это :ref:`_get_importer_name()<class_EditorImportPlugin_private_method__get_importer_name>`. "
"Это уникальное имя вашего плагина, которое Godot использует, чтобы "
"определить, какой импорт был использован в определённом файле. При "
"необходимости повторного импорта файлов редактор будет знать, какой плагин "
"вызывать."

msgid ""
"The :ref:`_get_visible_name()<class_EditorImportPlugin_private_method__get_visible_name>` "
"method is responsible for returning the name of the type it imports and it "
"will be shown to the user in the Import dock."
msgstr ""
"Метод :ref:`_get_visible_name()<class_EditorImportPlugin_private_method__get_visible_name>` "
"отвечает за возврат имени импортируемого им типа, и оно будет показано "
"пользователю в доке импорта."

msgid ""
"You should choose this name as a continuation to \"Import as\", e.g. "
"*\"Import as Silly Material\"*. You can name it whatever you want but we "
"recommend a descriptive name for your plugin."
msgstr ""
"Вам следует выбрать это имя как продолжение \"Import as\", например, "
"*«Импортировать как Silly Material»*. Вы можете назвать его как угодно, но "
"мы рекомендуем использовать описательное имя для вашего плагина."

msgid ""
"Godot's import system detects file types by their extension. In "
"the :ref:`_get_recognized_extensions()<class_EditorImportPlugin_private_method__get_recognized_extensions>` "
"method you return an array of strings to represent each extension that this "
"plugin can understand. If an extension is recognized by more than one "
"plugin, the user can select which one to use when importing the files."
msgstr ""
"Система импорта Godot определяет типы файлов по их расширению. В "
"методе :ref:`_get_recognized_extensions()<class_EditorImportPlugin_private_method__get_recognized_extensions>` "
"возвращается массив строк, представляющих каждое расширение, которое "
"распознаёт этот плагин. Если расширение распознаётся несколькими плагинами, "
"пользователь может выбрать, какой из них использовать при импорте файлов."

msgid ""
"Common extensions like ``.json`` and ``.txt`` might be used by many plugins. "
"Also, there could be files in the project that are just data for the game "
"and should not be imported. You have to be careful when importing to "
"validate the data. Never expect the file to be well-formed."
msgstr ""
"Распространённые расширения, такие как ``.json`` и ``.txt``, могут "
"использоваться многими плагинами. Кроме того, в проекте могут быть файлы, "
"которые содержат только данные для игры и не подлежат импорту. При импорте "
"необходимо соблюдать осторожность и проверять данные. Не рассчитывайте на "
"корректность файла."

msgid ""
"The imported files are saved in the ``.import`` folder at the project's "
"root. Their extension should match the type of resource you are importing, "
"but since Godot can't tell what you'll use (because there might be multiple "
"valid extensions for the same resource), you need to declare what will be "
"used in the import."
msgstr ""
"Импортированные файлы сохраняются в папке ``.import`` в корне проекта. Их "
"расширение должно соответствовать типу импортируемого ресурса, но поскольку "
"Godot не может определить, какой тип файла вы будете использовать (поскольку "
"для одного и того же ресурса может быть несколько допустимых расширений), "
"вам необходимо указать, какой тип файла будет использоваться при импорте."

msgid ""
"Since we're importing a Material, we'll use the special extension for such "
"resource types. If you are importing a scene, you can use ``scn``. Generic "
"resources can use the ``res`` extension. However, this is not enforced in "
"any way by the engine."
msgstr ""
"Поскольку мы импортируем материал, мы будем использовать специальное "
"расширение для таких типов ресурсов. При импорте сцены можно использовать "
"``scn``. Универсальные ресурсы могут использовать расширение ``res``. Однако "
"движок никак не навязывает это."

msgid ""
"The imported resource has a specific type, so the editor can know which "
"property slot it belongs to. This allows drag and drop from the FileSystem "
"dock to a property in the Inspector."
msgstr ""
"Импортированный ресурс имеет определённый тип, поэтому редактор может "
"определить, к какому слоту свойств он принадлежит. Это позволяет "
"перетаскивать его из дока файловой системы в свойство в инспекторе."

msgid ""
"In our case it's a :ref:`class_StandardMaterial3D`, which can be applied to "
"3D objects."
msgstr ""
"В нашем случае это :ref:`class_StandardMaterial3D`, который можно применять "
"к 3D-объектам."

msgid ""
"If you need to import different types from the same extension, you have to "
"create multiple import plugins. You can abstract the import code on another "
"file to avoid duplication in this regard."
msgstr ""
"Если вам нужно импортировать разные типы данных из одного расширения, "
"необходимо создать несколько плагинов импорта. Вы можете абстрагировать код "
"импорта в отдельный файл, чтобы избежать дублирования."

msgid "Options and presets"
msgstr "Опции и предустановки"

msgid ""
"Your plugin can provide different options to allow the user to control how "
"the resource will be imported. If a set of selected options is common, you "
"can also create different presets to make it easier for the user. The "
"following image shows how the options will appear in the editor:"
msgstr ""
"Ваш плагин может предоставлять различные параметры, позволяющие пользователю "
"управлять импортом ресурса. Если набор выбранных параметров является общим, "
"вы также можете создать различные предустановки, чтобы упростить работу "
"пользователя. На следующем изображении показано, как эти параметры будут "
"выглядеть в редакторе:"

msgid ""
"Since there might be many presets and they are identified with a number, "
"it's a good practice to use an enum so you can refer to them using names."
msgstr ""
"Поскольку предустановок может быть много и они идентифицируются по номеру, "
"хорошей практикой является использование перечисления, чтобы можно было "
"ссылаться на них по именам."

msgid ""
"Now that the enum is defined, let's keep looking at the methods of an import "
"plugin:"
msgstr ""
"Теперь, когда перечисление определено, давайте продолжим рассмотрение "
"методов плагина импорта:"

msgid ""
"The :ref:`_get_preset_count() "
"<class_EditorImportPlugin_private_method__get_preset_count>` method returns "
"the amount of presets that this plugins defines. We only have one preset "
"now, but we can make this method future-proof by returning the size of our "
"``Presets`` enumeration."
msgstr ""
"Метод :ref:`_get_preset_count() "
"<class_EditorImportPlugin_private_method__get_preset_count>` возвращает "
"количество предустановок, определяемых этим плагином. Сейчас у нас только "
"одна предустановка, но мы можем сделать этот метод перспективным, возвращая "
"размер перечисления ``Presets``."

msgid ""
"Here we have the :ref:`_get_preset_name() "
"<class_EditorImportPlugin_private_method__get_preset_name>` method, which "
"gives names to the presets as they will be presented to the user, so be sure "
"to use short and clear names."
msgstr ""
"Здесь у нас есть метод :ref:`_get_preset_name() "
"<class_EditorImportPlugin_private_method__get_preset_name>`, который дает "
"имена предустановкам, которые будут представлены пользователю, поэтому "
"обязательно используйте короткие и понятные имена."

msgid ""
"We can use the ``match`` statement here to make the code more structured. "
"This way it's easy to add new presets in the future. We use the catch all "
"pattern to return something too. Although Godot won't ask for presets beyond "
"the preset count you defined, it's always better to be on the safe side."
msgstr ""
"Мы можем использовать оператор ``match`` здесь, чтобы сделать код более "
"структурированным. Это позволит легко добавлять новые предустановки в "
"будущем. Мы также используем шаблон \"catch all\", чтобы что-нибудь вернуть. "
"Хотя Godot не будет запрашивать предустановки сверх указанного вами "
"количества, всегда лучше перестраховаться."

msgid ""
"If you have only one preset you could simply return its name directly, but "
"if you do this you have to be careful when you add more presets."
msgstr ""
"Если у вас только один пресет, вы можете просто напрямую вернуть его имя, но "
"в этом случае вам следует быть осторожным при добавлении дополнительных "
"пресетов."

msgid ""
"This is the method which defines the available "
"options. :ref:`_get_import_options() "
"<class_EditorImportPlugin_private_method__get_import_options>` returns an "
"array of dictionaries, and each dictionary contains a few keys that are "
"checked to customize the option as it's shown to the user. The following "
"table shows the possible keys:"
msgstr ""
"Этот метод определяет доступные параметры. :ref:`_get_import_options() "
"<class_EditorImportPlugin_private_method__get_import_options>` возвращает "
"массив словарей, каждый из которых содержит несколько ключей, проверяемых "
"для настройки параметра, отображаемого пользователю. В следующей таблице "
"представлены возможные ключи:"

msgid "Key"
msgstr "Ключ"

msgid "Type"
msgstr "Тип"

msgid "Description"
msgstr "Описание"

msgid "``name``"
msgstr "``name``"

msgid "String"
msgstr "Строка"

msgid ""
"The name of the option. When showed, underscores become spaces and first "
"letters are capitalized."
msgstr ""
"Название параметра. При отображении подчёркивания заменяются пробелами, а "
"первые буквы становятся заглавными."

msgid "``default_value``"
msgstr "``default_value``"

msgid "Any"
msgstr "Любой"

msgid "The default value of the option for this preset."
msgstr "Значение параметра по умолчанию для данной настройки."

msgid "``property_hint``"
msgstr "``property_hint``"

msgid "Enum value"
msgstr "Значение Перечисления (Enum)"

msgid ""
"One of the :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` values to "
"use as hint."
msgstr ""
"Одно из значений :ref:`PropertyHint <enum_@GlobalScope_PropertyHint>` для "
"использования в качестве подсказки."

msgid "``hint_string``"
msgstr "``hint_string``"

msgid ""
"The hint text of the property. The same as you'd add in the ``export`` "
"statement in GDScript."
msgstr ""
"Текст подсказки свойства. Тот же, что вы бы добавили в оператор ``export`` в "
"GDScript."

msgid "``usage``"
msgstr "``usage``"

msgid ""
"One of the :ref:`PropertyUsageFlags <enum_@GlobalScope_PropertyUsageFlags>` "
"values to define the usage."
msgstr ""
"Одно из значений :ref:`PropertyUsageFlags "
"<enum_@GlobalScope_PropertyUsageFlags>` для определения использования."

msgid ""
"The ``name`` and ``default_value`` keys are **mandatory**, the rest are "
"optional."
msgstr ""
"Ключи ``name`` и ``default_value`` являются **обязательными**, остальные — "
"необязательными."

msgid ""
"Note that the ``_get_import_options`` method receives the preset number, so "
"you can configure the options for each different preset (especially the "
"default value). In this example we use the ``match`` statement, but if you "
"have lots of options and the presets only change the value you may want to "
"create the array of options first and then change it based on the preset."
msgstr ""
"Обратите внимание, что метод ``_get_import_options`` получает номер "
"предустановки, поэтому вы можете настроить параметры для каждой отдельной "
"предустановки (особенно значение по умолчанию). В этом примере мы используем "
"оператор ``match``, но если у вас много параметров, а предустановки изменяют "
"только значение, вы можете сначала создать массив параметров, а затем "
"изменить его на основе предустановки."

msgid ""
"The ``_get_import_options`` method is called even if you don't define "
"presets (by making ``_get_preset_count`` return zero). You have to return an "
"array even it's empty, otherwise you can get errors."
msgstr ""
"Метод ``_get_import_options`` вызывается, даже если вы не определили "
"предустановки (заставив ``_get_preset_count`` возвращать ноль). Вам "
"необходимо возвращать массив, даже если он пустой, иначе возможны ошибки."

msgid ""
"For the :ref:`_get_option_visibility() "
"<class_EditorImportPlugin_private_method__get_option_visibility>` method, we "
"simply return ``true`` because all of our options (i.e. the single one we "
"defined) are visible all the time."
msgstr ""
"Для метода :ref:`_get_option_visibility() "
"<class_EditorImportPlugin_private_method__get_option_visibility>` мы просто "
"возвращаем ``true``, потому что все наши параметры (т. е. единственный, "
"который мы определили) видны все время."

msgid ""
"If you need to make certain option visible only if another is set with a "
"certain value, you can add the logic in this method."
msgstr ""
"Если вам нужно сделать определенную опцию видимой только в том случае, если "
"для другой опции установлено определенное значение, вы можете добавить "
"логику в этот метод."

msgid "The ``import`` method"
msgstr "Метод ``import``"

msgid ""
"The heavy part of the process, responsible for converting the files into "
"resources, is covered by the :ref:`_import() "
"<class_EditorImportPlugin_private_method__import>` method. Our sample code "
"is a bit long, so let's split in a few parts:"
msgstr ""
"Самая тяжёлая часть процесса, отвечающая за преобразование файлов в ресурсы, "
"выполняется методом :ref:`_import() "
"<class_EditorImportPlugin_private_method__import>`. Наш пример кода довольно "
"длинный, поэтому давайте разделим его на несколько частей:"

msgid ""
"The first part of our import method opens and reads the source file. We use "
"the :ref:`FileAccess <class_FileAccess>` class to do that, passing the "
"``source_file`` parameter which is provided by the editor."
msgstr ""
"Первая часть нашего метода импорта открывает и считывает исходный файл. Для "
"этого мы используем класс :ref:`FileAccess <class_FileAccess>`, передавая "
"параметр ``source_file``, предоставляемый редактором."

msgid ""
"If there's an error when opening the file, we return it to let the editor "
"know that the import wasn't successful."
msgstr ""
"Если при открытии файла возникла ошибка, мы возвращаем ее, чтобы сообщить "
"редактору, что импорт не был успешным."

msgid ""
"This code takes the line of the file it read before and splits it in pieces "
"that are separated by a comma. If there are more or less than the three "
"values, it considers the file invalid and reports an error."
msgstr ""
"Этот код берёт строку файла, которую он читал ранее, и разбивает её на "
"части, разделённые запятой. Если количество значений больше или меньше трёх, "
"файл считается недействительным и выдаёт ошибку."

msgid ""
"Then it creates a new :ref:`Color <class_Color>` variable and sets its "
"values according to the input file. If the ``use_red_anyway`` option is "
"enabled, then it sets the color as a pure red instead."
msgstr ""
"Затем он создаёт новую переменную :ref:`Color <class_Color>` и устанавливает "
"её значения в соответствии с входным файлом. Если включена опция "
"``use_red_anyway``, то цвет устанавливается как чисто красный."

msgid ""
"This part makes a new :ref:`StandardMaterial3D <class_StandardMaterial3D>` "
"that is the imported resource. We create a new instance of it and then set "
"its albedo color as the value we got before."
msgstr ""
"Эта часть создаёт новый :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>`, представляющий собой импортированный ресурс. Мы "
"создаём его новый экземпляр и устанавливаем его цвет альбедо равным "
"значению, полученному ранее."

msgid ""
"This is the last part and quite an important one, because here we save the "
"made resource to the disk. The path of the saved file is generated and "
"informed by the editor via the ``save_path`` parameter. Note that this comes "
"**without** the extension, so we add it using :ref:`string formatting "
"<doc_gdscript_printf>`. For this we call the ``_get_save_extension`` method "
"that we defined earlier, so we can be sure that they won't get out of sync."
msgstr ""
"Это последняя и весьма важная часть, поскольку здесь мы сохраняем созданный "
"ресурс на диск. Путь к сохранённому файлу генерируется и указывается "
"редактором через параметр ``save_path``. Обратите внимание, что он идёт "
"**без** расширения, поэтому мы добавляем его с помощью :ref:`string "
"formatting <doc_gdscript_printf>`. Для этого мы вызываем метод "
"``_get_save_extension``, который мы определили ранее, чтобы гарантировать "
"отсутствие рассинхронизации."

msgid ""
"We also return the result from the :ref:`ResourceSaver.save() "
"<class_ResourceSaver_method_save>` method, so if there's an error in this "
"step, the editor will know about it."
msgstr ""
"Мы также возвращаем результат из метода :ref:`ResourceSaver.save() "
"<class_ResourceSaver_method_save>`, поэтому, если на этом этапе возникнет "
"ошибка, редактор узнает об этом."

msgid "Platform variants and generated files"
msgstr "Варианты платформы и сгенерированные файлы"

msgid ""
"You may have noticed that our plugin ignored two arguments of the ``import`` "
"method. Those are *return arguments* (hence the ``r`` at the beginning of "
"their name), which means that the editor will read from them after calling "
"your import method. Both of them are arrays that you can fill with "
"information."
msgstr ""
"Вы могли заметить, что наш плагин проигнорировал два аргумента метода "
"``import``. Это *возвращаемые аргументы* (отсюда и ``r`` в начале их "
"названия), что означает, что редактор будет читать их после вызова вашего "
"метода импорта. Оба аргумента представляют собой массивы, которые можно "
"заполнить информацией."

msgid ""
"The ``r_platform_variants`` argument is used if you need to import the "
"resource differently depending on the target platform. While it's called "
"*platform* variants, it is based on the presence of :ref:`feature tags "
"<doc_feature_tags>`, so even the same platform can have multiple variants "
"depending on the setup."
msgstr ""
"Аргумент ``r_platform_variants`` используется, если вам нужно импортировать "
"ресурс по-разному в зависимости от целевой платформы. Хотя это называется "
"*platform* вариантами, он основан на наличии :ref:`feature tags "
"<doc_feature_tags>`, поэтому даже для одной платформы может быть несколько "
"вариантов в зависимости от настроек."

msgid ""
"To import a platform variant, you need to save it with the feature tag "
"before the extension, and then push the tag to the ``r_platform_variants`` "
"array so the editor can know that you did."
msgstr ""
"Чтобы импортировать вариант платформы, вам необходимо сохранить его с тегом "
"функции перед расширением, а затем поместить тег в массив "
"``r_platform_variants``, чтобы редактор мог это узнать."

msgid ""
"For example, let's say we save a different material for a mobile platform. "
"We would need to do something like the following:"
msgstr ""
"Например, если мы сохраняем другой материал для мобильной платформы, нам "
"нужно сделать что-то вроде следующего:"

msgid ""
"The ``r_gen_files`` argument is meant for extra files that are generated "
"during your import process and need to be kept. The editor will look at it "
"to understand the dependencies and make sure the extra file is not "
"inadvertently deleted."
msgstr ""
"Аргумент ``r_gen_files`` предназначен для дополнительных файлов, создаваемых "
"в процессе импорта и требующих сохранения. Редактор проверит его, чтобы "
"определить зависимости и убедиться, что дополнительный файл не будет "
"случайно удалён."

msgid ""
"This is also an array and should be filled with full paths of the files you "
"save. As an example, let's create another material for the next pass and "
"save it in a different file:"
msgstr ""
"Это тоже массив, который следует заполнить полными путями к сохраняемым "
"файлам. В качестве примера давайте создадим ещё один материал для следующего "
"прохода и сохраним его в другом файле:"

msgid "Trying the plugin"
msgstr "Пробуем плагин"

msgid ""
"This has been theoretical, but now that the import plugin is done, let's "
"test it. Make sure you created the sample file (with the contents described "
"in the introduction section) and save it as ``test.mtxt``. Then activate the "
"plugin in the Project Settings."
msgstr ""
"Это было теоретическим предположением, но теперь, когда плагин импорта "
"готов, давайте его протестируем. Убедитесь, что вы создали файл-пример (с "
"содержимым, описанным во введении), и сохраните его как ``test.mtxt``. Затем "
"активируйте плагин в настройках проекта."

msgid ""
"If everything goes well, the import plugin is added to the editor and the "
"file system is scanned, making the custom resource appear on the FileSystem "
"dock. If you select it and focus the Import dock, you can see the only "
"option to select there."
msgstr ""
"Если всё пройдёт успешно, плагин импорта будет добавлен в редактор, а "
"файловая система будет просканирована, после чего пользовательский ресурс "
"появится в доке FileSystem. Если выбрать его и сделать фокус на доке Import, "
"вы увидите там единственный пункт для выбора."

msgid ""
"Create a MeshInstance3D node in the scene, and for its Mesh property set up "
"a new SphereMesh. Unfold the Material section in the Inspector and then drag "
"the file from the FileSystem dock to the material property. The object will "
"update in the viewport with the blue color of the imported material."
msgstr ""
"Создайте в сцене узел MeshInstance3D и для его свойства Mesh настройте новый "
"SphereMesh. Разверните раздел Material в Inspector и перетащите файл из дока "
"FileSystem в свойство материала. Объект обновится в области просмотра, "
"приняв синий цвет импортированного материала."

msgid ""
"Go to Import dock, enable the \"Use Red Anyway\" option, and click on "
"\"Reimport\". This will update the imported material and should "
"automatically update the view showing the red color instead."
msgstr ""
"Перейдите в раздел Import, включите опцию \"Use Red Anyway\" и нажмите "
"\"Reimport\". Это обновит импортированный материал и автоматически обновит "
"представление, отображающее красный цвет."

msgid ""
"And that's it! Your first import plugin is done! Now get creative and make "
"plugins for your own beloved formats. This can be quite useful to write your "
"data in a custom format and then use it in Godot as if they were native "
"resources. This shows how the import system is powerful and extendable."
msgstr ""
"Вот и всё! Ваш первый плагин импорта готов! Теперь проявите креативность и "
"создайте плагины для ваших любимых форматов. Это может быть очень полезно "
"для записи данных в пользовательском формате и последующего использования их "
"в Godot как нативных ресурсов. Это демонстрирует, насколько мощна и "
"расширяема система импорта."
