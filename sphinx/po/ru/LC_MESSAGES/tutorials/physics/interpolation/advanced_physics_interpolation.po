#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced physics interpolation"
msgstr "Расширенная физическая интерполяция"

msgid ""
"Although the previous instructions will give satisfactory results in a lot "
"of games, in some cases you will want to go a stage further to get the best "
"possible results and the smoothest possible experience."
msgstr ""
"Хотя предыдущие инструкции дадут удовлетворительные результаты во многих "
"играх, в некоторых случаях вам захочется пойти немного дальше, чтобы "
"получить наилучшие результаты и максимально плавный игровой процесс."

msgid "Exceptions to automatic physics interpolation"
msgstr "Исключения из автоматической интерполяции физики"

msgid ""
"Even with physics interpolation active, there may be some local situations "
"where you would benefit from disabling automatic interpolation for "
"a :ref:`Node<class_Node>` (or branch of "
"the :ref:`SceneTree<class_SceneTree>`), and have the finer control of "
"performing interpolation manually."
msgstr ""
"Даже при активной интерполяции физики могут возникнуть некоторые локальные "
"ситуации, в которых вам будет полезно отключить автоматическую интерполяцию "
"для :ref:`Node<class_Node>` (или ветви :ref:`SceneTree<class_SceneTree>`), "
"чтобы иметь более точный контроль над выполнением интерполяции вручную."

msgid ""
"This is possible using "
"the :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"property which is present in all Nodes. If you for example, turn off "
"interpolation for a Node, the children will recursively also be affected (as "
"they default to inheriting the parent setting). This means you can easily "
"disable interpolation for an entire subscene."
msgstr ""
"Это возможно благодаря "
"свойству :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`, "
"которое присутствует во всех узлах. Например, если вы отключите интерполяцию "
"для узла, дочерние узлы также будут рекурсивно затронуты (поскольку они по "
"умолчанию наследуют родительские настройки). Это означает, что вы можете "
"легко отключить интерполяцию для всей подсцены."

msgid ""
"The most common situation where you may want to perform your own "
"interpolation is Cameras."
msgstr ""
"Наиболее распространенная ситуация, когда вам может понадобиться выполнить "
"собственную интерполяцию, — это Камеры."

msgid "Cameras"
msgstr "Камеры"

msgid ""
"In many cases, a :ref:`Camera3D<class_Camera3D>` can use automatic "
"interpolation just like any other node. However, for best results, "
"especially at low physics tick rates, it is recommended that you take a "
"manual approach to camera interpolation."
msgstr ""
"Во многих случаях узел :ref:`Camera3D<class_Camera3D>` может использовать "
"автоматическую интерполяцию, как и любой другой узел. Однако для достижения "
"наилучших результатов, особенно при низкой частоте физических тиков, "
"рекомендуется использовать ручную интерполяцию камеры."

msgid ""
"This is because viewers are very sensitive to camera movement. For instance, "
"a Camera3D that realigns slightly every 1/10th of a second (at 10tps tick "
"rate) will often be noticeable. You can get a much smoother result by moving "
"the camera each frame in ``_process``, and following an interpolated target "
"manually."
msgstr ""
"Это связано с тем, что зрители очень чувствительны к движению камеры. "
"Например, Camera3D, которая слегка перестраивается каждую десятую секунды (с "
"частотой тиков 10 транзакций в секунду), часто будет заметна. Вы можете "
"добиться гораздо более плавного результата, перемещая камеру в каждом кадре "
"в ``_process`` и вручную следуя за интерполированной целью."

msgid "Manual camera interpolation"
msgstr "Ручная интерполяция камеры"

msgid "Ensure the camera is using global coordinate space"
msgstr "Убедитесь, что камера использует глобальное координатное пространство"

msgid ""
"The very first step when performing manual camera interpolation is to make "
"sure the Camera3D transform is specified in *global space* rather than "
"inheriting the transform of a moving parent. This is because feedback can "
"occur between the movement of a parent node of a Camera3D and the movement "
"of the camera Node itself, which can mess up the interpolation."
msgstr ""
"Самый первый шаг при ручной интерполяции камеры — убедиться, что "
"преобразование Camera3D задано в *глобальном пространстве*, а не наследует "
"преобразование движущегося родительского узла. Это связано с тем, что между "
"движением родительского узла Camera3D и движением самого узла камеры может "
"возникнуть обратная связь, что может привести к сбоям в интерполяции."

msgid "There are two ways of doing this:"
msgstr "Есть два способа сделать это:"

msgid ""
"Move the Camera3D so it is independent on its own branch, rather than being "
"a child of a moving object."
msgstr ""
"Переместите Camera3D так, чтобы она стала независима на своей собственной "
"ветке, а не дочерним элементом движущегося объекта."

msgid ""
"Call :ref:`Node3D.top_level<class_Node3D_property_top_level>` and set this "
"to ``true``, which will make the Camera ignore the transform of its parent."
msgstr ""
"Вызовите :ref:`Node3D.top_level<class_Node3D_property_top_level>` и "
"установите для него значение ``true``, что заставит камеру игнорировать "
"преобразование своего родителя."

msgid "Typical example"
msgstr "Типичный пример"

msgid ""
"A typical example of a custom approach is to use the ``look_at`` function in "
"the Camera3D every frame in ``_process()`` to look at a target node (such as "
"the player)."
msgstr ""
"Типичным примером пользовательского подхода является использование функции "
"``look_at`` в Camera3D в каждом кадре в ``_process()`` для просмотра "
"целевого узла (например, игрока)."

msgid ""
"But there is a problem. If we use the traditional ``get_global_transform()`` "
"on a Camera3D \"target\" node, this transform will only focus the Camera3D "
"on the target *at the current physics tick*. This is *not* what we want, as "
"the camera will jump about on each physics tick as the target moves. Even "
"though the camera may be updated each frame, this does not help give smooth "
"motion if the *target* is only changing each physics tick."
msgstr ""
"Но есть проблема. Если мы используем традиционный метод "
"``get_global_transform()`` для узла \"target\" Camera3D, это преобразование "
"сфокусирует Camera3D только на цели *на текущем такте физики*. Это *не* то, "
"что нам нужно, поскольку камера будет перемещаться с каждым тактом физики по "
"мере движения цели. Даже если камера обновляется в каждом кадре, это не "
"обеспечит плавного движения, если *цель* меняется только на каждом такте "
"физики."

msgid "get_global_transform_interpolated()"
msgstr "get_global_transform_interpolated()"

msgid ""
"What we really want to focus the camera on, is not the position of the "
"target on the physics tick, but the *interpolated* position, i.e. the "
"position at which the target will be rendered."
msgstr ""
"На самом деле мы хотим сфокусировать камеру не на положении цели на "
"физическом такте, а на *интерполированном* положении, т. е. положении, в "
"котором цель будет отображаться."

msgid ""
"We can do this using "
"the :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"function. This acts exactly like "
"getting :ref:`Node3D.global_transform<class_Node3D_property_global_transform>` "
"but it gives you the *interpolated* transform (during a ``_process()`` call)."
msgstr ""
"Это можно сделать с помощью "
"функции :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`. "
"Это работает точно так же, как и "
"получение :ref:`Node3D.global_transform<class_Node3D_property_global_transform>`, "
"но возвращает *интерполированное* преобразование (во время вызова "
"``_process()``)."

msgid ""
"``get_global_transform_interpolated()`` should only be used once or twice "
"for special cases such as cameras. It should **not** be used all over the "
"place in your code (both for performance reasons, and to give correct "
"gameplay)."
msgstr ""
"``get_global_transform_interpolated()`` следует использовать только один или "
"два раза для особых случаев, таких как камеры. **Не** следует использовать "
"его повсеместно в коде (как из соображений производительности, так и для "
"обеспечения корректного игрового процесса)."

msgid ""
"Aside from exceptions like the camera, in most cases, your game logic should "
"be in ``_physics_process()``. In game logic you should be calling "
"``get_global_transform()`` or ``get_transform()``, which will give the "
"current physics transform (in global or local space respectively), which is "
"usually what you will want for gameplay code."
msgstr ""
"За исключением таких исключений, как камера, в большинстве случаев ваша "
"игровая логика должна быть реализована в ``_physics_process()``. В игровой "
"логике следует вызывать ``get_global_transform()`` или ``get_transform()``, "
"которые вернут текущее физическое преобразование (в глобальном или локальном "
"пространстве соответственно), что обычно требуется для игрового кода."

msgid "Example manual camera script"
msgstr "Пример ручного скрипта камеры"

msgid ""
"Here is an example of a simple fixed camera which follows an interpolated "
"target:"
msgstr ""
"Вот пример простой фиксированной камеры, которая следует за "
"интерполированной целью:"

msgid "Mouse look"
msgstr "Движение мыши"

msgid ""
"Mouse look is a very common way of controlling cameras. But there is a "
"problem. Unlike keyboard input which can be sampled periodically on the "
"physics tick, mouse move events can come in continuously. The camera will be "
"expected to react and follow these mouse movements on the next frame, rather "
"than waiting until the next physics tick."
msgstr ""
"Управление камерой с помощью мыши — очень распространённый способ. Но есть "
"проблема. В отличие от ввода с клавиатуры, который может считываться "
"периодически в каждом такте физики, события движения мыши могут поступать "
"непрерывно. Ожидается, что камера отреагирует и будет следовать за этими "
"движениями мыши в следующем кадре, а не будет ждать следующего такта физики."

msgid ""
"In this situation, it can be better to disable physics interpolation for the "
"camera node "
"(using :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"and directly apply the mouse input to the camera rotation, rather than apply "
"it in ``_physics_process``."
msgstr ""
"В этой ситуации может быть лучше отключить физическую интерполяцию для узла "
"камеры "
"(используя :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"и напрямую применить ввод мыши к вращению камеры, а не применять его в "
"``_physics_process``."

msgid ""
"Sometimes, especially with cameras, you will want to use a combination of "
"interpolation and non-interpolation:"
msgstr ""
"Иногда, особенно при работе с камерами, вам может потребоваться комбинация "
"интерполяции и отсутствия интерполяции:"

msgid ""
"A first person camera may position the camera at a player location (perhaps "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"but control the Camera rotation from mouse look *without* interpolation."
msgstr ""
"Камера от первого лица может располагаться в месте расположения игрока "
"(возможно, с "
"использованием :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"но управлять вращением камеры можно с помощью мыши *без* интерполяции."

msgid ""
"A third person camera may similarly determine the look at (target location) "
"of the camera "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"but position the camera using mouse look *without* interpolation."
msgstr ""
"Камера от третьего лица может аналогичным образом определить направление "
"взгляда (целевое местоположение) камеры, "
"используя :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"но расположить камеру можно, используя вид мыши *без* интерполяции."

msgid ""
"There are many permutations and variations of camera types, but it should be "
"clear that in many cases, disabling automatic physics interpolation and "
"handling this yourself can give a better result."
msgstr ""
"Существует множество вариаций и разновидностей типов камер, но должно быть "
"ясно, что во многих случаях отключение автоматической интерполяции физики и "
"выполнение этой задачи самостоятельно может дать лучший результат."

msgid "Disabling interpolation on other nodes"
msgstr "Отключение интерполяции на других узлах"

msgid ""
"Although cameras are the most common example, there are a number of cases "
"when you may wish other nodes to control their own interpolation, or be non-"
"interpolated. Consider for example, a player in a top view game whose "
"rotation is controlled by mouse look. Disabling physics rotation allows the "
"player rotation to match the mouse in real-time."
msgstr ""
"Хотя камеры — наиболее распространённый пример, существует ряд случаев, "
"когда может потребоваться, чтобы другие узлы самостоятельно управляли "
"интерполяцией или не использовали её вовсе. Рассмотрим, например, игрока в "
"игре с видом сверху, вращение которого управляется движением мыши. "
"Отключение вращения с учётом физических факторов позволяет игроку в реальном "
"времени синхронизировать вращение с движением мыши."

msgid "MultiMeshes"
msgstr "MultiMeshes (МультиСетки)"

msgid ""
"Although most visual Nodes follow the single Node single visual instance "
"paradigm, MultiMeshes can control several instances from the same Node. "
"Therefore, they have some extra functions for controlling interpolation "
"functionality on a *per-instance* basis. You should explore these functions "
"if you are using interpolated MultiMeshes."
msgstr ""
"Хотя большинство визуальных узлов следуют парадигме одного визуального "
"экземпляра узла, мультисетки могут управлять несколькими экземплярами одного "
"узла. Поэтому у них есть дополнительные функции для управления интерполяцией "
"на уровне *каждого экземпляра*. Если вы используете интерполированные "
"мультисетки, вам стоит изучить эти функции."

msgid ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"
msgstr ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"

msgid ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"
msgstr ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"

msgid ""
"Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation."
msgstr ""
"Полную информацию можно найти в "
"документации :ref:`MultiMesh<class_MultiMesh>`."
