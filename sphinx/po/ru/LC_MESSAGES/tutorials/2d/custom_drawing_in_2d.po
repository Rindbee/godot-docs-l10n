#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "Пользовательская отрисовка в 2D"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, text, and many other "
"common game development needs. However, if you need something specific not "
"covered with the standard nodes you can make any 2D node (for "
"example, :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`-"
"based) draw on screen using custom commands."
msgstr ""
"В Godot есть узлы для рисования спрайтов, полигонов, частиц, текста и многих "
"других распространенных задач разработки игр. Однако, если вам нужно что-то "
"конкретное и не представленное стандартными узлами, вы можете создать любой "
"2D-узел (например, на основе :ref:`Control <class_Control>` или :ref:`Node2D "
"<class_Node2D>`), отображаемый на экране с помощью пользовательских команд."

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"Пользовательский рисунок в 2D узле *действительно* полезен.Вот несколько "
"примеров, почему:"

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"Рисование фигур или логики, которые не обрабатываются узлами (пример: "
"создание узла, который рисует круг, изображение со следами, особый вид "
"анимированного многоугольника и т. д.)."

msgid ""
"Drawing a large number of simple objects, such as a grid or a board for a 2d "
"game. Custom drawing avoids the overhead of using a large number of nodes, "
"possibly lowering memory usage and improving performance."
msgstr ""
"Рисовать множество простых объектов, таких как сетка или поле для 2d-игры. "
"Пользовательское рисование позволяет избежать накладных расходов, связанных "
"с использованием большого количества узлов, что может снизить потребление "
"памяти и поднять производительность."

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"Создание пользовательского элемента управления пользовательского интерфейса "
"(UI). Существует множество доступных элементов управления, но когда у вас "
"есть нестандартные требования, вероятно, вам потребуется создать собственный "
"элемент управления."

msgid "Drawing"
msgstr "Отрисовка"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, "
"like :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then "
"override the :ref:`_draw()<class_CanvasItem_private_method__draw>` function."
msgstr ""
"Добавьте скрипт к любому производному узлу :ref:`CanvasItem "
"<class_CanvasItem>`, например :ref:`Control <class_Control>` "
"или :ref:`Node2D <class_Node2D>`. Затем переопределите "
"функцию :ref:`_draw()<class_CanvasItem_private_method__draw>`."

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them and we will see some of them in "
"the examples below."
msgstr ""
"Команды рисования описаны в :ref:`CanvasItem <class_CanvasItem>`. Их "
"прилично много, и мы посмотрим на них в примерах ниже."

msgid "Updating"
msgstr "Обновление"

msgid ""
"The :ref:`_draw <class_CanvasItem_private_method__draw>` function is only "
"called once, and then the draw commands are cached and remembered, so "
"further calls are unnecessary."
msgstr ""
"Функция :ref:`_draw <class_CanvasItem_private_method__draw>` вызывается "
"только единожды, затем команды рисования кэшируются и запоминаются, поэтому "
"в дальнейших вызовах нет необходимости."

msgid ""
"If re-drawing is required because a variable or something else changed, "
"call :ref:`CanvasItem.queue_redraw <class_CanvasItem_method_queue_redraw>` "
"in that same node and a new ``_draw()`` call will happen."
msgstr ""
"Если потребуется отрисовать все заново из-за изменения переменной или чего-"
"то еще, вызовите :ref:`CanvasItem.queue_redraw "
"<class_CanvasItem_method_queue_redraw>` в том же узле, и произойдет новый "
"вызов ``_draw()``."

msgid ""
"Here is a little more complex example, where we have a texture variable that "
"can be modified at any time, and using "
"a :ref:`setter<doc_gdscript_basics_setters_getters>`, it forces a redraw of "
"the texture when modified:"
msgstr ""
"Вот немного более сложный пример, где у нас есть переменная текстуры, "
"которую можно изменить в любое время, и "
"использование :ref:`setter<doc_gdscript_basics_setters_getters>`, которое "
"принудительно перерисовывает текстуру при изменении:"

msgid ""
"To see it in action, you can set the texture to be the Godot icon on the "
"editor by dragging and dropping the default ``icon.svg`` from the "
"``FileSystem`` tab to the Texture property on the ``Inspector`` tab. When "
"changing the ``Texture`` property value while the previous script is "
"running, the texture will also change automatically."
msgstr ""
"Чтобы увидеть это в действии, вы можете установить текстуру в качестве "
"значка Godot в редакторе, перетащив и отпустив ``icon.svg`` по умолчанию из "
"вкладки ``FileSystem`` в свойство Texture на вкладке ``Inspector``. При "
"изменении значения свойства ``Texture`` во время выполнения предыдущего "
"скрипта текстура также автоматически изменится."

msgid ""
"In some cases, we may need to redraw every frame. For this, "
"call :ref:`queue_redraw <class_CanvasItem_method_queue_redraw>` from "
"the :ref:`_process <class_Node_private_method__process>` method, like this:"
msgstr ""
"В некоторых случаях нам может потребоваться заново перерисовать каждый кадр. "
"Для этого вызовите :ref:`queue_redraw "
"<class_CanvasItem_method_queue_redraw>` из метода :ref:`_process "
"<class_Node_private_method__process>`, следующим образом:"

msgid "Coordinates and line width alignment"
msgstr "Выравнивание координат и ширины линии"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. This means ``_draw()`` uses the coordinate space created "
"after applying the CanvasItem's transform. Additionally, you can apply a "
"custom transform on top of it by "
"using :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"or :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"API рисования использует систему координат CanvasItem, а не обязательно "
"пиксельные координаты. Это означает, что ``_draw()`` использует координатное "
"пространство, созданное после применения преобразования CanvasItem. Кроме "
"того, вы можете применить пользовательское преобразование поверх него, "
"используя :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"или :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."

msgid ""
"When using :ref:`draw_line <class_CanvasItem_method_draw_line>`, you should "
"consider the width of the line. When using a width that is an odd size, the "
"position of the start and end points should be shifted by ``0.5`` to keep "
"the line centered, as shown below."
msgstr ""
"При использовании :ref:`draw_line <class_CanvasItem_method_draw_line>` "
"следует учитывать ширину линии. При использовании ширины нечетного размера "
"положение начальной и конечной точек следует сместить на ``0.5``, чтобы "
"линия оставалась центрированной, как показано ниже."

msgid ""
"The same applies to the :ref:`draw_rect <class_CanvasItem_method_draw_rect>` "
"method with ``filled = false``."
msgstr ""
"То же самое относится к методу :ref:`draw_rect "
"<class_CanvasItem_method_draw_rect>` с ``filled = false``."

msgid "Antialiased drawing"
msgstr "**Сглаживание**"

msgid ""
"Godot offers method parameters "
"in :ref:`draw_line<class_CanvasItem_method_draw_line>` to enable "
"antialiasing, but not all custom drawing methods offer this ``antialiased`` "
"parameter."
msgstr ""
"Godot предлагает параметры метода "
"в :ref:`draw_line<class_CanvasItem_method_draw_line>`, чтобы включить "
"сглаживание, но не все пользовательские методы рисования поддерживают "
"``antialiased`` параметр."

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"Для пользовательских методов рисования, которые не предоставляют параметр "
"``antialiased``, вы можете вместо этого включить 2D MSAA, который влияет на "
"рендеринг во всем окне просмотра. Это обеспечивает высококачественное "
"сглаживание, но более высокую стоимость производительности и только для "
"определенных элементов. См. :ref:`doc_2d_antialiasing` для получения "
"дополнительной информации."

msgid ""
"Here is a comparison of a line of minimal width (``width=-1``) drawn with "
"``antialiased=false``, ``antialiased=true``, and ``antialiased=false`` with "
"2D MSAA 2x, 4x, and 8x enabled."
msgstr ""
"Ниже приведено сравнение линии минимальной ширины (``width=-1``), "
"нарисованной с ``antialiased=false``, ``antialiased=true`` и "
"``antialiased=false`` при включенном 2D MSAA 2x, 4x и 8x."

msgid "Tools"
msgstr "Инструменты"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior."
msgstr ""
"Также может потребоваться нарисовать собственные узлы при их запуске в "
"редакторе. Это можно использовать для предпросмотра или визуализации какой-"
"либо функции или поведения."

msgid ""
"To do this, you can use the :ref:`tool annotation<doc_gdscript_tool_mode>` "
"on both GDScript and C#. See :ref:`the example "
"below<doc_draw_show_drawing_while_editing_example>` "
"and :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"Для этого можно использовать :ref:`аннотацию "
"инструмента<doc_gdscript_tool_mode>` как в GDScript, так и в C#. Для "
"получения дополнительной информации см. :ref:`пример "
"ниже<doc_draw_show_drawing_while_editing_example>` "
"и :ref:`doc_running_code_in_the_editor`."

msgid "Example 1: drawing a custom shape"
msgstr "Вот простой пример того, как это работает"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. We will recreate the "
"Godot logo but with code- only using drawing functions."
msgstr ""
"Теперь мы используем пользовательские функции рисования движка Godot, чтобы "
"нарисовать то, для чего в Godot нет встроенных функций. Мы воссоздадим "
"логотип Godot, но только кодом и функциями рисования."

msgid "You will have to code a function to perform this and draw it yourself."
msgstr ""
"Вам придется закодировать функцию для ее выполнения и нарисовать ее "
"самостоятельно."

msgid ""
"The following instructions use a fixed set of coordinates that could be too "
"small for high resolution screens (larger than 1080p). If that is your case, "
"and the drawing is too small consider increasing your window scale in the "
"project setting :ref:`Display > Window > Stretch > "
"Scale<class_ProjectSettings_property_display/window/stretch/scale>` to "
"adjust the project to a higher resolution (a 2 or 4 scale tends to work "
"well)."
msgstr ""
"В следующих инструкциях используется фиксированный набор координат, который "
"может быть слишком мал для экранов с высоким разрешением (больше 1080p). "
"Если это ваш случай, и рисунок слишком мал, рассмотрите возможность "
"увеличения масштаба окна в настройках проекта :ref:`Display > Window > "
"Stretch > Scale<class_ProjectSettings_property_display/window/stretch/"
"scale>`, чтобы настроить проект на более высокое разрешение (масштаб 2 или 4 "
"обычно работает хорошо)."

msgid "Drawing a custom polygon shape"
msgstr "Рисование пользовательского polygon shape (формы полигона)"

msgid ""
"While there is a dedicated node to draw custom polygons ( :ref:`Polygon2D "
"<class_Polygon2D>`), we will use in this case exclusively lower level "
"drawing functions to combine them on the same node and be able to create "
"more complex shapes later on."
msgstr ""
"Хотя для рисования пользовательских полигонов существует специальный узел "
"( :ref:`Polygon2D <class_Polygon2D>`), в данном случае мы будем использовать "
"исключительно функции рисования более низкого уровня, чтобы объединить их в "
"одном узле и иметь возможность создавать более сложные фигуры в дальнейшем."

msgid ""
"First, we will define a set of points -or X and Y coordinates- that will "
"form the base of our shape:"
msgstr ""
"Сначала мы определим набор точек (или координат X и Y), которые лягут в "
"основу нашей фигуры:"

msgid ""
"This format, while compact, is not the one that Godot understands to draw a "
"polygon. In a different scenario we could have to load these coordinates "
"from a file or calculate the positions while the application is running, so "
"some transformation may be needed."
msgstr ""
"Этот формат, хотя и компактный, не является тем, который Godot понимает для "
"рисования многоугольника. В другом сценарии нам пришлось бы загружать эти "
"координаты из файла или вычислять позиции во время работы приложения, "
"поэтому может потребоваться некоторое преобразование."

msgid ""
"To transform these coordinates into the right format, we will create a new "
"method ``float_array_to_Vector2Array()``. Then we will override the "
"``_ready()`` function, which Godot will call only once -at the start of the "
"execution- to load those coordinates into a variable:"
msgstr ""
"Чтобы преобразовать эти координаты в правильный формат, мы создадим новый "
"метод ``float_array_to_Vector2Array()``. Затем мы переопределим функцию "
"``_ready()``, которую Godot вызовет только один раз - в начале выполнения - "
"для загрузки этих координат в переменную:"

msgid ""
"To finally draw our first shape, we will use the method :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>` and pass the points (as an array of "
"Vector2 coordinates) and its color, like this:"
msgstr ""
"Чтобы наконец нарисовать нашу первую фигуру, мы воспользуемся "
"методом :ref:`draw_polygon <class_CanvasItem_method_draw_polygon>` и "
"передадим точки (как массив координат Vector2) и ее цвет, вот так:"

msgid "When running it you should see something like this:"
msgstr "Запустив, вы увидите что-то вроде этого:"

msgid ""
"Note the lower part of the logo looks segmented- this is because a low "
"amount of points were used to define that part. To simulate a smooth curve, "
"we could add more points to our array, or maybe use a mathematical function "
"to interpolate a curve and create a smooth shape from code "
"(see :ref:`example 2<doc_draw_custom_example_2>`)."
msgstr ""
"Обратите внимание, что нижняя часть логотипа выглядит сегментированной — это "
"потому, что для определения этой части было использовано малое количество "
"точек. Чтобы смоделировать плавную кривую, мы могли бы добавить больше точек "
"в наш массив или, может быть, использовать математическую функцию для "
"интерполяции кривой и создания плавной формы из кода (см. :ref:`example "
"2<doc_draw_custom_example_2>`)."

msgid ""
"Polygons will always **connect its last defined point to its first one** in "
"order to have a closed shape."
msgstr ""
"Многоугольники всегда **соединяют свою последнюю определенную точку с "
"первой**, чтобы иметь замкнутую форму."

msgid "Drawing connected lines"
msgstr "Отрисовка соединенных линий"

msgid ""
"Drawing a sequence of connected lines that don't close down to form a "
"polygon is very similar to the previous method. We will use a connected set "
"of lines to draw Godot's logo mouth."
msgstr ""
"Рисование последовательности соединенных линий, которые не замыкаются, чтобы "
"сформировать многоугольник, очень похоже на предыдущий метод. Мы будем "
"использовать соединенный набор линий, чтобы нарисовать рот логотипа Godot."

msgid ""
"First, we will define the list of coordinates that form the mouth shape, "
"like this:"
msgstr ""
"Сначала мы определим список координат, формирующих форму рта, например:"

msgid ""
"We will load these coordinates into a variable and define an additional "
"variable with the configurable line thickness:"
msgstr ""
"Мы загрузим эти координаты в переменную и определим дополнительную "
"переменную с настраиваемой толщиной линии:"

msgid ""
"And finally we will use the method :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>` to actually draw the line, like "
"this:"
msgstr ""
"И наконец, мы воспользуемся методом :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>`, чтобы нарисовать линию, вот так:"

msgid "You should get the following output:"
msgstr "Вы должны получить следующий вывод:"

msgid ""
"Unlike ``draw_polygon()``, polylines can only have a single unique color for "
"all its points (the second argument). This method has 2 additional "
"arguments: the width of the line (which is as small as possible by default) "
"and enabling or disabling the antialiasing (it is disabled by default)."
msgstr ""
"В отличие от ``draw_polygon()``, полилинии могут иметь только один "
"уникальный цвет для всех своих точек (второй аргумент). Этот метод имеет 2 "
"дополнительных аргумента: ширину линии (которая по умолчанию минимально "
"возможная) и включение или отключение сглаживания (по умолчанию оно "
"отключено)."

msgid ""
"The order of the ``_draw`` calls is important- like with the Node positions "
"on the tree hierarchy, the different shapes will be drawn from top to "
"bottom, resulting in the latest shapes hiding earlier ones if they overlap. "
"In this case we want the mouth drawn over the head, so we put it afterwards."
msgstr ""
"Порядок вызовов ``_draw`` важен - как и в случае с позициями Node в иерархии "
"дерева, различные формы будут рисоваться сверху вниз, в результате чего "
"последние формы будут скрывать более ранние, если они перекрываются. В этом "
"случае мы хотим, чтобы рот был нарисован поверх головы, поэтому мы помещаем "
"его после."

msgid ""
"Notice how we can define colors in different ways, either with a hexadecimal "
"code or a predefined color name. Check the class :ref:`Color <class_Color>` "
"for other constants and ways to define Colors."
msgstr ""
"Обратите внимание, как мы можем определять цвета разными способами, либо с "
"помощью шестнадцатеричного кода, либо с помощью предопределенного имени "
"цвета. Проверьте класс :ref:`Color <class_Color>` для других констант и "
"способов определения цветов."

msgid "Drawing circles"
msgstr "Отрисовка кругов"

msgid ""
"To create the eyes, we are going to add 4 additional calls to draw the eye "
"shapes, in different sizes, colors and positions."
msgstr ""
"Чтобы создать глаза, мы добавим 4 дополнительных вызова для рисования форм "
"глаз, с различными размерами, цветами и позициями."

msgid ""
"To draw a circle, you position it based on its center using "
"the :ref:`draw_circle <class_CanvasItem_method_draw_circle>` method. The "
"first parameter is a :ref:`Vector2<class_Vector2>` with the coordinates of "
"its center, the second is its radius, and the third is its color:"
msgstr ""
"Чтобы отрисовать круг, вы располагаете его от центра используя "
"метод :ref:`draw_circle <class_CanvasItem_method_draw_circle>`. Первый "
"параметр это :ref:`Vector2<class_Vector2>` координат его центра, второй - "
"его радиус, а третий - его цвет:"

msgid "When executing it, you should have something like this:"
msgstr "При запуске, вы должны получить примерно это:"

msgid ""
"For partial, unfilled arcs (portions of a circle shape between certain "
"arbitrary angles), you can use the method :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."
msgstr ""
"Для неполных, незаполненных дуг (частей формы круга между произвольными "
"углами), вы можете использовать метод :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."

msgid "Drawing lines"
msgstr "Отрисовка линий"

msgid ""
"To draw the final shape (the nose) we will use a line to approximate it."
msgstr "Что отрисовать последнюю часть (нос) мы используем линию."

msgid ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` can be used to draw a "
"single segment by providing its start and end coordinates as arguments, like "
"this:"
msgstr ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` может быть использован "
"чтобы отрисовать одиночный сегмент используя начальные и конечные координаты "
"для аргументов, подобно этому:"

msgid "You should now be able to see the following shape on screen:"
msgstr "Вы должны сейчас увидеть следующую форму на экране:"

msgid ""
"Note that if multiple unconnected lines are going to be drawn at the same "
"time, you may get additional performance by drawing all of them in a single "
"call, using the :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` method."
msgstr ""
"Заметьте что при отрисовке множественных несоединенных линий, вы можете "
"получить дополнительную производительность рисуя все линии одним вызовом "
"метода :ref:`draw_multiline <class_CanvasItem_method_draw_multiline>`."

msgid "Drawing text"
msgstr "Отрисовка текста"

msgid ""
"While using the :ref:`Label <class_Label>` Node is the most common way to "
"add text to your application, the low-level `_draw` function includes "
"functionality to add text to your custom Node drawing. We will use it to add "
"the name \"GODOT\" under the robot head."
msgstr ""
"Хотя использование узла :ref:`Label <class_Label>` является наиболее "
"распространенным способом добавления текста в ваше приложение, "
"низкоуровневая функция \"_draw\" включает в себя возможности для добавления "
"текста в ваш пользовательский рисунок узла. Мы используем его, чтобы "
"добавить \"GODOT\" под головой робота."

msgid ""
"We will use the :ref:`draw_string <class_CanvasItem_method_draw_string>` "
"method to do it, like this:"
msgstr ""
"Мы будем использовать :ref:`draw_string "
"<class_CanvasItem_method_draw_string>` метод, для того чтобы сделать это, "
"вот так:"

msgid ""
"Here we first load into the defaultFont variable the configured default "
"theme font (a custom one can be set instead) and then we pass the following "
"parameters: font, position, text, horizontal alignment, width, and font size."
msgstr ""
"Здесь мы сначала загружаем в переменную defaultFont настроенный шрифт темы "
"по умолчанию (вместо него можно установить пользовательский шрифт), а затем "
"передаем следующие параметры: шрифт, положение, текст, горизонтальное "
"выравнивание, ширину и размер шрифта."

msgid "You should see the following on your screen:"
msgstr "Вот, что вы увидите на экране:"

msgid ""
"Additional parameters as well as other methods related to text and "
"characters can be found on the :ref:`CanvasItem <class_CanvasItem>` class "
"reference."
msgstr ""
"Дополнительные параметры, а также другие методы, связанные с текстом и "
"символами, можно найти в справочнике классов :ref:`CanvasItem "
"<class_CanvasItem>`."

msgid "Show the drawing while editing"
msgstr "Показывать рисунок во время редактирования"

msgid ""
"While the code so far is able to draw the logo on a running window, it will "
"not show up on the ``2D view`` on the editor. In certain cases you would "
"also like to show your custom Node2D or control on the editor, to position "
"and scale it appropriately, like most other nodes do."
msgstr ""
"Хотя код пока что может рисовать логотип в запущенном окне, он не будет "
"отображаться в ``2D view`` редактора. В некоторых случаях вы также захотите "
"отобразить свой пользовательский Node2D или элемент управления в редакторе, "
"чтобы разместить и масштабировать его соответствующим образом, как это "
"делают большинство других узлов."

msgid ""
"To show the logo directly on the editor (without running it), you can use "
"the :ref:`@tool<doc_gdscript_tool_mode>` annotation to request the custom "
"drawing of the node to also appear while editing, like this:"
msgstr ""
"Чтобы отобразить логотип непосредственно в редакторе (не запуская его), "
"можно использовать аннотацию :ref:`@tool<doc_gdscript_tool_mode>`, чтобы "
"запросить отображение пользовательского рисунка узла во время "
"редактирования, например:"

msgid ""
"You will need to save your scene, rebuild your project (for C# only) and "
"reload the current scene manually at the menu option ``Scene > Reload Saved "
"Scene`` to refresh the current node in the ``2D`` view the first time you "
"add or remove the ``@tool`` annotation."
msgstr ""
"Вам потребуется сохранить сцену, пересобрать проект (только для C#) и "
"перезагрузить текущую сцену вручную с помощью пункта меню ``Сцена > "
"Перезагрузить сохраненную сцену``, чтобы обновить текущий узел в "
"представлении ``2D`` при первом добавлении или удалении аннотации ``@tool``."

msgid "Animation"
msgstr "Анимация"

msgid ""
"If we wanted to make the custom shape change at runtime, we could modify the "
"methods called or its arguments at execution time, or apply a transform."
msgstr ""
"Если бы мы хотели изменить пользовательскую форму во время выполнения, мы "
"могли бы изменить вызываемые методы или их аргументы во время выполнения или "
"применить преобразование."

msgid ""
"For example, if we want the custom shape we just designed to rotate, we "
"could add the following variable and code to the ``_ready`` and ``_process`` "
"methods:"
msgstr ""
"Например, если мы хотим, чтобы только что созданная нами пользовательская "
"фигура вращалась, мы можем добавить следующую переменную и код в методы "
"``_ready`` и ``_process``:"

msgid ""
"The problem with the above code is that because we have created the points "
"approximately on a rectangle starting from the upper left corner, the ``(0, "
"0)`` coordinate and extending to the right and down, we see that the "
"rotation is done using the top left corner as pivot. A position transform "
"change on the node won't help us here, as the rotation transform is applied "
"first."
msgstr ""
"Проблема с приведенным выше кодом заключается в том, что поскольку мы "
"создали точки приблизительно на прямоугольнике, начиная с верхнего левого "
"угла, координата ``(0, 0)`` и простираясь вправо и вниз, мы видим, что "
"поворот выполняется с использованием верхнего левого угла в качестве опорной "
"точки. Изменение преобразования положения на узле нам здесь не поможет, "
"поскольку сначала применяется преобразование вращения."

msgid ""
"While we could rewrite all of the points' coordinates to be centered around "
"``(0, 0)``, including negative coordinates, that would be a lot of work."
msgstr ""
"Хотя мы могли бы переписать все координаты точек так, чтобы они были "
"центрированы вокруг ``(0, 0)``, включая отрицательные координаты, это "
"потребовало бы много работы."

msgid ""
"One possible way to work around this is to use the lower "
"level :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"method to fix this issue, translating all points in the CanvasItem's own "
"space, and then moving it back to its original place with a regular node "
"transform, either in the editor or in code, like this:"
msgstr ""
"Одним из возможных способов решения этой проблемы является использование "
"метода нижнего "
"уровня :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"для исправления этой проблемы, переводя все точки в собственном пространстве "
"CanvasItem, а затем возвращая его в исходное место с помощью обычного "
"преобразования узла либо в редакторе, либо в коде, например:"

msgid "This is the result, rotating around a pivot now on ``(60, 60)``:"
msgstr "Вот результат вращения вокруг точки опоры на ``(60, 60)``:"

msgid ""
"If what we wanted to animate was a property inside the ``_draw()`` call, we "
"must remember to call ``queue_redraw()`` to force a refresh, as otherwise it "
"would not be updated on screen."
msgstr ""
"Если мы хотим анимировать свойство внутри вызова ``_draw()``, мы должны не "
"забыть вызвать ``queue_redraw()`` для принудительного обновления, так как в "
"противном случае оно не будет обновлено на экране."

msgid ""
"For example, this is how we can make the robot appear to open and close its "
"mouth, by changing the width of its mouth line follow a sinusoidal "
"(:ref:`sin<class_@globalscope_method_sin>`) curve:"
msgstr ""
"Например, вот как мы можем заставить робота открывать и закрывать рот, "
"изменяя ширину линии его рта по синусоидальной "
"(:ref:`sin<class_@globalscope_method_sin>`) кривой:"

msgid "It will look somewhat like this when run:"
msgstr "Примерно так оно будет выглядеть при запуске:"

msgid ""
"Please note that ``_mouth_width`` is a user defined property like any other "
"and it or any other used as a drawing argument can be animated using more "
"standard and high-level methods such as a :ref:`Tween<class_Tween>` or "
"an :ref:`AnimationPlayer<class_AnimationPlayer>` Node. The only difference "
"is that a ``queue_redraw()`` call is needed to apply those changes so they "
"get shown on screen."
msgstr ""
"Обратите внимание, что ``_mouth_width`` - это определяемое пользователем "
"свойство, как и любое другое, и оно или любое другое, используемое в "
"качестве аргумента рисования, может быть анимировано с использованием более "
"стандартных и высокоуровневых методов, таких как "
"узел :ref:`Tween<class_Tween>` "
"или :ref:`AnimationPlayer<class_AnimationPlayer>`. Единственное отличие "
"заключается в том, что для применения этих изменений, чтобы они отображались "
"на экране, необходим вызов ``queue_redraw()``."

msgid "Example 2: drawing a dynamic line"
msgstr "Пример 2: рисование линии в динамике"

msgid ""
"The previous example was useful to learn how to draw and modify nodes with "
"custom shapes and animations. This could have some advantages, such as using "
"exact coordinates and vectors for drawing, rather than bitmaps -which means "
"they will scale well when transformed on screen. In some cases, similar "
"results could be achieved composing higher level functionality with nodes "
"such as :ref:`sprites<class_Sprite2D>` "
"or :ref:`AnimatedSprites<class_AnimatedSprite2D>` loading SVG resources "
"(which are also images defined with vectors) and "
"the :ref:`AnimationPlayer<class_AnimationPlayer>` node."
msgstr ""
"Предыдущий пример был полезен для изучения того, как рисовать и изменять "
"узлы с помощью пользовательских фигур и анимаций. Это может иметь некоторые "
"преимущества, такие как использование точных координат и векторов для "
"рисования, а не растровых изображений, что означает, что они будут хорошо "
"масштабироваться при трансформации на экране. В некоторых случаях похожих "
"результатов можно достичь, составляя функциональность более высокого уровня "
"с узлами, такими как :ref:`sprites<class_Sprite2D>` "
"или :ref:`AnimatedSprites<class_AnimatedSprite2D>`, загружающими ресурсы SVG "
"(которые также являются изображениями, определенными с помощью векторов), и "
"узлом :ref:`AnimationPlayer<class_AnimationPlayer>`."

msgid ""
"In other cases that will not be possible because we will not know what the "
"resulting graphical representation will be before running the code. Here we "
"will see how to draw a dynamic line whose coordinates are not known "
"beforehand, and are affected by the user's input."
msgstr ""
"В других случаях это будет невозможно, поскольку мы не будем знать, каким "
"будет итоговое графическое представление до запуска кода. Здесь мы увидим, "
"как нарисовать динамическую линию, координаты которой заранее неизвестны и "
"на которые влияет ввод пользователя."

msgid "Drawing a straight line between 2 points"
msgstr "Проведем прямую линию между 2 точек"

msgid ""
"Let's assume we want to draw a straight line between 2 points, the first one "
"will be fixed on the upper left corner ``(0, 0)`` and the second will be "
"defined by the cursor position on screen."
msgstr ""
"Предположим, мы хотим нарисовать прямую линию между двумя точками, первая из "
"которых будет зафиксирована в верхнем левом углу ``(0, 0)``, а вторая будет "
"определяться положением курсора на экране."

msgid "We could draw a dynamic line between those 2 points like this:"
msgstr ""
"Мы могли бы провести динамическую линию между этими двумя точками следующим "
"образом:"

msgid ""
"In this example we obtain the position of the mouse in the default viewport "
"every frame with the method :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. If the position has changed "
"since the last draw request (a small optimization to avoid redrawing on "
"every frame)- we will schedule a redraw. Our ``_draw()`` method only has one "
"line: requesting the drawing of a green line of width 10 pixels between the "
"top left corner and that obtained position."
msgstr ""
"В этом примере мы получаем позицию мыши в области просмотра по умолчанию в "
"каждом кадре с помощью метода :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. Если позиция изменилась с "
"момента последнего запроса на отрисовку (небольшая оптимизация, чтобы "
"избежать перерисовки в каждом кадре) - мы запланируем перерисовку. Наш метод "
"``_draw()`` имеет только одну строку: запрос на отрисовку зеленой линии "
"шириной 10 пикселей между верхним левым углом и полученной позицией."

msgid ""
"The width, color, and position of the starting point can be configured with "
"with the corresponding properties."
msgstr ""
"Ширину, цвет и положение начальной точки можно настроить с помощью "
"соответствующих свойств."

msgid "It should look like this when run:"
msgstr "При запуске, мы увидим следующее:"

msgid "Drawing an arc between 2 points"
msgstr "Рисование дуги между 2 точками"

msgid ""
"The above example works, but we may want to join those 2 points with a "
"different shape or function, other than a straight line."
msgstr ""
"Пример выше работает, но мы можем захотеть присоединить эти 2 точки с другой "
"формой или функцией, отличной от прямой линии."

msgid ""
"Let's try now creating an arc (a portion of a circumference) between both "
"points."
msgstr "Давайте попробуем создать дугу (часть окружности) между двумя точками."

msgid ""
"Exporting the line starting point, segments, width, color, and antialiasing "
"will allow us to modify those properties very easily directly from the "
"editor inspector panel:"
msgstr ""
"Экспортируя стартовую точку линии, сегменты, длину, цвет и сглаживание "
"позволит нам очень просто модифицировать эти свойства напрямую из панели "
"инспектора:"

msgid ""
"To draw the arc, we can use the "
"method :ref:`draw_arc<class_CanvasItem_method_draw_arc>`. There are many "
"arcs that pass through 2 points, so we will chose for this example the "
"semicircle that has its center in the middle point between the 2 initial "
"points."
msgstr ""
"Чтобы нарисовать дугу, мы можем использовать "
"метод :ref:`draw_arc<class_CanvasItem_method_draw_arc>`. Существует "
"множество дуг, проходящих через 2 точки, поэтому мы выберем для этого "
"примера полукруг с центром в средней точке между 2 начальными точками."

msgid "Calculating this arc will be more complex than in the case of the line:"
msgstr "Вычисление этой дуги может быть более сложным чем в случае линии:"

msgid ""
"The center of the semicircle will be the middle point between both points. "
"The radius will be half the distance between both points. The start and end "
"angles will be the angles of the vector from point1 to point2 and vice-"
"versa. Note we had to normalize the ``end_angle`` in positive values because "
"if ``end_angle`` is less than ``start_angle``, the arc will be drawn counter-"
"clockwise, which we don't want in this case (the arc would be upside-down)."
msgstr ""
"Центр полукруга будет точкой посередине между обеими точками. Радиус будет "
"половиной расстояния между обеими точками. Начальный и конечный углы будут "
"углами вектора от точки1 до точки2 и наоборот. Заметьте что мы нормализуем "
"``end_angle`` в позитивные значения поскольку если ``end_angle`` меньше чем "
"``start_angle``, дуга будет отрисована против часовой стрелки, что мы не "
"хотим в этом случае (дуга будет смотреть сверху-вниз)."

msgid ""
"The result should be something like this, with the arc going down and "
"between the points:"
msgstr ""
"Результат будет выглядеть как-то так, с дугой смотрящей вниз и между точек:"

msgid ""
"Feel free to play with the parameters in the inspector to obtain different "
"results: change the color, the width, the antialiasing, and increase the "
"number of segments to increase the curve smoothness, at the cost of extra "
"performance."
msgstr ""
"Не стесняйтесь поиграть с параметрами в инспекторе для получения различных "
"результатов: измените цвет, длину, сглаживание, и увеличьте количество "
"сегментов для усиления сглаживания кривой, за цену производительности."
