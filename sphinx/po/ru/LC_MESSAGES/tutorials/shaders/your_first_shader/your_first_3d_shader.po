#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "Ваш первый 3D-шейдер"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"Вы решили начать писать свой собственный пространственный шейдер. Возможно, "
"вы увидели в интернете интересный трюк с шейдерами, или обнаружили, "
"что :ref:`StandardMaterial3D <class_StandardMaterial3D>` не совсем "
"соответствует вашим потребностям. В любом случае, вы решили написать свой "
"собственный шейдер, и теперь вам нужно понять, с чего начать."

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"В этом руководстве объясняется, как написать Spatial (пространственный) "
"шейдер, и рассматривается больше тем, чем в руководстве :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>`."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatial шейдеры обладают более широким набором встроенных функций, чем "
"шейдеры CanvasItem. От spatial шейдеров ожидается, что Godot уже "
"предоставляет функциональность для распространённых случаев использования, и "
"пользователю остаётся лишь задать необходимые параметры в шейдере. Это "
"особенно актуально для рабочего процесса PBR (физически корректного "
"рендеринга)."

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In "
"the :ref:`second part <doc_your_second_spatial_shader>` we will take the "
"concepts from this tutorial and set up custom materials in a fragment shader "
"by writing an ocean water shader."
msgstr ""
"Это руководство состоит из двух частей. В первой части мы создадим ландшафт, "
"используя смещение вершин из карты высот в вершинной функции. "
"Во :ref:`второй части <doc_your_second_spatial_shader>` мы возьмём концепции "
"из этого руководства и настроим пользовательские материалы во фрагментном "
"шейдере, написав шейдер морской воды."

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"В этом руководстве предполагается наличие базовых знаний о шейдерах, таких "
"как типы (``vec2``, ``float``, ``sampler2D``) и функции. Если вы не знакомы "
"с этими понятиями, перед началом работы рекомендуется кратко ознакомиться с "
"`The Book of Shaders <https://thebookofshaders.com>`_."

msgid "Where to assign my material"
msgstr "Куда направить мой материал"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a "
"few :ref:`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic "
"geometry to a scene without importing Meshes."
msgstr ""
"В 3D объекты рисуются с помощью :ref:`Meshes <class_Mesh>`. Сетки - это тип "
"ресурса, который хранит геометрию (форму объекта) и материалы (цвет и "
"реакцию объекта на свет) в единицах, называемых \"поверхностями\". Сетка "
"может иметь несколько поверхностей или только одну. Как правило, вы "
"импортируете сетку из другой программы (например, Blender). Но в Godot также "
"есть несколько :ref:`PrimitiveMeshes <class_primitivemesh>`, которые "
"позволяют добавить базовую геометрию в сцену без импорта мешей."

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also "
"use :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"Существует несколько типов узлов, которые можно использовать для рисования "
"сетки. Основной — :ref:`MeshInstance3D <class_MeshInstance3D>`, но также "
"можно использовать :ref:`GPUParticles3D "
"<class_GPUParticles3D>`, :ref:`MultiMeshes <class_MultiMesh>` "
"(с :ref:`MultiMeshInstance3D <class_MultiMeshInstance3D>`) и другие."

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"Обычно материал связан с заданной поверхностью в сетке, но некоторые узлы, "
"такие как MeshInstance3D, позволяют переопределить материал для определенной "
"поверхности или для всех поверхностей."

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"Если вы установите материал для самой поверхности или сетки, то все "
"экземпляры MeshInstance3D, использующие эту сетку, будут использовать этот "
"материал. Однако, если вы хотите использовать одну и ту же сетку в "
"нескольких экземплярах, но при этом использовать разные материалы для "
"каждого экземпляра, необходимо установить материал для MeshInstance3D."

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"В этом уроке мы установим наш материал на самой сетке вместо того, чтобы "
"воспользоваться возможностью MeshInstance3D переопределять материалы."

msgid "Setting up"
msgstr "Настройка"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr ""
"Добавьте новый узел :ref:`MeshInstance3D <class_MeshInstance3D>` в вашу "
"сцену."

msgid ""
"In the inspector tab, set the MeshInstance3D's **Mesh** property to a "
"new :ref:`PlaneMesh <class_planemesh>` resource, by clicking on ``<empty>`` "
"and choosing **New PlaneMesh**. Then expand the resource by clicking on the "
"image of a plane that appears."
msgstr ""
"На вкладке Инспектор задайте свойству **Mesh** объекта MeshInstance3D новый "
"ресурс :ref:`PlaneMesh <class_planemesh>`, щёлкнув по ``<empty>`` и выбрав "
"**New PlaneMesh**. Затем разверните ресурс, щёлкнув по появившемуся "
"изображению плоскости."

msgid "This adds a plane to our scene."
msgstr "Это добавит самолет к нашей сцене."

msgid ""
"Then, in the viewport, click in the upper left corner on the **Perspective** "
"button. In the menu that appears, select **Display Wireframe**."
msgstr ""
"Затем в области просмотра нажмите кнопку **Perspective** в левом верхнем "
"углу. В появившемся меню выберите **Отобразить каркас**."

msgid "This will allow you to see the triangles making up the plane."
msgstr "Это позволит вам увидеть треугольники, составляющие плоскость."

msgid ""
"Now set **Subdivide Width** and **Subdivide Depth** of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"Теперь установите **Subdivide Width** и **Subdivide Depth** "
"для :ref:`PlaneMesh <class_planemesh>` на ``32``."

msgid ""
"You can see that there are now many more triangles in "
"the :ref:`MeshInstance3D<class_MeshInstance3D>`. This will give us more "
"vertices to work with and thus allow us to add more detail."
msgstr ""
"Видите, что теперь в :ref:`MeshInstance3D<class_MeshInstance3D>` стало "
"гораздо больше треугольников. Это даст нам больше вершин для работы и "
"позволит добавить больше деталей."

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Set the "
"**Material** to a new ShaderMaterial, then expand the material by clicking "
"on the sphere that appears."
msgstr ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, как и PlaneMesh, имеют только "
"одну поверхность, поэтому вместо массива материалов используется только "
"один. Задайте **Material** для нового ShaderMaterial, затем разверните "
"материал, щёлкнув по появившейся сфере."

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
"Материалы, наследующие ресурс :ref:`class_Material`, такие "
"как :ref:`class_StandardMaterial3D` и :ref:`class_ParticleProcessMaterial`, "
"можно преобразовать в :ref:`class_ShaderMaterial`, а их существующие "
"свойства будут преобразованы в соответствующий текстовый шейдер. Для этого "
"щёлкните правой кнопкой мыши по материалу в доке \"FileSystem\" и выберите "
"**Convert to ShaderMaterial**. Это также можно сделать, щёлкнув правой "
"кнопкой мыши по любому свойству, содержащему ссылку на материал, в "
"инспекторе."

msgid ""
"Now set the material's **Shader** to a new Shader by clicking ``<empty>`` "
"and select **New Shader...**. Leave the default settings, give your shader a "
"name, and click **Create**."
msgstr ""
"Теперь задайте **Shader** материала, нажав ``<пустой>`` и выберите **New "
"Shader...**. Оставьте настройки по умолчанию, дайте шейдеру имя и нажмите "
"**Create**."

msgid ""
"Click on the shader in the inspector, and the shader editor should now pop "
"up. You are ready to begin writing your first Spatial shader!"
msgstr ""
"Щелкните по шейдеру в инспекторе, и должен открыться редактор шейдеров. "
"Теперь вы готовы приступить к написанию своего первого пространственного "
"шейдера!"

msgid "Shader magic"
msgstr "Магия шейдеров"

msgid ""
"The new shader is already generated with a ``shader_type`` variable, the "
"``vertex()`` function, and the ``fragment()`` function. The first thing "
"Godot shaders need is a declaration of what type of shader they are. In this "
"case the ``shader_type`` is set to ``spatial`` because this is a spatial "
"shader."
msgstr ""
"Новый шейдер уже сгенерирован с переменной ``shader_type``, функцией "
"``vertex()`` и функцией ``fragment()``. Первое, что требуется шейдерам "
"Godot, — это объявление типа шейдера. В данном случае ``shader_type`` "
"установлено как ``spatial``, поскольку это пространственный шейдер."

msgid ""
"The ``vertex()`` function determines where the vertices of "
"your :ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. "
"We will be using it to offset the height of each vertex and make our flat "
"plane appear like a little terrain."
msgstr ""
"Функция ``vertex()`` определяет, где вершины "
"вашего :ref:`MeshInstance3D<class_MeshInstance3D>` появятся в финальной "
"сцене. Мы будем использовать её для смещения высоты каждой вершины, чтобы "
"наша плоская поверхность выглядела как небольшой ландшафт."

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can start to make changes by adding a single line:"
msgstr ""
"Поскольку функция ``vertex()`` пуста, Godot будет использовать вершинный "
"шейдер по умолчанию. Мы можем начать вносить изменения, добавив одну строку:"

msgid "Adding this line, you should get an image like the one below."
msgstr ""
"Добавив эту строку, вы должны получить изображение, подобное показанному "
"ниже."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to :ref:`cos() <shader_func_cos>` and :ref:`sin() "
"<shader_func_sin>`; that gives us a wave-like appearance across the ``x`` "
"and ``z`` axes."
msgstr ""
"Хорошо, давайте разберёмся. Значение ``y`` вершины ``VERTEX`` увеличивается. "
"Мы передаём компоненты ``x`` и ``z`` вершины ``VERTEX`` в качестве "
"аргументов :ref:`cos() <shader_func_cos>` и :ref:`sin() <shader_func_sin>`; "
"это создаёт волнообразный эффект по осям ``x`` и ``z``."

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos()`` "
"and ``sin()`` already look kind of like hills. We do so by scaling the "
"inputs to the ``cos()`` and ``sin()`` functions."
msgstr ""
"В конце концов, мы хотим добиться эффекта небольших холмов. ``cos()`` и "
"``sin()`` уже выглядят как холмы. Мы добиваемся этого, масштабируя входные "
"данные функций ``cos()`` и ``sin()``."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr ""
"Выглядит лучше, но все еще слишком много острых углов и повторений. Давайте "
"сделаем это немного интереснее."

msgid "Noise heightmap"
msgstr "Карта высот шума"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"Шум — очень популярный инструмент для имитации рельефа. Представьте его как "
"функцию косинуса с повторяющимися холмами, только с шумом каждый холм имеет "
"разную высоту."

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot предоставляет ресурс :ref:`NoiseTexture2D <class_noisetexture2D>` для "
"генерации текстуры шума, к которой можно получить доступ из шейдера."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"Чтобы получить доступ к текстуре в шейдере, добавьте следующий код в верхнюю "
"часть шейдера, за пределами функции ``vertex()``."

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called **Shader "
"Parameters**. If you open it up, you'll see a parameter called \"Noise\"."
msgstr ""
"Это позволит вам отправить текстуру шума в шейдер. Теперь откройте инспектор "
"под вашим материалом. Вы увидите раздел **Shader Parameters**. Открыв его, "
"вы увидите параметр \"Noise\"."

msgid ""
"Set this **Noise** parameter to a new :ref:`NoiseTexture2D "
"<class_noisetexture2D>`. Then in your NoiseTexture2D, set its **Noise** "
"property to a new :ref:`FastNoiseLite <class_fastnoiselite>`. The "
"FastNoiseLite class is used by the NoiseTexture2D to generate a heightmap."
msgstr ""
"Задайте для этого параметра **Noise** новое значение :ref:`NoiseTexture2D "
"<class_noisetexture2D>`. Затем в NoiseTexture2D задайте для его свойства "
"**Noise** новое значение :ref:`FastNoiseLite <class_fastnoiselite>`. Класс "
"FastNoiseLite используется NoiseTexture2D для генерации карты высот."

msgid "Once you set it up and should look like this."
msgstr "Как только вы его настроите, он и должен выглядеть вот так."

msgid "Now, access the noise texture using the ``texture()`` function:"
msgstr ""
"Теперь получите доступ к текстуре шума, используя функцию ``texture()``:"

msgid ""
":ref:`texture() <shader_func_texture>` takes a texture as the first argument "
"and a ``vec2`` for the position on the texture as the second argument. We "
"use the ``x`` and ``z`` channels of ``VERTEX`` to determine where on the "
"texture to look up."
msgstr ""
"Функция :ref:`texture() <shader_func_texture>` принимает текстуру в качестве "
"первого аргумента и ``vec2`` для позиции на текстуре в качестве второго "
"аргумента. Мы используем каналы ``x`` и ``z`` функции ``VERTEX`` для "
"определения точки на текстуре."

msgid ""
"Since the PlaneMesh coordinates are within the ``[-1.0, 1.0]`` range (for a "
"size of ``2.0``), while the texture coordinates are within ``[0.0, 1.0]``, "
"to remap the coordinates we divide by the size of the PlaneMesh by ``2.0`` "
"and add ``0.5`` ."
msgstr ""
"Поскольку координаты PlaneMesh находятся в диапазоне ``[-1.0, 1.0]`` (для "
"размера ``2.0``), а координаты текстуры находятся в диапазоне ``[0.0, "
"1.0]``, для перераспределения координат мы делим размер PlaneMesh на ``2.0`` "
"и добавляем ``0.5``."

msgid ""
"``texture()`` returns a ``vec4`` of the ``r, g, b, a`` channels at the "
"position. Since the noise texture is grayscale, all of the values are the "
"same, so we can use any one of the channels as the height. In this case "
"we'll use the ``r``, or ``x`` channel."
msgstr ""
"``texture()`` возвращает ``vec4`` каналов ``r, g, b, a`` в указанной "
"позиции. Поскольку текстура шума представлена в оттенках серого, все "
"значения одинаковы, поэтому мы можем использовать любой из каналов в "
"качестве высоты. В данном случае мы будем использовать канал ``r`` или ``x``."

msgid ""
"``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture().x`` "
"above, we could use ``texture().r``. See the `OpenGL documentation <https://"
"www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more details."
msgstr ""
"``xyzw`` — это то же самое, что ``rgba`` в GLSL, поэтому вместо "
"``texture().x``, приведённого выше, можно использовать ``texture().r``. "
"Подробнее см. в документации OpenGL <https://www.khronos.org/opengl/wiki/"
"Data_Type_(GLSL)#Vectors>`_."

msgid "Using this code you can see the texture creates random looking hills."
msgstr ""
"Используя этот код, вы можете увидеть, как текстура создает случайно "
"выглядящие холмы."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"Сейчас он слишком колючий, мы хотим немного смягчить холмы. Для этого мы "
"используем равномерное распределение. Выше вы уже использовали равномерное "
"распределение для передачи текстуры шума, теперь давайте разберёмся, как оно "
"работает."

msgid "Uniforms"
msgstr "Uniform-переменные"

msgid ""
":ref:`Uniform variables <doc_shading_language_uniforms>` allow you to pass "
"data from the game into the shader. They are very useful for controlling "
"shader effects. Uniforms can be almost any datatype that can be used in the "
"shader. To use a uniform, you declare it in your :ref:`Shader<class_Shader>` "
"using the keyword ``uniform``."
msgstr ""
":ref:`Uniform variables <doc_shading_language_uniforms>` позволяют "
"передавать данные из игры в шейдер. Они очень полезны для управления "
"эффектами шейдера. Uniforms могут быть практически любым типом данных, "
"который можно использовать в шейдере. Чтобы использовать Uniform, объявите "
"его в :ref:`Shader<class_Shader>` с помощью ключевого слова ``uniform``."

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "Давайте создадим uniform, которая будет менять высоту рельефа."

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the "
"function :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` on the material "
"corresponding to the shader. The value passed from GDScript takes precedence "
"over the value used to initialize it in the shader."
msgstr ""
"Godot позволяет инициализировать юниформу заданным значением; в данном "
"случае ``height_scale`` равен ``0.5``. Вы можете задать юниформу из "
"GDScript, вызвав функцию :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` для материала, "
"соответствующего шейдеру. Значение, переданное из GDScript, имеет приоритет "
"над значением, использованным для его инициализации в шейдере."

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"Изменение униформ в узлах Spatial отличается от изменений в узлах "
"CanvasItem. Здесь мы задаём материал внутри ресурса PlaneMesh. В других "
"ресурсах сетки может потребоваться сначала получить доступ к материалу, "
"вызвав ``surface_get_material()``. В MeshInstance3D доступ к материалу "
"осуществляется с помощью ``get_surface_material()`` или "
"``material_override``."

msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the shader. You can use the uniform "
"variable anywhere inside your shader. Here, we will use it to set the height "
"value instead of arbitrarily multiplying by ``0.5``."
msgstr ""
"Помните, что строка, передаваемая в ``set_shader_parameter()``, должна "
"совпадать с именем переменной uniform в шейдере. Вы можете использовать "
"переменную uniform в любом месте шейдера. Здесь мы будем использовать её для "
"установки значения высоты вместо произвольного умножения на ``0.5``."

msgid "Now it looks much better."
msgstr "Теперь все выглядит намного лучше."

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"Используя юниформы, мы можем даже изменять значение в каждом кадре, чтобы "
"анимировать высоту рельефа. В сочетании с :ref:`Tweens <class_Tween>` это "
"может быть особенно полезно для анимации."

msgid "Interacting with light"
msgstr "Взаимодействие со светом"

msgid ""
"First, turn wireframe off. To do so, open the **Perspective** menu in the "
"upper-left of the viewport again, and select **Display Normal**. "
"Additionally in the 3D scene toolbar, turn off preview sunlight."
msgstr ""
"Сначала отключите каркасную модель. Для этого снова откройте меню "
"**Perspective** в левом верхнем углу области просмотра и выберите **Display "
"Normal**. Кроме того, на панели инструментов 3D-сцены отключите "
"предварительный просмотр sunlight."

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"Обратите внимание, что цвет сетки стал плоским. Это потому, что освещение на "
"ней плоское. Давайте добавим свет!"

msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene, "
"and drag it up so it is above the terrain."
msgstr ""
"Сначала мы добавим :ref:`OmniLight3D<class_OmniLight3D>` к сцене и перетащим "
"его так, чтобы он оказался над ландшафтом."

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"Вы видите, как свет падает на ландшафт, но выглядит это странно. Проблема в "
"том, что свет падает на ландшафт так, как будто это плоская поверхность. Это "
"происходит потому, что шейдер освещения использует нормали из :ref:`Mesh "
"<class_mesh>` для расчёта света."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"Нормали хранятся в сетке, но мы меняем её форму в шейдере, поэтому нормали "
"становятся некорректными. Чтобы исправить это, мы можем пересчитать нормали "
"в шейдере или использовать текстуру нормалей, соответствующую нашему шуму. "
"Godot упрощает оба варианта."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"Вы можете вручную рассчитать новую нормаль в вершинной функции, а затем "
"просто установить ``NORMAL``. Если установлено ``NORMAL``, Godot выполнит "
"все сложные расчёты освещения за нас. Мы рассмотрим этот метод в следующей "
"части урока, а пока будем считывать нормали из текстуры."

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"Вместо этого мы снова положимся на NoiseTexture для расчёта нормалей. Для "
"этого мы передаём вторую текстуру шума."

msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normal Map**."
msgstr ""
"Установите эту вторую однородную текстуру на другую :ref:`NoiseTexture2D "
"<class_noisetexture2D>` с другим :ref:`FastNoiseLite <class_fastnoiselite>`. "
"Но на этот раз выберите **Как карту нормалей**."

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP`` in the ``fragment()`` function. This way Godot will handle "
"wrapping the texture around the mesh automatically."
msgstr ""
"Если у нас есть нормали, соответствующие определённой вершине, мы "
"устанавливаем ``NORMAL``, но если у вас есть карта нормалей, полученная из "
"текстуры, задайте нормаль с помощью ``NORMAL_MAP`` в функции ``fragment()``. "
"Таким образом, Godot автоматически обёртывает сетку текстурой."

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the "
"``VERTEX.xz`` position from the ``vertex()`` function to the ``fragment()`` "
"function. We do that using a :ref:`varying <doc_shading_language_varyings>`."
msgstr ""
"Наконец, чтобы гарантировать, что мы считываем данные с одних и тех же мест "
"на текстуре шума и текстуре карты нормалей, мы передадим позицию "
"``VERTEX.xz`` из функции ``vertex()`` в функцию ``fragment()``. Это делается "
"с помощью :ref:`varying <doc_shading_language_varyings>`."

msgid ""
"Above the ``vertex()`` define a ``varying vec2`` called ``tex_position``. "
"And inside the ``vertex()`` function assign ``VERTEX.xz`` to "
"``tex_position``."
msgstr ""
"Над функцией ``vertex()`` определите ``varying vec2`` с именем "
"``tex_position``. Внутри функции ``vertex()`` присвойте ``VERTEX.xz`` "
"значению ``tex_position``."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr ""
"И теперь мы можем получить доступ к ``tex_position`` из функции "
"``fragment()``."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr ""
"После установки нормалей свет теперь динамически реагирует на высоту сетки."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr ""
"Мы даже можем перетаскивать источник света, и освещение будет обновляться "
"автоматически."

msgid "Full code"
msgstr "Полный код"

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"Вот полный код этого урока. Как видите, он не очень длинный, поскольку Godot "
"берёт на себя большую часть сложных задач."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"На этом всё в этой части. Надеюсь, теперь вы понимаете основы vertex "
"(вершинных) шейдеров в Godot. В следующей части урока мы напишем fragment "
"функцию для этой вершинной функции и рассмотрим более продвинутый метод "
"превращения этой поверхности в океан движущихся волн."
