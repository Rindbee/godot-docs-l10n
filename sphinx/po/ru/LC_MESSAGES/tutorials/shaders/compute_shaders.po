#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "Применение вычислительных шейдеров"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"В этом руководстве мы покажем вам процесс создания минимального "
"вычислительного шейдера. Но сначала немного информации о вычислительных "
"шейдерах и их работе с Godot."

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"В этом руководстве предполагается, что вы в целом знакомы с шейдерами. Если "
"вы новичок в этом деле, пожалуйста, "
"прочтите :ref:`doc_introduction_to_shaders` и :ref:`your first shader <toc-"
"your-first-shader>`, прежде чем продолжить изучение этого руководства."

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"Сompute (Вычислительный) шейдер — это особый тип шейдерной программы, "
"ориентированный на программирование общего назначения. Другими словами, они "
"более гибкие, чем vertex и fragment шейдеры, поскольку у них нет "
"фиксированной цели (например, преобразования вершин или записи цветов в "
"изображение). В отличие от vertex и fragment шейдеров, вычислительные "
"шейдеры практически не выполняют никаких внутренних операций. Графический "
"процессор выполняет только написанный вами код, и практически ничего больше. "
"Это делает их очень полезным инструментом для переноса тяжёлых вычислений на "
"графический процессор."

msgid "Now let's get started by creating a short compute shader."
msgstr "Теперь приступим к созданию короткого compute шейдера."

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"Сначала во **внешнем** текстовом редакторе по вашему выбору создайте новый "
"файл ``compute_example.glsl`` в папке вашего проекта. Вычислительные шейдеры "
"в Godot пишутся непосредственно на GLSL. Язык шейдеров Godot основан на "
"GLSL. Если вы знакомы с обычными шейдерами в Godot, синтаксис ниже покажется "
"вам знакомым."

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"Вычислительные шейдеры можно использовать только из рендереров на базе "
"RenderingDevice (рендер Forward+ или Mobile). Для выполнения этого "
"руководства убедитесь, что вы используете рендер Forward+ или Mobile. "
"Настройки находятся в правом верхнем углу редактора."

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"Обратите внимание, что поддержка вычислительных шейдеров на мобильных "
"устройствах, как правило, плохая (из-за ошибок драйверов), даже если они "
"технически поддерживаются."

msgid "Let's take a look at this compute shader code:"
msgstr "Давайте посмотрим на этот код вычислительного шейдера:"

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"Этот код принимает массив чисел с плавающей точкой, умножает каждый элемент "
"на 2 и сохраняет результат обратно в массив буфера. Теперь давайте "
"рассмотрим его построчно."

msgid "These two lines communicate two things:"
msgstr "Эти две строки сообщают две вещи:"

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"Следующий код представляет собой вычислительный шейдер. Это специфическая "
"подсказка Godot, необходимая редактору для корректного импорта файла шейдера."

msgid "The code is using GLSL version 450."
msgstr "Код использует GLSL версии 450."

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr ""
"Вам никогда не придется менять эти две строки для ваших пользовательских "
"вычислительных шейдеров."

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"Затем мы сообщаем количество вызовов, которые будут использоваться в каждой "
"рабочей группе. Вызовы — это экземпляры шейдера, работающие в одной рабочей "
"группе. При запуске вычислительного шейдера из CPU мы сообщаем ему, сколько "
"рабочих групп нужно запустить. Рабочие группы работают параллельно друг "
"другу. При запуске одной рабочей группы доступ к информации в другой рабочей "
"группе невозможен. Однако вызовы в одной рабочей группе могут иметь "
"ограниченный доступ к другим вызовам."

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr ""
"Подумайте о рабочих группах и вызовах как о гигантском вложенном цикле "
"``for``."

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"Рабочие группы и вызовы — это сложная тема. Пока что запомните, что мы будем "
"выполнять два вызова на каждую рабочую группу."

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"Здесь мы предоставляем информацию о памяти, к которой будет иметь доступ "
"вычислительный шейдер. Свойство ``layout`` позволяет указать шейдеру, где "
"искать буфер. Позже нам потребуется сопоставить эти позиции ``set`` и "
"``binding`` со стороны ЦП."

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"Ключевое слово ``restrict`` сообщает шейдеру, что к этому буферу можно будет "
"получить доступ только из одного места в шейдере. Другими словами, мы не "
"будем привязывать этот буфер к другому индексу ``set`` или ``binding``. Это "
"важно, поскольку позволяет компилятору шейдера оптимизировать код шейдера. "
"Всегда используйте ``restrict``, когда это возможно."

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"Это буфер *неопределённого размера*, то есть он может быть любого размера. "
"Поэтому нужно быть осторожным, чтобы не читать данные из индекса, размер "
"которого превышает размер буфера."

msgid ""
"Finally, we write the ``main`` function which is where all the logic "
"happens. We access a position in the storage buffer using the "
"``gl_GlobalInvocationID`` built-in variables. ``gl_GlobalInvocationID`` "
"gives you the global unique ID for the current invocation."
msgstr ""
"Наконец, мы пишем функцию ``main``, в которой реализуется вся логика. Мы "
"получаем доступ к позиции в буфере хранения, используя встроенные переменные "
"``gl_GlobalInvocationID``. ``gl_GlobalInvocationID`` возвращает глобальный "
"уникальный идентификатор текущего вызова."

msgid ""
"To continue, write the code above into your newly created "
"``compute_example.glsl`` file."
msgstr ""
"Чтобы продолжить, впишите код выше в только что созданный файл "
"``compute_example.glsl``."

msgid "Create a local RenderingDevice"
msgstr "Создайте локальное RenderingDevice"

msgid ""
"To interact with and execute a compute shader, we need a script. Create a "
"new script in the language of your choice and attach it to any Node in your "
"scene."
msgstr ""
"Для взаимодействия с вычислительным шейдером и его выполнения нам "
"понадобится скрипт. Создайте новый скрипт на выбранном вами языке и "
"прикрепите его к любому Узлу в вашей сцене."

msgid ""
"Now to execute our shader we need a local :ref:`class_RenderingDevice` which "
"can be created using the :ref:`class_RenderingServer`:"
msgstr ""
"Теперь для выполнения нашего шейдера нам нужен "
"локальный :ref:`class_RenderingDevice`, который можно создать с "
"помощью :ref:`class_RenderingServer`:"

msgid ""
"After that, we can load the newly created shader file "
"``compute_example.glsl`` and create a precompiled version of it using this:"
msgstr ""
"После этого мы можем загрузить недавно созданный файл шейдера "
"``compute_example.glsl`` и создать его предварительно скомпилированную "
"версию, используя следующее:"

msgid ""
"Local RenderingDevices cannot be debugged using tools such as `RenderDoc "
"<https://renderdoc.org/>`__."
msgstr ""
"Локальные RenderingDevices невозможно отладить с помощью таких инструментов, "
"как `RenderDoc <https://renderdoc.org/>`__."

msgid "Provide input data"
msgstr "Предоставьте входные данные"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"Как вы, возможно, помните, мы хотим передать входной массив в наш шейдер, "
"умножить каждый элемент на 2 и получить результат."

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"Нам нужно создать буфер для передачи значений в вычислительный шейдер. Мы "
"работаем с массивом чисел с плавающей точкой, поэтому в этом примере мы "
"будем использовать буфер хранения. Буфер хранения принимает массив байтов и "
"позволяет центральному процессору передавать данные в графический процессор "
"и обратно."

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr ""
"Итак, давайте инициализируем массив чисел с плавающей точкой и создадим "
"буфер хранения:"

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"После того, как буфер готов, нам нужно указать устройству рендеринга "
"использовать его. Для этого нам потребуется создать uniform (как в обычных "
"шейдерах) и назначить его набору uniform, который мы позже передадим в наш "
"шейдер."

msgid "Defining a compute pipeline"
msgstr "Определение вычислительного pipeline"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr ""
"Следующий шаг — создание набора инструкций, которые может выполнить наш "
"графический процессор. Для этого нам понадобится конвейер и список "
"вычислений."

msgid "The steps we need to do to compute our result are:"
msgstr "Шаги, которые нам необходимо выполнить для вычисления результата:"

msgid "Create a new pipeline."
msgstr "Создайте новый pipeline."

msgid "Begin a list of instructions for our GPU to execute."
msgstr ""
"Начать список инструкций, которые должен выполнить наш графический процессор."

msgid "Bind our compute list to our pipeline"
msgstr "Свяжите наш список вычислений с нашим pipeline"

msgid "Bind our buffer uniform to our pipeline"
msgstr "Привяжите наш буфер к нашему pipeline"

msgid "Specify how many workgroups to use"
msgstr "Укажите, сколько рабочих групп использовать"

msgid "End the list of instructions"
msgstr "Завершить список инструкций"

msgid ""
"Note that we are dispatching the compute shader with 5 work groups in the X "
"axis, and one in the others. Since we have 2 local invocations in the X axis "
"(specified in our shader), 10 compute shader invocations will be launched in "
"total. If you read or write to indices outside of the range of your buffer, "
"you may access memory outside of your shaders control or parts of other "
"variables which may cause issues on some hardware."
msgstr ""
"Обратите внимание, что мы запускаем вычислительный шейдер с пятью рабочими "
"группами по оси X и одной по остальным. Поскольку у нас есть два локальных "
"вызова по оси X (указанных в нашем шейдере), всего будет запущено 10 вызовов "
"вычислительного шейдера. При чтении или записи по индексам за пределами "
"диапазона буфера возможен доступ к памяти за пределами контроля шейдера или "
"к частям других переменных, что может вызвать проблемы на некоторых "
"устройствах."

msgid "Execute a compute shader"
msgstr "Выполнить вычислительный шейдер"

msgid ""
"After all of this we are almost done, but we still need to execute our "
"pipeline. So far we have only recorded what we would like the GPU to do; we "
"have not actually run the shader program."
msgstr ""
"После всего этого мы почти закончили, но нам ещё нужно запустить наш "
"конвейер. Пока что мы только записали, что именно должен делать графический "
"процессор; мы ещё не запустили шейдерную программу."

msgid ""
"To execute our compute shader we need to submit the pipeline to the GPU and "
"wait for the execution to finish:"
msgstr ""
"Чтобы выполнить наш вычислительный шейдер, нам необходимо передать конвейер "
"графическому процессору и дождаться завершения выполнения:"

msgid ""
"Ideally, you would not call ``sync()`` to synchronize the RenderingDevice "
"right away as it will cause the CPU to wait for the GPU to finish working. "
"In our example, we synchronize right away because we want our data available "
"for reading right away. In general, you will want to wait *at least* 2 or 3 "
"frames before synchronizing so that the GPU is able to run in parallel with "
"the CPU."
msgstr ""
"В идеале не следует вызывать ``sync()`` для синхронизации RenderingDevice "
"сразу, так как это заставит CPU ждать завершения работы GPU. В нашем примере "
"мы синхронизируемся сразу, потому что хотим, чтобы данные были доступны для "
"чтения немедленно. В общем случае, перед синхронизацией следует подождать "
"*как минимум* 2-3 кадра, чтобы GPU мог работать параллельно с CPU."

msgid ""
"Long computations can cause Windows graphics drivers to \"crash\" due "
"to :abbr:`TDR (Timeout Detection and Recovery)` being triggered by Windows. "
"This is a mechanism that reinitializes the graphics driver after a certain "
"amount of time has passed without any activity from the graphics driver "
"(usually 5 to 10 seconds)."
msgstr ""
"Длительные вычисления могут привести к \"crash\" графических драйверов "
"Windows из-за активации :abbr:`TDR (Timeout Detection and Recovery)` в "
"Windows. Это механизм, который повторно инициализирует графический драйвер "
"по истечении определённого времени бездействия (обычно 5–10 секунд)."

msgid ""
"Depending on the duration your compute shader takes to execute, you may need "
"to split it into multiple dispatches to reduce the time each dispatch takes "
"and reduce the chances of triggering a TDR. Given TDR is time-dependent, "
"slower GPUs may be more prone to TDRs when running a given compute shader "
"compared to a faster GPU."
msgstr ""
"В зависимости от длительности выполнения вычислительного шейдера может "
"потребоваться разделить его на несколько отправок, чтобы сократить время "
"каждой отправки и снизить вероятность срабатывания TDR. Учитывая, что TDR "
"зависит от времени, более медленные видеокарты могут быть более подвержены "
"возникновению TDR при выполнении данного вычислительного шейдера по "
"сравнению с более быстрыми видеокартами."

msgid "Retrieving results"
msgstr "Получение результатов"

msgid ""
"You may have noticed that, in the example shader, we modified the contents "
"of the storage buffer. In other words, the shader read from our array and "
"stored the data in the same array again so our results are already there. "
"Let's retrieve the data and print the results to our console."
msgstr ""
"Вы, возможно, заметили, что в примере шейдера мы изменили содержимое буфера "
"хранения. Другими словами, шейдер считывает данные из нашего массива и снова "
"сохраняет их в том же массиве, так что наши результаты уже там. Давайте "
"извлечём данные и выведем результат на консоль."

msgid "Freeing memory"
msgstr "Очистка памяти"

msgid ""
"The ``buffer``, ``pipeline``, and ``uniform_set`` variables we've been using "
"are each an :ref:`class_RID`. Because RenderingDevice is meant to be a lower-"
"level API, RIDs aren't freed automatically. This means that once you're done "
"using ``buffer`` or any other RID, you are responsible for freeing its "
"memory manually using the "
"RenderingDevice's :ref:`free_rid()<class_RenderingDevice_method_free_rid>` "
"method."
msgstr ""
"Используемые нами переменные ``buffer``, ``pipeline`` и ``uniform_set`` "
"представляют собой :ref:`class_RID`. Поскольку RenderingDevice задуман как "
"низкоуровневый API, RID не освобождаются автоматически. Это означает, что "
"после завершения использования ``buffer`` или любого другого RID вам "
"необходимо вручную освободить память с помощью "
"метода :ref:`free_rid()<class_RenderingDevice_method_free_rid>` класса "
"RenderingDevice."

msgid ""
"With that, you have everything you need to get started working with compute "
"shaders."
msgstr ""
"Теперь у вас есть все необходимое для начала работы с вычислительными "
"шейдерами."

msgid ""
"The demo projects repository contains a `Compute Shader Heightmap demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/compute/"
"heightmap>`__ This project performs heightmap image generation on the CPU "
"and GPU separately, which lets you compare how a similar algorithm can be "
"implemented in two different ways (with the GPU implementation being faster "
"in most cases)."
msgstr ""
"Репозиторий демонстрационных проектов содержит `демонстрацию Compute Shader "
"Heightmap <https://github.com/godotengine/godot-demo-projects/tree/master/"
"compute/heightmap>`__ Этот проект выполняет генерацию изображения карты "
"высот отдельно на центральном процессоре и графическом процессоре, что "
"позволяет сравнить, как один и тот же алгоритм может быть реализован двумя "
"различными способами (при этом реализация на графическом процессоре в "
"большинстве случаев оказывается быстрее)."
