#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Расширенная пост-обработка"

msgid "Introduction"
msgstr "Введение"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"В этом руководстве описывается продвинутый метод пост-обработки в Godot. В "
"частности, будет объяснено, как написать шейдер пост-обработки, использующий "
"буфер глубины. Вы уже должны быть знакомы с пост-обработкой в целом и, в "
"частности, с методами, описанными в :ref:`custom post-processing tutorial "
"<doc_custom_postprocessing>`."

msgid "Full screen quad"
msgstr "Полный экран Quad"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"Один из способов создания пользовательских эффектов постобработки — "
"использование Viewport. Однако у неё есть два основных недостатка:"

msgid "The depth buffer cannot be accessed"
msgstr "Невозможно получить доступ к буферу глубины"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "Эффект шейдера постобработки не виден в редакторе"

msgid ""
"To get around the limitation on using the depth buffer, use "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"Чтобы обойти ограничение на использование буфера глубины, "
"используйте :ref:`MeshInstance3D <class_MeshInstance3D>` с "
"примитивом :ref:`QuadMesh <class_QuadMesh>`. Это позволяет использовать "
"шейдер и получить доступ к текстуре глубины сцены. Затем используйте "
"вершинный шейдер, чтобы квадрат покрывал экран постоянно, и эффект "
"постобработки применялся всегда, в том числе в редакторе."

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"Сначала создайте новый объект MeshInstance3D и установите для него сетку "
"QuadMesh. Это создаст четырёхугольник с центром в точке ``(0, 0, 0)`` с "
"шириной и высотой ``1``. Установите ширину и высоту на ``2`` и включите "
"опцию **Flip Faces**. Сейчас четырёхугольник занимает положение в мировом "
"пространстве в начале координат. Однако мы хотим, чтобы он перемещался "
"вместе с камерой, чтобы всегда покрывать весь экран. Для этого мы обойдем "
"преобразования координат, которые переводят положения вершин через "
"разностные координатные пространства, и будем обрабатывать вершины так, как "
"будто они уже находятся в пространстве отсечения."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position in clip space directly."
msgstr ""
"Вершинный шейдер ожидает вывода координат в пространстве отсечения, которые "
"находятся в диапазоне от ``-1`` в левом и нижнем углах экрана до ``1`` в "
"верхнем и правом углах экрана. Именно поэтому QuadMesh должен иметь высоту и "
"ширину ``2``. Godot выполняет преобразование из пространства модели в "
"пространство вида и обратно, поэтому нам нужно свести на нет эффект "
"преобразований Godot. Мы делаем это, устанавливая встроенную функцию "
"``POSITION`` в нужное положение. ``POSITION`` обходит встроенные "
"преобразования и напрямую устанавливает положение вершины в пространстве "
"отсечения."

msgid ""
"In versions of Godot earlier than 4.3, this code recommended using "
"``POSITION = vec4(VERTEX, 1.0);`` which implicitly assumed the clip-space "
"near plane was at ``0.0``. That code is now incorrect and will not work in "
"versions 4.3+ as we use a \"reversed-z\" depth buffer now where the near "
"plane is at ``1.0``."
msgstr ""
"В версиях Godot до 4.3 этот код рекомендовал использовать ``POSITION = "
"vec4(VERTEX, 1.0);``, что неявно предполагало, что ближняя плоскость "
"пространства отсечения находится в точке ``0.0``. Этот код теперь неверен и "
"не будет работать в версиях 4.3+, поскольку теперь мы используем буфер "
"глубины с \"reversed-z\", где ближняя плоскость находится в точке ``1.0``."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Даже с этим вершинным (вертексным) шейдером квадрант продолжает исчезать. "
"Это происходит из-за выборки фрустума, которая выполняется на CPU. "
"Фрустумная очистка использует матрицу камеры и AABBs сетки, чтобы "
"определить, будет ли сетка видимой *до* передачи ее на GPU. CPU не знает, "
"что мы делаем с вершинами, поэтому он предполагает, что указанные координаты "
"относятся к мировым позициям, а не к позициям пространства клипа, что "
"приводит к тому, что Godot выбраковывает квад, когда мы отворачиваемся от "
"центра сцены. Для того чтобы квадрант не сворачивался, есть несколько "
"вариантов:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Добавьте QuadMesh как дочерний элемент к камере, чтобы камера всегда была "
"направлена на него"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Установите свойство геометрии ``extra_cull_margin`` как можно больше в "
"QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"Второй вариант гарантирует, что квадрат будет виден в редакторе, а первый — "
"что он останется видимым, даже если камера выйдет за пределы области "
"отбраковки. Вы также можете использовать оба варианта."

msgid "Depth texture"
msgstr "Текстура глубины"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"Чтобы выполнить чтение из текстуры глубины, нам сначала нужно создать "
"единообразный набор текстур для буфера глубины с помощью "
"``hint_metre_texture``."

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""
"После определения текстуру глубины можно прочитать с помощью функции "
"``texture()``."

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"Подобно доступу к текстуре экрана, доступ к текстуре глубины возможен только "
"при чтении из текущего окна просмотра. Текстура глубины недоступна из "
"другого окна просмотра, в котором вы выполнили рендеринг."

msgid ""
"The values returned by ``depth_texture`` are between ``1.0`` and ``0.0`` "
"(corresponding to the near and far plane, respectively, because of using a "
"\"reverse-z\" depth buffer) and are nonlinear. When displaying depth "
"directly from the ``depth_texture``, everything will look almost black "
"unless it is very close due to that nonlinearity. In order to make the depth "
"value align with world or model coordinates, we need to linearize the value. "
"When we apply the projection matrix to the vertex position, the z value is "
"made nonlinear, so to linearize it, we multiply it by the inverse of the "
"projection matrix, which in Godot, is accessible with the variable "
"``INV_PROJECTION_MATRIX``."
msgstr ""
"Значения, возвращаемые ``deep_texture``, находятся в диапазоне от ``1.0`` до "
"``0.0`` (что соответствует ближней и дальней плоскостям соответственно из-за "
"использования буфера глубины с \"обратной осью z\") и являются нелинейными. "
"При отображении глубины непосредственно из ``deep_texture`` всё будет "
"выглядеть почти чёрным, если только не находится очень близко, из-за этой "
"нелинейности. Чтобы привести значение глубины в соответствие с мировыми или "
"модельными координатами, нам необходимо линеаризовать его. При применении "
"матрицы проекции к положению вершины значение \"z\" становится нелинейным, "
"поэтому для его линеаризации мы умножаем его на обратную матрицу проекции, "
"которая в Godot доступна через переменную ``INV_PROJECTION_MATRIX``."

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"Сначала преобразуем координаты экранного пространства в нормализованные "
"координаты устройства (NDC). NDC изменяется от ``-1.0`` до ``1.0`` по осям "
"``x`` и ``y`` и от ``0.0`` до ``1.0`` по осям ``z`` при использовании "
"бэкенда Vulkan. Восстановите NDC, используя ``SCREEN_UV`` для осей ``x`` и "
"``y`` и значение глубины для ``z``."

msgid ""
"This tutorial assumes the use of the Forward+ or Mobile renderers, which "
"both use Vulkan NDCs with a Z-range of ``[0.0, 1.0]``. In contrast, the "
"Compatibility renderer uses OpenGL NDCs with a Z-range of ``[-1.0, 1.0]``. "
"For the Compatibility renderer, replace the NDC calculation with this "
"instead:"
msgstr ""
"В этом руководстве предполагается использование рендеров Forward+ или "
"Mobile, которые используют NDC Vulkan с Z-диапазоном ``[0.0, 1.0]``. В "
"отличие от этого, рендер совместимости использует NDC OpenGL с Z-диапазоном "
"``[-1.0, 1.0]``. Для рендера совместимости замените расчёт NDC следующим "
"образом:"

msgid ""
"You can also use the ``CURRENT_RENDERER`` and ``RENDERER_COMPATIBILITY`` "
"built-in defines for a shader that will work in all renderers:"
msgstr ""
"Вы также можете использовать встроенные определения ``CURRENT_RENDERER`` и "
"``RENDERER_COMPATIBILITY`` для шейдера, который будет работать во всех "
"рендерерах:"

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"Преобразуйте NDC в пространство обзора, умножив NDC на "
"``INV_PROJECTION_MATRIX``. Напомним, что пространство обзора задаёт "
"положение относительно камеры, поэтому значение ``z`` будет указывать "
"расстояние до точки."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Поскольку камера направлена в отрицательном направлении оси ``z``, позиция "
"будет иметь отрицательное значение ``z``. Чтобы получить полезное значение "
"глубины, нам нужно изменить ``view.z`` на отрицательное."

msgid ""
"The world position can be constructed from the depth buffer using the "
"following code, using the ``INV_VIEW_MATRIX`` to transform the position from "
"view space into world space."
msgstr ""
"Положение в мире можно построить из буфера глубины с помощью следующего "
"кода, используя ``INV_VIEW_MATRIX`` для преобразования положения из "
"пространства вида в мировое пространство."

msgid "Example shader"
msgstr "Пример шейдера"

msgid ""
"Once we add a line to output to ``ALBEDO``, we have a complete shader that "
"looks something like this. This shader lets you visualize the linear depth "
"or world space coordinates, depending on which line is commented out."
msgstr ""
"После добавления строки для вывода в ``ALBEDO`` мы получаем готовый шейдер, "
"который выглядит примерно так. Этот шейдер позволяет визуализировать "
"линейную глубину или координаты в мировом пространстве, в зависимости от "
"того, какая строка закомментирована."

msgid "An optimization"
msgstr "Оптимизация"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"However, the benefit is quite small and only beneficial when running "
"especially complex fragment shaders."
msgstr ""
"Использование одного большого треугольника вместо полноэкранного квадрата "
"может дать преимущество. Причина этого объяснена здесь: <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>_. "
"Однако преимущество довольно незначительно и заметно только при запуске "
"особенно сложных фрагментных шейдеров."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Установите сетку в MeshInstance3D в :ref:`ArrayMesh <class_ArrayMesh>`. "
"ArrayMesh — это инструмент, позволяющий легко создать сетку из массивов "
"вершин, нормалей, цветов и т. д."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr "Теперь прикрепите скрипт к MeshInstance3D и используйте следующий код:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"Треугольник задаётся в нормализованных координатах устройства. Напомним, что "
"NDC изменяется от ``-1.0`` до ``1.0`` как в направлениях ``x``, так и ``y``. "
"Это увеличивает ширину экрана до ``2`` единиц, а высоту до ``2`` единиц. "
"Чтобы покрыть весь экран одним треугольником, используйте треугольник "
"шириной ``4`` единиц и высотой ``4`` единиц, удвоив его высоту и ширину."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Назначьте тот же вершинный шейдер, что и выше, и все должно выглядеть точно "
"так же."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"Единственный недостаток использования ArrayMesh по сравнению с QuadMesh "
"заключается в том, что ArrayMesh не виден в редакторе, поскольку треугольник "
"не строится до запуска сцены. Чтобы обойти это ограничение, создайте в "
"программе моделирования один треугольный Mesh и используйте его в "
"MeshInstance3D."
