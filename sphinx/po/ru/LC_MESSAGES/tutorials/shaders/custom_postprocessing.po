#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "Пользовательская пост-обработка"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described "
"in :ref:`doc_environment_and_post_processing`. However, advanced use cases "
"may require custom effects. This article explains how to write your own "
"custom effects."
msgstr ""
"Godot предоставляет множество встроенных эффектов постобработки, включая "
"Bloom, DOF и SSAO, которые описаны в "
"документе :ref:`doc_environment_and_post_processing`. Однако для более "
"сложных случаев могут потребоваться пользовательские эффекты. В этой статье "
"объясняется, как создавать собственные пользовательские эффекты."

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"Самый простой способ реализовать собственный шейдер постобработки — "
"использовать встроенную в Godot возможность чтения текстуры с экрана. Если "
"вы не знакомы с этим, рекомендуем сначала прочитать :ref:`Учебник по "
"шейдерам для чтения с экрана <doc_screen-reading_shaders>`."

msgid "Single pass post-processing"
msgstr "Однопроходная постобработка"

msgid ""
"Post-processing effects are shaders applied to a frame after Godot has "
"rendered it. To apply a shader to a frame, create a :ref:`CanvasLayer "
"<class_CanvasLayer>`, and give it a :ref:`ColorRect <class_ColorRect>`. "
"Assign a new :ref:`ShaderMaterial <class_ShaderMaterial>` to the newly "
"created ``ColorRect``, and set the ``ColorRect``'s anchor preset to Full "
"Rect:"
msgstr ""
"Эффекты постобработки — это шейдеры, применяемые к кадру после его "
"рендеринга Godot. Чтобы применить шейдер к кадру, создайте :ref:`CanvasLayer "
"<class_CanvasLayer>` и присвойте ему :ref:`ColorRect <class_ColorRect>`. "
"Назначьте новый :ref:`ShaderMaterial <class_ShaderMaterial>` только что "
"созданному ``ColorRect`` и установите для ``ColorRect`` якорный шаблон Full "
"Rect:"

msgid "Setting the anchor preset to Full Rect on the ColorRect node"
msgstr "Установка предустановки привязки на Full Rect на узле ColorRect"

msgid "Your scene tree will look something like this:"
msgstr "Ваше дерево сцен будет выглядеть примерно так:"

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"Другой более эффективный метод — использовать :ref:`BackBufferCopy "
"<class_BackBufferCopy>` для копирования области экрана в буфер и доступа к "
"ней в скрипте шейдера через ``sampler2D`` с использованием "
"``hint_screen_texture``."

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"На момент написания статьи Godot не поддерживает рендеринг в несколько "
"буферов одновременно. Ваш шейдер постобработки не будет иметь доступа к "
"другим проходам рендеринга и буферам, не предоставляемым Godot (например, к "
"глубине или нормалям/шероховатости). Вам будет доступен только отрендеренный "
"кадр и буферы, предоставляемые Godot в качестве сэмплеров."

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr ""
"Для этой демонстрации мы будем использовать :ref:`Sprite <class_Sprite2D>` "
"овцы."

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built-in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"Назначьте новый :ref:`Shader <class_Shader>` для ``ShaderMaterial`` объекта "
"``ColorRect``. Доступ к текстуре и UV-координатам рамки можно получить с "
"помощью ``sampler2D``, используя ``hint_screen_texture`` и встроенные "
"юниформы ``SCREEN_UV``."

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"Скопируйте следующий код в свой шейдер. Этот код — шейдер шестнадцатеричной "
"пикселизации от `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/"
"master/>`_,"

msgid "The sheep will look something like this:"
msgstr "Овца будет выглядеть примерно так:"

msgid "Multi-pass post-processing"
msgstr "Многопроходная пост-обработка"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"Некоторые эффекты постобработки, такие как размытие, требуют больших "
"ресурсов. Вы можете значительно ускорить их выполнение, разбив на несколько "
"проходов. В многопроходном материале каждый проход принимает результат "
"предыдущего прохода в качестве входных данных и обрабатывает его."

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"Для создания многопроходного шейдера постобработки узлы ``CanvasLayer`` и "
"``ColorRect`` объединяются в один. В приведённом выше примере объект "
"``CanvasLayer`` используется для рендеринга шейдера с использованием кадра "
"на слое ниже. За исключением структуры узлов, шаги те же, что и для "
"однопроходного шейдера постобработки."

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"Например, вы можете реализовать полноэкранный эффект гауссова размытия, "
"добавив следующие фрагменты кода к каждому узлу ``ColorRect``. Порядок "
"применения шейдеров зависит от положения ``CanvasLayer`` в дереве сцены: чем "
"выше, тем быстрее. Для этого шейдера размытия порядок не имеет значения."

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr ""
"Используя приведенный выше код, вы должны получить эффект размытия на весь "
"экран, как показано ниже."
