#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "Шейдеры чтения экрана"

msgid "Introduction"
msgstr "Введение"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"Часто требуется создать шейдер, считывающий данные с того же экрана, на "
"который он выводит данные. 3D API, такие как OpenGL или DirectX, значительно "
"затрудняют это из-за внутренних аппаратных ограничений. Графические "
"процессоры работают исключительно параллельно, поэтому чтение и запись "
"вызывают всевозможные проблемы с кэшем и когерентностью. В результате даже "
"самое современное оборудование не поддерживает эту функцию должным образом."

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"Обходной путь — скопировать экран или его часть во вторичный буфер, а затем "
"считывать оттуда данные во время рисования. Godot предоставляет несколько "
"инструментов, упрощающих этот процесс."

msgid "Screen texture"
msgstr "Текстура экрана"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_language` имеет специальную текстуру для доступа к "
"уже отрисованному содержимому экрана. Она используется с указанием подсказки "
"при объявлении юниформы ``sampler2D``: ``hint_screen_texture``. Специальный "
"встроенный вариативный ``SCREEN_UV`` может использоваться для получения UV-"
"координат относительно экрана для текущего фрагмента. В результате этот "
"фрагментный шейдер canvas_item создаёт невидимый объект, поскольку "
"отображает только то, что находится за ним:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"Здесь используется ``textureLod``, поскольку мы хотим читать только из "
"нижней MIP-карты. Если вы хотите читать из размытой версии текстуры, можно "
"увеличить третий аргумент до ``textureLod`` и изменить подсказку "
"``filter_nearest`` на ``filter_nearest_mipmap`` (или любой другой фильтр с "
"поддержкой MIP-карт). При использовании фильтра с MIP-картами Godot "
"автоматически рассчитает размытую текстуру."

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with an LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""
"Если режим фильтра не изменен на режим фильтра, содержащий ``mipmap`` в "
"своем названии, ``textureLod`` с параметром LOD больше ``0.0`` будет иметь "
"тот же вид, что и с параметром LOD ``0.0``."

msgid "Screen texture example"
msgstr "Пример текстуры экрана"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"Текстуру экрана можно использовать для множества целей. Существует "
"специальная демоверсия *Screen Space Shaders*, которую вы можете скачать, "
"чтобы посмотреть и изучить. Один из примеров — простой шейдер для настройки "
"яркости, контрастности и насыщенности:"

msgid "Behind the scenes"
msgstr "За кулисами сцен"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"Хоть это и кажется магией, это не так. В 2D, когда ``hint_screen_texture`` "
"впервые обнаруживается в узле, готовящемся к отрисовке, Godot делает "
"полноэкранное копирование во вторичный буфер. Последующие узлы, использующие "
"его в шейдерах, не будут копировать экран, поскольку это становится "
"неэффективным. В 3D экран копируется после прохода непрозрачной геометрии, "
"но до прохода прозрачной геометрии, поэтому прозрачные объекты не будут "
"захвачены в текстуре экрана."

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"В результате в 2D, если шейдеры, использующие ``hint_screen_texture``, "
"перекрываются, второй не будет использовать результат первого, что приведет "
"к неожиданным визуальным эффектам:"

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"На изображении выше вторая сфера (справа вверху) использует тот же источник "
"для текстуры экрана, что и первая ниже, поэтому первая \"исчезает\" или не "
"видна."

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"В 2D это можно исправить с помощью узла :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, который можно создать между обеими сферами. "
"BackBufferCopy может работать, указывая как область экрана, так и весь экран:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""
"При правильном копировании обратного буфера две сферы смешиваются правильно:"

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""
"В 3D материалы, использующие ``hint_screen_texture``, сами по себе считаются "
"прозрачными и не будут отображаться в результирующей текстуре экрана других "
"материалов. Если вы планируете создать сцену, использующую материал с "
"``hint_screen_texture``, вам потребуется узел BackBufferCopy."

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"В 3D-графике решение этой проблемы менее гибкое, поскольку экранная текстура "
"захватывается только один раз. Будьте осторожны при использовании экранной "
"текстуры в 3D, так как она не захватывает прозрачные объекты и может "
"захватывать некоторые непрозрачные объекты, находящиеся перед объектом, "
"использующим экранную текстуру."

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"Вы можете воспроизвести логику заднего буфера в 3D, создав :ref:`Viewport "
"<class_Viewport>` с камерой в том же положении, что и ваш объект, а затем "
"использовать текстуру :ref:`Viewport's <class_Viewport>` вместо текстуры "
"экрана."

msgid "Back-buffer logic"
msgstr "Логика обратного буфера"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"Итак, чтобы было понятнее, вот как работает логика копирования обратного "
"буфера в 2D в Godot:"

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"Если узел использует ``hint_screen_texture``, весь экран копируется в "
"дальний буфер перед отрисовкой этого узла. Это происходит только в первый "
"раз; последующие узлы не вызывают этого."

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"Если узел BackBufferCopy был обработан до ситуации, описанной в пункте выше "
"(даже если ``hint_screen_texture`` не использовался), описанное в пункте "
"выше поведение не происходит. Другими словами, автоматическое копирование "
"всего экрана происходит только в том случае, если ``hint_screen_texture`` "
"используется в узле впервые и ранее в дереве не было найдено ни одного узла "
"BackBufferCopy (не отключённого)."

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy может копировать как весь экран, так и его область. Если "
"BackBufferCopy копирует только область (а не весь экран), и ваш шейдер "
"использует пиксели, не входящие в копируемую область, результат чтения будет "
"неопределённым (скорее всего, это мусор из предыдущих кадров). Другими "
"словами, BackBufferCopy можно использовать для обратного копирования области "
"экрана, а затем для чтения текстуры экрана из другой области. Избегайте "
"такого поведения!"

msgid "Depth texture"
msgstr "Текстура глубины"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"Для 3D-шейдеров также возможен доступ к буферу глубины экрана. Для этого "
"используется подсказка ``hint_metre_texture``. Эта текстура нелинейна и "
"должна быть преобразована с помощью матрицы обратной проекции."

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "Следующий код извлекает 3D-позицию под отрисовываемым пикселем:"

msgid "Normal-roughness texture"
msgstr "Текстура нормальной шероховатости"

msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr ""
"Текстура с нормальной шероховатостью поддерживается только в методе "
"рендеринга Forward+, но не в Mobile или Compatibility."

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"Аналогично, текстура нормалей и шероховатости может использоваться для "
"считывания нормалей и шероховатости объектов, визуализируемых в "
"предварительном проходе глубины. Нормаль хранится в каналах ``.xyz`` "
"(соответствующих диапазону 0-1), а шероховатость — в канале ``.w``."

msgid "Redefining screen textures"
msgstr "Переосмысление текстур экрана"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"Подсказки текстуры экрана (``hint_screen_texture``, ``hint_metre_texture`` и "
"``hint_normal_roughness_texture``) можно использовать с несколькими "
"униформами. Например, может потребоваться несколько раз прочитать текстуру с "
"разными флагами повторения или фильтра."

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"В следующем примере показан шейдер, который считывает нормаль экранного "
"пространства с помощью линейной фильтрации, но считывает шероховатость "
"экранного пространства с помощью фильтрации ближайшего соседа."
