#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "Введение"

msgid "Setting up the scene"
msgstr "Настраиваем сцену"

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"Заметили некрасивый шов, который образуется там, где текстура оборачивается "
"вокруг? Это потому, что мы выбираем цвет на основе UV-координат, а UV-"
"координаты не оборачиваются вокруг текстуры. Это классическая проблема при "
"проекции двумерных карт. Разработчики игр часто имеют двумерную карту, "
"которую они хотят спроецировать на сферу, но когда она оборачивается вокруг, "
"получаются большие швы. Существует элегантный обходной путь решения этой "
"проблемы, который мы проиллюстрируем в следующем разделе."

msgid ""
"So now, when we render to our :ref:`SubViewport <class_SubViewport>`, it "
"appears magically on the sphere. But there is an ugly seam created by our "
"texture coordinates. So how do we get a range of coordinates that wrap "
"around the sphere in a nice way? One solution is to use a function that "
"repeats on the domain of our texture. ``sin`` and ``cos`` are two such "
"functions. Let's apply them to the texture and see what happens. Replace the "
"existing color code in the shader with the following:"
msgstr ""
"Итак, теперь, когда мы рендерим в наш :ref:`SubViewport "
"<class_SubViewport>`, он чудесным образом отображается на сфере. Но есть "
"некрасивый шов, создаваемый нашими текстурными координатами. Как же нам "
"получить диапазон координат, который будет красиво огибать сферу? Одно из "
"решений — использовать функцию, повторяющуюся в области определения нашей "
"текстуры. ``sin`` и ``cos`` — две такие функции. Давайте применим их к "
"текстуре и посмотрим, что получится. Замените существующий код цвета в "
"шейдере следующим:"

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"Для каждого пикселя мы вычислим его трехмерное положение на сфере. Исходя из "
"этого, мы будем использовать 3D-шум для определения значения цвета. "
"Рассчитывая шум в 3D, мы решаем проблему защемления на полюсах. Чтобы "
"понять, почему, представьте, что шум рассчитывается по поверхности сферы, а "
"не по двухмерной плоскости. Когда вы рассчитываете по поверхности сферы, вы "
"никогда не заденете край, а значит, не создадите шов или точку защемления на "
"полюсе. Следующий код преобразует ``UV`` в декартовы координаты."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"Еще одна вещь, чтобы сделать это немного более планетарным. Земля не должна "
"быть такой шарообразной; давайте сделаем края немного более грубыми. Трюк, "
"который часто используется в шейдерах для создания грубого рельефа с помощью "
"шума, заключается в наложении друг на друга уровней шума с различными "
"частотами. Мы используем один слой для создания общей шарообразной структуры "
"континентов. Затем другой слой немного разбивает края, затем еще один, и так "
"далее. Мы вычислим ``n`` с помощью четырех строк кода шейдера вместо одной. "
"``n`` становится:"

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`SubViewport "
"<class_SubViewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`SubViewport "
"<class_SubViewport>` and enable the \"Transparent Bg\" property. Since we "
"are now rendering one transparent object on top of another, we want to "
"enable ``blend_premul_alpha``:"
msgstr ""
"Вы заметите, что изменений практически нет, за исключением того, что планета "
"больше не отражает небо. Это происходит потому, что по умолчанию при "
"рендеринге с альфа-значением объект отображается как прозрачный поверх фона. "
"А поскольку фон по умолчанию для :ref:`SubViewport <class_SubViewport>` "
"непрозрачен, канал ``alpha`` для :ref:`Viewport Texture "
"<class_ViewportTexture>` равен ``1``, в результате чего текстура планеты "
"отображается с чуть более тусклыми цветами и значением ``Roughness "
"(шероховатости)``, равным ``1`` везде. Чтобы исправить это, мы переходим "
"к :ref:`SubViewport <class_SubViewport>` и включаем свойство \"Transparent "
"Bg (Прозрачный фон)\". Поскольку теперь мы рендерим один прозрачный объект "
"поверх другого, нам нужно включить ``blend_premul_alpha``:"
