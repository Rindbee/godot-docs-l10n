#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "Оптимизация Производительности Навигации"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr ""
"Распространенные проблемы производительности, связанные с Навигацией, можно "
"разделить на следующие категории:"

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr ""
"Проблемы производительности при анализе узлов дерева сцены для запекания "
"навигационной сетки."

msgid "Performance problems with baking the actual navigation mesh."
msgstr ""
"Проблемы с производительностью при запекании реальной навигационной сетки."

msgid "Performance problems with NavigationAgent path queries."
msgstr "Проблемы производительности при запросах пути NavigationAgent."

msgid "Performance problems with the actual path search."
msgstr "Проблемы с производительностью при реальном поиске пути."

msgid "Performance problems with synchronizing the navigation map."
msgstr "Проблемы с производительностью синхронизации навигационной карты."

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"В следующих разделах вы найдете информацию о том, как выявить и устранить "
"или, по крайней мере, уменьшить их влияние на частоту кадров."

msgid "Performance problems with parsing scene tree nodes"
msgstr "Проблемы производительности при анализе узлов дерева сцены"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"Отдавайте предпочтение простым формам с минимальным количеством граней, "
"например, не используйте округлые формы вроде круга, сферы или тора (torus)."

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"В качестве исходной геометрии отдавайте предпочтение использованию "
"физических форм столкновений, а не сложных визуальных сеток, поскольку сетки "
"необходимо копировать из графического процессора, и они, как правило, "
"гораздо более подробны, чем необходимо."

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"В целом, избегайте использования очень сложной геометрии в качестве исходной "
"для запекания навигационных сеток. Например, никогда не используйте очень "
"детализированную визуальную сетку, так как преобразование её формы в массивы "
"данных и вокселизация для запекания навигационной сетки займёт много "
"времени, не давая существенного прироста качества финальной навигационной "
"сетки. Вместо этого используйте очень упрощённую версию формы. Ещё лучше "
"использовать очень примитивные формы, такие как блоки и прямоугольники, "
"которые лишь приблизительно охватывают ту же геометрию, но при этом дают "
"достаточно хороший результат запекания для поиска пути."

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"Предпочитайте использовать простые формы коллизий физики вместо визуальных "
"мешей в качестве исходной геометрии для запекания навигационных мешей. "
"Физические формы коллизий по умолчанию являются очень ограниченными и "
"оптимизированными формами, которые легко и быстро разбираются. Визуальный "
"меш, с другой стороны, может варьироваться от простых до сложных. Более "
"того, чтобы получить доступ к данным визуального меша, парсеру необходимо "
"запрашивать массивы данных меша у RenderingServer, поскольку данные "
"визуального меша хранятся непосредственно на GPU и не кэшируются на CPU. Это "
"требует блокировки потоков RenderingServer, что может существенно повлиять "
"на частоту кадров во время выполнения, в то время как рендеринг выполняется "
"в многопоточном режиме. Если рендеринг выполняется в однопоточном режиме, "
"влияние на частоту кадров может быть еще более значительным, и разбор меша "
"может \"заморозить\" всю игру на несколько секунд при работе со сложными "
"мешами."

msgid "Performance problems with navigation mesh baking"
msgstr "Проблемы с производительностью при запекании навигационной сетки"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr ""
"Во время выполнения всегда предпочитайте использовать фоновый поток для "
"запекания навигационных сеток."

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"Увеличьте NavigationMesh ``cell_size`` и ``cell_height``, чтобы создать "
"меньше вокселей."

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr ""
"Измените ``SamplePartitionType`` с водораздела на монотонный или слои, чтобы "
"повысить производительность выпечки."

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"НИКОГДА не масштабируйте исходную геометрию с узлами, чтобы избежать ошибок "
"точности. В большинстве случаев масштаб применяется только визуально, и "
"формы, которые очень велики в своём базовом масштабе, всё равно требуют "
"значительной дополнительной обработки даже при уменьшении масштаба."

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"Запекание навигационных сеток во время выполнения всегда следует по "
"возможности выполнять в фоновом потоке. Даже для небольших навигационных "
"сеток запекание может занять гораздо больше времени, чем можно уместить в "
"один кадр, по крайней мере, если частота кадров должна оставаться на "
"приемлемом уровне."

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out of memory in the middle "
"and crashes the game. The partition type can also be lowered depending on "
"how complex the games source geometry is to gain some performance. E.g. "
"games with mostly flat surfaces with blocky geometry can get away with the "
"monotone or layers mode that are a lot faster to bake (e.g. because they "
"require no distance field pass)."
msgstr ""
"Сложность исходных данных геометрии, проанализированных из узлов дерева "
"сцены, оказывает большое влияние на производительность запекания, поскольку "
"все должно быть отображено на сетку / воксели. Для производительности "
"запекания во время выполнения размер и высота ячеек NavigationMesh должны "
"быть установлены как можно выше, не вызывая проблем с качеством navigation "
"mesh для игры. Если размер или высота ячеек слишком низкие, запекание "
"вынуждено создавать чрезмерное количество вокселей для обработки исходной "
"геометрии. Если исходная геометрия охватывает очень большой игровой мир, то "
"возможно даже, что процесс запекания исчерпает память в середине и приведет "
"к сбою игры. Тип раздела также может быть понижен в зависимости от сложности "
"исходной геометрии игры, чтобы повысить производительность. Например, игры с "
"преимущественно плоскими поверхностями с блочной геометрией могут обойтись "
"монотонным или слоистым режимом, которые намного быстрее запекаются "
"(например, потому что они не требуют прохода поля расстояний)."

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"Никогда не масштабируйте исходную геометрию с помощью узлов. Это может "
"привести не только к множеству ошибок точности из-за неправильного "
"сопоставления вершин и рёбер, но и к тому, что некоторые масштабы "
"проявляются только визуально, а не в фактически проанализированных данных. "
"Например, если масштаб сетки визуально уменьшен в редакторе, например, "
"установлен на 0,001 для MeshInstance, для запекания сетки всё равно "
"потребуется гигантская и очень сложная сетка вокселей."

msgid "Performance problems with NavigationAgent path queries"
msgstr "Проблемы производительности при запросах пути NavigationAgent"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr ""
"Избегайте ненужных сбросов пути и запросов в каждом кадре в скриптах "
"NavigationAgent."

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr "Избегайте обновления всех путей NavigationAgent в одном кадре."

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"Логические ошибки и неэффективные операции в пользовательских скриптах "
"NavigationAgent часто приводят к проблемам с производительностью. Например, "
"обратите внимание на сброс пути в каждом кадре. По умолчанию NavigationAgent "
"оптимизированы для запроса новых путей только при изменении целевой позиции, "
"изменении навигационной карты или при слишком большом отклонении от "
"желаемого пути."

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"Например, когда ИИ должен двигаться к игроку, целевая позиция не должна "
"устанавливаться на основе позиции игрока в каждом кадре, так как это "
"приводит к запросу нового пути в каждом кадре. Вместо этого следует "
"сравнивать расстояние от текущей целевой позиции до позиции игрока, и только "
"когда игрок отошёл слишком далеко, следует устанавливать новую целевую "
"позицию."

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"Не проверяйте заранее, достижима ли целевая позиция в каждом кадре. То, что "
"выглядит как невинная проверка, на самом деле эквивалентно дорогостоящему "
"запросу пути в фоновом режиме. Если планируется запросить новый путь в любом "
"случае, если позиция достижима, путь следует запрашивать напрямую. Проверка "
"последней позиции возвращаемого пути и того, находится ли она на "
"\"достижимом\" расстоянии от проверяемой позиции, позволяет ответить на "
"вопрос \"достижима ли эта позиция?\". Это позволяет избежать выполнения двух "
"полных запросов пути в каждом кадре для одного и того же NavigationAgent."

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"Разделите общее количество NavigationAgents на группы обновлений или "
"используйте случайные таймеры, чтобы они не все запрашивали новые пути в "
"одном кадре."

msgid "Performance problems with the actual path search"
msgstr "Проблемы с производительностью при реальном поиске пути"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr ""
"Оптимизируйте чрезмерно подробные навигационные сетки, уменьшив количество "
"полигонов и ребер."

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"Стоимость фактического поиска пути напрямую коррелирует с количеством "
"полигонов и рёбер навигационной сетки, а не с реальным размером игрового "
"мира. Если в гигантском игровом мире используются высокооптимизированные "
"навигационные сетки с небольшим количеством полигонов, покрывающих большие "
"площади, производительность должна быть приемлемой. Если игровой мир разбит "
"на очень маленькие навигационные сетки, каждая из которых состоит из "
"крошечных полигонов (например, в случае с TileMaps), производительность "
"поиска пути снизится."

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"Распространенной проблемой является внезапное падение производительности, "
"когда целевая позиция не может быть достигнута в запросе пути. Такое падение "
"производительности является \"нормальным\" и является результатом слишком "
"большой и неоптимизированной навигационной сетки с большим количеством "
"полигонов и рёбер для поиска. При обычном поиске пути, когда целевая позиция "
"может быть достигнута быстро, поиск пути выполняет ранний выход сразу после "
"её достижения, что может на некоторое время скрыть этот недостаток "
"оптимизации. Если целевая позиция не может быть достигнута, поиск пути "
"должен выполнить гораздо более длительный поиск по доступным полигонам, "
"чтобы убедиться, что позиция абсолютно недостижима."

msgid "Performance problems with navigation map synchronization"
msgstr "Проблемы с производительностью синхронизации навигационных карт"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr ""
"По возможности объединяйте полигоны навигационных сеток по вершинам, а не по "
"ребрам."

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"При внесении изменений, например, в навигационные сетки или навигационные "
"регионы, NavigationServer должен синхронизировать навигационную карту. В "
"зависимости от сложности навигационных сеток, это может занять значительное "
"время и повлиять на частоту кадров."

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"NavigationServer объединяет навигационные сетки либо по вершинам, либо по "
"соединениям рёбер. Объединение по вершинам происходит, когда две вершины "
"двух разных рёбер попадают в одни и те же ячейки сетки карты. Это довольно "
"быстрая и малозатратная операция. Объединение по соединениям рёбер "
"происходит во втором проходе для всех ещё необъединённых рёбер. Все "
"свободные рёбра проверяются на наличие возможных соединений рёбер как по "
"расстоянию, так и по углу, что требует значительных затрат."

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"Таким образом, помимо общего правила, требующего как можно меньшего "
"количества рёбер полигонов, следует объединять как можно больше рёбер по "
"вершинам заранее, чтобы для более затратного расчёта рёберных соединений "
"оставалось лишь несколько рёбер. Отладочный Navigation PerformanceMonitor "
"можно использовать для получения статистики о количестве доступных полигонов "
"и рёбер, а также о том, сколько из них не объединены или не объединены по "
"вершинам. Если соотношение между объединёнными вершинами и рёберными "
"соединениями сильно отличается (число вершин должно быть значительно выше), "
"навигационные сетки создаются или размещаются крайне неэффективно."
