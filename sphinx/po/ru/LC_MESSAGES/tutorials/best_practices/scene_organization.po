#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "Организация сцены"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should you use? Where should you place them? How should "
"they interact?"
msgstr ""
"Эта статья охватывает темы связанные с эффективной организацией содержания "
"сцены. Какие узлы вам стоит использовать? Где их стоит располагать? Как они "
"должны взаимодействовать?"

msgid "How to build relationships effectively"
msgstr "Как эффективно строить зависимости"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""
"Когда пользователи Godot начинают создавать собственные сцены, они часто "
"приходят к подобной проблеме:"

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"Они создают свою первую сцену и заполняют её содержимым, чтобы в конечном "
"итоге прийти к тому, чтобы сохранить ветки узлов в отдельные сцены, так как "
"начинает накапливаться мучительное чувство, что нужно разделить их. Однако "
"затем они замечают, что ссылок, по которым они могли обращаться к узлам, "
"больше нет. Использование одной и той же сцены в разных местах "
"проблематично, потому что пути узлов не находят своих целей, а сигналы, "
"установленные в редакторе, разрываются."

msgid ""
"To fix these problems, you must instantiate the sub-scenes without them "
"requiring details about their environment. You need to be able to trust that "
"the sub-scene will create itself without being picky about how it's used."
msgstr ""
"Чтобы исправить эти проблемы, необходимо создавать экземпляры под-сцены без "
"подробностей об их окружении. Нужно быть уверенным в том, что под-сцена "
"создаст сама себя, не придавая значения тому, как её будут использовать."

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"Одна из важнейших вещей, которую следует учитывать в ООП — это поддержка "
"целевых классов единственного назначения со `слабым зацеплением <https://"
"ru.wikipedia.org/wiki/"
"%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#%D0%A2%D0%B8%D0%BF%D1%8B_%D0%B7%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F>`_ "
"с другими частями кодовой базы. Это сохраняет размеры объектов небольшими "
"(для удобства поддержки) и улучшает их переиспользование."

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr ""
"Этот наилучшие практики ООП имеет *некоторую* причастность к наилучшему "
"практикам в структурировании сцены и использования скриптов."

msgid ""
"**If at all possible, you should design scenes to have no dependencies.** "
"That is, you should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**Если в целом это возможно, вам стоит создавать сцены так, чтобы они не "
"имели зависимостей.** То есть, вам стоит создавать сцены, которые содержат в "
"себе всё, что им нужно."

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"Если сцена должна взаимодействовать с внешним контекстом, то опытные "
"разработчики рекомендуют использовать `Внедрение Зависимости <https://"
"ru.wikipedia.org/wiki/"
"%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8>`_. "
"Эта техника включает в себя наличие высокоуровневого API, который "
"предоставит зависимости для низкоуровневого API. Почему так стоит делать? "
"Потому что классы, которые полагаются на внешнее окружение могут ненароком "
"вызвать баги и неожиданное поведение."

msgid ""
"To do this, you must expose data and then rely on a parent context to "
"initialize it:"
msgstr ""
"Для этого необходимо предоставить данные, а затем положиться на родительскую "
"связь чтобы все это инициализировать:"

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"Подключение к сигналу. Очень безопасно, но должно использоваться только для "
"\"реагирования\" на поведение, а не для его запуска. По традиции, именами "
"сигналов обычно служат глаголы прошедшего времени типа \"вошел\" (entered), "
"\"навык_активирован\" (skill_activated) или \"предмет_собран\" "
"(item_collected)."

msgid "Call a method. Used to start behavior."
msgstr "Вызов метода. Используется для запуска поведения."

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"Инициализация свойства :ref:`Callable <class_Callable>`. Безопаснее, чем "
"метод, так как нет необходимости владеть методом. Используется для запуска "
"поведения."

msgid "Initialize a Node or other Object reference."
msgstr "Инициализация ссылки на Node или другой Object."

msgid "Initialize a NodePath."
msgstr "Инициализация NodePath."

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. You can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"Эти опции прячут точки доступа от дочернего узла. Этот ход оставляет "
"дочерний элемент **слабо связанным** со своим окружением. Можно использовать "
"это в другом контексте без дополнительных изменений в его API."

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their own hierarchies while an ancestor mediates "
"their communications and references."
msgstr ""
"Хотя приведенные выше примеры иллюстрируют отношения родитель-ребенок, те же "
"принципы применимы ко всем объектным отношениям. Узлы, являющиеся соседними, "
"должны знать только о своих собственных иерархиях, в то время как предок "
"опосредует их коммуникации и ссылки."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object owns the other objects "
"should manage the relationships between them."
msgstr ""
"Те же принципы применимы и к не-узловым объектам, которые поддерживают "
"зависимости от других объектов. Какой бы объект ни владел другими объектами, "
"он должен управлять отношениями между ними."

msgid ""
"You should favor keeping data in-house (internal to a scene), though, as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation to use it safely is error-prone by default."
msgstr ""
"Однако вам следует отдать предпочтение хранению данных в доме (внутри "
"сцены), поскольку размещение зависимости от внешнего контекста, даже "
"слабосвязанного, все равно означает, что узел будет ожидать, что что-то в "
"его среде будет истинным. Философия дизайна проекта должна предотвратить "
"это. В противном случае неотъемлемые обязательства кода заставят "
"разработчиков использовать документацию для отслеживания объектных связей в "
"микроскопическом масштабе; это также известно как ад разработки. Написание "
"кода, который полагается на внешнюю документацию для его безопасного "
"использования, по умолчанию подвержено ошибкам."

msgid ""
"To avoid creating and maintaining such documentation, you convert the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no "
"child :ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The "
"editor then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""
"Чтобы избежать создания и поддержки такой документации, вы преобразуете "
"зависимый узел («дочерний» выше) в скрипт инструмента, который реализует "
"``_get_configuration_warnings()``. Возврат непустого PackedStringArray из "
"него заставит док сцены сгенерировать значок предупреждения со строкой(ами) "
"в качестве подсказки у узла. Это тот же значок, который отображается для "
"таких узлов, как узел :ref:`Area2D <class_Area2D>`, когда у него не "
"определены дочерние узлы :ref:`CollisionShape2D <class_CollisionShape2D>`. "
"Затем редактор самостоятельно документирует сцену через код скрипта. "
"Дублирование содержимого через документацию не требуется."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"Подобный графический интерфейс может лучше информировать пользователей "
"проекта о важной информации об узлах. Есть ли у него внешние зависимости? "
"Удовлетворены ли эти зависимости? Другим программистам, особенно дизайнерам "
"и писателям, потребуются чёткие инструкции в сообщениях, говорящие им, что "
"делать, чтобы настроить его."

msgid ""
"So, why does all this complex switcheroo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class, and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely affecting other classes dependent on it."
msgstr ""
"Итак, почему все эти сложные переключения работают? Ну, потому что сцены "
"работают лучше всего, когда они работают в одиночку. Если не могут работать "
"в одиночку, то работа с другими анонимно (с минимальными жесткими "
"зависимостями, т. е. слабой связанностью) — это следующий лучший вариант. "
"Неизбежно может потребоваться внести изменения в класс, и если эти изменения "
"заставят его взаимодействовать с другими сценами непредвиденным образом, то "
"все начнет ломаться. Весь смысл всей этой косвенности в том, чтобы избежать "
"ситуации, когда изменение одного класса приводит к неблагоприятному влиянию "
"на другие классы, зависящие от него."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"Скрипты и сцены, как расширения классов движков, должны соответствовать "
"*всем* принципам ООП. Примеры включают..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr ""
"`SOLID <https://ru.wikipedia.org/wiki/"
"SOLID_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://ru.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr ""
"`KISS <https://ru.wikipedia.org/wiki/"
"KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://ru.wikipedia.org/wiki/YAGNI>`_"

msgid "Choosing a node tree structure"
msgstr "Выбор структуры дерева узлов"

msgid ""
"You might start to work on a game but get overwhelmed by the vast "
"possibilities before you. You might know what you want to do, what systems "
"you want to have, but *where* do you put them all? How you go about making "
"your game is always up to you. You can construct node trees in countless "
"ways. If you are unsure, this guide can give you a sample of a decent "
"structure to start with."
msgstr ""
"Вы можете начать работать над игрой, но быть ошеломленными огромными "
"возможностями, которые перед вами открываются. Вы можете знать, что вы "
"хотите сделать, какие системы вы хотите иметь, но *где* вы все это "
"разместите? То, как вы будете делать свою игру, всегда зависит от вас. Вы "
"можете построить деревья узлов бесчисленным количеством способов. Если вы не "
"уверены, это руководство может дать вам пример приличной структуры для "
"начала."

msgid ""
"A game should always have an \"entry point\"; somewhere you can definitively "
"track where things begin so that you can follow the logic as it continues "
"elsewhere. It also serves as a bird's eye view of all other data and logic "
"in the program. For traditional applications, this is normally a \"main\" "
"function. In Godot, it's a Main node."
msgstr ""
"Игра всегда должна иметь «точку входа»; где-то вы можете определенно "
"отследить, где все начинается, чтобы вы могли проследить логику, поскольку "
"она продолжается в другом месте. Это также служит видом сверху на все "
"остальные данные и логику в программе. Для традиционных приложений это "
"обычно «главная» функция. В Godot это узел Main."

msgid "Node \"Main\" (main.gd)"
msgstr "Узел \"Main\" (main.gd)"

msgid ""
"The ``main.gd`` script will serve as the primary controller of your game."
msgstr "Скрипт ``main.gd`` будет служить основным контроллером вашей игры."

msgid ""
"Then you have an in-game \"World\" (a 2D or 3D one). This can be a child of "
"Main. In addition, you will need a primary GUI for your game that manages "
"the various menus and widgets the project needs."
msgstr ""
"Затем у вас есть внутриигровой \"World\" (2D или 3D). Он может быть потомком "
"Main. Кроме того, вам понадобится основной GUI для вашей игры, который "
"управляет различными меню и виджетами, необходимыми проекту."

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D \"Мир\" (game_world.gd)"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Управление \"GUI\" (gui.gd)"

msgid ""
"When changing levels, you can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives you "
"full control over how your game world transitions."
msgstr ""
"При смене уровней вы можете поменять местами дочерние элементы узла "
"«World». :ref:`Смена сцен вручную <doc_change_scenes_manually>` дает вам "
"полный контроль над тем, как меняется игровой мир."

msgid ""
"The next step is to consider what gameplay systems your project requires. If "
"you have a system that..."
msgstr ""
"Следующий шаг - обдумать, какие игровые системы требуются для вашего "
"проекта. Если есть система, которая...."

msgid "tracks all of its data internally"
msgstr "отслеживает все свои данные изнутри"

msgid "should be globally accessible"
msgstr "должна быть доступна глобально"

msgid "should exist in isolation"
msgstr "может существовать изолированно"

msgid ""
"... then you should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"... тогда вам следует создать вышеуказанный :ref:`autoload 'singleton' "
"<doc_singletons_autoload>`."

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method to swap out the main "
"scene's content. This structure more or less keeps the \"World\" as the main "
"game node."
msgstr ""
"Для небольших игр более простой альтернативой с меньшим контролем может быть "
"синглтон \"Game\", который просто вызывает "
"метод :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` для смены содержимого "
"основной сцены. Эта структура более или менее сохраняет \"World\" в качестве "
"основного игрового узла."

msgid ""
"Any GUI would also need to be either a singleton, a transitory part of the "
"\"World\", or manually added as a direct child of the root. Otherwise, the "
"GUI nodes would also delete themselves during scene transitions."
msgstr ""
"Любой GUI также должен быть либо синглтоном, временной частью \"World\", "
"либо вручную добавленным как прямой потомок корня. В противном случае узлы "
"GUI также будут удалять себя во время переходов между сценами."

msgid ""
"If you have systems that modify other systems' data, you should define those "
"as their own scripts or scenes, rather than autoloads. For more information, "
"see :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>`."
msgstr ""
"Если у вас есть системы, которые изменяют данные других систем, вы должны "
"определить их как собственные скрипты или сцены, а не как автозагрузки. Для "
"получения дополнительной информации см. :ref:`Автозагрузки и обычные узлы "
"<doc_autoloads_versus_internal_nodes>`."

msgid ""
"Each subsystem within your game should have its own section within the "
"SceneTree. You should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that the children should also be removed? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"Каждая подсистема в вашей игре должна иметь свой собственный раздел в "
"SceneTree. Вы должны использовать родительско-дочерние отношения только в "
"тех случаях, когда узлы фактически являются элементами своих родителей. "
"Означает ли удаление родителя, что дочерние элементы также должны быть "
"удалены? Если нет, то он должен иметь свое собственное место в иерархии как "
"родственный элемент или какое-то другое отношение."

msgid ""
"In some cases, you need these separated nodes to *also* position themselves "
"relative to each other. You can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"В некоторых случаях вам нужно, чтобы эти разделенные узлы *также* "
"позиционировали себя относительно друг друга. Для этой цели вы можете "
"использовать узлы :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`. Они позволят целевому узлу условно наследовать "
"выбранные элементы преобразования из узла Remote\\*. Чтобы назначить "
"``target`` :ref:`NodePath <class_NodePath>`, используйте одно из следующих:"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr ""
"Надёжная третья сторона, вероятно, родительский узел, для посредничества при "
"назначении."

msgid ""
"A group, to pull a reference to the desired node (assuming there will only "
"ever be one of the targets)."
msgstr ""
"Группа, для извлечения ссылки на нужный узел (предполагается, что будет "
"только одна из целей)."

msgid ""
"When you should do this is subjective. The dilemma arises when you must "
"micro-manage when a node must move around the SceneTree to preserve itself. "
"For example..."
msgstr ""
"Когда это делать — вопрос субъективный. Дилемма возникает, когда необходимо "
"микроуправлять, когда узел должен перемещаться по SceneTree, чтобы сохранить "
"себя. Например..."

msgid "Add a \"player\" node to a \"room\"."
msgstr "Добавьте узел \"player\" в \"room\"."

msgid "Need to change rooms, so you must delete the current room."
msgstr ""
"Необходимо сменить комнату, поэтому вам придется удалить текущую комнату."

msgid ""
"Before the room can be deleted, you must preserve and/or move the player."
msgstr ""
"Прежде чем удалить комнату, необходимо сохранить и/или переместить игрока."

msgid "If memory is not a concern, you can..."
msgstr "Если память не бескоит, вы можете..."

msgid "Create the new room."
msgstr "Создать новую комнату."

msgid "Move the player to the new room."
msgstr "Переместите игрока в новую комнату.."

msgid "Delete the old room."
msgstr "Удалить старую комнату."

msgid "If memory is a concern, instead you will need to..."
msgstr ""
"Если у вас проблемы с памятью (компьютерной, а не в вашей), вам нужно "
"будет..."

msgid "Move the player somewhere else in the tree."
msgstr "Переместите игрока в другое место в дереве."

msgid "Delete the room."
msgstr "Удалить комнату."

msgid "Instantiate and add the new room."
msgstr "Создать и добавить новую комнату."

msgid "Re-add the player to the new room."
msgstr "Повторно добавьте игрока в новую комнату."

msgid ""
"The issue is that the player here is a \"special case\" where the developers "
"must *know* that they need to handle the player this way for the project. "
"The only way to reliably share this information as a team is to *document* "
"it. Keeping implementation details in documentation is dangerous. It's a "
"maintenance burden, strains code readability, and unnecessarily bloats the "
"intellectual content of a project."
msgstr ""
"Проблема в том, что проигрыватель здесь — это «особый случай», когда "
"разработчики должны *знать*, что им нужно обращаться с проигрывателем таким "
"образом для проекта. Единственный способ надежно поделиться этой информацией "
"в команде — это *документировать* её. Хранить детали реализации в "
"документации опасно. Это обременительно для обслуживания, затрудняет "
"читаемость кода и неоправданно раздувает интеллектуальное содержание проекта."

msgid ""
"In a more complex game with larger assets, it can be a better idea to keep "
"the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"В более сложной игре с большими активами может быть лучшей идеей полностью "
"оставить игрока в другом месте SceneTree. Это приводит к:"

msgid "More consistency."
msgstr "Большей согласованности."

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr ""
"Отсутствию \"особых случаев\", которые нужно где-то документировать и "
"поддерживать."

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr ""
"Отсутствию возможности допустить ошибку, так как эти детали не учитываются."

msgid ""
"In contrast, if you ever need a child node that does *not* inherit the "
"transform of its parent, you have the following options:"
msgstr ""
"Напротив, если вам когда-нибудь понадобится дочерний узел, который *не* "
"наследует преобразование своего родителя, у вас есть следующие варианты:"

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. Since it doesn't have a transform, they won't pass this information to "
"its children."
msgstr ""
"**Declarative (Декларативное)** решение: поместить :ref:`Node <class_Node>` "
"между ними. Поскольку у него нет преобразования, они не будут передавать эту "
"информацию своим потомкам."

msgid ""
"The **imperative** solution: Use the ``top_level`` property for "
"the :ref:`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**Императивное** решение: Используйте свойство ``top_level`` для "
"узла :ref:`CanvasItem <class_CanvasItem_property_top_level>` "
"или :ref:`Node3D <class_Node3D_property_top_level>`. Это заставит узел "
"игнорировать унаследованную трансформацию."

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic - they only need their own. Keeping them in a "
"separate branch from the \"world\" can help simplify the management of game "
"connections and the like."
msgstr ""
"При создании сетевой игры помните, какие узлы и игровые системы актуальны "
"для всех игроков, а какие — только для авторитетного сервера. Например, не "
"всем пользователям нужна копия логики \"PlayerController\" каждого игрока — "
"им нужна только их собственная. Размещение их в отдельной ветке от \"мира\" "
"может помочь упростить управление игровыми соединениями и т. п."

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"Ключ к организации сцены - рассматривать дерево сцены в терминах отношений, "
"а не в пространственных терминах. Зависимы ли узлы от существования их "
"родителей? Если нет, то они могут развиваться сами по себе где-нибудь ещё. "
"Если они зависимы, то логично предположить, что они должны быть потомками "
"этого родителя (и, вероятно, частью сцены родителя, если они ещё не являются "
"таковыми)."

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"you still have the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"Означает ли это, что узлы сами по себе являются компонентами? Вовсе нет. "
"Деревья узлов Godot образуют отношение агрегации, а не композиции. Но хотя у "
"вас все еще есть гибкость для перемещения узлов, все равно лучше, когда "
"такие перемещения, по умолчанию, не нужны."
