#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "Организация сцены"

msgid "How to build relationships effectively"
msgstr "Как эффективно строить зависимости"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""
"Когда пользователи Godot начинают создавать собственные сцены, они часто "
"приходят к подобной проблеме:"

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"Они создают свою первую сцену и заполняют её содержимым, чтобы в конечном "
"итоге прийти к тому, чтобы сохранить ветки узлов в отдельные сцены, так как "
"начинает накапливаться мучительное чувство, что нужно разделить их. Однако "
"затем они замечают, что ссылок, по которым они могли обращаться к узлам, "
"больше нет. Использование одной и той же сцены в разных местах "
"проблематично, потому что пути узлов не находят своих целей, а сигналы, "
"установленные в редакторе, разрываются."

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"Одна из важнейших вещей, которую следует учитывать в ООП — это поддержка "
"целевых классов единственного назначения со `слабым зацеплением <https://ru."
"wikipedia.org/wiki/"
"%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#%D0%A2%D0%B8%D0%BF%D1%8B_%D0%B7%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F>`_ "
"с другими частями кодовой базы. Это сохраняет размеры объектов небольшими "
"(для удобства поддержки) и улучшает их переиспользование."

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr ""
"Этот наилучшие практики ООП имеет *некоторую* причастность к наилучшему "
"практикам в структурировании сцены и использования скриптов."

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"Если сцена должна взаимодействовать с внешним контекстом, то опытные "
"разработчики рекомендуют использовать `Внедрение Зависимости <https://ru."
"wikipedia.org/wiki/"
"%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8>`_. "
"Эта техника включает в себя наличие высокоуровневого API, который "
"предоставит зависимости для низкоуровневого API. Почему так стоит делать? "
"Потому что классы, которые полагаются на внешнее окружение могут ненароком "
"вызвать баги и неожиданное поведение."

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"Подключение к сигналу. Очень безопасно, но должно использоваться только для "
"\"реагирования\" на поведение, а не для его запуска. По традиции, именами "
"сигналов обычно служат глаголы прошедшего времени типа \"вошел\" (entered), "
"\"навык_активирован\" (skill_activated) или \"предмет_собран\" "
"(item_collected)."

msgid "Call a method. Used to start behavior."
msgstr "Вызов метода. Используется для запуска поведения."

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"Инициализация свойства :ref:`Callable <class_Callable>`. Безопаснее, чем "
"метод, так как нет необходимости владеть методом. Используется для запуска "
"поведения."

msgid "Initialize a Node or other Object reference."
msgstr "Инициализация ссылки на Node или другой Object."

msgid "Initialize a NodePath."
msgstr "Инициализация NodePath."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"Подобный графический интерфейс может лучше информировать пользователей "
"проекта о важной информации об узлах. Есть ли у него внешние зависимости? "
"Удовлетворены ли эти зависимости? Другим программистам, особенно дизайнерам "
"и писателям, потребуются чёткие инструкции в сообщениях, говорящие им, что "
"делать, чтобы настроить его."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"Скрипты и сцены, как расширения классов движков, должны соответствовать "
"*всем* принципам ООП. Примеры включают..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr ""
"`SOLID <https://ru.wikipedia.org/wiki/"
"SOLID_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://ru.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr ""
"`KISS <https://ru.wikipedia.org/wiki/"
"KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://ru.wikipedia.org/wiki/YAGNI>`_"

msgid "Choosing a node tree structure"
msgstr "Выбор структуры дерева нод"

msgid "Node \"Main\" (main.gd)"
msgstr "Узел \"Main\" (main.gd)"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D \"Мир\" (game_world.gd)"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Управление \"GUI\" (gui.gd)"

msgid "tracks all of its data internally"
msgstr "отслеживает все свои данные изнутри"

msgid "should be globally accessible"
msgstr "должна быть доступна глобально"

msgid "should exist in isolation"
msgstr "может существовать изолированно"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"to swap out the main scene's content. This structure more or less keeps the "
"\"World\" as the main game node."
msgstr ""
"Для небольших игр более простой альтернативой с меньшим контролем может быть "
"синглтон \"Game\", который просто вызывает метод :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` для "
"смены содержимого основной сцены. Эта структура более или менее сохраняет "
"\"World\" в качестве основного игрового узла."

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr ""
"Надёжная третья сторона, вероятно, родительский узел, для посредничества при "
"назначении."

msgid "Add a \"player\" node to a \"room\"."
msgstr "Добавьте узел \"player\" в \"room\"."

msgid "Move the player somewhere else in the tree."
msgstr "Переместите игрока в другое место в дереве."

msgid "Delete the room."
msgstr "Удалить комнату."

msgid "Instantiate and add the new room."
msgstr "Создать и добавить новую комнату."

msgid "More consistency."
msgstr "Большей согласованности."

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr ""
"Отсутствию \"особых случаев\", которые нужно где-то документировать и "
"поддерживать."

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr ""
"Отсутствию возможности допустить ошибку, так как эти детали не учитываются."

msgid ""
"The **imperative** solution: Use the ``top_level`` property for the :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**Императивное** решение: Используйте свойство ``top_level`` для узла :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` или :ref:`Node3D "
"<class_Node3D_property_top_level>`. Это заставит узел игнорировать "
"унаследованную трансформацию."

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"Ключ к организации сцены - рассматривать дерево сцены в терминах отношений, "
"а не в пространственных терминах. Зависимы ли узлы от существования их "
"родителей? Если нет, то они могут развиваться сами по себе где-нибудь ещё. "
"Если они зависимы, то логично предположить, что они должны быть потомками "
"этого родителя (и, вероятно, частью сцены родителя, если они ещё не являются "
"таковыми)."
