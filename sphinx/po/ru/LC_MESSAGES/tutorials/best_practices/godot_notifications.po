#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot notifications"
msgstr "Уведомления Godot"

msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"Некоторые из этих уведомлений, например рисование (draw), полезно "
"переопределить в скриптах. Настолько, что Godot предоставляет многим из них "
"специальные функции:"

msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone, for example:"
msgstr ""
"Что пользователи могут *не* осознавать, так это то, что уведомления "
"существуют и для других типов, например, не только для Node:"

msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""
":ref:`Объект::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: обратный вызов, "
"который срабатывает при инициализации объекта. Не доступно для скриптов."

msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a \"destructor\"."
msgstr ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: обратный вызов, который "
"срабатывает до того, как движок удалит Object, т.е. 'деструктор'."

msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""
"И многие обратные вызовы, которые *действительно* существуют в Nodes "
"(узлах), не имеют специальных методов, но по-прежнему весьма полезны."

msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: обратный вызов, который "
"срабатывает при добавлении дочернего узла к другому узлу."

msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: обратный вызов, который "
"срабатывает в любой момент, когда удаляется дочерний узел из другого узла."

msgid ""
"One can access all these custom notifications from the universal "
"``_notification()`` method."
msgstr ""
"Доступ ко всем этим пользовательским уведомлениям можно получить из "
"универсального метода ``_notification()``."

msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr ""
"Методы в документации, помеченные как \"виртуальные\" (virtual), также "
"должны быть переопределены скриптами."

msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr ""
"Так в какой же ситуации следует использовать каждое из этих уведомлений или "
"виртуальные функции?"

msgid "_process vs. _physics_process vs. \\*_input"
msgstr "\"_process\" против \"_physics_process\" против \"\\*_input\""

msgid ""
"Use ``_process()`` when one needs a framerate-dependent delta time between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-timeout loop is another option."
msgstr ""
"Используйте ``_process()``, когда требуется зависимая от фрейма дельта "
"времени между кадрами. Если код, обновляющий данные объекта, должен "
"обновляться как можно чаще, то это самое подходящее место. Здесь часто "
"выполняются повторяющиеся логические проверки и кэширование данных, но все "
"сводится к тому, с какой частотой нужно обновлять оценки. Если они не должны "
"выполняться каждый кадр, то другим вариантом является реализация цикла Timer-"
"timeout."

msgid ""
"Use ``_physics_process()`` when one needs a framerate-independent delta time "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"Используйте ``_physics_process()``, когда требуется независимое от кадра "
"время дельты между кадрами. Если коду требуется последовательное обновление "
"данных во времени, независимо от того, насколько быстро или медленно "
"движется время, то это самое подходящее место. Повторяющиеся кинематические "
"операции и операции преобразования объектов должны выполняться здесь."

msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process()`` and "
"``_physics_process()`` will trigger at every opportunity (they do not "
"\"rest\" by default). In contrast, ``*_input()`` callbacks will trigger only "
"on frames in which the engine has actually detected the input."
msgstr ""
"Хотя это и возможно, для достижения наилучшей производительности следует "
"избегать проверки ввода во время этих обратных вызовов. ``_process()`` и "
"``_physics_process()`` будут срабатывать при каждой возможности (по "
"умолчанию они не \"отдыхают\"). Обратные вызовы ``*_input()``, напротив, "
"будут срабатывать только на кадрах, в которых движок действительно обнаружил "
"вход."

msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related delta time "
"methods as needed."
msgstr ""
"Аналогично можно проверять действия по вводу в рамках обратных вызовов "
"ввода. Если необходимо использовать дельта-время, то при необходимости его "
"можно получить из соответствующих методов дельта-времени."

msgid "_init vs. initialization vs. export"
msgstr "*_init* против *initialization* против *export*"

msgid "The C# equivalent to GDScript's ``_init()`` method is the constructor."
msgstr "Конструктор в C#, является эквивалентом метода GDScript ``_init()``."

msgid ""
"**``_init()`` assignment:** the property's value is replaced by any "
"assignments made in ``_init()``, triggering the setter."
msgstr ""
"**``_init()`` назначение:** значение свойства заменяется любыми "
"назначениями, сделанными в ``_init()``, вызывая сеттер."

msgid ""
"**Exported value assignment:** an exported property's value is again "
"replaced by any value set in the Inspector, triggering the setter."
msgstr ""
"**Присвоение экспортируемого значения:** значение экспортируемого свойства "
"снова заменяется любым значением, установленным в инспекторе, вызывая сеттер."

msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr "*_ready* против *_enter_tree* против *NOTIFICATION_PARENTED*"

msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init()`` calls) and build the "
"tree going downwards from the root. This causes ``_enter_tree()`` calls to "
"cascade down the tree. Once the tree is complete, leaf nodes call "
"``_ready``. A node will call this method once all child nodes have finished "
"calling theirs. This then causes a reverse cascade going up back to the "
"tree's root."
msgstr ""
"При создании экземпляра сцены, связанной с первой выполненной сценой, Godot "
"будет создавать экземпляры узлов вниз по дереву (выполняя вызовы ``_init``) "
"и строить дерево, идущее вниз от корня. Это вызывает каскадирование вызовов "
"``_enter_tree`` по дереву. Когда дерево готово, листовые узлы вызывают "
"``_ready``. Узел вызовет этот метод, как только все дочерние узлы закончат "
"свои вызовы. Затем это вызывает обратный каскад, возвращающийся к корню "
"дерева."

msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"Если нужно инициировать поведение, которое возникает в качестве родительских "
"узлов для другого, независимо от того, происходит ли оно как часть "
"основной / активной сцены или нет, можно использовать уведомление :ref:"
"`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>`. Например, вот "
"фрагмент, который без сбоев соединяет метод узла с настраиваемым сигналом на "
"родительском узле. Полезно для узлов, ориентированных на данные, которые "
"можно создать во время выполнения."

msgid "Translation status"
msgstr "Статус перевода"
