#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDExtension C example"
msgstr "Пример GDExtension на C"

msgid "Introduction"
msgstr "Введение"

msgid ""
"This is a simple example on how to work with GDExtension directly with C "
"code. Note that the API is not meant to be used directly, so this will "
"definitely be quite verbose and require a lot of steps even for a small "
"example. However, it serves as a reference for creating bindings for a "
"different language. It is still possible to use the API directly if you "
"prefer, which might be convenient when only binding a third-party library."
msgstr ""
"Это простой пример работы с GDExtension напрямую на языке C. Обратите "
"внимание, что API не предназначен для прямого использования, поэтому даже "
"для небольшого примера потребуется много шагов. Однако он служит "
"справочником для создания привязок для другого языка. По-прежнему возможно "
"использовать API напрямую, что может быть удобно при привязке сторонней "
"библиотеки."

msgid ""
"In this example we will create a custom node that moves a sprite on the "
"screen based on the user's parameters. While very simple, it serves to show "
"how to do some of the things with GDExtension, like registering custom "
"classes with methods, properties, and signals. It gives an insight on the "
"GDExtension API."
msgstr ""
"В этом примере мы создадим пользовательский узел, который перемещает спрайт "
"по экрану на основе параметров пользователя. Хотя он очень прост, он служит "
"для демонстрации некоторых возможностей GDExtension, таких как регистрация "
"пользовательских классов с методами, свойствами и сигналами. Это даёт "
"представление об API GDExtension."

msgid "Setting up the project"
msgstr "Настройка проекта"

msgid "There are a few prerequisites you'll need:"
msgstr "Вам необходимо выполнить несколько условий:"

msgid "a Godot 4.2 (or later) executable,"
msgstr "исполняемый файл Godot 4.2 (или новее),"

msgid "a C compiler,"
msgstr "компилятор C,"

msgid "SCons as a build tool."
msgstr "SCons в качестве инструмента сборки."

msgid ""
"Since this is using the API directly, there's no need to use the `godot-cpp "
"repository <https://github.com/godotengine/godot-cpp>`__."
msgstr ""
"Поскольку здесь используется API напрямую, нет необходимости использовать "
"репозиторий `godot-cpp <https://github.com/godotengine/godot-cpp>`__."

msgid "File structure"
msgstr "Структура файла"

msgid "To organize our files, we're gonna split into mainly two folders:"
msgstr "Для организации файлов мы разделим их на две основные папки:"

msgid ""
"We also need a copy of the ``gdextension_interface.h`` header from the Godot "
"source code, which can be obtained directly from the Godot executable by "
"running the following command:"
msgstr ""
"Нам также понадобится копия заголовочного файла ``gdextension_interface.h`` "
"из исходного кода Godot, который можно получить напрямую из исполняемого "
"файла Godot, выполнив команду:"

msgid ""
"This creates the header in the current folder, so you can just copy it to "
"the ``src`` folder in the example project."
msgstr ""
"Это создаст заголовочный файл в текущей папке, поэтому вы можете просто "
"скопировать его в папку ``src`` в проекте примера."

msgid ""
"Lastly, there's another source of information we need to refer to, which is "
"the JSON file with the Godot API reference. This file won't be used by the "
"code directly, we will only use it to extract some information manually."
msgstr ""
"Наконец, есть ещё один источник информации, к которому нам нужно обращаться "
"- JSON-файл со справочником API Godot. Этот файл не будет использоваться "
"кодом напрямую, мы будем использовать его только для ручного извлечения "
"некоторой информации."

msgid "To get this JSON file, just call the Godot executable:"
msgstr "Чтобы получить этот JSON-файл, просто вызовите исполняемый файл Godot:"

msgid ""
"The resulting ``extension_api.json`` file will be created in the current "
"folder. You can copy this file to the example folder to have it handy."
msgstr ""
"Результирующий файл ``extension_api.json`` будет создан в текущей папке. Вы "
"можете скопировать этот файл в папку примера для удобства."

msgid ""
"This extension is targeting Godot 4.2, but it should work on later versions "
"as well. If you want to target a different minimal version, make sure to get "
"the header and the JSON from the version Godot version you are targeting."
msgstr ""
"Это расширение предназначено для Godot 4.2, но должно работать и в более "
"поздних версиях. Если вы хотите поддерживать другую минимальную версию, "
"убедитесь, что получили заголовочный файл и JSON из версии Godot, которую вы "
"используете."

msgid "Buildsystem"
msgstr "Система сборки"

msgid ""
"Using a buildsystem makes our life a lot easier when dealing with C code. "
"For the sake of convenience, we'll use SCons since it's the same as what "
"Godot itself uses."
msgstr ""
"Использование системы сборки значительно упрощает работу с кодом на C. Для "
"удобства мы будем использовать SCons, так как он используется самим Godot."

msgid ""
"The following ``SConstruct`` file is a simple one that will build your "
"extension to the current platform that you are using, be it Linux, macOS, or "
"Windows. This will be a non-optimized build for debugging purposes. It also "
"assumes a 64-bit build, which is relevant for some parts of the example "
"code. Making other build types and cross-compilation is out of the scope of "
"this tutorial. Save this file to the root folder."
msgstr ""
"Следующий файл ``SConstruct`` - это простой файл, который соберёт ваше "
"расширение для текущей платформы, будь то Linux, macOS или Windows. Это "
"будет неоптимизированная сборка для целей отладки. Он также предполагает 64-"
"битную сборку, что важно для некоторых частей примера кода. Создание других "
"типов сборок и кросс-компиляция выходят за рамки данного руководства. "
"Сохраните этот файл в корневую папку."

msgid ""
"This will include all C files in the ``src`` folder, so we don't need to "
"change this file when adding new source files."
msgstr ""
"Это включит все C-файлы в папке ``src``, поэтому нам не нужно изменять этот "
"файл при добавлении новых исходных файлов."

msgid "Initializing the extension"
msgstr "Инициализация расширения"

msgid ""
"The first bit of code will be responsible for initializing the extension. "
"This is what makes Godot aware of what our GDExtension provides, such as "
"classes and plugins."
msgstr ""
"Первый фрагмент кода будет отвечать за инициализацию расширения. Это то, что "
"позволяет Godot узнать, что предоставляет наше GDExtension, например классы "
"и плагины."

msgid ""
"Create the file ``init.h`` in the ``src`` folder, with the following "
"contents:"
msgstr "Создайте файл ``init.h`` в папке ``src`` со следующим содержимым:"

msgid ""
"The functions declared here have the signatures expected by the GDExtension "
"API."
msgstr "Объявленные здесь функции имеют сигнатуры, ожидаемые API GDExtension."

msgid ""
"Note the inclusion of the ``defs.h`` file. This is one of our helpers to "
"simplify writing the extension code. For now it will only contain the "
"definition of ``GDE_EXPORT``, a macro that makes the function public in the "
"shared library so Godot can properly call it. This macro helps abstracting "
"what each compiler expects."
msgstr ""
"Обратите внимание на включение файла ``defs.h``. Это один из наших "
"вспомогательных файлов для упрощения написания кода расширения. Пока он "
"будет содержать только определение ``GDE_EXPORT`` - макроса, который делает "
"функцию публичной в общей библиотеке, чтобы Godot мог её правильно вызывать. "
"Этот макрос помогает абстрагировать требования разных компиляторов."

msgid ""
"Create the ``defs.h`` file in the ``src`` folder with the following contents:"
msgstr "Создайте файл ``defs.h`` в папке ``src`` со следующим содержимым:"

msgid ""
"We also include some standard headers to make things easier. Now we only "
"have to include ``defs.h`` and those will come as a bonus."
msgstr ""
"Мы также включаем некоторые стандартные заголовки для упрощения работы. "
"Теперь нам достаточно включить ``defs.h``, и они придут как бонус."

msgid ""
"Now, let's implement the functions we just declared. Create a file called "
"``init.c`` in the ``src`` folder and add this code:"
msgstr ""
"Теперь реализуем объявленные функции. Создайте файл ``init.c`` в папке "
"``src`` и добавьте следующий код:"

msgid ""
"What this does is set up the initialization data that Godot expects. The "
"functions to initialize and deinitialize are set so Godot will call then "
"when needed. It also sets the initialization level which varies per "
"extension. Since we plan to add a custom node, the ``SCENE`` level is enough."
msgstr ""
"Это настраивает данные инициализации, которые ожидает Godot. Функции "
"инициализации и деинициализации установлены, чтобы Godot вызывал их при "
"необходимости. Также устанавливается уровень инициализации, который "
"варьируется в зависимости от расширения. Поскольку мы планируем добавить "
"пользовательский узел, уровня ``SCENE`` достаточно."

msgid ""
"We will fill the ``initialize_gdexample_module()`` function later to "
"register our custom class."
msgstr ""
"Позже мы заполним функцию ``initialize_gdexample_module()`` для регистрации "
"нашего пользовательского класса."

msgid "A basic class"
msgstr "Базовый класс"

msgid ""
"In order to make an actual node, first we'll create a C struct to hold data "
"and functions that will act as methods. The plan is to make this a custom "
"node that inherits from :ref:`Sprite2D <class_Sprite2D>`."
msgstr ""
"Чтобы создать реальный узел, сначала мы создадим структуру на C для хранения "
"данных и функций, которые будут действовать как методы. Планируется сделать "
"это пользовательским узлом, наследующим от :ref:`Sprite2D <class_Sprite2D>`."

msgid ""
"Create a file called ``gdexample.h`` in the ``src`` folder with the "
"following contents:"
msgstr "Создайте файл ``gdexample.h`` в папке ``src`` со следующим содержимым:"

msgid ""
"Noteworthy here is the ``object`` field, which holds a pointer to the Godot "
"object, and the ``gdexample_class_bind_methods()`` function, which will "
"register the metadata of our custom class (properties, methods, and "
"signals). The latter is not entirely necessary, as we can do it when "
"registering the class, but it makes clearer to separate the concerns and let "
"our class register its own metadata."
msgstr ""
"Примечательны здесь поле ``object``, которое содержит указатель на объект "
"Godot, и функция ``gdexample_class_bind_methods()``, которая зарегистрирует "
"метаданные нашего пользовательского класса (свойства, методы и сигналы). "
"Последнее не совсем необходимо, так как мы можем сделать это при регистрации "
"класса, но это делает разделение ответственности более чётким и позволяет "
"нашему классу регистрировать свои собственные метаданные."

msgid ""
"The ``object`` field is necessary because our class will inherit a Godot "
"class. Since we can't inherit it directly, as we are not interacting with "
"the source code (and C doesn't even have classes), we instead tell Godot to "
"create an object of a type it knows and attach our extension to it. We will "
"need the reference to such objects when calling methods on the parent class, "
"for instance."
msgstr ""
"Поле ``object`` необходимо, потому что наш класс будет наследовать класс "
"Godot. Поскольку мы не можем наследовать его напрямую (мы не взаимодействуем "
"с исходным кодом, и в C даже нет классов), мы вместо этого говорим Godot "
"создать объект известного ему типа и прикрепить наше расширение к нему. Нам "
"понадобится ссылка на такие объекты, например, при вызове методов "
"родительского класса."

msgid ""
"Let's create the source counterpart of this header. Create the file "
"``gdexample.c`` in the ``src`` folder and add the following code to it:"
msgstr ""
"Создадим исходный файл для этого заголовка. Создайте файл ``gdexample.c`` в "
"папке ``src`` и добавьте в него следующий код:"

msgid ""
"As we don't have anything to do with those functions yet, they'll stay empty "
"for a while."
msgstr ""
"Поскольку нам пока нечего делать с этими функциями, они останутся пустыми на "
"некоторое время."

msgid ""
"The next step is registering our class. However, in order to do so we need "
"to create a :ref:`StringName <class_StringName>` and for that we have to get "
"a function from the GDExtension API. Since we'll need this a few times and "
"we'll also need other things, let's create a wrapper API to facilitate this "
"kind of chore."
msgstr ""
"Следующий шаг - регистрация нашего класса. Однако для этого нам нужно "
"создать :ref:`StringName <class_StringName>`, а для этого нужно получить "
"функцию из API GDExtension. Поскольку нам это понадобится несколько раз, и "
"нам также понадобятся другие вещи, давайте создадим обёртку API для "
"облегчения этой рутины."

msgid "A wrapper API"
msgstr "Обёртка API"

msgid "We'll start by creating an ``api.h`` file in the ``src`` folder:"
msgstr "Начнём с создания файла ``api.h`` в папке ``src``:"

msgid ""
"This file will include many other helpers as we fill our extension with "
"something useful. For now it only has a pointer to a function that creates a "
"StringName from a C string (in Latin-1 encoding) and another to destruct a "
"StringName, which we'll need to use to avoid leaking memory, as well as the "
"function to register a class, which is our initial goal."
msgstr ""
"Этот файл будет включать множество других вспомогательных функций по мере "
"наполнения нашего расширения полезным содержимым. Пока в нём есть только "
"указатель на функцию, создающую StringName из C-строки (в кодировке "
"Latin-1), и другая для уничтожения StringName, которые нам понадобятся, "
"чтобы избежать утечек памяти, а также функция регистрации класса, что "
"является нашей первоначальной целью."

msgid ""
"We also keep a reference to the ``class_library`` here. This is something "
"that Godot provides to us when initializing the extension and we'll need to "
"use it when registering the things we create so Godot can tell which "
"extension is making the call."
msgstr ""
"Мы также сохраняем здесь ссылку на ``class_library``. Это то, что Godot "
"предоставляет нам при инициализации расширения, и нам нужно будет "
"использовать это при регистрации создаваемых объектов, чтобы Godot мог "
"определить, какое расширение делает вызов."

msgid ""
"There's also a function to load those function pointers from the GDExtension "
"API."
msgstr ""
"Также есть функция для загрузки этих указателей функций из API GDExtension."

msgid ""
"Let's work on the source counterpart of this header. Create the ``api.c`` "
"file in the ``src`` folder, adding the following code:"
msgstr ""
"Давайте поработаем над исходным файлом для этого заголовка. Создайте файл "
"``api.c`` в папке ``src``, добавив следующий код:"

msgid ""
"The first important thing here is ``p_get_proc_address``. This a function "
"from the GDExtension API that is passed during initialization. You can use "
"this function to request specific functions from the API by their name. Here "
"we are caching the results so we don't have to keep a reference for "
"``p_get_proc_address`` everywhere and use our wrapper instead."
msgstr ""
"Первая важная вещь здесь - ``p_get_proc_address``. Это функция из API "
"GDExtension, которая передаётся во время инициализации. Вы можете "
"использовать эту функцию для запроса конкретных функций API по их имени. "
"Здесь мы кэшируем результаты, чтобы не хранить ссылку на "
"``p_get_proc_address`` повсюду и вместо этого использовать нашу обёртку."

msgid ""
"At the start we request the ``variant_get_ptr_destructor()`` function. This "
"is not going to be used outside of this function, so we don't add to our "
"wrapper and only cache it locally. The cast is necessary to silence compiler "
"warnings."
msgstr ""
"В начале мы запрашиваем функцию ``variant_get_ptr_destructor()``. Она не "
"будет использоваться вне этой функции, поэтому мы не добавляем её в нашу "
"обёртку, а только кэшируем локально. Приведение типа необходимо для "
"подавления предупреждений компилятора."

msgid ""
"Then we get the function that creates a StringName from a C string, exactly "
"what we mentioned before as a needed function. We store that in our "
"``constructors`` struct."
msgstr ""
"Затем мы получаем функцию, создающую StringName из C-строки, именно то, что "
"мы упоминали ранее как необходимую функцию. Мы сохраняем её в нашей "
"структуре ``constructors``."

msgid ""
"Next, we use the ``variant_get_ptr_destructor()`` function we just got to "
"query for the destructor for StringName, using the enum value from "
"``gdextension_interface.h`` API as a parameter. We could get destructors for "
"other types in a similar manner, but we'll limit ourselves to what is needed "
"for the example."
msgstr ""
"Далее мы используем только что полученную функцию "
"``variant_get_ptr_destructor()`` для запроса деструктора StringName, "
"используя значение перечисления из API ``gdextension_interface.h`` в "
"качестве параметра. Мы могли бы получить деструкторы для других типов "
"аналогичным образом, но ограничимся тем, что необходимо для примера."

msgid ""
"Lastly, we get the ``classdb_register_extension_class2()`` function, which "
"we'll need in order to register our custom class."
msgstr ""
"Наконец, мы получаем функцию ``classdb_register_extension_class2()``, "
"которая понадобится нам для регистрации нашего пользовательского класса."

msgid ""
"You may wonder why the ``2`` is there in the function name. This means it's "
"the second version of this function. The old version is kept to ensure "
"backwards compatibility with older extensions, but since we have the second "
"version available, it's best to use the new one, because we don't intend to "
"support older Godot versions in this example."
msgstr ""
"Вам может быть интересно, почему в имени функции есть ``2``. Это означает, "
"что это вторая версия этой функции. Старая версия сохраняется для "
"обеспечения обратной совместимости со старыми расширениями, но поскольку у "
"нас доступна вторая версия, лучше использовать новую, так как в этом примере "
"мы не планируем поддерживать старые версии Godot."

msgid ""
"The ``gdextension_interface.h`` header documents in which Godot version each "
"function was introduced."
msgstr ""
"Заголовочный файл ``gdextension_interface.h`` документирует, в какой версии "
"Godot была введена каждая функция."

msgid ""
"We also define the ``class_library`` variable here, which will be set during "
"initialization."
msgstr ""
"Мы также определяем здесь переменную ``class_library``, которая будет "
"установлена во время инициализации."

msgid ""
"Speaking of initialization, now we have to change the ``init.c`` file in "
"order to fill the things we just added:"
msgstr ""
"Говоря об инициализации, теперь нам нужно изменить файл ``init.c``, чтобы "
"заполнить то, что мы только что добавили:"

msgid ""
"Here we set the ``class_library`` as needed and call our new ``load_api()`` "
"function. Don't forget to also include the new headers at the top of this "
"file:"
msgstr ""
"Здесь мы устанавливаем ``class_library`` по мере необходимости и вызываем "
"нашу новую функцию ``load_api()``. Не забудьте также включить новые "
"заголовки в верхней части этого файла:"

msgid ""
"Since we are here, we can register our new custom class. Let's fill the "
"``initialize_gdexample_module()`` function:"
msgstr ""
"Раз уж мы здесь, мы можем зарегистрировать наш новый пользовательский класс. "
"Давайте заполним функцию ``initialize_gdexample_module()``:"

msgid ""
"The struct with the class information is the biggest thing here. None of its "
"fields are required with the exception of ``create_instance_func`` and "
"``free_instance_func``. We haven't made those functions yet, so we'll have "
"to work on them soon. Note that we skip the initialization if it isn't at "
"the ``SCENE`` level. This function may be called multiple times, once for "
"each level, but we only want to register our class once."
msgstr ""
"Структура с информацией о классе — это самое важное здесь. Ни одно из её "
"полей не является обязательным, за исключением ``create_instance_func`` и "
"``free_instance_func``. Мы ещё не создали эти функции, поэтому скоро "
"займёмся ими. Обратите внимание, что мы пропускаем инициализацию, если она "
"не находится на уровне ``SCENE``. Эта функция может вызываться несколько "
"раз, по одному разу на каждый уровень, но нам нужно зарегистрировать класс "
"только один раз."

msgid ""
"The other undefined thing here is ``StringName``. This will be an opaque "
"struct meant to hold the data of a Godot StringName in our extension. We'll "
"define it in the appropriately named ``defs.h`` file:"
msgstr ""
"Ещё один неопределённый параметр — ``StringName``. Это будет непрозрачная "
"структура, предназначенная для хранения данных Godot StringName в нашем "
"расширении. Мы определим её в файле ``defs.h`` с соответствующим именем:"

msgid ""
"As mentioned in the comment, the sizes can be found in the "
"``extension_api.json`` file that we generated earlier, under the "
"``builtin_class_sizes`` property. The ``BUILD_32`` is never defined, as we "
"assume we are working with a 64-bits build of Godot here, but if you need it "
"you can add ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` to your ``SConstruct`` "
"file."
msgstr ""
"Как уже упоминалось в комментарии, размеры можно найти в файле "
"``extension_api.json``, который мы сгенерировали ранее, в свойстве "
"``builtin_class_sizes``. Значение ``BUILD_32`` не определено, поскольку мы "
"предполагаем, что работаем с 64-битной сборкой Godot, но при необходимости "
"вы можете добавить ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` в файл "
"``SConstruct``."

msgid ""
"The ``// Types.`` comment foreshadows that we'll be adding more types to "
"this file. Let's leave that for later."
msgstr ""
"Комментарий ``// Types.`` предвещает, что мы будем добавлять в этот файл "
"новые типы. Оставим это на потом."

msgid ""
"The ``StringName`` struct here is just to hold Godot data, so we don't "
"really care what is inside of it. Though, in this case, it is just a pointer "
"to the data in the heap. We'll use this struct when we need to allocate data "
"for a StringName ourselves, like we are doing when registering our class."
msgstr ""
"Структура ``StringName`` здесь предназначена только для хранения данных "
"Godot, поэтому нам не важно, что именно находится внутри. Хотя в данном "
"случае это просто указатель на данные в куче. Мы будем использовать эту "
"структуру, когда нам понадобится самостоятельно выделить данные для "
"StringName, например, при регистрации нашего класса."

msgid ""
"Back to registering, we need to work on our create and free functions. Let's "
"include them in ``gdexample.h`` since they're specific to the custom class:"
msgstr ""
"Возвращаясь к регистрации, нам нужно поработать над функциями create и free. "
"Включим их в ``gdexample.h``, поскольку они относятся к пользовательскому "
"классу:"

msgid ""
"Before we can implement those function, we'll need a few more things in our "
"API. We need a way to allocate and free memory. While we could do this with "
"good ol' ``malloc()``, we can instead make use of Godot's memory management "
"functions. We'll also need a way to create a Godot object and set it with "
"our custom instance."
msgstr ""
"Прежде чем мы сможем реализовать эти функции, нам потребуется ещё кое-что в "
"нашем API. Нам нужен способ выделять и освобождать память. Хотя это можно "
"было бы сделать с помощью старого доброго ``malloc()``, вместо этого можно "
"использовать функции управления памятью Godot. Нам также понадобится способ "
"создать объект Godot и назначить его нашему экземпляру."

msgid "So let's change the ``api.h`` to include these new functions:"
msgstr "Давайте изменим ``api.h``, чтобы включить эти новые функции:"

msgid ""
"Then we change the ``load_api()`` function in ``api.c`` to grab these new "
"functions:"
msgstr ""
"Затем мы изменяем функцию ``load_api()`` в ``api.c``, чтобы она включала эти "
"новые функции:"

msgid ""
"Now we can go back to ``gdexample.c`` and define the new functions, without "
"forgetting to include the ``api.h`` header:"
msgstr ""
"Теперь мы можем вернуться к ``gdexample.c`` и определить новые функции, не "
"забыв включить заголовок ``api.h``:"

msgid ""
"When instantiating an object, first we create a new Sprite2D object, since "
"that's the parent of our class. Then we allocate memory for our custom "
"struct and call its constructor. We save the pointer to the Godot object in "
"the struct as well like we mentioned earlier."
msgstr ""
"При создании экземпляра объекта, сначала мы создаём новый объект Sprite2D, "
"поскольку он является родительским для нашего класса. Затем мы выделяем "
"память для нашей пользовательской структуры и вызываем её конструктор. Мы "
"также сохраняем указатель на объект Godot в структуре, как уже упоминалось "
"ранее."

msgid ""
"Then we set our custom struct as the instance data. This will make Godot "
"know that the object is an instance of our custom class and properly call "
"our custom methods for instance, as well as passing this data back."
msgstr ""
"Затем мы устанавливаем нашу пользовательскую структуру в качестве данных "
"экземпляра. Это позволит Godot определить, что объект является экземпляром "
"нашего пользовательского класса, и, например, корректно вызывать наши "
"пользовательские методы, а также передавать эти данные обратно."

msgid "Note that we return the Godot object we created, not our custom struct."
msgstr ""
"Обратите внимание, что мы возвращаем созданный нами объект Godot, а не нашу "
"пользовательскую структуру."

msgid ""
"For the ``gdextension_free_instance()`` function, we only call the "
"destructor and free the memory we allocated for the custom data. It is not "
"necessary to destruct the Godot object since that will be taken care of by "
"the engine itself."
msgstr ""
"Для функции ``gdextension_free_instance()`` мы только вызываем деструктор и "
"освобождаем память, выделенную для пользовательских данных. Уничтожать "
"объект Godot не обязательно, так как об этом позаботится сам движок."

msgid "A demo project"
msgstr "Демо-проект"

msgid ""
"Now that we can create and free our custom object, we should be able to try "
"it out in an actual project. For this, you need to open Godot and create a "
"new project on the ``demo`` folder. The project manager may warn you the "
"folder isn't empty if you have compiled the extension before, you can safely "
"ignore this warning this time."
msgstr ""
"Теперь, когда мы можем создать и освободить наш пользовательский объект, мы "
"можем опробовать его в реальном проекте. Для этого нужно открыть Godot и "
"создать новый проект в папке ``demo``. Менеджер проектов может предупредить "
"вас, что папка не пуста, если вы уже компилировали расширение. На этот раз "
"вы можете спокойно проигнорировать это предупреждение."

msgid ""
"If you didn't compile the extension yet, it is the time to do it now. To do "
"that, open a terminal or command prompt, navigate to the root folder of the "
"extension and run ``scons``. It should compile quickly since the extension "
"is very simple."
msgstr ""
"Если вы ещё не скомпилировали расширение, самое время сделать это сейчас. "
"Для этого откройте терминал или командную строку, перейдите в корневую папку "
"расширения и выполните команду ``scons``. Компиляция должна пройти быстро, "
"поскольку расширение очень простое."

msgid ""
"Then, create a file called ``gdexample.gdextension`` inside the ``demo`` "
"folder. This is a Godot resource that describes the extension, allowing the "
"engine to properly load it. Put the following content in this file:"
msgstr ""
"Затем создайте файл ``gdexample.gdextension`` в папке ``demo``. Это ресурс "
"Godot, описывающий расширение, что позволяет движку корректно его загрузить. "
"Поместите в этот файл следующее содержимое:"

msgid ""
"As you can see, ``gdexample_library_init()`` is the same name of the "
"function we defined in our ``init.c`` file. It is important that the names "
"match because it is how Godot calls the entry point of the extension."
msgstr ""
"Как видите, ``gdexample_library_init()`` — это то же имя, что и у функции, "
"которую мы определили в файле ``init.c``. Важно, чтобы имена совпадали, "
"поскольку Godot называет точку входа расширения именно так."

msgid ""
"We also set the compatibility minimum to 4.2, since we are targeting this "
"version. It should still work on later versions. If you are using a later "
"Godot version and rely on the new features, you need to increase this value "
"to a version number that has everything you use. "
"See :ref:`doc_what_is_gdextension_version_compatibility` for more "
"information."
msgstr ""
"Мы также устанавливаем минимальный уровень совместимости 4.2, поскольку "
"ориентируемся на эту версию. Он должен работать и в более поздних версиях. "
"Если вы используете более позднюю версию Godot и рассчитываете на новые "
"функции, вам необходимо увеличить это значение до номера версии, в которой "
"есть всё необходимое. Подробнее см. в "
"документе :ref:`doc_what_is_gdextension_version_compatibility`."

msgid ""
"In the ``[libraries]`` section we set up the paths to the shared library on "
"different platforms. Here there's only the debug versions since that's what "
"we are working on for the example. Using :ref:`feature tags "
"<doc_feature_tags>` you can fine tune this to also provide release versions, "
"add more target operating systems, as well as providing 32-bit and 64-bit "
"binaries."
msgstr ""
"В разделе ``[libraries]`` мы настраиваем пути к общей библиотеке на разных "
"платформах. Здесь представлены только отладочные версии, поскольку именно с "
"ними мы работаем в этом примере. Используя :ref:`feature tags "
"<doc_feature_tags>`, вы можете настроить их так, чтобы они также "
"предоставляли версии для релиза, добавляли больше целевых операционных "
"систем, а также 32- и 64-битные исполняемые файлы."

msgid ""
"You can also add library dependencies and custom icons for your classes in "
"this file, but this is out of the scope for this tutorial."
msgstr ""
"Вы также можете добавить зависимости библиотеки и пользовательские значки "
"для своих классов в этот файл, но это выходит за рамки данного руководства."

msgid ""
"After saving the file, go back to the editor. Godot should automatically "
"load the extension. Nothing will be seen because our extension only "
"registers a new class. To use this class add a ``Node2D`` as a root of the "
"scene. Move it to the middle of viewport for better visibility. Then add a "
"new child node to the root and in the **Create New Node** dialog search for "
"\"GDExample\", the name of our class, as it should be listed there. If it "
"isn't, it means that Godot didn't load the extension properly, so try "
"restarting the editor and retrace the steps to see if anything went missing."
msgstr ""
"После сохранения файла вернитесь в редактор. Godot должен автоматически "
"загрузить расширение. Ничего не будет видно, поскольку наше расширение "
"регистрирует только новый класс. Чтобы использовать этот класс, добавьте "
"``Node2D`` в качестве корневого узла сцены. Переместите его в центр области "
"просмотра для лучшей видимости. Затем добавьте новый дочерний узел в "
"корневой узел и в диалоговом окне **Create New Node** найдите \"GDExample\", "
"имя нашего класса, так как оно должно быть там указано. Если это не так, это "
"означает, что Godot не загрузил расширение должным образом. Попробуйте "
"перезапустить редактор и повторите шаги, чтобы проверить, не упустили ли вы "
"что-нибудь."

msgid ""
"Our custom class is derived from ``Sprite2D``, so it has a **Texture** "
"property in the Inspector. Set this to the ``icon.svg`` file that Godot "
"handily created for us when making the project. Save this scene as "
"``main.tscn`` and run it. You may want to set it as the main scene for "
"convenience."
msgstr ""
"Наш пользовательский класс наследуется от ``Sprite2D``, поэтому у него есть "
"свойство **Texture** в инспекторе. Укажите в нём файл ``icon.svg``, который "
"Godot любезно создал для нас при создании проекта. Сохраните эту сцену как "
"``main.tscn`` и запустите её. Для удобства можно сделать её основной сценой."

msgid ""
"Voilà! We have a custom node running in Godot. However, it does not do "
"anything and has nothing different than a regular ``Sprite2D`` node. We will "
"fix that next by adding custom methods and properties."
msgstr ""
"Вуаля! У нас есть пользовательский узел, работающий в Godot. Однако он "
"ничего не делает и ничем не отличается от обычного узла ``Sprite2D``. Сейчас "
"мы исправим это, добавив пользовательские методы и свойства."

msgid "Custom methods"
msgstr "Пользовательские методы"

msgid ""
"A common thing in extensions is creating methods for the custom classes and "
"exposing those to the Godot API. We are going to create a couple of getters "
"and setters which are need for binding the properties afterwards."
msgstr ""
"В расширениях часто используется создание методов для пользовательских "
"классов и предоставление их API Godot. Мы создадим несколько геттеров и "
"сеттеров, которые понадобятся для последующего связывания свойств."

msgid ""
"First, let's add the new fields in our struct to hold the values for "
"``amplitude`` and ``speed``, which we will use later on when creating the "
"behavior for the node. Add them to the ``gdexample.h`` file, changing the "
"``GDExample`` struct:"
msgstr ""
"Сначала добавим в нашу структуру новые поля для хранения значений "
"``amplitude`` и ``speed``, которые мы будем использовать позже при создании "
"поведения узла. Добавьте их в файл ``gdexample.h``, изменив структуру "
"``GDExample``:"

msgid ""
"In the same file, add the declaration for the getters and setters, right "
"after the destructor."
msgstr ""
"В том же файле, добавьте объявление для getters и setters, сразу после "
"destructor."

msgid ""
"In the ``gdexample.c`` file, we will initialize these values in the "
"constructor and add the implementations for those new functions, which are "
"quite trivial:"
msgstr ""
"В файле ``gdexample.c`` мы инициализируем эти значения в конструкторе и "
"добавим реализации для этих новых функций, которые довольно тривиальны:"

msgid ""
"To make those simple functions work when called by Godot, we will need some "
"wrappers to help us properly convert the data to and from the engine."
msgstr ""
"Чтобы эти простые функции работали при вызове Godot, нам понадобятся "
"некоторые оболочки, которые помогут нам правильно преобразовывать данные в "
"движок и из него."

msgid ""
"First, we will create wrappers for ``ptrcall``. This is what Godot uses when "
"the types of the values are known to be exact, which avoids using Variant. "
"We're gonna need two of those: one for the functions that take no arguments "
"and return a ``double`` (for the getters) and another for the functions that "
"take a single ``double`` argument and return nothing (for the setters)."
msgstr ""
"Сначала мы создадим обёртки для ``ptrcall``. Godot использует их, когда типы "
"значений известны как точные, что позволяет избежать использования Variant. "
"Нам понадобятся две обёртки: одна для функций без аргументов, возвращающих "
"``double`` (для геттеров), и другая для функций, принимающих один аргумент "
"``double`` и ничего не возвращающих (для сеттеров)."

msgid "Add the declarations to the ``api.h`` file:"
msgstr "Добавьте объявления в файл ``api.h``:"

msgid ""
"Those two functions follow the ``GDExtensionClassMethodPtrCall`` type, as "
"defined in the ``gdextension_interface.h``. We use ``float`` as a name here "
"because in Godot the ``float`` type has double precision, so we keep this "
"convention."
msgstr ""
"Эти две функции соответствуют типу ``GDExtensionClassMethodPtrCall``, как "
"определено в ``gdextension_interface.h``. Мы используем здесь имя ``float``, "
"поскольку в Godot тип ``float`` имеет двойную точность, поэтому мы "
"придерживаемся этого соглашения."

msgid "Then we implement those functions in the ``api.c`` file:"
msgstr "Затем мы реализуем эти функции в файле ``api.c``:"

msgid ""
"The ``method_userdata`` argument is a custom value that we give to Godot, in "
"this case we will set as the function pointer for the one we want to call. "
"So first we convert it to the function type, then we just call it by passing "
"the arguments when needed, or setting the return value."
msgstr ""
"Аргумент ``method_userdata`` — это пользовательское значение, которое мы "
"передаем Godot. В данном случае мы установим его как указатель на функцию, "
"которую хотим вызвать. Поэтому сначала мы преобразуем его в тип функции, а "
"затем просто вызываем её, передавая аргументы при необходимости или "
"устанавливая возвращаемое значение."

msgid ""
"The ``p_instance`` argument contains the custom instance of our class, which "
"we gave with ``object_set_instance()`` when creating the object."
msgstr ""
"Аргумент ``p_instance`` содержит пользовательский экземпляр нашего класса, "
"который мы указали с помощью ``object_set_instance()`` при создании объекта."

msgid ""
"``p_args`` is an array of arguments. Note this contains **pointers** to the "
"values. That's why we dereference it when passing to our functions. The "
"number of arguments will be declared when binding the function (which we "
"will do soon) and it will always include default ones if those exist."
msgstr ""
"``p_args`` — это массив аргументов. Обратите внимание, что он содержит "
"**указатели** на значения. Именно поэтому мы разыменовываем его при передаче "
"в наши функции. Количество аргументов будет объявлено при связывании функции "
"(что мы сделаем вскоре), и она всегда будет включать аргументы по умолчанию, "
"если таковые имеются."

msgid ""
"Finally, the ``r_ret`` is a pointer to the variable where the return value "
"needs to be set. Like the arguments, it will be the correct type as "
"declared. For the function that does not return, we have to avoid setting it."
msgstr ""
"Наконец, ``r_ret`` — это указатель на переменную, для которой необходимо "
"установить возвращаемое значение. Как и аргументы, тип будет соответствовать "
"объявленному. Для функции, которая не возвращает значение, следует избегать "
"его установки."

msgid ""
"Note how the type and argument counts are exact, so if we needed different "
"types, for example, we would have to create more wrappers. This could be "
"automated using some code generation, but this is out of the scope for this "
"tutorial."
msgstr ""
"Обратите внимание, что типы и количество аргументов указаны точно, поэтому, "
"например, если бы нам понадобились другие типы, нам пришлось бы создать "
"больше обёрток. Это можно автоматизировать с помощью генерации кода, но это "
"выходит за рамки данного руководства."

msgid ""
"While the ``ptrcall`` functions are used when types are exact, sometimes "
"Godot cannot know if that's the case (when the call comes from a dynamically "
"typed language, such as GDScript). In those situations it uses regular "
"``call`` functions, so we need to provide those as well when binding."
msgstr ""
"Хотя функции ``ptrcall`` используются, когда типы точны, иногда Godot не "
"может определить это (когда вызов поступает из языка с динамической "
"типизацией, например, GDScript). В таких ситуациях используются обычные "
"функции ``call``, поэтому при связывании необходимо указать и их."

msgid "Let's create two new wrappers in the ``api.h`` file:"
msgstr "Давайте создадим две новые оболочки в файле ``api.h``:"

msgid ""
"These follow the ``GDExtensionClassMethodCall`` type, which is a bit "
"different. First, you receive pointers to Variants instead of exact types. "
"There's also the amount of arguments and an error struct that you can set if "
"something goes wrong."
msgstr ""
"Они следуют типу ``GDExtensionClassMethodCall``, который немного отличается. "
"Во-первых, вы получаете указатели на варианты вместо конкретных типов. Также "
"есть количество аргументов и структура ошибки, которую можно установить, "
"если что-то пойдёт не так."

msgid ""
"In order to check the type and also extract interact with Variant, we will "
"need a few more functions from the GDExtension API. So let's expand our "
"wrapper structs:"
msgstr ""
"Чтобы проверить тип и извлечь взаимодействие с Variant, нам понадобится ещё "
"несколько функций из API GDExtension. Итак, давайте расширим наши структуры-"
"обёртки:"

msgid ""
"The names say all about what those do. We have a couple of constructors to "
"create and extract a floating point value to and from a Variant. We also "
"have a couple of helpers to actually get those constructors, as well as a "
"function to find out the type of a Variant."
msgstr ""
"Названия говорят сами за себя. У нас есть пара конструкторов для создания и "
"извлечения значения с плавающей точкой из типа Variant. Также у нас есть "
"пара вспомогательных функций для получения этих конструкторов, а также "
"функция для определения типа Variant."

msgid ""
"Let's get those from the API, like we did before, by changing the "
"``load_api()`` function in the ``api.c`` file:"
msgstr ""
"Давайте получим их из API, как мы делали раньше, изменив функцию "
"``load_api()`` в файле ``api.c``:"

msgid ""
"Now that we have these set, we can implement our call wrappers in the same "
"file:"
msgstr ""
"Теперь, когда у нас есть этот набор, мы можем реализовать наши оболочки "
"вызовов в том же файле:"

msgid ""
"These functions are a bit longer but easy to follow. First they check if the "
"argument count is as expected and if not they set the error struct and "
"return. For the one that has one parameter, it also checks if the argument "
"type is correct. This is important because mismatched types when extracting "
"from Variant can cause crashes."
msgstr ""
"Эти функции немного длиннее, но просты в использовании. Сначала они "
"проверяют, соответствует ли количество аргументов ожидаемому, и если нет, "
"устанавливают структуру ошибки и возвращают управление. Функция с одним "
"параметром также проверяет корректность типа аргумента. Это важно, поскольку "
"несоответствие типов при извлечении из Variant может привести к сбоям."

msgid ""
"Then it proceeds to extract the argument using the constructor we setup "
"before. The one with no arguments instead sets the return value after "
"calling the function. Note how they use a pointer to a ``double`` variable, "
"since this is what those constructors expect."
msgstr ""
"Затем он извлекает аргумент с помощью конструктора, который мы создали "
"ранее. Конструктор без аргументов вместо этого устанавливает возвращаемое "
"значение после вызова функции. Обратите внимание, что используется указатель "
"на переменную ``double``, поскольку именно этого и ожидают эти конструкторы."

msgid ""
"Before we can actually bind our methods, we need a way to create "
"``GDExtensionPropertyInfo`` instances. While we could do them inside the "
"binding functions that we'll implement afterwards, it's easier to have a "
"helper for it since we'll need it multiple times, including for when we bind "
"properties."
msgstr ""
"Прежде чем мы сможем привязать наши методы, нам нужен способ создания "
"экземпляров ``GDExtensionPropertyInfo``. Хотя мы могли бы делать это внутри "
"функций привязки, которые реализуем позже, проще использовать "
"вспомогательный метод, поскольку он понадобится нам несколько раз, в том "
"числе при привязке свойств."

msgid "Let's create these two functions in the ``api.h`` file:"
msgstr "Давайте создадим эти две функции в файле ``api.h``:"

msgid ""
"The first one is a simplified version of the second since we usually don't "
"need all the arguments for the property and are okay with the defaults. Then "
"we also have a function to destruct the PropertyInfo since we need to create "
"Strings and StringNames that need to be properly disposed of."
msgstr ""
"Первый вариант — это упрощённая версия второго, поскольку обычно нам не "
"нужны все аргументы для свойства, и нас устраивают значения по умолчанию. "
"Кроме того, у нас есть функция для уничтожения PropertyInfo, поскольку нам "
"нужно создать строки и имена строк, которые нужно правильно удалить."

msgid ""
"Speaking of which, we also need a way to create and destruct Strings, so "
"we'll make an addition to existing structs in this same file. We'll also get "
"a new API function for actually binding our custom method."
msgstr ""
"Кстати, нам также нужен способ создания и уничтожения строк, поэтому мы "
"добавим новые структуры в этот же файл. Кроме того, мы получим новую API-"
"функцию для привязки нашего метода."

msgid ""
"Before implementing those, let's do a quick stop in the ``defs.h`` file and "
"include the size of the ``String`` type and a couple of enums:"
msgstr ""
"Прежде чем реализовать это, давайте сделаем быструю остановку в файле "
"``defs.h`` и включим размер типа ``String`` и несколько перечислений:"

msgid ""
"While it's the same size as ``StringName``, it is more clear to use a "
"different name for it."
msgstr ""
"Хотя он имеет тот же размер, что и ``StringName``, для него понятнее "
"использовать другое имя."

msgid ""
"The enums here are just helpers to give names to the numbers they represent. "
"The information about them is present in the ``extension_api.json`` file. "
"Here we just set up the ones we need for the tutorial, to keep it more "
"concise."
msgstr ""
"Перечисления здесь — всего лишь вспомогательные элементы для наименования "
"представляемых ими чисел. Информация о них содержится в файле "
"``extension_api.json``. Здесь мы просто настраиваем те, которые нужны для "
"руководства, чтобы сделать его более лаконичным."

msgid ""
"Going now to the ``api.c``, we need to load the pointers to the new "
"functions we added to the API."
msgstr ""
"Теперь перейдем к ``api.c`` и нам нужно загрузить указатели на новые "
"функции, которые мы добавили в API."

msgid ""
"Then we can also implement the functions to create the ``PropertyInfo`` "
"struct."
msgstr ""
"Затем мы также можем реализовать функции для создания структуры "
"``PropertyInfo``."

msgid ""
"The simple version of ``make_property()`` just calls the more complete one "
"with a some default arguments. What those values mean exactly is out of the "
"scope of this tutorial, check the page about the :ref:`Object class "
"<doc_object_class>` for more details about binding methods and properties."
msgstr ""
"Простая версия ``make_property()`` просто вызывает более полную версию с "
"некоторыми аргументами по умолчанию. Точное значение этих значений выходит "
"за рамки данного руководства. Подробнее о методах и свойствах привязки см. "
"на странице :ref:`Object class <doc_object_class>`."

msgid ""
"The complete version is more involved. First, it creates ``String``'s and "
"``StringName``'s for the needed fields, by allocating memory and calling "
"their constructors. Then it creates a ``GDExtensionPropertyInfo`` struct and "
"sets all the fields with the arguments provided. Finally it returns this "
"created struct."
msgstr ""
"Полная версия сложнее. Сначала она создаёт ``String`` и ``StringName`` для "
"необходимых полей, выделяя память и вызывая их конструкторы. Затем создаёт "
"структуру ``GDExtensionPropertyInfo`` и задаёт все поля с помощью "
"предоставленных аргументов. Наконец, функция возвращает созданную структуру."

msgid ""
"The ``destruct_property()`` function is straightforward, it simply calls the "
"destructors for the created objects and frees their allocated memory."
msgstr ""
"Функция ``destruct_property()`` проста, она просто вызывает деструкторы для "
"созданных объектов и освобождает выделенную им память."

msgid ""
"Let's go back again to the header ``api.h`` to create the functions that "
"will actually bind the methods:"
msgstr ""
"Давайте снова вернемся к заголовочному файлу ``api.h``, чтобы создать "
"функции, которые фактически свяжут методы:"

msgid "Then switch back to the ``api.c`` file to implement these:"
msgstr "Затем вернитесь к файлу ``api.c``, чтобы реализовать следующее:"

msgid ""
"Both functions are very similar. First, they create a ``StringName`` with "
"the method name. This is created in the stack since we don't need to keep it "
"after the function ends. Then they create local variables to hold the "
"``call_func`` and ``ptrcall_func``, pointing to the helper functions we "
"defined earlier."
msgstr ""
"Обе функции очень похожи. Сначала они создают ``StringName`` с именем "
"метода. Он создаётся в стеке, так как нам не нужно его сохранять после "
"завершения функции. Затем они создают локальные переменные для хранения "
"``call_func`` и ``ptrcall_func``, указывающие на вспомогательные функции, "
"которые мы определили ранее."

msgid ""
"In the next step they diverge a bit. The first one creates a property for "
"the return value, which has an empty name since it's not needed. The other "
"creates an array of properties for the arguments, which in this case has a "
"single element. This one also has an array of metadata, which can be used if "
"there's something special about the argument (e.g. if an ``int`` value is 32 "
"bits long instead of the default of 64 bits)."
msgstr ""
"На следующем этапе они немного расходятся. Первый создаёт свойство для "
"возвращаемого значения с пустым именем, поскольку оно не требуется. Второй "
"создаёт массив свойств для аргументов, который в данном случае состоит из "
"одного элемента. Этот же создаёт массив метаданных, который можно "
"использовать, если аргумент обладает какими-то особыми свойствами (например, "
"если значение ``int`` имеет длину 32 бита вместо 64 бит по умолчанию)."

msgid ""
"Afterwards, they create the ``GDExtensionClassMethodInfo`` with the required "
"fields for each case. Then they make a ``StringName`` for the class name, in "
"order to associate the method with the class. Next, they call the API "
"function to actually bind this method to the class. Finally, we destruct the "
"objects we created since they aren't needed anymore."
msgstr ""
"После этого они создают ``GDExtensionClassMethodInfo`` с обязательными "
"полями для каждого случая. Затем они создают ``StringName`` для имени "
"класса, чтобы связать метод с этим классом. Затем они вызывают функцию API, "
"чтобы фактически привязать этот метод к классу. Наконец, мы уничтожаем "
"созданные нами объекты, поскольку они больше не нужны."

msgid ""
"The bind helpers here use the call helpers we created earlier, so do note "
"that those call helpers only accept the Godot ``FLOAT`` type (which is "
"equivalent to ``double`` in C). If you intend to use this for other types, "
"you would need to check the type of the arguments and return type and select "
"an appropriate function callback. This is avoided here only to keep the "
"example from becoming even longer."
msgstr ""
"Вспомогательные функции связывания здесь используют созданные нами ранее "
"вспомогательные функции вызова, поэтому обратите внимание, что эти "
"вспомогательные функции вызова принимают только тип Godot ``FLOAT`` "
"(эквивалент ``double`` в C). Если вы собираетесь использовать это для других "
"типов, вам потребуется проверить тип аргументов и возвращаемого типа, а "
"также выбрать подходящую функцию обратного вызова. Здесь это сделано только "
"для того, чтобы пример не стал ещё длиннее."

msgid ""
"Now that we have the means to bind methods, we can actually do so in our "
"custom class. Go to the ``gdexample.c`` file and fill up the "
"``gdexample_class_bind_methods()`` function:"
msgstr ""
"Теперь, когда у нас есть возможность привязывать методы, мы можем сделать "
"это в нашем классе. Перейдите в файл ``gdexample.c`` и заполните функцию "
"``gdexample_class_bind_methods()``:"

msgid ""
"Since this function is already being called by the initialization process, "
"we can stop here. This function is much more straightforward after we "
"created all the infrastructure to make this work. You can see that "
"implementing the binding functions inline here would take some space and "
"also be quite repetitive. This also makes it easier to add another method in "
"the future."
msgstr ""
"Поскольку эта функция уже вызывается процессом инициализации, мы можем "
"остановиться на этом. После создания всей необходимой инфраструктуры эта "
"функция стала гораздо проще. Видно, что реализация функций привязки в коде "
"заняла бы много места и была бы довольно повторяющейся. Это также упростит "
"добавление других методов в будущем."

msgid ""
"If you compile the code and reopen the demo project, nothing will be "
"different at first, since we only added two new methods. To ensure those are "
"registered properly, you can search for ``GDExample`` in the editor help and "
"verify they are present in the documentation page."
msgstr ""
"Если вы скомпилируете код и снова откроете демонстрационный проект, поначалу "
"ничего не изменится, поскольку мы добавили всего два новых метода. Чтобы "
"убедиться, что они зарегистрированы правильно, найдите ``GDExample`` в "
"справке редактора и проверьте их наличие на странице документации."

msgid "Custom properties"
msgstr "Пользовательские свойства"

msgid ""
"Since we now have the getter and setter for our properties already bound, we "
"can move forward to create actual properties that will be displayed in the "
"Godot editor inspector."
msgstr ""
"Поскольку теперь у нас уже есть геттер и сеттер для наших свойств, мы можем "
"перейти к созданию реальных свойств, которые будут отображаться в инспекторе "
"редактора Godot."

msgid ""
"Given our extensive setup in the previous section, there are only a few "
"things needed to enable us to bind properties. First, let's get a new API "
"function in the ``api.h`` file:"
msgstr ""
"Учитывая нашу обширную настройку, описанную в предыдущем разделе, для "
"привязки свойств нам потребуется лишь несколько действий. Для начала добавим "
"новую API-функцию в файл ``api.h``:"

msgid "Let's also declare a function here to bind properties:"
msgstr "Давайте также объявим здесь функцию для привязки свойств:"

msgid "In the ``api.c`` file, we can load the new API function:"
msgstr "В файле ``api.c`` мы можем загрузить новую функцию API:"

msgid "Then we can implement our new helper function in this same file:"
msgstr ""
"Затем мы можем реализовать нашу новую вспомогательную функцию в этом же "
"файле:"

msgid ""
"This function is similar to the one for binding methods. The main difference "
"is that we don't need an extra struct since we can simply use the "
"``GDExtensionPropertyInfo`` that is created by our helper function, so it's "
"more straightforward. It only creates the ``StringName`` values from the C "
"strings, creates a property info struct using our helper, calls the API "
"function to register the property in the class and then destructs all the "
"objects we created."
msgstr ""
"Эта функция похожа на функцию для привязки методов. Главное отличие "
"заключается в том, что нам не нужна дополнительная структура, поскольку мы "
"можем просто использовать ``GDExtensionPropertyInfo``, созданную нашей "
"вспомогательной функцией, что делает её более простой. Она лишь создаёт "
"значения ``StringName`` из строк C, создаёт структуру информации о свойстве "
"с помощью нашей вспомогательной функции, вызывает функцию API для "
"регистрации свойства в классе, а затем уничтожает все созданные нами объекты."

msgid ""
"With this done, we can extend the ``gdexample_class_bind_methods()`` "
"function in the ``gdexample.c`` file:"
msgstr ""
"После этого мы можем расширить функцию ``gdexample_class_bind_methods()`` в "
"файле ``gdexample.c``:"

msgid ""
"If you build the extension with ``scons``, you'll see in the Godot editor "
"the new property shown not only on the documentation page for the custom "
"class but also in the Inspector dock when the ``GDExample`` node is selected."
msgstr ""
"Если вы построите расширение с помощью ``scons``, то в редакторе Godot вы "
"увидите новое свойство, отображаемое не только на странице документации для "
"пользовательского класса, но и в доке Инспектора при выборе узла "
"``GDExample``."

msgid "Binding virtual methods"
msgstr "Привязка виртуальных методов"

msgid ""
"Our custom node now has properties to influence how it operates, but it "
"still doesn't do anything. In this section, we will bind the virtual "
"method :ref:`_process() <class_Node_private_method__process>` and make our "
"custom sprite move a little bit."
msgstr ""
"Теперь у нашего пользовательского узла есть свойства, влияющие на его "
"работу, но он по-прежнему ничего не делает. В этом разделе мы привяжем "
"виртуальный метод :ref:`_process() <class_Node_private_method__process>` и "
"заставим наш пользовательский спрайт немного двигаться."

msgid ""
"In the ``gdexample.h`` file, let's add a function that represents the custom "
"``_process()`` method:"
msgstr ""
"В файле ``gdexample.h`` добавим функцию, представляющую пользовательский "
"метод ``_process()``:"

msgid ""
"We'll also add a \"private\" field to keep track of the time passed in our "
"custom struct. This is \"private\" only in the sense that it won't be bound "
"to the Godot API, even though it is public in the C side, given the language "
"lacks access modifiers."
msgstr ""
"Мы также добавим \"частное\" поле для отслеживания прошедшего времени в "
"нашей пользовательской структуре. Оно \"приватное\" только в том смысле, что "
"не будет привязано к API Godot, хотя и является публичным в C-версии, "
"поскольку в этом языке отсутствуют модификаторы доступа."

msgid ""
"On the counterpart source file ``gdexample.c`` we need to initialize the new "
"field in the constructor:"
msgstr ""
"В исходном файле ``gdexample.c`` нам необходимо инициализировать новое поле "
"в конструкторе:"

msgid ""
"Then we can create the simplest implementation for the ``_process`` method:"
msgstr "Затем мы можем создать простейшую реализацию метода ``_process``:"

msgid ""
"For now it will do nothing but update the private field we created. We'll "
"come back to this after the method is properly bound."
msgstr ""
"Пока что он будет только обновлять созданное нами приватное поле. Мы "
"вернёмся к этому после того, как метод будет правильно привязан."

msgid ""
"Virtual methods are a bit different from the regular bindings. Instead of "
"explicitly registering the method itself, we'll register a special function "
"that Godot will call to ask if a particular virtual method is implemented in "
"our extension. The engine will pass a ``StringName`` as an argument so, "
"following the spirit of this tutorial, we'll create a helper function to "
"check if it is equal to a C string."
msgstr ""
"Виртуальные методы немного отличаются от обычных привязок. Вместо того, "
"чтобы явно регистрировать сам метод, мы зарегистрируем специальную функцию, "
"которую Godot будет вызывать, чтобы проверить, реализован ли конкретный "
"виртуальный метод в нашем расширении. Движок передаст ``StringName`` в "
"качестве аргумента, поэтому, следуя духу этого руководства, мы создадим "
"вспомогательную функцию для проверки его эквивалентности строке C."

msgid "Let's add the declaration to the ``api.h`` file:"
msgstr "Давайте добавим объявление в файл ``api.h``:"

msgid ""
"We'll also add a new struct to this file, to hold function pointers for "
"custom operators:"
msgstr ""
"Мы также добавим в этот файл новую структуру для хранения указателей функций "
"для пользовательских операторов:"

msgid ""
"Then in the ``api.c`` file we'll load the function pointer from the API:"
msgstr "Затем в файле ``api.c`` мы загрузим указатель функции из API:"

msgid ""
"As you can see we need a new local helper here in order to grab the function "
"pointer for the operator."
msgstr ""
"Как вы можете видеть, нам здесь нужен новый локальный помощник, чтобы "
"получить указатель функции для оператора."

msgid ""
"With this handy, we can easily create our comparison function in the same "
"file:"
msgstr ""
"Используя эту удобную возможность, мы можем легко создать нашу функцию "
"сравнения в том же файле:"

msgid ""
"This function creates a ``StringName`` from the argument, compares with the "
"other one using the operator function pointer, and returns the result. Note "
"that the return value for the operator is passed as an out reference, this "
"is a common thing in the API."
msgstr ""
"Эта функция создаёт ``StringName`` из аргумента, сравнивает его с другим "
"значением, используя указатель на функцию оператора, и возвращает результат. "
"Обратите внимание, что возвращаемое значение оператора передаётся как ссылка "
"out, что является распространённой практикой в API."

msgid ""
"Let's go back to the ``gdexample.h`` file and add a couple of functions that "
"will be used as the callbacks for the Godot API:"
msgstr ""
"Давайте вернемся к файлу ``gdexample.h`` и добавим пару функций, которые "
"будут использоваться в качестве обратных вызовов для API Godot:"

msgid ""
"There are actually two ways of registering virtual methods. Only one has the "
"``get`` part, in which you give Godot a properly crafted function pointer "
"which will be called. For this we would need to create another helper for "
"each virtual method, something that is not very convenient. Instead, we use "
"the second method which allows us to return any data, and then Godot will "
"call a second callback and give us back this data along with the call "
"information. We can simply give our own function pointer as custom data and "
"then have a single callback for all virtual methods. Although in this "
"example we will only use it for one method, this way is simpler to expand."
msgstr ""
"На самом деле существует два способа регистрации виртуальных методов. Только "
"один из них содержит часть ``get``, в которой вы передаёте Godot правильно "
"сформированный указатель на функцию, которая будет вызвана. Для этого нам "
"пришлось бы создавать отдельный вспомогательный метод для каждого "
"виртуального метода, что не очень удобно. Вместо этого мы используем второй "
"метод, который позволяет нам возвращать любые данные, а затем Godot вызывает "
"второй обратный вызов и возвращает нам эти данные вместе с информацией о "
"вызове. Мы можем просто передать собственный указатель на функцию в качестве "
"пользовательских данных и создать единый обратный вызов для всех виртуальных "
"методов. Хотя в этом примере мы будем использовать его только для одного "
"метода, этот способ проще в расширении."

msgid "So let's implement those two functions in the ``gdexample.c`` file:"
msgstr "Итак, давайте реализуем эти две функции в файле ``gdexample.c``:"

msgid ""
"Those functions are also quite straightforward after making all the helpers "
"previously."
msgstr ""
"Эти функции также довольно просты после создания всех вспомогательных "
"функций ранее."

msgid ""
"For the first one, we simply check if the function name requested is "
"``_process`` and if it is we return a function pointer to our implementation "
"of it. Otherwise we return ``NULL``, signaling that the method is not being "
"overridden. We don't use the ``p_class_userdata`` here since this function "
"is meant only for one class and we don't have any data associated with it."
msgstr ""
"В первом случае мы просто проверяем, является ли запрошенное имя функции "
"``_process``, и если это так, то возвращаем указатель на нашу реализацию. В "
"противном случае мы возвращаем ``NULL``, сигнализируя, что метод не "
"переопределяется. Мы не используем здесь ``p_class_userdata``, поскольку эта "
"функция предназначена только для одного класса, и у нас нет связанных с ней "
"данных."

msgid ""
"The second one is similar. If it is the ``_process()`` method, it uses the "
"given function pointer to call the ``ptrcall`` helper, passing the call "
"arguments forward. Otherwise it simply does nothing, since we don't have any "
"other virtual methods being implemented."
msgstr ""
"Второй метод аналогичен. Если это метод ``_process()``, он использует "
"заданный указатель на функцию для вызова вспомогательного метода "
"``ptrcall``, передавая аргументы вызова вперёд. В противном случае он просто "
"ничего не делает, поскольку у нас нет реализованных других виртуальных "
"методов."

msgid ""
"The only thing missing is using those callbacks when the class is "
"registered. Go to the ``init.c`` file and change the ``class_info`` "
"initialization to include those, replacing the ``NULL`` value used "
"previously:"
msgstr ""
"Единственное, чего не хватает, — это использования этих обратных вызовов при "
"регистрации класса. Перейдите в файл ``init.c`` и измените инициализацию "
"``class_info``, включив их, заменив ранее использованное значение ``NULL``:"

msgid ""
"This is enough to bind the virtual method. If you build the extension and "
"run the demo project again, the ``_process()`` function will be called. You "
"just won't be able to tell since the function itself does nothing visible. "
"We will solve this now by making the custom node move following a pattern."
msgstr ""
"Этого достаточно для привязки виртуального метода. Если вы соберёте "
"расширение и снова запустите демонстрационный проект, будет вызвана функция "
"``_process()``. Вы просто не заметите этого, поскольку сама функция не "
"делает видимых действий. Сейчас мы решим эту проблему, заставив "
"пользовательский узел двигаться по заданному шаблону."

msgid ""
"In order to make our node do stuff, we'll need to call Godot methods. Not "
"only the GDExtension API functions as we've being doing so far, but actual "
"engine methods, as we would do with scripting. This naturally requires some "
"extra setup."
msgstr ""
"Чтобы наш узел работал, нам потребуется вызывать методы Godot. Не только "
"функции API GDExtension, как мы делали до сих пор, но и методы самого "
"движка, как при использовании скриптов. Это, естественно, требует "
"дополнительной настройки."

msgid ""
"First, let's add :ref:`class_Vector2` to our ``defs.h`` file, so we can use "
"it in our method:"
msgstr ""
"Сначала давайте добавим :ref:`class_Vector2` в наш файл ``defs.h``, чтобы мы "
"могли использовать его в нашем методе:"

msgid ""
"The ``REAL_T_IS_DOUBLE`` define is only needed if your Godot version was "
"built with double precision support, which is not the default."
msgstr ""
"Определение ``REAL_T_IS_DOUBLE`` необходимо только в том случае, если ваша "
"версия Godot была создана с поддержкой двойной точности, что не является "
"поддержкой по умолчанию."

msgid ""
"Now, in the ``api.h`` file, we'll add few things to the API structs, "
"including a new one for holding engine methods to call."
msgstr ""
"Теперь в файле ``api.h`` мы добавим несколько вещей в структуры API, включая "
"новую для хранения вызываемых методов движка."

msgid ""
"Then in the ``api.c`` file we can grab the function pointers from Godot:"
msgstr "Затем в файле ``api.c`` мы можем получить указатели функций из Godot:"

msgid ""
"The only noteworthy part here is the ``Vector2`` constructor, for which we "
"request the index ``3``. Since there are multiple constructors with "
"different kinds of arguments, we need to specify which one we want. In this "
"case we're getting the one that takes two float numbers as the ``x`` and "
"``y`` coordinates, hence the name. This index can be retrieved from the "
"``extension_api.json`` file. Note we also need a new local helper to get it."
msgstr ""
"Единственный примечательный фрагмент здесь — конструктор ``Vector2``, для "
"которого мы запрашиваем индекс ``3``. Поскольку существует несколько "
"конструкторов с разными типами аргументов, нам нужно указать, какой из них "
"нам нужен. В данном случае мы получаем тот, который принимает два числа с "
"плавающей точкой в качестве координат ``x`` и ``y``, отсюда и название. Этот "
"индекс можно получить из файла ``extension_api.json``. Обратите внимание, "
"что для его получения нам также понадобится новый локальный вспомогательный "
"метод."

msgid ""
"Be aware that we don't get anything for the methods struct here. This is "
"because this function is called too early in the initialization process, so "
"classes won't be properly registered yet."
msgstr ""
"Обратите внимание, что для структуры методов здесь ничего не происходит. Это "
"связано с тем, что эта функция вызывается слишком рано в процессе "
"инициализации, поэтому классы ещё не будут должным образом зарегистрированы."

msgid ""
"Instead, we're gonna use the initialization level callback to grab those "
"when we are registering our custom class. Add this to the ``init.c`` file:"
msgstr ""
"Вместо этого мы будем использовать обратный вызов уровня инициализации для "
"их получения при регистрации нашего пользовательского класса. Добавьте это в "
"файл ``init.c``:"

msgid ""
"Here we create ``StringName``'s for the class and method we want to get, "
"then use the GDExtension API to retrieve their ``MethodBind``, which is an "
"object that represents the bound method. We get the ``set_position`` method "
"from ``Node2D`` since this is where it was registered, even though we're "
"going to use it in a ``Sprite2D``, a derived class."
msgstr ""
"Здесь мы создаём ``StringName`` для класса и метода, которые хотим получить, "
"а затем используем API GDExtension для получения их ``MethodBind`` — "
"объекта, представляющего привязанный метод. Метод ``set_position`` мы "
"получаем из ``Node2D``, поскольку именно там он был зарегистрирован, хотя мы "
"собираемся использовать его в ``Sprite2D``, производном классе."

msgid ""
"The seemingly random number for getting the bind is actually a hash of the "
"method signature. This allows Godot to match the method you're requesting "
"even if in a future Godot version this signature changes, by providing a "
"compatibility method that matches what you're asking for. This is one of the "
"systems that allow the engine to load extensions made for previous versions. "
"You can get the value of this hash from the ``extension_api.json`` file."
msgstr ""
"Случайное на первый взгляд число для получения привязки на самом деле "
"является хешем сигнатуры метода. Это позволяет Godot сопоставлять "
"запрашиваемый вами метод, даже если в будущей версии Godot эта сигнатура "
"изменится, предоставляя метод совместимости, соответствующий вашему запросу. "
"Это одна из систем, позволяющих движку загружать расширения, созданные для "
"предыдущих версий. Вы можете получить значение этого хеша из файла "
"``extension_api.json``."

msgid ""
"With all that, we can finally implement our custom ``_process()`` method in "
"the ``gdexample.c`` file:"
msgstr ""
"После всего этого мы наконец можем реализовать наш собственный метод "
"``_process()`` в файле ``gdexample.c``:"

msgid ""
"After updating the time passed scaled by the ``speed`` property, it creates "
"``x`` and ``y`` values based on that, also modulated by the ``amplitude`` "
"property. This is what will give the pattern effect. The ``math.h`` header "
"is needed for the ``sin()`` and ``cos()`` functions used here."
msgstr ""
"После обновления прошедшего времени, масштабированного свойством ``speed``, "
"на его основе создаются значения ``x`` и ``y``, также модулированные "
"свойством ``amplitude``. Именно это и создаёт эффект узора. Заголовочный "
"файл ``math.h`` необходим для функций ``sin()`` и ``cos()``, используемых "
"здесь."

msgid ""
"Then it sets up an array of arguments to construct a ``Vector2``, followed "
"by calling the constructor. It sets up another array of arguments and use it "
"to call the ``set_position()`` method via the bind we acquired previously."
msgstr ""
"Затем он создаёт массив аргументов для создания ``Vector2``, после чего "
"вызывает конструктор. Он создаёт ещё один массив аргументов и использует его "
"для вызова метода ``set_position()`` через ранее полученную нами привязку."

msgid "Since nothing here allocates any memory, there's not a need to cleanup."
msgstr "Поскольку здесь не выделяется память, нет необходимости в очистке."

msgid ""
"Now we can build the extension again and reopen Godot. Even in the editor "
"you'll see the custom sprite moving."
msgstr ""
"Теперь мы можем снова собрать расширение и снова открыть Godot. Даже в "
"редакторе вы увидите, как движется пользовательский спрайт."

msgid ""
"Try changing the **Speed** and **Amplitude** properties and see how the "
"sprite react."
msgstr ""
"Попробуйте изменить свойства **Speed** и **Amplitude** и посмотрите, как "
"отреагирует спрайт."

msgid "Registering and emitting a signal"
msgstr "Регистрация и выдача сигнала"

msgid ""
"To complete this tutorial, let's see how you can register a custom signal "
"and emit it when appropriate. As you might have guessed, we'll need a few "
"more function pointers from the API and more helper functions."
msgstr ""
"Чтобы завершить это руководство, давайте посмотрим, как зарегистрировать "
"собственный сигнал и подавать его при необходимости. Как вы, возможно, "
"догадались, нам понадобится ещё несколько указателей на функции из API и "
"несколько вспомогательных функций."

msgid ""
"In the ``api.h`` file we're adding two things. One is an API function to "
"register a signal, the other is a helper function to wrap the signal binding."
msgstr ""
"В файл ``api.h`` мы добавляем две вещи: API-функцию для регистрации сигнала "
"и вспомогательную функцию для обёртки привязки сигнала."

msgid ""
"In this case we only have a version for one argument, since it's what we're "
"going to use."
msgstr ""
"В этом случае у нас есть версия только для одного аргумента, поскольку "
"именно его мы и собираемся использовать."

msgid ""
"Moving to the ``api.c`` file, we can load this new function pointer and "
"implement the helper:"
msgstr ""
"Перейдя к файлу ``api.c``, мы можем загрузить этот новый указатель на "
"функцию и реализовать помощника:"

msgid ""
"This one is very similar to the function to bind methods. The main "
"difference is that we don't need to fill another struct, we just pass the "
"needed names and the array of arguments. The ``1`` at the end means the "
"amount of arguments the signal provides."
msgstr ""
"Эта функция очень похожа на функцию для связывания методов. Главное отличие "
"в том, что нам не нужно заполнять ещё одну структуру, мы просто передаём "
"необходимые имена и массив аргументов. ``1`` в конце означает количество "
"аргументов, передаваемых сигналом."

msgid "With this we can bind the signal in ``gdexample.c``:"
msgstr "С помощью этого мы можем привязать сигнал в ``gdexample.c``:"

msgid ""
"In order to emit a signal, we need to call the :ref:`emit_signal() "
"<class_Object_method_emit_signal>` method on our custom node. Since this is "
"a ``vararg`` function (meaning it takes any amount of arguments), we cannot "
"use ``ptrcall``. To do a regular call, we have to create Variants, which "
"require a few more steps of plumbing to get done."
msgstr ""
"Чтобы подать сигнал, нам нужно вызвать метод :ref:`emit_signal() "
"<class_Object_method_emit_signal>` в нашем пользовательском узле. Поскольку "
"это функция ``vararg`` (то есть принимающая любое количество аргументов), мы "
"не можем использовать ``ptrcall``. Для обычного вызова нам нужно создать "
"варианты, что требует дополнительных действий."

msgid "First, in the ``defs.h`` file we create a definition for Variant:"
msgstr "Сначала в файле ``defs.h`` мы создаем определение для Variant:"

msgid ""
"We first set the size of Variant together with the size of Vector2 that we "
"added before. Then we use it to create an opaque struct that is enough to "
"hold the Variant data. Again, we set the size for double precision builds as "
"a fallback, since by the official Godot builds use single precision."
msgstr ""
"Сначала мы задаём размер Variant вместе с размером Vector2, который мы "
"добавили ранее. Затем мы используем его для создания непрозрачной структуры, "
"достаточной для хранения данных Variant. Мы снова задаём размер для сборок с "
"двойной точностью в качестве запасного варианта, поскольку официально Godot "
"использует одинарную точность."

msgid ""
"The ``emit_signal()`` function will be called with two arguments. The first "
"is the name of the signal to be emitted and the second is the argument we're "
"passing to the signal connections, which is a Vector2 as we declared when "
"binding it. So we're gonna create a helper function that can call a "
"MethodBind with these types. Even though it does return something (an error "
"code), we don't need to deal with it, so for now we're just going to ignore "
"it."
msgstr ""
"Функция ``emit_signal()`` будет вызываться с двумя аргументами. Первый — это "
"имя испускаемого сигнала, а второй — аргумент, который мы передаём в "
"соединения с сигналом. Это Vector2, как мы объявили при привязке. Поэтому мы "
"создадим вспомогательную функцию, которая сможет вызывать MethodBind с этими "
"типами. Несмотря на то, что она что-то возвращает (код ошибки), нам не нужно "
"с этим разбираться, поэтому пока мы просто проигнорируем его."

msgid ""
"In the ``api.h``, we're adding a few things to the existing structs, plus a "
"new helper function for the call:"
msgstr ""
"В ``api.h`` мы добавляем несколько вещей к существующим структурам, а также "
"новую вспомогательную функцию для вызова:"

msgid ""
"Now let's switch to the ``api.c`` file to load these new function pointers "
"and implement the helper function."
msgstr ""
"Теперь перейдем к файлу ``api.c``, чтобы загрузить эти новые указатели "
"функций и реализовать вспомогательную функцию."

msgid ""
"This helper function has some boilerplate code but is quite straightforward. "
"It sets up the two arguments inside stack allocated Variants, then creates "
"an array with pointers to those. It also sets up another Variant to keep the "
"return value, which we don't need to construct since the call expects it to "
"be uninitialized."
msgstr ""
"Эта вспомогательная функция содержит шаблонный код, но довольно проста. Она "
"устанавливает два аргумента внутри выделенных в стеке вариантов, а затем "
"создаёт массив с указателями на них. Она также создаёт ещё один вариант для "
"хранения возвращаемого значения, которое нам не нужно создавать, поскольку "
"вызов предполагает, что оно не инициализировано."

msgid ""
"Then it actually calls the MethodBind using the instance we provided and the "
"arguments. The ``NULL`` at the end would be a pointer to a "
"``GDExtensionCallError`` struct. This can be used to treat potential errors "
"when calling the functions (such as wrong arguments). For the sake of "
"simplicity we're not gonna handle that here."
msgstr ""
"Затем он фактически вызывает MethodBind, используя предоставленный нами "
"экземпляр и аргументы. ``NULL`` в конце будет указателем на структуру "
"``GDExtensionCallError``. Это можно использовать для обработки потенциальных "
"ошибок при вызове функций (например, неверных аргументов). Для простоты мы "
"не будем обрабатывать это здесь."

msgid ""
"At the end we need to destruct the Variants we created. While technically "
"the Vector2 one does not require destructing, it is clearer to cleanup "
"everything."
msgstr ""
"В конце нам нужно уничтожить созданные нами варианты. Хотя технически "
"Vector2 не требует уничтожения, проще очистить всё."

msgid ""
"We also need to load the MethodBind, which we'll do in the ``init.c`` file, "
"right after loading the one for the ``set_position`` method we did before:"
msgstr ""
"Нам также необходимо загрузить MethodBind, что мы сделаем в файле "
"``init.c``, сразу после загрузки метода ``set_position``, которую мы сделали "
"ранее:"

msgid ""
"Note that we reuse the ``native_class_name`` and ``method_name`` variables "
"here, so we don't need to declare new ones."
msgstr ""
"Обратите внимание, что здесь мы повторно используем переменные "
"``native_class_name`` и ``method_name``, поэтому нам не нужно объявлять "
"новые."

msgid ""
"Now go to the ``gdexample.h`` file where we're going to add a couple of "
"fields:"
msgstr "Теперь перейдите в файл ``gdexample.h``, куда мы добавим пару полей:"

msgid ""
"The first one will store the time passed since the last signal was emitted, "
"since we'll be doing so at regular intervals. The other is just to cache the "
"signal name so we don't need to create a new StringName every time."
msgstr ""
"Первый будет хранить время, прошедшее с момента последнего сигнала, "
"поскольку мы будем делать это регулярно. Второй — просто кэшировать имя "
"сигнала, чтобы не создавать каждый раз новое StringName."

msgid ""
"In the source ``gdexample.c`` file we can change the constructor and "
"destructor to deal with the new fields:"
msgstr ""
"В исходном файле ``gdexample.c`` мы можем изменить конструктор и деструктор "
"для работы с новыми полями:"

msgid "It is important to destruct the StringName to avoid memory leaks."
msgstr "Важно уничтожить StringName, чтобы избежать утечек памяти."

msgid ""
"Now we can add to the ``gdexample_class_process()`` function to actually "
"emit the signal:"
msgstr ""
"Теперь мы можем добавить функцию ``gdexample_class_process()`` для "
"фактической отправки сигнала:"

msgid ""
"This updates the time passed for the signal emission and, if it is over one "
"second it calls the ``emit_signal()`` function on the current instance, "
"passing the name of the signal and the new position as arguments."
msgstr ""
"Это обновляет время, прошедшее с момента излучения сигнала, и, если оно "
"превышает одну секунду, вызывает функцию ``emit_signal()`` для текущего "
"экземпляра, передавая имя сигнала и новую позицию в качестве аргументов."

msgid ""
"Now we're done with our C GDExtension. Build it once more and reopen the "
"demo project in the editor."
msgstr ""
"Мы закончили с нашим C GDExtension. Соберите его ещё раз и откройте "
"демонстрационный проект в редакторе."

msgid ""
"In the documentation page for ``GDExample`` you can see the new signal we "
"bound:"
msgstr ""
"На странице документации по ``GDExample`` вы можете увидеть новый сигнал, "
"который мы привязали:"

msgid ""
"To check it's working, let's add a small script to the root node, parent of "
"our custom one, that prints the position to the output every time it "
"receives the signal:"
msgstr ""
"Чтобы проверить, как это работает, давайте добавим небольшой скрипт в "
"корневой узел, родительский для нашего пользовательского узла, который "
"выводит позицию на выход каждый раз при получении сигнала:"

msgid ""
"Run the project and you can observe the values being printed in the Output "
"dock in the editor:"
msgstr ""
"Запустите проект, и вы сможете наблюдать, как значения печатаются в доке "
"вывода в редакторе:"

msgid "Conclusion"
msgstr "Заключение"

msgid ""
"This tutorial shows a basic extension with custom methods, properties, and "
"signals. While it does require a good amount of boilerplate, it can scale "
"well by creating helper functions to handle the tedious tasks."
msgstr ""
"В этом руководстве показано базовое расширение с пользовательскими методами, "
"свойствами и сигналами. Хотя оно требует значительного количества шаблонного "
"кода, его можно легко масштабировать, создав вспомогательные функции для "
"решения сложных задач."

msgid ""
"This should serve as a good basis to understand the GDExtension API and as a "
"starting point to create custom binding generators. In fact, it would be "
"possible to create bindings for C using such type of generator, making the "
"actual coding look more like the ``gdexample.c`` file in this example, which "
"is quite straightforward and not very verbose."
msgstr ""
"Это должно послужить хорошей основой для понимания API GDExtension и "
"отправной точкой для создания собственных генераторов привязок. Фактически, "
"с помощью такого генератора можно создавать привязки для C, что делает код "
"более похожим на файл ``gdexample.c`` из этого примера, который довольно "
"прост и не слишком многословен."

msgid ""
"If you want to create actual extensions, it is preferred to use the C++ "
"bindings instead, as it takes away all of the boilerplate from your code. "
"Check the :ref:`godot-cpp documentation <doc_godot_cpp>` to see how you can "
"do this."
msgstr ""
"Если вы хотите создавать настоящие расширения, предпочтительнее использовать "
"привязки C++, поскольку это избавляет от всего шаблонного кода. Чтобы "
"узнать, как это сделать, ознакомьтесь с :ref:`godot-cpp documentation "
"<doc_godot_cpp>`."
