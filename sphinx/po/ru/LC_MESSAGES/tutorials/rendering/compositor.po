#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The Compositor"
msgstr "Композитор"

msgid ""
"The compositor is a new feature in Godot 4 that allows control over the "
"rendering pipeline when rendering the contents of a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"Композитор — это новая функция Godot 4, которая позволяет управлять "
"конвейером рендеринга при рендеринге содержимого :ref:`Viewport "
"<class_Viewport>`."

msgid ""
"It can be configured on a :ref:`WorldEnvironment <class_WorldEnvironment>` "
"node where it applies to all Viewports, or it can be configured on "
"a :ref:`Camera3D <class_Camera3D>` and apply only to the Viewport using that "
"camera."
msgstr ""
"Его можно настроить на узле :ref:`WorldEnvironment "
"<class_WorldEnvironment>`, где он применяется ко всем видовым областям, или "
"его можно настроить на узле :ref:`Camera3D <class_Camera3D>` и применить "
"только к видовой области, использующей эту камеру."

msgid ""
"The :ref:`Compositor <class_Compositor>` resource is used to configure the "
"compositor. To get started, create a new compositor on the appropriate node:"
msgstr ""
"Ресурс :ref:`Compositor <class_Compositor>` используется для настройки "
"компоновщика. Для начала создайте новый компоновщик на соответствующем узле:"

msgid ""
"The compositor is currently a feature that is only supported by the Mobile "
"and Forward+ renderers."
msgstr ""
"В настоящее время функция компоновщика поддерживается только рендерами "
"Mobile и Forward+."

msgid "Compositor effects"
msgstr "Эффекты композитора"

msgid ""
"Compositor effects allow you to insert additional logic into the rendering "
"pipeline at various stages. This is an advanced feature that requires a high "
"level of understanding of the rendering pipeline to use to its best "
"advantage."
msgstr ""
"Эффекты Compositor позволяют добавлять дополнительную логику в конвейер "
"рендеринга на разных этапах. Это сложная функция, требующая глубокого "
"понимания принципов работы конвейера рендеринга для её эффективного "
"использования."

msgid ""
"As the core logic of the compositor effect is called from the rendering "
"pipeline it is important to note that this logic will thus run within the "
"thread on which rendering takes place. Care needs to be taken to ensure we "
"don't run into threading issues."
msgstr ""
"Поскольку основная логика эффекта компоновщика вызывается из конвейера "
"рендеринга, важно отметить, что эта логика будет выполняться в том же "
"потоке, в котором происходит рендеринг. Необходимо соблюдать осторожность, "
"чтобы избежать проблем с потоками."

msgid ""
"To illustrate how to use compositor effects we'll create a simple post "
"processing effect that allows you to write your own shader code and apply "
"this full screen through a compute shader. You can find the finished demo "
"project `here <https://github.com/godotengine/godot-demo-projects/tree/"
"master/compute/post_shader>`_."
msgstr ""
"Чтобы продемонстрировать использование эффектов компоновщика, мы создадим "
"простой эффект постобработки, который позволит вам написать собственный код "
"шейдера и применить этот полноэкранный режим через вычислительный шейдер. "
"Готовый демонстрационный проект можно найти `здесь: <https://github.com/"
"godotengine/godot-demo-projects/tree/master/compute/post_shader>`_."

msgid ""
"We start by creating a new script called ``post_process_shader.gd``. We'll "
"make this a tool script so we can see the compositor effect work in the "
"editor. We need to extend our node from :ref:`CompositorEffect "
"<class_CompositorEffect>`. We must also give our script a class name."
msgstr ""
"Начнём с создания нового скрипта под названием ``post_process_shader.gd``. "
"Сделаем его инструментальным скриптом, чтобы можно было увидеть работу "
"эффекта компоновщика в редакторе. Нам нужно расширить наш узел "
"от :ref:`CompositorEffect <class_CompositorEffect>`. Также нужно дать нашему "
"скрипту имя класса."

msgid "post_process_shader.gd"
msgstr "post_process_shader.gd"

msgid ""
"Next we're going to define a constant for our shader template code. This is "
"the boilerplate code that makes our compute shader work."
msgstr ""
"Далее мы определим константу для кода шаблона нашего шейдера. Это шаблонный "
"код, который обеспечивает работу нашего вычислительного шейдера."

msgid ""
"For more information on how compute shaders work, please check :ref:`Using "
"compute shaders <doc_compute_shaders>`."
msgstr ""
"Более подробную информацию о работе вычислительных шейдеров см. в "
"разделе: :ref:`Using compute shaders <doc_compute_shaders>`."

msgid ""
"The important bit here is that for every pixel on our screen, our ``main`` "
"function is executed and inside of this we load the current color value of "
"our pixel, execute our user code, and write our modified color back to our "
"color image."
msgstr ""
"Важным моментом здесь является то, что для каждого пикселя на нашем экране "
"выполняется наша ``main`` функция, внутри которой мы загружаем текущее "
"значение цвета нашего пикселя, выполняем наш пользовательский код и "
"записываем наш измененный цвет обратно в наше цветное изображение."

msgid "``#COMPUTE_CODE`` gets replaced by our user code."
msgstr "``#COMPUTE_CODE`` заменяется нашим пользовательским кодом."

msgid ""
"In order to set our user code, we need an export variable. We'll also define "
"a few script variables we'll be using:"
msgstr ""
"Чтобы задать код пользователя, нам понадобится переменная экспорта. Мы также "
"определим несколько переменных скрипта, которые будем использовать:"

msgid ""
"Note the use of a :ref:`Mutex <class_Mutex>` in our code. Most of our "
"implementation gets called from the rendering engine and thus runs within "
"our rendering thread."
msgstr ""
"Обратите внимание на использование :ref:`Mutex <class_Mutex>` в нашем коде. "
"Большая часть нашей реализации вызывается из движка рендеринга и, "
"следовательно, выполняется в нашем потоке рендеринга."

msgid ""
"We need to ensure that we set our new shader code, and mark our shader code "
"as dirty, without our render thread accessing this data at the same time."
msgstr ""
"Нам нужно убедиться, что мы устанавливаем наш новый код шейдера и отмечаем "
"его как грязный, без того, чтобы наш поток рендеринга одновременно получал "
"доступ к этим данным."

msgid "Next we initialize our effect."
msgstr "Далее мы инициализируем наш эффект."

msgid ""
"The main thing here is setting our ``effect_callback_type`` which tells the "
"rendering engine at what stage of the render pipeline to call our code."
msgstr ""
"Главное здесь — установить наш ``effect_callback_type``, который сообщает "
"движку рендеринга, на каком этапе конвейера рендеринга вызывать наш код."

msgid ""
"Currently we only have access to the stages of the 3D rendering pipeline!"
msgstr ""
"В настоящее время у нас есть доступ только к этапам конвейера 3D-рендеринга!"

msgid ""
"We also get a reference to our rendering device, which will come in very "
"handy."
msgstr ""
"Мы также получим ссылку на наше устройство рендеринга, что будет очень "
"полезно."

msgid ""
"We also need to clean up after ourselves, for this we react to the "
"``NOTIFICATION_PREDELETE`` notification:"
msgstr ""
"Нам также необходимо убрать за собой, для этого мы реагируем на уведомление "
"``NOTIFICATION_PREDELETE``:"

msgid ""
"Note that we do not use our mutex here even though we create our shader "
"inside of our render thread. The methods on our rendering server are thread "
"safe and ``free_rid`` will be postponed cleaning up the shader until after "
"any frames currently being rendered are finished."
msgstr ""
"Обратите внимание, что мы не используем здесь мьютекс (mutex), хотя создаём "
"шейдер внутри потока рендеринга. Методы на нашем сервере рендеринга "
"потокобезопасны, и ``free_rid`` будет отложена очистка шейдера до завершения "
"рендеринга всех текущих кадров."

msgid ""
"Also note that we are not freeing our pipeline. The rendering device does "
"dependency tracking and as the pipeline is dependent on the shader, it will "
"be automatically freed when the shader is destructed."
msgstr ""
"Также обратите внимание, что мы не освобождаем наш конвейер. Устройство "
"рендеринга отслеживает зависимости, и поскольку конвейер зависит от шейдера, "
"он будет автоматически освобожден при уничтожении шейдера."

msgid "From this point onwards our code will run on the rendering thread."
msgstr "С этого момента наш код будет выполняться в потоке рендеринга."

msgid ""
"Our next step is a helper function that will recompile the shader if the "
"user code was changed."
msgstr ""
"Наш следующий шаг — вспомогательная функция, которая перекомпилирует шейдер, "
"если пользовательский код был изменен."

msgid ""
"At the top of this method we again use our mutex to protect accessing our "
"user shader code and our is dirty flag. We make a local copy of the user "
"shader code if our user shader code is dirty."
msgstr ""
"В начале этого метода мы снова используем мьютекс для защиты доступа к коду "
"пользовательского шейдера и флаг \"dirty\". Мы создаём локальную копию кода "
"пользовательского шейдера, если он \"dirty\"."

msgid ""
"If we don't have a new code fragment, we return true if we already have a "
"valid pipeline."
msgstr ""
"Если у нас нет нового фрагмента кода, мы возвращаем true, если у нас уже "
"есть действительный конвейер."

msgid ""
"If we do have a new code fragment we embed it in our template code and then "
"compile it."
msgstr ""
"Если у нас есть новый фрагмент кода, мы встраиваем его в код нашего шаблона, "
"а затем компилируем его."

msgid ""
"The code shown here compiles our new code in runtime. This is great for "
"prototyping as we can immediately see the effect of the changed shader."
msgstr ""
"Приведённый здесь код компилирует наш новый код во время выполнения. Это "
"отлично подходит для создания прототипов, поскольку мы сразу видим эффект от "
"изменённого шейдера."

msgid ""
"This prevents precompiling and caching this shader which may be an issues on "
"some platforms such as consoles. Note that the demo project comes with an "
"alternative example where a ``glsl`` file contains the entire compute shader "
"and this is used. Godot is able to precompile and cache the shader with this "
"approach."
msgstr ""
"Это предотвращает предварительную компиляцию и кэширование этого шейдера, "
"что может вызывать проблемы на некоторых платформах, например, на консолях. "
"Обратите внимание, что демонстрационный проект содержит альтернативный "
"пример, в котором файл ``glsl`` содержит весь вычислительный шейдер, и он "
"используется. Godot может предварительно компилировать и кэшировать шейдер, "
"используя этот подход."

msgid ""
"Finally we need to implement our effect callback, the rendering engine will "
"call this at the right stage of rendering."
msgstr ""
"Наконец, нам нужно реализовать обратный вызов нашего эффекта, движок "
"рендеринга вызовет его на нужном этапе рендеринга."

msgid ""
"At the start of this method we check if we have a rendering device, if our "
"callback type is the correct one, and check if we have our shader."
msgstr ""
"В начале этого метода мы проверяем, есть ли у нас устройство рендеринга, "
"правильный ли у нас тип обратного вызова и есть ли у нас шейдер."

msgid ""
"The check for the effect type is only a safety mechanism. We've set this in "
"our ``_init`` function, however it is possible for the user to change this "
"in the UI."
msgstr ""
"Проверка типа эффекта — всего лишь механизм безопасности. Мы задали её в "
"функции ``_init``, однако пользователь может изменить её в пользовательском "
"интерфейсе."

msgid ""
"Our ``p_render_data`` parameter gives us access to an object that holds data "
"specific to the frame we're currently rendering. We're currently only "
"interested in our render scene buffers, which provide us access to all the "
"internal buffers used by the rendering engine. Note that we cast this "
"to :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>` to expose the "
"full API to this data."
msgstr ""
"Наш параметр ``p_render_data`` предоставляет нам доступ к объекту, "
"содержащему данные, относящиеся к текущему кадру, который мы рендерим. В "
"настоящее время нас интересуют только буферы сцены рендеринга, которые "
"предоставляют доступ ко всем внутренним буферам, используемым движком "
"рендеринга. Обратите внимание, что мы приводим этот параметр "
"к :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>`, чтобы "
"предоставить полный API для работы с этими данными."

msgid ""
"Next we obtain our ``internal size`` which is the resolution of our 3D "
"render buffers before they are upscaled (if applicable), upscaling happens "
"after our post processes have run."
msgstr ""
"Затем мы получаем наш ``internal size``, который представляет собой "
"разрешение наших буферов 3D-рендеринга до их масштабирования (если "
"применимо), масштабирование происходит после завершения наших постпроцессов."

msgid ""
"From our internal size we calculate our group size, see our local size in "
"our template shader."
msgstr ""
"На основе нашего внутреннего размера мы рассчитываем размер нашей группы, "
"смотрите наш локальный размер в нашем шаблонном шейдере."

msgid ""
"We also populate our push constant so our shader knows our size. Godot does "
"not support structs here **yet** so we use a ``PackedFloat32Array`` to store "
"this data into. Note that we have to pad this array with a 16 byte "
"alignment. In other words, the length of our array needs to be a multiple of "
"4."
msgstr ""
"Мы также заполняем нашу константу push, чтобы шейдер знал наш размер. Godot "
"**пока** не поддерживает структуры, поэтому мы используем "
"``PackedFloat32Array`` для хранения этих данных. Обратите внимание, что нам "
"нужно дополнить этот массив выравниванием по 16 байт. Другими словами, длина "
"нашего массива должна быть кратна 4."

msgid ""
"Now we loop through our views, this is in case we're using multiview "
"rendering which is applicable for stereo rendering (XR). In most cases we "
"will only have one view."
msgstr ""
"Теперь мы циклически проходим по нашим представлениям. Это на случай, если "
"мы используем многовидовой рендеринг, который применим для стереорендеринга "
"(XR). В большинстве случаев у нас будет только одно представление."

msgid ""
"There is no performance benefit to use multiview for post processing here, "
"handling the views separately like this will still enable the GPU to use "
"parallelism if beneficial."
msgstr ""
"В данном случае использование нескольких представлений для постобработки не "
"дает никаких преимуществ в производительности, однако раздельная обработка "
"представлений, подобная этой, все равно позволит графическому процессору "
"использовать параллелизм, если это выгодно."

msgid ""
"Next we obtain the color buffer for this view. This is the buffer into which "
"our 3D scene has been rendered."
msgstr ""
"Затем мы получаем цветовой буфер для этого вида. Это буфер, в который была "
"отрендерена наша 3D-сцена."

msgid ""
"We then prepare a uniform set so we can communicate the color buffer to our "
"shader."
msgstr ""
"Затем мы подготавливаем единый набор, чтобы иметь возможность передать "
"цветовой буфер нашему шейдеру."

msgid ""
"Note the use of our :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` cache "
"which ensures we can check for our uniform set each frame. As our color "
"buffer can change from frame to frame and our uniform cache will "
"automatically clean up uniform sets when buffers are freed, this is the safe "
"way to ensure we do not leak memory or use an outdated set."
msgstr ""
"Обратите внимание на использование нашего кэша :ref:`UniformSetCacheRD "
"<class_UniformSetCacheRD>`, который гарантирует проверку нашего набора "
"юниформ в каждом кадре. Поскольку буфер цветов может меняться от кадра к "
"кадру, а кэш юниформ автоматически очищает наборы юниформ при освобождении "
"буферов, это безопасный способ избежать утечки памяти или использования "
"устаревшего набора."

msgid ""
"Finally we build our compute list by binding our pipeline, binding our "
"uniform set, pushing our push constant data, and calling dispatch for our "
"groups."
msgstr ""
"Наконец, мы создаем наш список вычислений, привязывая наш конвейер, "
"привязывая наш унифицированный набор, отправляя наши постоянные данные и "
"вызывая диспетчеризацию для наших групп."

msgid ""
"With our compositor effect completed, we now need to add it to our "
"compositor."
msgstr ""
"После завершения нашего эффекта композитора нам нужно добавить его в наш "
"композитор."

msgid ""
"On our compositor we expand the compositor effects property and press ``Add "
"Element``."
msgstr ""
"В нашем композиторе раскрываем свойство эффектов композитора и нажимаем "
"``Add Element``."

msgid "Now we can add our compositor effect:"
msgstr "Теперь мы можем добавить наш эффект композитора:"

msgid ""
"After selecting our ``PostProcessShader`` we need to set our user shader "
"code:"
msgstr ""
"После выбора нашего ``PostProcessShader`` нам нужно установить код шейдера "
"пользователя:"

msgid "With that all done, our output is in grayscale."
msgstr "После всего этого наш вывод будет в оттенках серого."

msgid ""
"For a more advanced example of post effects, check out the `Radial blur "
"based sky rays <https://github.com/BastiaanOlij/RERadialSunRays>`_ example "
"project created by Bastiaan Olij."
msgstr ""
"Для более продвинутого примера постэффектов ознакомьтесь с примером проекта "
"`Радиальное размытие на основе небесных лучей <https://github.com/"
"BastiaanOlij/RERadialSunRays>`_, созданным Бастианом Олием."
