#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "Использовать Viewports"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"Представьте себе :ref:`Viewport <class_Viewport>` как экран, на который "
"проецируется игра. Чтобы увидеть игру, нам нужна поверхность, на которой её "
"можно отобразить. Эта поверхность и есть корневой Root Viewport."

msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`SubViewports <class_SubViewport>` представляют собой своего рода "
"область просмотра, которую можно добавить к сцене, чтобы иметь несколько "
"поверхностей для рисования. Когда мы рисуем в SubViewport, мы называем его "
"целью рендеринга. Мы можем получить доступ к содержимому цели рендеринга, "
"обратившись к ее соответствующему :ref:`texture "
"<class_Viewport_method_get_texture>`. Используя SubViewport в качестве цели "
"рендеринга, мы можем либо визуализировать несколько сцен одновременно, либо "
"выполнить рендеринг в :ref:`ViewportTexture <class_ViewportTexture>`, "
"которая применяется к объекту в сцене, например, к динамическому скайбоксу."

msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ""
":ref:`SubViewports <class_SubViewport>` имеют множество вариантов "
"использования, включая:"

msgid "Rendering 3D objects within a 2D game"
msgstr "Рендеринг 3D-объектов в 2D-игре"

msgid "Rendering 2D elements in a 3D game"
msgstr "Рендеринг 2D-элементов в 3D-игре"

msgid "Rendering dynamic textures"
msgstr "Рендеринг динамических текстур"

msgid "Generating procedural textures at runtime"
msgstr "Генерация процедурных текстур во время выполнения"

msgid "Rendering multiple cameras in the same scene"
msgstr "Рендеринг нескольких камер в одной сцене"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"Общим для всех этих вариантов использования является то, что вам "
"предоставляется возможность рисовать объекты на текстуре, как если бы это "
"был еще один экран, а затем выбирать, что делать с получившейся текстурой."

msgid ""
"Another kind of Viewports in Godot are :ref:`Windows <class_Window>`. They "
"allow their content to be projected onto a window. While the Root Viewport "
"is a Window, they are less flexible. If you want to use the texture of a "
"Viewport, you'll be working with :ref:`SubViewports <class_SubViewport>` "
"most of the time."
msgstr ""
"Другой тип Viewports в Godot — это :ref:`Windows <class_Window>`. Они "
"позволяют проецировать своё содержимое на окно. Хотя корневой Viewports — "
"это окно, он менее гибок. Если вы хотите использовать текстуру Viewports, "
"большую часть времени вам придётся работать с :ref:`SubViewports "
"<class_SubViewport>`."

msgid "Input"
msgstr "Вход"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewports <class_Viewport>` также отвечают за доставку правильно "
"настроенных и масштабированных событий ввода своим дочерним узлам. По "
"умолчанию :ref:`SubViewports <class_SubViewport>` не получают входные данные "
"автоматически, если только они не получают их от своего непосредственного "
"родительского узла :ref:`SubViewportContainer <class_SubViewportContainer>`. "
"В этом случае ввод можно отключить с помощью свойства :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>`."

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"Более подробную информацию о том, как Godot обрабатывает ввод, можно найти "
"в :ref:`Input Event Tutorial <doc_inputevent>`."

msgid "Listener"
msgstr "Listener"

msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes). More on this can be found "
"in the :ref:`Audio Streams Tutorial <doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a :ref:`SubViewport "
"<class_SubViewport>` to display your :ref:`World3D <class_World3D>` "
"or :ref:`World2D <class_World2D>`, don't forget to enable this!"
msgstr ""
"Godot поддерживает 3D-звук (как в 2D-, так и в 3D-узлах). Подробнее об этом "
"можно узнать в :ref:`Audio Streams Tutorial <doc_audio_streams>`. Для "
"воспроизведения этого типа звука необходимо включить :ref:`Viewport "
"<class_Viewport>` в качестве прослушивателя (для 2D или 3D). Если вы "
"используете :ref:`SubViewport <class_SubViewport>` для "
"отображения :ref:`World3D <class_World3D>` или :ref:`World2D "
"<class_World2D>`, не забудьте включить его!"

msgid "Cameras (2D & 3D)"
msgstr "Камеры (2D и 3D)"

msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest "
"parent :ref:`Viewport <class_Viewport>` (going towards the root). For "
"example, in the following hierarchy:"
msgstr ""
"При использовании :ref:`Camera3D <class_Camera3D>` или :ref:`Camera2D "
"<class_Camera2D>`, он всегда будет отображаться на ближайшем "
"родительском :ref:`Viewport <class_Viewport>` (по направлению к корню). "
"Например, в следующей иерархии:"

msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"``CameraA`` будет отображаться на Root :ref:`Viewport <class_Viewport>` и "
"будет отображать ``MeshA``. ``CameraB`` будет захвачена :ref:`SubViewport "
"<class_SubViewport>` вместе с ``MeshB``. Несмотря на то, что ``MeshB`` "
"находится в иерархии сцены, она всё равно не будет отображена на Root "
"Viewport. Аналогично, ``MeshA`` не будет отображаться на SubViewport, "
"поскольку SubViewport захватывает только узлы, расположенные ниже в иерархии."

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has "
"the :ref:`current <class_Camera3D_property_current>` property set, or make "
"it the current camera by calling:"
msgstr ""
"На каждый :ref:`Viewport <class_Viewport>` может быть только одна активная "
"камера, поэтому если их несколько, убедитесь, что у нужной камеры "
"установлено свойство :ref:`current <class_Camera3D_property_current>`, или "
"сделайте ее текущей камерой, вызвав:"

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's "
"<class_VisualInstance3D>` :ref:`layer "
"<class_VisualInstance3D_property_layers>` property to restrict which objects "
"are rendered."
msgstr ""
"По умолчанию камеры визуализируют все объекты в своём мире. В 3D камеры "
"могут использовать свойство :ref:`cull_mask "
"<class_Camera3D_property_cull_mask>` в сочетании со свойством :ref:`layer "
"<class_VisualInstance3D_property_layers>` объекта :ref:`VisualInstance3D's "
"<class_VisualInstance3D>`, чтобы ограничить отображаемые объекты."

msgid "Scale & stretching"
msgstr "Масштаб и растяжение"

msgid ""
":ref:`SubViewports <class_SubViewport>` have "
"a :ref:`size<class_SubViewport_property_size>` property, which represents "
"the size of the SubViewport in pixels. For SubViewports which are children "
"of :ref:`SubViewportContainers <class_SubViewportContainer>`, these values "
"are overridden, but for all others, this sets their resolution."
msgstr ""
"У :ref:`SubViewports <class_SubViewport>` есть "
"свойство :ref:`size<class_SubViewport_property_size>`, которое задаёт размер "
"SubViewport в пикселях. Для SubViewports, являющихся дочерними "
"элементами :ref:`SubViewportContainers <class_SubViewportContainer>`, эти "
"значения переопределяются, но для всех остальных это задаёт разрешение."

msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"Также можно масштабировать 2D-контент и сделать разрешение :ref:`SubViewport "
"<class_SubViewport>` отличным от указанного в size, вызвав:"

msgid ""
"For information on scaling and stretching with the Root Viewport visit "
"the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"Информацию о масштабировании и растяжении с помощью Root Viewport см. "
"в :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "Миры"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World3D "
"<class_World3D>`. This is basically the universe that links physics and "
"rendering together. Node3D-based nodes will register using the World3D of "
"the closest Viewport. By default, newly created Viewports do not contain a "
"World3D but use the same as their parent Viewport. The Root Viewport always "
"contains a World3D, which is the one objects are rendered to by default."
msgstr ""
"Для 3D :ref:`Viewport <class_Viewport>` будет содержать :ref:`World3D "
"<class_World3D>`. По сути, это вселенная, которая связывает физику и "
"рендеринг. Узлы на основе Node3D регистрируются, используя World3D "
"ближайшего Viewport. По умолчанию вновь создаваемые Viewport не содержат "
"World3D, а используют тот же, что и родительский Viewport. Корневой Viewport "
"всегда содержит World3D, в котором объекты рендерятся по умолчанию."

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""
":ref:`World3D <class_World3D>` можно задать в :ref:`Viewport "
"<class_Viewport>` с помощью свойства :ref:`World "
"3D<class_Viewport_property_world_3d>`, которое отделит все дочерние узлы "
"этого :ref:`Viewport <class_Viewport>` и предотвратит их взаимодействие с "
"World3D родительского Viewport. Это особенно полезно в сценариях, где, "
"например, требуется отобразить отдельного трёхмерного персонажа, наложенного "
"на игровое поле (например, в StarCraft)."

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create "
"a :ref:`World3D <class_World3D>`, Viewport has the option to use "
"its :ref:`Own World3D <class_Viewport_property_own_world_3d>`. This is "
"useful when you want to instance 3D characters or objects in :ref:`World2D "
"<class_World2D>`."
msgstr ""
"В качестве вспомогательного инструмента для ситуаций, когда вы хотите "
"создать :ref:`Viewports <class_Viewport>`, отображающие отдельные объекты, и "
"не хотите создавать :ref:`World3D <class_World3D>`, Viewport позволяет "
"использовать свой :ref:`Own World3D <class_Viewport_property_own_world_3d>`. "
"Это полезно, когда вы хотите создать экземпляры 3D-персонажей или объектов "
"в :ref:`World2D <class_World2D>`."

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its "
"own :ref:`World2D <class_World2D>`. This suffices in most cases, but in case "
"sharing them may be desired, it is possible to do so by "
"setting :ref:`world_2d<class_Viewport_property_world_2d>` on the Viewport "
"through code."
msgstr ""
"В 2D-пространстве каждый :ref:`Viewport <class_Viewport>` всегда содержит "
"свой собственный :ref:`World2D <class_World2D>`. В большинстве случаев этого "
"достаточно, но если требуется их совместное использование, это можно "
"сделать, установив :ref:`world_2d<class_Viewport_property_world_2d>` на "
"Viewport через код."

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"Пример того, как это работает, можно увидеть в демонстрационных проектах `3D "
"in 2D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/3d_in_2d>`_ и `2D in 3D <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/2d_in_3d>`_ соответственно."

msgid "Capture"
msgstr "Capture (Захват)"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"Можно запросить снимок содержимого :ref:`Viewport <class_Viewport>`. Для "
"корневого Viewport это фактически снимок экрана. Это делается с помощью "
"следующего кода:"

msgid ""
"But if you use this in ``_ready()`` or from the first frame of "
"the :ref:`Viewport's <class_Viewport>` initialization, you will get an empty "
"texture because there is nothing to get as texture. You can deal with it "
"using (for example):"
msgstr ""
"Но если использовать это в ``_ready()`` или в первом кадре "
"инициализации :ref:`Viewport's <class_Viewport>`, вы получите пустую "
"текстуру, поскольку получать текстуру нечего. Решить эту проблему можно, "
"например, так:"

msgid "Viewport Container"
msgstr "Viewport Container (Контейнер Области просмотра)"

msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of "
"a :ref:`SubViewportContainer <class_SubViewportContainer>`, it will become "
"active and display anything it has inside. The layout looks like this:"
msgstr ""
"Если :ref:`SubViewport <class_SubViewport>` является дочерним "
"элементом :ref:`SubViewportContainer <class_SubViewportContainer>`, он "
"станет активным и отобразит всё, что находится внутри. Макет выглядит "
"следующим образом:"

msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
":ref:`SubViewport <class_SubViewport>` будет полностью покрывать область "
"своего родительского :ref:`SubViewportContainer "
"<class_SubViewportContainer>`, "
"если :ref:`Stretch<class_SubViewportContainer_property_stretch>` установлено "
"в ``true`` в SubViewportContainer."

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
"Размер :ref:`SubViewportContainer <class_SubViewportContainer>` не может "
"быть меньше размера :ref:`SubViewport <class_SubViewport>`."

msgid "Rendering"
msgstr "Отрисовка"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"Поскольку :ref:`Viewport <class_Viewport>` является точкой входа в другую "
"поверхность рендеринга, он предоставляет несколько свойств рендеринга, "
"которые могут отличаться от настроек проекта. Вы можете выбрать разный "
"уровень :ref:`MSAA <class_Viewport_property_msaa_2d>` для каждого Viewport. "
"По умолчанию установлено значение ``Disabled (Отключено)``."

msgid ""
"If you know that the :ref:`Viewport <class_Viewport>` is only going to be "
"used for 2D, you can :ref:`Disable 3D<class_Viewport_property_disable_3d>`. "
"Godot will then restrict how the Viewport is drawn. Disabling 3D is slightly "
"faster and uses less memory compared to enabled 3D. It's a good idea to "
"disable 3D if your viewport doesn't render anything in 3D."
msgstr ""
"Если вы знаете, что :ref:`Viewport <class_Viewport>` (область просмотра) "
"будет использоваться только для 2D, вы можете :ref:`Disable "
"3D<class_Viewport_property_disable_3d>`. Godot ограничит способ отрисовки "
"области просмотра. Отключение 3D немного ускоряет работу и потребляет меньше "
"памяти по сравнению с включённым 3D. Рекомендуется отключить 3D, если "
"область просмотра не отображает ничего в 3D."

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"Если вам нужно визуализировать 3D-тени в области просмотра, обязательно "
"установите для свойства области "
"просмотра :ref:`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"значение больше ``0``. В противном случае тени не будут визуализироваться. "
"По умолчанию эквивалентное значение параметра проекта равно ``4096`` на "
"настольных компьютерах и ``2048`` на мобильных устройствах."

msgid ""
"Godot also provides a way of customizing how everything is drawn "
"inside :ref:`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot также предоставляет возможность настраивать отрисовку "
"внутри :ref:`Viewports <class_Viewport>` с помощью :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw позволяет указать "
"режим, определяющий, как Viewport будет отображать объекты внутри него. "
"Debug Draw по умолчанию ``Disabled`` (отключен). Другие варианты: "
"``Unshaded``, ``Overdraw``, и ``Wireframe``. Полный список см. в "
"документации :ref:`Viewport "
"Documentation<class_Viewport_property_debug_draw>`."

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr ""
"**Debug Draw = Disabled** (по умолчанию): сцена отрисовывается в обычном "
"режиме."

msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"**Debug Draw = Unshaded**: Unshaded рисует сцену без использования "
"информации об освещении, поэтому все объекты выглядят плоско окрашенными в "
"цвете альбедо."

msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr ""
"**Debug Draw = Overdraw**: Overdraw рисует сетки полупрозрачными с "
"аддитивным смешиванием, чтобы можно было видеть, как перекрываются сетки."

msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr ""
"**Debug Draw = Wireframe**: Каркас рисует сцену, используя только края "
"треугольников в сетках."

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""
"Режимы отладки отрисовки в настоящее время **не** поддерживаются при "
"использовании метода совместимого рендеринга. Они будут отображаться как "
"обычные режимы отрисовки."

msgid "Render target"
msgstr "Цель рендеринга"

msgid ""
"When rendering to a :ref:`SubViewport <class_SubViewport>`, whatever is "
"inside will not be visible in the scene editor. To display the contents, you "
"have to draw the SubViewport's :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"При рендеринге в :ref:`SubViewport <class_SubViewport>` всё, что находится "
"внутри, не будет видно в редакторе сцены. Чтобы отобразить содержимое, "
"необходимо где-то нарисовать :ref:`ViewportTexture <class_ViewportTexture>` "
"этого SubViewport. Это можно сделать с помощью кода, например:"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "Или его можно назначить в редакторе, выбрав \"New ViewportTexture\""

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr ""
"и затем выберите :ref:`Viewport <class_Viewport>`, который вы хотите "
"использовать."

msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"В каждом кадре текстура :ref:`Viewport's <class_Viewport>` очищается цветом "
"по умолчанию (или прозрачным, если :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` установлено в значение "
"``true``). Это можно изменить, установив для :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` значение "
"``Never`` или ``Next Frame``. Как следует из названия, Never означает, что "
"текстура никогда не будет очищена, в то время как в следующем кадре текстура "
"будет очищена в следующем кадре и затем сама примет значение Never."

msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"По умолчанию повторная визуализация :ref:`SubViewport <class_SubViewport>` "
"происходит, когда его :ref:`ViewportTexture <class_ViewportTexture>` "
"отрисовывается в кадре. Если он видим, он будет отрисован, в противном "
"случае — нет. Это поведение можно изменить, установив :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` на ``Never``, "
"``Once``, ``Always`` или ``When Parent Visible``. Never и Always будут "
"никогда или всегда перерисовываться соответственно. Once перерисовывает "
"следующий кадр и впоследствии меняется на Never. Это можно использовать для "
"ручного обновления области просмотра. Такая гибкость позволяет пользователям "
"отрисовывать изображение один раз, а затем использовать текстуру, не неся "
"затраты на рендеринг каждого кадра."

msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"Обязательно ознакомьтесь с демонстрациями Viewport. Они доступны в папке "
"viewport архива демонстраций или по адресу https://github.com/godotengine/"
"godot-demo-projects/tree/master/viewport."
