#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR Render Models"
msgstr "Модели рендеринга OpenXR"

msgid ""
"A cornerstone of OpenXR's API design is being as platform agnostic as "
"possible. A great example of this is OpenXR's action map system where XR "
"runtimes have to support core interaction profiles to fall back on, if no "
"interaction profile exists for the hardware being used. This ensures that "
"OpenXR applications keep functioning even when used on hardware that didn't "
"exist when the application was released, or that the developers of the "
"application did not have access too."
msgstr ""
"Краеугольным камнем архитектуры API OpenXR является максимальная "
"платформенная независимость. Прекрасным примером этого является система карт "
"действий OpenXR, где среды выполнения XR должны поддерживать основные "
"профили взаимодействия, к которым можно обратиться, если для используемого "
"оборудования профиль взаимодействия отсутствует. Это гарантирует "
"работоспособность приложений OpenXR даже при использовании на оборудовании, "
"которого не существовало на момент выпуска приложения, или к которому у "
"разработчиков приложения не было доступа."

msgid ""
"A consequence of this is that the application developer doesn't know with "
"any certainty what hardware is being used, as the XR runtime could be "
"mimicking other hardware. The application developer thus can't show anything "
"in relation to the actual hardware used, the most common use case being "
"showing the controllers the user is currently holding."
msgstr ""
"Следствием этого является то, что разработчик приложения не может точно "
"знать, какое оборудование используется, поскольку среда выполнения XR может "
"имитировать другое оборудование. Таким образом, разработчик приложения не "
"может показать ничего, связанного с фактически используемым оборудованием. "
"Наиболее распространённый вариант использования — отображение контроллеров, "
"которые в данный момент держит пользователь."

msgid ""
"Showing the correct controller models and having these models correctly "
"positioned is important to a proper sense of immersion."
msgstr ""
"Демонстрация правильных моделей контроллеров и их правильное расположение "
"важны для создания ощущения полного погружения."

msgid ""
"This is where OpenXR's `render models API <https://registry.khronos.org/"
"OpenXR/specs/1.1/html/xrspec.html#XR_EXT_render_models>`_ comes in. This API "
"allows us to query the XR runtime for 3D assets that are correct for the "
"physical hardware being used. The API also allows us to query the position "
"of this hardware within the tracking volume and the correct positioning of "
"subcomponents of this hardware."
msgstr ""
"Именно здесь на помощь приходит `API рендеринга моделей OpenXR <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_render_models>`_. Этот API позволяет нам запрашивать у "
"среды выполнения XR 3D-ресурсы, соответствующие используемому физическому "
"оборудованию. API также позволяет нам запрашивать положение этого "
"оборудования в области отслеживания и корректное позиционирование его "
"подкомпонентов."

msgid ""
"For instance, we can correctly position and animate the trigger or show "
"buttons being pressed."
msgstr ""
"Например, мы можем правильно расположить и анимировать триггер или показать "
"нажатие кнопок."

msgid ""
"For those runtimes that support the `controller data source for hand "
"tracking <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_tracking_data_source>`_ , we can also correctly "
"position the user's fingers and hand according to the shape of the "
"controller. Do note that this works in combination with the `hand joints "
"motion range extension <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_joints_motion_range>`_ to prevent clipping of the "
"fingers."
msgstr ""
"В средах выполнения, поддерживающих `источник данных контроллера для "
"отслеживания рук <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_tracking_data_source>`_, мы также можем корректно "
"позиционировать пальцы и кисть пользователя в соответствии с формой "
"контроллера. Обратите внимание, что это работает в сочетании с `расширением "
"диапазона движения суставов руки <https://registry.khronos.org/OpenXR/specs/"
"1.1/html/xrspec.html#XR_EXT_hand_joints_motion_range>`_, чтобы предотвратить "
"застревание пальцев."

msgid "OpenXR Render models node"
msgstr "Узел моделей рендеринга OpenXR"

msgid ""
"The :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node can "
"be used to automate most of the render models functionality. This node keeps "
"track of the active render models currently made available by the XR runtime."
msgstr ""
"Узел :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` можно "
"использовать для автоматизации большинства функций рендеринга моделей. Этот "
"узел отслеживает активные рендеринг-модели, доступные в данный момент в "
"среде выполнения XR."

msgid ""
"It will create child nodes for each active render model resulting in that "
"render model being displayed."
msgstr ""
"Он создаст дочерние узлы для каждой активной модели рендеринга, в результате "
"чего будет отображена эта модель рендеринга."

msgid ""
"This node must have an :ref:`XROrigin3D<class_XROrigin3D>` node as an "
"ancestor."
msgstr ""
"Этот узел должен иметь узел :ref:`XROrigin3D<class_XROrigin3D>` в качестве "
"предка."

msgid ""
"If ``tracker`` is set to ``Any`` our node will show all render models "
"currently being tracked. In this scenario this node must be a direct child "
"of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"Если для ``tracker`` задано значение ``Any``, наш узел будет отображать все "
"отслеживаемые в данный момент модели рендеринга. В этом случае этот узел "
"должен быть прямым дочерним узлом нашего "
"узла :ref:`XROrigin3D<class_XROrigin3D>`."

msgid ""
"If ``tracker`` is set to ``None set`` our node will only show render models "
"for which no tracker has been identified. In this scenario this node must "
"also be a direct child of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"Если для ``tracker`` задано значение ``None set``, наш узел будет отображать "
"только модели рендеринга, для которых не идентифицирован трекер. В этом "
"случае этот узел также должен быть прямым дочерним узлом нашего "
"узла :ref:`XROrigin3D<class_XROrigin3D>`."

msgid ""
"If ``tracker`` is set to ``Left Hand`` or ``Right Hand`` our node will only "
"show render models related to our left or right hand respectively. In this "
"scenario, our node can be placed deeper in the scene tree."
msgstr ""
"Если ``tracker`` установлен на ``Left Hand`` или ``Right Hand``, наш узел "
"будет отображать только модели рендеринга, относящиеся к левой или правой "
"руке соответственно. В этом случае наш узел можно разместить глубже в дереве "
"сцены."

msgid ""
"For most XR runtimes this means the render model represents a controller "
"that is actually being held by the user but this is not a guarantee. Some XR "
"runtimes will always set the tracker to either the left or right hand even "
"if the controller is not currently held but is being tracked. You should "
"always test this as this will lead to unwanted behavior."
msgstr ""
"Для большинства сред выполнения XR это означает, что модель рендеринга "
"представляет собой контроллер, который фактически находится в руках "
"пользователя, но это не гарантируется. Некоторые среды выполнения XR всегда "
"устанавливают трекер либо на левую, либо на правую руку, даже если "
"контроллер в данный момент не находится в руках, но отслеживается. Всегда "
"проверяйте это, так как это может привести к нежелательному поведению."

msgid ""
"In this scenario we can also specify an action for a pose in the action map "
"by setting the ``make_local_to_pose`` property to the pose action. Use this "
"in combination with an :ref:`XRController3D<class_XRController3D>` node that "
"is using the same pose and you can now add a layer that allows you to "
"deviate from the tracked position of both your controller and the related "
"render model (see example below)."
msgstr ""
"В этом сценарии мы также можем указать действие для позы на карте действий, "
"установив свойство ``make_local_to_pose`` для действия позы. Используйте это "
"в сочетании с узлом :ref:`XRController3D<class_XRController3D>`, который "
"использует ту же позу, и теперь вы можете добавить слой, позволяющий "
"отклоняться от отслеживаемого положения как вашего контроллера, так и "
"связанной с ним модели рендеринга (см. пример ниже)."

msgid ""
"Combining the above with hand tracking does introduce the problem that hand "
"tracking is completely independent from the action map system. You will need "
"to combine the hand tracking and controller tracking poses to properly "
"offset the render models."
msgstr ""
"Сочетание вышеперечисленного с отслеживанием рук приводит к проблеме, "
"поскольку отслеживание рук полностью независимо от системы карт действий. "
"Вам потребуется объединить отслеживание рук и позы отслеживания контроллера "
"для правильного смещения моделей рендеринга."

msgid "This falls beyond the scope of this documentation."
msgstr "Это выходит за рамки данной документации."

msgid "Render model manager example"
msgstr "Пример менеджера моделей рендеринга"

msgid ""
"You can download `our render models demo <https://github.com/godotengine/"
"godot-demo-projects/tree/master/xr/openxr_render_models>`_ which implements "
"the setup described below."
msgstr ""
"Вы можете загрузить `нашу демонстрационную версию моделей рендеринга "
"<https://github.com/godotengine/godot-demo-projects/tree/master/xr/"
"openxr_render_models>`_, которая реализует описанную ниже настройку."

msgid ""
"In this setup we find "
"an :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node "
"directly underneath our :ref:`XROrigin3D<class_XROrigin3D>` node. On this "
"node our ``target`` property is set to ``None set`` and will handle showing "
"all render models that are currently not related to our left or right hand "
"controllers."
msgstr ""
"В этой настройке мы находим "
"узел :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` "
"непосредственно под нашим узлом :ref:`XROrigin3D<class_XROrigin3D>`. В этом "
"узле наше свойство ``target`` установлено в ``None set`` и будет "
"обрабатывать отображение всех моделей рендеринга, которые в данный момент не "
"связаны с нашими левым или правым контроллерами."

msgid ""
"We then see the same setup for our left and right hand so we'll focus on "
"just the left hand."
msgstr ""
"Затем мы видим ту же самую установку для левой и правой руки, поэтому "
"сосредоточимся только на левой руке."

msgid ""
"We have an :ref:`XRController3D<class_XRController3D>` that will track the "
"location of our hand."
msgstr ""
"У нас есть :ref:`XRController3D<class_XRController3D>`, который будет "
"отслеживать местоположение нашей руки."

msgid ""
"We are using the ``grip`` pose in this example. The ``palm`` pose is "
"arguably more suitable and predictable however it is not supported by all XR "
"runtimes. See the hand tracking demo project for a solution to switching "
"between these poses based on what is supported."
msgstr ""
"В этом примере мы используем позу ``grip``«хват». Поза ``palm`` «ладонь», "
"возможно, более подходящая и предсказуемая, однако она поддерживается не "
"всеми средами выполнения XR. Решение переключения между этими позами в "
"зависимости от поддерживаемых конфигураций можно найти в демонстрационном "
"проекте отслеживания рук."

msgid ""
"As a child of the node we have "
"an :ref:`AnimatableBody3D<class_AnimatableBody3D>` node that follows the "
"tracked location of the hand **but** will interact with physics objects to "
"stop the player's hand from going through walls etc. This node has a "
"collision shape that encapsulates the hand."
msgstr ""
"В качестве дочернего элемента узла у нас есть "
"узел :ref:`AnimatableBody3D<class_AnimatableBody3D>`, который следует за "
"отслеживаемым местоположением руки, **но** будет взаимодействовать с "
"физическими объектами, чтобы не дать руке игрока пройти сквозь стены и т. д. "
"Этот узел имеет форму столкновения, которая инкапсулирует руку."

msgid ""
"It is important to set the physics priority so that this logic runs after "
"any physics logic that moves the XROrigin3D node or the hand will lag a "
"frame behind."
msgstr ""
"Важно установить приоритет физики так, чтобы эта логика выполнялась после "
"любой физической логики, которая перемещает узел XROrigin3D, иначе рука "
"будет отставать на кадр."

msgid ""
"The script below shows a basic implementation for this that you can build "
"upon."
msgstr ""
"Приведенный ниже сценарий демонстрирует базовую реализацию этого решения, "
"которую вы можете использовать в качестве основы."

msgid ""
"Finally we see "
"another :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` "
"node, this one with ``target`` set to the appropriate hand and "
"``make_local_to_pose`` set to the correct pose. This will ensure that the "
"render models related to this hand are properly shown and offset if our "
"collision handler has altered the location."
msgstr ""
"Наконец, мы видим ещё один "
"узел :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>`, в "
"котором ``target`` соответствует соответствующей руке, а "
"``make_local_to_pose`` — правильной позе. Это гарантирует, что модели "
"рендеринга, связанные с этой рукой, будут отображаться и смещаться, если наш "
"обработчик столкновений изменит местоположение."

msgid "Render model node"
msgstr "Узел модели рендеринга"

msgid ""
"The :ref:`OpenXRRenderModel<class_OpenXRRenderModel>` node implements all "
"the logic to display and position a given render model provided by the "
"render models API."
msgstr ""
"Узел :ref:`OpenXRRenderModel<class_OpenXRRenderModel>` реализует всю логику "
"для отображения и позиционирования заданной модели рендеринга, "
"предоставляемой API моделей рендеринга."

msgid ""
"Instances of this node are added by the render model manager node we used up "
"above but you can interact with these directly if you wish."
msgstr ""
"Экземпляры этого узла добавляются узлом менеджера моделей рендеринга, "
"который мы использовали выше, но при желании вы можете взаимодействовать с "
"ними напрямую."

msgid ""
"Whenever Godot obtains information about a new render model an RID is "
"created to reference that render model."
msgstr ""
"Всякий раз, когда Godot получает информацию о новой модели рендеринга, "
"создается RID для ссылки на эту модель рендеринга."

msgid ""
"By assigning that RID to the ``render_model`` property on this node, the "
"node will start displaying the render model and manage both the transform "
"that places the render model in the correct place and animates all the sub "
"objects."
msgstr ""
"Назначив этот RID свойству ``render_model`` этого узла, узел начнет "
"отображать модель рендеринга и управлять как преобразованием, которое "
"помещает модель рендеринга в правильное место, так и анимацией всех "
"подобъектов."

msgid ""
"The ``get_top_level_path`` function will return the top level path "
"associated with this render model. This will point to either the left or "
"right hand. As the top level path can be set or cleared depending on whether "
"the user picks up, or puts down, the controller you can connect to the "
"``render_model_top_level_path_changes`` signal and react to these changes."
msgstr ""
"Функция ``get_top_level_path`` вернет путь верхнего уровня, связанный с этой "
"моделью рендеринга. Он будет указывать либо на левую, либо на правую руку. "
"Поскольку путь верхнего уровня может быть установлен или удален в "
"зависимости от того, поднимает ли пользователь контроллер или опускает его, "
"вы можете подключиться к сигналу ``render_model_top_level_path_changes`` и "
"реагировать на эти изменения."

msgid ""
"Depending on your setup of "
"the :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` nodes, "
"render models will be removed or added as their top level path changes."
msgstr ""
"В зависимости от настройки "
"узлов :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>`, "
"модели рендеринга будут удаляться или добавляться по мере изменения их пути "
"верхнего уровня."

msgid "Backend access"
msgstr "Внутренний доступ"

msgid ""
"The nodes we've detailed out above handle all the display logic for us but "
"it is possible to interact with the data that drives this directly and "
"create your own implementation."
msgstr ""
"Узлы, которые мы подробно описали выше, обрабатывают всю логику отображения, "
"но можно напрямую взаимодействовать с данными, которые этим управляют, и "
"создавать собственную реализацию."

msgid ""
"For this you can access "
"the :ref:`OpenXRRenderModelExtension<class_OpenXRRenderModelExtension>` "
"singleton."
msgstr ""
"Для этого можно обратиться к "
"синглтону :ref:`OpenXRRenderModelExtension<class_OpenXRRenderModelExtension>`."

msgid ""
"This object also lets you query whether render models are supported and "
"enabled on the device currently being used by calling the ``is_active`` "
"function on this object."
msgstr ""
"Этот объект также позволяет вам запрашивать, поддерживаются ли и включены ли "
"модели рендеринга на текущем устройстве, вызывая функцию ``is_active`` для "
"этого объекта."

msgid ""
"The built-in logic implements the `interaction render model API <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_interaction_render_model>`_ that lists all render models "
"related to controllers and similar devices that are present in the action "
"map. It will automatically create and remove render model entities that are "
"exposed through this API."
msgstr ""
"Встроенная логика реализует `API модели рендеринга взаимодействия <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_interaction_render_model>`_, который выводит список всех "
"моделей рендеринга, связанных с контроллерами и аналогичными устройствами, "
"представленными на карте действий. Он автоматически создает и удаляет "
"сущности моделей рендеринга, доступные через этот API."

msgid ""
"As other extensions become available these can be implemented in a "
"GDExtension plugin. Such a plugin can call ``render_model_create`` and "
"``render_model_destroy`` to create the object that will provide access to "
"that render model through the core render models API."
msgstr ""
"По мере появления других расширений их можно будет реализовать в плагине "
"GDExtension. Такой плагин может вызывать ``render_model_create`` и "
"``render_model_destroy`` для создания объекта, который обеспечит доступ к "
"этой модели рендеринга через API базовых моделей рендеринга."

msgid "You should not destroy a render model outside of this logic."
msgstr "Не следует уничтожать модель рендеринга вне этой логики."

msgid ""
"You can connect to the ``render_model_added`` and ``render_model_removed`` "
"signals to be informed when new render models are added or removed."
msgstr ""
"Вы можете подключиться к сигналам ``render_model_added`` и "
"``render_model_removed``, чтобы получать уведомления о добавлении или "
"удалении новых моделей рендеринга."

msgid "The core methods for working with this API are listed below:"
msgstr "Основные методы работы с этим API перечислены ниже:"

msgid "Render modele extension functions"
msgstr "Функции расширения Render modele"

msgid "Function"
msgstr "Функция"

msgid "Description"
msgstr "Описание"

msgid "render_model_get_all"
msgstr "render_model_get_all"

msgid "Provides an array of RIDs for all render models that are being tracked."
msgstr "Предоставляет массив RID-ов для всех отслеживаемых моделей рендеринга."

msgid "render_model_new_scene_instance"
msgstr "render_model_new_scene_instance"

msgid ""
"Provides a new scene that contains all meshes needed to display the render "
"model."
msgstr ""
"Предоставляет новую сцену, содержащую все сетки, необходимые для отображения "
"модели рендеринга."

msgid "render_model_get_subaction_paths"
msgstr "render_model_get_subaction_paths"

msgid ""
"Provides a list of subaction paths from your action map related to this "
"render mode."
msgstr ""
"Предоставляет список путей поддействий из вашей карты действий, связанных с "
"этим режимом рендеринга."

msgid "render_model_get_top_level_path"
msgstr "render_model_get_top_level_path"

msgid ""
"Returns the top level path associated with this render model (if any). Use "
"the ``render_model_top_level_path_changed`` signal to react to this changing."
msgstr ""
"Возвращает путь верхнего уровня, связанный с этой моделью рендеринга (если "
"таковой имеется). Используйте сигнал "
"``render_model_top_level_path_changed``, чтобы отреагировать на это "
"изменение."

msgid "render_model_get_confidence"
msgstr "render_model_get_confidence"

msgid ""
"Returns the tracking confidence for the tracking data for this render model."
msgstr ""
"Возвращает достоверность отслеживания для данных отслеживания для этой "
"модели рендеринга."

msgid "render_model_get_root_transform"
msgstr "render_model_get_root_transform"

msgid ""
"Returns the root transform for this render model within our current "
"reference space. This can be used to place the render model in space."
msgstr ""
"Возвращает корневое преобразование для данной модели рендеринга в текущем "
"пространстве отсчета. Это преобразование можно использовать для размещения "
"модели рендеринга в пространстве."

msgid "render_model_get_animatable_node_count"
msgstr "render_model_get_animatable_node_count"

msgid ""
"Returns the number of nodes in our render model scene that can be animated"
msgstr ""
"Возвращает количество узлов в нашей сцене модели рендеринга, которые можно "
"анимировать"

msgid "render_model_get_animatable_node_name"
msgstr "render_model_get_animatable_node_name"

msgid ""
"Returns the name of the node that we can animate. Note that this node can be "
"any number of levels deep within the scene."
msgstr ""
"Возвращает имя узла, который можно анимировать. Обратите внимание, что этот "
"узел может находиться на любом количестве уровней в глубину сцены."

msgid "render_model_is_animatable_node_visible"
msgstr "render_model_is_animatable_node_visible"

msgid "Returns true if this animatable node should be visible"
msgstr "Возвращает true, если этот анимируемый узел должен быть видимым"

msgid "render_model_get_animatable_node_transform"
msgstr "render_model_get_animatable_node_transform"

msgid ""
"Returns the transform for this animatable node. This is a local transform "
"that can be directly applied."
msgstr ""
"Возвращает преобразование для данного анимируемого узла. Это локальное "
"преобразование, которое можно применить напрямую."
