#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "A better XR start script"
msgstr "Лучший сценарий запуска XR"

msgid ""
"In :ref:`doc_setting_up_xr` we introduced a startup script that initialises "
"our setup which we used as our script on our main node. This script performs "
"the minimum steps required for any given interface."
msgstr ""
"В :ref:`doc_setting_up_xr` мы представили стартовый скрипт, который "
"инициализирует нашу настройку, которую мы использовали в качестве скрипта на "
"нашем главном узле. Этот скрипт выполняет минимально необходимые действия "
"для любого интерфейса."

msgid ""
"When using OpenXR there are a number of improvements we should do here. For "
"this we've created a more elaborate starting script. You will find these "
"used in our demo projects."
msgstr ""
"При использовании OpenXR необходимо внести ряд улучшений. Для этого мы "
"создали более сложный стартовый скрипт. Вы найдёте его применение в наших "
"демонстрационных проектах."

msgid ""
"Alternatively, if you are using XR Tools "
"(see :ref:`doc_introducing_xr_tools`) it contains a version of this script "
"updated with some features related to XR tools."
msgstr ""
"В качестве альтернативы, если вы используете XR Tools "
"(см. :ref:`doc_introducing_xr_tools`), он содержит версию этого скрипта, "
"обновленную некоторыми функциями, связанными с инструментами XR."

msgid ""
"Below we will detail out the script used in our demos and explain the parts "
"that are added."
msgstr ""
"Ниже мы подробно опишем скрипт, используемый в наших демонстрациях, и "
"объясним добавленные части."

msgid "Signals for our script"
msgstr "Сигналы для нашего сценария"

msgid ""
"We are introducing 3 signals to our script so that our game can add further "
"logic:"
msgstr ""
"Мы вводим в наш скрипт 3 сигнала, чтобы наша игра могла добавлять "
"дополнительную логику:"

msgid ""
"``focus_lost`` is emitted when the player takes off their headset or when "
"the player enters the menu system of the headset."
msgstr ""
"``focus_lost`` издается, когда игрок снимает гарнитуру или входит в "
"системное меню гарнитуры."

msgid ""
"``focus_gained`` is emitted when the player puts their headset back on or "
"exits the menu system and returns to the game."
msgstr ""
"``focus_gained`` издается, когда игрок снова надевает гарнитуру или выходит "
"из меню и возвращается в игру."

msgid ""
"``pose_recentered`` is emitted when the headset requests the player's "
"position to be reset."
msgstr ""
"``pose_recentered`` выдается, когда гарнитура запрашивает сброс позиции "
"игрока."

msgid "Our game should react accordingly to these signals."
msgstr "Наша игра должна соответствующим образом реагировать на эти сигналы."

msgid "Variables for our script"
msgstr "Переменные для нашего скрипта"

msgid "We introduce a few new variables to our script as well:"
msgstr "Мы также вводим в наш скрипт несколько новых переменных:"

msgid ""
"``maximum_refresh_rate`` will control the headsets refresh rate if this is "
"supported by the headset."
msgstr ""
"``maximum_refresh_rate`` будет управлять частотой обновления гарнитуры, если "
"она поддерживается гарнитурой."

msgid ""
"``xr_interface`` holds a reference to our XR interface, this already existed "
"but we now type it to get full access to our :ref:`XRInterface "
"<class_xrinterface>` API."
msgstr ""
"``xr_interface`` содержит ссылку на наш интерфейс XR, он уже существовал, но "
"теперь мы вводим его, чтобы получить полный доступ к нашему "
"API :ref:`XRInterface <class_xrinterface>`."

msgid "``xr_is_focussed`` will be set to true whenever our game has focus."
msgstr ""
"``xr_is_focussed`` будет установлено в значение true всякий раз, когда наша "
"игра имеет фокус."

msgid "Our updated ready function"
msgstr "Наша обновленная функция ready"

msgid "We add a few things to the ready function."
msgstr "Мы добавляем несколько вещей в функцию ready."

msgid ""
"If we're using the mobile or forward+ renderer we set the viewport's "
"``vrs_mode`` to ``VRS_XR``. On platforms that support this, this will enable "
"foveated rendering."
msgstr ""
"При использовании mobile или forward+ рендера мы устанавливаем ``vrs_mode`` "
"области просмотра на ``VRS_XR``. На платформах, которые поддерживают эту "
"функцию, это включит фовеальный рендеринг."

msgid ""
"If we're using the compatibility renderer, we check if the OpenXR foveated "
"rendering settings are configured and if not, we output a warning. "
"See :ref:`OpenXR Settings <doc_openxr_settings>` for further details."
msgstr ""
"Если мы используем совместимый рендерер, мы проверяем, настроены ли "
"параметры фовеального рендеринга OpenXR, и если нет, выводим предупреждение. "
"Подробнее см. в разделе :ref:`OpenXR Settings <doc_openxr_settings>`."

msgid ""
"We hook up a number of signals that will be emitted by the :ref:`XRInterface "
"<class_xrinterface>`. We'll provide more detail about these signals as we "
"implement them."
msgstr ""
"Мы подключаем ряд сигналов, которые будут испускаться :ref:`XRInterface "
"<class_xrinterface>`. Мы предоставим более подробную информацию об этих "
"сигналах по мере их реализации."

msgid ""
"We also quit our application if we couldn't successfully initialise OpenXR. "
"Now this can be a choice. If you are making a mixed mode game you setup the "
"VR mode of your game on success, and setup the non-VR mode of your game on "
"failure. However, when running a VR only application on a standalone "
"headset, it is nicer to exit on failure than to hang the system."
msgstr ""
"Мы также завершаем работу приложения, если не удалось успешно "
"инициализировать OpenXR. Теперь это может быть вариантом. Если вы создаёте "
"игру со смешанным режимом, вы настраиваете режим VR при успешном завершении "
"и режим без VR при сбое. Однако при запуске приложения, использующего только "
"VR, на автономной гарнитуре лучше завершить работу при сбое, чем вызвать "
"зависание системы."

msgid "On session begun"
msgstr "Начало сеанса"

msgid ""
"This signal is emitted by OpenXR when our session is setup. This means the "
"headset has run through setting everything up and is ready to begin "
"receiving content from us. Only at this time various information is properly "
"available."
msgstr ""
"Этот сигнал OpenXR испускает при настройке сеанса. Это означает, что "
"гарнитура завершила все необходимые настройки и готова к приёму контента. "
"Только в этот момент различная информация становится доступной."

msgid ""
"The main thing we do here is to check our headset's refresh rate. We also "
"check the available refresh rates reported by the XR runtime to determine if "
"we want to set our headset to a higher refresh rate."
msgstr ""
"Главное, что мы делаем здесь, — это проверяем частоту обновления нашей "
"гарнитуры. Мы также проверяем доступные частоты обновления, сообщаемые "
"средой выполнения XR, чтобы определить, нужно ли установить более высокую "
"частоту обновления для нашей гарнитуры."

msgid ""
"Finally we match our physics update rate to our headset update rate. Godot "
"runs at a physics update rate of 60 updates per second by default while "
"headsets run at a minimum of 72, and for modern headsets often up to 144 "
"frames per second. Not matching the physics update rate will cause "
"stuttering as frames are rendered without objects moving."
msgstr ""
"Наконец, мы подбираем частоту обновления физики под частоту обновления "
"гарнитуры. Godot по умолчанию работает с частотой обновления физики 60 "
"кадров в секунду, в то время как гарнитуры работают минимум с 72 кадрами в "
"секунду, а современные гарнитуры часто достигают 144 кадров в секунду. "
"Несоответствие частоты обновления физики приведёт к подтормаживанию, "
"поскольку кадры рендерятся без движения объектов."

msgid "On visible state"
msgstr "В видимом состоянии"

msgid ""
"This signal is emitted by OpenXR when our game becomes visible but is not "
"focused. This is a bit of a weird description in OpenXR but it basically "
"means that our game has just started and we're about to switch to the "
"focused state next, that the user has opened a system menu or the user has "
"just took their headset off."
msgstr ""
"Этот сигнал испускается OpenXR, когда игра становится видимой, но не "
"находится в фокусе. Это немного странное описание в OpenXR, но по сути это "
"означает, что игра только что запущена и мы собираемся перейти в состояние "
"фокуса, что пользователь открыл системное меню или только что снял гарнитуру."

msgid ""
"On receiving this signal we'll update our focused state, we'll change the "
"process mode of our node to disabled which will pause processing on this "
"node and its children, and emit our ``focus_lost`` signal."
msgstr ""
"Получив этот сигнал, мы обновим наше сфокусированное состояние, изменим "
"режим процесса нашего узла на отключенный, что приостановит обработку этого "
"узла и его дочерних элементов, и выдадим наш сигнал ``focus_lost``."

msgid ""
"If you've added this script to your root node, this means your game will "
"automatically pause when required. If you haven't, you can connect a method "
"to the signal that performs additional changes."
msgstr ""
"Если вы добавили этот скрипт в корневой узел, игра будет автоматически "
"останавливаться при необходимости. Если вы этого не сделали, вы можете "
"подключить к сигналу метод, который выполняет дополнительные изменения."

msgid ""
"While your game is in visible state because the user has opened a system "
"menu, Godot will keep rendering frames and head tracking will remain active "
"so your game will remain visible in the background. However controller and "
"hand tracking will be disabled until the user exits the system menu."
msgstr ""
"Пока ваша игра находится в видимом состоянии, поскольку пользователь открыл "
"системное меню, Godot продолжит рендеринг кадров, а отслеживание положения "
"головы останется активным, так что игра будет видна в фоновом режиме. Однако "
"отслеживание контроллера и рук будет отключено до тех пор, пока пользователь "
"не выйдет из системного меню."

msgid "On focussed state"
msgstr "В сосредоточенном состоянии"

msgid ""
"This signal is emitted by OpenXR when our game gets focus. This is done at "
"the completion of our startup, but it can also be emitted when the user "
"exits a system menu, or put their headset back on."
msgstr ""
"Этот сигнал выдаётся OpenXR, когда игра получает фокус. Это происходит по "
"завершении запуска, но он также может выдаваться, когда пользователь выходит "
"из системного меню или снова надевает гарнитуру."

msgid ""
"Note also that when your game starts while the user is not wearing their "
"headset, the game stays in 'visible' state until the user puts their headset "
"on."
msgstr ""
"Также обратите внимание, что если игра запускается, а пользователь не надел "
"гарнитуру, игра остается в 'видимом' состоянии до тех пор, пока пользователь "
"не наденет гарнитуру."

msgid ""
"It is thus important to keep your game paused while in visible mode. If you "
"don't the game will keep on running while your user isn't interacting with "
"your game. Also when the game returns to the focused mode, suddenly all "
"controller and hand tracking is re-enabled and could have game breaking "
"consequences if you do not react to this accordingly. Be sure to test this "
"behavior in your game!"
msgstr ""
"Поэтому важно ставить игру на паузу в режиме видимости. Если этого не "
"сделать, игра продолжит работать, пока пользователь не взаимодействует с "
"ней. Кроме того, когда игра возвращается в режим фокусировки, всё "
"отслеживание контроллера и рук внезапно включается снова, что может привести "
"к сбоям в игре, если вы не отреагируете соответствующим образом. Обязательно "
"протестируйте это поведение в своей игре!"

msgid ""
"While handling our signal we will update the focuses state, unpause our node "
"and emit our ``focus_gained`` signal."
msgstr ""
"При обработке нашего сигнала мы обновим состояние фокуса, возобновим работу "
"нашего узла и отправим сигнал ``focus_gained``."

msgid "On stopping state"
msgstr "В состоянии остановки"

msgid ""
"This signal is emitted by OpenXR when we enter our stop state. There are "
"some differences between platforms when this happens. On some platforms this "
"is only emitted when the game is being closed. But on other platforms this "
"will also be emitted every time the player takes off their headset."
msgstr ""
"Этот сигнал выдаётся OpenXR при переходе в состояние остановки. Время "
"появления этого сигнала может различаться на разных платформах. На некоторых "
"платформах он выдаётся только при закрытии игры. На других платформах он "
"также выдаётся каждый раз, когда игрок снимает гарнитуру."

msgid "For now this method is only a place holder."
msgstr "На данный момент этот метод является лишь временным."

msgid "On pose recentered"
msgstr "В центрированной позе"

msgid ""
"This signal is emitted by OpenXR when the user requests their view to be "
"recentered. Basically this communicates to your game that the user is now "
"facing forward and you should re-orient the player so they are facing "
"forward in the virtual world."
msgstr ""
"Этот сигнал отправляется OpenXR, когда пользователь запрашивает "
"центрирование своего взгляда. По сути, это сообщает вашей игре, что "
"пользователь теперь смотрит вперёд, и вам следует переориентировать игрока "
"так, чтобы он смотрел вперёд в виртуальном мире."

msgid ""
"As doing so is dependent on your game, your game needs to react accordingly."
msgstr ""
"Поскольку это зависит от вашей игры, ваша игра должна реагировать "
"соответствующим образом."

msgid ""
"All we do here is emit the ``pose_recentered`` signal. You can connect to "
"this signal and implement the actual recenter code. Often it is enough to "
"call :ref:`center_on_hmd() <class_XRServer_method_center_on_hmd>`."
msgstr ""
"Всё, что мы делаем здесь, — это посылаем сигнал ``pose_recentered``. Вы "
"можете подключиться к этому сигналу и реализовать код рецентрирования. Часто "
"достаточно вызвать :ref:`center_on_hmd() "
"<class_XRServer_method_center_on_hmd>`."

msgid ""
"And that finished our script. It was written so that it can be re-used over "
"multiple projects. Just add it as the script on your main node (and extend "
"it if needed) or add it on a child node specific for this script."
msgstr ""
"На этом наш скрипт готов. Он был написан так, чтобы его можно было "
"использовать повторно в нескольких проектах. Просто добавьте его в качестве "
"скрипта на основной узел (и при необходимости расширьте) или добавьте на "
"дочерний узел, предназначенный специально для этого скрипта."
