#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR composition layers"
msgstr "Слои композиции OpenXR"

msgid "Introduction"
msgstr "Введение"

msgid ""
"In XR games you generally want to create user interactions that happen in 3D "
"space and involve users touching objects as if they are touching them in "
"real life."
msgstr ""
"В XR-играх обычно требуется создавать пользовательские взаимодействия, "
"которые происходят в трехмерном пространстве и предполагают прикосновение "
"пользователей к объектам так, как будто они касаются их в реальной жизни."

msgid ""
"Sometimes however creating a more traditional 2D interface is unavoidable. "
"In XR however you can't just add 2D components to your scene. Godot needs "
"depth information to properly position these elements so they appear at a "
"comfortable place for the user. Even with depth information there are "
"headsets with slanted displays that make it impossible for the standard 2D "
"pipeline to correctly render the 2D elements."
msgstr ""
"Однако иногда создание более традиционного 2D-интерфейса неизбежно. В XR, "
"однако, нельзя просто добавить 2D-компоненты в сцену. Godot нужна информация "
"о глубине для правильного расположения этих элементов, чтобы они "
"отображались в удобном для пользователя месте. Даже с информацией о глубине "
"существуют гарнитуры с наклонными дисплеями, из-за чего стандартный конвейер "
"2D-графики не может корректно отрисовывать 2D-элементы."

msgid ""
"The solution then is to render the UI to a :ref:`SubViewport "
"<class_subviewport>` and display the result of this using "
"a :ref:`ViewportTexture <class_viewporttexture>` on a 3D mesh. "
"The :ref:`QuadMesh <class_quadmesh>` is a suitable option for this."
msgstr ""
"Решение заключается в том, чтобы визуализировать пользовательский интерфейс "
"в :ref:`SubViewport <class_subviewport>` и отобразить результат с "
"помощью :ref:`ViewportTexture <class_viewporttexture>` на 3D-сетке. Для "
"этого хорошо подходит :ref:`QuadMesh <class_quadmesh>`."

msgid ""
"See the `GUI in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/gui_in_3d>`_ example project for an example of this approach."
msgstr ""
"Пример такого подхода см. в примере проекта `GUI in 3D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`_."

msgid ""
"The problem with displaying the viewport in this way is that the rendered "
"result is sampled for lens distortion by the XR runtime and the resulting "
"quality loss can make UI text hard to read."
msgstr ""
"Проблема с отображением области просмотра таким способом заключается в том, "
"что визуализированный результат подвергается выборке на предмет искажения "
"объектива средой выполнения XR, и в результате потери качества текст "
"пользовательского интерфейса может стать трудночитаемым."

msgid ""
"OpenXR offers a solution to this problem through composition layers. With "
"composition layers it is possible for the contents of a viewport to be "
"projected on a surface after lens distortion resulting in a much higher "
"quality end result."
msgstr ""
"OpenXR предлагает решение этой проблемы с помощью композиционных слоёв. "
"Благодаря композиционным слоям содержимое области просмотра можно "
"проецировать на поверхность после искажения объектива, что обеспечивает "
"гораздо более высокое качество конечного результата."

msgid ""
"As not all XR runtimes support all composition layer types, Godot implements "
"a fallback solution where we render the viewport as part of the normal scene "
"but with the aforementioned quality limitations."
msgstr ""
"Поскольку не все среды выполнения XR поддерживают все типы слоев композиции, "
"Godot реализует резервное решение, при котором мы визуализируем область "
"просмотра как часть обычной сцены, но с вышеупомянутыми ограничениями "
"качества."

msgid ""
"When the composition layer is supported, it is the XR runtime that presents "
"the subviewport. This means the UI is only visible in the headset, it will "
"not be accessible by Godot and will thus not be shown when you have a "
"spectator view on the desktop."
msgstr ""
"При поддержке слоя композиции подокно просмотра отображается в среде "
"выполнения XR. Это означает, что пользовательский интерфейс виден только в "
"гарнитуре, он недоступен для Godot и, следовательно, не отображается в "
"режиме зрителя на десктопе."

msgid "There are currently 3 nodes that expose this functionality:"
msgstr "В настоящее время эту функциональность реализуют 3 узла:"

msgid ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a cylinder (or "
"\"slice\" of a cylinder)."
msgstr ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"отображает содержимое SubViewport на внутренней стороне цилиндра (или "
"\"части\" цилиндра)."

msgid ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a sphere (or "
"\"slice\" of a sphere)."
msgstr ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"отображает содержимое SubViewport на внутренней стороне сферы (или \"части\" "
"сферы)."

msgid ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a flat rectangle."
msgstr ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` "
"отображает содержимое SubViewport на плоском прямоугольнике."

msgid "Setting up the SubViewport"
msgstr "Настройка SubViewport"

msgid ""
"The first step is adding a SubViewport for our 2D UI, this doesn't require "
"any specific steps. For our example we do mark the viewport as transparent."
msgstr ""
"Первый шаг — добавление подокна просмотра (SubViewport) для нашего 2D-"
"интерфейса. Это не требует никаких специальных действий. В нашем примере мы "
"делаем область просмотра прозрачной."

msgid ""
"You can now create the 2D UI by adding child nodes to the SubViewport as you "
"normally would. It is advisable to save the 2D UI in a subscene, this makes "
"it easier to do your layout."
msgstr ""
"Теперь вы можете создать 2D-интерфейс, добавляя дочерние узлы в SubViewport, "
"как обычно. Рекомендуется сохранить 2D-интерфейс в подсцене, это облегчит "
"создание макета."

msgid ""
"The update mode \"When Visible\" will not work as Godot can't determine "
"whether the viewport is visible to the user. When assigning our viewport to "
"a composition layer Godot will automatically adjust this."
msgstr ""
"Режим обновления \"Когда Видна\" не будет работать, поскольку Godot не "
"сможет определить, видна ли область просмотра пользователю. При назначении "
"области просмотра композиционному слою Godot автоматически настроит это."

msgid "Adding a composition layer"
msgstr "Добавление композиционного слоя"

msgid ""
"The second step is adding our composition layer. We can add the correct "
"composition layer node as a child node of our :ref:`XROrigin3D "
"<class_xrorigin3d>` node. This is very important as the XR runtime positions "
"everything in relation to our origin."
msgstr ""
"Вторым шагом является добавление композиционного слоя. Мы можем добавить "
"нужный узел композиционного слоя как дочерний узел нашего "
"узла :ref:`XROrigin3D <class_xrorigin3d>`. Это очень важно, поскольку среда "
"выполнения XR позиционирует все объекты относительно нашего начала координат."

msgid ""
"We want to position the composition layer so it is at eye height and roughly "
"1 to 1.5 meters away from the player."
msgstr ""
"Мы хотим расположить слой композиции так, чтобы он находился на уровне глаз "
"и примерно на расстоянии 1–1,5 метра от игрока."

msgid ""
"We now assign the SubViewport to the ``Layer Viewport`` property and enable "
"Alpha Blend."
msgstr ""
"Теперь мы назначаем SubViewport свойству ``Layer Viewport`` и включаем Alpha "
"Blend."

msgid ""
"As the player can walk away from the origin point, you will want to "
"reposition the composition layer when the player recenters the view. Using "
"the reference space ``Local Floor`` will apply this logic automatically."
msgstr ""
"Поскольку игрок может отойти от исходной точки, вам потребуется изменить "
"положение слоя композиции, когда игрок центрирует вид. Использование "
"опорного пространства ``Local Floor`` автоматически применит эту логику."

msgid "Making the interface work"
msgstr "Заставить интерфейс работать"

msgid ""
"So far we're only displaying our UI, to make it work we need to add some "
"code. For this example we're going to keep things simple and make one of the "
"controllers work as a pointer. We'll then simulate mouse actions with this "
"pointer."
msgstr ""
"Пока что мы только отображаем наш пользовательский интерфейс, чтобы он "
"заработал, нам нужно добавить немного кода. В этом примере мы не будем "
"усложнять и сделаем один из контроллеров указателем. Затем мы будем "
"имитировать действия мыши с помощью этого указателя."

msgid ""
"This code also requires a ``MeshInstance3D`` node called ``Pointer`` to be "
"added as a child to our ``OpenXRCompositionLayerQuad`` node. We configure a "
"``SphereMesh`` with a radius ``0.01`` meters. We'll be using this as a "
"helper to visualize where the user is pointing."
msgstr ""
"Этот код также требует добавления узла ``MeshInstance3D`` с именем "
"``Pointer`` в качестве дочернего к нашему узлу "
"``OpenXRCompositionLayerQuad``. Мы настраиваем ``SphereMesh`` с радиусом "
"``0,01`` метра. Мы будем использовать это как вспомогательный элемент для "
"визуализации направления указателя пользователя."

msgid ""
"The main function that drives this functionality is the ``intersects_ray`` "
"function on our composition layer node. This function takes the global "
"position and orientation of our pointer and returns the UV where our ray "
"intersects our viewport. It returns ``Vector2(-1.0, -1.0)`` if we're not "
"pointing at our viewport."
msgstr ""
"Основная функция, управляющая этой функциональностью, — это функция "
"``intersects_ray`` в узле композиционного слоя. Эта функция принимает "
"глобальные координаты и ориентацию указателя и возвращает UV-координату "
"точки пересечения луча с областью просмотра. Если луч не указывает на "
"область просмотра, она возвращает ``Vector2(-1.0, -1.0)``."

msgid ""
"We start with setting up some variables, important here are the export "
"variables which identify our controller node with which we point to our "
"screen."
msgstr ""
"Начнем с настройки некоторых переменных, среди которых важными являются "
"экспортные переменные, идентифицирующие наш узел контроллера, с помощью "
"которого мы указываем на наш экран."

msgid ""
"Next we define a helper function that takes the value returned from "
"``intersects_ray`` and gives us the global position for that intersection "
"point. This implementation only works for our ``OpenXRCompositionLayerQuad`` "
"node."
msgstr ""
"Затем мы определяем вспомогательную функцию, которая принимает значение, "
"возвращаемое ``intersects_ray``, и возвращает нам глобальную позицию этой "
"точки пересечения. Эта реализация работает только для нашего узла "
"``OpenXRCompositionLayerQuad``."

msgid ""
"We also define a helper function that takes our ``intersect`` value and "
"returns our location in the viewport's local coordinate system:"
msgstr ""
"Мы также определяем вспомогательную функцию, которая принимает наше значение "
"``intersect`` и возвращает наше местоположение в локальной системе координат "
"области просмотра:"

msgid ""
"The main logic happens in our ``_process`` function. Here we start by hiding "
"our pointer, we then check if we have a valid controller and viewport, and "
"we call ``intersects_ray`` with the position and orientation of our "
"controller:"
msgstr ""
"Основная логика происходит в нашей функции ``_process``. Здесь мы сначала "
"скрываем указатель, затем проверяем наличие корректного контроллера и "
"области просмотра, а затем вызываем ``intersects_ray``, указывая положение и "
"ориентацию нашего контроллера:"

msgid ""
"Next we check if we're intersecting with our viewport. If so, we check if "
"our button is pressed and place our pointer at our intersection point."
msgstr ""
"Затем мы проверяем, пересекаемся ли мы с областью просмотра. Если да, то "
"проверяем, нажата ли кнопка, и помещаем указатель в точку пересечения."

msgid ""
"If we were intersecting in our previous process call and our pointer has "
"moved, we prepare an :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` object to simulate our mouse moving and send "
"that to our viewport for further processing."
msgstr ""
"Если в нашем предыдущем вызове процесса произошло пересечение и наш "
"указатель переместился, мы подготавливаем объект :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` для имитации движения нашей мыши и отправляем "
"его в нашу область просмотра для дальнейшей обработки."

msgid ""
"If we've just released our button we also prepare "
"an :ref:`InputEventMouseButton <class_InputEventMouseButton>` object to "
"simulate a button release and send that to our viewport for further "
"processing."
msgstr ""
"Если мы только что отпустили кнопку, мы также подготавливаем "
"объект :ref:`InputEventMouseButton <class_InputEventMouseButton>` для "
"имитации отпускания кнопки и отправляем его в нашу область просмотра для "
"дальнейшей обработки."

msgid ""
"Or if we've just pressed our button we prepare "
"an :ref:`InputEventMouseButton <class_InputEventMouseButton>` object to "
"simulate a button press and send that to our viewport for further processing."
msgstr ""
"Или, если мы только что нажали кнопку, мы подготавливаем "
"объект :ref:`InputEventMouseButton <class_InputEventMouseButton>` для "
"имитации нажатия кнопки и отправляем его в область просмотра для дальнейшей "
"обработки."

msgid "Next we remember our state for next frame."
msgstr "Далее мы запоминаем наше состояние для следующего кадра."

msgid "Finally, if we aren't intersecting, we clear our state."
msgstr "Наконец, если мы не пересекаемся, мы очищаем наше состояние."

msgid "Hole punching"
msgstr "Hole punching (Пробивка отверстий)"

msgid ""
"As the composition layer is composited on top of the render result, it can "
"be rendered in front of objects that are actually forward of the viewport."
msgstr ""
"Поскольку слой композиции накладывается поверх результата рендеринга, его "
"можно визуализировать перед объектами, которые фактически находятся впереди "
"области просмотра."

msgid ""
"By enabling hole punch you instruct Godot to render a transparent object "
"where our viewport is displayed. It does this in a way that fills the depth "
"buffer and clears the current rendering result. Anything behind our viewport "
"will now be cleared, while anything in front of our viewport will be "
"rendered as usual."
msgstr ""
"Включая функцию \"hole punch\", вы указываете Godot визуализировать "
"прозрачный объект там, где отображается наша область просмотра. При этом "
"заполняется буфер глубины и очищается текущий результат рендеринга. Всё, что "
"находится за нашей областью просмотра, теперь будет очищено, а всё, что "
"находится перед ней, будет визуализироваться как обычно."

msgid ""
"You also need to set ``Sort Order`` to a negative value, the XR compositor "
"will now draw the viewport first, and then overlay our rendering result."
msgstr ""
"Вам также необходимо установить ``Порядок сортировки`` на отрицательное "
"значение, тогда компоновщик XR сначала отрисует область просмотра, а затем "
"наложит наш результат рендеринга."

msgid ""
"Use case showing how the user's hand is incorrectly obscured by a "
"composition layer when hole punching is not used."
msgstr ""
"Пример использования, демонстрирующий, как рука пользователя неправильно "
"закрывается композиционным слоем, когда перфорация не используется."
