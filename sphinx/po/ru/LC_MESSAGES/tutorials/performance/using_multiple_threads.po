#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using multiple threads"
msgstr "Использование многопоточности"

msgid "Threads"
msgstr "Потоки"

msgid ""
"Threads allow simultaneous execution of code. It allows off-loading work "
"from the main thread."
msgstr ""
"Потоки позволяют выполнять код одновременно. Это позволяет разгрузить работу "
"от основного потока."

msgid "Godot supports threads and provides many handy functions to use them."
msgstr ""
"Godot поддерживает потоки и предоставляет множество удобных функций для их "
"использования."

msgid ""
"If using other languages (C#, C++), it may be easier to use the threading "
"classes they support."
msgstr ""
"При использовании других языков (C#, C++) может быть проще использовать "
"поддерживаемые ими классы потоковой передачи."

msgid ""
"Before using a built-in class in a thread, read :ref:`doc_thread_safe_apis` "
"first to check whether it can be safely used in a thread."
msgstr ""
"Прежде чем использовать встроенный класс в потоке, сначала "
"прочитайте :ref:`doc_thread_safe_apis`, чтобы проверить, можно ли безопасно "
"использовать его в потоке."

msgid "Creating a Thread"
msgstr "Создание потока"

msgid "To create a thread, use the following code:"
msgstr "Чтобы создать поток, используйте следующий код:"

msgid ""
"Your function will, then, run in a separate thread until it returns. Even if "
"the function has returned already, the thread must collect it, so "
"call :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, "
"which will wait until the thread is done (if not done yet), then properly "
"dispose of it."
msgstr ""
"В этом случае ваша функция будет выполняться в отдельном потоке до "
"завершения работы. Даже если функция уже завершилась, поток должен её "
"забрать, поэтому "
"вызовите :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, "
"который дождётся завершения работы потока (если он ещё не завершён), а затем "
"должным образом уничтожит её."

msgid ""
"Creating threads is a slow operation, especially on Windows. To avoid "
"unnecessary performance overhead, make sure to create threads before heavy "
"processing is needed instead of creating threads just-in-time."
msgstr ""
"Создание потоков — медленная операция, особенно в Windows. Чтобы избежать "
"ненужного снижения производительности, создавайте потоки до того, как "
"потребуется интенсивная обработка, а не создавайте их непосредственно перед "
"выполнением."

msgid ""
"For example, if you need multiple threads during gameplay, you can create "
"threads while the level is loading and only actually start processing with "
"them later on."
msgstr ""
"Например, если вам нужно несколько потоков во время игры, вы можете "
"создавать потоки во время загрузки уровня и начинать обработку с ними только "
"позже."

msgid ""
"Additionally, locking and unlocking of mutexes can also be an expensive "
"operation. Locking should be done carefully; avoid locking too often (or for "
"too long)."
msgstr ""
"Кроме того, блокировка и разблокировка мьютексов может быть дорогостоящей "
"операцией. Блокировку следует выполнять осторожно; избегайте слишком частой "
"(или слишком длительной) блокировки."

msgid "Mutexes"
msgstr "Мьютексы"

msgid ""
"Accessing objects or data from multiple threads is not always supported (if "
"you do it, it will cause unexpected behaviors or crashes). Read "
"the :ref:`doc_thread_safe_apis` documentation to understand which engine "
"APIs support multiple thread access."
msgstr ""
"Доступ к объектам или данным из нескольких потоков поддерживается не всегда "
"(это может привести к непредвиденному поведению или сбоям). Ознакомьтесь с "
"документацией :ref:`doc_thread_safe_apis`, чтобы понять, какие API движка "
"поддерживают многопоточный доступ."

msgid ""
"When processing your own data or calling your own functions, as a rule, try "
"to avoid accessing the same data directly from different threads. You may "
"run into synchronization problems, as the data is not always updated between "
"CPU cores when modified. Always use a :ref:`Mutex<class_Mutex>` when "
"accessing a piece of data from different threads."
msgstr ""
"При обработке собственных данных или вызове собственных функций, как "
"правило, старайтесь избегать прямого доступа к одним и тем же данным из "
"разных потоков. Это может привести к проблемам синхронизации, поскольку "
"данные не всегда обновляются между ядрами процессора при изменении. Всегда "
"используйте :ref:`Mutex<class_Mutex>` при доступе к данным из разных потоков."

msgid ""
"When calling :ref:`Mutex.lock()<class_Mutex_method_lock>`, a thread ensures "
"that all other threads will be blocked (put on suspended state) if they try "
"to *lock* the same mutex. When the mutex is unlocked by "
"calling :ref:`Mutex.unlock()<class_Mutex_method_unlock>`, the other threads "
"will be allowed to proceed with the lock (but only one at a time)."
msgstr ""
"При вызове метода :ref:`Mutex.lock()<class_Mutex_method_lock>` поток "
"гарантирует, что все остальные потоки будут заблокированы (переведены в "
"состояние ожидания) при попытке *заблокировать* тот же мьютекс. Когда "
"мьютекс разблокируется вызовом "
"метода :ref:`Mutex.unlock()<class_Mutex_method_unlock>`, остальным потокам "
"будет разрешено продолжить блокировку (но только по одному за раз)."

msgid "Here is an example of using a Mutex:"
msgstr "Вот пример использования мьютекса:"

msgid "Semaphores"
msgstr "Семафоры"

msgid ""
"Sometimes you want your thread to work *\"on demand\"*. In other words, tell "
"it when to work and let it suspend when it isn't doing anything. For "
"this, :ref:`Semaphores<class_Semaphore>` are used. The "
"function :ref:`Semaphore.wait()<class_Semaphore_method_wait>` is used in the "
"thread to suspend it until some data arrives."
msgstr ""
"Иногда требуется, чтобы поток работал *«по требованию»*. Другими словами, "
"нужно указать ему, когда он должен работать, и позволить ему "
"приостанавливаться, когда он ничего не делает. Для этого "
"используются :ref:`Semaphores<class_Semaphore>`. "
"Функция :ref:`Semaphore.wait()<class_Semaphore_method_wait>` используется в "
"потоке для приостановки потока до получения данных."

msgid ""
"The main thread, instead, "
"uses :ref:`Semaphore.post()<class_Semaphore_method_post>` to signal that "
"data is ready to be processed:"
msgstr ""
"Вместо этого основной поток "
"использует :ref:`Semaphore.post()<class_Semaphore_method_post>` для подачи "
"сигнала о готовности данных к обработке:"
