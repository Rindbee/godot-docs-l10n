#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "Оптимизация графического процессора"

msgid "Introduction"
msgstr "Введение"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"Потребность в новых графических функциях и прогресс практически "
"гарантированно приводят к возникновению узких мест в графике. Некоторые из "
"них могут быть связаны с центральным процессором, например, с вычислениями в "
"движке Godot для подготовки объектов к рендерингу. Узкие места могут также "
"возникать в центральном процессоре, в графическом драйвере, который "
"сортирует инструкции для передачи в графический процессор, и при передаче "
"этих инструкций. И наконец, узкие места возникают и в самом графическом "
"процессоре."

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"Узкие места при рендеринге сильно зависят от аппаратного обеспечения. "
"Мобильные видеокарты, в частности, могут испытывать трудности со сценами, "
"которые легко воспроизводятся на настольных компьютерах."

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"Понимание и исследование узких мест графического процессора несколько "
"отличается от ситуации с центральным процессором. Это связано с тем, что "
"зачастую производительность можно изменить только косвенно, изменяя "
"инструкции, передаваемые графическому процессору. Кроме того, проводить "
"измерения может быть сложнее. Во многих случаях единственный способ измерить "
"производительность — это изучить изменения времени, затрачиваемого на "
"рендеринг каждого кадра."

msgid "Draw calls, state changes, and APIs"
msgstr "Вызовы отрисовки, изменения состояния и API-ы"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"Следующий раздел не предназначен для конечных пользователей, но полезен для "
"предоставления справочной информации, которая будет важна в последующих "
"разделах."

msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"Godot отправляет инструкции графическому процессору через графический API "
"(Vulkan, OpenGL, OpenGL ES или WebGL). Соответствующие коммуникации и "
"действия драйвера могут быть весьма затратными, особенно в OpenGL, OpenGL ES "
"и WebGL. Если мы сможем предоставить эти инструкции в удобном для драйвера и "
"графического процессора виде, мы сможем значительно повысить "
"производительность."

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"Практически каждая команда API в OpenGL требует определённой проверки, чтобы "
"убедиться, что графический процессор находится в правильном состоянии. Даже "
"кажущиеся простыми команды могут привести к потоку скрытых действий. Поэтому "
"цель состоит в том, чтобы свести эти инструкции к минимуму и максимально "
"сгруппировать похожие объекты, чтобы их можно было отрисовывать вместе или с "
"минимальным количеством этих дорогостоящих изменений состояния."

msgid "2D batching"
msgstr "2D-партийная обработка"

msgid ""
"In 2D, the costs of treating each item individually can be prohibitively "
"high - there can easily be thousands of them on the screen. This is why 2D "
"*batching* is used. Multiple similar items are grouped together and rendered "
"in a batch, via a single draw call, rather than making a separate draw call "
"for each item. In addition, this means state changes, material and texture "
"changes can be kept to a minimum."
msgstr ""
"В 2D-графике затраты на обработку каждого объекта по отдельности могут быть "
"чрезмерно высокими — на экране их могут легко быть тысячи. Именно поэтому "
"используется 2D-*batching* (пакетирование). Несколько похожих объектов "
"группируются и визуализируются в пакете одним вызовом отрисовки, а не "
"отдельными вызовами отрисовки для каждого объекта. Кроме того, это позволяет "
"свести к минимуму изменения состояний, материалов и текстур."

msgid "3D batching"
msgstr "3D batching (пакетирование)"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"В 3D мы по-прежнему стремимся минимизировать количество вызовов отрисовки и "
"изменений состояния. Однако объединить несколько объектов в один вызов "
"отрисовки может быть сложнее. 3D-сетки, как правило, состоят из сотен или "
"тысяч треугольников, а объединение больших сеток в реальном времени "
"обходится непомерно дорого. Затраты на их объединение быстро перевешивают "
"любые выгоды по мере роста числа треугольников в сетке. Гораздо лучшей "
"альтернативой является **предварительное объединение сеток** (статичных "
"сеток относительно друг друга). Это могут сделать художники или программно в "
"Godot с помощью дополнения."

msgid ""
"There is also a cost to batching together objects in 3D. Several objects "
"rendered as one cannot be individually culled. An entire city that is off-"
"screen will still be rendered if it is joined to a single blade of grass "
"that is on screen. Thus, you should always take objects' locations and "
"culling into account when attempting to batch 3D objects together. Despite "
"this, the benefits of joining static objects often outweigh other "
"considerations, especially for large numbers of distant or low-poly objects."
msgstr ""
"Объединение объектов в 3D также имеет свои издержки. Несколько объектов, "
"отрисованных как один, нельзя отсечь по отдельности. Целый город, "
"находящийся за пределами экрана, всё равно будет отрисован, если его "
"присоединить к одной травинке на экране. Поэтому при объединении 3D-объектов "
"всегда следует учитывать местоположение объектов и их отсечку. Несмотря на "
"это, преимущества объединения статичных объектов часто перевешивают другие "
"соображения, особенно для большого количества удалённых или "
"низкополигональных объектов."

msgid ""
"For more information on 3D specific optimizations, "
"see :ref:`doc_optimizing_3d_performance`."
msgstr ""
"Для получения дополнительной информации о специальных 3D-оптимизациях "
"см. :ref:`doc_optimizing_3d_performance`."

msgid "Reuse shaders and materials"
msgstr "Повторное использование шейдеров и материалов"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"Рендерер Godot немного отличается от существующих. Он разработан, чтобы "
"максимально минимизировать изменения состояния графического "
"процессора. :ref:`StandardMaterial3D <class_StandardMaterial3D>` хорошо "
"справляется с повторным использованием материалов, требующих схожих "
"шейдеров. Если используются пользовательские шейдеры, обязательно "
"используйте их повторно как можно чаще. Приоритеты Godot:"

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**Повторное использование материалов:** Чем меньше различных материалов в "
"сцене, тем быстрее будет рендеринг. Если в сцене огромное количество "
"объектов (сотни или тысячи), попробуйте повторно использовать материалы. В "
"худшем случае используйте атласы, чтобы уменьшить количество изменений "
"текстур."

msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**Повторное использование шейдеров:** Если материалы невозможно использовать "
"повторно, попробуйте хотя бы повторно использовать шейдеры. Примечание: "
"шейдеры автоматически используются повторно между объектами "
"StandardMaterial3D, имеющими одинаковую конфигурацию (функции, включаемые "
"или отключаемые флажком), даже если у них разные параметры."

msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"Например, если в сцене 20 000 объектов, каждый из которых использует 20 000 "
"различных материалов, рендеринг будет медленным. Если же в той же сцене 20 "
"000 объектов, но используется всего 100 материалов, рендеринг будет гораздо "
"быстрее."

msgid "Pixel cost versus vertex cost"
msgstr "Стоимость пикселя против стоимости вершины"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"Возможно, вы слышали, что чем меньше полигонов в модели, тем быстрее она "
"будет визуализироваться. Это *действительно* относительно и зависит от "
"многих факторов."

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"На современных ПК и консолях стоимость вершин низкая. Изначально графические "
"процессоры рендерили только треугольники. Это означало, что каждый кадр:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr ""
"Все вершины должны были быть преобразованы центральным процессором (включая "
"обрезку)."

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr ""
"Все вершины необходимо было отправить в память графического процессора из "
"основной оперативной памяти."

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"В настоящее время всё это обрабатывается графическим процессором, что "
"значительно повышает производительность. 3D-художники часто ошибочно "
"оценивают производительность, связанную с количеством полигонов, поскольку "
"программы для 3D-моделирования (такие как Blender, 3ds Max и т. д.) "
"вынуждены хранить геометрию в памяти процессора для её редактирования, что "
"снижает производительность. Игровые движки больше полагаются на графический "
"процессор, поэтому они могут гораздо эффективнее рендерить множество "
"треугольников."

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"На мобильных устройствах ситуация иная. Видеокарты для ПК и консолей — это "
"мощные монстры, способные потреблять из электросети столько электроэнергии, "
"сколько им нужно. Мобильные видеокарты ограничены крошечным аккумулятором, "
"поэтому им нужно быть гораздо более энергоэффективными."

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"Чтобы быть более эффективными, мобильные графические процессоры стараются "
"избегать *overdraw*. Перерисовка происходит, когда один и тот же пиксель на "
"экране отображается более одного раза. Представьте себе город с несколькими "
"зданиями. Графические процессоры не знают, что является видимым, а что "
"скрытым, пока не отрисуют его. Например, может быть нарисован дом, а затем "
"ещё один дом перед ним (что означает, что рендеринг одного и того же пикселя "
"происходит дважды). Графические процессоры ПК обычно не слишком заботятся об "
"этом и просто добавляют больше пиксельных процессоров, чтобы увеличить "
"производительность (что также увеличивает энергопотребление)."

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"Использование большего количества ресурсов на мобильных устройствах "
"невозможно, поэтому они используют технологию, называемую *плиточным "
"рендерингом*, которая делит экран на сетку. Каждая ячейка хранит список "
"отрисованных на ней треугольников и сортирует их по глубине для минимизации "
"*перерисовки*. Эта технология повышает производительность и снижает "
"энергопотребление, но снижает производительность обработки вершин. В "
"результате для отрисовки обрабатывается меньше вершин и треугольников."

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"Кроме того, тайловый рендеринг испытывает трудности, когда на небольшом "
"участке экрана находятся мелкие объекты с большим количеством геометрических "
"элементов. Это вынуждает мобильные графические процессоры создавать большую "
"нагрузку на один тайл экрана, что значительно снижает производительность, "
"поскольку все остальные ячейки должны ждать его завершения, прежде чем "
"отобразить кадр."

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"Подводя итог, не беспокойтесь о количестве вершин на мобильных устройствах, "
"но **избегайте концентрации вершин в небольших областях экрана**. Если "
"персонаж, NPC, транспортное средство и т. д. находится далеко (и выглядит "
"крошечным), используйте модель с более низким уровнем детализации (LOD). "
"Даже на настольных видеокартах желательно избегать треугольников размером "
"меньше пикселя на экране."

msgid "Pay attention to the additional vertex processing required when using:"
msgstr ""
"Обратите внимание на дополнительную обработку вершин, необходимую при "
"использовании:"

msgid "Skinning (skeletal animation)"
msgstr "Skinning (скелетная анимация)"

msgid "Morphs (shape keys)"
msgstr "Morphs (ключи формы)"

msgid "Vertex-lit objects (common on mobile)"
msgstr ""
"Объекты с вершинным освещением (часто встречается на мобильных устройствах)"

msgid "Pixel/fragment shaders and fill rate"
msgstr "Пиксельные/фрагментные шейдеры и скорость заполнения"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"В отличие от обработки вершин, стоимость фрагментного (попиксельного) "
"шейдинга за последние годы значительно выросла. Разрешение экранов "
"увеличилось: площадь 4K-экрана составляет 8 294 400 пикселей против 307 200 "
"пикселей у старого VGA-экрана с разрешением 640×480. Это в 27 раз больше! "
"Кроме того, сложность фрагментных шейдеров резко возросла. Физически "
"корректный рендеринг требует сложных вычислений для каждого фрагмента."

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"Проверить, ограничена ли скорость заполнения проекта, можно довольно просто. "
"Отключите V-Sync, чтобы предотвратить ограничение кадров в секунду, затем "
"сравните количество кадров в секунду при работе с большим окном и при работе "
"с очень маленьким окном. Вы также можете получить пользу от аналогичного "
"уменьшения размера карты теней, если используете тени. Обычно при "
"использовании маленького окна FPS увеличивается довольно сильно, что "
"указывает на то, что вы в какой-то степени ограничены в скорости заполнения. "
"С другой стороны, если FPS практически не увеличивается, значит, узкое место "
"находится в другом месте."

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the "
"number and size of textures used. Also, when using non-unshaded particles, "
"consider forcing vertex shading in their material to decrease the shading "
"cost."
msgstr ""
"Производительность в проекте с ограниченной скоростью заполнения можно "
"повысить, уменьшив объём работы, выполняемой графическим процессором. Это "
"можно сделать, упростив шейдер (например, отключив ресурсоёмкие опции, если "
"вы используете :ref:`StandardMaterial3D <class_StandardMaterial3D>`) или "
"уменьшив количество и размер используемых текстур. Кроме того, при "
"использовании частиц без затенения рассмотрите возможность принудительного "
"затенения вершин в их материале для снижения стоимости затенения."

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""
"На поддерживаемом оборудовании :ref:`doc_variable_rate_shading` можно "
"использовать для снижения затрат на обработку затенения, не влияя на "
"резкость краев на конечном изображении."

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr ""
"**При ориентации на мобильные устройства рассмотрите возможность "
"использования максимально простых шейдеров, которые вы можете себе "
"позволить.**"

msgid "Reading textures"
msgstr "Чтение текстур"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"Другим фактором, влияющим на фрагментные шейдеры, является стоимость чтения "
"текстур. Чтение текстур — дорогостоящая операция, особенно при чтении "
"нескольких текстур в одном фрагментном шейдере. Кроме того, следует "
"учитывать, что фильтрация может ещё больше замедлить процесс (трилинейная "
"фильтрация между MIP-текстурами и усреднение). Чтение текстур также "
"потребляет много энергии, что является серьёзной проблемой на мобильных "
"устройствах."

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**Если вы используете сторонние шейдеры или пишете собственные шейдеры, "
"старайтесь использовать алгоритмы, требующие как можно меньшего количества "
"чтений текстур.**"

msgid "Texture compression"
msgstr "Сжатие текстур"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"По умолчанию Godot сжимает текстуры 3D-моделей при импорте, используя сжатие "
"видеопамяти (VRAM). Сжатие видеопамяти не так эффективно с точки зрения "
"размера, как PNG или JPG при сохранении, но значительно повышает "
"производительность при отрисовке достаточно больших текстур."

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr ""
"Это связано с тем, что основной целью сжатия текстур является сокращение "
"пропускной способности между памятью и графическим процессором."

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"В 3D форма объектов больше зависит от геометрии, чем от текстуры, поэтому "
"сжатие обычно незаметно. В 2D сжатие больше зависит от формы внутри текстур, "
"поэтому артефакты, возникающие при 2D-сжатии, более заметны."

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"В качестве предупреждения следует отметить, что большинство устройств "
"Android не поддерживают сжатие текстур с прозрачностью (только "
"непрозрачные), поэтому имейте это в виду."

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"Даже в 3D-текстурах \"pixel art\" следует отключать сжатие видеопамяти, "
"поскольку это негативно скажется на их внешнем виде, не приводя к "
"значительному повышению производительности из-за их низкого разрешения."

msgid "Post-processing and shadows"
msgstr "Постобработка и тени"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"Эффекты постобработки и тени также могут быть затратными с точки зрения "
"фрагментного затенения. Всегда проверяйте их влияние на различное "
"оборудование."

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**Уменьшение размера карт теней может повысить производительность**, как при "
"записи, так и при чтении. Кроме того, лучший способ улучшить "
"производительность теней — отключить тени для как можно большего числа "
"источников света и объектов. Тени небольших или удалённых источников "
"OmniLight/SpotLight часто можно отключить, что лишь незначительно повлияет "
"на визуальный эффект."

msgid "Transparency and blending"
msgstr "Прозрачность и смешивание"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"Прозрачные объекты представляют собой серьёзные проблемы с эффективностью "
"рендеринга. Непрозрачные объекты (особенно в 3D) можно визуализировать "
"практически в любом порядке, и Z-буфер обеспечит затенение только передних "
"объектов. Прозрачные или смешанные объекты работают иначе. В большинстве "
"случаев они не могут полагаться на Z-буфер и должны визуализироваться в "
"\"painter's order\" (то есть от заднего плана к переднему), чтобы выглядеть "
"корректно."

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"Прозрачные объекты также особенно плохо влияют на скорость заполнения, "
"поскольку каждый элемент должен быть отрисован, даже если позже поверх него "
"будут отрисованы другие прозрачные объекты."

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"Непрозрачным объектам это не нужно. Обычно они могут воспользоваться "
"преимуществами Z-буфера, сначала записав данные только в Z-буфер, а затем "
"выполнив фрагментный шейдер только для \"победившего\" фрагмента — объекта, "
"находящегося впереди в определённом пикселе."

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"Прозрачность особенно затратна при перекрытии нескольких прозрачных "
"объектов. Обычно лучше использовать как можно меньшие по размеру прозрачные "
"области, чтобы минимизировать требования к скорости заполнения, особенно на "
"мобильных устройствах, где скорость заполнения очень дорога. Действительно, "
"во многих ситуациях рендеринг более сложной непрозрачной геометрии может "
"оказаться быстрее, чем использование прозрачности для \"обмана\"."

msgid "Multi-platform advice"
msgstr "Советы по работе с несколькими платформами"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"Если вы планируете выпустить игру на нескольких платформах, тестируйте её "
"*как можно раньше* и *часто* на всех платформах, особенно на мобильных. "
"Разрабатывать игру для ПК, а в последний момент пытаться портировать её на "
"мобильные устройства — верный путь к провалу."

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"В целом, следует разрабатывать игру, ориентируясь на наименьший общий "
"знаменатель, а затем добавлять дополнительные улучшения для более мощных "
"платформ. Например, можно использовать метод рендеринга совместимости как "
"для настольных компьютеров, так и для мобильных платформ, если вы "
"ориентируетесь на обе платформы."

msgid "Mobile/tiled renderers"
msgstr "Мобильные/плиточные рендереры"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"Как уже было сказано, графические процессоры мобильных устройств работают "
"совершенно иначе, чем графические процессоры настольных компьютеров. "
"Большинство мобильных устройств используют тайловые рендереры. Тайловые "
"рендереры разбивают экран на плитки стандартного размера, помещающиеся в "
"сверхбыструю кэш-память, что сокращает количество операций чтения/записи в "
"основную память."

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"Однако есть и недостатки. Плиточный рендеринг может значительно усложнить и "
"удорожить реализацию некоторых техник. Плиточные модели, использующие "
"результаты рендеринга в разных тайлах или сохраняемые результаты предыдущих "
"операций, могут работать очень медленно. Будьте особенно внимательны при "
"тестировании производительности шейдеров, текстур области просмотра и "
"постобработки."
