#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "Оптимизация CPU"

msgid "Measuring performance"
msgstr "Замер производительности"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"Нам необходимо знать, где находятся \"узкие места\", чтобы знать, как "
"ускорить нашу программу. Узкие места — это самые медленные части программы, "
"ограничивающие скорость её выполнения. Сосредоточение внимания на \"узких "
"местах\" позволяет нам сосредоточить усилия на оптимизации областей, которые "
"обеспечат максимальный прирост скорости, вместо того, чтобы тратить много "
"времени на оптимизацию функций, приводящую к небольшому повышению "
"производительности."

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr ""
"Для CPU самый простой способ выявить узкие места — использовать профайлер "
"(profiler)."

msgid "CPU profilers"
msgstr "Профайлеры CPU"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"Профилировщики работают вместе с вашей программой и выполняют измерения "
"времени, чтобы определить, какая доля времени тратится на каждую функцию."

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot IDE имеет встроенный профилировщик (built-in profiler). Он не "
"запускается при каждом запуске проекта: его необходимо запускать и "
"останавливать вручную. Это связано с тем, что, как и в случае с большинством "
"профилировщиков, запись этих измерений времени может значительно замедлить "
"проект."

msgid "After profiling, you can look back at the results for a frame."
msgstr "После профилирования вы можете просмотреть результаты для кадра."

msgid "Screenshot of the Godot profiler"
msgstr "Скриншот профайлера Godot"

msgid "Results of a profile of one of the demo projects."
msgstr "Результаты профиля одного из демонстрационных проектов."

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"Мы можем увидеть стоимость встроенных процессов, таких как физика и звук, а "
"также стоимость наших собственных функций скриптов внизу."

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr ""
"Время ожидания различных встроенных серверов может не учитываться в "
"профилировщиках. Это известная ошибка."

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"Когда проект выполняется медленно, вы часто замечаете, что какая-то "
"очевидная функция или процесс занимает гораздо больше времени, чем другие. "
"Это ваше основное узкое место, и обычно можно повысить скорость, "
"оптимизировав эту область."

msgid ""
"For more info about using Godot's built-in profiler, "
"see :ref:`doc_debugger_panel`."
msgstr ""
"Дополнительную информацию об использовании встроенного профилировщика Godot "
"см. в разделе :ref:`doc_debugger_panel`."

msgid "External profilers"
msgstr "Внешние профилировщики (profilers)"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"Хотя профилировщик Godot IDE очень удобен и полезен, иногда вам требуется "
"больше мощности и возможность профилировать сам исходный код движка Godot."

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"Для этого можно :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` (использовать ряд сторонних профилировщиков C++)."

msgid "Screenshot of Callgrind"
msgstr "Скриншот Callgrind"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "Примеры результатов Callgrind, который является частью Valgrind."

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"Слева направо Callgrind выводит процент времени, проведенного внутри функции "
"и ее дочерних функций (включительно), процент времени, проведенного внутри "
"самой функции, без учета дочерних функций (Self), количество вызовов "
"функции, имя функции и файл или модуль."

msgid ""
"In this example, we can see nearly all time is spent under the "
"``Main::iteration()`` function. This is the master function in the Godot "
"source code that is called repeatedly. It causes frames to be drawn, physics "
"ticks to be simulated, and nodes and scripts to be updated. A large "
"proportion of the time is spent in the functions to render a canvas (66%), "
"because this example uses a 2D benchmark. Below this, we see that almost 50% "
"of the time is spent outside Godot code in ``libglapi`` and ``i965_dri`` "
"(the graphics driver). This tells us the a large proportion of CPU time is "
"being spent in the graphics driver."
msgstr ""
"В этом примере мы видим, что почти всё время тратится на функцию "
"``Main::iteration()``. Это главная функция в исходном коде Godot, которая "
"вызывается многократно. Она отвечает за отрисовку кадров, моделирование "
"физических тиков, а также обновление узлов и скриптов. Значительная часть "
"времени тратится на функции рендеринга холста (66%), поскольку в этом "
"примере используется 2D-бенчмарк. Ниже мы видим, что почти 50% времени "
"тратится вне кода Godot в ``libglapi`` и ``i965_dri`` (графическом "
"драйвере). Это говорит о том, что значительная доля процессорного времени "
"тратится на графический драйвер."

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"На самом деле, это отличный пример, поскольку в идеальном мире лишь очень "
"малая часть времени тратилась бы на графический драйвер. Это указывает на "
"проблему, связанную со слишком большим объемом обмена данными и работы в "
"графическом API. Именно такое профилирование привело к разработке 2D-"
"батчинга, который значительно ускоряет 2D-рендеринг, устраняя узкие места в "
"этой области."

msgid "Manually timing functions"
msgstr "Функции ручного хронометража"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"Ещё один удобный метод, особенно после того, как вы определили узкое место с "
"помощью профилировщика, — это вручную замерить время выполнения тестируемой "
"функции или области. Конкретные действия различаются в зависимости от языка, "
"но в GDScript это можно сделать следующим образом:"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"При ручном синхронизации (timing ) функций обычно рекомендуется запускать "
"функцию многократно (1000 или более раз), а не один раз (если только функция "
"не очень медленная). Это обусловлено тем, что таймеры часто имеют "
"ограниченную точность. Более того, процессоры планируют процессы хаотично. "
"Поэтому среднее значение по серии запусков точнее, чем единичное измерение."

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"При оптимизации функций обязательно регулярно профилируйте их или засекайте "
"время выполнения. Это даст вам важную обратную связь относительно того, "
"работает ли оптимизация (или нет)."

msgid "Caches"
msgstr "Кэши"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"Кэш-память процессора - это то, о чем следует помнить, особенно при "
"сравнении временных результатов двух разных версий функции. Результаты могут "
"сильно зависеть от того, находятся ли данные в кэше процессора или нет. "
"Процессоры не загружают данные непосредственно из системной оперативной "
"памяти, даже если она огромна по сравнению с кэшем процессора (несколько "
"гигабайт вместо нескольких мегабайт). Это происходит потому, что доступ к "
"системной оперативной памяти очень медленный. Вместо этого процессоры "
"загружают данные из меньшего, более быстрого банка памяти, называемого кэш-"
"памятью. Загрузка данных из кэша происходит очень быстро, но каждый раз, "
"когда вы пытаетесь загрузить адрес памяти, который не хранится в кэше, кэш "
"должен совершить путешествие в основную память и медленно загрузить данные. "
"Эта задержка может привести к тому, что процессор будет долгое время "
"простаивать, и называется \"пропуском кэша\"."

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"Это означает, что при первом запуске функция может выполняться медленно, "
"поскольку данные отсутствуют в кэше процессора. При втором и последующих "
"запусках она может выполняться значительно быстрее, поскольку данные "
"находятся в кэше. В связи с этим при измерении времени всегда используйте "
"средние значения и учитывайте влияние кэша."

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"Понимание кэширования также имеет решающее значение для оптимизации "
"процессора. Если у вас есть алгоритм (рутина), который загружает небольшие "
"биты данных из произвольно распределенных областей основной памяти, это "
"может привести к большому количеству пропусков кэша, и большую часть времени "
"процессор будет ждать данных, вместо того чтобы выполнять какую-либо работу. "
"Вместо этого, если вы можете сделать доступ к данным локализованным или, еще "
"лучше, обращаться к памяти линейно (как к непрерывному списку), тогда кэш "
"будет работать оптимально, а процессор сможет работать максимально быстро."

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"Godot обычно берёт на себя заботу о таких низкоуровневых деталях. Например, "
"API сервера обеспечивают оптимизацию данных для кэширования уже для таких "
"задач, как рендеринг и физика. Тем не менее, при написании GDExtensions "
"следует быть особенно внимательным к кэшированию."

msgid "Languages"
msgstr "Языки"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot поддерживает ряд различных языков, и стоит помнить о компромиссах. "
"Некоторые языки разработаны для удобства использования в ущерб скорости, а "
"другие быстрее, но с ними сложнее работать."

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"Встроенные функции движка работают с одинаковой скоростью независимо от "
"выбранного языка программирования. Если ваш проект выполняет множество "
"вычислений в собственном коде, рассмотрите возможность переноса этих "
"вычислений на более быстрый язык."

msgid "GDScript"
msgstr "GDScript_"

msgid ""
":ref:`GDScript <doc_gdscript>` is designed to be easy to use and iterate, "
"and is ideal for making many types of games. However, in this language, ease "
"of use is considered more important than performance. If you need to make "
"heavy calculations, consider moving some of your project to one of the other "
"languages."
msgstr ""
":ref:`GDScript <doc_gdscript>` разработан для удобства использования и "
"итераций и идеально подходит для создания самых разных игр. Однако в этом "
"языке простота использования считается важнее производительности. Если вам "
"нужно выполнять сложные вычисления, рассмотрите возможность переноса части "
"вашего проекта на один из других языков."

msgid "C#"
msgstr "C#"

msgid ""
":ref:`C# <doc_c_sharp>` is popular and has first-class support in Godot. It "
"offers a good compromise between speed and ease of use. Beware of possible "
"garbage collection pauses and leaks that can occur during gameplay, though. "
"A common approach to workaround issues with garbage collection is to use "
"*object pooling*, which is outside the scope of this guide."
msgstr ""
":ref:`C# <doc_c_sharp>` популярен и имеет первоклассную поддержку в Godot. "
"Он предлагает хороший компромисс между скоростью и простотой использования. "
"Однако будьте осторожны с возможными паузами в сборке мусора и утечками, "
"которые могут возникнуть во время игры. Распространённый подход к решению "
"проблем со сборкой мусора — использование *object pooling*, что выходит за "
"рамки данного руководства."

msgid "Other languages"
msgstr "Другие языки"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"Третьи стороны обеспечивают поддержку нескольких других языков, включая "
"`Rust <https://github.com/godot-rust/gdext>`_."

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"Godot написан на C++. Использование C++ обычно обеспечивает самый быстрый "
"код. Однако на практике его сложнее всего развернуть на компьютерах конечных "
"пользователей на разных платформах. Варианты использования C++ включают "
"GDExtensions и :ref:`custom modules <doc_custom_modules_in_cpp>`."

msgid "Threads"
msgstr "Потоки"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"Рассмотрите возможность использования потоков при выполнении большого "
"количества вычислений, которые могут выполняться параллельно. Современные "
"процессоры имеют несколько ядер, каждое из которых способно выполнять "
"ограниченный объём работы. Распределяя нагрузку между несколькими потоками, "
"можно добиться максимальной эффективности процессора."

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"Недостаток потоков заключается в необходимости соблюдать крайнюю "
"осторожность. Поскольку каждое ядро процессора работает независимо, они "
"могут одновременно пытаться получить доступ к одной и той же памяти. Один "
"поток может читать переменную, пока другой записывает её: это называется "
"*состоянием гонки*. Прежде чем использовать потоки, убедитесь, что вы "
"понимаете связанные с ними опасности и знаете, как предотвратить эти "
"состояния гонки. Потоки могут значительно усложнить отладку."

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr ""
"Более подробную информацию о потоках см. :ref:`doc_using_multiple_threads`."

msgid "SceneTree"
msgstr "Дерево сцены"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"Хотя Узлы (Nodes) — невероятно мощная и универсальная концепция, помните, "
"что каждый узел имеет свою стоимость. Встроенные функции, такие как "
"``_process()`` и ``_physics_process()``, распространяются по всему дереву. "
"Эта функция может снизить производительность при очень большом количестве "
"узлов (точное количество зависит от целевой платформы и может варьироваться "
"от тысяч до десятков тысяч, поэтому обязательно оцените производительность "
"на всех целевых платформах во время разработки)."

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"Каждый узел обрабатывается отдельно в рендерере Godot. Поэтому меньшее "
"количество узлов и большее количество каждого из них может привести к лучшей "
"производительности."

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later "
"using :ref:`Node.add_child(node) <class_Node_method_add_child>`. This can be "
"very useful for adding and removing areas from a game, for example."
msgstr ""
"Одна из особенностей :ref:`SceneTree <class_SceneTree>` заключается в том, "
"что иногда можно добиться гораздо большей производительности, удаляя узлы из "
"SceneTree, а не приостанавливая или скрывая их. Удалять отсоединённый узел "
"не обязательно. Например, можно сохранить ссылку на узел, отсоединить его от "
"дерева сцены с помощью :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, а затем снова присоединить его позже с "
"помощью :ref:`Node.add_child(node) <class_Node_method_add_child>`. Это может "
"быть очень полезно, например, для добавления и удаления областей в игре."

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"Вы можете полностью отказаться от SceneTree, используя серверные API. "
"Подробнее см. :ref:`doc_using_servers`."

msgid "Physics"
msgstr "Физика"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"В некоторых ситуациях физика может стать узким местом. Это особенно "
"актуально в сложных мирах и с большим количеством физических объектов."

msgid "Here are some techniques to speed up physics:"
msgstr "Вот несколько приемов для ускорения физики:"

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"Попробуйте использовать упрощённые версии визуализированной геометрии для "
"форм столкновений. Зачастую это незаметно для конечных пользователей, но "
"может значительно повысить производительность."

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"Попробуйте удалить объекты из физики, когда они находятся вне поля зрения/за "
"пределами текущей области, или повторно использовать физические объекты "
"(например, можно разрешить 8 монстров на область и повторно использовать их)."

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"Другим важным аспектом физики является частота тиков. В некоторых играх её "
"можно значительно снизить, например, вместо обновления физики 60 раз в "
"секунду, а можно обновлять её всего 30 или даже 20 раз в секунду. Это может "
"значительно снизить нагрузку на процессор."

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"Недостатком изменения частоты физических тиков является возможность "
"возникновения рывков или дрожания, когда частота обновления физики не "
"соответствует количеству кадров в секунду. Кроме того, уменьшение частоты "
"физических тиков увеличит задержку ввода. В большинстве игр с движением "
"игрока в реальном времени рекомендуется придерживаться частоты физических "
"тиков по умолчанию (60 Гц)."

msgid ""
"The solution to jitter is to use *fixed timestep interpolation*, which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. Godot has built-in physics interpolation which you can "
"read about :ref:`here<doc_physics_interpolation>`. Performance-wise, "
"interpolation is a very cheap operation compared to running a physics tick. "
"It's orders of magnitude faster, so this can be a significant performance "
"win while also reducing jitter."
msgstr ""
"Решением проблемы дрожания является использование *интерполяции с "
"фиксированным временным шагом*, которая включает сглаживание "
"визуализированных положений и поворотов в нескольких кадрах для соответствия "
"физике. Godot имеет встроенную физическую интерполяцию, о которой вы можете "
"прочитать сдесь :ref:`here<doc_physics_interpolation>`. С точки зрения "
"производительности интерполяция — очень дешевая операция по сравнению с "
"выполнением физического тика. Он на порядок быстрее, так что это может дать "
"существенный выигрыш в производительности, а также снизить дрожание (jitter)."
