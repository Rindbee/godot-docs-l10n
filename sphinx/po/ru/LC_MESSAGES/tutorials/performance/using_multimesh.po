#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using MultiMeshes"
msgstr "Оптимизация с использованием мультисеток"

msgid ""
"For large amount of instances (in the thousands), that need to be constantly "
"processed (and certain amount of control needs to be retained), :ref:`using "
"servers directly <doc_using_servers>` is the recommended optimization."
msgstr ""
"Для большого количества экземпляров (тысяч), которые необходимо постоянно "
"обрабатывать (и сохранять определенный уровень контроля), рекомендуемой "
"оптимизацией является :ref:`using servers directly <doc_using_servers>`."

msgid ""
"When the amount of objects reach the hundreds of thousands or millions, none "
"of these approaches are efficient anymore. Still, depending on the "
"requirements, there is one more optimization possible."
msgstr ""
"Когда количество объектов достигает сотен тысяч или миллионов, ни один из "
"этих подходов уже неэффективен. Тем не менее, в зависимости от требований, "
"возможен ещё один вариант оптимизации."

msgid "MultiMeshes"
msgstr "MultiMeshes (МультиСетки)"

msgid ""
"A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw "
"up to millions of objects in one go. It's extremely efficient because it "
"uses the GPU hardware to do this."
msgstr ""
":ref:`MultiMesh<class_MultiMesh>` — это единый примитив рисования, способный "
"отрисовывать до миллионов объектов за один раз. Он чрезвычайно эффективен, "
"поскольку использует для этого аппаратное обеспечение графического "
"процессора."

msgid ""
"The only drawback is that there is no *screen* or *frustum* culling possible "
"for individual instances. This means, that millions of objects will be "
"*always* or *never* drawn, depending on the visibility of the whole "
"MultiMesh. It is possible to provide a custom visibility rect for them, but "
"it will always be *all-or-none* visibility."
msgstr ""
"Единственный недостаток заключается в отсутствии возможности отбраковки "
"*экрана* или *усеченной* области для отдельных экземпляров. Это означает, "
"что миллионы объектов будут *всегда* или *никогда* отрисовываться, в "
"зависимости от видимости всей мультисетки. Можно задать для них собственный "
"прямоугольник видимости, но видимость всегда будет по принципу *все или "
"ничего*."

msgid ""
"If the objects are simple enough (just a couple of vertices), this is "
"generally not much of a problem as most modern GPUs are optimized for this "
"use case. A workaround is to create several MultiMeshes for different areas "
"of the world."
msgstr ""
"Если объекты достаточно простые (всего пара вершин), это, как правило, не "
"представляет особой проблемы, поскольку большинство современных видеокарт "
"оптимизированы для такого использования. Обходной путь — создание нескольких "
"мультисеток для разных областей мира."

msgid ""
"It is also possible to execute some logic inside the vertex shader (using "
"the ``INSTANCE_ID`` or ``INSTANCE_CUSTOM`` built-in constants). For an "
"example of animating thousands of objects in a MultiMesh, see "
"the :ref:`Animating thousands of fish <doc_animating_thousands_of_fish>` "
"tutorial. Information to the shader can be provided via textures (there are "
"floating-point :ref:`Image<class_Image>` formats which are ideal for this)."
msgstr ""
"Также возможно выполнение некоторой логики внутри вершинного шейдера "
"(используя встроенные константы ``INSTANCE_ID`` или ``INSTANCE_CUSTOM``). "
"Пример анимации тысяч объектов в MultiMesh см. в руководстве :ref:`Animating "
"thousands of fish <doc_animating_thousands_of_fish>`. Информация для шейдера "
"может быть предоставлена через текстуры (существуют форматы с плавающей "
"точкой :ref:`Image<class_Image>`, которые идеально подходят для этого)."

msgid ""
"Another alternative is to use a GDExtension and C++, which should be "
"extremely efficient (it's possible to set the entire state for all objects "
"using linear memory via the :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>` function). This way, "
"the array can be created with multiple threads, then set in one call, "
"providing high cache efficiency."
msgstr ""
"Другой вариант — использовать GDExtension и C++, что должно быть чрезвычайно "
"эффективно (можно установить полное состояние всех объектов, используя "
"линейную память, с помощью "
"функции :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>`). Таким образом, массив "
"можно создать в несколько потоков, а затем установить за один вызов, что "
"обеспечивает высокую эффективность кэширования."

msgid ""
"Finally, it's not required to have all MultiMesh instances visible. The "
"amount of visible ones can be controlled with "
"the :ref:`MultiMesh.visible_instance_count "
"<class_MultiMesh_property_visible_instance_count>` property. The typical "
"workflow is to allocate the maximum amount of instances that will be used, "
"then change the amount visible depending on how many are currently needed."
msgstr ""
"Наконец, не обязательно, чтобы все экземпляры MultiMesh были видимыми. "
"Количество видимых экземпляров можно контролировать с помощью "
"свойства :ref:`MultiMesh.visible_instance_count "
"<class_MultiMesh_property_visible_instance_count>`. Типичный рабочий процесс "
"заключается в выделении максимального количества экземпляров, которые будут "
"использоваться, а затем изменении количества видимых экземпляров в "
"зависимости от текущей потребности."

msgid "Multimesh example"
msgstr "Пример Multimesh"

msgid ""
"Here is an example of using a MultiMesh from code. Languages other than "
"GDScript may be more efficient for millions of objects, but for a few "
"thousands, GDScript should be fine."
msgstr ""
"Вот пример использования MultiMesh из кода. Другие языки, помимо GDScript, "
"могут быть эффективнее для миллионов объектов, но для нескольких тысяч "
"GDScript вполне подойдёт."
