#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "Матрицы и преобразования"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"Перед прочтением этого руководства мы рекомендуем вам внимательно прочитать "
"и понять руководство :ref:`doc_vector_math`, так как для этого руководства "
"требуются знания векторов."

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"В этом руководстве мы расскажем о *преобразованиях* и о том, как мы "
"представляем их в Godot с помощью матриц. Это не исчерпывающее руководство "
"по матрицам. Преобразования чаще всего применяются в виде переноса, поворота "
"и масштабирования, поэтому мы сосредоточимся на том, как представить их с "
"помощью матриц."

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` "
"and :ref:`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"Большая часть этого руководства посвящена 2D с "
"использованием :ref:`class_Transform2D` и :ref:`class_Vector2`, но в 3D все "
"работает очень похоже."

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"Как упоминалось в предыдущем уроке, важно помнить, что в модели Godot ось Y "
"в двумерном пространстве направлена *вниз*. Это противоположно тому, как в "
"большинстве школ преподают линейную алгебру, где ось Y направлена вверх."

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"Ось X обозначается красным цветом, ось Y — зелёным, а ось Z — синим. В этом "
"уроке используется соответствующая цветовая схема, но синий цвет также "
"применяется для отображения вектора начала координат."

msgid "Matrix components and the Identity matrix"
msgstr "Компоненты матрицы и Единичная матрица"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"Единичная матрица — это преобразование без перемещения, поворота и "
"масштабирования. Давайте начнём с рассмотрения единичной матрицы и того, как "
"её компоненты связаны с её визуальным представлением."

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr ""
"Матрицы состоят из строк и столбцов, а матрица преобразования имеет "
"определенные соглашения о том, что делает каждая из них."

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"На изображении выше видно, что красный вектор X представлен первым столбцом "
"матрицы, а зелёный вектор Y — вторым. Изменение столбцов изменит эти "
"векторы. В следующих нескольких примерах мы рассмотрим, как ими "
"манипулировать."

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"Вам не стоит беспокоиться о непосредственной работе со строками, поскольку "
"мы обычно работаем со столбцами. Однако строки матрицы можно рассматривать "
"как индикаторы векторов, способствующих движению в заданном направлении."

msgid ""
"When we refer to a value such as ``t.x.y``, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, "
"``t.x.x`` is top-left, ``t.y.x`` is top-right, and ``t.y.y`` is bottom-"
"right, where ``t`` is the Transform2D."
msgstr ""
"Когда мы говорим о значении вроде ``t.x.y``, это Y-компонент вектор-столбца "
"X. Другими словами, левый нижний элемент матрицы. Аналогично, ``t.x.x`` — "
"это левый верхний, ``t.y.x`` — правый верхний, а ``t.y.y`` — правый нижний, "
"где ``t`` — это Transform2D."

msgid "Scaling the transformation matrix"
msgstr "Масштабирование матрицы преобразования"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"Масштабирование — одна из самых простых для понимания операций. Начнём с "
"размещения логотипа Godot под нашими векторами, чтобы наглядно увидеть "
"влияние преобразования на объект:"

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"Теперь, чтобы масштабировать матрицу, нам достаточно умножить каждый её "
"компонент на нужный коэффициент масштабирования. Увеличим масштаб в 2 раза.1 "
"умножить на 2 станет 2, а 0 умноженный на 2 останется 0, в результате "
"получаем:"

msgid "To do this in code, we multiply each of the vectors:"
msgstr "Чтобы сделать это в коде, мы перемножаем каждый из векторов:"

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"Если нужно вернуть исходный масштаб, достаточно умножить каждый компонент на "
"0.5. Это, в целом, всё, что требуется знать о масштабировании матрицы "
"преобразования."

msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use ``length()`` on each of the column vectors."
msgstr ""
"Чтобы вычислить масштаб объекта из существующей матрицы преобразования, вы "
"можете использовать ``length()`` для каждого из векторов-столбцов."

msgid ""
"In actual projects, you can use the ``scaled()`` method to perform scaling."
msgstr ""
"В реальных проектах для выполнения масштабирования можно использовать метод "
"``scaled()``."

msgid "Rotating the transformation matrix"
msgstr "Вращение матрицы преобразования"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr ""
"Начнём так же, как и ранее — разместим логотип Godot под единичной матрицей:"

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"Предположим, мы хотим повернуть наш логотип по часовой стрелке на 90 "
"градусов. Сейчас ось X направлена вправо, а ось Y - вниз. Если мы представим "
"их поворот, то логически увидим, что новая ось X должна указывать вниз, а "
"новая ось Y - влево."

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"Можете представить, будто вы берёте и логотип Godot, и его векторы, а затем "
"вращаете их вокруг центра. В каком бы положении вы ни остановили вращение, "
"ориентация векторов будет определять значение матрицы."

msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"``Vector2.DOWN`` and ``Vector2.LEFT``. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"Нам нужно представить «вниз» и «влево» в нормальных координатах, поэтому мы "
"установим X в (0, 1), а Y в (-1, 0). Это также значения ``Vector2.DOWN`` и "
"``Vector2.LEFT``. Когда мы это сделаем, мы получим желаемый результат в виде "
"вращения объекта:"

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"Если вам сложно понять вышесказанное, попробуйте такое упражнение: вырежьте "
"из бумаги квадрат, нарисуйте на нём векторы X и Y, положите его на лист в "
"клетку, затем поверните и отметьте конечные точки векторов."

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"Для выполнения поворота в коде нам нужно уметь программно вычислять "
"значения. Это изображение показывает формулы, необходимые для расчёта "
"матрицы преобразования из угла поворота. Не волнуйтесь, если эта часть "
"кажется сложной — обещаю, это самое трудное, что вам нужно знать."

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or `PI/"
"2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"В Godot все вращения задаются в радианах, а не в градусах. Полный оборот "
"равен `TAU` или `PI*2` радиан, а поворот на 90 градусов (четверть оборота) — "
"`TAU/4` или `PI/2` радиан. Использование `TAU` обычно делает код более "
"читаемым."

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"Интересный факт: В дополнение к тому, что в Godot ось Y указывает вниз, "
"вращение представлено по часовой стрелке. Это означает, что все "
"математические и тригонометрические функции работают так же, как в системе с "
"осью Y вверх и вращением против часовой стрелки (CCW), поскольку эти "
"различия \"компенсируются\". Можно считать, что вращение в обеих системах "
"происходит \"от X к Y\"."

msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug "
"in a value of 0.5 to the formula above and evaluate to find what the actual "
"values should be:"
msgstr ""
"Чтобы выполнить поворот на 0,5 радиана (около 28,65 градуса), мы подставляем "
"значение 0,5 в приведенную выше формулу и вычисляем, какими должны быть "
"фактические значения:"

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "Вот как это реализуется в коде (поместите скрипт на узел Node2D):"

msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use ``atan2(t.x.y, t.x.x)``, where t is the Transform2D."
msgstr ""
"Чтобы вычислить поворот объекта из существующей матрицы преобразования, "
"можно использовать ``atan2(t.x.y, t.x.x)``, где t — это Transform2D."

msgid ""
"In actual projects, you can use the ``rotated()`` method to perform "
"rotations."
msgstr ""
"В актуальных проектах для выполнения поворотов можно использовать метод "
"``rotated()``."

msgid "Basis of the transformation matrix"
msgstr "Основа матрицы преобразования"

msgid ""
"So far we have only been working with the ``x`` and ``y``, vectors, which "
"are in charge of representing rotation, scale, and/or shearing (advanced, "
"covered at the end). The X and Y vectors are together called the *basis* of "
"the transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"До сих пор мы работали только с векторами ``x`` и ``y``, которые отвечают за "
"представление поворота, масштаба и/или сдвига (для продвинутых "
"пользователей, об этом будет рассказано в конце). Векторы X и Y вместе "
"называются *базисом* матрицы преобразования. Важно знать термины \"базис\" и "
"\"базисные векторы\"."

msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has "
"three :ref:`class_Vector2` values: ``x``, ``y``, and ``origin``. The "
"``origin`` value is not part of the basis, but it is part of the transform, "
"and we need it to represent position. From now on we'll keep track of the "
"origin vector in all examples. You can think of origin as another column, "
"but it's often better to think of it as completely separate."
msgstr ""
"Вы могли заметить, что у :ref:`class_Transform2D` на самом деле есть три "
"значения :ref:`class_Vector2`: ``x``, ``y`` и ``origin``. Значение "
"``origin`` не является частью базиса, но является частью преобразования и "
"необходимо нам для представления положения. С этого момента мы будем "
"отслеживать вектор начала координат во всех примерах. Вы можете "
"рассматривать начало координат как ещё один столбец, но часто лучше "
"рассматривать его как совершенно отдельный столбец."

msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it "
"from :ref:`class_Transform3D` (which is composed of one :ref:`class_Basis` "
"and one extra :ref:`class_Vector3` for the origin)."
msgstr ""
"Обратите внимание, что в 3D Godot имеет отдельную "
"структуру :ref:`class_Basis` для хранения трех значений :ref:`class_Vector3` "
"базиса, поскольку код может стать сложным, и имеет смысл отделить ее "
"от :ref:`class_Transform3D` (которая состоит из одного :ref:`class_Basis` и "
"одного дополнительного :ref:`class_Vector3` для начала координат)."

msgid "Translating the transformation matrix"
msgstr "Перевод матрицы преобразования"

msgid ""
"Changing the ``origin`` vector is called *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"Изменение вектора ``origin (исходной)`` координат называется *трансляцией* "
"матрицы преобразования. Трансляция — это, по сути, технический термин, "
"обозначающий \"перемещение\" объекта, но он явно не подразумевает поворота."

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"Разберём пример для понимания. Начнём с единичного преобразования, как в "
"прошлый раз, но теперь будем отслеживать вектор начала координат."

msgid ""
"If we want to move the object to a position of (1, 2), we need to set its "
"``origin`` vector to (1, 2):"
msgstr ""
"Если мы хотим переместить объект в позицию (1, 2), нам нужно установить его "
"``исходный`` вектор в (1, 2):"

msgid ""
"There is also a ``translated_local()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The "
"``translated_local()`` method will translate the object *relative to its own "
"rotation*. For example, an object rotated 90 degrees clockwise will move to "
"the right when ``translated_local()`` with ``Vector2.UP``. To translate "
"*relative to the global/parent frame* use ``translated()`` instead."
msgstr ""
"Существует также метод ``translated_local()``, который выполняет операцию, "
"отличную от прямого добавления или изменения ``origin``. Метод "
"``translated_local()`` перемещает объект *относительно его собственного "
"поворота*. Например, объект, повёрнутый на 90 градусов по часовой стрелке, "
"сместится вправо при использовании ``translated_local()`` с ``Vector2.UP``. "
"Для перемещения *относительно глобальной/родительской системы координат* "
"используйте ``translated()``."

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godot в 2D использует координаты, основанные на пикселях, поэтому в реальных "
"проектах вам потребуется перемещать объекты на сотни единиц."

msgid "Putting it all together"
msgstr "Собираем все вместе"

msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a project with a Sprite2D node and use the Godot logo "
"for the texture resource."
msgstr ""
"Мы применим всё, что мы уже описали, к одному преобразованию. Для этого "
"создайте проект с узлом Sprite2D и используйте логотип Godot в качестве "
"ресурса текстуры."

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"Давайте установим перемещение на (350, 150), поворот на -0.5 радиан и "
"масштаб на 3. Я приложил скриншот и код для воспроизведения, но советую вам "
"попробовать воссоздать скриншот, не заглядывая в код!"

msgid "Shearing the transformation matrix (advanced)"
msgstr "Скос с помощью матрицы преобразования (дополнительно)"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"Если вам нужно только узнать, как *использовать* матрицы преобразования, "
"смело пропускайте этот раздел. Здесь рассматривается редко применяемый "
"аспект матриц преобразования для более глубокого понимания их работы."

msgid "Node2D provides a shearing property out of the box."
msgstr "Node2D изначально предоставляет возможность сдвига."

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"Возможно, вы заметили, что преобразование имеет больше степеней свободы, чем "
"комбинация указанных выше действий. Основа матрицы 2D-преобразования "
"содержит четыре числа в двух значениях :ref:`class_Vector2`, тогда как угол "
"поворота и Vector2 масштаба — только 3 числа. Этот недостающий параметр "
"называется *перекосом* (shearing)."

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"Обычно базисные векторы всегда перпендикулярны друг другу. Однако в "
"некоторых ситуациях сдвиг может быть полезен, и понимание принципа сдвига "
"помогает понять, как работают преобразования."

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr ""
"Чтобы наглядно показать, как это будет выглядеть, давайте наложим сетку на "
"логотип Godot:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"Каждая точка этой сетки получается путём сложения базисных векторов. В "
"правом нижнем углу это X + Y, а в правом верхнем — X - Y. Изменение базисных "
"векторов приводит к изменению всей сетки, поскольку она состоит из базисных "
"векторов. Все параллельные линии сетки останутся параллельными, независимо "
"от изменений базисных векторов."

msgid "As an example, let's set Y to (1, 1):"
msgstr "В качестве примера установим Y равным (1, 1):"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr ""
"Вы не можете задать необработанные значения Transform2D в редакторе, поэтому "
"вам *придется* использовать код, если вы хотите сдвинуть объект."

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"Из-за того, что векторы больше не перпендикулярны, объект был сдвинут. "
"Нижний центр сетки, который находится в точке (0, 1) относительно себя, "
"теперь находится в мировой точке (1, 1)."

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"Внутриобъектные координаты в текстурах называются UV-координатами, поэтому "
"давайте позаимствуем этот термин здесь. Чтобы найти положение объекта в мире "
"по относительному положению, используется формула U * X + V * Y, где U и V — "
"числа, а X и Y — базисные векторы."

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"Правый нижний угол сетки, который всегда находится в UV-координате (1, 1), "
"находится в мировой координате (2, 1), которая рассчитывается по формуле X*1 "
"+ Y*1, то есть (1, 0) + (1, 1), или (1 + 1, 0 + 1), или (2, 1). Это "
"совпадает с нашим наблюдением положения правого нижнего угла изображения."

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"Аналогично, правый верхний угол сетки, который всегда находится в "
"ультрафиолетовой позиции (1, -1), находится в мировой позиции (0, -1), "
"которая вычисляется по X*1 + Y*-1, что составляет (1, 0) - (1, 1), или (1 - "
"1, 0 - 1), или (0, -1). Это совпадает с нашими наблюдениями о том, где "
"находится правый верхний угол изображения."

msgid ""
"Hopefully you now fully understand how a transformation matrix affects the "
"object, and the relationship between the basis vectors and how the object's "
"\"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"Надеюсь, теперь вы полностью понимаете, как матрица преобразования влияет на "
"объект, а также взаимосвязь между базисными векторами и тем, как «UV» или "
"«внутрикоординаты» объекта изменяют свое мировое положение."

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"В Godot все вычисления преобразований выполняются относительно родительского "
"узла. Когда мы говорим о \"мировом положении\", оно относилось бы к "
"родительскому узлу, если бы у узла был родительский узел."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"Если вам нужны дополнительные объяснения, посмотрите великолепное видео "
"3Blue1Brown о линейных преобразованиях: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"

msgid "Practical applications of transforms"
msgstr "Практические применения преобразований"

msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Node3D` "
"nodes parented to each other."
msgstr ""
"В реальных проектах вы обычно будете работать с преобразованиями внутри "
"преобразований, имея несколько узлов :ref:`class_Node2D` "
"или :ref:`class_Node3D`, являющихся родительскими по отношению друг к другу."

msgid ""
"However, it's useful to understand how to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` "
"or :ref:`class_Transform3D` to manually calculate transforms of nodes."
msgstr ""
"Однако полезно понимать, как вручную вычислять необходимые значения. Мы "
"рассмотрим, как использовать :ref:`class_Transform2D` "
"или :ref:`class_Transform3D` для ручного вычисления преобразований узлов."

msgid "Converting positions between transforms"
msgstr "Конвертация позиций между трансформациями"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"Существует множество случаев, когда может потребоваться преобразование "
"позиции в преобразование и обратно. Например, если у вас есть позиция "
"относительно игрока и вы хотите найти мировую позицию (относительно "
"родителя), или если у вас есть мировая позиция и вы хотите узнать её "
"относительно игрока."

msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the ``*`` operator:"
msgstr ""
"Мы можем найти, как будет определен вектор относительно игрока в мировом "
"пространстве, используя оператор ``*``:"

msgid ""
"And we can use the ``*`` operator in the opposite order to find a what world "
"space position would be if it was defined relative to the player:"
msgstr ""
"И мы можем использовать оператор ``*`` в обратном порядке, чтобы узнать, "
"какой была бы позиция в мировом пространстве, если бы она была определена "
"относительно игрока:"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"Если заранее известно, что преобразование расположено в точке (0, 0), можно "
"использовать методы \"basis_xform\" или \"basis_xform_inv\", которые "
"пропускают обработку преобразования."

msgid "Moving an object relative to itself"
msgstr "Перемещение объекта относительно самого себя"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"Распространенной операцией, особенно в 3D-играх, является перемещение "
"объекта относительно него самого. Например, в шутерах от первого лица вы "
"хотите, чтобы персонаж двигался вперёд (по оси -Z) при нажатии :kbd:`W`."

msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can add multiples "
"of the basis vectors to move an object relative to itself."
msgstr ""
"Поскольку базисные векторы задают ориентацию относительно родителя, а "
"начальный вектор — положение относительно родителя, мы можем складывать "
"кратные базисным векторам, чтобы перемещать объект относительно самого себя."

msgid "This code moves an object 100 units to its own right:"
msgstr "Этот код перемещает объект на 100 единиц вправо:"

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "Для перемещения в 3D вам необходимо заменить «x» на «basis.x»."

msgid ""
"In actual projects, you can use ``translate_object_local`` in 3D or "
"``move_local_x`` and ``move_local_y`` in 2D to do this."
msgstr ""
"В реальных проектах для этого можно использовать ``translate_object_local`` "
"в 3D или ``move_local_x`` и ``move_local_y`` в 2D."

msgid "Applying transforms onto transforms"
msgstr "Применение преобразований к преобразованиям"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"Одна из самых важных вещей, которую нужно знать о преобразованиях, — это то, "
"как использовать несколько из них одновременно. Преобразование родительского "
"узла влияет на все его дочерние узлы. Давайте разберём пример."

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"На этом изображении дочерний узел отмечен цифрой «2» после имени компонента, "
"чтобы отличать его от родительского узла. Обилие цифр может показаться "
"немного громоздким, но помните, что каждая цифра отображается дважды (рядом "
"со стрелками и в матрицах), и почти половина из них — нули."

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"Единственные преобразования, которые здесь происходят, заключаются в том, "
"что родительскому узлу присваивается масштаб (2, 1), дочернему узлу "
"присваивается масштаб (0,5, 0,5) и обоим узлам задаются позиции."

msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's ``origin`` vector is set to (1, "
"1), but this actually moves it (2, 1) in world space, due to the parent "
"node's basis vectors."
msgstr ""
"Все дочерние преобразования подвержены влиянию родительских преобразований. "
"У ребенка масштаб (0,5, 0,5), поэтому можно было бы ожидать, что он будет "
"квадратом с соотношением сторон 1:1, и так оно и есть, но только "
"относительно родителя. Вектор X дочернего элемента оказывается равным (1, 0) "
"в мировом пространстве, поскольку он масштабируется базисными векторами "
"родителя. Аналогично, вектор ``origin`` дочернего узла устанавливается в (1, "
"1), но это фактически перемещает его в мировое пространство в точку (2, 1) "
"из-за базисных векторов родительского узла."

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr ""
"Чтобы вручную вычислить преобразование мирового пространства дочернего "
"преобразования, мы будем использовать следующий код:"

msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the ``*`` operator:"
msgstr ""
"В реальных проектах мы можем найти мировое преобразование дочернего объекта, "
"применив одно преобразование к другому с помощью оператора ``*``:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr ""
"При умножении матриц порядок имеет значение! Не смешивайте элементы матриц."

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "В итоге, применение преобразования тождества никогда ничего не дает."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"Если вам нужно дополнительное объяснение, вам стоит посмотреть отличное "
"видео от 3Blue1Brown о композиции (умножении) матриц: https://"
"www.youtube.com/watch?v=XkY2DOUCWMU"

msgid "Inverting a transformation matrix"
msgstr "Обращение матрицы преобразования"

msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations. Let's take a look "
"at a few examples."
msgstr ""
"Функция «affine_inverse» возвращает преобразование, которое «отменяет» "
"предыдущее. Это может быть полезно в некоторых ситуациях. Давайте рассмотрим "
"несколько примеров."

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr ""
"Умножение обратного преобразования на нормальное отменяет все преобразования:"

msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position:"
msgstr ""
"Преобразование позиции с помощью преобразования и его обратного "
"преобразования приводит к той же позиции:"

msgid "How does it all work in 3D?"
msgstr "Как все это работает в 3D?"

msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform3D`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"Одно из замечательных свойств матриц преобразования заключается в том, что "
"они работают практически одинаково для 2D и 3D преобразований. Весь код и "
"формулы, использованные выше для 2D преобразований, работают одинаково и в "
"3D, за тремя исключениями: добавление третьей оси, тип каждой "
"оси :ref:`class_Vector3`, а также то, что Godot хранит :ref:`class_Basis` "
"отдельно от :ref:`class_Transform3D`, поскольку математические вычисления "
"могут быть сложными, и их разделение имеет смысл."

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"Все концепции перемещения, поворота, масштабирования и сдвига, работают в 3D "
"также, как и в 2D. Для масштабирования мы берем каждый компонент и умножаем "
"его; для поворота мы изменяем направление каждого базисного вектора; для "
"перемещения мы управляем началом координат; для сдвига мы делаем базисные "
"векторы неперпендикулярными."

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"Если хотите, стоит поэкспериментировать с преобразованиями, чтобы понять, "
"как они работают. Godot позволяет редактировать матрицы трёхмерных "
"преобразований прямо из инспектора. Вы можете скачать этот проект с цветными "
"линиями и кубами для визуализации векторов :ref:`class_Basis` и начала "
"координат как в 2D, так и в 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"

msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"Матрицу преобразования Node2D нельзя редактировать непосредственно в "
"инспекторе Godot 4.0. Это может быть изменено в будущих версиях Godot."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"Если вам нужно дополнительное объяснение, вам следует посмотреть отличное "
"видео от 3Blue1Brown о трехмерных линейных преобразованиях: https://"
"www.youtube.com/watch?v=rHLEWRxRGiM"

msgid "Representing rotation in 3D (advanced)"
msgstr "Представление вращения в 3D (расширенное)"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"Самое большое различие между матрицами преобразования 2D и 3D заключается в "
"том, как представлено вращение само по себе, без базисных векторов."

msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, rotation is too complex to represent as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"В двумерном пространстве у нас есть простой способ (atan2) переключаться "
"между матрицей преобразования и углом. В трёхмерном пространстве поворот "
"слишком сложен, чтобы быть представленным одним числом. Существуют так "
"называемые углы Эйлера, которые могут представлять повороты в виде набора из "
"трёх чисел, однако их возможности ограничены и они не очень полезны, за "
"исключением тривиальных случаев."

msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quaternion` struct. My "
"suggestion to you is to completely ignore how they work under-the-hood, "
"because they are very complicated and unintuitive."
msgstr ""
"В 3D мы обычно не используем углы, а либо используем базис преобразований "
"(применяемый практически повсеместно в Godot), либо кватернионы. Godot может "
"представлять кватернионы с помощью структуры :ref:`class_Quaternion`. Я "
"предлагаю вам полностью игнорировать то, как они работают изнутри, потому "
"что они очень сложны и неинтуитивны."

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"Однако если вам действительно необходимо знать, как это работает, вот "
"несколько замечательных ресурсов, которые вы можете изучить по порядку:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.youtube.com/watch?v=mvmuCPvRoWQ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.youtube.com/watch?v=d4EgbgTm0Bg"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"
