#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "Продвинутая векторная математика"

msgid "Planes"
msgstr "Плоскости"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"Скалярное произведение имеет одно интересное свойство с единичными "
"векторами. Вообразите что перпендикуляр к такому вектору(и через начальную "
"точку) проходит через плоскость. Плоскости разделяют все пространство на "
"положительное (над плоскостью) и отрицательное (под плоскостью), и (вопреки "
"популярному мнению) вы сможете также использовать его в 2D:"

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"Единичные вектора которые перпендикулярны плоскости (так, что они описывают "
"ориентацию поверхности) называются **единичными векторами нормали**. Хотя, "
"обычно это сокращают до **нормалей**. Нормали имеются в плоскостях, 3D "
"геометрии (чтобы определять которая из сторон или вершин скользит), и т.д. "
"**Нормаль** это **единичный вектор**, но называется **нормалью** поскольку "
"имеет такое предназначение. (Так же как мы называем (0,0) Началом "
"координат !)."

msgid ""
"The plane passes by the origin and the surface of it is perpendicular to the "
"unit vector (or *normal*). The side the vector points to is the positive "
"half-space, while the other side is the negative half-space. In 3D this is "
"exactly the same, except that the plane is an infinite surface (imagine an "
"infinite, flat sheet of paper that you can orient and is pinned to the "
"origin) instead of a line."
msgstr ""
"Плоскость проходит через начало координат, и её поверхность перпендикулярна "
"единичному вектору (или *normal (нормали)*). Сторона, на которую указывает "
"вектор, — это положительное полупространство, а другая сторона — "
"отрицательное полупространство. В трёхмерном пространстве это происходит "
"точно так же, за исключением того, что плоскость — это бесконечная "
"поверхность (представьте себе бесконечный плоский лист бумаги, который можно "
"ориентировать и который закреплён в начале координат), а не прямая."

msgid "Distance to plane"
msgstr "Расстояние до самолета"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"Теперь, когда понятно, что такое плоскость, вернемся к скалярному "
"произведению. Скалярное произведение между **единичным вектором** и любой "
"**точкой в пространстве** (да, на этот раз мы делаем скалярное произведение "
"между вектором и положением) возвращает **расстояние от точки до плоскости**:"

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""
"Но не только абсолютное расстояние: если точка находится в отрицательном "
"полупространстве, расстояние тоже будет отрицательным:"

msgid "This allows us to tell which side of the plane a point is."
msgstr ""
"Это позволяет нам определить, на какой стороне плоскости находится точка."

msgid "Away from the origin"
msgstr "Вдали от источника"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"Я знаю, что вы думаете! Пока что это хорошо, но *реальные* плоскости есть "
"повсюду в пространстве, а не только проходят через начало координат. Вы "
"хотите настоящего *плоскостного* действия, и вы хотите этого *сейчас*."

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"Помните, что плоскости не только делят пространство на две части, но и "
"обладают *полярностью*. Это означает, что можно иметь идеально "
"перекрывающиеся плоскости, но их отрицательное и положительное "
"полупространства поменяются местами."

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"Имея это в виду, давайте опишем полную плоскость как **нормальную** *N* и "
"скаляр **расстояния от начала координат** *D*. Таким образом, наша плоскость "
"обозначается буквами N и D. Например:"

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"Для 3D-математики Godot предоставляет встроенный тип :ref:`Plane "
"<class_Plane>`, который обрабатывает это."

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"По сути, N и D могут представлять любую плоскость в пространстве, будь то 2D "
"или 3D (в зависимости от количества измерений N), и математика для обоих "
"одинакова. Это то же самое, что и раньше, но D — это расстояние от начала "
"координат до плоскости, движущейся в направлении N. В качестве примера "
"представьте, что вы хотите достичь точки на плоскости, вы просто сделаете:"

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"Это растянет (изменит размер) вектор нормали и заставит его коснуться "
"плоскости. Эта математика может показаться запутанной, но на самом деле она "
"намного проще, чем кажется. Если мы хотим снова определить расстояние от "
"точки до плоскости, мы делаем то же самое, но с поправкой на расстояние:"

msgid "The same thing, using a built-in function:"
msgstr "То же самое, используя встроенную функцию:"

msgid "This will, again, return either a positive or negative distance."
msgstr "Это снова вернет либо положительное, либо отрицательное расстояние."

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"Изменение полярности плоскости можно выполнить, отрицая N и D. В результате "
"плоскость окажется в том же положении, но с перевернутыми отрицательными и "
"положительными полупространствами:"

msgid ""
"Godot also implements this operator in :ref:`Plane <class_Plane>`. So, using "
"the format below will work as expected:"
msgstr ""
"Godot также реализует этот оператор в :ref:`Plane <class_Plane>`. Поэтому "
"использование следующего формата будет работать так, как и ожидалось:"

msgid ""
"So, remember, the plane's main practical use is that we can calculate the "
"distance to it. So, when is it useful to calculate the distance from a point "
"to a plane? Let's see some examples."
msgstr ""
"Итак, помните, главное практическое применение плоскости заключается в том, "
"что мы можем рассчитать расстояние до неё. Итак, когда же полезно вычислять "
"расстояние от точки до плоскости? Давайте рассмотрим несколько примеров."

msgid "Constructing a plane in 2D"
msgstr "Построение плоскости в 2D"

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"Плоскости явно не появляются из ниоткуда, поэтому их надо строить. Построить "
"их в 2D легко, это можно сделать либо по нормали (единичному вектору) и "
"точке, либо по двум точкам в пространстве."

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so calculate D from the dot product of the normal and "
"the point."
msgstr ""
"В случае нормали и точки большая часть работы выполнена, поскольку нормаль "
"уже вычислена, поэтому вычисляем D из скалярного произведения нормали и "
"точки."

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90 degrees to either "
"side:"
msgstr ""
"Для двух точек в пространстве существуют две плоскости, проходящие через "
"них, разделяя одно и то же пространство, но с нормалями, направленными в "
"противоположные стороны. Чтобы вычислить нормаль из двух точек, необходимо "
"сначала получить вектор направления, а затем повернуть его на 90 градусов в "
"любую сторону:"

msgid ""
"The rest is the same as the previous example. Either point_a or point_b will "
"work, as they are in the same plane:"
msgstr ""
"Остальное как в предыдущем примере. Подойдут как point_a, так и point_b, "
"поскольку они находятся в одной плоскости:"

msgid ""
"Doing the same in 3D is a little more complex and is explained further down."
msgstr "Сделать то же самое в 3D немного сложнее и будет объяснено ниже."

msgid "Some examples of planes"
msgstr "Несколько примеров плоскостей"

msgid ""
"Here is an example of what planes are useful for. Imagine you have a `convex "
"<https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"Вот пример того, для чего полезны плоскости. Представьте, что у вас есть "
"`выпуклый <https://www.mathsisfun.com/definitions/convex.html>`__ "
"многоугольник. Например, прямоугольник, трапеция, треугольник или любой "
"многоугольник, у которого ни одна из граней не загнута внутрь."

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"Для каждого сегмента многоугольника мы вычисляем плоскость, проходящую через "
"этот сегмент. Получив список плоскостей, мы можем делать изящные вещи, "
"например проверять, находится ли точка внутри многоугольника."

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"Проходим все плоскости, если удается найти плоскость, в которой расстояние "
"до точки положительное, то точка находится вне многоугольника. Если не "
"можем, то точка внутри."

msgid "Code should be something like this:"
msgstr "Код должен быть примерно таким:"

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"Довольно круто, да? Но это может стать намного лучше! Приложив немного "
"больше усилий, аналогичная логика сообщит нам, когда два выпуклых "
"многоугольника перекрываются. Это называется теоремой о разделяющей оси (или "
"SAT (Separating Axis Theorem)), и большинство физических движков используют "
"ее для обнаружения столкновений."

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"В случае с точкой достаточно просто проверить, возвращает ли плоскость "
"положительное расстояние, чтобы определить, находится ли точка снаружи. С "
"другим многоугольником мы должны найти плоскость, в которой *все* *другие* "
"*полигоны* *точки* возвращают положительное расстояние до него. Эта проверка "
"выполняется с плоскостями А по точкам В, а затем с плоскостями В по точкам А:"

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"Как видите, плоскости весьма полезны, и это лишь верхушка айсберга. Вам "
"может быть интересно, что происходит с невыпуклыми многоугольниками. Обычно "
"это решается путем разделения вогнутого многоугольника на более мелкие "
"выпуклые многоугольники или с использованием такого метода, как BSP (который "
"в настоящее время мало используется)."

msgid "Collision detection in 3D"
msgstr "Обнаружение столкновений в 3D"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"Это еще один бонус, награда за терпение и понимание хода мысли этого "
"длинного руководства. Вот еще одна мудрость. Возможно, это не что-то для "
"прямого использования (Godot уже неплохо справляется с обнаружением "
"столкновений), но оно используется почти всеми физическими движками и "
"библиотеками обнаружения столкновений :)"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"Помните, преобразование выпуклой формы в 2D в массив 2D плоскостей было "
"полезно для обнаружения столкновений? Вы могли определить, находится ли "
"точка внутри какой-либо выпуклой формы или перекрываются две выпуклые "
"двумерные формы."

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"Что ж, это работает и в 3D: если две трехмерные многогранные фигуры "
"сталкиваются, вы не сможете найти разделяющую плоскость. Если разделяющая "
"плоскость найдена, то фигуры точно не сталкиваются."

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"Немного обновить разделяющую плоскость означает, что все вершины "
"многоугольника A находятся на одной стороне плоскости, а все вершины "
"многоугольника B — на другой стороне. Эта плоскость всегда является одной из "
"граней либо многоугольника A, либо многоугольника B."

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"Однако в 3D пространстве этот подход имеет свою проблему, поскольку в "
"некоторых случаях разделяющую плоскость найти невозможно. Вот пример такой "
"ситуации:"

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"Чтобы избежать этого, необходимо проверить некоторые дополнительные "
"плоскости как разделители. Эти плоскости являются векторным произведением "
"между ребрами полигона A и ребрами полигона B"

msgid "So the final algorithm is something like:"
msgstr "Итак, окончательный алгоритм выглядит примерно так:"

msgid "More information"
msgstr "Дополнительная информация"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr ""
"Дополнительную информацию об использовании векторной математики в Godot "
"можно найти в следующей статье:"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
