#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Vector math"
msgstr "Векторная математика"

msgid "Introduction"
msgstr "Введение"

msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"Этот урок - короткое и практичное введение в линейную алгебру, применяемую в "
"разработке игр. Линейная алгебра изучает векторы и их использование. Векторы "
"могут применяться в 2D и 3D разработке и Godot использует их интенсивно. "
"Разработчику игр требуется хорошее понимание векторной алгебры чтобы стать "
"сильным в этой области."

msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"Этот урок — **не** учебник по линейной алгебре. Мы рассмотрим только то, что "
"применяется в разработке игр. Для более широкого взгляда на математику, "
"смотрите https://www.khanacademy.org/math/linear-algebra"

msgid "Coordinate systems (2D)"
msgstr "Системы координат (2D)"

msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"В 2D пространстве, координаты определены использованием горизонтальной оси "
"(``x``) и вертикальной оси (``y``). Определённая позиция в 2D пространстве "
"записывается как пара значений, таких как ``(4, 3)``."

msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"Если вы новичок в компьютерной графике, вам может показаться странным, что "
"положительная ось ``y`` указывает **вниз**, а не вверх, как вас учили в "
"школе. Тем не менее, в приложениях компьютерной графики это встречается "
"повсеместно."

msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"Любая точка на 2D плоскости может быть таким образом определена парой чисел. "
"Вы также можете рассматривать ``(4, 3)`` как **смещение** от точки ``(0, "
"0)``, или точки **начала** координат. Нарисуем стрелку от начала координат "
"до заданной точки:"

msgid ""
"This is a **vector**. A vector represents a lot of useful information. As "
"well as telling us that the point is at ``(4, 3)``, we can also think of it "
"as an angle ``θ`` (theta) and a length (or magnitude) ``m``. In this case, "
"the arrow is a **position vector** - it denotes a position in space, "
"relative to the origin."
msgstr ""
"Это **вектор**. Вектор предоставляет множество полезной информации. Помимо "
"сообщения нам, что точка расположена в ``(4, 3)``, мы можем также "
"представить это в виде угла ``θ`` и длины (величины, модуля) ``m``. В данном "
"примере стрелка — это **вектор позиции** — он обозначает позицию в "
"пространстве относительно начала координат."

msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"При рассмотрении векторов крайне важно иметь в виду, что они представляют "
"только **относительные** направление и величину (модуль). Вектору нельзя "
"приписать определённой позиции. Два следующих вектора идентичны:"

msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"Оба вектора представляют точку 4 единицами правее и 3 единицами ниже "
"стартовой точки. Неважно, где на плоскости вы нарисуете вектор, он всегда "
"представляет относительное направление и величину."

msgid "Vector operations"
msgstr "Операции над векторами"

msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"Вы можете применять любой из методов (задание координат x и y или угла с "
"длиной) для определения вектора, но обычно программисты используют "
"координаты. Для примера, в Godot начало координат — это верхний-левый угол "
"экрана, так что для перемещения 2D узла с именем ``Node2D`` на 400 пикселей "
"вправо и 300 вниз используйте следующий код:"

msgid ""
"Godot supports both :ref:`Vector2 <class_Vector2>` and :ref:`Vector3 "
"<class_Vector3>` for 2D and 3D usage, respectively. The same mathematical "
"rules discussed in this article apply to both types, and wherever we link to "
"``Vector2`` methods in the class reference, you can also check out their "
"``Vector3`` counterparts."
msgstr ""
"Godot поддерживает типы :ref:`Vector2 <class_Vector2>` и :ref:`Vector3 "
"<class_Vector3>` для 2D и 3D соответственно. Математические правила, "
"рассказанные в этой статье, применяются к обоим типам, и везде, где мы "
"ссылаемся на методы ``Vector2`` в ссылке на класс, вы также можете "
"ознакомиться с их аналогами ``Vector3``."

msgid "Member access"
msgstr "Доступ к полям"

msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr ""
"К отдельным компонентам вектора можно обращаться непосредственно по имени."

msgid "Adding vectors"
msgstr "Сложение векторов"

msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr ""
"Когда два вектора складываются или вычитаются, складываются соответствующие "
"компоненты:"

msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr ""
"Мы также можем посмотреть визуально на добавление второго вектора к концу "
"первого:"

msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr ""
"Отметьте что сложение ``a + b`` даёт такой же результат что и ``b + a``."

msgid "Scalar multiplication"
msgstr "Скалярное перемножение"

msgid ""
"Vectors represent both direction and magnitude. A value representing only "
"magnitude is called a **scalar**. Scalars use the :ref:`class_float` type in "
"Godot."
msgstr ""
"Векторы представляют как направление, так и величину. Значение, "
"представляющее только величину, называется **скаляром**. в Godot, скаляры "
"используют тип :ref:`class_float`."

msgid "A vector can be multiplied by a **scalar**:"
msgstr "Вектор может быть умножен на **скаляр**:"

msgid ""
"Multiplying a vector by a positive scalar does not change its direction, "
"only its magnitude. Multiplying with a negative scalar results in a vector "
"in the opposite direction. This is how you **scale** a vector."
msgstr ""
"Умножение вектора на положительный скаляр не изменяет его направление, а "
"только величину. Умножение на отрицательный скаляр приводит к получению "
"вектора в противоположном направлении. Вот как вы **масштабируете** вектор."

msgid "Practical applications"
msgstr "Практические применения"

msgid "Let's look at two common uses for vector addition and subtraction."
msgstr ""
"Давайте посмотрим на два обычных приёма использования для векторного "
"сложения и вычитания."

msgid "Movement"
msgstr "Движение"

msgid ""
"A vector can represent **any** quantity with a magnitude and direction. "
"Typical examples are: position, velocity, acceleration, and force. In this "
"image, the spaceship at step 1 has a position vector of ``(1, 3)`` and a "
"velocity vector of ``(2, 1)``. The velocity vector represents how far the "
"ship moves each step. We can find the position for step 2 by adding the "
"velocity to the current position."
msgstr ""
"Вектор может представлять **любую** величину, имеющую модуль и направление. "
"Типичные примеры: положение (position), скорость (velocity), ускорение "
"(acceleration) и сила (force). На этом изображении космический корабль на "
"шаге 1 имеет вектор положения ``(1, 3)`` и вектор скорости ``(2, 1)``. "
"Вектор скорости показывает, насколько далеко корабль перемещается на каждом "
"шаге. Мы можем найти положение для шага 2, прибавив скорость к текущему "
"положению."

msgid ""
"Velocity measures the **change** in position per unit of time. The new "
"position is found by adding the velocity multiplied by the elapsed time "
"(here assumed to be one unit, e.g. 1 s) to the previous position."
msgstr ""
"Скорость измеряет **изменение** положения за единицу времени. Новое "
"положение определяется путём прибавления скорости, умноженной на прошедшее "
"время (в данном случае предполагается, что оно равно одной единице, "
"например, 1 s), к предыдущему положению."

msgid ""
"In a typical 2D game scenario, you would have a velocity in pixels per "
"second, and multiply it by the ``delta`` parameter (time elapsed since the "
"previous frame) from the :ref:`_process() "
"<class_Node_private_method__process>` or :ref:`_physics_process() "
"<class_Node_private_method__physics_process>` callbacks."
msgstr ""
"В типичных сценариях 2D игр, у вас есть скорость в пикселях в секунду, и вы "
"умножаете её на параметр ``delta`` (время, прошедшее с предыдущего кадра) из "
"вызовов :ref:`_process() <class_Node_private_method__process>` "
"или :ref:`_physics_process() <class_Node_private_method__physics_process>`."

msgid "Pointing toward a target"
msgstr "Направление в сторону цели"

msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"В этом примере вы, управляя танком, хотите направить дуло на робота. "
"Вычитание позиции танка из позиции робота даёт вектор, направленный от танка "
"к роботу."

msgid "To find a vector pointing from ``A`` to ``B``, use ``B - A``."
msgstr ""
"Чтобы найти вектор, направленный от ``A`` к ``B``, используйте ``B - A``."

msgid "Unit vectors"
msgstr "Единичные векторы"

msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"Вектор с **длиной**, равной ``1``, называется **единичным вектором**. Они "
"также иногда называются **векторами направления** или **нормалями**. "
"Единичные векторы полезны, когда вам нужно сохранить направление без учёта "
"длины."

msgid "Normalization"
msgstr "Нормализация"

msgid ""
"**Normalizing** a vector means reducing its length to ``1`` while preserving "
"its direction. This is done by dividing each of its components by its "
"magnitude. Because this is such a common operation, Godot provides a "
"dedicated :ref:`normalized() <class_Vector2_method_normalized>` method for "
"this:"
msgstr ""
"**Normalizing (Нормализация)** вектора означает уменьшение его длины до "
"``1`` с сохранением направления. Это достигается делением каждого из его "
"компонентов на его модуль. Поскольку эта операция встречается так часто, "
"Godot предоставляет для этого специальный метод :ref:`normalized() "
"<class_Vector2_method_normalized>`:"

msgid ""
"Because normalization involves dividing by the vector's length, you cannot "
"normalize a vector of length ``0``. Attempting to do so would normally "
"result in an error. In GDScript though, trying to call the ``normalized()`` "
"method on a vector of length 0 leaves the value untouched and avoids the "
"error for you."
msgstr ""
"Поскольку нормализация подразумевает деление на длину вектора, вектор длины "
"``0`` нормализовать невозможно. Попытка сделать это обычно приводит к "
"ошибке. Однако в GDScript попытка вызвать метод ``normalized()`` для вектора "
"длины 0 оставляет значение неизменным и позволяет избежать ошибки."

msgid "Reflection"
msgstr "Отражение"

msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"Обычный пример использования единичных векторов - определение **нормалей**. "
"Векторы нормалей - это единичные векторы, перпендикулярные к поверхности, "
"определяющей их направление. Обычно они используются в обработке света, "
"столкновений и других операциях с поверхностями."

msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr ""
"Например, представьте что вы движете шар, который вы хотите отражать от стен "
"или других объектов:"

msgid ""
"The surface normal has a value of ``(0, -1)`` because this is a horizontal "
"surface. When the ball collides, we take its remaining motion (the amount "
"left over when it hits the surface) and reflect it using the normal. In "
"Godot, there is a :ref:`bounce() <class_Vector2_method_bounce>` method to "
"handle this. Here is a code example of the above diagram using "
"a :ref:`CharacterBody2D <class_CharacterBody2D>`:"
msgstr ""
"Нормаль поверхности имеет значение ``(0, -1)``, поскольку это горизонтальная "
"поверхность. При столкновении мяча мы берём его оставшееся движение "
"(количество оставшихся после удара о поверхность) и отражаем его с помощью "
"нормали. В Godot для этого есть метод :ref:`bounce() "
"<class_Vector2_method_bounce>`. Вот пример кода для вышеприведённой "
"диаграммы с использованием :ref:`CharacterBody2D <class_CharacterBody2D>`:"

msgid "Dot product"
msgstr "Скалярное произведение"

msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"Результат **скалярного произведения** очень важный аспект в векторной "
"алгебре, но его также часто плохо понимают. Скалярное произведение это "
"операция над двумя векторами которая возвращает **скаляр**. В отличии от "
"вектора, который содержит длину и направление, скаляр содержит только длину."

msgid "The formula for dot product takes two common forms:"
msgstr "Формула скалярного произведения имеет две распространённых формы:"

msgid "and"
msgstr "и"

msgid ""
"The mathematical notation *||A||* represents the magnitude of vector ``A``, "
"and *A*\\ :sub:`x` means the ``x`` component of vector ``A``."
msgstr ""
"Математическая запись *||A||* представляет величину вектора ``A``, а "
"*A*\\ :sub:`x` означает компоненту ``x`` вектора ``A``."

msgid ""
"However, in most cases it is easiest to use the built-in :ref:`dot() "
"<class_Vector2_method_dot>` method. Note that the order of the two vectors "
"does not matter:"
msgstr ""
"Однако в большинстве случаев проще всего использовать встроенный "
"метод :ref:`dot() <class_Vector2_method_dot>`. Обратите внимание, что "
"порядок векторов не имеет значения:"

msgid ""
"The dot product is most useful when used with unit vectors, making the first "
"formula reduce to just ``cos(θ)``. This means we can use the dot product to "
"tell us something about the angle between two vectors:"
msgstr ""
"Скалярное произведение наиболее полезно при использовании с единичными "
"векторами, что позволяет сократить первую формулу до ``cos(θ)``. Это "
"означает, что мы можем использовать скалярное произведение, чтобы получить "
"информацию об угле между двумя векторами:"

msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr ""
"При использовании единичных векторов результат всегда будет находиться между "
"``-1`` (180°) и ``1`` (0°)."

msgid "Facing"
msgstr "Направление взгляда"

msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"Мы можем использовать этот факт для обнаружения, что объект смотрит в "
"направлении другого объекта. На диаграмме ниже, игрок ``P`` пытается "
"избежать взгляда зомби ``A`` и ``B``. Могут ли зомби его увидеть если их "
"угол обзора равен **180°** ?"

msgid ""
"The green arrows ``fA`` and ``fB`` are **unit vectors** representing the "
"zombie's facing direction and the blue semicircle represents its field of "
"view. For zombie ``A``, we find the direction vector ``AP`` pointing to the "
"player using ``P - A`` and normalize it, however, Godot has a helper method "
"to do this called :ref:`direction_to() <class_Vector2_method_direction_to>`. "
"If the angle between this vector and the facing vector is less than 90°, "
"then the zombie can see the player."
msgstr ""
"Зелёные стрелки ``fA`` и ``fB`` — это **единичные векторы**, указывающие "
"направление взгляда зомби, а синий полукруг — его поле зрения. Для зомби "
"``A`` мы находим вектор направления ``AP``, указывающий на игрока, используя "
"``P - A``, и нормализуем его. Однако в Godot есть вспомогательный метод для "
"этого, называемый :ref:`direction_to() <class_Vector2_method_direction_to>`. "
"Если угол между этим вектором и вектором направления взгляда меньше 90°, то "
"зомби видит игрока."

msgid "In code it would look like this:"
msgstr "В коде это бы выглядело как:"

msgid "Cross product"
msgstr "Векторное произведение"

msgid ""
"Like the dot product, the **cross product** is an operation on two vectors. "
"However, the result of the cross product is a vector with a direction that "
"is perpendicular to both. Its magnitude depends on their relative angle. If "
"two vectors are parallel, the result of their cross product will be a null "
"vector."
msgstr ""
"Также как и скалярное произведение, **векторное произведение** это операция "
"над двумя векторами. Но в результате векторного произведения вы получаете "
"вектор с направлением перпендикулярным обоим исходным векторам. Его длина "
"зависит от их относительного угла. Если два вектора параллельны, в "
"результате вы получите нулевой вектор."

msgid "The cross product is calculated like this:"
msgstr "Векторное произведение вычисляется так:"

msgid ""
"With Godot, you can use the built-in :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` method:"
msgstr ""
"С Godot вы можете использовать встроенный метод :ref:`Vector3.cross() "
"<class_Vector3_method_cross>`:"

msgid ""
"The cross product is not mathematically defined in 2D. "
"The :ref:`Vector2.cross() <class_Vector2_method_cross>` method is a commonly "
"used analog of the 3D cross product for 2D vectors."
msgstr ""
"Векторное произведение математически не определено в двумерном пространстве. "
"Метод :ref:`Vector2.cross() <class_Vector2_method_cross>` — это широко "
"используемый аналог трёхмерного векторного произведения для двумерных "
"векторов."

msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"В векторном произведении, порядок аргументов важен. ``a.cross(b)`` не даёт "
"такого же результата что и ``b.cross(a)``. Получаемые векторы имеют "
"**противоположные** направления."

msgid "Calculating normals"
msgstr "Расчитывание нормалей"

msgid ""
"One common use of cross products is to find the surface normal of a plane or "
"surface in 3D space. If we have the triangle ``ABC`` we can use vector "
"subtraction to find two edges ``AB`` and ``AC``. Using the cross product, "
"``AB × AC`` produces a vector perpendicular to both: the surface normal."
msgstr ""
"Одно из распространённых применений векторных произведений — поиск нормали к "
"плоскости или поверхности в трёхмерном пространстве. Если у нас есть "
"треугольник ``ABC``, мы можем использовать вычитание векторов для нахождения "
"двух рёбер ``AB`` и ``AC``. Используя векторное произведение, ``AB × AC`` "
"получаем вектор, перпендикулярный обоим рёбрам: нормаль к поверхности."

msgid "Here is a function to calculate a triangle's normal:"
msgstr "Здесь показана функция для вычисления нормали треугольника:"

msgid "Pointing to a target"
msgstr "Направление на цель"

msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"В скалярном произведении выше, мы видели как оно может использоваться для "
"нахождения угла между двумя векторами. Однако для 3D этого недостаточно. Мы "
"также должны знать вокруг какой оси нужно осуществлять вращение. Мы можем "
"найти её выполняя векторное произведение текущего направления взгляда и "
"направлением цели. В результате мы получим перпендикулярный вектор оси "
"вращения."

msgid "More information"
msgstr "Дополнительная информация"

msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr ""
"Для большей информации об использовании векторной алгебры в Godot, смотрите "
"следующие статьи:"

msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
