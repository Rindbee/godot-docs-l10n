#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "Сохранение игр"

msgid "Introduction"
msgstr "Введение"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"Игры с сохранением могут быть сложными. Например, может быть желательно "
"сохранить информацию о нескольких объектах на нескольких уровнях. "
"Продвинутые системы сохранения игр должны позволять сохранять дополнительную "
"информацию о произвольном количестве объектов. Это позволит масштабировать "
"функцию сохранения по мере усложнения игры."

msgid ""
"If you're looking to save user configuration, you can use "
"the :ref:`class_ConfigFile` class for this purpose."
msgstr ""
"Если вы хотите сохранить конфигурацию пользователя, вы можете использовать "
"для этого класс :ref:`class_ConfigFile`."

msgid ""
"You can see how saving and loading works in action using the `Saving and "
"Loading (Serialization) demo project <https://github.com/godotengine/godot-"
"demo-projects/blob/master/loading/serialization>`__."
msgstr ""
"Вы можете увидеть, как сохранение и загрузка работают в действии, используя "
"`Демонстрационный проект сохранения и загрузки (сериализации) <https://"
"github.com/godotengine/godot-demo-projects/blob/master/loading/"
"serialization>`__."

msgid "Identify persistent objects"
msgstr "Идентификация постоянных объектов"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"Во-первых, мы должны определить, какие объекты мы хотим сохранить между "
"игровыми сессиями и какую информацию мы хотим сохранить от этих объектов. В "
"этом учебнике мы будем использовать группы для маркировки и обработки "
"объектов для сохранения, но, конечно, возможны и другие методы."

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"Мы начнем с добавления объектов, которые мы хотим сохранить, в группу "
"\"Persist\". Мы можем сделать это с помощью графического интерфейса или "
"скрипта. Давайте добавим соответствующие узлы с помощью графического "
"интерфейса:"

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"Когда это будет сделано, когда нам понадобится сохранить игру, мы сможем "
"получить все объекты для сохранения, а затем сказать им всем сохраниться с "
"помощью этого скрипта:"

msgid "Serializing"
msgstr "Сериализация"

msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has the helper "
"class :ref:`JSON<class_json>` to convert between dictionary and string. Our "
"node needs to contain a save function that returns this data. The save "
"function will look like this:"
msgstr ""
"Следующий шаг — сериализация данных. Это значительно упрощает чтение и "
"сохранение на диск. В данном случае мы предполагаем, что каждый член группы "
"Persist является экземпляром узла и, следовательно, имеет путь. В GDScript "
"есть вспомогательный класс :ref:`JSON<class_json>` для преобразования "
"словаря в строку. Наш узел должен содержать функцию сохранения, возвращающую "
"эти данные. Функция сохранения будет выглядеть следующим образом:"

msgid ""
"This gives us a dictionary with the style "
"``{ \"variable_name\":value_of_variable }``, which will be useful when "
"loading."
msgstr ""
"Это дает нам словарь со стилем ``{\"имя_переменной\":значение_переменной }"
"``, который будет полезен при загрузке."

msgid "Saving and reading data"
msgstr "Сохранение и чтение данных"

msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use the "
"class :ref:`JSON<class_json>` to convert it into an easily stored string and "
"store them in a file. Doing it this way ensures that each line is its own "
"object, so we have an easy way to pull the data out of the file as well."
msgstr ""
"Как уже говорилось в руководстве по :ref:`doc_filesystem`, нам нужно открыть "
"файл, чтобы можно было записывать в него данные или читать из него. Теперь, "
"когда у нас есть способ вызывать группы и получать их данные, давайте "
"используем класс :ref:`JSON<class_json>`, чтобы преобразовать их в удобную "
"для хранения строку и сохранить в файле. Такой подход гарантирует, что "
"каждая строка будет представлять собой отдельный объект, поэтому мы также "
"легко извлекаем данные из файла."

msgid ""
"Game saved! Now, to load, we'll read each line. Use "
"the :ref:`parse<class_JSON_method_parse>` method to read the JSON string "
"back to a dictionary, and then iterate over the dict to read our values. But "
"we'll need to first create the object and we can use the filename and parent "
"values to achieve that. Here is our load function:"
msgstr ""
"Игра сохранена! Теперь, чтобы загрузить, мы будем читать каждую строку. "
"Используйте метод :ref:`parse<class_JSON_method_parse>` для чтения JSON-"
"строки обратно в словарь, а затем пройдитесь по словарю, чтобы прочитать "
"наши значения. Но сначала нам нужно создать объект, и для этого мы можем "
"использовать имя файла и родительские значения. Вот наша функция загрузки:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"Теперь мы можем сохранять и загружать произвольное количество объектов, "
"расположенных практически в любом месте дерева сцены! Каждый объект может "
"хранить различные данные в зависимости от того, что ему нужно сохранить."

msgid "Some notes"
msgstr "Некоторые примечания"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"Мы подробно остановились на настройке состояния игры для загрузки. В "
"конечном итоге от создателя проекта зависит, куда будет направлена большая "
"часть этой логики. Это часто бывает сложно и требует значительной настройки "
"в зависимости от потребностей конкретного проекта."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"Кроме того, наша реализация предполагает, что никакие объекты Persist не "
"являются дочерними для других объектов Persist. В противном случае будут "
"создаваться недопустимые пути. Чтобы учесть вложенные объекты Persist, "
"рассмотрите возможность поэтапного сохранения объектов. Сначала загрузите "
"родительские объекты, чтобы они были доступны для вызова :ref:`add_child() "
"<class_node_method_add_child>`, когда загружаются дочерние объекты. Вам "
"также понадобится способ связать дочерние объекты с родительскими, "
"поскольку :ref:`NodePath <class_nodepath>`, скорее всего, будет "
"недействительным."

msgid "JSON vs binary serialization"
msgstr "JSON против двоичной сериализации"

msgid ""
"For simple game state, JSON may work and it generates human-readable files "
"that are easy to debug."
msgstr ""
"Для простого игрового состояния может подойти JSON, который генерирует "
"понятные человеку файлы, которые легко отлаживать."

msgid ""
"But JSON has many limitations. If you need to store more complex game state "
"or a lot of it, :ref:`binary serialization<doc_binary_serialization_api>` "
"may be a better approach."
msgstr ""
"Но у JSON есть множество ограничений. Если вам нужно хранить более сложное "
"или большое количество игрового состояния, :ref:`binary "
"serialization<doc_binary_serialization_api>` может быть лучшим подходом."

msgid "JSON limitations"
msgstr "Ограничения JSON"

msgid "Here are some important gotchas to know about when using JSON."
msgstr ""
"Вот несколько важных моментов, которые следует знать при использовании JSON."

msgid ""
"**Filesize:** JSON stores data in text format, which is much larger than "
"binary formats."
msgstr ""
"**Filesize:** JSON хранит данные в текстовом формате, который намного больше "
"двоичных форматов."

msgid ""
"**Data types:** JSON only offers a limited set of data types. If you have "
"data types that JSON doesn't have, you will need to translate your data to "
"and from types that JSON can handle. For example, some important types that "
"JSON can't parse are: ``Vector2``, ``Vector3``, ``Color``, ``Rect2``, and "
"``Quaternion``."
msgstr ""
"**Data types:** JSON поддерживает лишь ограниченный набор типов данных. Если "
"у вас есть типы данных, которых нет в JSON, вам потребуется преобразовать их "
"в типы, поддерживаемые JSON, и обратно. Например, вот некоторые важные типы, "
"которые JSON не может обработать: ``Vector2``, ``Vector3``, ``Color``, "
"``Rect2`` и ``Quaternion``."

msgid ""
"**Custom logic needed for encoding/decoding:** If you have any custom "
"classes that you want to store with JSON, you will need to write your own "
"logic for encoding and decoding those classes."
msgstr ""
"**Для кодирования/декодирования требуется специальная логика:** Если у вас "
"есть какие-либо специальные классы, которые вы хотите хранить с помощью "
"JSON, вам потребуется написать собственную логику для кодирования и "
"декодирования этих классов."

msgid "Binary serialization"
msgstr "Binary serialization (Двоичная сериализация)"

msgid ""
":ref:`Binary serialization<doc_binary_serialization_api>` is an alternative "
"approach for storing game state, and you can use it with the functions "
"``get_var`` and ``store_var`` of :ref:`class_FileAccess`."
msgstr ""
":ref:`Binary serialization<doc_binary_serialization_api>` — это "
"альтернативный подход к хранению состояния игры, и вы можете использовать "
"его с функциями ``get_var`` и ``store_var`` из :ref:`class_FileAccess`."

msgid "Binary serialization should produce smaller files than JSON."
msgstr ""
"Двоичная сериализация должна создавать файлы меньшего размера, чем JSON."

msgid "Binary serialization can handle most common data types."
msgstr ""
"Двоичная сериализация может обрабатывать большинство распространенных типов "
"данных."

msgid ""
"Binary serialization requires less custom logic for encoding and decoding "
"custom classes."
msgstr ""
"Двоичная сериализация требует меньше пользовательской логики для кодирования "
"и декодирования пользовательских классов."

msgid ""
"Note that not all properties are included. Only properties that are "
"configured with "
"the :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"flag set will be serialized. You can add a new usage flag to a property by "
"overriding "
"the :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"method in your class. You can also check how property usage is configured by "
"calling ``Object._get_property_list``. "
"See :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` for the "
"possible usage flags."
msgstr ""
"Обратите внимание, что включены не все свойства. Сериализуются только "
"свойства, настроенные с установленным "
"флагом :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>`. "
"Вы можете добавить новый флаг использования к свойству, переопределив "
"метод :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"в вашем классе. Вы также можете проверить, как настроено использование "
"свойства, вызвав ``Object._get_property_list``. "
"См. :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` для "
"получения информации о возможных флагах использования."
