# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#, fuzzy
msgid "OpenXR Settings"
msgstr "설정"

msgid ""
"OpenXR has its own set of settings that are applied when OpenXR starts. "
"While it is possible for OpenXR extensions implemented through Godot plugins "
"to add additional settings, we will only discuss the settings in the core of "
"Godot here."
msgstr ""

msgid "Enabled"
msgstr "활성화됨"

msgid ""
"This setting enables the OpenXR module when Godot starts. This is required "
"when the Vulkan backend is used. For other backends you can enable OpenXR at "
"any time by calling ``initialize`` on the :ref:`OpenXRInterface "
"<class_openxrinterface>`."
msgstr ""

msgid "This also needs to be enabled to get access to the action map editor."
msgstr ""

msgid ""
"You can use the ``--xr-mode on`` command line switch to force this to on."
msgstr ""

#, fuzzy
msgid "Default Action Map"
msgstr "빛 애니메이션"

msgid ""
"This specifies the path of the action map file that OpenXR will load and "
"communicate to the XR Runtime."
msgstr ""

#, fuzzy
msgid "Form Factor"
msgstr "형식"

msgid "This specifies whether your game is designed for:"
msgstr ""

msgid ""
"``Head Mounted`` devices such as a Meta Quest, Valve Index, or Magic Leap,"
msgstr ""

msgid "``Handheld`` devices such as phones."
msgstr ""

msgid ""
"If the device on which you run your game does not match the selection here, "
"OpenXR will fail to initialise."
msgstr ""

#, fuzzy
msgid "View Configuration"
msgstr "엔진 싱글톤(Engine Singleton)"

msgid "This specifies the view configuration your game is designed for:"
msgstr ""

msgid ""
"``Mono``, your game provides a single image output. E.g. phone based AR;"
msgstr ""

msgid ""
"``Stereo``, your game provides stereo image output. E.g. head mounted "
"devices."
msgstr ""

msgid ""
"OpenXR has additional view configurations for very specific devices that "
"Godot doesn't support yet. For instance, Varjo headsets have a quad view "
"configuration that outputs two sets of stereo images. These may be supported "
"in the near future."
msgstr ""

#, fuzzy
msgid "Reference Space"
msgstr "구현"

msgid ""
"Within XR all elements like the player's head and hands are tracked within a "
"tracking volume. At the base of this tracking volume is our origin point, "
"which maps our virtual space to the real space. There are however different "
"scenarios that place this point in different locations, depending on the XR "
"system used. In OpenXR these scenarios are well defined and selected by "
"setting a reference space."
msgstr ""

#, fuzzy
msgid "Local"
msgstr "위치"

msgid ""
"The local reference space places our origin point at the player's head by "
"default. Some XR runtimes will do this each time your game starts, others "
"will make the position persist over sessions."
msgstr ""

msgid ""
"This reference space however does not prevent the user from walking away so "
"you will need to detect if the user does so if you wish to prevent the user "
"from leaving the vehicle they are controlling, which could potentially be "
"game breaking."
msgstr ""

msgid ""
"This reference space is the best option for games like flight simulators or "
"racing simulators where we want to place the :ref:`XROrigin3D "
"<class_xrorigin3d>` node where the player's head should be."
msgstr ""

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will move the :ref:"
"`XRCamera3D <class_xrcamera3d>` to the :ref:`XROrigin3D <class_xrorigin3d>` "
"node. The :ref:`OpenXRInterface <class_openxrinterface>` will also emit the "
"``pose_recentered`` signal so your game can react accordingly."
msgstr ""

msgid ""
"Any other XR tracked elements such as controllers or anchors will also be "
"adjusted accordingly."
msgstr ""

msgid ""
"You should **not** call ``center_on_hmd`` when using this reference space."
msgstr ""

msgid "Stage"
msgstr ""

msgid ""
"The stage reference space is our default reference space and places our "
"origin point at the center of our play space. For XR runtimes that allow you "
"to draw out a guardian boundary this location and its orientation is often "
"set by the user. Other XR runtimes may decide on the placement of this point "
"by other means. It is however a stationary point in the real world."
msgstr ""

msgid ""
"This reference space is the best option for room scale games where the user "
"is expected to walk around a larger space, or for games where there is a "
"need to switch between game modes. See :ref:`Room Scale <doc_xr_room_scale>` "
"for more information."
msgstr ""

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will not change the origin "
"point. The :ref:`OpenXRInterface <class_openxrinterface>` will emit the "
"``pose_recentered`` signal and it is up to the game to react appropriately. "
"Not doing so will prevent your game from being accepted on various stores."
msgstr ""

msgid ""
"In Godot you can do this by calling the ``center_on_hmd`` function on the :"
"ref:`XRServer <class_xrserver>`:"
msgstr ""

msgid ""
"Calling ``XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)`` will "
"move the :ref:`XRCamera3D <class_xrcamera3d>` node to the :ref:`XROrigin3D "
"<class_xrorigin3d>` node similar to the ``Local`` reference space."
msgstr ""

msgid ""
"Calling ``XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)`` will "
"move the :ref:`XRCamera3D <class_xrcamera3d>` node above the :ref:"
"`XROrigin3D <class_xrorigin3d>` node keeping the player's height, similar to "
"the ``Local Floor`` reference space."
msgstr ""

#, fuzzy
msgid "Local Floor"
msgstr "로컬 좌표"

msgid ""
"The local floor reference space is similar to the local reference space as "
"it positions the origin point where the player is. In this mode however the "
"height of the player is kept. Same as with the local reference space, some "
"XR runtimes will persist this location over sessions."
msgstr ""

msgid ""
"It is thus not guaranteed the player will be standing on the origin point, "
"the only guarantee is that they were standing there when the user last "
"recentered. The player is thus also free to walk away."
msgstr ""

msgid ""
"This reference space is the best option of games where the user is expected "
"to stand in the same location or for AR type games where the user's "
"interface elements are bound to the origin node and are quickly placed at "
"the player's location on recenter."
msgstr ""

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will move the :ref:"
"`XRCamera3D <class_xrcamera3d>` above the :ref:`XROrigin3D "
"<class_xrorigin3d>` node but keeping the player's height. The :ref:"
"`OpenXRInterface <class_openxrinterface>` will also emit the "
"``pose_recentered`` signal so your game can react accordingly."
msgstr ""

msgid ""
"Be careful using this mode in combination with virtual movement of the "
"player. The user recentering in this scenario can be unpredictable unless "
"you counter the move when handling the recenter signal. This can even be "
"game breaking as the effect in this scenario would be the player teleporting "
"to whatever abstract location the origin point was placed at during virtual "
"movement, including the ability for players teleporting into locations that "
"should be off limits. It is better to use the Stage mode in this scenario "
"and limit resetting to orientation only when a ``pose_recentered`` signal is "
"received."
msgstr ""

#, fuzzy
msgid "Environment Blend Mode"
msgstr "환경 옵션"

msgid ""
"The environment blend mode defines how our rendered output is blended into "
"\"the real world\" provided this is supported by the headset."
msgstr ""

msgid "``Opaque`` means our output obscures the real world, we are in VR mode."
msgstr ""

msgid ""
"``Additive`` means our output is added to the real world, this is an AR mode "
"where optics do not allow us to fully obscure the real world (e.g. Hololens),"
msgstr ""

msgid ""
"``Alpha`` means our output is blended with the real world using the alpha "
"output (viewport should have transparent background enabled), this is an AR "
"mode where optics can fully obscure the real world (Magic Leap, all pass "
"through devices, etc.)."
msgstr ""

msgid ""
"If a mode is selected that is not supported by the headset, the first "
"available mode will be selected."
msgstr ""

msgid ""
"Some OpenXR devices have separate systems for enabling/disabling "
"passthrough. From Godot 4.3 onwards selecting the alpha blend mode will also "
"perform these extra steps. This does require the latest vendor plugin to be "
"installed."
msgstr ""

#, fuzzy
msgid "Foveation Level"
msgstr "최적화(Optimization)"

msgid ""
"Sets the foveation level used when rendering provided this feature is "
"supported by the hardware used. Foveation is a technique where the further "
"away from the center of the viewport we render content, the lower resolution "
"we render at. Most XR runtimes only support fixed foveation, but some will "
"take eye tracking into account and use the focal point for this effect."
msgstr ""

msgid ""
"The higher the level, the better the performance gains, but also the more "
"reduction in quality there is in the users peripheral vision."
msgstr ""

msgid ""
"**Compatibility renderer only**, for Mobile and Forward+ renderer, set the "
"``vrs_mode`` property on :ref:`Viewport <class_viewport>` to ``VRS_XR``."
msgstr ""

msgid ""
"This feature is disabled if post effects are used such as glow, bloom, or "
"DOF."
msgstr ""

msgid "Foveation Dynamic"
msgstr ""

msgid ""
"When enabled the foveation level will be adjusted automatically depending on "
"current GPU load. It will be adjusted between low and the select foveation "
"level in the previous setting. It is therefore best to combine this setting "
"with foveation level set to high."
msgstr ""

msgid "**Compatibility renderer only**"
msgstr ""

msgid "Submit Depth Buffer"
msgstr ""

msgid ""
"If enabled an OpenXR supplied depth buffer will be used while rendering "
"which is submitted alongside the rendered image. The XR runtime can use this "
"for improved reprojection."
msgstr ""

msgid ""
"Enabling this feature will disable stencil support during rendering. Not "
"many XR runtimes make use of this, it is advised to leave this setting off "
"unless it provides noticeable benefits for your use case."
msgstr ""

msgid "Startup Alert"
msgstr ""

msgid ""
"If enabled, this will result in an alert message presented to the user if "
"OpenXR fails to start. We don't always receive feedback from the XR system "
"as to why starting fails. If we do, we log this to the console. Common "
"failure reasons are:"
msgstr ""

msgid "No OpenXR runtime is installed on the host system."
msgstr ""

msgid ""
"Microsoft's WMR OpenXR runtime is currently active, this only supports "
"DirectX and will fail if OpenGL or Vulkan is used."
msgstr ""

msgid "SteamVR is used but no headset is connected/turned on."
msgstr ""

msgid ""
"Disable this if you support a fallback mode in your game so it can be played "
"in desktop mode when no VR headset is connected, or if you're handling the "
"failure condition yourself by checking ``OpenXRInterface.is_initialized()``."
msgstr ""

#, fuzzy
msgid "Extensions"
msgstr "Expression Node(표현식 노드)"

msgid "This subsection provides access to various optional OpenXR extensions."
msgstr ""

#, fuzzy
msgid "Hand Tracking"
msgstr "굽기"

msgid ""
"This enables the hand tracking extension when supported by the device used. "
"This is on by default for legacy reasons. The hand tracking extension "
"provides access to data that allows you to visualise the user's hands with "
"correct finger positions. Depending on platform capabilities the hand "
"tracking data can be inferred from controller inputs, come from data gloves, "
"come from optical hand tracking sensors or any other applicable source."
msgstr ""

msgid "If your game only supports controllers this should be turned off."
msgstr ""

msgid ""
"See the chapter on :ref:`hand tracking <doc_openxr_hand_tracking>` for "
"additional details."
msgstr ""

#, fuzzy
msgid "Eye Gaze Interaction"
msgstr "보간"

msgid ""
"This enables the eye gaze interaction extension when supported by the device "
"used. When enabled we will get feedback from eye tracking through a pose "
"situated between the user's eyes orientated in the direction the user is "
"looking. This will be a unified orientation."
msgstr ""

msgid ""
"In order to use this functionality you need to edit your action map and add "
"a new pose action, say ``eye_pose``. Now add a new interaction profile for "
"the eye gaze interaction and map the ``eye_pose``:"
msgstr ""

msgid "Don't forget to save!"
msgstr ""

msgid ""
"Next add a new :ref:`XRController3D <class_xrcontroller3d>` node to your "
"origin node and set its ``tracker`` property to ``/user/eyes_ext`` and set "
"its ``pose`` property to ``eye_pose``."
msgstr ""

msgid ""
"Now you can add things to this controller node such as a raycast, and "
"control things with your eyes."
msgstr ""

msgid "Translation status"
msgstr "번역 상태"
