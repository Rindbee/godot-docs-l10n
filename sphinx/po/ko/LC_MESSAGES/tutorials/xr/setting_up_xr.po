#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "XR 설정하기"

msgid "Introduction to the XR system in Godot"
msgstr "Godot의 XR 시스템 소개"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot는 사용자가 서로 다른 XR 플랫폼들의 특수한 사항을 신경쓰지 않게 하기 위"
"해서 추상화된 모듈화 XR 시스템을 제공합니다. 그 핵심은 :ref:`XRServer "
"<class_xrserver>`로 XR 시스템과의 일원화된 인터페이스이며 사용자는 여기서 XR "
"시스템의 인터페이스를 찾을 수 있고, 컴포넌트와 상호작용할 수 있습니다."

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"인터페이스가 등록되었다는 것은 단순히 그 인터페이스가 사용 가능하다는 의미이"
"며, 만일 호스트 시스템에서 그 인터페이스를 지원하지 않는다면 초기화가 실패하"
"고 ``false``를 반환합니다. 이런 일이 발생하는 원인은 다양하며, 안타깝게도 플"
"랫폼별로 그 이유가 다를 수 있습니다. 사용자가 필요한 소프트웨어를 설치하지 않"
"아서 일 수도 있고, 헤드셋을 연결하지 않았기 때문일 수도 있습니다. 여러분은 개"
"발자로써, 인터페이스의 초기화가 실패할 경우 그에 따라 적절히 반응하도록 개발"
"하셔야 합니다."

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"하나의 인터페이스로만 XR 장치의 출력을 관리할 수 있다는 점에 유의하세요. 이"
"를 주(primary) 인터페이스라 하고 기본적으로 가장 먼저 초기화된 인터페이스가 "
"됩니다. Godot는 현재 하나의 헤드셋만 지원하도록 구현되어 있습니다. 아주 드물"
"게 두 번째 인터페이스가 있는 경우가 있는데 예를 들어 3DOF만을 지원하는 장치"
"에 추가적인 트래킹을 더하는 경우가 그 예시입니다."

msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr ""
"거의 대부분의 XR 응용 프로그램에서 사용하는, XR을 위한 노드 타입이 세 가지 있"
"습니다:"

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` 는 여러분의 플레이 공간의 중심점입니다. "
"이 설명은 지나치게 단순하긴 한데 자세한 사항은 뒤쪽에서 살펴볼 것입니다. 물리"
"적인 공간에서 XR 플랫폼에 의해서 트래킹되는 모든 물체는 이 중심점에 상대적으"
"로 위치하게 됩니다."

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` 는 XR 장치의 출력을 렌더링하는 (스테레"
"오) 카메라를 의미합니다. 이 노드의 위치는 XR 시스템에 의해 제어되는데 XR 플랫"
"폼이 제공하는 트래킹 정보에 의해 자동으로 업데이트됩니다."

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` 는 플레이어가 사용하는 컨트롤러"
"를 의미하며 일반적으로 양 손에 하나씩 두 개가 있습니다. 이 노드는 그 컨트롤러"
"들의 다양한 상태 정보에 접근 가능하게 하며 플레이어가 버튼을 누르면 시그널을 "
"발생시킵니다. 이 노드의 위치는 XR 시스템에 의해 제어되며 XR 플랫폼이 제공하"
"는 트래킹 정보에 의해 자동으로 업데이트됩니다."

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"다른 XR 관련 노드들도 존재하며, 위 세 노드에 대해서도 설명할 것들이 많지만 이"
"는 나중에 다루도록 하겠습니다."

msgid "Which Renderer to use"
msgstr "사용할 렌더러"

msgid "OpenXR"
msgstr "OpenXR"

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR의 Vulkan 구현은 Vulkan 시스템의 일부를 대신하여 Vulkan과 긴밀하게 통합"
"됩니다. 이를 위해서는 Vulkan 렌더러의 특정 핵심(core) 그래픽스 기능과의 통합"
"이 필요하며, XR 시스템을 설정하기 전에 이러한 작업이 수행되어야 합니다. 이를 "
"통해 OpenXR이 핵심 인터페이스에 포함할지 여부가 결정됩니다."

msgid ""
"You can find several other settings related to OpenXR here as well. These "
"can't be changed while your application is running. The default settings "
"will get us started, but for more information on what's here "
"see :ref:`doc_openxr_settings`."
msgstr ""
"OpenXR과 관련된 여러 가지 다른 설정도 여기에서 찾을 수 있습니다. 이 값은 애플"
"리케이션이 실행 중에는 바꿀 수 없습니다. 기본 설정으로 시작하겠지만, 여기에 "
"있는 것의 자세한 정보는 :ref:`doc_openxr_settings`\\ 를 참조하세요."

msgid "Setting up the XR scene"
msgstr "XR 씬 설정"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have "
"two :ref:`XRController3D <class_xrcontroller3d>`, one for the left hand and "
"one for the right. Keep in mind that the camera and controller nodes should "
"be children of the origin node. Add these nodes to a new scene and rename "
"the controller nodes to ``LeftHand`` and ``RightHand``, your scene should "
"look something like this:"
msgstr ""
"모든 XR 애플리케이션은 최소한 :ref:`XROrigin3D <class_xrorigin3d>`\\ "
"와 :ref:`XRCamera3D <class_xrcamera3d>` 노드가 필요합니다. 또한 대부분의 경"
"우 왼손과 오른손 두 개의:ref:`XRController3D <class_xrcontroller3d>`\\ 가 필"
"요할 것입니다. 카메라와 컨트롤러 노드는 origin 노드의 자식이어야 한다는 것에 "
"유의하세요. 이것들을 새로운 씬에 추가하고 컨트롤러 노드의 이름을 ``LeftHand``"
"와 ``RightHand``로 변경하면 아래와 같이 될 것입니다:"

msgid "And the right hand:"
msgstr "오른 손은 아래와 같습니다:"

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"지금 이 노드들은 바닥에 위치해 있지만, 런타임에는 제대로 위치하게 될겁니다. "
"개발의 편의성을 위해 카메라를 위로 옮겨서 ``y`` 값을 ``1.7`` 로 설정하고 컨트"
"롤러 노드들을 왼손과 오른손 각각 ``-0.5, 1.0, -0.5``, ``0.5, 1.0, -0.5`` 로 "
"옮깁시다."

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr ""
"다음으로 루트 노드에 스트립트를 추가하고, 아래 코드를 스크립트에 추가합니다:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"이 코드 프래그먼트는 OpenXR을 사용한다고 가정합니다. 다른 인터페이스를 사용하"
"려는 경우 ``find_interface`` 호출을 변경할 수 있습니다."

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"위 코드 조각에서 볼 수 있는 것처럼 v-sync는 비활성화 하였습니다. OpenXR을 사"
"용하는 경우 렌더링 결과가 HMD로 90Hz 이상으로 전달되어야만 합니다. 여러분의 "
"모니터가 60Hz인데 v-sync가 켜져 있으면 출력이 초당 60프레임으로 제한됩니다."

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "OpenXR과 같은 XR 인터페이스는 자체적인 동기화를 수행합니다."

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set "
"``Engine.physics_ticks_per_second`` to a higher value."
msgstr ""
"또 유의해야 할 것은 물리 엔진은 기본적으로 60Hz로 동작하기 때문에 불안정한 결"
"과가 나타날 수 있습니다. ``Engine.physics_ticks_per_second`` 도 더 높은 값으"
"로 설정해야 합니다."

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add "
"a :ref:`DirectionalLight3D <class_directionallight3d>` and "
"a :ref:`WorldEnvironment <class_worldenvironment>` node to your scene. You "
"may wish to also add a mesh instance as a child to each controller node just "
"to temporarily visualise them. Make sure you configure a sky in your world "
"environment."
msgstr ""
"이제 프로젝트를 실행하면 모든 것들이 잘 동작하지만 검은 화면이 보일 것입니"
"다. 따라서 마지막으로 :ref:`DirectionalLight3D <class_directionallight3d>` "
"와 :ref:`WorldEnvironment <class_worldenvironment>` 노드를 씬에 추가하는 것으"
"로 마치도록 하겠습니다. 메시 인스턴스를 컨트롤러 노드의 자식으로 추가하여 임"
"시로 손의 위치를 보여줄 수도 있습니다. 하늘(sky)을 월드 환경에 추가하는 것을 "
"잊지 마세요."

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr ""
"이제 프로젝트를 실행하면 여러분은 어딘가에 떠 있는 상태로 주변을 둘러 볼 수 "
"있게 됩니다."

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"XR 애플리케이션에서도 기존처럼 레벨 전환을 수행할 수 있습니다. 이는 각 레벨마"
"다 씬을 설정하는 방식인데 한 번 설정하면 레벨을 하위씬으로 불러오기 간단합니"
"다. 만일 씬을 전환하면서 XR 설정을 복사하게 되는 경우 ``initialize``\\ 를 여"
"러 번 수행하지 않도록 주의하세요. XR 인터페이스에 따라 예측이 불가능한 결과"
"가 나타날 수 있습니다."

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr ""
"이 기초 튜토리얼 시리즈의 나머지에서는 하나의 씬을 사용하는 게임을 만들어 보"
"겠습니다."
