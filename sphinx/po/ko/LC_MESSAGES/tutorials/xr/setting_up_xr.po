# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "XR 설정"

msgid "Introduction to the XR system in Godot"
msgstr "Godot의 XR 시스템 소개"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot는 사용자가 서로 다른 XR 플랫폼들의 특수한 사항을 신경쓰지 않게 하기 위"
"해서 추상화된 모듈화 XR 시스템을 제공합니다. 그 핵심은 :ref:`XRServer "
"<class_xrserver>`로 XR 시스템과의 일원화된 인터페이스이며 사용자는 여기서 XR "
"시스템의 인터페이스를 찾을 수 있고, 컴포넌트와 상호작용할 수 있습니다."

msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with the :ref:"
"`XRServer <class_xrserver>` and can be queried with the ``find_interface`` "
"method on the :ref:`XRServer <class_xrserver>`. When the desired interface "
"is found it can be initialized by calling ``initialize`` on the interface."
msgstr ""
"지원하는 각각의 XR 플랫폼은 :ref:`XRInterface <class_xrinterface>`로 구현되"
"어 있습니다. 지원하는 인터페이스는 :ref:`XRServer <class_xrserver>`에 등록되"
"고 ``find_interface`` 메서드를 사용해 쿼리할 수 있습니다. 의도한 인터페이스"
"를 찾았다면 ``initialize``를 호출하여 초기화 할 수 있습니다."

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"인터페이스가 등록되었다는 것은 단순히 그 인터페이스가 사용 가능하다는 의미이"
"며, 만일 호스트 시스템에서 그 인터페이스를 지원하지 않는다면 초기화가 실패하"
"고 ``false``를 반환합니다. 이런 일이 발생하는 원인은 다양하며, 안타깝게도 플"
"랫폼별로 그 이유가 다를 수 있습니다. 사용자가 필요한 소프트웨어를 설치하지 않"
"아서 일 수도 있고, 헤드셋을 연결하지 않았기 때문일 수도 있습니다. 여러분은 개"
"발자로써, 인터페이스의 초기화가 실패할 경우 그에 따라 적절히 반응하도록 개발"
"하셔야 합니다."

msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"XR로의 출력은 특수한 요구사항을 만족해야 하는데, 특히 양 눈에 다른 이미지를 "
"보여줘야 하는 HMD 장비와 같은 경우 Godot의 :ref:`XRServer <class_xrserver>`"
"는 렌더링 시스템의 다양한 기능을 오버라이드 하게 됩니다. 독립형(stand-alone) "
"장치의 경우 이는 :ref:`XRInterface <class_xrinterface>`가 최종 출력을 책임진"
"다는 뜻이고 Godot의 사용자 출력 시스템은 비활성화됩니다. 데스크탑 XR 장치의 "
"경우 두 번째 화면처럼 동작하므로 XR 출력을 위한 별도의 :ref:`Viewport "
"<class_viewport>`가 이를 처리하도록 할 수 있습니다. 이런 경우 Godot의 메인 윈"
"도우는 다른 컨텐츠를 출력할 수도 있습니다."

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"하나의 인터페이스로만 XR 장치의 출력을 관리할 수 있다는 점에 유의하십시오. 이"
"를 주(primary) 인터페이스라 하고 기본적으로 가장 먼저 초기화된 인터페이스가 "
"됩니다. Godot는 현재 하나의 헤드셋만 지원하도록 구현되어 있습니다. 아주 드물"
"게 두 번째 인터페이스가 있는 경우가 있는데 예를 들어 3DOF만을 지원하는 장치"
"에 추가적인 트래킹을 더하는 경우가 그 예시입니다."

msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr ""
"거의 대부분의 XR 응용 프로그램에서 사용하는, XR을 위한 노드 타입이 세 가지 있"
"습니다:"

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` 는 여러분의 플레이 공간의 중심점입니다. "
"이 설명은 지나치게 단순하긴 한데 자세한 사항은 뒤쪽에서 살펴볼 것입니다. 물리"
"적인 공간에서 XR 플랫폼에 의해서 트래킹되는 모든 물체는 이 중심점에 상대적으"
"로 위치하게 됩니다."

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` 는 XR 장치의 출력을 렌더링하는 (스테레"
"오) 카메라를 의미합니다. 이 노드의 위치는 XR 시스템에 의해 제어되는데 XR 플랫"
"폼이 제공하는 트래킹 정보에 의해 자동으로 업데이트됩니다."

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` 는 플레이어가 사용하는 컨트롤러"
"를 의미하며 일반적으로 양 손에 하나씩 두 개가 있습니다. 이 노드는 그 컨트롤러"
"들의 다양한 상태 정보에 접근 가능하게 하며 플레이어가 버튼을 누르면 시그널을 "
"발생시킵니다. 이 노드의 위치는 XR 시스템에 의해 제어되며 XR 플랫폼이 제공하"
"는 트래킹 정보에 의해 자동적으로 업데이트됩니다."

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"다른 XR 관련 노드들도 존재하며, 위 세 노드에 대해서도 설명할 것들이 많지만 이"
"는 나중에 다루도록 하겠습니다."

msgid "Prerequisites for XR in Godot 4"
msgstr "Godot 4에서 XR을 사용하기 위한 준비사항"

msgid ""
"While in Godot 3 most things worked out of the box, Godot 4 needs a little "
"more setup. This is mainly due to the more advanced nature of the Vulkan "
"renderer. There are many rendering features in Vulkan the XR system uses "
"that aren't enabled by default. They are very easy to turn on, simply open "
"up your project settings and tick the XR shaders tickbox in the XR section:"
msgstr ""
"Godot 3에서는 대부분의 것들이 함께 제공되었지만, Godot 4에서는 설정 과정이 "
"좀 더 필요합니다. 이는 Vulkan 렌더러의 특성 때문입니다. XR 시스템이 사용하는 "
"많은 Vulkan의 렌더링 기능들이 있는데 이것들은 기본적으로 활성화 되어있지 않습"
"니다. 활성화 시키는 것은 어렵지 않은데 프로젝트 설정을 열고 XR 섹션에서 XR 셰"
"이더 항목을 체크해 주면 됩니다:"

msgid ""
"As Godot 4 is still in development, many post process effects have not yet "
"been updated to support stereoscopic rendering. Using these will have "
"adverse effects."
msgstr ""
"Godot 4는 아직 개발 중이므로, 많은 포스트 프로세싱 효과들은 아직 스테레오 렌"
"더링을 지원하지 않습니다. 사용하는 경우 부작용이 나타날 수 있습니다."

msgid ""
"Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the "
"future XR desktop projects should use Forward+, and projects for stand-alone "
"headsets should use Mobile. However Compatibility is the recommended "
"renderer for now due to it having the best XR performance."
msgstr ""
"Godot 4에는 Compatibility, Mobile, Forward+의 세 가지 렌더링 옵션이 있습니"
"다. 나중에는 XR 데스크탑 프로젝트의 경우 Forward+를, 독립형 헤드셋의 경우 "
"Mobile을 사용해야 할 겁니다. 하지만 지금은 Compatibility를 사용하는 것이 추천"
"되는데, 이 옵션이 가장 높은 XR 성능을 보입니다."

msgid "OpenXR"
msgstr "OpenXR"

msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR은 XR 응용 프로그램에서 표준화된 API를 사용함으로써 서로 다른 XR 플랫폼"
"에서 동작 가능하게 하는 새로운 산업 표준입니다. 이 표준은 Khronos 그룹에서 관"
"리하는 공개 표준이므로 Godot와 아주 잘 어울립니다."

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR의 Vulkan 구현은 Vulkan 시스템의 일부를 대신하여 Vulkan과 긴밀하게 통합"
"됩니다. 이를 위해서는 Vulkan 렌더러의 특정 핵심(core) 그래픽스 기능과의 통합"
"이 필요하며, XR 시스템을 설정하기 전에 이러한 작업이 수행되어야 합니다. 이를 "
"통해 OpenXR이 핵심 인터페이스에 포함할지 여부가 결정됩니다."

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. The required setting can be found in your project "
"settings:"
msgstr ""
"따라서 OpenXR은 Godot 실행 시에 활성화되어야 합니다. 프로젝트 설정에서 관련"
"된 설정을 찾으실 수 있습니다:"

msgid ""
"As setup is brought forward with OpenXR you can find several other settings "
"related to OpenXR here as well. These can't be changed while your "
"application is running. The default settings will get us started and we will "
"go into detail in another section of the documentation."
msgstr ""
"OpenXR로 설정되었으므로 여기서는 OepnXR과 관련한 다른 설정들이 함께 나타나게 "
"됩니다. 이 값들은 어플리케이션이 실행되고 있는 도중에는 바꿀 수 없습니다. 기"
"본값을 사용하면 되며, 문서의 다른 부분에서 상세하게 설명할 예정입니다."

msgid "Setting up the XR scene"
msgstr "XR 씬 설정"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have two :ref:"
"`XRController3D <class_xrcontroller3d>`, one for the left hand and one for "
"the right. Keep in mind that the camera and controller nodes should be "
"children of the origin node. Add these nodes to a new scene and rename the "
"controller nodes to ``LeftHand`` and ``RightHand``, your scene should look "
"something like this:"
msgstr ""
"모든 XR 어플리케이션은 최소한 :ref:`XROrigin3D <class_xrorigin3d>`와 :ref:"
"`XRCamera3D <class_xrcamera3d>` 노드가 필요합니다. 또한 대부분의 경우 왼손과 "
"오른손 두 개의 :ref:`XRController3D <class_xrcontroller3d>`가 필요할 것입니"
"다. 카메라와 컨트롤러 노드는 origin 노드의 자식이어야 한다는 것에 유의하십시"
"오. 이것들을 새로운 씬에 추가하고 컨트롤러 노드의 이름을 ``LeftHand``와 "
"``RightHand``로 변경하면 아래와 같이 될 것입니다:"

msgid ""
"Next you need to configure the controllers, select the left hand and set it "
"up as follows:"
msgstr ""
"다음으로 컨트롤러를 설정해야 하며, 왼손 노드를 선택하고 아래와 같이 설정합니"
"다:"

msgid "And the right hand:"
msgstr "오른 손은 아래와 같습니다:"

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"지금 이 노드들은 바닥에 위치해 있지만, 런타임에는 제대로 위치하게 될겁니다. "
"개발의 편의성을 위해 카메라를 위로 옮겨서 ``y`` 값을 ``1.7`` 로 설정하고 컨트"
"롤러 노드들을 왼손과 오른손 각각 ``-0.5, 1.0, -0.5``, ``0.5, 1.0, -0.5`` 로 "
"옮깁시다."

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr ""
"다음으로 루트 노드에 스트립트를 추가하고, 아래 코드를 스크립트에 추가합니다:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"위 코드는 OpenXR을 사용한다고 가정하고 작성되었으며 다른 인터페이스를 사용하"
"는 경우 ``find_interface`` 호출 부분을 수정해야 합니다."

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"위 코드 조각에서 볼 수 있는 것처럼 v-sync는 비활성화 하였습니다. OpenXR을 사"
"용하는 경우 렌더링 결과가 HMD로 90Hz 이상으로 전달되어야만 합니다. 여러분의 "
"모니터가 60Hz인데 v-sync가 켜져 있으면 출력이 초당 60프레임으로 제한됩니다."

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "OpenXR과 같은 XR 인터페이스는 자체적인 동기화를 수행합니다."

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set ``Engine."
"physics_ticks_per_second`` to a higher value."
msgstr ""
"또 유의해야 할 것은 물리 엔진은 기본적으로 60Hz로 동작하기 때문에 불안정한 결"
"과가 나타날 수 있습니다. ``Engine.physics_ticks_per_second`` 도 더 높은 값으"
"로 설정해야 합니다."

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add a :ref:"
"`DirectionalLight3D <class_directionallight3d>` and a :ref:`WorldEnvironment "
"<class_worldenvironment>` node to your scene. You may wish to also add a "
"mesh instance as a child to each controller node just to temporarily "
"visualise them. Make sure you configure a sky in your world environment."
msgstr ""
"이제 프로젝트를 실행하면 모든 것들이 잘 동작하지만 검은 화면이 보일 것입니"
"다. 따라서 마지막으로 :ref:`DirectionalLight3D <class_directionallight3d>` "
"와 :ref:`WorldEnvironment <class_worldenvironment>` 노드를 씬에 추가하는 것으"
"로 마치도록 하겠습니다. 메시 인스턴스를 컨트롤러 노드의 자식으로 추가하여 임"
"시로 손의 위치를 보여줄 수도 있습니다. 하늘(sky)을 월드 환경에 추가하는 것을 "
"잊지 마세요."

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr ""
"이제 프로젝트를 실행하면 여러분은 어딘가에 떠 있는 상태로 주변을 둘러 볼 수 "
"있게 됩니다."

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"XR 어플리케이션에서도 기존처럼 레벨 전환을 수행할 수 있습니다. 이는 각 레벨마"
"다 씬을 설정하는 방식인데 한 번 설정하면 레벨을 서브씬으로 로딩하기 간단합니"
"다. 만일 씬을 전환하면서 XR 설정을 복사하게 되는 경우 ``initialize`` 를 여러 "
"번 수행하지 않도록 주의하십시오. XR 인터페이스에 따라 예측이 불가능한 결과가 "
"나타날 수 있습니다."

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr ""
"이 튜토리얼 시리즈에서는 하나의 씬만 사용하는 게임으로 진행하도록 하겠습니다."

msgid "Translation status"
msgstr "번역 상태"
