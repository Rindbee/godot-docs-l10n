#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Applying object-oriented principles in Godot"
msgstr "Godot에 객체 지향 원리 적용하기"

msgid ""
"The engine offers two main ways to create reusable objects: scripts and "
"scenes. Neither of these technically define classes under the hood."
msgstr ""
"엔진에서는 재사용 가능한 코드를 작성하기 위해 스크립트와 씬 두 가지를 사용할 "
"수 있습니다. 둘 모두 클래스의 기술적인 개념을 내부적으로 정의하는 것은 아닙니"
"다."

msgid ""
"Still, many best practices using Godot involve applying object-oriented "
"programming principles to the scripts and scenes that compose your game. "
"That is why it's useful to understand how we can think of them as classes."
msgstr ""
"하지만 많은 Godot의 모범 사례들이 게임을 제작할 때 스크립트와 씬에 객체 지향 "
"프로그래밍 원리를 적용합니다. 때문에 이 둘을 클래스처럼 생각하는 것이 도움이 "
"됩니다."

msgid ""
"This guide briefly explains how scripts and scenes work in the engine's core "
"to help you understand how they work under the hood."
msgstr ""
"이 가이드에서는 여러분이 스크립트와 씬의 내부적인 동작을 이해할 수 있도록 이"
"들어 어떻게 엔진 내부에서 동작하는지 간단히 설명합니다."

msgid "How scripts work in the engine"
msgstr "스크립트가 엔진에서 동작하는 방식"

msgid ""
"The engine provides built-in classes like :ref:`Node <class_Node>`. You can "
"extend those to create derived types using a script."
msgstr ""
"엔진은 :ref:`Node <class_Node>`같은 내장 클래스를 제공합니다. 스크립트를 이용"
"하면 이를 상속해 파생 타입들을 만들 수 있도록 해줍니다."

msgid ""
"These scripts are not technically classes. Instead, they are resources that "
"tell the engine a sequence of initializations to perform on one of the "
"engine's built-in classes."
msgstr ""
"스크립트들은 기술적으로는 클래스에 해당하지 않습니다. 대신 스크립트는 엔진의 "
"내장 클래스에 어떤 초기화 절차를 진행해야 하는지 엔진에게 알려주는 리소스입니"
"다."

msgid ""
"Godot's internal classes have methods that register a class's data with "
"a :ref:`ClassDB <class_ClassDB>`. This database provides runtime access to "
"class information. ``ClassDB`` contains information about classes like:"
msgstr ""
"Godot의 내장 클래스는 :ref:`ClassDB <class_ClassDB>`에 클래스의 데이터를 등록"
"하는 메서드를 갖습니다. 이 데이터베이스는 런타임에 클래스 정보에 액세스 할 "
"수 있도록 해줍니다. ``ClassDB``는 다음과 같은 클래스들의 정보를 포함합니다:"

msgid "Properties."
msgstr "속성."

msgid "Methods."
msgstr "메서드."

msgid "Constants."
msgstr "상수."

msgid "Signals."
msgstr "시그널."

msgid ""
"This ``ClassDB`` is what objects check against when performing an operation "
"like accessing a property or calling a method. It checks the database's "
"records and the object's base types' records to see if the object supports "
"the operation."
msgstr ""
"오브젝트는 속성에 액세스하거나 메서드를 호출할 때 ``ClassDB``\\ 를 확인합니"
"다. 데이터베이스의 기록 및 오브젝트의 부모 타입의 기록을 확인해 오브젝트가 하"
"고자 하는 연산을 지원하는지 확인합니다."

msgid ""
"Attaching a :ref:`Script <class_Script>` to your object extends the methods, "
"properties, and signals available from the ``ClassDB``."
msgstr ""
":ref:`Script <class_Script>`\\ 를 오브젝트에 붙이면 ``ClassDB``\\ 에 있는 메"
"서드, 속성 및 시그널을 상속합니다."

msgid ""
"Even scripts that don't use the ``extends`` keyword implicitly inherit from "
"the engine's base :ref:`RefCounted <class_RefCounted>` class. As a result, "
"you can instantiate scripts without the ``extends`` keyword from code. Since "
"they extend ``RefCounted`` though, you cannot attach them to a :ref:`Node "
"<class_Node>`."
msgstr ""
"``extends`` 키워드를 사용하지 않는 스크립트도 묵시적으로 엔진의 기"
"본 :ref:`RefCounted <class_RefCounted>` 클래스를 상속합니다. 결과적으로 "
"``extends`` 키워드를 사용하지 않고 스크립트를 인스턴스화 할 수 있습니다. 스크"
"립트가 ``RefCounted`` 를 상속하기 때문에 :ref:`Node <class_Node>`에는 붙일 "
"수 없습니다."

msgid "Scenes"
msgstr "씬"

msgid ""
"The behavior of scenes has many similarities to classes, so it can make "
"sense to think of a scene as a class. Scenes are reusable, instantiable, and "
"inheritable groups of nodes. Creating a scene is similar to having a script "
"that creates nodes and adds them as children using ``add_child()``."
msgstr ""
"씬의 동작도 클래스와 여러 유사점을 갖고 있으므로 씬을 클래스처럼 여기는 것도 "
"타당합니다. 씬은 재사용이 가능하고, 인스턴스화 할 수 있고, 상속이 가능한 노드"
"들의 집합입니다. 씬을 생성하는 것은 스크립트가 노드를 생성한 후 이를 "
"``add_child()`` 를 사용해 자식으로 추가하는 것과 유사합니다."

msgid ""
"We often pair a scene with a scripted root node that makes use of the "
"scene's nodes. As such, the script extends the scene by adding behavior "
"through imperative code."
msgstr ""
"종종 씬과 씬의 노드들을 사용하는 (루트 노드에 연결된)스크립트를 짝지어 생각합"
"니다. 이렇게 보면 스크립트는 씬에 필요한 동작을 추가함으로써 씬을 상속하는 것"
"이기도 합니다."

msgid "The content of a scene helps to define:"
msgstr "씬의 구성물은 다음을 정의하는데 도움이 됩니다:"

msgid "What nodes are available to the script."
msgstr "어떤 노드를 스크립트에서 사용할 수 있는지"

msgid "How they are organized."
msgstr "노드들이 어떻게 조직화 되어있는지"

msgid "How they are initialized."
msgstr "노드들이 어떻게 초기화되는지"

msgid ""
"Why is any of this important to scene organization? Because instances of "
"scenes *are* objects. As a result, many object-oriented principles that "
"apply to written code also apply to scenes: single responsibility, "
"encapsulation, and others."
msgstr ""
"왜 씬의 구성에 이런 사항들이 중요할까요? 이는 씬의 인스턴스가 *곧* 오브젝트이"
"기 때문입니다. 결과적으로 단일 책임 원칙, 캡슐화 등 코드에 적용할 수 있는 객"
"체 지향 기법이 씬에도 적용될 수 있습니다."

msgid ""
"The scene is *always an extension of the script attached to its root node*, "
"so you can interpret it as part of a class."
msgstr ""
"씬은 *항상 자신의 루트 노트에 붙은 스크립트를 상속합니다*. 따라서 이를 클래스"
"의 일종으로 생각할 수 있습니다."

msgid ""
"Most of the techniques explained in this best practices series build on this "
"point."
msgstr "모범 사례에서 설명하는 여러 기법들은 이런 점에 기반하고 있습니다."
