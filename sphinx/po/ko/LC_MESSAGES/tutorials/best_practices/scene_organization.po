#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "씬 구성"

msgid "How to build relationships effectively"
msgstr "효과적인 관계(relationship) 구축 방법"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""
"Godot 사용자들은 씬을 만들 때, 종종 다음과 같은 문제점을 마주치게 됩니다:"

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"사용자들은 먼저 첫 씬을 만들고 거기에 내용물을 넣다가 왠지 씬을 좀 나눠야 할 "
"것 같은 불길한 기분을 느낄 쯤 씬의 가지를 개별의 씬으로 저장합니다. 그리고는 "
"더 이상 이전처럼 직접적인 참조를 할 수가 없다는 것을 깨닫는거죠. 노드 경로가 "
"목표를 찾을 수 없고 편집기의 시그널 연결이 무너지기 때문에 씬을 여러 곳에서 "
"재사용하는 것이 문제를 일으킵니다."

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"객체 지향 프로그래밍에서 고려해야할 가장 큰 점은 집중된 단일 목적의 클래스를 "
"코드베이스의 다른 부분과의 `느슨한 연결(loose coupling) <https://"
"en.wikipedia.org/wiki/Loose_coupling>`_ 을 유지하는 것입니다. 이것으로 오브젝"
"트의 크기를 (유지 보수성을 위해) 작게 유지하며 재사용성을 높여줍니다."

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"씬이 외부 컨텍스트와 상호작용해야 한다면, 경험있는 개발자들은 `의존성 주입 "
"<https://ko.wikipedia.org/wiki/의존성 주입>`_\\ 사용을 권장합니다. 이 기술은 "
"하이 레벨 API를 사용해 로우 레벨 API의 의존성을 제공하는 것과 관련이 있습니"
"다. 왜 이럴까요? 외부 환경에 의존하는 클래스에서는 버그나 예측하지 못한 동작"
"이 발생하기 쉽기 때문입니다."

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"시그널에 연결합니다. 매우 안전하지만 동작에 \"응답\"하기 위해 사용해야하고, "
"동작을 시작하기 위해 사용하면 안됩니다. 시그널 이름은 보통 과거 시제 동사를 "
"사용합니다, \"entered\", \"skill_activated\", 혹은 \"item_collected\"처럼 말"
"이죠."

msgid "Call a method. Used to start behavior."
msgstr "메서드를 호출합니다. 동작을 시작하기 위해 사용됩니다."

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
":ref:`Callable <class_Callable>` 속성을 초기화합니다. 메서드의 소유권이 불필"
"요하므로 메서드 호출보다 안전합니다. 동작을 시작하는 데 사용됩니다."

msgid "Initialize a Node or other Object reference."
msgstr "노드나 다른 오브젝트 참조를 초기화합니다."

msgid "Initialize a NodePath."
msgstr "노드 경로를 초기화합니다."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"이런 GUI는 프로젝트 사용자에게 노드에 대한 중요한 정보를 더 잘 전달할 수 있습"
"니다. 외부 종속성을 갖고 있나요? 그러한 종속성을 만족시켰나요? 다른 프로그래"
"머들, 특히 디자이너와 작가들에게 노드를 구성하기 위해 어떻게 해야하는지를 메"
"시지로 명확하게 설명해야 합니다."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr ""
"`SOLID (객체 지향 설계) <https://ko.wikipedia.org/wiki/"
"SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS 원칙 <https://ko.wikipedia.org/wiki/KISS_%EC%9B%90%EC%B9%99>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "노드 트리 구조 선택"

msgid "Node \"Main\" (main.gd)"
msgstr "노드 \"Main\" (main.gd)"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D \"World\" (game_world.gd)"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control \"GUI\" (gui.gd)"

msgid "tracks all of its data internally"
msgstr "모든 데이터를 내부적으로 추적하고"

msgid "should be globally accessible"
msgstr "전역으로 접근해야 하고"

msgid "should exist in isolation"
msgstr "독립적으로 존재해야 하는 것"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "지정하는 것을 조정하기 위한, 부모 노드와 같은, 신뢰할 수 있는 제 3자."

msgid "Add a \"player\" node to a \"room\"."
msgstr "\"플레이어\" 노드를 \"방\"에 추가합니다."

msgid "If memory is not a concern, you can..."
msgstr "만약 메모리가 걱정되지 않는다면, 당신은..."

msgid "Move the player somewhere else in the tree."
msgstr "플레이어를 트리 어딘가로 이동시킵니다."

msgid "Delete the room."
msgstr "방을 삭제합니다."

msgid "Instantiate and add the new room."
msgstr "새로운 방을 인스턴스화하고 추가합니다."

msgid "More consistency."
msgstr "더 일관성 있음."

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "문서화하거나 어딘가에 남겨둬야 하는 \"특수한 상황\"이 없음."

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "이러한 세부 사항이 고려되지 않았기 때문에 오류가 발생하지 않음."

msgid ""
"The **imperative** solution: Use the ``top_level`` property for "
"the :ref:`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**명령형** 해결: :ref:`CanvasItem <class_CanvasItem_method_set_as_toplevel>`"
"또는 :ref:`Node3D <class_Node3D_property_top_level>` 노드의 ``top_level`` 속"
"성을 사용합니다. 이렇게 하면 노드는 상속된 트랜스폼을 무시합니다."

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"씬 조직의 핵심은 SceneTree를 공간적 용어보다는 관계적 용어로 생각하는 것입니"
"다. 노드가 부모의 존재에 의존적인가요? 그렇지 않다면, 그들은 다른 어딘가에서 "
"스스로 잘 있을 수 있을 겁니다. 의존적이라면, 그들은 부모의 자식으로 (그리고 "
"부모의 씬의 일부로) 존재해야 할 것입니다."

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"you still have the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"이것이 노드가 구성 요소라는 뜻일까요? 전혀 아닙니다. Godot의 노드 트리는 집"
"합 관계를 형성하는 것이지 구성 관계를 형성하는 것이 아닙니다. 그러나 노드를 "
"유연하게 이동할 수 있긴 하지만, 기본적으로 노드에는 그러한 이동이 필요하지 않"
"은 것이 가장 좋습니다."
