#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Autoloads versus regular nodes"
msgstr "자동 로드 vs 일반 노드"

msgid ""
"Godot offers a feature to automatically load nodes at the root of your "
"project, allowing you to access them globally, that can fulfill the role of "
"a Singleton: :ref:`doc_singletons_autoload`. These autoloaded nodes are not "
"freed when you change the scene from code with :ref:`SceneTree."
"change_scene_to_file <class_SceneTree_method_change_scene_to_file>`."
msgstr ""
"Godot은 프로젝트의 루트에 자동으로 노드를 로드하는 기능을 지원해 전역적으로 "
"액세스가 가능하도록 합니다. 따라서 싱글턴 :ref:`doc_singletons_autoload`의 목"
"적에 부합합니다. 자동 로드된 노드들은 코드에서 :ref:`SceneTree.change_scene "
"<class_SceneTree_method_change_scene>`로 씬을 변경할 때 할당이 해제되지 않습"
"니다."

msgid ""
"In this guide, you will learn when to use the Autoload feature, and "
"techniques you can use to avoid it."
msgstr ""
"이 가이드에서는 자동 로드 기능을 사용해야 하는 때가 언제인지와 사용하지 않기 "
"위해서는 어떻게 해야 하는지를 배우게 됩니다."

msgid "The cutting audio issue"
msgstr "오디오 잘림 문제"

msgid ""
"Other engines can encourage the use of creating manager classes, singletons "
"that organize a lot of functionality into a globally accessible object. "
"Godot offers many ways to avoid global state thanks to the node tree and "
"signals."
msgstr ""
"다른 엔진에서는 전역으로 접근 가능할 오브젝트에 다양한 기능을 구현한 \"관리자"
"\" 싱글턴 클래스를 만들어 쓰는 것을 권장할 지도 모릅니다. Godot는 노드 트리"
"와 시그널 덕분에 이러한 전역 상태의 선언을 회피할 수 있는 다양한 방법을 제공"
"합니다."

msgid ""
"For example, let's say we are building a platformer and want to collect "
"coins that play a sound effect. There's a node for that: the :ref:"
"`AudioStreamPlayer <class_AudioStreamPlayer>`. But if we call the "
"``AudioStreamPlayer`` while it is already playing a sound, the new sound "
"interrupts the first."
msgstr ""
"예를 들어, 플랫포머 게임을 제작하면서 동전을 먹을 때 음향 효과가 나게 하고 싶"
"다고 해 봅시다. 이를 위한 노드가 있습니다: :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>`. 하지만 소리가 재생되고 있는 도중 "
"``AudioStreamPlayer``를 호출하면, 새로운 소리가 첫 번째 소리가 끝나기 전에 재"
"생됩니다."

msgid ""
"A solution is to code a global, autoloaded sound manager class. It generates "
"a pool of ``AudioStreamPlayer`` nodes that cycle through as each new request "
"for sound effects comes in. Say we call that class ``Sound``, you can use it "
"from anywhere in your project by calling ``Sound.play(\"coin_pickup."
"ogg\")``. This solves the problem in the short term but causes more problems:"
msgstr ""
"해결 방법은 전역 자동 로드 사운드 매니저 클래스를 만드는 것입니다. 여기에서 "
"``AudioStreamPlayer`` 노드의 풀을 만들어서 새로운 사운드 효과가 요청될때마다 "
"하나씩 순회하도록 하는 것입니다. 이 클래스를 ``Sound`` 라고 한다면 프로젝트 "
"어디에서든 ``Sound.play(\"coin_pickup.ogg\")`` 를 호출하여 사용할 수 있습니"
"다. 이렇게 하면 일시적으로 문제가 해결되지만 더 많은 문제가 발생하게 됩니다:"

msgid ""
"**Global state**: one object is now responsible for all objects' data. If "
"the ``Sound`` class has errors or doesn't have an AudioStreamPlayer "
"available, all the nodes calling it can break."
msgstr ""
"**전역 상태**: 한 오브젝트가 이제 모든 오브젝트의 데이터를 담당합니다. "
"``Sound`` 클래스에 오류가 있거나 AudioStreamPlayer를 사용할 수 없다면, 이를 "
"호출하는 노드들 모두가 제대로 동작하지 않을 것입니다."

msgid ""
"**Global access**: now that any object can call ``Sound.play(sound_path)`` "
"from anywhere, there's no longer an easy way to find the source of a bug."
msgstr ""
"**전역 접근**: 이제 모든 오브젝트가 어디서든 ``Sound.play(sound_path)`` 를 호"
"출할 수 있으므로, 버그의 출처를 찾기가 어려워집니다."

msgid ""
"**Global resource allocation**: with a pool of ``AudioStreamPlayer`` nodes "
"stored from the start, you can either have too few and face bugs, or too "
"many and use more memory than you need."
msgstr ""
"**전역 리소스 할당**: ``AudioStreamPlayer`` 노드 풀을 처음에 생성하기 때문에 "
"너무 적게 생성하면 버그가 발생하고 너무 많이 생성하면 메모리를 비효율적으로 "
"사용하게 됩니다."

msgid ""
"About global access, the problem is that any code anywhere could pass wrong "
"data to the ``Sound`` autoload in our example. As a result, the domain to "
"explore to fix the bug spans the entire project."
msgstr ""
"전역 접근의 문제점은 어딘가의 어떤 코드든지 예제의 ``Sound`` 자동 로드에 잘못"
"된 데이터를 전달할 수 있다는 점 입니다. 결과적으로 버그를 찾기 위해 프로젝트 "
"전체를 탐색해야 합니다."

msgid ""
"When you keep code inside a scene, only one or two scripts may be involved "
"in audio."
msgstr ""
"코드를 씬 내에 국한시킬 경우, 오디오와 관련된 스크립트는 한 두개 뿐일 것입니"
"다."

msgid ""
"Contrast this with each scene keeping as many ``AudioStreamPlayer`` nodes as "
"it needs within itself and all these problems go away:"
msgstr ""
"이것과 반대로 각 씬이 필요한 만큼의 ``AudioStreamPlayer`` 노드를 유지하면 이 "
"문제는 사라집니다:"

msgid ""
"Each scene manages its own state information. If there is a problem with the "
"data, it will only cause issues in that one scene."
msgstr ""
"각 씬은 자체적인 상태 정보를 관리합니다. 데이터에 문제가 생기면, 해당 데이터"
"가 있는 씬 내에서만 문제를 일으킵니다."

msgid ""
"Each scene accesses only its own nodes. Now, if there is a bug, it's easy to "
"find which node is at fault."
msgstr ""
"각 씬은 자기 자신의 노드들에만 액세스합니다. 따라서 버그가 일어난다면 어느 노"
"드가 문제인지 특정하기가 쉽습니다."

msgid "Each scene allocates exactly the amount of resources it needs."
msgstr "각 씬은 자신에게 정확히 필요한 양의 리소스만을 할당합니다."

msgid "Managing shared functionality or data"
msgstr "공유 기능 및 데이터 관리"

msgid ""
"Another reason to use an Autoload can be that you want to reuse the same "
"method or data across many scenes."
msgstr ""
"자동 로드를 써야 하는 또 다른 이유는 동일한 메소드나 데이터를 여러 씬에서 재"
"사용 하고 싶기 때문입니다."

msgid ""
"In the case of functions, you can create a new type of ``Node`` that "
"provides that feature for an individual scene using the :ref:`class_name "
"<doc_gdscript_basics_class_name>` keyword in GDScript."
msgstr ""
"함수의 경우 GDScript의 :ref:`class_name <doc_scripting_continued_class_name>`"
"키워드를 사용해 개별 씬에 기능을 지원하도록 새로운 타입의 ``Node`` 를 만들 "
"수 있습니다."

msgid "When it comes to data, you can either:"
msgstr "데이터의 경우 다음이 가능합니다:"

msgid ""
"Create a new type of :ref:`Resource <class_Resource>` to share the data."
msgstr ""
"새로운 타입의 :ref:`Resource <class_Resource>`을 만들어서 데이터를 공유하는 "
"것."

msgid ""
"Store the data in an object to which each node has access, for example using "
"the ``owner`` property to access the scene's root node."
msgstr ""
"예를 들어 ``owner`` 속성(property)으로 액세스 할 수 있는 씬의 루트 노드와 같"
"이, 각 노드가 액세스 할 수 있는 오브젝트에 데이터를 저장하는 것."

msgid "When you should use an Autoload"
msgstr "자동 로드를 사용해야 하는 경우"

msgid ""
"GDScript supports the creation of ``static`` functions using ``static "
"func``. When combined with ``class_name``, this makes it possible to create "
"libraries of helper functions without having to create an instance to call "
"them. The limitation of static functions is that they can't reference member "
"variables, non-static functions or ``self``."
msgstr ""
"GDScript는 ``static func`` 을 통해 ``static`` 함수를 만들 수 있습니다. "
"``class_name`` 과 같이 활용하면 인스턴스화 하지 않고도 헬퍼 함수들의 라이브러"
"리를 만들 수 있습니다. 정적 함수의 한계점은 멤버 변수와 비정적 함수, 또는 "
"``self`` 를 참조할 수 없다는 점입니다."

msgid ""
"Still, autoloaded nodes can simplify your code for systems with a wide "
"scope. If the autoload is managing its own information and not invading the "
"data of other objects, then it's a great way to create systems that handle "
"broad-scoped tasks. For example, a quest or a dialogue system."
msgstr ""
"그래도 여전히 자동 로드된 노드를 사용하면 넓은 범위에서 시스템을 위해 사용되"
"는 코드를 간결하게 유지할 수 있습니다. 자동 로드가 스스로의 정보를 관리하고 "
"다른 오브젝트의 데이터를 침범하지 않는 한, 넓은 범위의 작업을 관리하기에는 좋"
"은 방법입니다. 예를 들자면 퀘스트나 대화 상자 시스템의 경우가 있겠습니다."

msgid ""
"An autoload is *not* necessarily a singleton. Nothing prevents you from "
"instantiating copies of an autoloaded node. An autoload is only a tool that "
"makes a node load automatically as a child of the root of your scene tree, "
"regardless of your game's node structure or which scene you run, e.g. by "
"pressing the :kbd:`F6` key."
msgstr ""
"자동 로드드가 싱글턴일 필요는 *없습니다*. 자동 로드된 노드의 복사본을 인스턴"
"스화 하는데 아무런 제약이 없기 때문입니다. 자동 로드는 그저 씬 트리의 루트 노"
"드의 자손으로 노드를 자동으로 로드해주는 기능일 뿐입니다. 게임의 노드 구조가 "
"어떤지, 현재 어떤 씬이 실행되고 있는지(예를 들어 :kbd:`F6` 를 눌렀을 경우처"
"럼)와 관계없이 말입니다."

msgid ""
"As a result, you can get the autoloaded node, for example an autoload called "
"``Sound``, by calling ``get_node(\"/root/Sound\")``."
msgstr ""
"결과적으로 만약 자동 로드의 이름이 ``Sound`` 라면 ``get_node(\"/root/"
"Sound\")`` 를 호출해서 자동 로드된 노드를 얻을 수 있습니다."
