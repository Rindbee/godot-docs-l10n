# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-10 15:20+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When and how to avoid using nodes for everything"
msgstr "노드를 모든 곳에서 사용하지 말아야 할 때와 이를 위한 방법"

msgid ""
"Nodes are cheap to produce, but even they have their limits. A project may "
"have tens of thousands of nodes all doing things. The more complex their "
"behavior though, the larger the strain each one adds to a project's "
"performance."
msgstr ""
"노드는 만들기 쉽지만 한계가 있습니다. 한 프로젝트에서 모든 작업을 위해 수 만 "
"개의 노드를 만들 수도 있습니다. 하지만 각각의 동작이 더 복잡해진다면, 프로젝"
"트의 성능에 부하가 더 크게 더해질 수 있습니다."

msgid ""
"Godot provides more lightweight objects for creating APIs which nodes use. "
"Be sure to keep these in mind as options when designing how you wish to "
"build your project's features."
msgstr ""
"Godot는 노드가 사용하는 API를 만들기 위한 더 가벼운 오브젝트를 제공합니다. 프"
"로젝트의 기능을 만들 때 아래와 같은 대안들을 기억해 두십시오."

msgid ""
":ref:`Object <class_Object>`: The ultimate lightweight object, the original "
"Object must use manual memory management. With that said, it isn't too "
"difficult to create one's own custom data structures, even node structures, "
"that are also lighter than the :ref:`Node <class_Node>` class."
msgstr ""
":ref:`오브젝트 <class_Object>`: 가장 가벼운 오브젝트로, 오리지널 오브젝트는 "
"수동으로 메모리 관리를 하는데 사용해야 합니다. 또한 자체 데이터 구조를 만드"
"는 것이 그리 어렵지 않으며 :ref:`노드 <class_Node>` 클래스보다 가벼운 노드 구"
"조도 만들 수 있습니다."

msgid ""
"**Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level "
"of customization for a table of content with an arbitrary number of rows and "
"columns. The data that it uses to generate its visualization though is "
"actually a tree of :ref:`TreeItem <class_TreeItem>` Objects."
msgstr ""
"**예시:** :ref:`트리 <class_Tree>` 노드를 참고하세요. 이 노드는 임의 개수의 "
"행과 열이 있는 테이블을 위한 고수준 커스터마이제이션을 제공합니다. 화면에 보"
"여지는 데이터는 실제로는 :ref:`TreeItem <class_TreeItem>` 오브젝트들입니다."

#, fuzzy
msgid ""
"**Advantages:** Simplifying one's API to smaller scoped objects helps "
"improve its accessibility and improve iteration time. Rather than working "
"with the entire Node library, one creates an abbreviated set of Objects from "
"which a node can generate and manage the appropriate sub-nodes."
msgstr ""
"**이점:** API를 더 작은 유효 범위의 오브젝트로 단순화하여 접근성과 반복 시간"
"을 향상시켜 줍니다. 전체 노드 라이브러리에서 작업하는 대신, 한 노드가 적절한 "
"하위 노드를 생성하고 관리할 수 있는 단축된 오브젝트들의 집합을 만듭니다."

msgid ""
"One should be careful when handling them. One can store an Object into a "
"variable, but these references can become invalid without warning. For "
"example, if the object's creator decides to delete it out of nowhere, this "
"would trigger an error state when one next accesses it."
msgstr ""
"오브젝트들을 다룰 때는 조심해야 합니다. 오브젝트를 변수 안에 저장할 수 있지"
"만, 오브젝트의 참조는 경고 없이 올바르지 않게 될 수 있습니다. 예를 들어 오브"
"젝트의 생성자가 오브젝트를 아무 곳에도 삭제하지 않기로 결정하면, 다음에 오브"
"젝트에 접근하려 하면 오류 상태가 발동합니다."

#, fuzzy
msgid ""
":ref:`RefCounted <class_RefCounted>`: Only a little more complex than "
"Object. They track references to themselves, only deleting loaded memory "
"when no further references to themselves exist. These are useful in the "
"majority of cases where one needs data in a custom class."
msgstr ""
":ref:`참조 <class_Reference>`: 오브젝트보다 오직 조금 더 복잡함. 참조는 자신"
"을 참조하는 지를 추적해서 더 이상 참조하지 않으면 불러온 메모리를 삭제합니"
"다. 이는 데이터가 필요한 맞춤 클래스에 있어 대부분의 경우에 유용합니다."

#, fuzzy
msgid ""
"**Example:** See the :ref:`FileAccess <class_FileAccess>` object. It "
"functions just like a regular Object except that one need not delete it "
"themselves."
msgstr ""
"**예시:** :ref:`파일 <class_File>` 오브젝트를 참고하세요. 이것은 자기 자신을 "
"삭제할 필요가 없다는 것 빼면 보통 오브젝트처럼 작동합니다."

msgid "**Advantages:** same as the Object."
msgstr "**이점:** 오브젝트와 같음."

#, fuzzy
msgid ""
":ref:`Resource <class_Resource>`: Only slightly more complex than "
"RefCounted. They have the innate ability to serialize/deserialize (i.e. save "
"and load) their object properties to/from Godot resource files."
msgstr ""
":ref:`리소스 <class_Resource>`: 참조보다 오직 조금 더 복잡함. 리소스는 그들"
"의 오브젝트 속성을 Godot 리소스 파일로 직렬화, 혹은 그 반대로 비직렬화하는데 "
"타고났습니다 (예를 들어, 저장 및 불러오기)."

#, fuzzy
msgid ""
"**Example:** Scripts, PackedScene (for scene files), and other types like "
"each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these "
"can be saved and loaded, therefore they extend from Resource."
msgstr ""
"**예시:** 스크립트, PackedScene (씬 파일 용), 그리고 각 :ref:`AudioEffect "
"<class_AudioEffect>` 클래스와 같은 다른 타입들. 각각은 저장되고 불러와 질 수 "
"있습니다. 따라서 이들은 리소스에서 분화된 것들입니다."

#, fuzzy
msgid ""
"**Advantages:** Much has :ref:`already been said <doc_resources>` on :ref:"
"`Resource <class_Resource>`'s advantages over traditional data storage "
"methods. In the context of using Resources over Nodes though, their main "
"advantage is in Inspector-compatibility. While nearly as lightweight as "
"Object/RefCounted, they can still display and export properties in the "
"Inspector. This allows them to fulfill a purpose much like sub-Nodes on the "
"usability front, but also improve performance if one plans to have many such "
"Resources/Nodes in their scenes."
msgstr ""
"**이점:** 기본의 데이터 저장 방법보다 :ref:`리소스 <class_Resource>`\\ 가 갖"
"는 이점 대부분은 :ref:`이미 말했습니다 <doc_resources>`\\ . 노드를 통한 리소"
"스 사용의 관점에서, 주요 이점은 인스펙터(Inspecter) 호환성에 있습니다. 오브젝"
"트/참조처럼 가벼우면서도, 리소스는 인스펙터(Inspecter)에서 볼 수 있고, 속성"
"을 내보낼 수 있습니다. 이를 통해 사용성 측면에서 하위 노드와 같은 목적을 달성"
"할 수 있으면서도, 씬에 그러한 리소스/노드를 갖게 한다면 성능을 향상시킬 수 있"
"습니다."

msgid "Translation status"
msgstr "번역 상태"
