#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When to use scenes versus scripts"
msgstr "씬과 스크립트 중 하나를 사용해야 하는 경우"

msgid ""
"We've already covered how scenes and scripts are different. Scripts define "
"an engine class extension with imperative code, scenes with declarative code."
msgstr ""
"우리는 이미 씬과 스크립트가 어떻게 다른지 알아 보았습니다. 스크립트는 명령형 "
"코드로 엔진 클래스 확장을 정의하고, 씬은 선언형 코드로 정의합니다."

msgid ""
"Each system's capabilities are different as a result. Scenes can define how "
"an extended class initializes, but not what its behavior actually is. Scenes "
"are often used in conjunction with a script, the scene declaring a "
"composition of nodes, and the script adding behaviour with imperative code."
msgstr ""
"결과적으로 각 시스템의 능력은 다릅니다. 씬은 어떻게 확장된 클래스를 초기화하"
"는 지 정의할 수 있지만, 실제 동작은 정의할 수 없습니다. 씬은 종종 스크립트와 "
"함께 사용되며, 씬을 통해 노드의 구성이 정의되고 스크립트를 통해 선언형 코드"
"로 기술된 동작이 추가됩니다."

msgid "Anonymous types"
msgstr "익명 타입"

msgid ""
"It *is* possible to completely define a scenes' contents using a script "
"alone. This is, in essence, what the Godot Editor does, only in the C++ "
"constructor of its objects."
msgstr ""
"스크립트 하나 만으로 씬의 내용을 완전히 정의하는 것도 *가능합니다*. 이것이 본"
"질적으로 Godot 편집기가 하는 일이고, 오브젝트의 C++ 생성자에서 이루어집니다."

msgid ""
"But, choosing which one to use can be a dilemma. Creating script instances "
"is identical to creating in-engine classes whereas handling scenes requires "
"a change in API:"
msgstr ""
"하지만 어떤 것을 사용해야 하는지 결정하는 것은 딜레마가 됩니다. 스크립트 인스"
"턴스를 만드는 것은 인 게임 클래스를 만드는 것과 동일하지만 씬을 다루려면 API"
"를 변경해야 합니다:"

msgid ""
"Also, scripts will operate a little slower than scenes due to the speed "
"differences between engine and script code. The larger and more complex the "
"node, the more reason there is to build it as a scene."
msgstr ""
"또한 엔진과 스크립트 코드 간의 속도 차 때문에 스크립트가 씬에 비해 조금 더 느"
"리게 작동합니다. 노드가 크고 복잡할수록, 씬으로 작업하는 것이 더 좋습니다."

msgid "Named types"
msgstr "명명된 타입"

msgid ""
"Scripts can be registered as a new type within the editor itself. This "
"displays it as a new type in the node or resource creation dialog with an "
"optional icon. This way, the user's ability to use the script is much more "
"streamlined. Rather than having to..."
msgstr ""
"에디터 자체에서 스크립트를 새로운 타입으로 등록할 수 있습니다. 노드 생성 또"
"는 리소스 생성 대화 상자에서 새로운 타입으로 추가적인 아이콘과 함께 표시됩니"
"다. 이런 경우, 사용자가 스크립트를 사용하는 것이 훨씬 더 간소화됩니다. 아래"
"와 같이 하지 않아도 됩니다..."

msgid "Know the base type of the script they would like to use."
msgstr "사용하고 싶은 스크립트의 기본 타입을 알기."

msgid "Create an instance of that base type."
msgstr "기본 타입의 인스턴스를 생성하기."

msgid "Add the script to the node."
msgstr "노드에 스크립트를 추가하기."

msgid ""
"With a registered script, the scripted type instead becomes a creation "
"option like the other nodes and resources in the system. The creation dialog "
"even has a search bar to look up the type by name."
msgstr ""
"등록된 스크립트에 대해서 다른 시스템 내 노드와 리소스와 같이 스크립트로 만들"
"어진 타입의 생성 옵션이 나타납니다. 생성 대화 상자에는 타입을 이름으로 찾아"
"볼 수 있는 검색 상자도 있습니다."

msgid "There are two systems for registering types:"
msgstr "타입을 등록하는 데는 두 가지 시스템이 있습니다:"

msgid ":ref:`Custom Types <doc_making_plugins>`"
msgstr ":ref:`커스텀 타입 <doc_making_plugins>`"

msgid "Editor-only. Typenames are not accessible at runtime."
msgstr "에디터에서만 사용 가능. 런타임에는 타입 이름에 접근할 수 없습니다."

msgid "Does not support inherited custom types."
msgstr "상속된 커스텀 타입을 지원하지 않습니다."

msgid "An initializer tool. Creates the node with the script. Nothing more."
msgstr ""
"초기화 툴입니다. 스크립트를 사용해 노드를 만듭니다. 다른 기능은 없습니다."

msgid ""
"Editor has no type-awareness of the script or its relationship to other "
"engine types or scripts."
msgstr ""
"에디터는 스크립트에 대한 타입 인식, 다른 엔진 타입이나 스크립트와의 관계를 인"
"식할 수 없습니다."

msgid "Allows users to define an icon."
msgstr "사용자가 아이콘을 정의할 수 있습니다."

msgid ""
"Works for all scripting languages because it deals with Script resources in "
"abstract."
msgstr "스크립트 리소스를 추상화하기 때문에 모든 스크립트 언어에서 작동합니다."

msgid ""
"Set up using :ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>`."
msgstr ""
":ref:`EditorPlugin.add_custom_type "
"<class_EditorPlugin_method_add_custom_type>` 을 사용해 설정합니다."

msgid "Editor and runtime accessible."
msgstr "에디터와 런타임에서 모두 접근할 수 있습니다."

msgid "Displays inheritance relationships in full."
msgstr "상속 관계 전체를 표시합니다."

msgid ""
"Creates the node with the script, but can also change types or extend the "
"type from the editor."
msgstr ""
"스크립트가 부착되어 있는 노드를 만들지만, 에디터에서 타입을 바꾸거나 확장할 "
"수도 있습니다."

msgid ""
"Editor is aware of inheritance relationships between scripts, script "
"classes, and engine C++ classes."
msgstr ""
"에디터는 스크립트, 스크립트 클래스, 엔진 C++ 클래스 간의 상속 관계를 인식합니"
"다."

msgid ""
"Engine developers must add support for languages manually (both name "
"exposure and runtime accessibility)."
msgstr ""
"엔진 개발자는 수동으로 언어 지원을 추가해야 합니다 (이름 표시와 런타임 접근 "
"가능성 모두)."

msgid ""
"The Editor scans project folders and registers any exposed names for all "
"scripting languages. Each scripting language must implement its own support "
"for exposing this information."
msgstr ""
"에디터는 프로젝트 폴더를 탐색하여 모든 스크립팅 언어의 노출된 이름을 등록합니"
"다. 각 스크립팅 언어에 대해 이러한 정보의 노출에 대한 지원을 각각 구현해야 합"
"니다."

msgid ""
"Both methodologies add names to the creation dialog, but script classes, in "
"particular, also allow for users to access the typename without loading the "
"script resource. Creating instances and accessing constants or static "
"methods is viable from anywhere."
msgstr ""
"두 방법론 모두 생성 대화 상자에 이름을 추가할 수 있습니다. 하지만 스크립트 클"
"래스는 사용자가 스크립트 리소스를 불러오지 않고도 타입이름에 접근할 수 있습니"
"다. 인스턴스를 만들고 상수나 정적 메서드에 접근하는 것은 어디서나 가능합니다."

msgid ""
"With features like these, one may wish their type to be a script without a "
"scene due to the ease of use it grants users. Those developing plugins or "
"creating in-house tools for designers to use will find an easier time of "
"things this way."
msgstr ""
"이러한 기능을 사용하는 경우 씬 없이도 스크립트로 만든 타입을 통해 사용 편의성"
"을 제공할 수 있습니다. 플러그인을 개발하거나 디자이너를 위한 사내 툴을 만드"
"는 사람들에게 이러한 방식의 구현이 더 편리할 것입니다."

msgid ""
"On the downside, it also means having to use largely imperative programming."
msgstr "단점은 명령형 프로그래밍을 주로 사용해야 한다는 것입니다."

msgid "Performance of Script vs PackedScene"
msgstr "스크립트와 PackedScene의 성능"

msgid ""
"One last aspect to consider when choosing scenes and scripts is execution "
"speed."
msgstr "마지막으로 씬과 스크립트를 선택할 때 고려할 사항은 실행 속도입니다."

msgid ""
"As the size of objects increases, the scripts' necessary size to create and "
"initialize them grows much larger. Creating node hierarchies demonstrates "
"this. Each Node's logic could be several hundred lines of code in length."
msgstr ""
"오브젝트의 규모가 커질수록, 오브젝트를 만들고 초기화 하는 데 필요한 스크립트"
"의 크기는 더욱 더 커집니다. 노드 계층 구조를 만드는 것이 그러한 경우입니다. "
"각 노드의 로직은 수 백줄의 코드가 될 수 있습니다."

msgid ""
"The code example below creates a new ``Node``, changes its name, assigns a "
"script to it, sets its future parent as its owner so it gets saved to disk "
"along with it, and finally adds it as a child of the ``Main`` node:"
msgstr ""
"아래의 코드 예제는 새로운 ``Node`` 를 생성하고, 이름을 변경하고, 스크립트를 "
"할당하고, 부모가 될 노드를 소유자로 지정하여 디스크에 같이 저장되도록 한 뒤 "
"``Main`` 노드의 자식으로 등록하는 코드입니다:"

msgid ""
"Script code like this is much slower than engine-side C++ code. Each "
"instruction makes a call to the scripting API which leads to many "
"\"lookups\" on the back-end to find the logic to execute."
msgstr ""
"이와 같은 스크립트 코드는 엔진쪽의 C++ 코드보다 훨씬 느립니다. 매 명령은 스크"
"립트 API를 호출하기 때문에 실행할 로직을 찾기 위해 백엔드에서 많은 "
"\"lookup\"이 일어나게 됩니다."

msgid ""
"Scenes help to avoid this performance issue. :ref:`PackedScene "
"<class_PackedScene>`, the base type that scenes inherit from, defines "
"resources that use serialized data to create objects. The engine can process "
"scenes in batches on the back-end and provide much better performance than "
"scripts."
msgstr ""
"씬은 이런 문제를 피할 수 있도록 해줍니다. 씬이 상속하는 기본 타입인 :ref:"
"`PackedScene <class_PackedScene>`은 오브젝트를 생성에 필요한, 직렬화된 데이터"
"를 사용하는 리소스를 정의합니다. 엔진은 백엔드에서 씬을 배치(batch)로 처리할 "
"수 있게 되고 스크립트보다 훨씬 나은 성능을 보입니다."

msgid "Conclusion"
msgstr "결론"

msgid "In the end, the best approach is to consider the following:"
msgstr "결론적으로, 최선의 접근법은 아래 사항들을 고려하는 것입니다:"

msgid ""
"If one wishes to create a basic tool that is going to be re-used in several "
"different projects and which people of all skill levels will likely use "
"(including those who don't label themselves as \"programmers\"), then "
"chances are that it should probably be a script, likely one with a custom "
"name/icon."
msgstr ""
"여러 다른 프로젝트에서 재사용될 예정이며, (\"프로그래머\"라는 이름표가 없는 "
"사람들을 포함한) 모든 실력 수준의 사람들이 사용할 수 있는 기본 툴을 만들고 싶"
"다면, 아마 커스텀한 이름과 아이콘을 가지고 있는 스크립트로 만들어야 할 것입니"
"다."

msgid ""
"If one wishes to create a concept that is particular to their game, then it "
"should always be a scene. Scenes are easier to track/edit and provide more "
"security than scripts."
msgstr ""
"게임에 필요한 어떤 개념이라면, 거의 대부분의 경우 씬으로 만들어야 합니다. 씬"
"이 스크립트보다 더 쉽게 추적/편집이 가능하고 보안성이 높습니다."

msgid ""
"If one would like to give a name to a scene, then they can still sort of do "
"this by declaring a script class and giving it a scene as a constant. The "
"script becomes, in effect, a namespace:"
msgstr ""
"씬에 이름을 부여하고 싶다면, 스크립트 클래스를 선언하고 상수로 씬을 지정하여 "
"원하는 바를 달성할 수 있습니다. 스크립트는 사실상 네임스페이스가 됩니다:"
