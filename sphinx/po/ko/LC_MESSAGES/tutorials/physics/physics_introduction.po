#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "물리 소개"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"게임 개발 중 종종 게임의 두 물체가 교차하거나 접촉할 때를 알아야 합니다. 이"
"를 **콜리전 감지**\\ 라고 합니다. 콜리전이 감지될 때, 일반적이라면 무언가가 "
"발생하길 원할겁니다. 이를 **콜리전 응답**\\ 이라고 합니다."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot는 콜리전 감지와 반응을 모두 제공하기 위해 2D와 3D로 구성된 다수의 콜리"
"전 오브젝트를 제공합니다. 프로젝트에 이 중 어떠한 것을 사용할지 결정하려는 것"
"은 혼란스러울 수 있습니다. 하지만 각각의 작동 방식과 장단점을 이해한다면 이러"
"한 문제를 피하고 개발을 간소화할 수 있습니다."

msgid "In this guide, you will learn:"
msgstr "이 가이드에서 다음 내용을 배울 것입니다:"

msgid "Godot's four collision object types"
msgstr "Godot의 4가지 콜리전 오브젝트 유형"

msgid "How each collision object works"
msgstr "각 콜리전 오브젝트의 작동 방식"

msgid "When and why to choose one type over another"
msgstr "한 유형을 다른 유형보다 선택해야 하는 시기 및 이유"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"이 문서의 예제에서는 2D 오브젝트를 사용합니다. 모든 2D 물리 오브젝트와 콜리"
"전 모양은 3D에서 직접적으로 동등하며 대부분의 경우 거의 동일한 방식으로 작동"
"합니다."

msgid "Collision objects"
msgstr "콜리전 오브젝트"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 노드는 **감지(detection)**\\ 와 **영향력(influence)**\\ 을 제공합"
"니다. 그들은 오브젝트들이 언제 겹치는지를 감지할 수 있고, 바디가 들어가거나 "
"나올 때 시그널을 보낼 수 있습니다. ``Area2D``\\ 는 또한 정의된 영역에서 중력"
"이나 제동과 같은 물리적 특성을 치환하는데 사용될 수도 있습니다."

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"정적 바디는 물리 엔진에 의해 움직이지 않는 물체입니다. 그것은 콜리전 감지에"
"는 관여하지만, 콜리전에 대응하여 움직이지는 않습니다. 이것들은 환경의 일부이"
"거나 동적 동작이 필요하지 않은 오브젝트에 가장 많이 사용됩니다."

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting movement. :"
"ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"이것은 시뮬레이션된 2D 물리를 구현하는 노드입니다. ``RigidBody2D``\\ 를 직접"
"적으로 제어하지는 않지만, 그대신 (중력, 충격 등) 힘을 가하며 물리 엔진은 그것"
"의 결과적인 움직임을 계산합니다. :ref:`리지드 바디 사용에 대해 더 알아보기. "
"<doc_rigid_body>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"콜리전 감지 기능을 제공하지만, 물리는 제공하지 않는 body입니다. 모든 이동 및 "
"콜리전 반응은 코드로 구현되어야 합니다."

msgid "Physics material"
msgstr "물리 머티리얼"

msgid "Collision shapes"
msgstr "콜리전 모양"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"물리 바디는 원하는 수의 :ref:`Shape2D <class_Shape2D>` 오브젝트를 자손으로 수"
"용할 수 있습니다. 이러한 모양은 오브젝트의 콜리전 경계를 정의하고 다른 오브젝"
"트와의 접촉을 감지하는 데 사용됩니다."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr ""
"콜리전을 감지하기 위해, 최소한 하나 이상의 ``Shape2D``\\ 가 오브젝트에 할당되"
"어야 합니다."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"모양을 지정하는 가장 일반적인 방법은 오브젝트의 자손으로 :ref:"
"`CollisionShape2D <class_CollisionShape2D>`\\ 또는 :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>`\\ 를 추가하는 것입니다. 이러한 노드들은 편집기 작"
"업 공간에서 직접 모양을 그릴 수 있도록 합니다."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"편집기에서 콜리전 모양을 변경하지 않도록 주의하십시오. 인스펙터(Inspecter)의 "
"\"Scale\" 속성은 ``(1, 1)``\\ 로 유지되어야 합니다. 콜리전 모양을 변경할 때"
"는 항상 ``Node2D`` 크기 핸들이 **아닌** 크기 핸들을 사용해야 합니다. 도형의 "
"크기를 조절하는 것은 예기치 않은 콜리전 행동이 일어날 수 있습니다."

msgid "Physics process callback"
msgstr "물리 프로세스 콜백"

msgid "Collision layers and masks"
msgstr "콜리전 레이어와 마스크"

msgid "Let's look at each of the properties in turn:"
msgstr "각 속성을 차례대로 살펴보겠습니다:"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"이것은 오브젝트가 **나타나는** 레이어를 형성합니다. 기본적으로 모든 바디는 레"
"이어 ``1``에 있습니다."

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"이것은 바디가 콜리전을 위해 **스캔**\\ 하는 레이어를 뜻합니다. 오브젝트가 마"
"스크 레이어 중 하나에 있지 않으면, 바디는 이를 무시합니다. 기본적으로 모든 바"
"디는 레이어 ``1``\\ 을 스캔합니다."

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr ""
"이러한 속성은 코드를 통해, 혹은 인스펙터(Inspecter)에서 편집하여 구성할 수 있"
"습니다."

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"당신의 게임에는 4가지의 노드 타입이 있습니다: 벽, 플레이어, 적, 코인. 플레이"
"어와 적 모두 벽과 충돌해야 합니다. 플레이어 노드는 적과 코인의 콜리전을 모두 "
"감지해야 하지만, 적과 코인은 서로 무시해야 합니다."

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"레이어 1-4를 \"walls\", \"player\", \"enemies\", 그리고 \"coins\"으로 이름을 "
"지정하는 걸로 시작하고, \"Layer\" 속성을 사용하여 각 노드 타입을 각각의 레이"
"어에 배치합니다. 그런 다음 각 노드가 상호 작용할 레이어를 선택하여 각 노드의 "
"\"Mask\" 속성을 설정합니다. 예를 들어, 플레이어의 설정은 다음과 같습니다:"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Area 노드는 **감지**\\ 와 **영향력**\\ 을 제공합니다. 그들은 물체가 중복되는 "
"때를 감지하고 바디가 들어가거나 나올 때 시그널을 방출할 수 있습니다.  Area는 "
"정의된 영역에서 중력 또는 제동과 같은 물리적 특성을 치환하는 데 사용될 수도 "
"있습니다."

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr ":ref:`Area2D <class_Area2D>`\\ 에는 3가지 주요 용도가 있습니다:"

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "특정 지역에서 (중력과 같은) 물리적 매개변수를 재정의 합니다."

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr ""
"다른 바디가 특정 지역에 들어오거나 나가는 때를 감지하거나 현재 지역에 있는 바"
"디가 무엇인 지를 탐지합니다."

msgid "Checking other areas for overlap."
msgstr "다른 영역들이 겹치는지 확인합니다."

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "기본적으로, 영역은 마우스 및 터치스크린 입력도 받습니다."

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"정적 바디는 물리 엔진에 의해 움직이지 않는 물체입니다. 그것은 콜리전 감지에"
"는 참여하지만 콜리전에 대응하여 움직이지 않습니다. 그러나, "
"``constant_linear_velocity``\\ 와 ``constant_angular_velocity``\\ 의 특성을 "
"이용하여 **마치** 움직이는 것처럼 충돌하는 바디에 움직임이나 회전을 전달할 "
"수 있습니다."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"``StaticBody2D`` 노드는 환경에 속하거나 동적 동작을 수행할 필요가 없는 오브젝"
"트에 가장 많이 사용됩니다."

msgid "Example uses for ``StaticBody2D``:"
msgstr "``StaticBody2D`` 이용 예시:"

msgid "Platforms (including moving platforms)"
msgstr "플랫폼 (이동 플랫폼 포함)"

msgid "Conveyor belts"
msgstr "컨베이어 벨트"

msgid "Walls and other obstacles"
msgstr "벽 및 기타 장애물"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a :"
"ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces to "
"it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"이것은 시뮬레이션 된 2D 물리를 구현하는 노드입니다. 당신은 :ref:`RigidBody2D "
"<class_RigidBody2D>`\\ 를 직접 제어하지는 않습니다. 대신 힘을 가하게 되면 물"
"리 엔진은 다른 물체와의 콜리전을 포함한 결과 움직임과 바운스, 회전 등의 콜리"
"전 반응을 계산합니다."

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"리지드 바디가 쉬는 상태이고 한동안 움직이지 않으면, 잠들게 됩니다. 잠든 바디"
"는 정적 바디처럼 작용하며, 그 힘은 물리 엔진에 의해 계산되지 않습니다. 콜리"
"전 또는 코드를 통해 힘이 가해지면 바디가 깨어나게 됩니다."

msgid "Using RigidBody2D"
msgstr "RigidBody2D 사용하기"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"리지드 바디를 사용하는 것의 이점 중 하나는 코드를 쓰지 않고도 많은 행동을 "
"\"자유롭게\" 할 수 있다는 것입니다. 예를 들어, 떨어지는 블록으로 \"앵그리 버"
"드\"-스타일의 게임을 만드는 경우, RigidBody2D들을 만들고 해당 속성을 조정하기"
"만 하면 됩니다. 쌓기, 낙하 및 튕김은 물리 엔진에 의해 자동으로 계산됩니다."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "예를 들어, 다음은 \"소행성\" 스타일 우주선의 코드입니다:"

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"``linear_velocity`` 또는 ``angular_velocity``\\ 를 직접 설정하는 것이 아니라 "
"바디에 힘을 (``thrust``\\ 과 ``torque``) 적용하고 그 결과적인 움직임을 물리 "
"엔진이 계산하도록 한다는 점에 유의해야 합니다."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling the :"
"ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be aware "
"that this can have a negative effect on performance."
msgstr ""
"리지드 바디가 잠에 들 때 ``_integrate_forces()`` 함수는 호출되지 않을 것입니"
"다. 이 동작을 오버라이드 하려면 콜리전을 만들거나, 콜리전을 적용하거나, 힘을 "
"가하거나, :ref:`can_sleep <class_RigidBody2D_property_can_sleep>` 속성을 비활"
"성화하여 바디를 깨어 있게 해야 합니다. 이것이 퍼포먼스에 안 좋은 영향을 줄 "
"수 있으니 조심하세요."

msgid "Contact reporting"
msgstr "접촉 알림"

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. See :ref:"
"`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"시그널을 통한 접촉 모니터링은 :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` 속성을 통해 활성화할 수 있습니"
"다. 사용 가능한 시그널 목록은 :ref:`RigidBody2D <class_RigidBody2D>`\\ 를 참"
"조하십시오."

msgid ""
"When using ``move_and_collide()``, the function returns a :ref:"
"`KinematicCollision2D <class_KinematicCollision2D>` object, which contains "
"information about the collision and the colliding body. You can use this "
"information to determine the response."
msgstr ""
"이 함수는 ``move_and_collide()``\\ 를 사용할 때 콜리전과 충돌하는 물체에 대"
"한 정보가 포함된 :ref:`KinematicCollision2D <class_KinematicCollision2D>` 오"
"브젝트를 반환합니다. 이 정보를 사용하여 응답을 확인할 수 있습니다."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr ""
"예를 들어, 콜리전이 발생한 공간의 지점을 찾으려면 다음과 같이 하면 됩니다:"

msgid "Or to bounce off of the colliding object:"
msgstr "혹은 충돌 오브젝트가 튀어나오도록 하려면 다음과 같습니다:"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"슬라이딩은 일반적인 콜리전 반응입니다; 플레이어가 탑뷰 게임에서 벽을 따라 움"
"직이거나 플랫폼 안에서 오르내리는 경사를 상상해 보십시오. "
"``move_and_collide()``\\ 를 사용한 후 직접 이를 코딩할 수 있지만 "
"``move_and_slide()``\\ 는 많은 코드를 작성하지 않고 슬라이딩 이동을 실행할 "
"수 있는 편리한 방법입니다."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"예를 들어, 다음 코드를 사용하여 지면 (경사 포함)을 따라 걸을 수 있고 지면에 "
"있을 때 점프할 수 있는 캐릭터를 만들 수 있습니다:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"자세한 코드가 포함된 데모 프로젝트를 포함하여 ``move_and_slide()`` 사용에 대"
"한 자세한 내용은 :ref:`doc_kinematic_character_2d`\\ 를 참조하십시오."
