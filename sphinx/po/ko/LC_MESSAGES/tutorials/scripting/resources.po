#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Resources"
msgstr "리소스"

msgid "Nodes and resources"
msgstr "노드와 리소스"

msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as "
"important: :ref:`Resource <class_Resource>`."
msgstr ""
"지금까지 우리는 Godot에서 동작을 코딩하는 데 쓰이고 엔진 대부분의 기능이 의존"
"하는 :ref:`Node <class_Node>` 클래스에 초점을 두었습니다. 이와 마찬가지로 중"
"요한 데이터 타입: :ref:`Resource <class_Resource>`\\ 가 있습니다."

msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*노드(Node)*\\ 는 스프라이트, 3D 모델, 물리 시뮬레이션, 유저 인터페이스 정렬 "
"등의 기능을 제공합니다. **리소스(Resource)**\\ 는 **데이터 컨테이너**\\ 입니"
"다. 리소스 자체적으로는 아무 것도 하지 않습니다. 대신 노드는 리소스에 포함된 "
"데이터를 사용합니다."

msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"엔진이 디스크에서 리소스를 불러올 때 **항상 한 번만 불러옵니다**. 해당 리소스"
"의 복사본이 이미 메모리에 있는 경우 리소스를 다시 불러오려고 하면 매번 같은 "
"복사본을 반환합니다. 리소스에는 데이터만 포함되어 있으므로 리소스를 복제할 필"
"요가 없습니다."

msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"노드 또는 리소스와 같은 모든 개체는 속성을 내보낼 수 있습니다. String, "
"integer, Vector2 등과 같은 많은 타입의 속성 중 하나가 리소스가 될 수 있습니"
"다. 즉, 노드와 리소스 모두 리소스를 속성으로 포함할 수 있습니다:"

msgid "External vs built-in"
msgstr "외부 대 내장"

msgid "There are two ways to save resources. They can be:"
msgstr ""
"리소스를 저장하는 두 가지 방법이 있습니다. 두 가지 방법은 다음과 같습니다:"

msgid "**External** to a scene, saved on the disk as individual files."
msgstr "씬의 **외부** 에 개별 파일로 저장."

msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "``.tscn``\\ 이나 ``.scn`` 파일 안에 **내장**\\ 된 채로 저장."

msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"Path 속성은 리소스의 경로를 알려줍니다. 이 경우 리소스는 ``robi.png``\\ 라는 "
"PNG 이미지에서 가져옵니다. 이와 같이 파일에서 리소스를 불러오는 경우 외부 리"
"소스라고 합니다. Path를 지우거나 비워 두면 내장 리소스가 됩니다."

msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"내장 리소스와 외부 리소스 간의 전환은 씬을 저장할 때 발생합니다. 위의 예시에"
"서 경로 ``\"res://robi.png\"``\\ 를 지우고 저장한다면, Godot는 ``.tscn`` 씬 "
"파일 안에 이미지를 저장합니다."

msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"내장 리소스로 저장하더라도 씬을 여러 번 인스턴스화하면 엔진은 해당 복사본을 "
"하나만 불러옵니다."

msgid "Loading resources from code"
msgstr "코드에서 리소스 불러오기"

msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr ""
"코드에서 리소스를 불러오는 방법은 두 가지가 있습니다. 첫 번째로, 언제든지 "
"``load()`` 함수를 사용해 불러올 수 있습니다:"

msgid "Loading scenes"
msgstr "씬 불러오기"

msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"이 메서드는 씬의 계층 구조에 노드를 만들고, 구성하고, 씬의 루트 노드를 반환합"
"니다. 그런 다음 이것을 다른 노드의 자식으로 추가할 수 있습니다."

msgid "Freeing resources"
msgstr "리소스 해제(Free)하기"

msgid "Creating your own resources"
msgstr "여러분만의 리소스 만들기"

msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr ""
"상수를 정의할 수 있으므로 다른 데이터 필드나 오브젝트의 상수가 필요하지 않습"
"니다."

msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"속성에 대한 setter/getter 메서드를 포함한 메서드를 정의할 수 있습니다. 이를 "
"통해 기본 데이터를 추상화하고 캡슐화할 수 있습니다. 리소스 스크립트의 구조를 "
"변경해야 하는 경우 리소스를 사용하는 게임을 변경할 필요가 없습니다."

msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr ""
"시그널을 정의할 수 있으므로 리소스가 관리하는 데이터의 변경사항에 대한 응답"
"을 트리거할 수 있습니다."

msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr ""
"정의된 속성이 있으므로 유저는 자신의 데이터가 존재한다는 것을 100% 알 수 있습"
"니다."

msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"리소스 자동 직렬화 및 역직렬화는 Godot 엔진에 내장된 기능입니다. 사용자는 리"
"소스 파일의 데이터를 가져오거나 내보내기 위해 사용자 지정 로직을 구현할 필요"
"가 없습니다."

msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr ""
"리소스는 하위 리소스를 재귀적으로 직렬화할 수도 있습니다. 이는 유저가 훨씬 "
"더 정교한 데이터 구조를 설계할 수 있음을 의미합니다."

msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files "
"(\\*.res) for increased speed and compression."
msgstr ""
"유저는 리소스를 버전 관리에 적합한 텍스트 파일(\\*.tres)로 저장할 수 있습니"
"다. 게임을 내보낼 때 Godot는 리소스 파일을 바이너리 파일(\\*.res)로 직렬화해"
"서 속도와 압축률을 높입니다."

msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot 엔진의 인스펙터는 리소스 파일을 바로 렌더링하고 편집합니다. 따라서 사용"
"자는 데이터를 시각화하거나 편집하기 위해 사용자 지정 로직을 구현할 필요가 없"
"는 경우가 많습니다. 이렇게 하려면 파일시스템 독에서 리소스 파일을 더블 클릭하"
"거나 인스펙터에서 폴더 아이콘을 클릭하고 대화 상자에서 파일을 여세요."

msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "기본 리소스 외에 **다른** 리소스 타입을 확장할 수 있습니다."

msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr ""
"Godot의 인스펙터(Inspecter)에서는 커스텀 리소스를 쉽게 만들 수 있습니다."

msgid "Set the ``script`` property in the Inspector to be your script."
msgstr ""
"인스펙터(Inspecter)에서 ``script`` 속성을 여러분의 스크립트로 설정합니다."

msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with "
"an :ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations "
"and editors for their data."
msgstr ""
"리소스 스크립트는 Unity의 ScriptableObjects와 유사합니다. 인스펙터는 사용자 "
"지정 리소스를 위한 내장 지원을 제공합니다. 원한다면 사용자만의 Control 기반 "
"도구 스크립트를 디자인하고 이를 :ref:`EditorPlugin <class_EditorPlugin>`\\ "
"과 결합해서 데이터에 대한 사용자 지정 시각화 및 편집기를 만들 수도 있습니다."

msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTable은 float 배열 또는 :ref:`Curve <class_Curve>`/:ref:`Curve2D "
"<class_Curve2D>` 리소스 개체에 매핑된다는 점을 제외하고는 동일합니다."

msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"아래 예시에서, Godot는 ``Node`` 스크립트를 불러오고, ``Resource``\\ 를 확장"
"(extend)하지 않는지 확인한 다음, 이 경우 타입이 호환되지 않으므로 스크립트가 "
"Resource 오브젝트를 불러오는 데 실패했다고 판단합니다."
