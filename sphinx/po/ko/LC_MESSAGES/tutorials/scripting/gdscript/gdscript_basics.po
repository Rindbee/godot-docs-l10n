#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "History"
msgstr "이력"

msgid ""
"Documentation about GDScript's history has been moved to "
"the :ref:`Frequently Asked Questions <doc_faq_what_is_gdscript>`."
msgstr ""
"GDScript의 역사에 대한 문서는 :ref:`자주 묻는 질문 "
"<doc_faq_what_is_gdscript>`\\ 으로 이동되었습니다."

msgid "Example of GDScript"
msgstr "GDScript 예제"

msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"이전에 C, C++, C#과 같은 정적 타입 언어에 대한 경험이 있지만 한 번도 동적 타"
"입 언어를 써 본 적이 없다면, 이 튜토리얼을 읽는 것이 좋습니"
"다: :ref:`doc_gdscript_more_efficiently`."

msgid "Identifiers"
msgstr "식별자(Identifier)"

msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"알파벳 문자로 제한되는 문자열 (``a``\\ 부터 ``z``, ``A``\\ 부터 ``Z``), 숫자 "
"(``0``\\ 부터 ``9``), ``_``\\ 는 식별자입니다. 추가로 식별자는 숫자로 시작할 "
"수 없습니다. 식별자는 대소문자를 구분합니다 (``foo``\\ 는 ``FOO``\\ 와 다릅니"
"다)."

msgid "Keywords"
msgstr "키워드(Keyword)"

msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"다음은 언어에서 지원하는 키워드 목록입니다. 키워드는 예약된 단어(토큰)이기 때"
"문에, 식별자로 사용할 수 없습니다. 다음 섹션에 나열된 (``in``, ``not``, "
"``and`` 혹은 ``or`` 와 같은) 연산자와 내장 타입 이름 역시 예약된 단어입니다."

msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"키워드는 `GDScript tokenizer <https://github.com/godotengine/godot/blob/"
"master/modules/gdscript/gdscript_tokenizer.cpp>`_\\ 에 정의되어 있습니다. 정"
"체가 궁금하다면 확인해보세요."

msgid "Keyword"
msgstr "키워드"

msgid "Description"
msgstr "설명"

msgid "if"
msgstr "if"

msgid "See `if/else/elif`_."
msgstr "`if/else/elif`_\\ 를 참고하세요."

msgid "elif"
msgstr "elif"

msgid "else"
msgstr "else"

msgid "for"
msgstr "for"

msgid "See for_."
msgstr "for_\\ 를 참고하세요."

msgid "while"
msgstr "while"

msgid "See while_."
msgstr "while_\\ 을 참고하세요."

msgid "match"
msgstr "match"

msgid "See match_."
msgstr "match_\\ 를 참고하세요."

msgid "break"
msgstr "break"

msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "현재의 ``for`` 또는 ``while`` 루프 실행을 끝냅니다."

msgid "continue"
msgstr "continue"

msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "즉시 ``for`` 또는 ``while`` 루프의 다음 반복으로 건너뜁니다."

msgid "pass"
msgstr "pass"

msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr ""
"명령문이 문법적으로는 필요하지만 실행할 만한 코드가 마땅치 않을 때 사용됩니"
"다. 예: 빈 함수."

msgid "return"
msgstr "return"

msgid "Returns a value from a function."
msgstr "함수에서 값을 반환합니다."

msgid "class"
msgstr "클래스"

msgid "class_name"
msgstr "class_name"

msgid "extends"
msgstr "extends"

msgid "Defines what class to extend with the current class."
msgstr "현재 클래스로 확장할 클래스를 정의합니다."

msgid "is"
msgstr "is"

msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr ""
"변수가 주어진 클래스를 확장하는지, 혹은 변수가 주어진 내장 유형인지 여부를 테"
"스트합니다."

msgid "as"
msgstr "as"

msgid "Cast the value to a given type if possible."
msgstr "가능하다면 주어진 타입으로 값을 캐스트합니다."

msgid "self"
msgstr "self"

msgid "signal"
msgstr "signal"

msgid "func"
msgstr "func"

msgid "static"
msgstr "static"

msgid "const"
msgstr "const"

msgid "enum"
msgstr "enum"

msgid "Defines an enum. See `Enums`_."
msgstr "열거형을 정의합니다. `Enums`_\\ 를 참조하세요."

msgid "var"
msgstr "var"

msgid "breakpoint"
msgstr "breakpoint"

msgid "preload"
msgstr "preload"

msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr ""
"클래스나 변수를 미리 불러옵니다. `리소스로 취급되는 클래스`_\\ 를 참고하세요."

msgid "await"
msgstr "await"

msgid "yield"
msgstr "yield"

msgid "assert"
msgstr "assert"

msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"조건을 가정(Assert)하고 실패 시 오류를 기록합니다. 디버그가 아닌 빌드에서는 "
"무시됩니다. `Assert 키워드`_\\ 를 참고하세요."

msgid "PI"
msgstr "PI"

msgid "PI constant."
msgstr "PI 상수."

msgid "TAU"
msgstr "TAU"

msgid "TAU constant."
msgstr "TAU 상수."

msgid "INF"
msgstr "INF"

msgid "NAN"
msgstr "NAN"

msgid "Operators"
msgstr "연산자"

msgid "**Operator**"
msgstr "**연산자**"

msgid "**Description**"
msgstr "**설명**"

msgid "Grouping (highest priority)"
msgstr "묶기 (가장 높은 우선순위)"

msgid "``x[index]``"
msgstr "``x[index]``"

msgid "``x.attribute``"
msgstr "``x.attribute``"

msgid "Attribute reference"
msgstr "속성 참조"

msgid "``foo()``"
msgstr "``foo()``"

msgid "Function call"
msgstr "함수 호출"

msgid "Bitwise NOT"
msgstr "비트 단위 NOT"

msgid "``-x``"
msgstr "``-x``"

msgid "Multiplication / Division / Remainder"
msgstr "곱하기 / 나누기 / 나머지"

msgid "Bit shifting"
msgstr "비트 시프트"

msgid "Bitwise AND"
msgstr "비트 단위 AND"

msgid "Bitwise XOR"
msgstr "비트 단위 XOR"

msgid "Bitwise OR"
msgstr "비트 단위 OR"

msgid "Ternary if/else"
msgstr "삼항 if/else"

msgid "`Type casting <casting_>`_"
msgstr "`유형 캐스트하기 <casting_>`_"

msgid "Assignment (lowest priority)"
msgstr "지정 (가장 낮은 우선순위)"

msgid "Literals"
msgstr "리터럴(Literal)"

msgid "``45``"
msgstr "``45``"

msgid "Base 10 integer"
msgstr "기본 10진법 정수"

msgid "``0x8f51``"
msgstr "``0x8f51``"

msgid "Base 16 (hexadecimal) integer"
msgstr "기본 16진법 정수"

msgid "``0b101010``"
msgstr "``0b101010``"

msgid "Base 2 (binary) integer"
msgstr "기본 2진법 정수"

msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14``, ``58.1e-10``"

msgid "Floating-point number (real)"
msgstr "부동 소수점 숫자 (실수)"

msgid "Raw strings"
msgstr "원시 문자열"

msgid "Triple-quoted raw strings"
msgstr "세 번 따옴표로 묶인 원시 문자열"

msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

msgid "**Example**"
msgstr "**예제**"

msgid "``$NodePath``"
msgstr "``$NodePath``"

msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "``get_node(\"NodePath\")``\\ 의 짧은 표현"

msgid "**Escape sequence**"
msgstr "**이스케이프 시퀀스**"

msgid "**Expands to**"
msgstr "**설명**"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Newline (line feed)"
msgstr "줄 바꿈 (라인 피드)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "Horizontal tab character"
msgstr "수평 탭 문자"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage return"
msgstr "캐리지 리턴"

msgid "``\\a``"
msgstr "``\\a``"

msgid "Alert (beep/bell)"
msgstr "경보 (비프/벨)"

msgid "``\\b``"
msgstr "``\\b``"

msgid "Backspace"
msgstr "백스페이스"

msgid "``\\f``"
msgstr "``\\f``"

msgid "Formfeed page break"
msgstr "폼 피드 페이지 나누기"

msgid "``\\v``"
msgstr "``\\v``"

msgid "Vertical tab character"
msgstr "수직 탭 문자"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote"
msgstr "큰 따옴표"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote"
msgstr "작은 따옴표"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash"
msgstr "백슬래시"

msgid "``\\uXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-16 Unicode codepoint ``XXXX`` (hexadecimal, case-insensitive)"
msgstr "UTF-16 유니코드 코드포인트 ``XXXX`` (16진수, 대소문자 구분 없음)"

msgid "``\\UXXXXXX``"
msgstr "``\\UXXXXXX``"

msgid "UTF-32 Unicode codepoint ``XXXXXX`` (hexadecimal, case-insensitive)"
msgstr "UTF-32 유니코드 코드포인트 ``XXXXXX`` (16진수, 대소문자 구분 없음)"

msgid ""
"There are two ways to represent an escaped Unicode character above "
"``0xFFFF``:"
msgstr ""
"``0xFFFF`` 위의 이스케이프된 유니코드 문자를 나타내는 방법은 두 가지가 있습니"
"다:"

msgid ""
"as a `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."
msgstr ""
"`UTF-16 서로게이트 쌍 <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_\\ 으로 ``\\uXXXX\\uXXXX``."

msgid "as a single UTF-32 codepoint ``\\UXXXXXX``."
msgstr "단일 UTF-32 코드포인트로 ``\\UXXXXXX``."

msgid "GDScript also supports :ref:`format strings <doc_gdscript_printf>`."
msgstr "GDScript는 :ref:`형식 문자열 <doc_gdscript_printf>`\\ 도 지원합니다."

msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to ``Node._ready()`` is made."
msgstr ""
"노드를 사용할 때, 씬의 일부를 변수로 참조하는 것이 일반적입니다. 씬은 활성 "
"씬 트리에 들어갈 때만 구성되기 때문에 하위 노드는 ``Node._ready()`` 호출이 있"
"을 때만 가져올 수 있습니다."

msgid "Comments"
msgstr "주석"

msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr "``#``\\ 부터 줄 끝까지는 주석으로 간주되어 무시됩니다."

msgid "Line continuation"
msgstr "선 계속"

msgid "Built-in types"
msgstr "내장 타입"

msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The exceptions are ``Object``, ``Array``, ``Dictionary``, and "
"packed arrays (such as ``PackedByteArray``), which are passed by reference "
"so they are shared. All arrays, ``Dictionary``, and some objects (``Node``, "
"``Resource``) have a ``duplicate()`` method that allows you to make a copy."
msgstr ""
"내장 타입은 스택에 할당됩니다. 그들은 값으로 전달됩니다. 즉, 복사본은 각 할당"
"에서 또는 타입이 인수로 함수에 전달할 때 만들어진다는 뜻입니다. 예외는 참조"
"로 전달되어 공유되는 ``Object``, ``Array``, ``Dictionary``, 그리고 "
"(``PackedByteArray``\\ 와 같은) 압축 배열입니다. 모든 배열, ``Dictionary``, "
"그리고 일부 오브젝트(``Node``, ``Resource``)에는 복사본을 만들 수 있는 "
"``duplicate()`` 메서드가 있습니다."

msgid "Basic built-in types"
msgstr "기본 내장 타입"

msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "GDScript의 변수에는 여러 내장 타입을 할당할 수 있습니다."

msgid "null"
msgstr "null"

msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr ""
"``null``\\ 은 정보를 가지지 않는 빈 데이터 타입으로 어떤 값도 할당할 수 없습"
"니다."

msgid ":ref:`bool <class_bool>`"
msgstr ":ref:`bool <class_bool>`"

msgid "Short for \"boolean\", it can only contain ``true`` or ``false``."
msgstr ""
"\"불리언\"의 약자로, 오직 ``true`` 또는 ``false``\\ 만 포함할 수 있습니다."

msgid ":ref:`int <class_int>`"
msgstr ":ref:`int <class_int>`"

msgid ""
"Short for \"integer\", it stores whole numbers (positive and negative). It "
"is stored as a 64-bit value, equivalent to ``int64_t`` in C++."
msgstr ""
"\"정수\"의 약자로, 전체 숫자(양수와 음수)를 저장합니다. 64비트 값으로 저장되"
"며, C++에서 ``int64_t``\\ 와 같습니다."

msgid ":ref:`float <class_float>`"
msgstr ":ref:`float <class_float>`"

msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

msgid "Vector built-in types"
msgstr "벡터 내장 타입"

msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as an "
"array."
msgstr ""
"2D 벡터 타입으로 ``x``, ``y`` 필드를 가집니다. 배열로 접근할 수도 있습니다."

msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Also contains an ``end`` field which is ``position + size``."
msgstr ""
"2D 사각형 타입으로 두 개의 벡터 필드 ``position``, ``size``\\ 를 가집니다. 또"
"한 ``position + size``\\ 값인 ``end`` 필드를 가집니다."

msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr ""
"3D 벡터 타입으로 ``x``, ``y``, ``z`` 필드를 가집니다. 배열로 접근할 수도 있습"
"니다."

msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

msgid "3×2 matrix used for 2D transforms."
msgstr "3x2 행렬(Matrix)로 2D 변형에 사용됩니다."

msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr ""
"표준화된 형태의 3D 평면(Plane) 타입으로 ``normal`` 벡터와 ``d`` 스칼라 거리 "
"필드를 가집니다."

msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr ""
"사원수(Quaternion)는 3D 회전을 표현하기 위해 사용되는 데이터 타입입니다. 회"
"전 값을 보간하는 용도로 사용됩니다."

msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Also contains an ``end`` field which is "
"``position + size``."
msgstr ""
"축이 정렬된 경계 사각형(또는 3D 상자)로 두 개의 벡터 필드 ``position``, "
"``size``\\ 를 가집니다. 또한 ``position + size``\\ 값인 ``end`` 필드를 가집니"
"다."

msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"3x3 행렬로 3D 회전과 크기 조정에 사용됩니다. 3개의 벡터 필드(``x``, ``y``, "
"``z``)를 가집니다. 3D 벡터의 배열로 접근할 수도 있습니다."

msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr ""
"3D 변형으로 기본 필드 ``basis``\\ 와 Vector3 필드 ``origin``\\ 을 포함합니다."

msgid "Engine built-in types"
msgstr "엔진 내장 타입"

msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"색상 데이터 유형으로 ``r``, ``g``, ``b``, ``a`` 필드를 가집니다. 색조/채도/명"
"도 값을 ``h``, ``s``, ``v``\\ 로 접근할 수도 있습니다."

msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr ""
"리소스 ID (RID). 서버는 불투명한 데이터를 참조하기 위해 통용 RID를 사용합니"
"다."

msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

msgid "Base class for anything that is not a built-in type."
msgstr "내장 타입이 아닌 모든 것의 기본 클래스."

msgid "Container built-in types"
msgstr "컨테이너 내장 타입"

msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Negative indices count from the end."
msgstr ""
"다른 배열이나 딕셔너리를 포함한 임의 오브젝트 타입의 통용 시퀀스입니다 (아래 "
"참조). 배열은 동적으로 크기를 조절할 수 있습니다. 배열은 인덱스 ``0``\\ 부터 "
"시작하여 매깁니다. 음수 인덱스는 배열의 끝부터 셉니다."

msgid "Typed arrays"
msgstr "타입 있는 배열"

msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

msgid "Associative container which contains values referenced by unique keys."
msgstr "고유 키로 참조되는 값들을 가지는 연관 컨테이너입니다."

msgid ""
"The bracket syntax can be used to access properties of "
"any :ref:`class_Object`, not just Dictionaries. Keep in mind it will cause a "
"script error when attempting to index a non-existing property. To avoid "
"this, use the :ref:`Object.get() <class_Object_method_get>` "
"and :ref:`Object.set() <class_Object_method_set>` methods instead."
msgstr ""
"대괄호 구문은 딕셔너리 뿐만 아니라 모든 :ref:`class_Object`\\ 의 속성에 접근"
"하는 데 사용할 수 있습니다. 존재하지 않는 속성을 인덱싱하려고 할 때 스크립트 "
"오류가 발생한다는 점에 유의하세요. 이를 방지하려면 :ref:`Object.get() "
"<class_Object_method_get>` 및 :ref:`Object.set() <class_Object_method_set>` "
"메서드를 대신 사용하세요."

msgid "Variables"
msgstr "변수"

msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"변수는 클래스 멤버로 존재할 수도 있고 함수에 지역적으로 존재할 수도 있습니"
"다. 이들은 ``var`` 키워드로 생성되며 초기화할 때 값을 할당받을 수도 있습니다."

msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"변수는 타입을 지정할 수도 있습니다. 타입을 지정하면 항상 같은 타입을 가지도"
"록 강제되며, 호환되지 않는 값을 할당하려고 하면 오류가 발생합니다."

msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr ""
"타입은 변수 선언 시 변수 이름 뒤에 ``:``\\ (콜론) 기호를 사용해 지정하고 그 "
"뒤에 타입을 지정합니다."

msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr ""
"타입 유추는 할당된 값에 정의된 타입이 있는 경우에만 가능하며, 그렇지 않으면 "
"오류가 발생합니다."

msgid "Valid types are:"
msgstr "올바른 타입은 다음과 같습니다:"

msgid "Built-in types (Array, Vector2, int, String, etc.)."
msgstr "내장 유형 (Array, Vector2, int, String 등)."

msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"스크립트 리소스가 포함된 상수 이름(``const MyScript = preload(\"res://"
"my_script.gd\")``\\ 를 선언한 경우에 ``MyScript``\\ 가 여기에 속합니다)."

msgid ""
"Other classes in the same script, respecting scope "
"(``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the "
"``class InnerClass`` in the same scope)."
msgstr ""
"같은 스크립트의 스코프 안에 있는 다른 클래스들(같은 스코프에서 ``class "
"InnerClass`` 안에 ``class NestedClass``\\ 를 선언한 경우 "
"``InnerClass.NestedClass``\\ 가 여기에 속합니다)."

msgid "Script classes declared with the ``class_name`` keyword."
msgstr "``class_name`` 키워드로 선언된 스크립트 클래스."

msgid "Casting"
msgstr "캐스트하기"

msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"타입이 지정된 변수에는 호환 가능한 타입의 값을 할당해야 합니다. 값을 특정 타"
"입으로 강제 변환해야 하는 경우, 특히 객체 타입의 경우 캐스팅 연산자 ``as``\\ "
"를 사용할 수 있습니다."

msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"오브젝트 유형 간 캐스팅은 값이 캐스팅할 유형과 같거나 캐스팅할 유형의 하위 유"
"형인 경우 캐스팅하면 동일한 오브젝트가 생성됩니다."

msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr "값이 하위 유형이 아닌 경우 캐스팅 연산 결과는 ``null`` 값입니다."

msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr ""
"내장 타입의 경우 가능하다면 강제로 타입을 변환하지만, 불가능하다면 오류를 발"
"생합니다."

msgid "Constants"
msgstr "상수"

msgid ""
"Constants are values you cannot change when the game is running. Their value "
"must be known at compile-time. Using the ``const`` keyword allows you to "
"give a constant value a name. Trying to assign a value to a constant after "
"it's declared will give you an error."
msgstr ""
"상수는 게임이 실행 중일 때 변경할 수 없는 값입니다. 상수 값은 컴파일 시간에 "
"정해져야 합니다. ``const`` 키워드를 사용하면 상수 값에 이름을 지정할 수 있습"
"니다. 선언된 상수에 값을 할당하려고 하면 오류가 발생합니다."

msgid "We recommend using constants whenever a value is not meant to change."
msgstr "값이 변경되지 않는다면 상수를 사용하는 것이 좋습니다."

msgid "Assigning a value of an incompatible type will raise an error."
msgstr "호환되지 않는 타입의 값을 할당하면 오류가 발생합니다."

msgid "Enums"
msgstr "열거형"

msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr ""
"열거형은 기본적으로 상수의 축약형으로, 연속적인 정수를 일부 상수에 할당할 때 "
"꽤 유용합니다."

msgid "Functions"
msgstr "함수"

msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members "
"(see `self`_), but is not always required (and should *not* be sent as the "
"function's first argument, unlike Python)."
msgstr ""
"함수는 항상 `class <Classes_>`_\\ 에 속합니다. 변수 조회의 범위 우선순위는: "
"로컬 → 클래스 멤버 → 전역입니다. ``self`` 변수는 항상 사용할 수 있고 클래스 "
"멤버(`self`_ 참조)에 접근하기 위한 옵션으로 제공되지만 항상 필수적이지는 않습"
"니다(Python과 달리 함수의 첫 번째 인수로 보내서는 *안* 됩니다)."

msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr ""
"함수는 언제든지 ``반환(return)``\\ 할 수 있습니다. 기본 반환 값은 ``null``\\ "
"입니다."

msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"반환 타입이 있는 함수는 **반드시** 그에 맞는 값을 반환해야 합니다. 타입을 "
"``void``\\ 로 설정하면 함수는 아무 것도 반환하면 안 됩니다. Void 함수는 "
"``return`` 키워드로 함수에서 일찍 반환할 수 있지만, 값을 반환하면 안 됩니다."

msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"void가 아닌 함수는 **항상** 값을 반환해야 하므로 코드에 분기 문이 있는 경우"
"(예: ``if``/``else`` 구조) 가능한 모든 경로에서 반환해야 합니다. 예를 들어, "
"``if`` 블록 안에 ``return``\\ 이 있지만 그 이후에는 없는 경우 블록이 실행되"
"지 않으면 함수가 반환할 올바른 값을 가지지 않기 때문에 편집기에서 오류가 발생"
"합니다."

msgid "Referencing functions"
msgstr "함수 참조하기(Referencing functions)"

msgid "Static functions"
msgstr "정적 함수"

msgid "Statements and control flow"
msgstr "명령문(Statement)과 제어 흐름(Control Flow)"

msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"명령문은 표준으로 할당(Assignment), 함수 호출(Function Call), 제어 흐름 "
"(Control Flow) 구조 등이 될 수 있습니다. 명령문 구분 기호인 ``;``\\ 의 사용"
"은 자유입니다."

msgid "if/else/elif"
msgstr "if/else/elif"

msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"간단한 조건은 ``if``/``else``/``elif`` 구문을 사용해 만들 수 있습니다. 조건"
"문 주변에 괄호를 씌워도 되지만 필수는 아닙니다. 탭 기반 들여쓰기의 특성을 감"
"안하면 ``else``/``if`` 대신 ``elif``\\ 를 사용해서 들여쓰기 수준을 유지할 수 "
"있습니다."

msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *key* is stored in the "
"loop variable."
msgstr ""
"배열이나 테이블과 같은 범위의 반복에는 *for* 루프가 사용됩니다. 배열을 반복"
"할 때 현재 배열 요소는 루프 변수에 저장됩니다. 딕셔너리를 반복할 때 *key*\\ "
"는 루프 변수에 저장됩니다."

msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"``match`` 명령문은 프로그램의 실행을 분기하는 데 사용됩니다. 다른 많은 언어에"
"서 볼 수 있는 ``switch`` 명령문과 유사하지만 몇 가지 추가 기능을 제공합니다."

msgid "Replace ``switch`` with ``match``."
msgstr "``switch``\\ 를 ``match``\\ 로 바꾸세요."

msgid "Remove ``case``."
msgstr "``case``\\ 를 제거하세요."

msgid "Change ``default`` to a single underscore."
msgstr "``default``\\ 를 하나의 밑줄로 변경하세요."

msgid "Control flow"
msgstr "제어 흐름"

msgid "Literal pattern"
msgstr "리터럴 패턴"

msgid "Expression pattern"
msgstr "표현식 패턴"

msgid "Wildcard pattern"
msgstr "와일드카드 패턴"

msgid "This pattern matches everything. It's written as a single underscore."
msgstr "이 패턴은 모든 것에 매치됩니다. 하나의 밑줄로 쓸 수 있습니다."

msgid "Binding pattern"
msgstr "바인딩 패턴"

msgid "Array pattern"
msgstr "배열 패턴"

msgid ""
"Matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr ""
"배열을 비교합니다. 배열 패턴의 각 단일 요소도 패턴이므로, 패턴을 중첩할 수 있"
"습니다."

msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr ""
"배열의 길이가 패턴과 같은지 테스트하고, 같지 않다면 패턴이 일치하지 않습니다."

msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``."
msgstr ""
"**개방형 배열**: 배열의 마지막 서브패턴을 ``..``\\ 으로 만들어서 패턴보다 배"
"열이 더 커질 수 있습니다."

msgid "Every subpattern has to be comma-separated."
msgstr "각 서브패턴은 쉼표로 구분해야 합니다."

msgid "Dictionary pattern"
msgstr "딕셔너리 패턴"

msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr ""
"배열 패턴과 같은 방식으로 작동합니다. 모든 키는 일정한 패턴이어야 합니다."

msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr ""
"딕셔너리의 길이가 패턴과 같은지 테스트하고, 같지 않다면 패턴이 일치하지 않습"
"니다."

msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``."
msgstr ""
"**개방형 딕셔너리**: 딕셔너리의 마지막 서브패턴을 ``..``\\ 으로 만들어서 패턴"
"보다 딕셔너리가 더 커질 수 있습니다."

msgid "Every subpattern has to be comma separated."
msgstr "모든 서브패턴은 쉼표로 구분되어야 합니다."

msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "값을 지정하지 않으면, 키의 존재 여부만 확인됩니다."

msgid "A value pattern is separated from the key pattern with a ``:``."
msgstr "값 패턴과 키 패턴은 ``:``\\ 로 분리됩니다."

msgid "Multiple patterns"
msgstr "다중 패턴"

msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them."
msgstr ""
"여러 패턴을 쉼표로 구분해서 지정할 수 있습니다. 이 패턴들 사이에서 바인딩은 "
"허용되지 않습니다."

msgid "Pattern guards"
msgstr "패턴 가드"

msgid "Classes"
msgstr "클래스"

msgid "Here's a class file example:"
msgstr "클래스 파일 예제입니다:"

msgid "Inheritance"
msgstr "상속(Inheritance)"

msgid "A class (stored as a file) can inherit from:"
msgstr "(파일로 저장한) 클래스는 여기서 상속될 수 있습니다:"

msgid "A global class."
msgstr "전역 클래스(Global class)."

msgid "Another class file."
msgstr "다른 클래스 파일."

msgid "An inner class inside another class file."
msgstr "다른 클래스 파일의 내부 클래스."

msgid "Multiple inheritance is not allowed."
msgstr "다중 상속은 허용되지 않습니다."

msgid "Class constructor"
msgstr "클래스 생성자(Class Constructor)"

msgid "There are a few things to keep in mind here:"
msgstr "유의해야 할 몇 가지 사항이 있습니다:"

msgid "Static constructor"
msgstr "정적 생성자"

msgid "Inner classes"
msgstr "내부 클래스"

msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"클래스 파일은 내부 클래스를 가질 수 있습니다. 내부 클래스는 ``class`` 키워드"
"로 정의합니다. 내부 클래스는 ``ClassName.new()`` 함수로 인스턴스화 될 수 있습"
"니다."

msgid "Classes as resources"
msgstr "리소스로 취급되는 클래스"

msgid "Exports"
msgstr "내보내기"

msgid ""
"Documentation about exports has been moved to :ref:`doc_gdscript_exports`."
msgstr "내보내기에 관한 서술은 :ref:`doc_gdscript_exports`\\ 로 옮겨졌습니다."

msgid "Example:"
msgstr "예시:"

msgid "Tool mode"
msgstr "툴 모드(Tool mode)"

msgid "See :ref:`doc_running_code_in_the_editor` for more information."
msgstr "자세한 설명은 :ref:`doc_running_code_in_the_editor`\\ 를 참고하세요."

msgid ""
"Be cautious when freeing nodes with ``queue_free()`` or ``free()`` in a tool "
"script (especially the script's owner itself). As tool scripts run their "
"code in the editor, misusing them may lead to crashing the editor."
msgstr ""
"Tool 스크립트에서 ``queue_free()`` 또는 ``free()``\\ 로 노드를 해제할 때 (특"
"히 해제할 노드가 스크립트 소유자 자체일 때) 주의하세요. Tool 스크립트는 편집"
"기에서 코드를 실행하기 때문에 잘못 사용하면 편집기가 충돌할 수 있습니다."

msgid "Memory management"
msgstr "메모리 관리"

msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"또는, 참조를 사용하지 않을 때 ``is_instance_valid(instance)``\\ 를 사용해서 "
"오브젝트가 해제되었는지 확인할 수 있습니다."

msgid "Signals"
msgstr "시그널"

msgid ""
"Signals are a tool to emit messages from an object that other objects can "
"react to. To create custom signals for a class, use the ``signal`` keyword."
msgstr ""
"시그널은 한 오브젝트에서 반응할 수 있는 다른 오브젝트로 메시지를 방출하는 도"
"구입니다. 클래스에 대한 커스텀 시그널을 생성하려면 ``signal`` 키워드를 사용하"
"세요."

msgid ""
"Signals are a `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ mechanism. They also fill the role of "
"Observers, a common programming pattern. For more information, read the "
"`Observer tutorial <https://gameprogrammingpatterns.com/observer.html>`_ in "
"the Game Programming Patterns ebook."
msgstr ""
"시그널은 `콜백 <https://ko.wikipedia.org/wiki/콜백>`_ 메커니즘입니다. 그리고 "
"일반적인 프로그래밍 패턴인 옵저버(Observer)의 역할도 합니다. 자세한 정보는 "
"Game Programming Patterns의 전자책, `Observer tutorial <https://"
"gameprogrammingpatterns.com/observer.html>`_\\ 을 읽으세요."

msgid "You can emit as many arguments as you want along with a signal."
msgstr "하나의 시그널에 원하는 만큼 많은 인수를 함께 방출할 수 있습니다."

msgid ""
"Here is an example where this is useful. Let's say we want a life bar on "
"screen to react to health changes with an animation, but we want to keep the "
"user interface separate from the player in our scene tree."
msgstr ""
"위가 유용한 예입니다. 화면의 체력 바가 애니메이션이 적용되며 체력 변화에 반응"
"하기를 원하지만 유저 인터페이스를 씬 트리의 플레이어와 분리하려고 한다고 가정"
"해 보겠습니다."

msgid ""
"In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, "
"then connect the character, that emits the signal, to the receiver, the "
"``Lifebar`` node in this case."
msgstr ""
"``Game`` 노드에서는 ``Character``\\ 와 ``Lifebar`` 노드를 가져와서 시그널을 "
"방출하는 캐릭터를 수신기인 ``Lifebar`` 노드에 연결합니다."

msgid ""
"This allows the ``Lifebar`` to react to health changes without coupling it "
"to the ``Character`` node."
msgstr ""
"이를 통해 ``Lifebar``\\ 를 ``Character`` 노드에 연결하지 않고도 체력 변화에 "
"반응할 수 있습니다."

msgid ""
"These arguments show up in the editor's node dock, and Godot can use them to "
"generate callback functions for you. However, you can still emit any number "
"of arguments when you emit signals; it's up to you to emit the correct "
"values."
msgstr ""
"인수는 편집기의 노드 독에 표시되며 Godot는 이 인수로 콜백 함수를 생성할 수 있"
"습니다. 시그널을 방출할 때 여전히 많은 수의 인수를 방출할 수 있으므로, 다시 "
"말해 올바른 값을 방출하는 일은 여러분에게 달려 있습니다."

msgid "Assert keyword"
msgstr "Assert 키워드"

msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds. This means that the "
"expression passed as argument won't be evaluated in a project exported in "
"release mode. Due to this, assertions must **not** contain expressions that "
"have side effects. Otherwise, the behavior of the script would vary "
"depending on whether the project is run in a debug build."
msgstr ""
"``assert`` 키워드는 디버그 빌드에서 조건을 확인하는 데 사용할 수 있습니다. "
"assert는 디버그 빌드가 아니면 무시됩니다. 즉, 인수로 전달된 표현식은 릴리스 "
"모드로 내보낸 프로젝트에서 평가되지 않습니다. 이 때문에 assert에는 부작용이 "
"있는 표현식이 포함되어서는 **안 됩니다**. 그렇지 않으면 스크립트는 프로젝트"
"가 디버그 빌드인지 여부에 따라 매우 다르게 동작할 것입니다."

msgid ""
"When running a project from the editor, the project will be paused if an "
"assertion error occurs."
msgstr ""
"편집기에서 프로젝트를 실행할 때 assert 오류가 발생하면 프로젝트가 일시 정지됩"
"니다."
