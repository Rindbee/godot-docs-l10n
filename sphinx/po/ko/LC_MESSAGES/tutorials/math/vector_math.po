#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Vector math"
msgstr "벡터 수학"

msgid "Introduction"
msgstr "소개"

msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"이 튜토리얼은 게임 개발에 적용되는 선형대수에 대한 짧고 실용적인 소개입니다. "
"선형 대수란 벡터와 벡터 사용에 대한 학문입니다. 벡터는 2D 및 3D 개발 모두에"
"서 많은 응용방법이 있으며 Godot는 이를 광범위하게 사용합니다. 벡터 수학에 대"
"한 올바른 이해는 강력한 게임 개발자가 되기 위해 필수적입니다."

msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"이 튜토리얼은 선형대수에 관한 공식 교과서가 **절대** 아닙니다. 우리는 단지 그"
"것이 어떻게 게임 개발에 적용되는지 지켜볼 것입니다. 수학에 대한 자세한 내용"
"은 https://www.khanacademy.org/math/linear-algebra을 참조하십시오"

msgid "Coordinate systems (2D)"
msgstr "좌표계 (2D)"

msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"2차원 공간에서, 좌표계들은 가로축(``x``)과 세로축(``y``)을 사용하여 정의됩니"
"다. 2차원 공간에서의 특정한 위치는 ``(4,3)``\\ 과 같이 한 쌍의 값으로 쓰여집"
"니다."

msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"컴퓨터 그래픽을 처음 접하는 사람이라면 아마 수학 수업에서 배웠듯이 양의``y\" "
"축이 위쪽이 아니라 **아래쪽**을 가리키는 것이 이상하게 보일지도 모릅니다. 그"
"러나 대부분의 컴퓨터 그래픽 응용 프로그램에서는 일반적으로 이러한 현상이 발생"
"합니다."

msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"2D 평면의 모든 위치는 이러한 방식으로 한 쌍의 수들로 식별할 수 있습니다. 그러"
"나 우리는 또한 ``(4, 3)``\\ 의 위치를 ``(0, 0)``\\ 또는 원점으로부터의 오프셋"
"으로 생각할 수 있습니다. 원점에서 점까지 점을 가리키는 화살표를 그리세요:"

msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"벡터에 대해 고려해야 할 매우 중요한 점은 벡터가 **상대적인** 방향과 크기만 나"
"타낸다는 것입니다. 벡터의 위치에 대한 개념이 없습니다. 다음 두 벡터는 동일합"
"니다:"

msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"두 벡터 모두 시작점으로 부터 오른쪽으로 4만큼 아랫쪽으로 3만큼 의 단위를 나타"
"냅니다.  평면에서 벡터를 그리는 것은 중요하지 않습니다. 이것은 항상 상대적인 "
"방향과 크기를 나타냅니다."

msgid "Vector operations"
msgstr "벡터 연산"

msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"당신은 둘 중 하나의 방법(x 및 y 좌표 또는 각도 및 크기)을 사용하여 벡터를 참"
"조할 수 있지만, 프로그래머는 편의를 위해 일반적으로 좌표 표기법을 사용합니"
"다. 예를 들어, Godot에서 원점은 화면의 왼쪽 상단 모서리이고, ``Node2D``\\ 라"
"는 2차원의 노드를 400픽셀 오른쪽, 300픽셀 아래로 배치하려면 다음 코드를 사용"
"하십시오:"

msgid "Member access"
msgstr "멤버 접근"

msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr "벡터의 각각의 구성요소는 이름으로 직접 접근할 수 있다."

msgid "Adding vectors"
msgstr "벡터의 합"

msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr "두 벡터를 더하거나 뺄 때, 해당하는 구성요소는 더해집니다:"

msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr ""
"첫번째 벡터의 끝에 두번째 벡터를 더함으로써 우리는 시각적으로도 이것을 확인"
"할 수 있습니다:"

msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr "즉 더하기 a+b는 b+a 와 같은 결과 값을 갖는다."

msgid "Scalar multiplication"
msgstr "스칼라 곱"

msgid "A vector can be multiplied by a **scalar**:"
msgstr "벡터는 스칼라에 의해 곱해질 수 있습니다:"

msgid "Practical applications"
msgstr "실용적인 응용"

msgid "Let's look at two common uses for vector addition and subtraction."
msgstr "벡터 덧셈과 뺄셈의 두 가지 일반적인 용법을 살펴보자."

msgid "Movement"
msgstr "이동"

msgid "Pointing toward a target"
msgstr "표적을 향하기"

msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"이 시나리오에서, 당신은 회전 포탑을 로봇에게 겨누고자 하는 탱크를 가지고 있습"
"니다. 로봇의 위치에서 탱크의 위치를 빼면 탱크에서 로봇을 가리키는 벡터를 얻"
"을 수 있습니다."

msgid "Unit vectors"
msgstr "단위 벡터"

msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"**크기** 가 1인 벡터를 **단위 벡터** 라고 합니다. 또한 이러한 벡터는 **방향 "
"벡터** 또는 **법선벡터** 라고도 합니다. 단위 벡터는 방향을 추적해야 할 때 유"
"용합니다."

msgid "Normalization"
msgstr "표준화"

msgid "Reflection"
msgstr "반사"

msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"단위벡터의 일반적인 용도는 **법선 벡터** 를 나타내는 것입니다. 법선 벡터는 표"
"면에 수직으로 정렬된 단위 벡터를 말하며, 방향을 정의합니다. 이 장치는 일반적"
"으로 조명, 콜리전 및 표면과 관련된 기타 작업에 사용됩니다."

msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr ""
"예를 들어, 우리가 벽이나 다른 물체에서 튀기길 원하는 움직이는 공을 가지고 있"
"다고 상상해 보세요:"

msgid "Dot product"
msgstr "내적"

msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"**내적**\\ 은 벡터 수학에서 가장 중요한 개념 중 하나이지만 종종 잘못 이해됩니"
"다. 내적은 두 벡터를 **스칼라** 로 반환해주는 연산입니다. 크기와 방향 모두를 "
"포함하는 벡터와는 다르게 스칼라 값은 오직 크기만 갖습니다."

msgid "The formula for dot product takes two common forms:"
msgstr "내적의 공식은 두가지 형태를 취한다:"

msgid "and"
msgstr "그리고"

msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr "단위벡터를 사용할때, 결과는 항상 -1(180°)에서 1(0°) 사이일 것이다."

msgid "Facing"
msgstr "직면"

msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"우리는 이 사실을 어떤 물체가 다른 물체를 향하고 있는지 감지하는 데 이용할 수 "
"있습니다. 아래 그림에서 ``P`` 선수는 좀비 ``A``\\ 와 ``B``\\ 를 피하려고 합니"
"다. 좀비의 시야각이 **180°**\\ 라고 가정하면 플레이어를 볼 수 있을까요?"

msgid "In code it would look like this:"
msgstr "코드에서는 이렇게 보일 것이다:"

msgid "Cross product"
msgstr "외적"

msgid "The cross product is calculated like this:"
msgstr "외적은 이렇게 계산된다:"

msgid ""
"With Godot, you can use the built-in :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` method:"
msgstr ""
"Godot에서는 내장 :ref:`Vector3.cross() <class_Vector3_method_cross>` 메서드"
"를 사용할 수 있습니다:"

msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"외적에서는, 순서가 중요합니다. \"a.cross(b)\"는 \"b.cross(a)\"와 같은 결가가 "
"나오지 않습니다.  결과 벡터는 **반대쪽** 방향을 가리킵니다."

msgid "Calculating normals"
msgstr "법선 계산하기"

msgid "Here is a function to calculate a triangle's normal:"
msgstr "이것은 삼각형에 수직인 평면을 계산하는 함수이다:"

msgid "Pointing to a target"
msgstr "대상 가리키기"

msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"위의 내적 섹션에서, 우리는 두 벡터 사이의 각도를 찾는 데 어떻게 이것을 이용"
"할 수 있는지 확인했습니다. 그러나 3차원에서는 정보가 충분하지 않습니다. 우리"
"는 또한 어떤 축을 중심으로 회전해야 하는지 알아야 합니다. 우리는 현재 마주보"
"는 방향과 목표 방향의 외적을 계산함으로써 그것을 발견할 수 있습니다. 그 결과"
"인 수직 벡터는 회전의 축입니다."

msgid "More information"
msgstr "추가 정보"

msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr ""
"Godot에서 벡터 수학을 사용하는 것에 대해 더 많은 정보에 대해서는 다음 글들을 "
"참고하세요:"

msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
