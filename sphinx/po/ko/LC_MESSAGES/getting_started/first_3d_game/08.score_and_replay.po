#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid ""
"In the main scene, add a new child node :ref:`Control <class_Control>` to "
"``Main`` and name it ``UserInterface``. Ensure you are on the 2D screen, "
"where you can edit your User Interface (UI)."
msgstr ""
"메인 씬에서 `Main`의 새로운 자식 노드로 :ref:`Control <class_Control>`을 추가"
"하고, 이름을 `UserInterface`로 지정하세요. UI를 편집할 수 있는 2D 화면에 있는"
"지 확인하세요."

msgid "Add a :ref:`Label <class_Label>` node and name it ``ScoreLabel``"
msgstr ""
":ref:`Label <class_Label>` 노드를 추가하고 노드 이름을 ``ScoreLabel``로 지정"

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid ""
"In the *Inspector*, set the *Label*'s *Text* to a placeholder like \"Score: "
"0\"."
msgstr ""
"*인스펙터*에서 *Label*의 *Text*에 \"Score: 0\"과 같은 플레이스홀더를 설정하세"
"요."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"Also, the text is white by default, like our game's background. We need to "
"change its color to see it at runtime."
msgstr ""
"또한, 텍스트는 기본적으로 게임의 배경과 같은 흰색입니다. 게임 실행 시 텍스트"
"가 보이도록 색상을 변경해야 합니다."

msgid ""
"Scroll down to *Theme Overrides*, and expand *Colors* and enable *Font "
"Color* in order to tint the text to black (which contrasts well with the "
"white 3D scene)"
msgstr ""
"*테마 오버라이드*\\ 까지 스크롤한 다음, *색상*\\ 을 펼치고 *글꼴 색상*\\ 를 "
"활성화하여 텍스트를 검정색으로 틴트를 입히세요. (이렇게 하면 흰색 3D 씬과 대"
"비가 잘 됩니다)"

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Finally, click and drag on the text in the viewport to move it away from the "
"top-left corner."
msgstr ""
"마지막으로, 뷰포트에서 텍스트를 클릭하고 드래그하여 왼쪽 상단 모서리에서 떨어"
"지도록 이동하세요."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"The ``UserInterface`` node allows us to group our UI in a branch of the "
"scene tree and use a theme resource that will propagate to all its children. "
"We'll use it to set our game's font."
msgstr ""
"``UserInterface`` 노드를 사용하면 씬 트리의 한 지점에 UI를 그룹화하고 모든 자"
"식에 전파되는 테마 리소스를 사용할 수 있습니다. 이를 사용하여 게임의 글꼴을 "
"설정할 수 있습니다."

msgid ""
"Once again, select the ``UserInterface`` node. In the *Inspector*, create a "
"new theme resource in *Theme -> Theme*."
msgstr ""
"다시 한 번 ``UserInterface`` 노드를 선택합니다. *인스펙터*에서 *Theme -> "
"Theme*에 새 테마 리소스를 만드세요."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"Click on it to open the theme editor In the bottom panel. It gives you a "
"preview of how all the built-in UI widgets will look with your theme "
"resource."
msgstr ""
"*Theme*을 클릭하여 아래 패널에서 테마 편집기를 엽니다. 이 편집기는 테마 리소"
"스를 사용한 기본 UI 위젯들이 어떻게 보일지 미리 볼 수 있게 해줍니다."

msgid ""
"By default, a theme only has a few properties: *Default Base Scale*, "
"*Default Font* and *Default Font Size*."
msgstr ""
"기본적으로 테마에는 몇 가지 속성만 있습니다: *Default Base Scale*, *Default "
"Font*, *Default Font Size*."

msgid ""
"You can add more properties to the theme resource to design complex user "
"interfaces, but that is beyond the scope of this series. To learn more about "
"creating and editing themes, see :ref:`doc_gui_skinning`."
msgstr ""
"테마 리소스에 더 많은 속성을 추가하여 복잡한 사용자 인터페이스를 디자인할 수 "
"있지만, 이는 본 문서의 범위를 벗어납니다. 테마의 생성과 편집에 대해 더 알고 "
"싶다면 :ref:`doc_gui_skinning`을 참조하세요."

msgid ""
"The *Default Font* expects a font file like the ones you have on your "
"computer. Two common font file formats are TrueType Font (TTF) and OpenType "
"Font (OTF)."
msgstr ""
"*Default Font*에는 컴퓨터에 있는 폰트 파일을 사용합니다. 일반적인 폰트 파일 "
"형식으로는 TrueType Font (TTF)와 OpenType Font (OTF)가 있습니다."

msgid ""
"In the *FileSystem* dock, expand the ``fonts`` directory and click and drag "
"the ``Montserrat-Medium.ttf`` file we included in the project onto the "
"*Default Font*. The text will reappear in the theme preview."
msgstr ""
"*FileSystem* 도크에서 ``fonts`` 디렉터리를 펼치고, 프로젝트에 포함된 "
"``Montserrat-Medium.ttf`` 파일을 *Default Font*로 드래그하세요. 그러면 테마 "
"미리보기에서 텍스트가 다시 나타납니다."

msgid ""
"The text is a bit small. Set the *Default Font Size* to ``22`` pixels to "
"increase the text's size."
msgstr ""
"텍스트가 조금 작습니다. *Default Font Size*를 ``22`` 픽셀로 설정하여 텍스트 "
"크기를 늘리세요."

msgid "|image7|"
msgstr "|image7|"

msgid "Keeping track of the score"
msgstr "점수 추적"

msgid ""
"Let's work on the score next. Attach a new script to the ``ScoreLabel`` and "
"define the ``score`` variable."
msgstr ""
"다음으로 점수가 동작하게 해봅시다. ``ScoreLabel``\\ 에 새로운 스크립트를 추가"
"하고 ``score`` 변수를 정의하세요."

msgid ""
"The score should increase by ``1`` every time we squash a monster. We can "
"use their ``squashed`` signal to know when that happens. However, because we "
"instantiate monsters from the code, we cannot connect the mob signal to the "
"``ScoreLabel`` via the editor."
msgstr ""
"몬스터를 잡을 때마다 점수가 ``1``\\ 씩 올라가도록 해야 합니다. 이를 위해 몬스"
"터가 잡힐 때 발생하는 ``squashed`` 시그널을 사용할 수 있습니다. 다만, 몬스터"
"를 코드에서 생성하기 때문에, 편집기에서 직접 mob 시그널을 ``ScoreLabel``\\ "
"에 연결할 수는 없습니다."

msgid ""
"Instead, we have to make the connection from the code every time we spawn a "
"monster."
msgstr "그 대신에, 매번 몬스터를 소환할 때마다 코드로 연결해야 합니다."

msgid ""
"Open the script ``main.gd``. If it's still open, you can click on its name "
"in the script editor's left column."
msgstr ""
"``main.gd`` 스크립트를 엽니다. 아직 열려 있다면, 스크립트 편집기의 왼쪽 열에"
"서 이름을 클릭하여 열 수 있습니다."

msgid "|image8|"
msgstr "|image8|"

msgid ""
"Alternatively, you can double-click the ``main.gd`` file in the *FileSystem* "
"dock."
msgstr ""
"또는 *FileSystem* 도크에서 ``main.gd`` 파일을 더블 클릭하여 열 수도 있습니다."

msgid ""
"At the bottom of the ``_on_mob_timer_timeout()`` function, add the following "
"line:"
msgstr "``_on_mob_timer_timeout()`` 함수의 하단에 다음 줄을 추가하세요:"

msgid ""
"This line means that when the mob emits the ``squashed`` signal, the "
"``ScoreLabel`` node will receive it and call the function "
"``_on_mob_squashed()``."
msgstr ""
"이 라인은 mob가 ``squashed`` 시그널을 보낼 때 ``ScoreLabel`` 노드가 이를 받"
"아 ``_on_mob_squashed()`` 함수를 호출하도록 한다는 의미입니다."

msgid "There, we increment the score and update the displayed text."
msgstr "여기서 점수를 증가시키고 화면에 표시되는 텍스트를 업데이트합니다."

msgid ""
"The second line uses the value of the ``score`` variable to replace the "
"placeholder ``%s``. When using this feature, Godot automatically converts "
"values to string text, which is convenient when outputting text in labels or "
"when using the ``print()`` function."
msgstr ""
"두 번째 줄에서는 ``score`` 변수의 값을 ``%s``\\ 에 대체하여 사용합니다. 이 기"
"능을 사용하면 Godot가 자동으로 값을 문자열로 변환해 주기 때문에, 라벨에 텍스"
"트를 출력하거나 ``print()`` 함수를 사용할 때 편리합니다."

msgid ""
"You can learn more about string formatting here: :ref:`doc_gdscript_printf`. "
"In C#, consider using `string interpolation with \"$\" <https://"
"learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/"
"interpolated>`_."
msgstr ""
"문자열 포맷팅에 대해 더 알고 싶다면 :ref:`doc_gdscript_printf`를 참조하세요. "
"C#에서는 `문자열 보간법 (\"$\") <https://learn.microsoft.com/en-us/dotnet/"
"csharp/language-reference/tokens/interpolated>`_ 을 확인해 보세요."

msgid ""
"You can now play the game and squash a few enemies to see the score increase."
msgstr ""
"이제 게임을 실행해 적을 잡아보면 점수가 올라가는 것을 확인할 수 있습니다."

msgid "|image9|"
msgstr "|image9|"

msgid ""
"In a complex game, you may want to completely separate your user interface "
"from the game world. In that case, you would not keep track of the score on "
"the label. Instead, you may want to store it in a separate, dedicated "
"object. But when prototyping or when your project is simple, it is fine to "
"keep your code simple. Programming is always a balancing act."
msgstr ""
"복잡한 게임에서는 사용자 인터페이스를 게임 세계와 완전히 분리하고 싶을 수도 "
"있습니다. 그런 경우 라벨에서 점수를 관리하지 않고, 별도의 객체에 저장할 수 있"
"습니다. 그러나 프로토타입 단계나 간단한 프로젝트에서는 코드를 간단하게 유지하"
"는 것이 좋습니다. 프로그래밍은 항상 균형을 맞추는 작업입니다."

msgid "Retrying the game"
msgstr "게임 다시 플레이"

msgid ""
"We'll now add the ability to play again after dying. When the player dies, "
"we'll display a message on the screen and wait for input."
msgstr ""
"이제 죽은 후에 다시 플레이할 수 있는 기능을 추가해 보겠습니다. 플레이어가 죽"
"으면 화면에 메시지를 표시하고 입력을 기다리도록 할 것입니다."

msgid ""
"Head back to the ``main.tscn`` scene, select the ``UserInterface`` node, add "
"a child node :ref:`ColorRect <class_ColorRect>`, and name it ``Retry``. This "
"node fills a rectangle with a uniform color and will serve as an overlay to "
"darken the screen."
msgstr ""
"``main.tscn`` 씬으로 돌아가서 ``UserInterface`` 노드를 선택한 후, 자식 노드"
"로 :ref:`ColorRect <class_ColorRect>`를 추가하고 이름을 ``Retry``로 설정하세"
"요. 이 노드는 화면을 어둡게 하는 오버레이로 사용될 단색 사각형을 채우는 역할"
"을 합니다."

msgid ""
"To make it span over the whole viewport, you can use the *Anchor Preset* "
"menu in the toolbar."
msgstr ""
"이 노드가 뷰포트 전체를 덮도록 하려면, 툴바의 *Anchor Preset* 메뉴를 사용하세"
"요."

msgid "|image10|"
msgstr "|image10|"

msgid "Open it and apply the *Full Rect* command."
msgstr "메뉴를 열고 *공간 전체* 명령을 적용하세요."

msgid "|image11|"
msgstr "|image11|"

msgid ""
"Nothing happens. Well, almost nothing; only the four green pins move to the "
"corners of the selection box."
msgstr ""
"아직 아무 일도 일어나지 않았습니다. 정확히는 거의 아무 변화도 없고, 초록색 "
"핀 4개만 선택 상자의 모서리로 이동했습니다."

msgid "|image12|"
msgstr "|image12|"

msgid ""
"This is because UI nodes (all the ones with a green icon) work with anchors "
"and margins relative to their parent's bounding box. Here, the "
"``UserInterface`` node has a small size and the ``Retry`` one is limited by "
"it."
msgstr ""
"이는 UI 노드(녹색 아이콘이 표시된 모든 노드)가 부모 노드의 선택 상자를 기준으"
"로 anchor와 margin을 사용하기 때문입니다. 여기서 ``UserInterface`` 노드는 크"
"기가 작으며, ``Retry`` 노드는 그에 의해 제한됩니다."

msgid ""
"Select the ``UserInterface`` and apply *Anchor Preset -> Full Rect* to it as "
"well. The ``Retry`` node should now span the whole viewport."
msgstr ""
"``UserInterface`` 노드를 선택하고 거기에도 *앵커 프리셋 -> 공간 전체*를 적용"
"합니다. ``Retry`` 노드가 이제 전체 뷰포트에 걸쳐 있어야 합니다."

msgid ""
"Let's change its color so it darkens the game area. Select ``Retry`` and in "
"the *Inspector*, set its *Color* to something both dark and transparent. To "
"do so, in the color picker, drag the *A* slider to the left. It controls the "
"color's Alpha channel, that is to say, its opacity/transparency."
msgstr ""
"이제 화면을 어둡게 만들기 위해 색상을 변경해 봅시다. ``Retry`` 노드를 선택하"
"고 *인스펙터*에서 *Color*를 어두우면서도 투명한 색으로 설정합니다. 이를 위해 "
"색상 선택기에서 *A* 슬라이더를 왼쪽으로 드래그하세요. 이 슬라이더는 색상의 알"
"파(Alpha)값, 즉 불투명도/투명도를 제어할 수 있습니다."

msgid "|image13|"
msgstr "|image13|"

msgid "|image14|"
msgstr "|image14|"

msgid "Coding the retry option"
msgstr "재시작 옵션 코딩"

msgid ""
"We can now head to the code to show and hide the ``Retry`` node when the "
"player dies and plays again."
msgstr ""
"이제 플레이어가 죽었을 때와 다시 플레이할 때 ``Retry`` 노드를 표시하거나 숨기"
"는 코드를 작성할 차례입니다."

msgid ""
"Open the script ``main.gd``. First, we want to hide the overlay at the start "
"of the game. Add this line to the ``_ready()`` function."
msgstr ""
"``main.gd`` 스크립트를 엽니다. 먼저 게임 시작 시 오버레이를 숨기고자 합니다. "
"이를 위해 ``_ready()`` 함수에 다음 줄을 추가하세요."

msgid "Then, when the player gets hit, we show the overlay."
msgstr "이제, 플레이어가 타격받았을 때, 오버레이가 표시됩니다."

msgid ""
"Finally, when the ``Retry`` node is visible, we need to listen to the "
"player's input and restart the game if they press enter. To do this, we use "
"the built-in ``_unhandled_input()`` callback, which is triggered on any "
"input."
msgstr ""
"마지막으로, ``Retry`` 노드가 표시될 때 플레이어의 입력을 감지해, 엔터 키를 누"
"르면 게임을 다시 시작해야 합니다. 이를 위해, 모든 입력에서 호출되는 내장 콜"
"백 함수 ``_unhandled_input()``를 이용할 것입니다."

msgid ""
"If the player pressed the predefined ``ui_accept`` input action and "
"``Retry`` is visible, we reload the current scene."
msgstr ""
"``Retry`` 노드가 표시된 상태에서 플레이어가 미리 정의된 ``ui_accept``를 입력"
"하면, 이 씬을 다시 불러옵니다."

msgid ""
"The function ``get_tree()`` gives us access to the global :ref:`SceneTree "
"<class_SceneTree>` object, which allows us to reload and restart the current "
"scene."
msgstr ""
"``get_tree()`` 함수는 :ref:`SceneTree <class_SceneTree>`에 접근할 권한을 부여"
"합니다. 이 권한을 통해 씬을 재시작할 수 있습니다."

msgid "Adding music"
msgstr "노래 추가하기"

msgid ""
"To add music that plays continuously in the background, we're going to use "
"another feature in Godot: :ref:`autoloads <doc_singletons_autoload>`."
msgstr ""
"배경에서 계속 재생되는 음악을 추가하기 위해, 우리는 Godot의 또 다른 기능"
"인 :ref:`autoloads <doc_singletons_autoload>`를 사용할 것입니다."

msgid ""
"To play audio, all you need to do is add an :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` node to your scene and attach an audio file to "
"it. When you start the scene, it can play automatically. However, when you "
"reload the scene, like we do to play again, the audio nodes are also reset, "
"and the music starts back from the beginning."
msgstr ""
"오디오를 재생하려면 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>` 노드"
"를 씬에 추가하고 오디오 파일을 붙이기만 하면 됩니다. 씬을 시작하면 자동으로 "
"재생될 수 있습니다. 하지만 다시 재생하기 위해 하는 것처럼 씬을 새로 고치면 오"
"디오 노드도 재설정되고 음악이 처음부터 다시 시작됩니다."

msgid ""
"You can use the autoload feature to have Godot load a node or a scene "
"automatically at the start of the game, outside the current scene. You can "
"also use it to create globally accessible objects."
msgstr ""
"오토로드 기능을 사용하면 Godot가 게임 시작 시 현재 장면 외부에서 노드나 장면"
"을 자동으로 불러올 수 있습니다. 또한 전역적으로 접근 가능한 객체를 생성하는 "
"데도 사용할 수 있습니다."

msgid ""
"Create a new scene by going to the *Scene* menu and clicking *New Scene* or "
"by using the *+* icon next to your currently opened scene."
msgstr ""
"Scene 메뉴로 가서 New Scene을 클릭하거나 현재 열려 있는 장면 옆의 + 아이콘을 "
"사용하여 새 씬을 만드세요."

msgid ""
"Click the *Other Node* button to create an :ref:`AudioStreamPlayer "
"<class_AudioStreamPlayer>` and rename it to ``MusicPlayer``."
msgstr ""
"Other Node 버튼을 클릭하여 :ref:`AudioStreamPlayer <class_AudioStreamPlayer>`"
"를 생성한 후, 이름을 ``MusicPlayer``로 변경하세요."

msgid ""
"We included a music soundtrack in the ``art/`` directory, ``House In a "
"Forest Loop.ogg``. Click and drag it onto the *Stream* property in the "
"*Inspector*. Also, turn on *Autoplay* so the music plays automatically at "
"the start of the game."
msgstr ""
"``art/`` 디렉토리에 있는 음악 House In a Forest Loop.ogg를 *인스펙터*의 "
"Stream 속성에 클릭하고 드래그하여 추가하세요. 또한, *Autoplay*를 켜서 게임 시"
"작 시 음악이 자동으로 재생되도록 설정하세요."

msgid "Save the scene as ``music_player.tscn``."
msgstr "``music_player.tscn`` 과 같은 이름으로 씬을 저장합니다."

msgid ""
"In the *Path* field, you want to enter the path to your scene. Click the "
"folder icon to open the file browser and double-click on "
"``music_player.tscn``. Then, click the *Add* button on the right to register "
"the node."
msgstr ""
"Path 필드에 씬의 경로를 입력해야 합니다. 폴더 아이콘을 클릭하여 파일 브라우저"
"를 열고``music_player.tscn`` 파일을 두 번 클릭하세요. 그런 다음, 오른쪽의 "
"*Add* 버튼을 클릭하여 노드를 등록하세요."

msgid ""
"``music_player.tscn`` now loads into any scene you open or play. So if you "
"run the game now, the music will play automatically in any scene."
msgstr ""
"이제 ``music_player.tscn``이 여러분이 열거나 실행하는 모든 씬에 로드됩니다. "
"따라서 지금 게임을 실행하면, 모든 씬에서 음악이 자동으로 재생됩니다."

msgid ""
"Before we wrap up this lesson, here's a quick look at how it works under the "
"hood. When you run the game, your *Scene* dock changes to give you two tabs: "
"*Remote* and *Local*."
msgstr ""
"이 레슨을 마무리하기 전에, 작동 원리를 간단히 살펴보겠습니다. 게임을 실행하"
"면 *씬* 독(Scene Dock)이 *원격*(Remote)과 *로컬*(Local) 두 개의 탭으로 변경됩"
"니다."

msgid ""
"The *Remote* tab allows you to visualize the node tree of your running game. "
"There, you will see the *Main* node and everything the scene contains and "
"the instantiated mobs at the bottom."
msgstr ""
"*원격* 탭(Remote Tab)을 사용하면 실행 중인 게임의 노드 트리를 볼 수 있습니"
"다. 이 탭에서 *Main* 노드와 씬에 포함된 모든 요소, 그리고 아래에서 인스턴스화"
"된 몹들을 확인할 수 있습니다."

msgid ""
"At the top are the autoloaded ``MusicPlayer`` and a *root* node, which is "
"your game's viewport."
msgstr ""
"맨 위에는 오토로드된 ``MusicPlayer``와 *root* 노드가 있습니다. *root* 노드는 "
"게임의 뷰포트를 나타냅니다."

msgid ""
"And that does it for this lesson. In the next part, we'll add an animation "
"to make the game both look and feel much nicer."
msgstr ""
"이것으로 이번 레슨을 마칩니다. 다음 단계에서는 게임에 애니메이션을 추가하여 "
"더 멋지게 만들어 보겠습니다."
