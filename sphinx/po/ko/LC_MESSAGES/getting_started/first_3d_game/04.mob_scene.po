#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"이 파트에서는 몹이라고 부르는 괴물을 코딩해 보겠습니다. 다음 단원에서는 몹을 "
"플레이 가능한 영역에 무작위로 소환하겠습니다."

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the ``player.tscn`` scene."
msgstr ""
"새 씬에서 몬스터 자체를 디자인해 봅시다. 노드 구조는 ``player.tscn`` 씬과 비"
"슷할 것입니다."

msgid ""
"Create a scene with, once again, a :ref:`CharacterBody3D "
"<class_CharacterBody3D>` node as its root. Name it ``Mob``. Add a child "
"node :ref:`Node3D <class_Node3D>`, name it ``Pivot``. And drag and drop the "
"file ``mob.glb`` from the *FileSystem* dock onto the ``Pivot`` to add the "
"monster's 3D model to the scene."
msgstr ""
"다시 한 번 :ref:`CharacterBody3D <class_CharacterBody3D>` 노드를 루트로 하여 "
"씬을 생성합니다. 이름을 ``Mob`` 으로 지정합니다. 자식 노드인 :ref:`Node3D "
"<class_Node3D>`를 추가하고 이름을 ``Pivot`` 으로 지정합니다. 그리고 *File "
"System* 도크에서 ``mob.glb`` 파일을 ``Pivot`` 으로 끌어다 놓아 몬스터의 3D 모"
"델을 씬에 추가합니다."

msgid "You can rename the newly created ``mob`` node into ``Character``."
msgstr "새로 생성한 ``mob`` 노드의 이름을 ``Character`` 로 변경할 수 있습니다."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"We need a collision shape for our body to work. Right-click on the ``Mob`` "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"신체가 작동하려면 충돌 모양이 필요합니다. 씬의 루트인 ``Mob`` 노드를 마우스 "
"오른쪽 버튼으로 클릭하고 *Add Child Node*를 클릭합니다."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid "In the *Inspector*, assign a *BoxShape3D* to the *Shape* property."
msgstr "*Inspector* 에서 *BoxShape3D* 를 *Shape* 프로퍼티에 할당합니다."

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"3D 모델에 더 잘 맞도록 크기를 변경해야 합니다. 주황색 점을 클릭하고 드래그하"
"여 대화형으로 변경할 수 있습니다."

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"상자는 바닥에 닿아야 하며 모델보다 약간 얇아야 합니다. 물리 엔진은 플레이어"
"의 구체가 상자의 모서리에 닿으면 충돌이 발생하는 방식으로 작동합니다. 상자가 "
"3D 모델에 비해 너무 크면 몬스터와 멀리 떨어진 곳에서 죽을 수 있으며 플레이어"
"에게 게임이 불공평하게 느껴질 수 있습니다."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"내 상자가 괴물보다 더 큰 것을 알 수 있습니다. 이 게임에서는 위에서 고정된 시"
"점을 사용하여 장면을 보고 있기 때문에 괜찮습니다. 콜리전 모양이 모델과 정확"
"히 일치할 필요는 없습니다. 테스트할 때 게임의 느낌에 따라 형태와 크기를 결정"
"해야 합니다."

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob is outside the screen."
msgstr ""
"게임 레벨에서 일정한 시간 간격으로 괴물을 소환할 것입니다. 조심하지 않으면 괴"
"물의 수가 무한대로 늘어날 수 있는데, 이런 상황을 원하지 않습니다. 각 몹 인스"
"턴스에는 메모리와 처리 비용이 모두 있으며, 몹이 화면 밖에 있을 때는 비용을 지"
"불하고 싶지 않습니다."

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we should "
"delete it. Godot has a node that detects when objects leave the "
"screen, :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, "
"and we're going to use it to destroy our mobs."
msgstr ""
"몬스터가 화면을 떠나면 더 이상 필요하지 않으므로 삭제해야 합니다. 고닷에는 오"
"브젝트가 화면을 떠나는 시점을 감지하는 노드"
"인 :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`가 있으"
"며, 이를 사용하여 몹을 파괴할 것입니다."

msgid ""
"When you keep instancing an object, there's a technique you can use to avoid "
"the cost of creating and destroying instances all the time called pooling. "
"It consists of pre-creating an array of objects and reusing them over and "
"over."
msgstr ""
"객체를 계속 인스턴스화할 때 인스턴스를 항상 생성하고 소멸하는 비용을 피하기 "
"위해 풀링이라는 기술을 사용할 수 있습니다. 풀링은 객체 배열을 미리 생성하고 "
"이를 반복해서 재사용하는 방식으로 구성됩니다."

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here: :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"GDScript로 작업할 때는 이에 대해 걱정할 필요가 없습니다. 풀을 사용하는 주된 "
"이유는 C#이나 Lua와 같은 가비지 수집 언어에서 멈추는 현상을 피하기 위해서입니"
"다. GDScript는 메모리 관리, 참조 카운팅에 다른 기술을 사용하므로 이러한 주의 "
"사항이 없습니다. 이에 대한 자세한 내용은 여기에서 확인할 수 있습니"
"다: :ref:`doc_gdscript_basics_memory_management`."

msgid ""
"Select the ``Mob`` node and add a child node :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`. Another box, pink this time, appears. "
"When this box completely leaves the screen, the node will emit a signal."
msgstr ""
"``Mob`` 노드를 선택하고 자식 노드 :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`를 추가합니다. 이번에는 분홍색의 또 다른 상"
"자가 나타납니다. 이 상자가 화면에서 완전히 사라지면 노드는 신호를 방출합니다."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr "전체 3D 모델을 덮을 때까지 주황색 점을 사용하여 크기를 조정합니다."

msgid "Coding the mob's movement"
msgstr "몹의 움직임 코딩하기"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the ``Mob`` that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the ``main.tscn`` scene and call the function from there."
msgstr ""
"몬스터의 동작을 구현해 봅시다. 이 작업은 두 단계로 진행하겠습니다. 먼저 몬스"
"터를 초기화하는 함수를 정의하는 스크립트를 ``Mob`` 에 작성합니다. 그런 다음 "
"``main.tscn`` 씬에서 무작위 소환 메커니즘을 코딩하고 거기에서 함수를 호출합니"
"다."

msgid "|image7|"
msgstr "|image7|"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range, which we "
"will later use to define ``CharacterBody3D.velocity``."
msgstr ""
"먼저 시작할 이동 코드는 다음과 같습니다. ``min_speed`` 와 ``max_speed`` 라는 "
"두 프로퍼티를 정의하여 임의의 속도 범위를 정의하고, 나중에 "
"``CharacterBody3D.velocity`` 를 정의하는 데 사용할 것입니다."

msgid ""
"Similarly to the player, we move the mob every frame by calling the function "
"``CharacterBody3D.move_and_slide()``. This time, we don't update the "
"``velocity`` every frame; we want the monster to move at a constant speed "
"and leave the screen, even if it were to hit an obstacle."
msgstr ""
"플레이어와 마찬가지로 ``CharacterBody3D.move_and_slide()`` 함수를 호출하여 몹"
"을 매 프레임마다 이동시킵니다. 이번에는 매 프레임마다 ``velocity``를 업데이트"
"하지 않고, 몬스터가 장애물에 부딪히더라도 일정한 속도로 움직이며 화면을 벗어"
"나도록 합니다."

msgid ""
"We need to define another function to calculate the "
"``CharacterBody3D.velocity``. This function will turn the monster towards "
"the player and randomize both its angle of motion and its velocity."
msgstr ""
"``CharacterBody3D.velocity`` 를 계산하기 위해 다른 함수를 정의해야 합니다. "
"이 함수는 몬스터가 플레이어를 향해 움직이고 그 각도와 속도를 모두 무작위화합"
"니다."

msgid ""
"The function will take a ``start_position``,the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"이 함수는 몹의 소환 위치인 ``start_position``\\ 과 ``player_position``\\ 을 "
"인수로 받습니다."

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``randf_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"몹을 ``start_position`` 에 배치하고 ``look_at_from_position()`` 메서드를 사용"
"하여 플레이어를 향해 돌리고, Y축을 중심으로 임의의 양을 회전시켜 각도를 랜덤"
"화합니다. 아래 ``randf_range()`` 는 ``-PI / 4`` 라디안과 ``PI / 4`` 라디안 사"
"이의 임의의 값을 출력합니다."

msgid ""
"We got a random position, now we need a ``random_speed``. ``randi_range()`` "
"will be useful as it gives random int values, and we will use ``min_speed`` "
"and ``max_speed``. ``random_speed`` is just an integer, and we just use it "
"to multiply our ``CharacterBody3D.velocity``. After ``random_speed`` is "
"applied, we rotate ``CharacterBody3D.velocity`` Vector3 towards the player."
msgstr ""
"임의의 위치를 얻었으니 이제 ``random_speed`` 가 필요합니다. "
"``randi_range()`` 는 임의의 정수 값을 제공하므로 유용하며, ``min_speed`` 와 "
"``max_speed`` 를 사용합니다. ``random_speed`` 는 그냥 정수이며, "
"``CharacterBody3D.velocity`` 를 곱하는 데 사용합니다. ``random_speed`` 가 적"
"용된 후 ``CharacterBody3D.velocity`` Vector3를 플레이어를 향해 회전시킵니다."

msgid "Leaving the screen"
msgstr "화면 떠나기"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node's ``screen_exited`` signal to the "
"``Mob``."
msgstr ""
"몹이 화면을 떠날 때 파괴해야 합니다. 이를 위"
"해 :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` 노드의 "
"``screen_exited`` 신호를 ``Mob`` 에 연결합니다."

msgid "|image8|"
msgstr "|image8|"

msgid ""
"Select the :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node and on the right side of the "
"interface, navigate to the *Node* dock. Double-click the ``screen_exited()`` "
"signal."
msgstr ""
":ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` 노드를 선"
"택하고 인터페이스 오른쪽에서 *Node* 도크로 이동합니다. ``screen_exited()`` 신"
"호를 더블클릭합니다."

msgid "|image9|"
msgstr "|image9|"

msgid "|image10|"
msgstr "|image10|"

msgid ""
"This will add a new function for you in your mob script, "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. From it, call the "
"``queue_free()`` method. This function destroys the instance it's called on."
msgstr ""
"이렇게 하면 몹 스크립트에 "
"``_on_visible_on_screen_notifier_3d_screen_exited()`` 라는 새 함수가 추가됩니"
"다. 이 함수에서 ``queue_free()`` 메서드를 호출합니다. 이 함수는 호출된 인스턴"
"스를 파괴합니다."

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"괴물이 게임에 참가할 준비가 되었습니다! 다음 부분에서는 게임 레벨에 괴물을 소"
"환합니다."
