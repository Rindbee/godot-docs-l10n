#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid ""
"In this part, we'll add the ability to jump and squash the monsters. In the "
"next lesson, we'll make the player die when a monster hits them on the "
"ground."
msgstr ""
"이번 파트에서는 점프하여 몬스터를 찌르는 기능을 추가하겠습니다. 다음 단원에서"
"는 몬스터가 플레이어를 바닥에 내리치면 플레이어가 죽도록 만들겠습니다."

msgid ""
"Physics bodies have access to two complementary properties: layers and "
"masks. Layers define on which physics layer(s) an object is."
msgstr ""
"Physics bodies는 레이어와 마스크라는 두 가지 상호 보완적인 프로퍼티에 액세스"
"할 수 있습니다. 레이어는 오브젝트가 어떤 피직스 레이어에 있는지 정의합니다."

msgid ""
"Masks control the layers that a body will listen to and detect. This affects "
"collision detection. When you want two bodies to interact, you need at least "
"one to have a mask corresponding to the other."
msgstr ""
"마스크는 바디가 듣고 감지할 레이어를 제어합니다. 이는 콜리전 감지에 영향을 줍"
"니다. 두 바디가 상호 작용하려면 적어도 하나는 다른 바디에 해당하는 마스크가 "
"있어야 합니다."

msgid "If that's confusing, don't worry, we'll see three examples in a second."
msgstr "헷갈리신다면 걱정하지 마세요. 곧 세 가지 예를 보여드리겠습니다."

msgid ""
"The important point is that you can use layers and masks to filter physics "
"interactions, control performance, and remove the need for extra conditions "
"in your code."
msgstr ""
"중요한 점은 레이어와 마스크를 사용하여 물리 상호작용을 필터링하고 성능을 제어"
"하며 코드에서 추가 조건의 필요성을 제거할 수 있다는 점입니다."

msgid ""
"By default, all physics bodies and areas are set to both layer and mask "
"``1``. This means they all collide with each other."
msgstr ""
"기본적으로 모든 피직스 바디와 영역은 레이어와 마스크 모두 ``1`` 로 설정됩니"
"다. 이는 모두 서로 충돌한다는 뜻입니다."

msgid ""
"Physics layers are represented by numbers, but we can give them names to "
"keep track of what's what."
msgstr ""
"물리 레이어는 숫자로 표시되지만, 이름을 지정하여 무엇이 무엇인지 추적할 수 있"
"습니다."

msgid ""
"Let's give our physics layers a name. Go to *Project -> Project Settings*."
msgstr ""
"물리 레이어에 이름을 지정해 봅시다. *Project-> Project Settings*로 이동합니"
"다."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"In the left menu, navigate down to *Layer Names -> 3D Physics*. You can see "
"a list of layers with a field next to each of them on the right. You can set "
"their names there. Name the first three layers *player*, *enemies*, and "
"*world*, respectively."
msgstr ""
"왼쪽 메뉴에서 *Layer Names -> 3D Physics* 로 이동합니다. 오른쪽에 각 레이어 "
"옆에 필드가 있는 레이어 목록을 볼 수 있습니다. 거기에서 이름을 설정할 수 있습"
"니다. 처음 세 개의 레이어 이름을 각각 *player*, *enemies*, *world* 로 지정합"
"니다."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "Now, we can assign them to our physics nodes."
msgstr "이제 물리 노드에 할당할 수 있습니다."

msgid "Assigning layers and masks"
msgstr "레이어와 마스크 할당하기"

msgid ""
"In the *Main* scene, select the ``Ground`` node. In the *Inspector*, expand "
"the *Collision* section. There, you can see the node's layers and masks as a "
"grid of buttons."
msgstr ""
"*Main* 씬에서 ``Ground`` 노드를 선택합니다. *Inspector* 에서 *Collision* 섹션"
"을 펼칩니다. 여기에서 노드의 레이어와 마스크를 버튼 격자로 볼 수 있습니다."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"The ground is part of the world, so we want it to be part of the third "
"layer. Click the lit button to toggle **off** the first *Layer* and toggle "
"**on** the third one. Then, toggle **off** the *Mask* by clicking on it."
msgstr ""
"Ground는 세계의 일부이므로, 세 번째 레이어의 일부가 되기를 원합니다. 불이 켜"
"진 버튼을 클릭하여 첫 번째 *Layer*를 **끄고** 세 번째 레이어를 **켜세요**. 그"
"런 다음 *Mask*를 클릭하여 **끄기**를 선택합니다."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Note that you can click the \"...\" button on the right side of the "
"properties to see a list of named checkboxes."
msgstr ""
"속성 오른쪽에 \"...\" 버튼을 클릭해서 이름 붙여진 확인 상자의 리스트를 볼 수 "
"있음을 참고하세요."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Next up are the ``Player`` and the ``Mob``. Open ``player.tscn`` by double-"
"clicking the file in the *FileSystem* dock."
msgstr ""
"다음으로 ``Player``\\ 와 ``Mob``\\ 입니다. *파일시스템* 독에서 파일을 더블 클"
"릭하여 ``player.tscn``\\ 을 엽니다."

msgid ""
"Select the *Player* node and set its *Collision -> Mask* to both \"enemies\" "
"and \"world\". You can leave the default *Layer* property as it is, because "
"the first layer is the \"player\" layer."
msgstr ""
"*Player* 노드를 선택하고 *콜리전 -> 마스크*\\ 를 \"enemies\"와 \"world\" 전부"
"로 설정합니다. 첫 번째 레이어는 \"player\" 레이어이기 때문에 기본 *Layer* 속"
"성은 그대로 놔둬도 됩니다."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"Then, open the *Mob* scene by double-clicking on ``mob.tscn`` and select the "
"``Mob`` node."
msgstr ""
"그리고, ``mob.tscn`` 을 더블 클릭하고 ``Mob`` 노드를 선택하여 *Mob* 씬을 엽니"
"다."

msgid ""
"Set its *Collision -> Layer* to \"enemies\" and unset its *Collision -> "
"Mask*, leaving the mask empty."
msgstr ""
"이 *콜리전 -> 레이어*\\ 를 \"enemies\"로 설정하고 *콜리전 -> 마스크*\\ 를 설"
"정 취소하여 마스크를 비게 합니다."

msgid ""
"These settings mean the monsters will move through one another. If you want "
"the monsters to collide with and slide against each other, turn **on** the "
"\"enemies\" mask."
msgstr ""
"이 설정들은 몬스터들이 서로를 통과하여 움직임을 의미합니다. 만약 몬스터들이 "
"서로 충돌하고 미끄러지길 원하신다면 \"enemies\" 마스크를 **켜**\\ 세요."

msgid ""
"The mobs don't need to mask the \"world\" layer because they only move on "
"the XZ plane. We don't apply any gravity to them by design."
msgstr ""
"몹은 XZ 평면에서만 움직이기 때문에 \"world\" 레이어에 마스크하지 않아도 됩니"
"다. 우리는 이들에 의도적으로 아무 중력도 적용하지 않습니다."

msgid "Jumping"
msgstr "점프"

msgid ""
"The jumping mechanic itself requires only two lines of code. Open the "
"*Player* script. We need a value to control the jump's strength and update "
"``_physics_process()`` to code the jump."
msgstr ""
"점프 기능은 단 두 줄의 코드만 있으면 됩니다. *Player* 스크립트를 엽니다. 우리"
"는 점프를 코딩하기 위해 점프의 강도를 조절할 값과 ``_physics_process()``를 업"
"데이트해줘야 합니다."

msgid ""
"After the line that defines ``fall_acceleration``, at the top of the script, "
"add the ``jump_impulse``."
msgstr ""
"스크립트 최상단의 ``fall_acceleration``이 정의된 줄 밑에 ``jump_impulse``를 "
"추가합니다."

msgid ""
"Inside ``_physics_process()``, add the following code before the "
"``move_and_slide()`` codeblock."
msgstr ""
"``_physics_process()``안의 ``move_and_slide()`` 위에 다음 코드를 추가합니다."

msgid "That's all you need to jump!"
msgstr "점프에는 이것만 있으면 됩니다!"

msgid ""
"The ``is_on_floor()`` method is a tool from the ``CharacterBody3D`` class. "
"It returns ``true`` if the body collided with the floor in this frame. "
"That's why we apply gravity to the *Player*: so we collide with the floor "
"instead of floating over it like the monsters."
msgstr ""
"``is_on_floor()`` 메서드는 ``CharacterBody3D`` 클래스의 도구입니다. 이것은 현"
"재 프레임에 바디가 바닥과 충돌했다면 ``true``(참)을 반환합니다. 그렇기 때문"
"에 우리는 *Player*에 중력을 적용합니다. 그러면 우리는 몬스터같이 바닥 위에 떠"
"다니는 대신 바닥과 접축할 수 있습니다."

msgid ""
"If the character is on the floor and the player presses \"jump\", we "
"instantly give them a lot of vertical speed. In games, you really want "
"controls to be responsive and giving instant speed boosts like these, while "
"unrealistic, feels great."
msgstr ""
"만약 캐릭터가 바닥 위에 있고 플레이어가 \"jump\"를 누른다면 우리는 캐릭터에 "
"많은 수직 속도를 부여합니다. 게임 안에서는, 당신은 이렇게 조작이 즉시 반응하"
"고 일시적인 속도 부스트를 받기를 원합니다. 비현실적이지만, 감각은 좋으니까요."

msgid ""
"Notice that the Y axis is positive upwards. That's unlike 2D, where the Y "
"axis is positive downwards."
msgstr ""
"Y축이 위쪽으로 양수인 것을 알 수 있습니다. 이는 Y축이 아래쪽으로 양수인 2D와 "
"다릅니다."

msgid "Squashing monsters"
msgstr "몬스터를 짓밟기"

msgid ""
"Let's add the squash mechanic next. We're going to make the character bounce "
"over monsters and kill them at the same time."
msgstr ""
"다음으로 스쿼시 메카닉을 추가해 보겠습니다. 캐릭터가 몬스터를 튕기면서 동시"
"에 몬스터를 처치하도록 만들겠습니다."

msgid ""
"We need to detect collisions with a monster and to differentiate them from "
"collisions with the floor. To do so, we can use Godot's :ref:`group "
"<doc_groups>` tagging feature."
msgstr ""
"몬스터와의 콜리전을 감지하고 바닥과의 콜리전과 구분해야 합니다. 이를 위해 "
"Godot의 :ref:`group <doc_groups>` 태깅 기능을 사용할 수 있습니다."

msgid "|image7|"
msgstr "|image7|"

msgid "|image8|"
msgstr "|image8|"

msgid "|image9|"
msgstr "|image9|"

msgid ""
"An icon appears in the *Scene* dock to indicate the node is part of at least "
"one group."
msgstr ""
"*씬* 독에 아이콘이 표시되어 노드가 하나 이상의 그룹에 속해 있음을 나타냅니다."

msgid "|image10|"
msgstr "|image10|"

msgid ""
"We can now use the group from the code to distinguish collisions with "
"monsters from collisions with the floor."
msgstr ""
"이제 코드의 그룹을 사용하여 몬스터와의 콜리전과 바닥과의 콜리전을 구분할 수 "
"있습니다."

msgid "Coding the squash mechanic"
msgstr "스쿼시 메카닉 코딩하기"

msgid "Head back to the *Player* script to code the squash and bounce."
msgstr "*플레이어* 스크립트로 돌아가서 스쿼시 및 바운스를 코딩하세요."

msgid ""
"At the top of the script, we need another property, ``bounce_impulse``. When "
"squashing an enemy, we don't necessarily want the character to go as high up "
"as when jumping."
msgstr ""
"스크립트의 맨 위에는 또 다른 속성인 ``bounce_impulse``\\ 가 필요합니다. 적을 "
"격파할 때 캐릭터가 점프할 때처럼 높이 올라가는 것은 원하지 않습니다."

msgid ""
"Then, after the **Jumping** codeblock we added above in "
"``_physics_process()``, add the following loop. With ``move_and_slide()``, "
"Godot makes the body move sometimes multiple times in a row to smooth out "
"the character's motion. So we have to loop over all collisions that may have "
"happened."
msgstr ""
"그런 다음 위에서 ``_physics_process()``\\ 에 추가한 **Jumping** 코드 블록 뒤"
"에 다음 루프를 추가합니다. Godot는 ``move_and_slide()``\\ 를 사용하여 캐릭터"
"의 움직임을 부드럽게 하기 위해 몸을 여러 번 연속으로 움직이게 합니다. 따라서 "
"발생했을 수 있는 모든 콜리전을 반복해야 합니다."

msgid ""
"In every iteration of the loop, we check if we landed on a mob. If so, we "
"kill it and bounce."
msgstr ""
"루프를 반복할 때마다 몹에 착지했는지 확인합니다. 그렇다면 몹을 죽이고 바운스"
"합니다."

msgid ""
"With this code, if no collisions occurred on a given frame, the loop won't "
"run."
msgstr ""
"이 코드를 사용하면 주어진 프레임에서 콜리전이 발생하지 않으면 루프가 실행되"
"지 않습니다."

msgid "That's a lot of new functions. Here's some more information about them."
msgstr ""
"아무 많은 새로운 기능들이 있습니다. 다음은 여기에 관한 추가적인 정보들입니다."

msgid ""
"The functions ``get_slide_collision_count()`` and ``get_slide_collision()`` "
"both come from the :ref:`CharacterBody3D <class_CharacterBody3D>` class and "
"are related to ``move_and_slide()``."
msgstr ""
"get_slide_collision_count()``와 ``get_slide_collision()`` 함수는 모"
"두 :ref:`CharacterBody3D <class_CharacterBody3D>` 클래스에서 제공되며 "
"``move_and_slide()``와 관련되어 있습니다."

msgid ""
"To check that we are landing on the monster, we use the vector dot product: "
"``Vector3.UP.dot(collision.get_normal()) > 0.1``. The collision normal is a "
"3D vector that is perpendicular to the plane where the collision occurred. "
"The dot product allows us to compare it to the up direction."
msgstr ""
"우리가 괴물 위에 착륙하는 것을 확인하려면, 벡터 곱 연산을 사용합니다: "
"``Vector3.UP.dot (collision.get_normal) > 0.1``. 콜리전 법선은 콜리전이 발생"
"한 평면에 수직인 3D 벡터입니다. 곱 연산은 위 방향과 비교를 할 수 있게 합니다."

msgid ""
"With dot products, when the result is greater than ``0``, the two vectors "
"are at an angle of fewer than 90 degrees. A value higher than ``0.1`` tells "
"us that we are roughly above the monster."
msgstr ""
"곱 연산의 결과가 ``0``보다 크다면 두 벡터는 90도보다 작다는 것 입니다. 따라"
"서 값이``0.1``보다 크다는 것은 대충 우리가 괴물의 위에 있다는 것을 말해줍니"
"다."

msgid ""
"When using C#, Godot will create the appropriate events automatically for "
"all Signals ending with `EventHandler`, see :ref:`C# Signals "
"<doc_c_sharp_signals>`."
msgstr ""
"C#을 사용할 때 Godot는 `EventHandler`\\ 로 모든 시그널을 끝내기 위해 자동으"
"로 적절한 이벤트를 생성합니다. :ref:`C# 시그널 <doc_c_sharp_signals>`\\ 을 참"
"조하세요."
