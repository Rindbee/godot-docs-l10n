#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr ""
"이제 코딩할 시간입니다! 이전 부분에서 만든 입력 동작을 사용하여 캐릭터를 이동"
"시키겠습니다."

msgid "For this project, we will be following the Godot naming conventions."
msgstr "이 프로젝트에서, 우리는 Godot의 명명 규칙을 따를 것입니다."

msgid ""
"**GDScript**: Classes (nodes) use PascalCase, variables and functions use "
"snake_case, and constants use ALL_CAPS (See :ref:`doc_gdscript_styleguide`)."
msgstr ""
"**GDScript**: 클래스(노드)는 파스칼 표기법(PascalCase)을 사용하고, 변수와 함"
"수는 스네이크_표기법(snake_case)을 사용하며, 상수는 전부 대문자(ALL_CAPS)를 "
"사용합니다(:ref:`doc_gdscript_styleguide` 참조)."

msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button. We set it to *Empty* because we want to write our own "
"code for player movement."
msgstr ""
"``Player`` 노드를 마우스 오른쪽 버튼으로 클릭하고 *Attach Script* 를 선택하"
"여 새 스크립트를 추가합니다. 팝업에서 *Template* 을 *Empty* 로 설정한 후 "
"*Create* 버튼을 누릅니다. 이는 플레이어 이동을 위한 코드를 직접 작성하고자 하"
"기 때문입니다."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"먼저 클래스의 속성부터 시작하겠습니다. 이동 속도, 중력을 나타내는 낙하 가속"
"도, 그리고 캐릭터를 이동시키기 위해 사용할 속도를 정의하겠습니다."

msgid ""
"These are common properties for a moving body. The ``target_velocity`` is a :"
"ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, we "
"define it as a property because we want to update and reuse its value across "
"frames."
msgstr ""
"이것들은 이동하는 객체에 대한 일반적인 속성입니다. ``target_velocity`` 는 속"
"도와 방향을 결합한 :ref:`3D 벡터 <class_Vector3>`입니다. 여기에서는 프레임마"
"다 값을 업데이트하고 재사용하기 위해 속성으로 정의합니다."

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"값은 2D 코드와 상당히 다릅니다. 이는 거리가 미터 단위로 측정되기 때문입니다. "
"2D에서는 천 단위(픽셀)가 화면 너비의 절반에 불과할 수 있지만, 3D에서는 이는 1"
"킬로미터에 해당합니다."

msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"이제 이동 코드를 작성해보겠습니다. 먼저 글로벌 ``Input`` 객체를 사용하여 "
"``_physics_process()`` 에서 입력 방향 벡터를 계산합니다."

msgid ""
"Here, we're going to make all calculations using the ``_physics_process()`` "
"virtual function. Like ``_process()``, it allows you to update the node "
"every frame, but it's designed specifically for physics-related code like "
"moving a kinematic or rigid body."
msgstr ""
"여기서는 모든 계산을 ``_physics_process()`` 가상 함수를 사용하여 수행할 것입"
"니다. 이 함수는 ``_process()`` 와 마찬가지로 매 프레임마다 노드를 업데이트할 "
"수 있게 해주지만, 주로 운동체나 리지드 바디와 같은 물리 관련 코드를 처리하도"
"록 설계되었습니다."

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"``_process()`` 와 ``_physics_process()`` 의 차이점에 대해 자세히 알아보려면 :"
"ref:`doc_idle_and_physics_processing`를 참조하세요."

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"먼저 ``Vector3.ZERO`` 로 초기화된 ``direction`` 변수를 설정합니다. 그런 다"
"음, 플레이어가 하나 이상의 ``move_*`` 입력을 누르고 있는지 확인하고 벡터의 "
"``x`` 및 ``z`` 구성 요소를 적절히 업데이트합니다. 이 구성 요소들은 지면 평면"
"의 축에 해당합니다."

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr ""
"이 네 가지 조건은 여덟 가지 가능성과 여덟 가지 가능한 방향을 제공합니다."

msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"플레이어가 W와 D를 동시에 누를 경우, 벡터의 길이는 약 ``1.4`` 가 됩니다. 하지"
"만 단일 키를 누를 경우, 길이는 ``1`` 이 됩니다. 우리는 벡터의 길이가 일관되도"
"록 하여 대각선으로 이동할 때 더 빨리 움직이지 않도록 하고 싶습니다. 이를 위"
"해 ``normalized()`` 메서드를 호출할 수 있습니다."

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"여기서 우리는 벡터의 길이가 0보다 클 때만 벡터를 정규화합니다. 이는 플레이어"
"가 방향 키를 누르고 있음을 의미합니다."

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""
"우리는 ``direction`` 방향을 바라보는 :ref:`Basis <class_Basis>`를 생성하여 "
"``$Pivot`` 이 바라보는 방향을 계산합니다."

msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"그런 다음, 속도를 업데이트합니다. 지면 속도와 낙하 속도를 별도로 계산해야 합"
"니다. 방금 작성한 조건문 바깥에 있지만 ``_physics_process()`` 함수 내부에 해"
"당 줄이 있도록 한 탭을 뒤로 이동하는 것을 잊지 마세요."

msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"``CharacterBody3D.is_on_floor()`` 함수는 몸체가 이번 프레임에서 바닥과 충돌했"
"는지 여부를 반환합니다. 그래서 우리는 ``Player`` 가 공중에 있을 때만 중력을 "
"적용합니다."

msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"수직 속도의 경우, 매 프레임마다 델타 시간에 낙하 가속도를 곱하여 빼줍니다. "
"이 코드 줄은 캐릭터가 바닥에 있거나 바닥과 충돌하지 않는 한 매 프레임마다 캐"
"릭터가 떨어지게 만듭니다."

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"물리 엔진은 주어진 프레임 동안 움직임과 충돌이 발생할 때만 벽, 바닥 또는 다"
"른 물체와의 상호 작용을 감지할 수 있습니다. 우리는 이 속성을 나중에 점프를 코"
"딩할 때 사용할 것입니다."

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"마지막 줄에서 우리는 ``CharacterBody3D.move_and_slide()`` 를 호출합니다. 이 "
"메서드는 ``CharacterBody3D`` 클래스의 강력한 메서드로, 캐릭터를 부드럽게 이동"
"할 수 있게 해줍니다. 움직이는 도중에 벽에 부딪히면, 엔진이 그 충격을 부드럽"
"게 처리하려고 합니다. 이 메서드는 :ref:`CharacterBody3D "
"<class_CharacterBody3D>`의 기본 속성인 *velocity* 값을 사용합니다"

msgid "And that's all the code you need to move the character on the floor."
msgstr "이것이 캐릭터를 바닥에서 이동시키는 데 필요한 모든 코드입니다."

msgid "Testing our player's movement"
msgstr "플레이어의 움직임 테스트하기"

msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"플레이어를 테스트하기 위해 ``Main`` 씬에 배치하겠습니다. 이를 위해 플레이어"
"를 인스턴스화하고 카메라를 추가해야 합니다. 2D와 달리, 3D에서는 뷰포트에 카메"
"라가 어떤 것을 가리키지 않으면 아무것도 보이지 않습니다."

msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"``Player`` 씬을 저장하고 ``Main`` 씬을 엽니다. 이를 위해 편집기 상단의 "
"*Main* 탭을 클릭할 수 있습니다."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"씬을 이전에 닫았다면, *FileSystem* 도크로 이동하여 ``main.tscn``을 더블 클릭"
"하여 다시 엽니다."

msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"``Player`` 를 인스턴스화하려면 ``Main`` 노드를 마우스 오른쪽 버튼으로 클릭하"
"고 *Instantiate Child Scene* 을 선택합니다."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr ""
"팝업에서 ``player.tscn`` 을 더블 클릭합니다. 캐릭터가 뷰포트의 중앙에 나타나"
"야 합니다."

msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child node :ref:"
"`Camera3D <class_Camera3D>` to it. Your scene tree should look similar to "
"this."
msgstr ""
"다음으로 카메라를 추가하겠습니다. *Player*\\의 *Pivot* 을 만들었던 것처럼 기"
"본 리그를 생성할 것입니다. 다시 ``Main`` 노드를 마우스 오른쪽 버튼으로 클릭하"
"고 *Add Child Node* 를 선택합니다. 새로운 :ref:`Marker3D <class_Marker3D>`를 "
"생성하고 이름을 ``CameraPivot`` 으로 지정합니다. ``CameraPivot`` 을 선택하고 "
"자식 노드로 :ref:`Camera3D <class_Camera3D>`를 추가합니다. 씬 트리는 다음과 "
"유사하게 보여야 합니다."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left of the 3D view "
"when you have the *Camera* selected. You can click it to preview the in-game "
"camera projection."
msgstr ""
"*Camera* 를 선택했을 때 3D 뷰의 왼쪽 상단에 나타나는 *Preview* 체크박스를 확"
"인하세요. 클릭하면 게임 내 카메라 투영을 미리 볼 수 있습니다."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"우리는 *Pivot*을 사용하여 카메라를 마치 크레인에 있는 것처럼 회전시킬 것입니"
"다. 먼저 3D 뷰를 분할하여 장면을 자유롭게 탐색하고 카메라가 보는 것을 볼 수 "
"있도록 하겠습니다."

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"뷰포트 바로 위의 툴바에서 *View* 를 클릭한 다음 *2 Viewports* 를 선택합니다. "
"macOS에서는 :kbd:`Cmd + 2`, Windows 및 Linux에서는 :kbd:`Ctrl + 2`를 누를 수"
"도 있습니다."

msgid "|image11|"
msgstr "|image11|"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"하단 뷰에서 :ref:`Camera3D <class_Camera3D>`를 선택하고 체크박스를 클릭하여 "
"카메라 Preview를 켭니다."

msgid ""
"In the top view, make sure your *Camera3D* is selected and move the camera "
"about ``19`` units on the Z axis (drag the blue arrow)."
msgstr ""
"상단 뷰에서 *Camera3D* 가 선택되어 있는지 확인하고, Z축을 따라 카메라를 약 "
"``19`` 단위만큼 이동시킵니다(파란색 화살표를 드래그)."

msgid "|image7|"
msgstr "|image7|"

msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"이제 마법이 일어나는 순간입니다. *CameraPivot* 을 선택하고 X축을 기준으로 "
"``-45`` 도 회전시킵니다(빨간색 원을 사용). 그러면 카메라가 마치 크레인에 부착"
"된 것처럼 움직이는 것을 볼 수 있습니다."

msgid "|image8|"
msgstr "|image8|"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr ""
"씬을 실행하려면 :kbd:`F6` 키를 누르고, 화살표 키를 눌러 캐릭터를 이동시킬 수 "
"있습니다."

msgid "|image9|"
msgstr "|image9|"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"원근 투영으로 인해 캐릭터 주변에 빈 공간이 보입니다. 이 게임에서는 게임 플레"
"이 영역을 더 잘 구성하고 플레이어가 거리를 읽기 쉽게 하기 위해 정사영"
"(Orthographic) 투영을 사용할 것입니다."

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"다시 *Camera*를 선택하고 *Inspector*에서 *Projection*을 *Orthogonal*로 설정하"
"고 *Size*를 ``19``로 설정합니다. 이제 캐릭터가 더 평평하게 보이고 지면이 배경"
"을 채우게 됩니다."

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""
"Godot 4에서 직교 카메라를 사용할 때 방향성 그림자 품질은 카메라의 *Far* 값에 "
"따라 달라집니다. *Far* 값이 높을수록 카메라가 더 멀리 볼 수 있습니다. 그러나 "
"*Far* 값이 높을수록 섀도 렌더링이 더 먼 거리를 커버해야 하므로 그림자 품질도 "
"떨어집니다."

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""
"직교 카메라로 전환한 후 방향 그림자가 너무 흐릿하게 보이면 카메라의 *Far* 속"
"성을 ``100`` 과 같이 낮은 값으로 줄이세요. 이 *Far* 속성을 너무 많이 낮추면 "
"멀리 있는 물체가 사라지기 시작합니다."

msgid "|image10|"
msgstr "|image10|"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""
"씬을 테스트하면 8방향으로 모두 움직일 수 있어야 하며 바닥을 통과할 때 끊김 현"
"상이 없어야 합니다!"

msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr ""
"궁극적으로 플레이어의 움직임과 시야를 모두 확보했습니다. 다음으로 몬스터에 대"
"한 작업을 진행하겠습니다."
