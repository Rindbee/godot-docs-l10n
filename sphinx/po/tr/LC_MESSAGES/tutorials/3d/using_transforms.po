#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using 3D transforms"
msgstr "3B dönüştürmeleri kullanmak"

msgid "Introduction"
msgstr "Giriş"

msgid ""
"If you have never made 3D games before, working with rotations in three "
"dimensions can be confusing at first. Coming from 2D, the natural way of "
"thinking is along the lines of *\"Oh, it's just like rotating in 2D, except "
"now rotations happen in X, Y and Z\"*."
msgstr ""
"Eğer daha önce hiç 3B oyun yapmadıysanız, üç boyutlu ortamda döndürme işlemi "
"yapmak başlangıçta kafa karıştırıcı olabilir. 2B'den geliyorsanız, doğal "
"olarak \"Aa, bu bildiğin 2B'deki döndürme işlemine benziyor, ama şimdi "
"döndürmeler X, Y ve Z eksenlerinde gerçekleşiyor\" diye düşünebilirsiniz."

msgid ""
"At first, this seems easy. For simple games, this way of thinking may even "
"be enough. Unfortunately, it's often incorrect."
msgstr ""
"Başlangıçta bu kolay görünebilir. Basit oyunlar için bu şekilde düşünmek "
"yeterli de olabilir. Ne yazık ki, bu genellikle doğru değildir."

msgid ""
"Angles in three dimensions are most commonly referred to as \"Euler Angles\"."
msgstr "Üç boyuttaki açılar genellikle \"Euler Açıları\" olarak adlandırılır."

msgid ""
"Euler angles were introduced by mathematician Leonhard Euler in the early "
"1700s."
msgstr ""
"Euler açıları, 1700'lerin başlarında matematikçi Leonhard Euler tarafından "
"tanıtılmıştır."

msgid ""
"This way of representing 3D rotations was groundbreaking at the time, but it "
"has several shortcomings when used in game development (which is to be "
"expected from a guy with a funny hat). The idea of this document is to "
"explain why, as well as outlining best practices for dealing with transforms "
"when programming 3D games."
msgstr ""
"3B dönmeleri temsil etmenin bu yolu o zamanlar çığır açıcıydı, ancak oyun "
"geliştirmede kullanıldığında bazı eksiklikleri vardır (komik şapkalı bir "
"adamdan da bu beklenirdi). Bu belgenin amacı, 3B oyunları programlarken "
"dönüştürmelerle başa çıkmak için en iyi uygulamaların ana hatlarını çizmenin "
"yanı sıra bunun nedenini açıklamaktır."

msgid "Problems of Euler angles"
msgstr "Euler açılarındaki sorunlar"

msgid ""
"While it may seem intuitive that each axis has a rotation, the truth is that "
"it's just not practical."
msgstr ""
"Her eksenin bir dönüşe sahip olması sezgisel görünse de, gerçek şu ki bu "
"pratik değildir."

msgid "Axis order"
msgstr "Eksen sırası"

msgid ""
"The main reason for this is that there isn't a *unique* way to construct an "
"orientation from the angles. There isn't a standard mathematical function "
"that takes all the angles together and produces an actual 3D rotation. The "
"only way an orientation can be produced from angles is to rotate the object "
"angle by angle, in an *arbitrary order*."
msgstr ""
"Bunun ana nedeni, açıları kullanıp bir yönelim oluşturmanın *benzersiz* bir "
"yolunun olmamasıdır. Tüm açıları bir araya getiren ve gerçek bir 3B dönme "
"üreten standart bir matematiksel fonksiyon yoktur. Açılardan bir yönelim "
"üretilebilmesinin tek yolu, nesneyi *keyfi bir sırayla* açıdan açıya "
"döndürmektir."

msgid ""
"This could be done by first rotating in *X*, then *Y* and then in *Z*. "
"Alternatively, you could first rotate in *Y*, then in *Z* and finally in "
"*X*. Anything works, but depending on the order, the final orientation of "
"the object will *not necessarily be the same*. Indeed, this means that there "
"are several ways to construct an orientation from 3 different angles, "
"depending on *the order of the rotations*."
msgstr ""
"Bu, önce *X*, sonra *Y* ve ardından *Z* yönünde döndürülerek yapılabilir. "
"Alternatif olarak, önce *Y*, sonra *Z* ve son olarak *X* yönünde "
"döndürebilirsiniz. Her türlü işe yarar, ancak sıraya bağlı olarak, nesnenin "
"sonuçtaki yönelimi *mutlak aynı olmayacaktır*. Aslında bu, *dönüşlerin "
"sırasına* bağlı olarak 3 farklı açıdan bir yönelim oluşturmanın birçok yolu "
"olduğu anlamına gelir."

msgid ""
"Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal "
"(from Wikipedia). As you can see, the orientation of each axis depends on "
"the rotation of the previous one:"
msgstr ""
"Aşağıda bir yalpa çemberinde dönme eksenlerinin (X, Y, Z sırasına göre) "
"görselleştirmesi yer almaktadır (Wikipedia'dan). Gördüğünüz gibi, her "
"eksenin yönelimi bir öncekinin dönüşüne bağlıdır:"

msgid ""
"You may be wondering how this affects you. Let's look at a practical example:"
msgstr ""
"Bunun sizi nasıl etkilediğini merak ediyor olabilirsiniz. Pratik bir örneğe "
"bakalım:"

msgid ""
"Imagine you are working on a first-person controller (e.g. an FPS game). "
"Moving the mouse left and right controls your view angle parallel to the "
"ground, while moving it up and down moves the player's view up and down."
msgstr ""
"Birinci-şahıs kumandası üzerinde çalıştığınızı düşünün (örneğin bir FPS "
"oyunu). Fareyi sola ve sağa hareket ettirmek görüş açınızı yere paralel "
"olarak kontrol ederken, yukarı ve aşağı hareket ettirmek oyuncunun görüşünü "
"yukarı ve aşağı hareket ettirir."

msgid ""
"In this case to achieve the desired effect, rotation must be applied first "
"in the *Y* axis (\"up\" in this case, since Godot uses a \"Y-Up\" "
"orientation), followed by rotation in the *X* axis."
msgstr ""
"Bu durumda istenen etkiyi elde etmek için, döndürmeyi önce *Y* ekseninde "
"(Godot \"Y-Yukarı\" yönelimini kullandığından bu durumda \"yukarı\") "
"uygulamalı, ardından *X* ekseninde döndürme yapılmalıdır."

msgid ""
"If we were to apply rotation in the *X* axis first, and then in *Y*, the "
"effect would be undesired:"
msgstr ""
"Döndürmeyi önce *X* ekseninde, sonra da *Y* ekseninde uygulasaydık, "
"istenmeyen bir etki ortaya çıkardı:"

msgid ""
"Depending on the type of game or effect desired, the order in which you want "
"axis rotations to be applied may differ. Therefore, applying rotations in X, "
"Y, and Z is not enough: you also need a *rotation order*."
msgstr ""
"İstenen oyun veya efekt türüne bağlı olarak, eksen dönüşlerinin "
"uygulanmasını istediğiniz sıra farklılık gösterebilir. Bu nedenle, X, Y ve "
"Z'de dönüşler uygulamak yeterli değildir: bir *dönüş sırasına* da "
"ihtiyacınız vardır."

msgid "Interpolation"
msgstr "Ara Değerleme"

msgid ""
"Another problem with using Euler angles is interpolation. Imagine you want "
"to transition between two different camera or enemy positions (including "
"rotations). One logical way to approach this is to interpolate the angles "
"from one position to the next. One would expect it to look like this:"
msgstr ""
"Euler açılarının kullanılmasıyla ilgili bir başka sorun da ara değerlemedir. "
"İki farklı kamera veya düşman konumu (dönüşler dahil) arasında geçiş yapmak "
"istediğinizi düşünün. Buna yaklaşmanın mantıklı bir yolu, açıları bir "
"konumdan diğerine ara değerleme yapmaktır. Şöyle görünmesi beklenir:"

msgid "But this does not always have the expected effect when using angles:"
msgstr "Ancak bu, açıları kullanırken her zaman beklenen etkiyi yaratmaz:"

msgid "The camera actually rotated the opposite direction!"
msgstr "Kamera aslında ters yöne döndü!"

msgid "There are a few reasons this may happen:"
msgstr "Bunun birkaç nedeni olabilir:"

msgid ""
"Rotations don't map linearly to orientation, so interpolating them does not "
"always result in the shortest path (i.e., to go from ``270`` to ``0`` "
"degrees is not the same as going from ``270`` to ``360``, even though the "
"angles are equivalent)."
msgstr ""
"Dönüşler, yönelim ile doğrusal olarak eşleşmez, bu nedenle bunların ara "
"değerlenmesi her zaman en kısa yolla sonuçlanmaz (yani, açılar eşdeğer olsa "
"bile ``270`` dereceden ``0`` dereceye gitmek ``270`` dereceden ``360`` "
"dereceye gitmekle aynı şey değildir)."

msgid ""
"Gimbal lock is at play (first and last rotated axis align, so a degree of "
"freedom is lost). See `Wikipedia's page on Gimbal Lock <https://en.wikipedia."
"org/wiki/Gimbal_lock>`_ for a detailed explanation of this problem."
msgstr ""
"Yalpa çemberi kilidi söz konusudur (ilk ve son döndürülen eksenler "
"hizalanır, bu nedenle bir serbestlik derecesi kaybolur). Bu sorunun "
"ayrıntılı bir açıklaması için `Wikipedia'daki Gimbal Lock Sayfası <https://"
"en.wikipedia.org/wiki/Gimbal_lock>`_ 'na bakın."

msgid "Say no to Euler angles"
msgstr "Euler açılarına hayır deyin"

msgid ""
"The result of all this is that you should **not use** the ``rotation`` "
"property of :ref:`class_Node3D` nodes in Godot for games. It's there to be "
"used mainly in the editor, for coherence with the 2D engine, and for simple "
"rotations (generally just one axis, or even two in limited cases). As much "
"as you may be tempted, don't use it."
msgstr ""
"Tüm bunların sonucu olarak, oyunlar için Godot'daki :ref:`class_Node3D` "
"düğümlerinin ``rotation`` özelliğini **kullanmamanız** gerekir. Bu özellik "
"esas olarak düzenleyicide, 2B motorla uyumluluk için, ve basit döndürmeler "
"için (genellikle sadece bir eksen, hatta sınırlı durumlarda iki eksen) "
"kullanılmak üzere vardır. Her ne kadar cazip gelse de, kullanmayın."

msgid "Instead, there is a better way to solve your rotation problems."
msgstr "Bunun yerine, döndürme sorunlarınızı çözmenin daha iyi bir yolu var."

msgid "Introducing transforms"
msgstr "Dönüşümlerle tanışalım"

msgid ""
"Godot uses the :ref:`class_Transform3D` datatype for orientations. Each :ref:"
"`class_Node3D` node contains a ``transform`` property which is relative to "
"the parent's transform, if the parent is a Node3D-derived type."
msgstr ""
"Godot yönelimler için :ref:`class_Transform3D` veri tipini kullanır. Her :"
"ref:`class_Node3D` düğümü, eğer üst öge bir Node3D türevi bir tip ise üst "
"ögenin dönüşümüne göreceli olan bir ``transform`` özelliği içerir."

msgid ""
"It is also possible to access the world coordinate transform via the "
"``global_transform`` property."
msgstr ""
"Dünya koordinat dönüşümüne ``global_transform`` özelliği aracılığıyla "
"erişmek de mümkündür."

msgid ""
"A transform has a :ref:`class_Basis` (transform.basis sub-property), which "
"consists of three :ref:`class_Vector3` vectors. These are accessed via the "
"``transform.basis`` property and can be accessed directly by ``transform."
"basis.x``, ``transform.basis.y``, and ``transform.basis.z``. Each vector "
"points in the direction its axis has been rotated, so they effectively "
"describe the node's total rotation. The scale (as long as it's uniform) can "
"also be inferred from the length of the axes. A *basis* can also be "
"interpreted as a 3x3 matrix and used as ``transform.basis[x][y]``."
msgstr ""
"Bir dönüşümün üç :ref:`class_Vector3` vektöründen oluşan bir :ref:"
"`class_Basis` temeli (baz)(transform.basis alt-özelliği) vardır. Bunlara "
"``transform.basis`` özelliği aracılığıyla erişilir ve ``transform.basis.x``, "
"``transform.basis.y`` ve ``transform.basis.z`` ile doğrudan erişilebilir. "
"Her vektör kendi ekseninin döndürüldüğü yönü işaret eder, bu nedenle etkin "
"olarak düğümün toplam dönüşünü tanımlarlar. Ölçek (düzenli olduğu sürece) "
"eksenlerin uzunluğundan da çıkarılabilir. Bir *basis*, 3x3'lük bir matris "
"olarak da yorumlanabilir ve ``transform. basis[x][y]`` şeklinde "
"kullanılabilir."

msgid "A default basis (unmodified) is akin to:"
msgstr "Varsayılan baz (değiştirilmemiş) şuna benzer:"

msgid "This is also an analog of a 3x3 identity matrix."
msgstr "Bu örnek aynı zamanda bir 3x3 birim matrisinin benzeridir."

msgid ""
"Following the OpenGL convention, ``X`` is the *Right* axis, ``Y`` is the "
"*Up* axis and ``Z`` is the *Forward* axis."
msgstr ""
"OpenGL kuralına göre, ``X`` *Sağ* ekseni, ``Y`` *Yukarı* ekseni ve ``Z`` "
"*İleri* ekseni gösterir."

msgid ""
"Together with the *basis*, a transform also has an *origin*. This is a "
"*Vector3* specifying how far away from the actual origin ``(0, 0, 0)`` this "
"transform is. Combining the *basis* with the *origin*, a *transform* "
"efficiently represents a unique translation, rotation, and scale in space."
msgstr ""
"*basis* bazı ile birlikte, bir dönüşümün bir de *origin* özelliği vardır. "
"Bu, bu dönüşümün gerçek sıfır merkezinden, ``(0, 0, 0)``, ne kadar uzakta "
"olduğunu belirten bir *Vector3* vektörüdür. *basis* ile *origin* bir araya "
"gelince, bir *dönüşüm*, uzayda benzersiz bir öteleme, döndürme ve "
"ölçeklemeyi etkili bir şekilde temsil eder."

msgid ""
"One way to visualize a transform is to look at an object's 3D gizmo while in "
"\"local space\" mode."
msgstr ""
"Bir dönüşümü görselleştirmenin bir yolu, \"yerel uzay\" modundayken bir "
"nesnenin 3B aletini kullanmaktır."

msgid ""
"The gizmo's arrows show the ``X``, ``Y``, and ``Z`` axes (in red, green, and "
"blue respectively) of the basis, while the gizmo's center is at the object's "
"origin."
msgstr ""
"Aletin okları ``X``, ``Y`` ve ``Z`` baz eksenlerini (sırasıyla kırmızı, "
"yeşil ve mavi) gösterirken, aletin merkezi nesnenin merkez noktası "
"üzerindedir."

msgid ""
"For more information on the mathematics of vectors and transforms, please "
"read the :ref:`doc_vector_math` tutorials."
msgstr ""
"Vektörlerin ve dönüşümlerin matematiği hakkında daha fazla bilgi için "
"lütfen :ref:`doc_vector_math` eğitimlerini okuyun."

msgid "Manipulating transforms"
msgstr "Dönüşümleri değiştirmek"

msgid ""
"Of course, transforms are not as straightforward to manipulate as angles and "
"have problems of their own."
msgstr ""
"Elbette, dönüşümlerin değiştirilmesi açılar kadar kolay değildir ve "
"kendilerine has sorunları vardır."

msgid ""
"It is possible to rotate a transform, either by multiplying its basis by "
"another (this is called accumulation), or by using the rotation methods."
msgstr ""
"Bir dönüşümü, ya bazını başka bir baz ile çarparak (buna biriktirme denir) "
"ya da döndürme yöntemlerini kullanarak döndürmek mümkündür."

msgid "A method in Node3D simplifies this:"
msgstr "Node3D'deki bir yöntem bunu basitleştirir:"

msgid "This rotates the node relative to the parent node."
msgstr "Bu, düğümü üst düğüme göre döndürür."

msgid ""
"To rotate relative to object space (the node's own transform), use the "
"following:"
msgstr ""
"Nesne uzayına (düğümün kendi dönüşümü) göre döndürmek için aşağıdakileri "
"kullanın:"

msgid "Precision errors"
msgstr "Kesinlik hataları"

msgid ""
"Doing successive operations on transforms will result in a loss of precision "
"due to floating-point error. This means the scale of each axis may no longer "
"be exactly ``1.0``, and they may not be exactly ``90`` degrees from each "
"other."
msgstr ""
"Dönüşümler üzerinde art arda işlemler yapmak, ondalık sayılardaki kayan-"
"nokta hatası nedeniyle hassasiyet kaybına neden olacaktır. Bu, her eksenin "
"ölçeğinin artık tam olarak ``1.0`` olmayabileceği ve birbirlerinden tam "
"olarak ``90`` derece uzakta olamayabilecekleri anlamına gelir."

msgid ""
"If a transform is rotated every frame, it will eventually start deforming "
"over time. This is unavoidable."
msgstr ""
"Bir dönüşüm her karede döndürülürse, zaman içinde bozulmaya başlayacaktır. "
"Bu kaçınılmazdır."

msgid ""
"There are two different ways to handle this. The first is to "
"*orthonormalize* the transform after some time (maybe once per frame if you "
"modify it every frame):"
msgstr ""
"Bunu ele almanın iki farklı yolu vardır. Birincisi, dönüşümü bir süre sonra "
"*orto-normalize etmektir* (her karede değiştiriyorsanız belki kare başına "
"bir kez):"

msgid ""
"This will make all axes have ``1.0`` length again and be ``90`` degrees from "
"each other. However, any scale applied to the transform will be lost."
msgstr ""
"Bu, tüm eksenlerin tekrar ``1.0`` uzunluğa sahip olmasını ve birbirlerinden "
"``90`` derece uzakta olmasını sağlayacaktır. Ancak, dönüşüme uygulanan "
"herhangi bir ölçek kaybolacaktır."

msgid ""
"It is recommended you not scale nodes that are going to be manipulated; "
"scale their children nodes instead (such as MeshInstance3D). If you "
"absolutely must scale the node, then re-apply it at the end:"
msgstr ""
"Değiştirilecek düğümleri ölçeklendirmemeniz önerilir; bunun yerine alt "
"düğümlerini ölçeklendirin (MeshInstance3D gibi). Düğümü mutlaka "
"ölçeklendirmeniz gerekiyorsa, bunu işlem sonunda yeniden uygulayın:"

msgid "Obtaining information"
msgstr "Bilgi edinme"

msgid ""
"You might be thinking at this point: **\"Ok, but how do I get angles from a "
"transform?\"**. The answer again is: you don't. You must do your best to "
"stop thinking in angles."
msgstr ""
"Bu noktada şöyle düşünüyor olabilirsiniz: **\"Tamam, ama bir dönüşümün "
"açılarını geri nasıl elde edebilirim? \"**. Cevap yine şu: alamazsınız. "
"Açılarla düşünmeyi bırakmak için elinizden geleni yapmalısınız."

msgid ""
"Imagine you need to shoot a bullet in the direction your player is facing. "
"Just use the forward axis (commonly ``Z`` or ``-Z``)."
msgstr ""
"Oyuncunuzun baktığı yöne doğru bir mermi ateşlemeniz gerektiğini düşünün. "
"Sadece ileri ekseni kullanın (genellikle ``Z`` veya ``-Z``)."

msgid ""
"Is the enemy looking at the player? Use the dot product for this (see the :"
"ref:`doc_vector_math` tutorial for an explanation of the dot product):"
msgstr ""
"Düşman oyuncuya doğru bakıyor mu? Bunun için nokta çarpımını kullanın (nokta "
"çarpımının açıklaması için :ref:`doc_vector_math` eğitimine bakın):"

msgid "Strafe left:"
msgstr "Sol yana kaydır:"

msgid "Jump:"
msgstr "Zıpla:"

msgid "All common behaviors and logic can be done with just vectors."
msgstr "Tüm yaygın davranışlar ve mantık sadece vektörlerle yapılabilir."

msgid "Setting information"
msgstr "Bilgileri ayarlama"

msgid ""
"There are, of course, cases where you want to set information to a "
"transform. Imagine a first person controller or orbiting camera. Those are "
"definitely done using angles, because you *do want* the transforms to happen "
"in a specific order."
msgstr ""
"Elbette, bir dönüşümün bilgilerini ayarlamak istediğiniz durumlar vardır. "
"Birinci şahıs denetleyici veya bir yörünge kamerası düşünün. Bunlar "
"kesinlikle açılar kullanılarak yapılır, çünkü dönüşümlerin belirli bir "
"sırada gerçekleşmesini *istersiniz*."

msgid ""
"For such cases, keep the angles and rotations *outside* the transform and "
"set them every frame. Don't try to retrieve and reuse them because the "
"transform is not meant to be used this way."
msgstr ""
"Bu gibi durumlarda, açıları ve dönüşleri dönüşümün *dışında* tutun ve "
"bunları her karede ayarlayın. Dönüşüm bu şekilde kullanılmak üzere "
"tasarlanmadığı için bunları geri almaya ve yeniden kullanmaya çalışmayın."

msgid "Example of looking around, FPS style:"
msgstr "Etrafa bakınma örneği, FPS tarzı:"

msgid ""
"As you can see, in such cases it's even simpler to keep the rotation "
"outside, then use the transform as the *final* orientation."
msgstr ""
"Gördüğünüz gibi, bu gibi durumlarda dönmeyi dışarıda tutmak, ve ardından "
"dönüşümü *son* yönelim olarak kullanmak daha da basittir."

msgid "Interpolating with quaternions"
msgstr "Kuaterniyonlarla ara değerleme yapma"

msgid ""
"Interpolating between two transforms can efficiently be done with "
"quaternions. More information about how quaternions work can be found in "
"other places around the Internet. For practical use, it's enough to "
"understand that pretty much their main use is doing a closest path "
"interpolation. As in, if you have two rotations, a quaternion will smoothly "
"allow interpolation between them using the closest axis."
msgstr ""
"İki dönüşüm arasında ara değerleme yapmak kuaterniyonlarla verimli bir "
"şekilde yapılabilir. Kuaterniyonların (quaternion) nasıl çalıştığı hakkında "
"daha fazla bilgi internette başka yerlerde bulunabilir. Pratik kullanım "
"için, ana kullanımlarının hemen hemen en yakın yol ara değerlemesi yapmak "
"olduğunu anlamak yeterlidir. Yani, iki dönüşünüz varsa, bir kuaterniyon en "
"yakın ekseni kullanarak aralarında düzgün bir şekilde ara değerlemeye izin "
"verecektir."

msgid "Converting a rotation to quaternion is straightforward."
msgstr "Bir dönmeyi kuaterniyona dönüştürmek basittir."

msgid ""
"The :ref:`class_Quaternion` type reference has more information on the "
"datatype (it can also do transform accumulation, transform points, etc., "
"though this is used less often). If you interpolate or apply operations to "
"quaternions many times, keep in mind they need to be eventually normalized. "
"Otherwise, they will also suffer from numerical precision errors."
msgstr ""
":ref:`class_Quaternion` tip başvurusu, veri tipi hakkında daha fazla bilgi "
"içerir (daha az sıklıkta kullanılmasına rağmen dönüşüm birikimi, dönüşüm "
"noktaları vb. de yapabilir). Kuaterniyonlara birçok kez ara değerleme yapar "
"veya üzerinde işlem uygularsanız, eninde sonunda normalize edilmeleri "
"gerektiğini unutmayın. Aksi takdirde, sayısal kesinlik hatalarından onlar da "
"muzdarip olacaklardır."

msgid ""
"Quaternions are useful when doing camera/path/etc. interpolations, as the "
"result will always be correct and smooth."
msgstr ""
"Kuaterniyonlar, sonuç her zaman doğru ve pürüzsüz olacağından, kamera/yol/"
"vb. ara değerlemeleri yaparken kullanışlıdır."

msgid "Transforms are your friend"
msgstr "Dönüşümler arkadaşınızdır"

msgid ""
"For most beginners, getting used to working with transforms can take some "
"time. However, once you get used to them, you will appreciate their "
"simplicity and power."
msgstr ""
"Yeni başlayanların çoğu için dönüşümlerle çalışmaya alışmak biraz zaman "
"alabilir. Ancak, bir kez alıştığınızda, basitliklerini ve güçlerini takdir "
"edeceksiniz."

msgid ""
"Don't hesitate to ask for help on this topic in any of Godot's `online "
"communities <https://godotengine.org/community>`_ and, once you become "
"confident enough, please help others!"
msgstr ""
"Godot'nun `çevrimiçi topluluklarından <https://godotengine.org/community>`_ "
"herhangi birinde bu konuda yardım istemekten çekinmeyin ve kendinize "
"yeterince güvendiğinizde lütfen başkalarına da yardım edin!"
