#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"Se recomienda utilizar formas de colisión físicas simples en lugar de mallas "
"visuales como geometría fuente para el precalculado de mallas de navegación. "
"Las formas físicas son, por defecto, formas muy limitadas y optimizadas que "
"son fáciles y rápidas de analizar. Por otro lado, una malla visual puede "
"variar de simple a compleja. Además, para acceder a los datos de la malla "
"visual, el analizador necesita solicitar los arreglos de datos de malla al "
"Servidor de Renderizado, ya que los datos de la malla visual se almacenan "
"directamente en la GPU y no se almacenan en caché en la CPU. Esto requiere "
"bloquear el hilo del Servidor de Renderizado y puede afectar severamente la "
"tasa de cuadros en tiempo de ejecución mientras el renderizado se ejecuta en "
"múltiples hilos. Si el renderizado se ejecuta en un solo hilo, el impacto en "
"la tasa de cuadros puede ser aún peor y el análisis de la malla puede "
"congelar el juego completo durante unos segundos en mallas complejas."

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake "
"(e.g. because they require no distance field pass)."
msgstr ""
"La complejidad de los datos de geometría fuente analizados desde los nodos "
"del árbol de escena tiene un gran impacto en el rendimiento del precálculo "
"(baking), ya que todo debe mapearse a una cuadrícula/voxeles. Para el "
"rendimiento del precálculo en tiempo de ejecución, el tamaño y la altura de "
"celda de NavigationMesh deben establecerse lo más altos posible sin causar "
"problemas de calidad en la malla de navegación para un juego. Si el tamaño o "
"la altura de celda se establecen demasiado bajos, el precálculo (baking) se "
"ve obligado a crear una cantidad excesiva de voxeles para procesar la "
"geometría fuente. Si la geometría fuente se extiende sobre un mundo de juego "
"muy grande, es incluso posible que el proceso de precálculo (baking) se "
"quede sin memoria en el proceso y bloquee el juego. El tipo de partición "
"también se puede reducir dependiendo de la complejidad de la geometría "
"fuente del juego para ganar algo de rendimiento. Por ejemplo, los juegos con "
"superficies principalmente planas y geometría en bloque pueden procesarse "
"con el modo monotono o de capas que son mucho más rápidos de precálcular "
"(porque no requieren un paso de campo de distancia, por ejemplo)."

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"Un problema común es una caída repentina del rendimiento cuando no se puede "
"alcanzar una posición de destino en una consulta de ruta. Esta caída del "
"rendimiento es \"normal\" y el resultado de una malla de navegación "
"demasiado grande y no optimizada, con demasiados polígonos y bordes para "
"buscar. En las búsquedas de ruta normales donde se puede alcanzar la "
"posición de destino rápidamente, la función de búsqueda de ruta realizará "
"una respuesta temprana tan pronto como se alcance la posición, lo que puede "
"ocultar esta falta de optimización por un tiempo. Si no se puede alcanzar la "
"posición de destino, la función de búsqueda de ruta tiene que hacer una "
"búsqueda mucho más larga a través de los polígonos disponibles para "
"confirmar que la posición es absolutamente inalcanzable."
