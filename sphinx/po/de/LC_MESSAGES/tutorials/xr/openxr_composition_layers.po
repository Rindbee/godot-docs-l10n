#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR composition layers"
msgstr "OpenXR-Kompositionsschichten"

msgid "Introduction"
msgstr "Einführung"

msgid ""
"In XR games you generally want to create user interactions that happen in 3D "
"space and involve users touching objects as if they are touching them in "
"real life."
msgstr ""
"In XR-Spielen möchte man in der Regel Benutzerinteraktionen schaffen, die im "
"3D-Raum stattfinden und bei denen die Benutzer Objekte so berühren, als ob "
"man sie im echten Leben berühren würde."

msgid ""
"Sometimes however creating a more traditional 2D interface is unavoidable. "
"In XR however you can't just add 2D components to your scene. Godot needs "
"depth information to properly position these elements so they appear at a "
"comfortable place for the user. Even with depth information there are "
"headsets with slanted displays that make it impossible for the standard 2D "
"pipeline to correctly render the 2D elements."
msgstr ""
"Manchmal ist es jedoch unvermeidlich, eine traditionellere 2D-"
"Benutzeroberfläche zu erstellen. In XR können Sie jedoch nicht einfach 2D-"
"Komponenten zu Ihrer Szene hinzufügen. Godot benötigt Tiefeninformationen, "
"um diese Elemente richtig zu positionieren, damit sie an einer für den "
"Benutzer angenehmen Stelle erscheinen. Selbst mit Tiefeninformationen gibt "
"es Headsets mit schrägen Displays, die es der Standard 2D-Pipeline unmöglich "
"machen, die 2D-Elemente korrekt zu rendern."

msgid ""
"The solution then is to render the UI to a :ref:`SubViewport "
"<class_subviewport>` and display the result of this using a :ref:"
"`ViewportTexture <class_viewporttexture>` on a 3D mesh. The :ref:`QuadMesh "
"<class_quadmesh>` is a suitable option for this."
msgstr ""
"Die Lösung ist dann, das UI in ein :ref:`SubViewport <class_subviewport>` zu "
"rendern und das Ergebnis mit einer :ref:`ViewportTexture "
"<class_viewporttexture>` auf einem 3D-Mesh darzustellen. Das :ref:`QuadMesh "
"<class_quadmesh>` ist hierfür eine geeignete Option."

msgid ""
"See the `GUI in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/gui_in_3d>`_ example project for an example of this approach."
msgstr ""
"Ein Beispiel für diesen Ansatz finden Sie im Beispielprojekt `GUI in 3D "
"<https://github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"gui_in_3d>`_\"."

msgid ""
"The problem with displaying the viewport in this way is that the rendered "
"result is sampled for lens distortion by the XR runtime and the resulting "
"quality loss can make UI text hard to read."
msgstr ""
"Das Problem bei der Anzeige des Viewports auf diese Weise ist, dass das "
"gerenderte Ergebnis von der XR Runtime für die Linsenverzerrung abgetastet "
"wird und der daraus resultierende Qualitätsverlust dazu führen kann, dass "
"der Text auf der Benutzeroberfläche schwer zu lesen ist."

msgid ""
"OpenXR offers a solution to this problem through composition layers. With "
"composition layers it is possible for the contents of a viewport to be "
"projected on a surface after lens distortion resulting in a much higher "
"quality end result."
msgstr ""
"OpenXR bietet mit Kompositionsebenen eine Lösung für dieses Problem. Mit "
"Kompositionsebenen ist es möglich, den Inhalt eines Viewports nach der "
"Linsenverzerrung auf eine Oberfläche zu projizieren, was zu einem wesentlich "
"hochwertigeren Endergebnis führt."

msgid ""
"As not all XR runtimes support all composition layer types, Godot implements "
"a fallback solution where we render the viewport as part of the normal scene "
"but with the aforementioned quality limitations."
msgstr ""
"Da nicht alle XR Runtimes alle Kompositionsebenen-Typen unterstützen, "
"implementiert Godot eine Fallback-Lösung, die den Viewport als Teil der "
"normalen Szene rendert, allerdings mit den oben genannten "
"Qualitätseinschränkungen."

msgid ""
"When the composition layer is supported, it is the XR runtime that presents "
"the subviewport. This means the UI is only visible in the headset, it will "
"not be accessible by Godot and will thus not be shown when you have a "
"spectator view on the desktop."
msgstr ""
"Wenn die Kompositionsebene unterstützt wird, ist es die XR Runtime, die das "
"Subviewport präsentiert. Das bedeutet, dass die Benutzeroberfläche nur im "
"Headset sichtbar ist. Sie ist für Godot nicht zugänglich und wird daher "
"nicht angezeigt, wenn Sie einen Zuschauer-View auf dem Desktop haben."

msgid "There are currently 3 nodes that expose this functionality:"
msgstr "Derzeit gibt es 3 Nodes, die diese Funktion anbieten:"

msgid ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a cylinder (or "
"\"slice\" of a cylinder)."
msgstr ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"zeigt den Inhalt des SubViewports auf der Innenseite eines Zylinders (oder "
"\"Slice\" eines Zylinders)."

msgid ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a sphere (or "
"\"slice\" of a sphere)."
msgstr ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"zeigt den Inhalt des SubViewports auf der Innenseite einer Kugel (oder "
"\"Scheibe\" einer Kugel)."

msgid ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a flat rectangle."
msgstr ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` zeigt "
"den Inhalt des SubViewports auf einem flachen Rechteck."

msgid "Setting up the SubViewport"
msgstr "Einrichten des SubViewports"

msgid ""
"The first step is adding a SubViewport for our 2D UI, this doesn't require "
"any specific steps. For our example we do mark the viewport as transparent."
msgstr ""
"Der erste Schritt ist das Hinzufügen eines SubViewports für unsere 2D-"
"Benutzeroberfläche, dies erfordert keine besonderen Schritte. Für unser "
"Beispiel markieren wir den Viewport als transparent."

msgid ""
"You can now create the 2D UI by adding child nodes to the SubViewport as you "
"normally would. It is advisable to save the 2D UI in a subscene, this makes "
"it easier to do your layout."
msgstr ""
"Sie können nun die 2D-Benutzeroberfläche erstellen, indem Sie dem "
"SubViewport Child-Nodes hinzufügen, wie Sie es normalerweise tun würden. Es "
"ist ratsam, die 2D-Benutzeroberfläche in einer Unterszene zu speichern, da "
"dies das Layout erleichtert."

msgid ""
"The update mode \"When Visible\" will not work as Godot can't determine "
"whether the viewport is visible to the user. When assigning our viewport to "
"a composition layer Godot will automatically adjust this."
msgstr ""
"Der Aktualisierungsmodus \"Wenn sichtbar\" wird nicht funktionieren, da "
"Godot nicht feststellen kann, ob der Viewport für den Benutzer sichtbar ist. "
"Wenn wir unseren Viewpoert einer Kompositionsebene zuweisen, wird Godot dies "
"automatisch anpassen."

msgid "Adding a composition layer"
msgstr "Hinzufügen einer Kompositionsebene"

msgid ""
"The second step is adding our composition layer. We simply add the correct "
"composition layer node as a child node of our :ref:`XROrigin3D "
"<class_xrorigin3d>` node. This is very important as the XR runtime positions "
"everything in relation to our origin."
msgstr ""
"Der zweite Schritt ist das Hinzufügen unserer Kompositionsebene. Wir fügen "
"einfach den richtigen Kompositionsebenen-Node als Child-Node unseres :ref:"
"`XROrigin3D <class_xrorigin3d>`-Nodes hinzu. Dies ist sehr wichtig, da die "
"XR Runtime alles im Verhältnis zu unserem Ursprung positioniert."

msgid ""
"We want to position the composition layer so it is at eye height and roughly "
"1 to 1.5 meters away from the player."
msgstr ""
"Wir wollen die Kompositionsebene so positionieren, dass sie sich auf "
"Augenhöhe und etwa 1 bis 1,5 Meter vom Spieler entfernt befindet."

msgid ""
"We now assign the SubViewport to the ``Layer Viewport`` property and enable "
"Alpha Blend."
msgstr ""
"Wir weisen nun den SubViewport der Property ``Layer Viewport`` zu und "
"aktivieren Alpha Blend."

msgid ""
"As the player can walk away from the origin point, you will want to "
"reposition the composition layer when the player recenters the view. Using "
"the reference space ``Local Floor`` will apply this logic automatically."
msgstr ""
"Da der Spieler sich vom Ursprungspunkt entfernen kann, sollten Sie die "
"Kompositionsebene neu positionieren, wenn der Spieler die Ansicht erneut "
"ändert. Die Verwendung des Referenzraums ``Localer Boden`` wird diese Logik "
"automatisch anwenden."

msgid "Making the interface work"
msgstr "Die Benutzeroberfläche zum Laufen bringen"

msgid ""
"So far we're only displaying our UI, to make it work we need to add some "
"code. For this example we're going to keep things simple and make one of the "
"controllers work as a pointer. We'll then simulate mouse actions with this "
"pointer."
msgstr ""
"Bis jetzt haben wir nur unsere Benutzeroberfläche angezeigt, damit sie "
"funktioniert, müssen wir etwas Code hinzufügen. Für dieses Beispiel werden "
"wir die Dinge einfach halten und einen der Controller als Zeiger verwenden. "
"Wir werden dann Mausaktionen mit diesem Zeiger simulieren."

msgid ""
"This code also requires a ``MeshInstance3D`` node called ``Pointer`` to be "
"added as a child to our ``OpenXRCompositionLayerQuad`` node. We configure a "
"``SphereMesh`` with a radius ``0.01`` meters. We'll be using this as a "
"helper to visualize where the user is pointing."
msgstr ""
"Dieser Code erfordert auch einen ``MeshInstance3D``-Node namens ``Pointer``, "
"der als Child-Node unseres ``OpenXRCompositionLayerQuad``-Nodes hinzugefügt "
"wird. Wir konfigurieren ein ``SphereMesh`` mit einem Radius von ``0.01`` "
"Metern. Wir werden dies als Hilfsmittel benutzen, um zu visualisieren, wohin "
"der Benutzer zeigt."

msgid ""
"The main function that drives this functionality is the ``intersects_ray`` "
"function on our composition layer node. This function takes the global "
"position and orientation of our pointer and returns the UV where our ray "
"intersects our viewport. It returns ``Vector2(-1.0, -1.0)`` if we're not "
"pointing at our viewport."
msgstr ""
"Die Hauptfunktion, die diese Funktionalität steuert, ist die Funktion "
"``intersects_ray`` auf unserem Kompositionsebenen-Node. Diese Funktion nimmt "
"die globale Position und Orientierung unseres Zeigers und gibt das UV "
"zurück, in dem unser Strahl unseren Viewport schneidet. Sie gibt "
"``Vector2(-1.0, -1.0)`` zurück, wenn wir nicht auf unseren Viewport zeigen."

msgid ""
"We start with setting up some variables, important here are the export "
"variables which identify our controller node with which we point to our "
"screen."
msgstr ""
"Wir beginnen mit dem Einrichten einiger Variablen, wichtig sind hier die "
"Exportvariablen, die unseren Controller-Node identifizieren, mit dem wir auf "
"unseren Bildschirm zeigen."

msgid ""
"Next we define a helper function that takes the value returned from "
"``intersects_ray`` and gives us the global position for that intersection "
"point. This implementation only works for our ``OpenXRCompositionLayerQuad`` "
"node."
msgstr ""
"Als nächstes definieren wir eine Hilfsfunktion, die den von "
"``intersects_ray`` zurückgegebenen Wert nimmt und uns die globale Position "
"für diesen Schnittpunkt gibt. Diese Implementierung funktioniert nur für "
"unseren ``OpenXRCompositionLayerQuad``-Node."

msgid ""
"We also define a helper function that takes our ``intersect`` value and "
"returns our location in the viewports local coordinate system:"
msgstr ""
"Wir definieren auch eine Hilfsfunktion, die unseren ``Intersect``-Wert nimmt "
"und unsere Position im lokalen Koordinatensystem des Viewports zurückgibt:"

msgid ""
"The main logic happens in our ``_process`` function. Here we start by hiding "
"our pointer, we then check if we have a valid controller and viewport, and "
"we call ``intersects_ray`` with the position and orientation of our "
"controller:"
msgstr ""
"Die Hauptlogik geschieht in unserer ``_process``-Funktion. Hier fangen wir "
"an, indem wir unseren Zeiger verstecken, dann prüfen wir, ob wir einen "
"gültigen Controller und Viewport haben, und wir rufen ``intersects_ray`` mit "
"der Position und Orientierung unseres Controllers auf:"

msgid ""
"Next we check if we're intersecting with our viewport. If so, we check if "
"our button is pressed and place our pointer at our intersection point."
msgstr ""
"Als Nächstes prüfen wir, ob wir uns mit unserem Viewport schneiden. Wenn ja, "
"prüfen wir, ob unser Button gedrückt ist und platzieren unseren Zeiger an "
"unserem Schnittpunkt."

msgid ""
"If we were intersecting in our previous process call and our pointer has "
"moved, we prepare a :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` object to simulate our mouse moving and send "
"that to our viewport for further processing."
msgstr ""
"Wenn wir uns in unserem vorherigen Prozessaufruf überschnitten haben und "
"unser Zeiger sich bewegt hat, bereiten wir ein :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>`-Objekt vor, um unsere Mausbewegung zu "
"simulieren, und senden es zur weiteren Verarbeitung an unser Viewport."

msgid ""
"If we've just released our button we also prepare a :ref:"
"`InputEventMouseButton <class_InputEventMouseButton>` object to simulate a "
"button release and send that to our viewport for further processing."
msgstr ""
"Wenn wir gerade unseren Button losgelassen haben, bereiten wir auch ein :ref:"
"`InputEventMouseButton <class_InputEventMouseButton>`-Objekt vor, um das "
"Loslassen eines Buttons zu simulieren, und senden es zur weiteren "
"Verarbeitung an unseren Viewport."

msgid ""
"Or if we've just pressed our button we prepare a :ref:`InputEventMouseButton "
"<class_InputEventMouseButton>` object to simulate a button press and send "
"that to our viewport for further processing."
msgstr ""
"Oder wenn wir gerade unseren Button gedrückt haben, bereiten wir ein :ref:"
"`InputEventMouseButton <class_InputEventMouseButton>`-Objekt vor, um das "
"Drücken eines Buttons zu simulieren, und senden dieses an unseren Viewport "
"zur weiteren Verarbeitung."

msgid "Next we remember our state for next frame."
msgstr "Als Nächstes merken wir uns unseren Zustand für das nächste Frame."

msgid "Finally, if we aren't intersecting, we simply clear our state."
msgstr "Wenn wir uns nicht schneiden, löschen wir einfach unseren Status."

msgid "Hole punching"
msgstr "Hole Punching"

msgid ""
"As the composition layer is composited on top of the render result, it can "
"be rendered in front of objects that are actually forward of the viewport."
msgstr ""
"Da die Kompositionsebene über dem Renderergebnis zusammengesetzt wird, kann "
"sie vor Objekten gerendert werden, die sich eigentlich vor dem Viewport "
"befinden."

msgid ""
"By enabling hole punch you instruct Godot to render a transparent object "
"where our viewport is displayed. It does this in a way that fills the depth "
"buffer and clears the current rendering result. Anything behind our viewport "
"will now be cleared, while anything in front of our viewport will be "
"rendered as usual."
msgstr ""
"Wenn Sie Hole Punch aktivieren, weisen Sie Godot an, ein transparentes "
"Objekt dort zu rendern, wo unser Viewport angezeigt wird. Dies geschieht auf "
"eine Weise, die den Tiefenpuffer füllt und das aktuelle Rendering-Ergebnis "
"löscht. Alles, was sich hinter unserem Viewport befindet, wird nun gelöscht, "
"während alles vor unserem Viewport wie gewohnt gerendert wird."

msgid ""
"You also need to set ``Sort Order`` to a negative value, the XR compositor "
"will now draw the viewport first, and then overlay our rendering result."
msgstr ""
"Sie müssen auch ``Sortierreihenfolge`` auf einen negativen Wert setzen, der "
"XR-Compositor wird nun zuerst den Viewport zeichnen und dann unser Rendering-"
"Ergebnis überlagern."

msgid ""
"Use case showing how the users hand is incorrectly obscured by a composition "
"layer when hole punching is not used."
msgstr ""
"Anwendungsfall, der zeigt, wie die Hand des Benutzers fälschlicherweise von "
"einer Kompositionsebene verdeckt wird, wenn Hole Punch nicht verwendet wird."

msgid "Translation status"
msgstr "Übersetzungsstatus"
