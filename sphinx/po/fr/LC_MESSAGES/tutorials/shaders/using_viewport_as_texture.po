#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "Introduction"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr ""
"Ce tutoriel ne couvre pas la façon de coder une atmosphère dynamique comme "
"celle de cette planète."

msgid "In this tutorial, we'll cover the following topics:"
msgstr "Durant ce tutoriel, nous couvrirons les sujets suivant :"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "Mappage d'une texture sur une sphère avec un mappage équirectangulaire"

msgid "Fragment shader techniques for procedural planets"
msgstr "Techniques fragment shader pour planètes procédurales"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr ""
"Paramétrage d'une carte de rugosité à partir d'une :ref:`Viewport Texture "
"<class_ViewportTexture>`"

msgid "Setting up the scene"
msgstr "Mise en place de la scène"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"Ensuite, on ajoute un :ref:`Shader Material <class_ShaderMaterial>` au :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"Une connaissance de base du shading est recommandée pour ce tutoriel. "
"Cependant, même si vous êtes nouveau dans les shaders, tout le code sera "
"fourni, donc vous ne devriez pas avoir de problème pour suivre."

msgid "Applying the texture"
msgstr "Appliquer la texture"

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr ""
"Votre sphère devrait maintenant être colorée avec les couleurs que nous "
"avons rendues dans le Viewport."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"Remarquez-vous la jointure laide qui se forme à l'endroit où la texture "
"s'enroule ? C'est parce que nous choisissons une couleur basée sur les "
"coordonnées UV et que les coordonnées UV ne s'enroulent pas autour de la "
"texture. C'est un problème classique dans la projection de cartes 2D. Les "
"développeurs de jeux ont souvent une carte en 2 dimensions qu'ils veulent "
"projeter sur une sphère, mais quand elle s'enroule autour, elle a de larges "
"jointures. Il existe une solution élégante à ce problème, que nous "
"illustrerons dans la prochaine section."

msgid "Making the planet texture"
msgstr "Créer la texture de la planète"

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"Si vous êtes intéressé par un peu plus d'informations sur la technique, nous "
"allons convertir des coordonnées sphériques en coordonnées cartésiennes. Les "
"coordonnées sphériques représentent la longitude et la latitude de la "
"sphère, tandis que les coordonnées cartésiennes sont, à toutes fins utiles, "
"un vecteur allant du centre de la sphère au point."

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"Pour chaque pixel, nous allons calculer sa position 3D sur la sphère. A "
"partir de là, nous allons utiliser un bruit 3D pour déterminer une valeur de "
"couleur. En calculant le bruit en 3D, nous résolvons le problème du "
"pincement aux pôles. Pour comprendre pourquoi, imaginez le bruit calculé sur "
"la surface de la sphère plutôt que sur le plan 2D. Lorsque vous calculez sur "
"la surface de la sphère, vous ne touchez jamais un bord, et donc vous ne "
"créez jamais de couture ou de point de pincement sur le pôle. Le code "
"suivant convertit les ``UVs`` en coordonnées cartésiennes."

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr ""
"Et si nous utilisons ``unit`` comme valeur de sortie ``COLOR``, nous "
"obtenons :"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"Maintenant que nous pouvons calculer la position 3D de la surface de la "
"sphère, nous pouvons utiliser le bruit 3D pour faire la planète. Nous "
"utiliserons cette fonction de bruit directement depuis un `Shadertoy "
"<https://www.shadertoy.com/view/Xsl3Dl>`_ :"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr ""
"Tout les crédits vont à l'auteur, Inigo Quilez, Cela est publié sous une "
"licence ``MIT``."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr ""
"Maintenant pour utiliser le ``noise``, ajoutez ce qui suit à la fonction "
"``fragment`` :"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr ""
"Afin de mettre en valeur la texture, nous avons réglé le matériau sur "
"unshaded."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"Vous pouvez voir maintenant que le bruit s'enroule en effet sans jointure "
"autour de la sphère. Bien que cela ne ressemble en rien à la planète qu'on "
"vous a promise. Alors passons à quelque chose de plus coloré."

msgid "Coloring the planet"
msgstr "Colorer la planète"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"Maintenant pour faire les couleurs de la planète. Bien qu'il y ait de "
"nombreuses façons de le faire, pour l'instant, nous nous en tiendrons à un "
"gradient entre l'eau et la terre."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"Pour faire un gradient dans GLSL, on utilise la fonction ``mix``. ``mix`` "
"prend deux valeurs à interpoler entre elles et un troisième argument pour "
"choisir la quantité à interpoler entre elles ; en substance, il *mixe* les "
"deux valeurs ensemble. Dans d'autres API, cette fonction est souvent appelée "
"``lerp``. Cependant, ``lerp`` est typiquement réservé au mélange de deux "
"flottants ensemble ; ``mix`` peut prendre n'importe quelle valeur, que ce "
"soit des flottants ou des types vecteur."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"La première couleur est le bleu pour l'océan. La deuxième couleur est une "
"sorte de couleur rougeâtre (parce que toutes les planètes extraterrestres "
"ont besoin d'un terrain rouge). Et finalement, ils sont mélangés par ``n * "
"0.5 + 0.5``. ``n`` varie en douceur entre ``-1`` et ``1``. Donc nous le "
"mappons dans l'intervalle ``0-1`` que ``mix`` attend. Maintenant vous pouvez "
"voir que les couleurs changent entre le bleu et le rouge."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"C'est un peu plus flou que ce que nous voulons. Les planètes ont "
"généralement une séparation relativement nette entre la terre et la mer. "
"Pour ce faire, nous allons changer le dernier terme en ``smoothstep(-0.1, "
"0.0, n)``. Et ainsi toute la ligne devient :"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"Ce que fait ``smoothstep`` est de retourner ``0`` si le troisième argument "
"est en dessous du premier et ``1`` si le troisième argument est plus grand "
"que le second et se mélange doucement entre ``0`` et ``1`` si le troisième "
"nombre est entre le premier et le second. Donc, dans cette ligne, "
"``smoothstep`` renvoie ``0`` lorsque ``n`` est inférieur à ``-0.1`` et ``1`` "
"lorsque ``n`` est supérieur à ``0``."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"Une dernière chose pour rendre ça un peu plus planétaire. La terre ne "
"devrait pas être aussi tachetée ; rendons les bords un peu plus rugueux. Une "
"astuce souvent utilisée dans les shaders pour rendre un terrain rugueux avec "
"du bruit consiste à superposer des niveaux de bruit à différentes "
"fréquences. Nous utilisons une couche pour faire la structure globale des "
"continents. Ensuite, une autre couche casse un peu les bords, puis une "
"autre, et ainsi de suite. Ce que nous allons faire, c'est calculer ``n`` "
"avec quatre lignes de code de shader au lieu d'une seule. ``n`` devient :"

msgid "And now the planet looks like:"
msgstr "Et maintenant, la planète ressemble à :"

msgid "Making an ocean"
msgstr "Créer un océan"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"Une dernière chose pour que ça ressemble plus à une planète. L'océan et la "
"terre reflètent la lumière différemment. Nous voulons donc que l'océan "
"brille un peu plus que la terre. Nous pouvons faire cela en passant une "
"quatrième valeur dans le canal ``alpha`` de notre sortie ``COLOR`` et en "
"l'utilisant comme carte de rugosité."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"Cette ligne renvoie ``0.3`` pour l'eau et ``1.0`` pour la terre. Cela "
"signifie que le terrain sera assez accidenté, tandis que l'eau sera assez "
"lisse."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"Et ensuite, dans le matériau, sous la section \"Metallic\", assurez-vous que "
"``Metallic`` est réglé à ``0`` et ``Specular`` est réglé à ``1``. La raison "
"en est que l'eau réfléchit très bien la lumière, mais n'est pas métallique. "
"Ces valeurs ne sont pas physiquement exactes, mais elles sont suffisamment "
"bonnes pour cette démo."

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"Ceci pré-multiplie les couleurs par la valeur ``alpha`` et les mélange "
"ensuite correctement ensemble. Typiquement, en mélangeant une couleur "
"transparente sur une autre, même si le fond a un ``alpha`` de ``0`` (comme "
"c'est le cas ici), vous vous retrouvez avec d'étranges problèmes de "
"saignement de couleur. Le paramètre ``blend_premul_alpha`` corrige cela."

msgid "Translation status"
msgstr "État de la traduction"
