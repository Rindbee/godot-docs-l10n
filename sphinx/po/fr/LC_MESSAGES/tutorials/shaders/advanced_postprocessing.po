#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Post-traitement avancé"

msgid "Introduction"
msgstr "Introduction"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Ce tutoriel décrit une méthode avancée de post-traitement dans Godot. Il "
"expliquera notamment comment écrire un shader de post-traitement qui utilise "
"le tampon de profondeur. Vous devriez déjà être familier avec le post-"
"traitement en général et, en particulier, avec les méthodes décrites dans le "
"tutoriel :ref:`custom post-processing tutorial <doc_custom_postprocessing>`."

msgid "Full screen quad"
msgstr "Quadrant plein écran"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"Un moyen de faire des effets de post-traitement personnalisés est d'utiliser "
"un Viewport. L'utilisation d'un Viewport présente deux inconvénients "
"majeurs :"

msgid "The depth buffer cannot be accessed"
msgstr "Le tampon de profondeur n'est pas accessible"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "L'effet du shader de post-traitement n'est pas visible dans l'éditeur"

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Même avec ce shader de sommet, le quad continue de disparaître. Cela est dû "
"au frustum culling, qui se fait sur le CPU. Le Frustum culling utilise la "
"matrice de la caméra et les AABB des mailles pour déterminer si la maille "
"sera visible *avant* de la passer au GPU. Le CPU ne sait pas ce que nous "
"faisons avec les sommets, il suppose donc que les coordonnées spécifiées se "
"réfèrent à des positions mondiales, et non à des positions d'espace de "
"clipping, ce qui a pour conséquence que Godot élimine le quadrant lorsque "
"nous nous éloignons du centre de la scène. Afin d'éviter que le quad ne soit "
"éliminé, il existe plusieurs options :"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Ajouter le QuadMesh comme enfant de la caméra, de sorte que la caméra "
"regarde toujours vers lui"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Définissez la propriété ``extra_cull_margin`` aussi large que possible dans "
"le QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"La deuxième option garantie que le quad soit visible dans l'éditeur, alors "
"que la première option assure qu'il reste visible même si la caméra se "
"déplace en dehors de l'espace d'affichage. Vous pouvez également utiliser "
"les deux options."

msgid "Depth texture"
msgstr "Texture de profondeur"

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"Semblable à l'accès à la texture d'écran, accéder à la texture de profondeur "
"n'est possible qu'en lisant à partir du viewport courant. La texture de "
"profondeur n'est pas accessible à partir d'un autre viewport dans lequel "
"vous avez fait un rendu."

msgid ""
"The values returned by ``depth_texture`` are between ``1.0`` and ``0.0`` "
"(corresponding to the near and far plane, respectively, because of using a "
"\"reverse-z\" depth buffer) and are nonlinear. When displaying depth "
"directly from the ``depth_texture``, everything will look almost black "
"unless it is very close due to that nonlinearity. In order to make the depth "
"value align with world or model coordinates, we need to linearize the value. "
"When we apply the projection matrix to the vertex position, the z value is "
"made nonlinear, so to linearize it, we multiply it by the inverse of the "
"projection matrix, which in Godot, is accessible with the variable "
"``INV_PROJECTION_MATRIX``."
msgstr ""
"Les valeurs renvoyées par ``depth_texture`` sont comprises entre ``1.0`` et "
"``0.0`` (correspondant au plan proche (near plane) et plan éloigné (far "
"plane), respectivement, à cause de l'utilisation d'un tampon de profondeur à "
"\"z-inversé\") et ne sont pas linéaires. Lorsque l'on affiche directement la "
"profondeur depuis la ``depth_texture``, tout va être presque noir sauf si "
"c'est très proche à cause de la non-linéarité. Pour que la valeur de "
"profondeur soit cohérente avec les coordonnées du monde ou du modèle, il "
"nous faut linéariser la valeur. Lorsque l'on applique la matrice de "
"projection à la position du sommet, la valeur z est rendue non-linéaire, "
"alors pour la linéariser, il faut la multiplier par la matrice de projection "
"inverse qui, dans Godot, est accessible par la variable "
"``INV_PROJECTION_MATRIX``."

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"Convertissez les NDC en coordonnées de l'espace visuel les NDC en "
"multipliant par ``INV_PROJECTION_MATRIX``. Rappelez-vous que l'espace visuel "
"donne les positions relatives à la caméra, la valeur de ``z`` nous renseigne "
"donc sur la distance au point."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Comme la caméra est orientée dans la direction ``z`` négative, la position "
"aura une valeur ``z`` négative. Pour obtenir une valeur de profondeur "
"utilisable, il nous faut mettre``view.z`` négative."

msgid "Example shader"
msgstr "Shader d'exemple"

msgid "An optimization"
msgstr "Une optimisation"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"However, the benefit is quite small and only beneficial when running "
"especially complex fragment shaders."
msgstr ""
"Vous pouvez tirer profit de l'utilisation d'un seul grand triangle plutôt "
"que d'un grand quadrilatère de la taille de l'écran. Vous trouverez une "
"explication à `cette adresse <https://michaldrobot.com/2014/04/01/gcn-"
"execution-patterns-in-full-screen-passes>`_. Cependant, le bénéfice est "
"assez faible et seulement utile lors de l'utilisation de fragments shaders "
"particulièrement complexes."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Réglez le Mesh dans la MeshInstance3D sur un :ref:`ArrayMesh "
"<class_ArrayMesh>`. Un ArrayMesh est un outil qui vous permet de construire "
"facilement un Mesh à partir de Arrays pour les sommets, les normales, les "
"couleurs, etc."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr ""
"Maintenant, attachez un script à MeshInstance3D et utilisez le code suivant :"

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Assignez le même vertex shader qu'au-dessus et tout devrait avoir exactement "
"la même apparence."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"Le seul inconvénient de l'utilisation d'un ArrayMesh par rapport à celle "
"d'un QuadMesh est que le ArrayMesh n'est pas visible dans l'éditeur car le "
"triangle n'est pas construit avant que la scène ne soit exécutée. Pour "
"contourner ce problème, construisez un Mesh triangulaire dans un programme "
"de modélisation et utilisez-le dans le MeshInstance3D à la place du "
"ArrayMesh."
