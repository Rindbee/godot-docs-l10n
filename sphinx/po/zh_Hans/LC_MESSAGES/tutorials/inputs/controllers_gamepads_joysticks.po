#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Controllers, gamepads, and joysticks"
msgstr "控制器、手柄和摇杆"

msgid ""
"Since Godot 4.5, the engine relies on `SDL 3 <https://www.libsdl.org/"
"index.php>`__ for controller support on Windows, macOS, and Linux. This "
"means the list of supported controllers and their behavior should closely "
"match what is available in other games and engines using SDL 3. Note that "
"SDL is only used for input, not for windowing or sound."
msgstr ""
"自 Godot 4.5 起，引擎在 Windows、macOS 和 Linux 平台上依赖 `SDL 3 <https://"
"www.libsdl.org/index.php>`__ 实现控制器支持。这意味着支持的控制器列表及其行为"
"应与使用 SDL 3 的其他游戏和引擎高度一致。请注意，SDL 仅用于输入处理，不涉及窗"
"口管理或音频功能。"

msgid ""
"Prior to Godot 4.5, the engine used its own controller support code. This "
"can cause certain controllers to behave incorrectly. This custom code is "
"still used to support controllers on Android, iOS, and Web, so it may result "
"in issues appearing only on those platforms."
msgstr ""
"在 Godot 4.5 之前，引擎使用自有的控制器支持代码，这可能导致某些控制器行为异"
"常。目前该自定义代码仍用于支持 Android、iOS 和 Web 平台上的控制器，因此相关问"
"题可能仅在这些平台上出现。"

msgid ""
"Note that more specialized devices such as steering wheels, rudder pedals "
"and `HOTAS <https://en.wikipedia.org/wiki/HOTAS>`__ are less tested and may "
"not always work as expected. Overriding force feedback for those devices is "
"also not implemented yet. If you have access to one of those devices, don't "
"hesitate to `report bugs on GitHub <https://github.com/godotengine/godot/"
"blob/master/CONTRIBUTING.md#reporting-bugs>`__."
msgstr ""
"请注意，诸如方向盘、方向盘踏板和 `HOTAS <https://en.wikipedia.org/wiki/"
"HOTAS>`__ 等更专业的设备测试较少，可能并不总是按照预期工作。目前尚未实现在这"
"些设备上的力反馈覆盖。如果你有机会使用这些设备，请不要犹豫，\\ `在 GitHub "
"<https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-"
"bugs>`__ 上报告错误。"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你将学会："

msgid ""
"**How to write your input logic to support both keyboard and controller "
"inputs.**"
msgstr "**如何编写你的输入逻辑，从而支持键盘和控制器输入。**"

msgid "**How controllers can behave differently from keyboard/mouse input.**"
msgstr "**控制器的行为如何与键盘/鼠标输入不同。**"

msgid "**Troubleshooting issues with controllers in Godot.**"
msgstr "**解决 Godot 中控制器的问题。**"

msgid "Supporting universal input"
msgstr "支持通用输入"

msgid ""
"Thanks to Godot's input action system, Godot makes it possible to support "
"both keyboard and controller input without having to write separate code "
"paths. Instead of hardcoding keys or controller buttons in your scripts, you "
"should create *input actions* in the Project Settings which will then refer "
"to specified key and controller inputs."
msgstr ""
"得益于 Godot 的输入动作系统，Godot 可以同时支持键盘和控制器输入，而不需要编写"
"单独的代码路径。你不应该在脚本中对控制器的按键进行硬编码，应该在项目设置中创"
"建\\ *输入动作*\\ ，这些动作引用按键和控制器输入。"

msgid ""
"Input actions are explained in detail on the :ref:`doc_inputevent` page."
msgstr "输入动作在 :ref:`doc_inputevent` 页面上有详细解释。"

msgid ""
"Unlike keyboard input, supporting both mouse and controller input for an "
"action (such as looking around in a first-person game) will require "
"different code paths since these have to be handled separately."
msgstr ""
"与键盘输入不同，支持鼠标和控制器输入的动作（例如在第一人称游戏中环顾四周）将"
"需要不同的代码路径，因为它们必须分开处理。"

msgid "Which Input singleton method should I use?"
msgstr "我应该使用哪个输入单例方法？"

msgid "There are 3 ways to get input in an analog-aware way:"
msgstr "有 3 种方式可以以模拟感知的方式获得输入："

msgid ""
"When you have two axes (such as joystick or WASD movement) and want both "
"axes to behave as a single input, use ``Input.get_vector()``:"
msgstr ""
"当你有两个轴（例如摇杆或 WASD 运动）并且希望两个轴都作为单个输入时，请使用 "
"``Input.get_vector()``\\ ："

msgid ""
"When you have one axis that can go both ways (such as a throttle on a flight "
"stick), or when you want to handle separate axes individually, use "
"``Input.get_axis()``:"
msgstr ""
"当你有一个轴可以双向移动时（比如飞行摇杆上的油门），或者你想单独处理不同的轴"
"时，使用 ``Input.get_axis()`` :"

msgid ""
"For other types of analog input, such as handling a trigger or handling one "
"direction at a time, use ``Input.get_action_strength()``:"
msgstr ""
"对于其他类型的模拟输入，例如处理一个触发器或一次处理一个方向，使用 "
"``Input.get_action_strength()``\\ ："

msgid ""
"For non-analog digital/boolean input (only \"pressed\" or \"not pressed\" "
"values), such as controller buttons, mouse buttons or keyboard keys, use "
"``Input.is_action_pressed()``:"
msgstr ""
"对于非模拟数字/布尔输入（只有 \"按下 \" 或 \"未按下 \" 的值），如控制器按钮、"
"鼠标按钮或键盘按键，使用 ``Input.is_action_pressed()``\\ ："

msgid ""
"If you need to know whether an input was *just* pressed in the previous "
"frame, use ``Input.is_action_just_pressed()`` instead of "
"``Input.is_action_pressed()``. Unlike ``Input.is_action_pressed()`` which "
"returns ``true`` as long as the input is held, "
"``Input.is_action_just_pressed()`` will only return ``true`` for one frame "
"after the button has been pressed."
msgstr ""
"如果你想要知道上一帧是否\\ *刚刚*\\ 按下了某个输入，请使用 "
"``Input.is_action_just_pressed()``\\ ，不要使用 "
"``Input.is_action_pressed()``\\ 。\\ ``Input.is_action_pressed()`` 是只要输入"
"处于按下的状态就会返回 ``true``\\ ，而 ``Input.is_action_just_pressed()`` 只"
"会在按下按钮后的一帧内返回 ``true``\\ 。"

msgid "Vibration"
msgstr "振动"

msgid ""
"Vibration (also called *haptic feedback*) can be used to enhance the feel of "
"a game. For instance, in a racing game, you can convey the surface the car "
"is currently driving on through vibration, or create a sudden vibration on a "
"crash."
msgstr ""
"振动（也叫\\ *触觉反馈*\\ ）可以用来提升游戏手感。比如在赛车游戏中，可以通过"
"振动来体现车辆当前所处的路面，也可以在撞车时进行突然的振动。"

msgid ""
"Use the Input "
"singleton's :ref:`start_joy_vibration<class_Input_method_start_joy_vibration>` "
"method to start vibrating a gamepad. "
"Use :ref:`stop_joy_vibration<class_Input_method_stop_joy_vibration>` to stop "
"vibration early (useful if no duration was specified when starting)."
msgstr ""
"请使用 Input 单例"
"的 :ref:`start_joy_vibration<class_Input_method_start_joy_vibration>` 方法开"
"启游戏手柄的振动。要提前结束振动，请使"
"用 :ref:`stop_joy_vibration<class_Input_method_stop_joy_vibration>`\\ （尤其"
"适用于启动时未指定时长的情况）。"

msgid ""
"On mobile devices, you can also "
"use :ref:`vibrate_handheld<class_Input_method_vibrate_handheld>` to vibrate "
"the device itself (independently from the gamepad). On Android, this "
"requires the ``VIBRATE`` permission to be enabled in the Android export "
"preset before exporting the project."
msgstr ""
"在移动设备上，你还可以使"
"用 :ref:`vibrate_handheld<class_Input_method_vibrate_handheld>` 来振动设备本"
"身（与游戏手柄的振动是分开的）。在 Android 上，这个功能需要在导出项目前启用 "
"Android 导出预设中的 ``VIBRATE`` 权限。"

msgid ""
"Vibration can be uncomfortable for certain players. Make sure to provide an "
"in-game slider to disable vibration or reduce its intensity."
msgstr ""
"振动可能造成某些玩家的不适。请确保在游戏中提供滑块，用来禁用振动或降低振动强"
"度。"

msgid "Differences between keyboard/mouse and controller input"
msgstr "键盘/鼠标和控制器输入之间的差异"

msgid ""
"If you're used to handling keyboard and mouse input, you may be surprised by "
"how controllers handle specific situations."
msgstr ""
"如果你习惯于处理键盘和鼠标输入，可能会对控制器处理特定情况的方式感到惊讶。"

msgid "Dead zone"
msgstr "死区"

msgid ""
"Unlike keyboards and mice, controllers offer axes with *analog* inputs. The "
"upside of analog inputs is that they offer additional flexibility for "
"actions. Unlike digital inputs which can only provide strengths of ``0.0`` "
"and ``1.0``, an analog input can provide *any* strength between ``0.0`` and "
"``1.0``. The downside is that without a deadzone system, an analog axis' "
"strength will never be equal to ``0.0`` due to how the controller is "
"physically built. Instead, it will linger at a low value such as ``0.062``. "
"This phenomenon is known as *drifting* and can be more noticeable on old or "
"faulty controllers."
msgstr ""
"与键盘和鼠标不同，控制器提供带有\\ *模拟*\\ 输入的轴。模拟输入的好处是它们为"
"动作提供了额外的灵活性。不像数字输入只能提供 ``0.0`` 和 ``1.0`` 的强度，模拟"
"输入可以提供 ``0.0`` 和 ``1.0`` 之间的\\ *任何*\\ 强度。缺点是没有死区系统，"
"由于控制器的物理结构，模拟轴的强度永远不会等于 ``0.0``\\ 。相反，它将徘徊在一"
"个低值，如 ``0.062``\\ 。这种现象被称为\\ *漂移*\\ ，在旧的或有问题的控制器上"
"会更加明显。"

msgid ""
"Let's take a racing game as a real-world example. Thanks to analog inputs, "
"we can steer the car slowly in one direction or another. However, without a "
"deadzone system, the car would slowly steer by itself even if the player "
"isn't touching the joystick. This is because the directional axis strength "
"won't be equal to ``0.0`` when we expect it to. Since we don't want our car "
"to steer by itself in this case, we define a \"dead zone\" value of ``0.2`` "
"which will ignore all input whose strength is lower than ``0.2``. An ideal "
"dead zone value is high enough to ignore the input caused by joystick "
"drifting, but is low enough to not ignore actual input from the player."
msgstr ""
"让我们把赛车游戏作为一个现实世界的例子。由于有了模拟输入，我们可以将汽车慢慢"
"地转向一个或另一个方向。然而，如果没有死区系统，即使玩家不接触操纵杆，汽车也"
"会自己慢慢转向。这是因为方向轴的强度在我们期望的时候不会等于 ``0.0``\\ 。因为"
"我们不希望我们的车在这种情况下自动转向，我们定义了一个“死区”值 ``0.2``\\ ，它"
"将忽略所有强度低于 ``0.2`` 的输入。一个理想的死区值是足够高的，可以忽略操纵杆"
"漂移引起的输入，但又足够低，不会忽略玩家的实际输入。"

msgid ""
"Godot features a built-in deadzone system to tackle this problem. The "
"default value is ``0.5``, but you can adjust it on a per-action basis in the "
"Project Settings' Input Map tab. For ``Input.get_vector()``, the deadzone "
"can be specified as an optional 5th parameter. If not specified, it will "
"calculate the average deadzone value from all of the actions in the vector."
msgstr ""
"Godot 提供了内置的死区系统来解决这个问题。默认值是 ``0.5``\\ ，但你可以在“项"
"目设置”的“输入映射”选项卡中针对具体的动作进行调整。\\ "
"``Input.get_vector()``\\ 可以在第五个参数中指定死区。如果没有指定，则会计算向"
"量中的所有动作死区的平均值。"

msgid "\"Echo\" events"
msgstr "“回显”事件"

msgid ""
"Unlike keyboard input, holding down a controller button such as a D-pad "
"direction will **not** generate repeated input events at fixed intervals "
"(also known as \"echo\" events). This is because the operating system never "
"sends \"echo\" events for controller input in the first place."
msgstr ""
"与键盘输入不同，按住一个控制器按钮，如十字方向键，\\ **不会**\\ 产生固定间隔"
"的重复输入事件（也被称为“回显”事件）。这是因为操作系统首先不会为控制器输入发"
"送“回显”事件。"

msgid ""
"If you want controller buttons to send echo events, you will have to "
"generate :ref:`class_InputEvent` objects by code and parse them "
"using :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` at regular intervals. This can be "
"accomplished with the help of a :ref:`class_Timer` node."
msgstr ""
"如果你想让控制器按钮发送回显事件，你将不得不通过代码生"
"成 :ref:`class_InputEvent` 对象，并使用 :ref:`Input.parse_input_event() "
"<class_Input_method_parse_input_event>` 定期解析它们。这可以"
"在 :ref:`class_Timer` 节点的帮助下完成。"

msgid "Window focus"
msgstr "窗口焦点"

msgid ""
"Unlike keyboard input, controller inputs can be seen by **all** windows on "
"the operating system, including unfocused windows."
msgstr ""
"与键盘输入不同，控制器的输入可以被操作系统中的\\ **所有**\\ 窗口看到，包括未"
"持有焦点的窗口。"

msgid ""
"While this is useful for `third-party split screen functionality <https://"
"nucleus-coop.github.io/>`__, it can also have adverse effects. Players may "
"accidentally send controller inputs to the running project while interacting "
"with another window."
msgstr ""
"虽然这对于\\ `第三方分屏功能 <https://nucleus-coop.github.io/>`__\\ 很有用，"
"但也可能产生不利影响。玩家在与另一个窗口互动时可能会意外地将控制器输入传送到"
"正在执行的项目。"

msgid ""
"If you wish to ignore events when the project window isn't focused, you will "
"need to create an :ref:`autoload <doc_singletons_autoload>` called ``Focus`` "
"with the following script and use it to check all your inputs:"
msgstr ""
"如果你希望在项目窗口未聚焦时忽略事件，则需要使用以下脚本创建一个名为 "
"``Focus`` 的\\ :ref:`自动加载 <doc_singletons_autoload>`\\ ，并使用它来检查所"
"有输入："

msgid ""
"Then, instead of using ``Input.is_action_pressed(action)``, use "
"``Focus.input_is_action_pressed(action)`` where ``action`` is the name of "
"the input action. Also, instead of using "
"``event.is_action_pressed(action)``, use "
"``Focus.event_is_action_pressed(event, action)`` where ``event`` is an "
"InputEvent reference and ``action`` is the name of the input action."
msgstr ""
"然后，不要使用 ``Input.is_action_pressed(action)``\\ ，而是使用 "
"``Focus.input_is_action_pressed(action)``\\ ，其中 ``action`` 是输入动作的名"
"称。另外，不要使用 ``event.is_action_pressed(action)``\\ ，而是使用 "
"``Focus.event_is_action_pressed(event, action)``\\ ，其中 ``event`` 是 "
"InputEvent 引用，\\ ``action`` 是输入动作的名称。"

msgid "Power saving prevention"
msgstr "防止省电模式"

msgid ""
"Unlike keyboard and mouse input, controller inputs do **not** inhibit sleep "
"and power saving measures (such as turning off the screen after a certain "
"amount of time has passed)."
msgstr ""
"与键盘和鼠标输入不同，控制器输入\\ **不会**\\ 抑制睡眠和省电措施（例如在经过"
"一定时间后关闭屏幕）。"

msgid ""
"To combat this, Godot enables power saving prevention by default when a "
"project is running. If you notice the system is turning off its display when "
"playing with a gamepad, check the value of **Display > Window > Energy "
"Saving > Keep Screen On** in the Project Settings."
msgstr ""
"为了解决这个问题，Godot 在项目运行时默认启用预防省电。如果你注意到在使用游戏"
"手柄玩游戏时系统正在关闭其显示屏，请检查项目设置中的\\ **显示 > 窗口 > 节能 "
"> 保持屏幕开启**\\ 的值。"

msgid "Troubleshooting"
msgstr "故障排除"

msgid ""
"You can view a list of `known issues with controller support <https://"
"github.com/godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__ on GitHub."
msgstr ""
"你可以在 GitHub 上查看\\ `控制器支持的已知问题列表 <https://github.com/"
"godotengine/godot/issues?"
"q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad>`__\\ 。"

msgid "My controller isn't recognized by Godot."
msgstr "Godot 无法识别我的控制器。"

msgid ""
"On Windows Godot only supports up to 4 controllers at a time. This is "
"because Godot uses the XInput API, which is limited to supporting 4 "
"controllers at once. Additional controllers above this limit are ignored by "
"Godot."
msgstr ""
"在 Windows 上，Godot 一次最多支持 4 个控制器。这是因为 Godot 使用了 XInput "
"API，该 API 一次最多支持 4 个控制器。超过该限制的其他控制器将被 Godot 忽略。"

msgid "My controller has incorrectly mapped buttons or axes."
msgstr "我的控制器的按钮或轴映射不正确。"

msgid ""
"First, if your controller provides some kind of firmware update utility, "
"make sure to run it to get the latest fixes from the manufacturer. For "
"instance, Xbox One and Xbox Series controllers can have their firmware "
"updated using the `Xbox Accessories app <https://www.microsoft.com/en-us/p/"
"xbox-accessories/9nblggh30xj3>`__. (This application only runs on Windows, "
"so you have to use a Windows machine or a Windows virtual machine with USB "
"support to update the controller's firmware.) After updating the "
"controller's firmware, unpair the controller and pair it again with your PC "
"if you are using the controller in wireless mode."
msgstr ""
"首先，如果你的控制器提供某种固件更新实用程序，请确保运作它以从制造商处获取最"
"新修复程序。例如，Xbox One 和 Xbox 系列控制器可以使用 `Xbox 附件应用 "
"<https://www.microsoft.com/en-us/p/xbox-accessories/9nblggh30xj3>`__ 更新固"
"件。（此应用程序仅在 Windows 上执行，因此你必须使用 Windows 电脑或支持 USB "
"的 Windows 虚拟机来更新控制器的固件。）更新控制器的固件后，如果你在无线模式下"
"使用控制器，请取消配对控制器并将其重新与你的 PC 配对。"

msgid ""
"There are many ways to create mappings. One option is to use the mapping "
"wizard in the `official Joypads demo <https://godotengine.org/asset-library/"
"asset/2785>`__. Once you have a working mapping for your controller, you can "
"test it by defining the ``SDL_GAMECONTROLLERCONFIG`` environment variable "
"before running Godot:"
msgstr ""
"有很多方法可以创建映射。一种选择是使用\\ `官方 Joypads 演示 <https://"
"godotengine.org/asset-library/asset/2785>`__\\ 中的映射向导。一旦你为控制器建"
"立了可用的映射，你就可以在运行 Godot 之前通过定义 "
"``SDL_GAMECONTROLLERCONFIG`` 环境变量来测试它："

msgid ""
"To test mappings on non-desktop platforms or to distribute your project with "
"additional controller mappings, you can add them by "
"calling :ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>` "
"as early as possible in a script's ``_ready()`` function."
msgstr ""
"要在非桌面平台上测试映射，或者用额外的控制器映射来分发你的项目，你可以通过调"
"用 :ref:`Input.add_joy_mapping() <class_Input_method_add_joy_mapping>` 尽早在"
"脚本的 ``_ready()`` 函数中添加它们。"

msgid ""
"Once you are satisfied with the custom mapping, you can contribute it for "
"the next Godot version by opening a pull request on the `Godot game "
"controller database <https://github.com/godotengine/godot/blob/master/core/"
"input/godotcontrollerdb.txt>`__."
msgstr ""
"当你对自定义映射感到满意后，可以通过在 `Godot 游戏控制器数据库 <https://"
"github.com/godotengine/godot/blob/master/core/input/"
"godotcontrollerdb.txt>`__ 上发起拉取请求，为下一个 Godot 版本贡献你的映射。"

msgid "My controller works on a given platform, but not on another platform."
msgstr "我的控制器在特定的平台上工作，但在另一个平台上却不能。"

msgid "Linux"
msgstr "Linux"

msgid ""
"If you're using a self-compiled engine binary, make sure it was compiled "
"with udev support. This is enabled by default, but it is possible to disable "
"udev support by specifying ``udev=no`` on the SCons command line. If you're "
"using an engine binary supplied by a Linux distribution, double-check "
"whether it was compiled with udev support."
msgstr ""
"如果你使用自编译引擎二进制文件，请确保它是使用 udev 支持进行编译的。默认启用"
"该功能，但可以通过在 SCons 命令列上指定 ``udev=no`` 来禁用 udev 支持。如果你"
"使用的是 Linux 发行版提供的引擎二进制文件，请仔细检查它是否是使用 udev 支持进"
"行编译的。"

msgid ""
"Controllers can still work without udev support, but it is less reliable as "
"regular polling must be used to check for controllers being connected or "
"disconnected during gameplay (hotplugging)."
msgstr ""
"控制器在没有 udev 支持的情况下仍然可以工作，但可靠性较差，因为必须使用定期轮"
"询来检查游戏过程中控制器是否连接或断开连接（热插拔）。"

msgid ""
"As described at the top of the page, controller support on mobile platforms "
"relies on a custom implementation instead of using SDL for input. This means "
"controller support may be less reliable than on desktop platforms."
msgstr ""
"如页面顶部所述，移动平台上的控制器支持依赖于自定义实现，而非使用 SDL 处理输"
"入。这意味着相比桌面平台，移动平台上的控制器支持可能不够稳定可靠。"

msgid "Web"
msgstr "Web"

msgid ""
"Like for mobile platforms, support for SDL-based controller input on the web "
"platform is `planned <https://github.com/godotengine/godot/pull/109645>`__ "
"in a future release."
msgstr ""
"与移动平台类似，未来版本中计划在 Web 平台上支持基于 SDL 的控制器输入（参见 `"
"规划 <https://github.com/godotengine/godot/pull/109645>`__）。"
