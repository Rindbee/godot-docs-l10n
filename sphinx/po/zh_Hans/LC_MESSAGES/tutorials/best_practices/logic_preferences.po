#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "逻辑偏好"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"有没有想过应该用数据结构Y还是Z, 来处理问题X ？本文涵盖了与这些困境有关的各种"
"主题."

msgid "Adding nodes and changing properties: which first?"
msgstr "先添加节点还是先修改属性？"

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""
"运行时使用脚本初始化节点时，你可能需要对节点的名称、位置等属性进行修改。常见"
"的纠结点在于，你应该什么时候去修改？"

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""
"最佳实践是在节点加入场景树之前修改取值。部分属性的 setter 代码会更新其他对应"
"的值，可能会比较慢！大多数情况下，这样的代码不会对游戏的性能产生影响，但对于"
"程序式生成之类的重型使用场景，就可能让游戏卡成 PPT。"

msgid ""
"For these reasons, it is usually best practice to set the initial values of "
"a node before adding it to the scene tree. There are some exceptions where "
"values *can't* be set before being added to the scene tree, like setting "
"global position."
msgstr ""
"综上，最佳的做法就是先为节点设置初始值，然后再把它添加到场景树中。有值在被加"
"入场景树之前\\ *不能*\\被设置的例外情况，比如设置世界坐标的时候。"

msgid "Loading vs. preloading"
msgstr "加载 VS 预加载"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"在 GDScript 中，存在全局 :ref:`preload <class_@GDScript_method_preload>` 方"
"法。它尽可能早地加载资源，以便提前进行“加载”操作，并避免在执行性能敏感的代码"
"时加载资源。"

msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias "
"for :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` "
"which is accessible to *all* scripting languages."
msgstr ""
"其对应的 :ref:`load <class_@GDScript_method_load>` 方法只有在执行 load 语句时"
"才会加载资源。也就是说，它将立即加载资源。所以，在敏感进程中加载资源会造成速"
"度减慢。\\ ``load()`` 函数是可以被 *所有* 脚本语言访问"
"的 :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` 的别"
"名。"

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"那么, 预加载和加载到底在什么时候发生, 又应该什么时候使用这两种方法呢？我们来"
"看一个例子:"

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"如果其他东西可以代替该值(例如场景导出的初始化), 则预加载该值没有任何意义. 如"
"果打算总是自己创建脚本, 那么这一点并不是重要因素."

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"如果只希望“导入”另一个类资源（脚本或者场景），那么最好的解决方法就是使用预加"
"载常量（Preloaded Constant）。不过也有例外的情况："

msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``@export`` or a ``load()`` (and "
"perhaps not even initialized until later)."
msgstr ""
"如果“导入”的类有可能发生变化，那么就应该是属性，使用 ``@export`` 或 "
"``load()`` 初始化（或者甚至更晚一些才初始化）。"

msgid "Large levels: static vs. dynamic"
msgstr "大型关卡：静态 VS 动态"

msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"答案很简单，“当性能需要的时候”。与这两种选择有关的困境是一种古老的编程选择："
"优化内存还是速度？"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"最简单的方法是使用静态关卡, 它可以一次加载所有内容. 但是, 这取决于项目, 这可"
"能会消耗大量内存. 浪费用户的运行内存会导致程序运行缓慢, 或者计算机在同一时间"
"尝试做的所有其他事情都会崩溃."

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"无论如何，应该将较大的场景分解为较小的场景（以利于资产重用）。然后，开发人员"
"可以设计一个节点，该节点实时管理资源和节点的创建/加载和删除/卸载。具有大型多"
"样环境或程序生成的元素的游戏，通常会实行这些策略，以避免浪费内存。"

msgid "As such, the best options would be..."
msgstr "因此, 最好的选择是…"

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"有关在运行时中, 可以交换场景的各种方式的示例, 请参见文档 :ref:`手动更改场景 "
"<doc_change_scenes_manually>` ."
