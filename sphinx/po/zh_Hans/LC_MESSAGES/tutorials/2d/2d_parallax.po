#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "2D Parallax"
msgstr "2D 视差"

msgid "Introduction"
msgstr "前言"

msgid ""
"Parallax is an effect used to simulate depth by having textures move at "
"different speeds relative to the camera. Godot provides "
"the :ref:`Parallax2D<class_parallax2d>` node to achieve this effect. It can "
"still be easy to get tripped up though, so this page provides in-depth "
"descriptions of some properties and how to fix some common mistakes."
msgstr ""
"视差是一种视觉效果，通过让图像纹理相对于相机以不同速度移动来模拟纵深。Godot "
"提供了 :ref:`Parallax2D<class_parallax2d>` 节点来实现这种效果。这方面的坑还是"
"不少的，因此本页面会对部分属性进行深入描述，并会介绍纠正一些常见错误的方法。"

msgid ""
"This page covers how to use :ref:`Parallax2D<class_parallax2d>`, which is "
"recommended to use over the :ref:`ParallaxLayer<class_parallaxlayer>` "
"and :ref:`ParallaxBackground<class_parallaxbackground>` nodes."
msgstr ""
"本页面介绍如何使用 :ref:`Parallax2D<class_parallax2d>` 节点。建议使用它来替"
"代 :ref:`ParallaxLayer<class_parallaxlayer>` "
"和 :ref:`ParallaxBackground<class_parallaxbackground>` 节点。"

msgid "Getting started"
msgstr "入门"

msgid ""
"The parallax node supports adding nodes that render things as children, so "
"you can use one or many nodes to make up each layer. To begin, place each "
"node or nodes you want to have scroll independently as a child of their own "
"parallax node. Make sure that the top left of the textures used are at the "
"``(0, 0)`` crossing, like in the image below. See the section "
"on :ref:`positioning <doc_2d_parallax_positioning>` for why this is "
"important."
msgstr ""
"视差节点支持添加将对象渲染为子节点的节点，因此你可以使用一个或多个节点来组成"
"每个图层。首先，将每个你想要独立滚动的节点（或多个节点）放置为它们各自视差节"
"点的子节点。确保使用的纹理的左上角位于 ``(0, 0)`` 交叉点，如下图所示。请参"
"阅 :ref:`定位 <doc_2d_parallax_positioning>` 部分了解这一节点为何重要。"

msgid ""
"The scene above uses one prepared texture for the higher clouds in "
"a :ref:`Sprite2D <class_sprite2d>`, but you could just as easily use "
"multiple nodes spaced out to compose the layer."
msgstr ""
"上面的场景在 :ref:`Sprite2D <class_sprite2d>` 中使用了一张准备好的纹理来表现"
"较高的云层，但你也可以轻松地使用多个间隔开的节点来组成该层。"

msgid "Scroll scale"
msgstr "滚动缩放"

msgid ""
"The backbone of the parallax effect is the :ref:`scroll_scale "
"<class_parallax2d_property_scroll_scale>` property. It works as a scroll-"
"speed multiplier, allowing layers to move at a different speed than the "
"camera for each axis set. A value of 1 makes the parallax node scroll at the "
"same speed as the camera. If you want your image to look further away when "
"scrolling, use a value lower than 1, with 0 bringing it to a complete stop. "
"If you want something to appear closer to the camera, use a value higher "
"than 1, making it scroll faster."
msgstr ""
"视差效果的核心是 :ref:`scroll_scale "
"<class_parallax2d_property_scroll_scale>` 属性，该属性为滚动速度系数，能够让"
"图层的移动速度和相机的移动速度产生差别，不同的轴可以分别进行调整。设为 1 时视"
"差节点与相机同速。滚动时，如果你想要让图像看起来比较远，请使用小于 1 的值，设"
"为 0 就会完全停止。如果你想要让图像看起来离相机很近，请使用大于 1 的值，这样"
"图像滚动得就会更快。"

msgid ""
"The scene above is comprised of five layers. Some good :ref:`scroll_scale "
"<class_parallax2d_property_scroll_scale>` values might be:"
msgstr ""
"上面这个场景由五个图层构成，对应的 :ref:`scroll_scale "
"<class_parallax2d_property_scroll_scale>` 可以设置为："

msgid "``(0.7, 1)`` - Forest"
msgstr "``(0.7, 1)`` - 森林"

msgid "``(0.5, 1)`` - Hills"
msgstr "``(0.5, 1)`` - 山丘"

msgid "``(0.3, 1)`` - Lower Clouds"
msgstr "``(0.3, 1)`` - 低处的云"

msgid "``(0.2, 1)`` - Higher Clouds"
msgstr "``(0.2, 1)`` - 高处的云"

msgid "``(0.1, 1)`` - Sky"
msgstr "``(0.1, 1)`` - 天空"

msgid ""
"The video below displays how these values affect scrolling while in-game:"
msgstr "下面的这个视频展示的就是这些值在游戏中的对滚动的影响："

msgid "Infinite repeat"
msgstr "无限重复"

msgid ""
":ref:`Parallax2D<class_parallax2d>` provides a bonus effect that gives "
"textures the illusion of repeating "
"infinitely. :ref:`repeat_size<class_parallax2d_property_repeat_size>` tells "
"the node to snap its position forward or back when the camera scrolls by the "
"set value. This effect is achieved by adding a single repeat to all the "
"child canvas items offset by the value. While the camera scrolls between the "
"image and its repeat, it invisibly snaps back giving the appearance of a "
"looping image."
msgstr ""
":ref:`Parallax2D<class_parallax2d>` 还可以顺便让纹理产生无限重复的假象。相机"
"移动时，\\ :ref:`repeat_size<class_parallax2d_property_repeat_size>` 可以让节"
"点的位置根据这个值向前或向后吸附。这个效果的原理是让所有子级画布项重复一次并"
"使用这个值进行偏移。而相机在原本的图像和重复的图像之间滚动，悄悄跳回原本的位"
"置就会造成图像循环的效果。"

msgid ""
"Being a delicate effect, it's easy for unfamiliar users to make mistakes "
"with their setup. Let's go over the \"how\" and \"why\" of a few common "
"problems users encounter."
msgstr ""
"这是一个很巧妙的效果，不熟悉的用户很容易在设置时出错。那我们就来看几个常见问"
"题的“原理”和“解法”。"

msgid "Poor sizing"
msgstr "大小问题"

msgid ""
"The infinite repeat effect is easiest to work with when you have an image "
"designed to repeat seamlessly and is the same size or larger than your "
"viewport **before** setting "
"the :ref:`repeat_size<class_parallax2d_property_repeat_size>`. If you aren't "
"able to obtain assets that are designed for this task, there are some other "
"things you can do to better prepare your image in regards to size."
msgstr ""
"为了方便实现无限重复效果，图像本身最好就需要能够无缝重复，并且需要图像的大小"
"在设置 :ref:`repeat_size<class_parallax2d_property_repeat_size>` **之前**\\ "
"至少要和视口大小一致。如果无法获取合适的资产素材，也有一些方法可以事先处理一"
"下图像的大小。"

msgid "Here is an example of a texture that is too small for its viewport:"
msgstr "下例是一个在视口中显得太小的纹理:"

msgid ""
"We can see that the viewport size is 500x300 but the texture is 288x208. If "
"we set the :ref:`repeat_size<class_parallax2d_property_repeat_size>` to the "
"size of our image, the infinite repeat effect doesn't scroll properly "
"because the original texture doesn't cover the viewport. If we set "
"the :ref:`repeat_size<class_parallax2d_property_repeat_size>` to the size of "
"the viewport, we have a large gap. What can we do?"
msgstr ""
"我们可以看到视口的尺寸是 500x300 而纹理的尺寸是 288x208。如果我们"
"把 :ref:`repeat_size<class_parallax2d_property_repeat_size>` 设置为图像的尺"
"寸，无限重复效果在滚动时就会出问题，因为原始纹理没有覆盖整个视口。如果我们"
"把 :ref:`repeat_size<class_parallax2d_property_repeat_size>` 设置为视口的尺"
"寸，那么就会有一个很大的间隙。那该怎么办呢？"

msgid "Make the viewport smaller"
msgstr "把视口调小"

msgid ""
"The simplest answer is to make the viewport the same size or smaller than "
"your textures. In **Project Settings > Display > Window**, change "
"the :ref:`Viewport Width<class_ProjectSettings_property_display/window/size/"
"viewport_width>` and :ref:`Viewport "
"Height<class_ProjectSettings_property_display/window/size/viewport_height>` "
"settings to match your background."
msgstr ""
"最简单的答案是将视口设置为与纹理大小相同或更小。在 **项目设置 > 显示 > 窗口"
"** 中，更改 :ref:`视口宽度<class_ProjectSettings_property_display/window/"
"size/viewport_width>` 和 :ref:`视口高度"
"<class_ProjectSettings_property_display/window/size/viewport_height>` 设置，"
"使其与背景匹配。"

msgid "Scale the Parallax2D"
msgstr "缩放 Parallax2D"

msgid ""
"If you're not aiming for a pixel-perfect style, or don't mind a little "
"blurriness, you may opt to scale the textures larger to fit your screen. Set "
"the :ref:`scale<class_node2d_property_scale>` of "
"the :ref:`Parallax2D<class_parallax2d>`, and all child textures scale with "
"it."
msgstr ""
"如果你想要实现的不是完美像素风，或者不介意存在略微的模糊，那么你可以选择将纹"
"理放大到适合屏幕的尺寸。请设置 :ref:`Parallax2D<class_parallax2d>` "
"的 :ref:`scale<class_node2d_property_scale>`\\ ，所有子级纹理都会对应发生缩"
"放。"

msgid "Scale the child nodes"
msgstr "缩放子节点"

msgid ""
"Similar to scaling the :ref:`Parallax2D<class_parallax2d>`, you can scale "
"your :ref:`Sprite2D<class_sprite2d>` nodes to be large enough to cover the "
"screen. Keep in mind that some settings "
"like :ref:`Parallax2D.repeat_size<class_parallax2d_property_repeat_size>` "
"and :ref:`Sprite2D.region_rect<class_sprite2d_property_region_rect>` do not "
"take scaling into account, so it's necessary to adjust these values based on "
"the scale."
msgstr ""
"和放大 :ref:`Parallax2D<class_parallax2d>` 类似的是"
"将 :ref:`Sprite2D<class_sprite2d>` 节点放大到能够覆盖住屏幕。请注意，"
"\\ :ref:`Parallax2D.repeat_size<class_parallax2d_property_repeat_size>` "
"和 :ref:`Sprite2D.region_rect<class_sprite2d_property_region_rect>` 等设置并"
"不会考虑缩放，因此这些值也需要根据缩放进行调整。"

msgid "Repeat the textures"
msgstr "重复纹理"

msgid ""
"You can also start off on the right foot by preparing child nodes earlier in "
"the process. If you have a :ref:`Sprite2D<class_sprite2d>` you'd like to "
"repeat, but is too small, you can do the following to repeat it:"
msgstr ""
"你也可以通过提前准备子节点来确保从一开始就走上正确的道路。如果你有一个希望重"
"复的 :ref:`Sprite2D<class_sprite2d>`\\ ，但它的尺寸太小，就可以按照以下步骤来"
"重复它："

msgid ""
"set :ref:`texture_repeat<class_canvasitem_property_texture_repeat>` "
"to :ref:`CanvasItem.TEXTURE_REPEAT_ENABLED<class_canvasitem_constant_TEXTURE_REPEAT_ENABLED>`"
msgstr ""
"将 :ref:`texture_repeat<class_canvasitem_property_texture_repeat>` 设置"
"为 :ref:`CanvasItem.TEXTURE_REPEAT_ENABLED<class_canvasitem_constant_TEXTURE_REPEAT_ENABLED>`"

msgid ""
"set :ref:`region_enabled<class_sprite2d_property_region_enabled>` to ``true``"
msgstr ""
"将 :ref:`region_enabled<class_sprite2d_property_region_enabled>` 设置为 "
"``true``"

msgid ""
"set the :ref:`region_rect<class_sprite2d_property_region_rect>` to a "
"multiple of the size of your texture large enough to cover the viewport."
msgstr ""
"将 :ref:`region_rect<class_sprite2d_property_region_rect>` 设置为纹理大小的倍"
"数，让纹理足够覆盖住视口。"

msgid ""
"Below, you can see that repeating the image twice makes it large enough to "
"cover the screen."
msgstr "下图中可以看到，把图像重复一次就足够覆盖住屏幕了。"

msgid "Poor positioning"
msgstr "位置问题"

msgid ""
"It's common to see users mistakenly set all of their textures to be centered "
"at ``(0,0)``:"
msgstr "用户经常错误地把所有纹理都设成在 ``(0,0)`` 居中："

msgid ""
"This creates problems with the infinite repeat effect and should be avoided. "
"The \"infinite repeat canvas\" starts at ``(0,0)`` and expands down and to "
"the right to the size of "
"the :ref:`repeat_size<class_parallax2d_property_repeat_size>` value."
msgstr ""
"这会给无限重复效果带来问题，应当尽量避免。“无限重复画布”从 ``(0,0)`` 开始，向"
"右下扩展至 :ref:`repeat_size<class_parallax2d_property_repeat_size>` 的大小"
"值。"

msgid ""
"If the textures are centered on the ``(0,0)`` crossing, the infinite repeat "
"canvas is only partly covered, so it only partly repeats."
msgstr ""
"如果纹理是以 ``(0,0)`` 交叉点为中心的，那么无限重复画布只会被部分覆盖，因此也"
"只会部分地重复。"

msgid "Would increasing ``repeat_times`` fix this?"
msgstr "把 ``repeat_times`` 调大有用吗？"

msgid ""
"Increasing :ref:`repeat_times<class_parallax2d_property_repeat_times>` "
"technically *would* work in some scenarios, but is a brute force solution "
"and not the problem it is designed to solve (we'll go over this in a bit). A "
"better fix is to understand how the repeat effect works and set up the "
"parallax textures appropriately to begin with."
msgstr ""
"从技术上来说，增"
"加 :ref:`repeat_times<class_parallax2d_property_repeat_times>` 在某些情况下"
"\\ *将是*\\ 可行的，但这是一种暴力的解决方案，而不是它被设计用于解决的问题"
"（我们稍后会讨论这个问题）。更好的解决方法是理解重复效果的工作原理，并在开始"
"时就适当地设置视差纹理。"

msgid ""
"First, check to see if any textures are spilling over onto the negative "
"parts of the canvas. Make sure the textures used in the parallax nodes fit "
"inside the \"infinite repeat canvas\" starting at ``(0,0)``. That way, "
"if :ref:`Parallax2D.repeat_size<class_parallax2d_property_repeat_size>` is "
"set correctly, it should look something like this, with one single loop of "
"the image the same size or larger than the viewport:"
msgstr ""
"首先，检查是否有任何纹理溢出到画布的负轴向。确保在视差节点中使用的纹理都位于"
"从 ``(0,0)`` 开始的“无限重复画布”内。这样，如果正确设置"
"了 :ref:`Parallax2D.repeat_size<class_parallax2d_property_repeat_size>`，效果"
"应该看起来像这样，图像的单次循环与视口大小相同或更大："

msgid ""
"If you think of how the image scrolls across the screen, it starts by "
"displaying what's inside the red rectangle (determined "
"by :ref:`repeat_size<class_parallax2d_property_repeat_size>`), and when it "
"reaches what's inside the yellow rectangle it zips the image forward to give "
"the illusion of scrolling forever."
msgstr ""
"想象一下图像是如何在屏幕上滚动的，它首先显示红色矩形内的内容"
"（由 :ref:`repeat_size <class_parallax2d_property_repeat_size>` 确定），当到"
"达黄色矩形内时，它会将图像向前拉动，从而给人一种永远滚动的感觉。"

msgid ""
"If you have the image positioned away from the \"infinite repeat canvas\", "
"when the camera reaches the yellow rectangle, half of the image is cut off "
"before it jumps forward like in the image below:"
msgstr ""
"如果你将图像放置在“无限重复画布”之外的位置，当摄像机到达黄色矩形区域时，图像"
"的一半会被裁切掉，然后才会向前跳转，就像下图所示："

msgid "Scroll offset"
msgstr "滚动偏移"

msgid ""
"If your parallax textures are already working correctly, but you prefer it "
"to start at a different point, :ref:`Parallax2D<class_parallax2d>` comes "
"with a :ref:`scroll_offset<class_parallax2d_property_scroll_offset>` "
"property used to offset where the infinite repeat canvas starts. As an "
"example, if your image is 288x208, setting "
"the :ref:`scroll_offset<class_parallax2d_property_scroll_offset>` to "
"``(-144,0)`` or ``(144,0)`` allows it to begin halfway across the image."
msgstr ""
"如果你的视差纹理已经正常工作，但你希望它从不同的点开始，:ref:`Parallax2D "
"<class_parallax2d>` 附带一个 :ref:`scroll_offset "
"<class_parallax2d_property_scroll_offset>` 属性，用于偏移无限重复画布的开始位"
"置。例如，如果你的图像是 288x208，将 :ref:`scroll_offset "
"<class_parallax2d_property_scroll_offset>` 设置为 ``(-144,0)`` 或 "
"``(144,0)`` 可使其从图像的中间位置开始。"

msgid "Repeat times"
msgstr "重复次数"

msgid ""
"Ideally, following this guide, your parallax textures are large enough to "
"cover the screen even when zoomed out. Until now, we have had a perfectly "
"fitting 288x208 texture inside of a 288x208 viewport. However, problems "
"occur when we zoom out by setting "
"the :ref:`Camera2D.zoom<class_camera2d_property_zoom>` to ``(0.5, 0.5)``:"
msgstr ""
"理想情况下，按照本指南操作，你的视差纹理足够大，即使在缩小时也能覆盖屏幕。到"
"目前为止，我们在 288x208 视口内拥有一个完美贴合的 288x208 纹理。但是，当我们"
"通过将 :ref:`Camera2D.zoom<class_camera2d_property_zoom>` 设置为 ``(0.5, "
"0.5)`` 进行缩小时，会出现问题："

msgid ""
"Even though everything is correctly set for the viewport at the default zoom "
"level, zooming out makes it smaller than the viewport, breaking the infinite "
"repeat effect. This is "
"where :ref:`repeat_times<class_parallax2d_property_repeat_times>` can help "
"out. Setting a value of ``3`` (one extra repeat behind and in front), it is "
"now large enough to accommodate the infinite repeat effect."
msgstr ""
"尽管在默认缩放级别下，视口的所有内容都已正确设置，但缩小后会使它小于该视口，"
"从而破坏无限重复效果。这"
"时 :ref:`repeat_times<class_parallax2d_property_repeat_times>` 就可以提供帮"
"助。将值设置为 ``3``\\ （前后各一个额外的重复），现在它就足够大，可以容纳无限"
"重复的效果了。"

msgid ""
"If these textures were meant to be repeated vertically, we would have "
"specified a ``y`` value for "
"the :ref:`repeat_size<class_parallax2d_property_repeat_size>`. "
"The :ref:`repeat_times<class_parallax2d_property_repeat_times>` would "
"automatically add a repeat above and below as well. This is only a "
"horizontal parallax, so it leaves an empty block above and below the image. "
"How do we solve this? We need to get creative! In this example, we stretch "
"the sky higher, and grass sprite lower. The textures now support the normal "
"zoom level and zooming out to half size."
msgstr ""
"如果这些纹理需要垂直地重复，我们应该为 :ref:`repeat_size "
"<class_parallax2d_property_repeat_size>` 指定一个 ``y`` "
"值。:ref:`repeat_times <class_parallax2d_property_repeat_times>` 也会自动在上"
"方和下方添加重复。这只是一个水平视差，因此它会在图像上方和下方留下一个空白"
"块。我们如何解决这个问题？我们需要发挥创造力！在这个例子中，我们将天空拉高，"
"将草精灵拉低。纹理现在支持正常缩放级别以及缩小到一半大小。"

msgid "Split screen"
msgstr "分屏"

msgid ""
"Most tutorials for making a split screen game in Godot begin by writing a "
"small script to assign "
"the :ref:`Viewport.world_2d<class_viewport_property_world_2d>` of the first "
"SubViewport to the second, so they have a shared display. Questions often "
"pop up about how to share a parallax effect between both screens."
msgstr ""
"大多数用 Godot 制作分屏游戏的教程一开始都是要写一个简单的脚本，把第一个 "
"SubViewport 的 :ref:`Viewport.world_2d<class_viewport_property_world_2d>` 赋"
"值给第二个 SubViewport，从而实现屏幕的共享。此时就会产生如何在这两个屏幕之间"
"共享视差效果的问题。"

msgid ""
"The parallax effect fakes a perspective by moving the positions of different "
"textures in relation to the camera. This is understandably problematic if "
"you have multiple cameras, because your textures can't be in two places at "
"once!"
msgstr ""
"视差效果模拟透视的方法是让不同的纹理根据其与相机的关系移动不同的距离。存在多"
"个相机时，很显然就会出现问题，因为同一个纹理不可能同时出现在两个不同的地方！"

msgid ""
"This is still achievable by cloning the parallax nodes into the second (or "
"third or fourth) :ref:`SubViewport<class_subviewport>`. Here's how a setup "
"looks for a two player game:"
msgstr ""
"解决方法也是有的，把视差节点往第二个（或者第三第四"
"个） :ref:`SubViewport<class_subviewport>` 里复制一份就好了。在双人游戏里是这"
"个样子的："

msgid ""
"Of course, now both backgrounds show in both SubViewports. What we want is "
"for each parallax to only show in their corresponding viewport. We can "
"achieve this by doing the following:"
msgstr ""
"当然，现在两个背景都会在两个 SubViewport 中显示。我们希望的是每个视差背景只在"
"其对应的视口中显示。你可以通过以下方式实现这一点："

msgid ""
"Leave all parallax nodes at their "
"default :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` "
"of 1."
msgstr ""
"将所有视差节点"
"的 :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` 保留为"
"其默认值 1 。"

msgid ""
"Set the first "
"SubViewport's :ref:`canvas_cull_mask<class_viewport_property_canvas_cull_mask>` "
"to only layers 1 and 2."
msgstr ""
"将第一个 SubViewport "
"的 :ref:`canvas_cull_mask<class_viewport_property_canvas_cull_mask>` 设置为仅"
"显示层 1 和 2。"

msgid "Do the same for the second SubViewport but use layers 1 and 3."
msgstr "对第二个 SubViewport 执行相同的操作，但使用图层 1 和 图层 3。"

msgid ""
"Give your parallax nodes in the first SubViewport a common parent and set "
"its :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` to 2."
msgstr ""
"为第一个 SubViewport 中的视差节点提供一个共同的父节点，并将"
"其 :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` 设置"
"为 2。"

msgid ""
"Do the same for the second SubViewport's parallax nodes, but use a layer of "
"3."
msgstr "对第二个 SubViewport 的视差节点执行相同的操作，但使用 3 号图层。"

msgid ""
"How does this work? If a canvas item has "
"a :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` that "
"doesn't match the "
"SubViewport's :ref:`canvas_cull_mask<class_viewport_property_canvas_cull_mask>`, "
"it will hide all children, even if they do. We use this to our advantage, "
"letting the SubViewports cut off rendering of parallax nodes whose parent "
"doesn't have a "
"supported :ref:`visibility_layer<class_canvasitem_property_visibility_layer>`."
msgstr ""
"这是如何工作的？如果一个画布项"
"的 :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` 与 "
"SubViewport "
"的 :ref:`canvas_cull_mask<class_viewport_property_canvas_cull_mask>` 不匹配，"
"它将隐藏所有子节点，即使它们匹配也是如此。我们利用这一点，让 SubViewport 停止"
"那些父节点没有匹配"
"的 :ref:`visibility_layer<class_canvasitem_property_visibility_layer>` 的视差"
"节点的渲染。"

msgid "Previewing in the editor"
msgstr "在编辑器中预览"

msgid ""
"Prior to 4.3, the recommendation was to place every layer in their "
"own :ref:`ParallaxBackground<class_parallaxbackground>`, enable "
"the :ref:`follow_viewport_enabled<class_canvaslayer_property_follow_viewport_enabled>` "
"property, and scale the individual layer. This method has always been tricky "
"to get right, but is still achievable by using "
"a :ref:`CanvasLayer<class_canvaslayer>` instead of "
"a :ref:`ParallaxBackground<class_parallaxbackground>`."
msgstr ""
"4.3 版本之前推荐的是把每个层都放到各自"
"的 :ref:`ParallaxBackground<class_parallaxbackground>` 下面，然后启"
"用 :ref:`follow_viewport_enabled<class_canvaslayer_property_follow_viewport_enabled>` "
"属性，再对各个层进行缩放。这个方法要用对还挺难的，"
"用 :ref:`CanvasLayer<class_canvaslayer>` 代"
"替 :ref:`ParallaxBackground<class_parallaxbackground>` 也能达到想要的效果。"

msgid ""
"Another recommendation is `KoBeWi's \"Parallax2D Preview\" addon <https://"
"github.com/KoBeWi/Godot-Parallax2D-Preview>`_. It provides a few different "
"preview modes and is very handy!"
msgstr ""
"另外推荐 `KoBeWi 的“Parallax2D Preview”插件 <https://github.com/KoBeWi/Godot-"
"Parallax2D-Preview>`_\\ 。这个插件提供了很多预览模式，挺好用的！"
