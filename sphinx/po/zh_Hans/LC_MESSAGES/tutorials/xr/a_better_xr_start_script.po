#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "A better XR start script"
msgstr "更好的 XR 启动脚本"

msgid ""
"In :ref:`doc_setting_up_xr` we introduced a startup script that initialises "
"our setup which we used as our script on our main node. This script performs "
"the minimum steps required for any given interface."
msgstr ""
"在 :ref:`doc_setting_up_xr` 中，我们介绍了一个用于初始化配置的启动脚本，并将"
"其作为主节点脚本使用，以执行任何接口部署所需的最小步骤。"

msgid ""
"When using OpenXR there are a number of improvements we should do here. For "
"this we've created a more elaborate starting script. You will find these "
"used in our demo projects."
msgstr ""
"使用 OpenXR 时，这个脚本最好进行一些改进。为此，我们重新编写了一个更为详尽的"
"启动脚本。你可以在演示项目中找到它。"

msgid ""
"Alternatively, if you are using XR Tools "
"(see :ref:`doc_introducing_xr_tools`) it contains a version of this script "
"updated with some features related to XR tools."
msgstr ""
"除此以外，如果你使用 XR 工具（见 :ref:`doc_introducing_xr_tools`），它也包含"
"了另一个版本的启动脚本，那个版本在源代码基础上添加了一些与 XR 工具相关联的功"
"能。"

msgid ""
"Below we will detail out the script used in our demos and explain the parts "
"that are added."
msgstr "下面将详细介绍演示中使用的脚本，并解释添加的部分。"

msgid "Signals for our script"
msgstr "脚本的信号"

msgid ""
"We are introducing 3 signals to our script so that our game can add further "
"logic:"
msgstr "我们在脚本中引入了 3 个信号以方便在游戏中添加更多逻辑："

msgid ""
"``focus_lost`` is emitted when the player takes off their headset or when "
"the player enters the menu system of the headset."
msgstr ""
"``focus_lost`` 作为检测玩家摘下头戴设备或进入头戴设备的菜单系统时的触发器。"

msgid "Our game should react accordingly to these signals."
msgstr "我们的游戏将根据这些信号作出相应的反应。"

msgid "Variables for our script"
msgstr "脚本的变量"

msgid "We introduce a few new variables to our script as well:"
msgstr "我们还向脚本引入了几个新变量："

msgid ""
"``maximum_refresh_rate`` will control the headsets refresh rate if this is "
"supported by the headset."
msgstr ""
"``maximum_refresh_rate`` 将控制头显设备的刷新率——如果头显设备支持控制的话。"

msgid ""
"``xr_interface`` holds a reference to our XR interface, this already existed "
"but we now type it to get full access to our :ref:`XRInterface "
"<class_xrinterface>` API."
msgstr ""
"``xr_interface`` 保存了对我们的 XR 接口的引用，这个变量其实已经存在，但现在我"
"们将其类型化，以便更好地访问 :ref:`XRInterface <class_xrinterface>` API。"

msgid "``xr_is_focussed`` will be set to true whenever our game has focus."
msgstr "``xr_is_focussed`` 将在我们的游戏获得焦点时设置为 true。"

msgid "Our updated ready function"
msgstr "更新后的 `_ready` 函数"

msgid "We add a few things to the ready function."
msgstr "我们在 ``_ready`` 函数中新加了一些东西。"

msgid ""
"We hook up a number of signals that will be emitted by the :ref:`XRInterface "
"<class_xrinterface>`. We'll provide more detail about these signals as we "
"implement them."
msgstr ""
"这些信号将由 :ref:`XRInterface <class_xrinterface>` 触发。随着实现的深入，后"
"续将提供更多关于这些信号的详细信息。"

msgid ""
"We also quit our application if we couldn't successfully initialise OpenXR. "
"Now this can be a choice. If you are making a mixed mode game you setup the "
"VR mode of your game on success, and setup the non-VR mode of your game on "
"failure. However, when running a VR only application on a standalone "
"headset, it is nicer to exit on failure than to hang the system."
msgstr ""
"如果我们无法顺利启动 OpenXR ，我们也会选择退出应用。对于混合现实游戏的开发来"
"说，你可以在成功初始化后进入 VR 模式，若失败再切换至非 VR 模式。不过，在一个"
"独立的 VR 设备上运行仅支持 VR 的应用，启动失败时直接退出程序会比让系统挂着更"
"合适。"

msgid "On session begun"
msgstr "会话开始"

msgid ""
"This signal is emitted by OpenXR when our session is setup. This means the "
"headset has run through setting everything up and is ready to begin "
"receiving content from us. Only at this time various information is properly "
"available."
msgstr ""
"该信号由 OpenXR 在我们设置会话时发出。意味着头戴设备已经完成了所有设置，并准"
"备好开始接收程序内容。只有此时，各种信息才能正确地获取到。"

msgid ""
"Finally we match our physics update rate to our headset update rate. Godot "
"runs at a physics update rate of 60 updates per second by default while "
"headsets run at a minimum of 72, and for modern headsets often up to 144 "
"frames per second. Not matching the physics update rate will cause "
"stuttering as frames are rendered without objects moving."
msgstr ""
"最后，我们将物理更新速率与头戴设备的更新速率相匹配。Godot 默认物理帧刷新率为"
"每秒 60 帧，而头戴设备通常至少以每秒 72 帧运行，较为先进的型号能高达 144 "
"帧 / 秒。如果不将物理帧刷新率相匹配，将导致设备在对象尚未移动前过早开始渲染，"
"导致画面出现卡顿。"

msgid "On visible state"
msgstr "进入可见状态"

msgid ""
"If you've added this script to your root node, this means your game will "
"automatically pause when required. If you haven't, you can connect a method "
"to the signal that performs additional changes."
msgstr ""
"如果你将此脚本添加到根节点，这意味着你的游戏将在需要时自动暂停。如果没有，你"
"可以将方法连接到该信号，以执行额外的更改。"

msgid ""
"While your game is in visible state because the user has opened a system "
"menu, Godot will keep rendering frames and head tracking will remain active "
"so your game will remain visible in the background. However controller and "
"hand tracking will be disabled until the user exits the system menu."
msgstr ""
"如果游戏是因当用户打开系统菜单而处于可见状态，Godot 会继续渲染帧并保持头部跟"
"踪活跃，因此游戏会在后台保持可见。然而，控制器和手部跟踪将被禁用，直到用户退"
"出系统菜单为止。"

msgid "On focussed state"
msgstr "进入聚焦状态"

msgid ""
"This signal is emitted by OpenXR when our game gets focus. This is done at "
"the completion of our startup, but it can also be emitted when the user "
"exits a system menu, or put their headset back on."
msgstr ""
"OpenXR 会在游戏获得聚焦时发出这个信号。这会在启动完成时触发，但也可能在用户退"
"出系统菜单或重新戴上头戴设备时触发。"

msgid ""
"Note also that when your game starts while the user is not wearing their "
"headset, the game stays in 'visible' state until the user puts their headset "
"on."
msgstr ""
"同时注意，当游戏在用户未佩戴头戴设备时启动，游戏会保持在可见状态，直到用户戴"
"上头戴设备。"

msgid "On stopping state"
msgstr "进入停止状态"

msgid ""
"This signal is emitted by OpenXR when we enter our stop state. There are "
"some differences between platforms when this happens. On some platforms this "
"is only emitted when the game is being closed. But on other platforms this "
"will also be emitted every time the player takes off their headset."
msgstr ""
"OpenXR 会在进入停止状态时发出这个信号。不同平台在该情况下的表现会有所不同。一"
"部分平台只会在游戏关闭时发出此信号，另一部分在玩家摘下头戴设备时也会发出。"

msgid "For now this method is only a place holder."
msgstr "目前为止，该方法只充当一个占位符。"

msgid "On pose recentered"
msgstr "姿势重新居中"

msgid ""
"This signal is emitted by OpenXR when the user requests their view to be "
"recentered. Basically this communicates to your game that the user is now "
"facing forward and you should re-orient the player so they are facing "
"forward in the virtual world."
msgstr ""
"当用户请求重新定位视角时，OpenXR 会发出此信号。该信号主要用于告诉你的游戏：用"
"户现在面朝前方，你应该重新定位玩家，使其在虚拟世界中面朝前方。"

msgid ""
"As doing so is dependent on your game, your game needs to react accordingly."
msgstr ""
"由于重新定位视角依赖于游戏设计，因此你的游戏需要被设计能正确地做出反应。"

msgid ""
"All we do here is emit the ``pose_recentered`` signal. You can connect to "
"this signal and implement the actual recenter code. Often it is enough to "
"call :ref:`center_on_hmd() <class_XRServer_method_center_on_hmd>`."
msgstr ""
"下面这段代码里，我们只是发出 ``pose_recentered`` 信号，并未提供用户重新定位的"
"代码实现。你可以连接到这个信号并自行实现它。通常调用 :ref:`center_on_hmd() "
"<class_XRServer_method_center_on_hmd>` 就足够了。"

msgid ""
"And that finished our script. It was written so that it can be re-used over "
"multiple projects. Just add it as the script on your main node (and extend "
"it if needed) or add it on a child node specific for this script."
msgstr ""
"这样就完成了我们的脚本。它被设计为能够重复利用。只需将它添加为主节点的脚本"
"（如有需要还可以进行扩展），或者添加到专门用于此脚本的子节点上。"
