#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logging"
msgstr "日志"

msgid "Godot comes with several ways to organize and collect log messages."
msgstr "Godot 提供了多种方式来组织和收集日志消息。"

msgid "Printing messages"
msgstr "打印消息"

msgid ""
"See :ref:`doc_output_panel_printing_messages` for instructions on printing "
"messages. The printed output is generally identical to the logged output."
msgstr ""
"有关打印消息的说明，请参阅:ref:`doc_output_panel_printing_messages`。打印输出"
"的内容通常与日志输出内容一致。"

msgid "Project settings"
msgstr "项目设置"

msgid ""
"**Application > Run > Disable stdout:** Disables logging to standard output "
"entirely. This also affects what custom loggers receive. This can be "
"controlled at runtime by setting :ref:`Engine.print_to_stdout "
"<class_Engine_property_print_to_stdout>`."
msgstr ""
"**应用程序 > 运行 > 禁用标准输出（Application > Run > Disable stdout）：** 完"
"全禁用向标准输出的日志记录。这也会影响自定义日志记录器接收到的内容。可在运行"
"时通过设置:ref:`Engine.print_to_stdout "
"<class_Engine_property_print_to_stdout>`来控制此选项。"

msgid ""
"**Application > Run > Disable stderr:** Disables logging to standard error "
"entirely. This also affects what custom loggers receive. This can be "
"controlled at runtime by setting :ref:`Engine.print_error_messages "
"<class_Engine_property_print_error_messages>`."
msgstr ""
"**应用程序 > 运行 > 禁用标准错误（Application > Run > Disable stderr）：** 完"
"全禁用向标准错误输出的日志记录。这也会影响自定义日志记录器接收到的内容。可在"
"运行时通过设置:ref:`Engine.print_error_messages "
"<class_Engine_property_print_error_messages>`来控制此选项。"

msgid ""
"**Debug > Settings > stdout > Verbose stdout:** Enables verbose logging to "
"standard output. Prints from :ref:`print_verbose() "
"<class_@GlobalScope_method_print_verbose>` are only visible if verbose mode "
"is enabled."
msgstr ""
"**调试 > 设置 > 标准输出 > 详细标准输出（Debug > Settings > stdout > Verbose "
"stdout）：** 启用向标准输出的详细日志记录。仅当启用详细模式"
"时，:ref:`print_verbose() <class_@GlobalScope_method_print_verbose>`的输出内"
"容才会显示。"

msgid ""
"**Debug > Settings > stdout > Print FPS:** Prints the frames per second "
"every second, as well as the V-Sync status on startup (as it can effectively "
"cap the maximum framerate)."
msgstr ""
"**调试 > 设置 > 标准输出 > 打印 FPS（Debug > Settings > stdout > Print "
"FPS）：** 每秒打印一次帧率（FPS），并在启动时打印垂直同步（V-Sync）状态（因为"
"它可能有效限制最大帧率）。"

msgid ""
"**Debug > Settings > stdout > Print GPU Profile:** Prints a report of GPU "
"utilization every second, using the same data source as "
"the :ref:`doc_debugger_panel_visual_profiler`."
msgstr ""
"**调试 > 设置 > 标准输出 > 打印 GPU 性能分析（Debug > Settings > stdout > "
"Print GPU Profile）：** 每秒打印一次 GPU 使用情况报告，数据来源"
"与 :ref:`doc_debugger_panel_visual_profiler`相同。"

msgid ""
"Some of these project settings can also be overridden using :ref:`command "
"line arguments <doc_command_line_tutorial>` such as ``--quiet``, ``--"
"verbose``, and ``--print-fps``."
msgstr ""
"这些项目设置中的一部分也可以通过 :ref:`command line arguments "
"<doc_command_line_tutorial>` 进行覆盖，例如 ``--quiet``（静默模式）、``--"
"verbose``（详细模式）和 ``--print-fps``（打印帧率）。"

msgid ""
"The engine's own file logging is also configurable, as described in the "
"section below."
msgstr "引擎自身的文件日志记录功能也可进行配置，具体说明见下文。"

msgid ""
"Since Godot 4.5, when GDScript code encounters an error, it will log a "
"backtrace that points to the origin of the error, while also containing the "
"call stack leading to it. This behavior is always enabled when running in "
"the editor, or when the project is exported in debug mode."
msgstr ""
"自 Godot 4.5 起，当 GDScript 代码遇到错误时，会记录一个指向错误源头的回溯信息"
"（backtrace），并包含导致该错误的调用栈。此功能在编辑器内运行或项目以调试模式"
"导出时始终启用。"

msgid ""
"In projects exported in release mode, backtraces are disabled by default for "
"performance reasons. You can enable them by checking **Debug > Settings > "
"GDScript > Always Track Call Stacks** in the Project Settings. If you use a "
"custom logging system that reports exceptions to a remote service, it's "
"recommended to enable this to make reported errors more actionable."
msgstr ""
"在以发布模式导出的项目中，出于性能考虑，默认禁用回溯功能。您可以通过在项目设"
"置中勾选 **调试 > 设置 > GDScript > 始终跟踪调用栈（Debug > Settings > "
"GDScript > Always Track Call Stacks）** 来启用该功能。如果您使用自定义日志系"
"统将异常上报至远程服务，建议启用此选项，以便让上报的错误信息更具可操作性。"

msgid "Crash backtraces"
msgstr "崩溃回溯"

msgid ""
"Crash backtraces are only useful if they were recorded in a build that "
"contains :ref:`debugging symbols "
"<doc_introduction_to_the_buildsystem_debugging_symbols>`. Official Godot "
"binaries do not contain debugging symbols, so you must compile a custom "
"editor or export template binary to get useful crash backtraces."
msgstr ""
"崩溃回溯仅在包含 :ref:`debugging symbols "
"<doc_introduction_to_the_buildsystem_debugging_symbols>` 的构建版本中才有实际"
"意义。官方发布的 Godot 二进制文件不包含调试符号，因此您必须自行编译自定义的编"
"辑器或导出模板二进制文件，才能获得有用的崩溃回溯信息。"

msgid ""
"When the project crashes, a crash backtrace is printed to the standard error "
"stream. This is what it can look like in a build with debug symbols:"
msgstr ""
"当项目崩溃时，崩溃回溯信息会被打印到标准错误流。在包含调试符号的构建版本中，"
"其输出可能如下所示："

msgid ""
"On the other hand, without debug symbols, it will look like this instead:"
msgstr "另一方面，如果没有调试符号，输出将如下所示："

msgid ""
"This backtrace is also logged to the file for the current session, but it is "
"**not** visible in the editor Output panel. Since the engine's scripting "
"system is not running anymore when the engine is crashing, it is not "
"possible to access it from scripting in the same session. However, you can "
"still read the crash backtrace on the next session by loading log files and "
"searching for the crash backtrace string (``Program crashed with signal``) "
"using :ref:`class_FileAccess`. This allows you to access the backtrace "
"information even after a crash, as long as the user restarts the project and "
"file logging is enabled:"
msgstr ""
"此回溯信息也会被记录到当前会话的日志文件中，但 **not** 显示在编辑器的输出面板"
"中。由于引擎崩溃时脚本系统已停止运行，因此无法在同一次会话中通过脚本访问该信"
"息。不过，您仍可在下一次会话中通过加载日志文件，并使"
"用 :ref:`class_FileAccess` 搜索崩溃回溯字符串（``Program crashed with "
"signal``）来读取崩溃回溯内容。只要用户重新启动项目且已启用文件日志记录，即可"
"在崩溃后获取回溯信息："

msgid ""
"You can customize the message that appears at the top of the backtrace using "
"the **Debug > Settings > Crash Handler > Message** project setting. This can "
"be used to point to a URL or email address that users can report issues to."
msgstr ""
"您可以通过 **调试 > 设置 > 崩溃处理器 > 消息（Debug > Settings > Crash "
"Handler > Message）** 项目设置，自定义回溯信息顶部显示的消息内容。此功能可用"
"于引导用户访问指定的网址或邮箱地址，以便提交问题反馈。"

msgid ""
"Since Godot 4.5, it is possible to create custom loggers. This custom "
"logging can be used for many purposes:"
msgstr ""
"自 Godot 4.5 起，可以创建自定义日志记录器。自定义日志功能可用于多种用途："

msgid ""
"Show an in-game console with the same messages as printed by the engine, "
"without requiring other scripts to be modified."
msgstr "在游戏内显示一个控制台，展示与引擎输出相同的消息，而无需修改其他脚本。"

msgid ""
"Report printed errors from the player's machine to a remote server. This can "
"make it easier for developers to fix bugs when the game is already released, "
"or during playtesting."
msgstr ""
"将玩家设备上打印的错误信息上报至远程服务器。这有助于开发者在游戏已发布或进行"
"试玩测试时更便捷地修复错误。"

msgid "Integrate a dedicated server export with monitoring platforms."
msgstr "将专用服务器导出版本与监控平台集成。"

msgid ""
"A custom logger can be registered by creating a class that inherits "
"from :ref:`class_logger`, then passing an instance of this class "
"to :ref:`OS.add_logger <class_OS_method_add_logger>`, in a "
"script's :ref:`_init() <class_Object_private_method__init>` method. A good "
"place to do this is an :ref:`autoload <doc_singletons_autoload>`."
msgstr ""
"可通过创建一个继承自 :ref:`class_logger` 的类来注册自定义日志记录器，然后在脚"
"本的 :ref:`OS.add_logger <class_OS_method_add_logger>` 方法中，将该类的实例传"
"递给 :ref:`_init() <class_Object_private_method__init>`。一个合适的实现位置"
"是 :ref:`autoload <doc_singletons_autoload>`。"

msgid ""
"The class must define two methods: :ref:`_log_message() "
"<class_Logger_private_method__log_message>` and :ref:`_log_error() "
"<class_Logger_private_method__log_error>`."
msgstr ""
"该类必须定义两个方法：:ref:`_log_message() "
"<class_Logger_private_method__log_message>` 和 :ref:`_log_error() "
"<class_Logger_private_method__log_error>`。"

msgid ""
"Here is a minimal working example of a custom logger, with the script added "
"as an autoload:"
msgstr ""
"以下是一个最小可运行的自定义日志记录器示例，该脚本已作为自动加载（autoload）"
"添加："

msgid ""
"Note that to avoid infinite recursion, you cannot effectively "
"use :ref:`print() <class_@GlobalScope_method_print>` and its related methods "
"in ``_log_message()``. You also can't effectively use :ref:`push_error() "
"<class_@GlobalScope_method_push_error>` or :ref:`push_warning() "
"<class_@GlobalScope_method_push_warning>` in ``_log_error()``. Attempting to "
"do so will print a message to the same stream as the original message. This "
"message is not available in the custom logger, which is what prevents "
"infinite recursion from occurring:"
msgstr ""
"请注意，为避免无限递归，在 ``_log_message()`` 中不能有效使用 :ref:`print() "
"<class_@GlobalScope_method_print>` 及其相关方法；同样，在 ``_log_error()`` 中"
"也不能有效使用 :ref:`push_error() <class_@GlobalScope_method_push_error>` "
"或 :ref:`push_warning() <class_@GlobalScope_method_push_warning>`。若尝试这样"
"做，消息将被输出到与原始消息相同的流中，而该消息对自定义日志记录器不可见，这"
"正是防止无限递归发生的原因："
