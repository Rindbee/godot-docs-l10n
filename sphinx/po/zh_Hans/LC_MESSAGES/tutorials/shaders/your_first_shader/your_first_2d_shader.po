#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 2D shader"
msgstr "你的第一个 2D 着色器"

msgid "Introduction"
msgstr "前言"

msgid ""
"Shaders are special programs that execute on the GPU and are used for "
"rendering graphics. All modern rendering is done with shaders. For a more "
"detailed description of what shaders are please see :ref:`What are shaders "
"<doc_introduction_to_shaders>`."
msgstr ""
"着色器是在 GPU 上运行，用来渲染图像的一种特殊程序。现代渲染都是通过着色器实现"
"的。若想了解关于着色器更详细的说明，请查看\\ :ref:`着色器是什么 "
"<doc_introduction_to_shaders>`\\ 。"

msgid ""
"This tutorial will focus on the practical aspects of writing shader programs "
"by walking you through the process of writing a shader with both vertex and "
"fragment functions. This tutorial targets absolute beginners to shaders."
msgstr ""
"本教程将通过带领你逐步完成一个包含顶点函数和片段函数的着色器编写过程，着重介"
"绍着色器程序的实用编写方法。本教程面向着色器的初学者。"

msgid ""
"If you have experience writing shaders and are just looking for an overview "
"of how shaders work in Godot, see the :ref:`Shading Reference <toc-shading-"
"reference>`."
msgstr ""
"如果你在着色器方面有一定的经验，只是想知道着色器在 Godot 中是如何运作的，请参"
"阅\\ :ref:`着色器参考 <toc-shading-reference>`\\ 。"

msgid "Setup"
msgstr "场景布置"

msgid ""
":ref:`CanvasItem shaders <doc_canvas_item_shader>` are used to draw all 2D "
"objects in Godot, while :ref:`Spatial <doc_spatial_shader>` shaders are used "
"to draw all 3D objects."
msgstr ""
":ref:`CanvasItem 着色器 <doc_canvas_item_shader>`\\ 在 Godot 中是用来绘制所"
"有 2D 对象的，而 :ref:`Spatial <doc_spatial_shader>` 着色器则用于绘制所有 3D "
"对象。"

msgid ""
"In order to use a shader it must be attached inside a :ref:`Material "
"<class_Material>` which must be attached to an object. Materials are a type "
"of :ref:`Resource <doc_resources>`. To draw multiple objects with the same "
"material, the material must be attached to each object."
msgstr ""
"要使用着色器，它必须被附加到一个 :ref:`Material <class_Material>`\\ （材质）"
"上，而这个材质也必须附加到一个对象上。材质是一种 :ref:`Resource "
"<doc_resources>`\\ （资源）。若要使用相同的材质绘制多个对象，该材质必须附加到"
"每个对象上。"

msgid ""
"All objects derived from a :ref:`CanvasItem <class_CanvasItem>` have a "
"material property. This includes all :ref:`GUI elements "
"<class_Control>`, :ref:`Sprite2Ds <class_Sprite2D>`, :ref:`TileMapLayers "
"<class_TileMapLayer>`, :ref:`MeshInstance2Ds <class_MeshInstance2D>` etc. "
"They also have an option to inherit their parent's material. This can be "
"useful if you have a large number of nodes that you want to use the same "
"material."
msgstr ""
"所有继承自 :ref:`CanvasItem <class_CanvasItem>` 的对象都有一个材质属性。包括"
"所有的 :ref:`GUI elements <class_Control>` 、 :ref:`Sprite2Ds "
"<class_Sprite2D>` 、 :ref:`TileMapLayers "
"<class_TileMapLayer>` 、 :ref:`MeshInstance2Ds <class_MeshInstance2D>` 等等。"
"它们同时也可以选择性地继承其父类的材质。当你有很多节点都想使用同一个材质，这"
"个特性就可以派上用场。"

msgid ""
"To begin, create a Sprite2D node. :ref:`You can use any CanvasItem "
"<doc_custom_drawing_in_2d>`, so long as it is drawing to the canvas, so for "
"this tutorial we will use a Sprite2D, as it is the easiest CanvasItem to "
"start drawing with."
msgstr ""
"首先，创建一个 Sprite2D 节点。:ref:`你可以使用任何 CanvasItem "
"<doc_custom_drawing_in_2d>`，只要它是在画布上绘制的，因此在本教程中我们将使"
"用 Sprite2D，因为它是最易上手绘制的 CanvasItem。"

msgid ""
"In the Inspector, click beside \"Texture\" where it says \"[empty]\" and "
"select \"Load\", then select \"icon.svg\". For new projects, this is the "
"Godot icon. You should now see the icon in the viewport."
msgstr ""
"在“检查器”中，点击“Texture”旁边写着“<空>”的地方然后选择“加载”，再选"
"择“icon.svg”。这个就是新项目中的 Godot 图标。你现在应该能在视口中看到这个图标"
"了。"

msgid ""
"Next, look down in the Inspector, under the CanvasItem section, click beside "
"\"Material\" and select \"New ShaderMaterial\". This creates a new Material "
"resource. Click on the sphere that appears. Godot currently doesn't know "
"whether you are writing a CanvasItem Shader or a Spatial Shader and it "
"previews the output of spatial shaders. So what you are seeing is the output "
"of the default Spatial Shader."
msgstr ""
"接下来，在“检查器”下的 CanvasItem 部分中，在“Material”旁点击并选择“新建 "
"ShaderMaterial”。这会创建一个新的材质资源。然后点击新出现的球体。Godot 目前还"
"不知道你是要写 CanvasItem 着色器还是 Spatial 着色器，它显示 Spatial 着色器的"
"输出预览，所以你看到的是默认的 Spatial 着色器的输出。"

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
"继承自 :ref:`class_Material` 资源的材质，例"
"如 :ref:`class_StandardMaterial3D` 和 :ref:`class_ParticleProcessMaterial`，"
"可以转换为 :ref:`class_ShaderMaterial`，并且它们现有的属性将被转换为附带的文"
"本着色器。要执行此操作，请在文件系统面板中右键单击材质并选择**转换为 "
"ShaderMaterial**。你也可以通过在检查器中右键单击任何持有材质引用的属性来完成"
"此操作。"

msgid ""
"Click beside \"Shader\" and select \"New Shader\". Finally, click on the "
"shader you just created and the shader editor will open. You are now ready "
"to begin writing your first shader."
msgstr ""
"点击“Shader”旁边的位置并选择“新建着色器”。最后，双击你刚刚新建的着色器，着色"
"器编辑器将会打开。现在你已准备好开始编写第一个着色器了。"

msgid "Your first CanvasItem shader"
msgstr "你的第一个 CanvasItem 着色器"

msgid ""
"In Godot, all shaders start with a line specifying what type of shader they "
"are. It uses the following format:"
msgstr "在Godot中, 所有的着色器第一行都是指定着色器类型的, 格式如下:"

msgid ""
"Because we are writing a CanvasItem shader, we specify ``canvas_item`` in "
"the first line. All our code will go beneath this declaration."
msgstr ""
"因为我们正在编写 CanvasItem 着色器，所以我们在第一行中指定了 "
"``canvas_item`` 。我们所有的代码都会在这个声明下面。"

msgid ""
"This line tells the engine which built-in variables and functionality to "
"supply you with."
msgstr "这一行告诉游戏引擎要向你提供哪些内置变量以及函数。"

msgid ""
"In Godot you can override three functions to control how the shader "
"operates; ``vertex``, ``fragment``, and ``light``. This tutorial will walk "
"you through writing a shader with both vertex and fragment functions. Light "
"functions are significantly more complex than vertex and fragment functions "
"and so will not be covered here."
msgstr ""
"在 Godot 中，你可以重写三个函数来控制着色器的运作，它们是 ``vertex`` (顶点函"
"数)、 ``fragment`` (片段函数)和 ``light`` (光照函数)。本教程会引导你写出一个"
"包含顶点和片段函数的着色器。因为光照函数比另外两个函数要复杂得多，所以在这里"
"不会进行讲解。"

msgid "Your first fragment function"
msgstr "你的第一个片段函数"

msgid ""
"The fragment function runs for every pixel in a Sprite2D and determines what "
"color that pixel should be."
msgstr "片段函数会为 Sprite2D 的每个像素运行，并决定该像素应显示的颜色。"

msgid ""
"They are restricted to the pixels covered by the Sprite2D, that means you "
"cannot use one to, for example, create an outline around a Sprite2D."
msgstr ""
"它们的作用范围仅限于 Sprite2D 所覆盖的像素区域。这意味着，你无法用它来实现诸"
"如在 Sprite2D 周围创建轮廓之类的效果。"

msgid ""
"The most basic fragment function does nothing except assign a single color "
"to every pixel."
msgstr "最基础的片段函数仅将所有像素设置为单一颜色，不执行其他任何操作。"

msgid ""
"We do so by writing a ``vec4`` to the built-in variable ``COLOR``. ``vec4`` "
"is shorthand for constructing a vector with 4 numbers. For more information "
"about vectors see the :ref:`Vector math tutorial <doc_vector_math>`. "
"``COLOR`` is both an input variable to the fragment function and the final "
"output from it."
msgstr ""
"我们通过向内置变量 ``COLOR`` 写入一个 ``vec4`` 类型的值来实现此操作。 "
"``vec4`` 是创建包含4个数字的向量的简写。有关向量的更多信息，请参阅 :ref:`向量"
"数学教程 <doc_vector_math>`。 ``COLOR`` 既是片段函数的输入变量，也是其最终输"
"出。"

msgid ""
"Congratulations! You're done. You have successfully written your first "
"shader in Godot."
msgstr "恭喜你！你成功在 Godot 中写出了你的第一个着色器。"

msgid "Now let's make things more complex."
msgstr "现在让我们将事情变得复杂一些。"

msgid ""
"There are many inputs to the fragment function that you can use for "
"calculating ``COLOR``. ``UV`` is one of them. UV coordinates are specified "
"in your Sprite2D (without you knowing it!) and they tell the shader where to "
"read from textures for each part of the mesh."
msgstr ""
"片段函数有许多可用于计算 ``COLOR`` 的输入参数， ``UV`` 便是其中之一。UV 坐标"
"已在你的 Sprite2D 中定义（在你不知情的情况下！），它们告诉着色器应从纹理的哪"
"个位置为网格的每个部分读取颜色信息。"

msgid ""
"In the fragment function you can only read from ``UV``, but you can use it "
"in other functions or to assign values to ``COLOR`` directly."
msgstr ""
"在片段函数中，你只能从 ``UV`` 读取它的值，但你可以将其用于其他函数的计算，或"
"直接赋值给 ``COLOR`` 。"

msgid "``UV`` varies between 0-1 from left-right and from top-bottom."
msgstr "``UV`` 的取值在 0 到 1 之间，从左至右、从上至下递增。"

msgid "Using ``TEXTURE`` built-in"
msgstr "使用内置变量 ``TEXTURE``"

msgid ""
"The default fragment function reads from the set Sprite2D texture and "
"displays it."
msgstr "默认的片段函数会读取 Sprite2D 设置的纹理并将其显示出来。"

msgid ""
"When you want to adjust a color in a Sprite2D you can adjust the color from "
"the texture manually like in the code below."
msgstr ""
"想要调整 Sprite2D 中的颜色时，你可以像下面的代码那样手动修改纹理中的颜色。"

msgid ""
"Certain nodes, like Sprite2Ds, have a dedicated texture variable that can be "
"accessed in the shader using ``TEXTURE``. If you want to use the Sprite2D "
"texture to combine with other colors, you can use the ``UV`` with the "
"``texture`` function to access this variable. Use them to redraw the "
"Sprite2D with the texture."
msgstr ""
"Sprite2D 等节点存在专门的纹理变量，在着色器中可以通过 ``TEXTURE`` 访问。使用 "
"Sprite2D 纹理时如果需要与其他颜色组合，你可以使用 ``UV`` 配合 ``texture`` 函"
"数来访问这个变量，重绘 Sprite2D 的纹理。"

msgid "Uniform input"
msgstr "Uniform 输入"

msgid ""
"Uniform input is used to pass data into a shader that will be the same "
"across the entire shader."
msgstr ""
"Uniform 输入是用来向着色器传递数据的，这些数据在整个着色器中都是一致的。"

msgid ""
"You can use uniforms by defining them at the top of your shader like so:"
msgstr "你可以像这样通过在着色器顶部定义来使用 Uniform 值："

msgid ""
"For more information about usage see the :ref:`Shading Language doc "
"<doc_shading_language>`."
msgstr "用法的更多详情请参见\\ :ref:`着色语言文档 <doc_shading_language>`\\ 。"

msgid "Add a uniform to change the amount of blue in our Sprite2D."
msgstr "添加一个 Uniform 值来改变 Sprite2D 中蓝色量。"

msgid ""
"Now you can change the amount of blue in the Sprite2D from the editor. Look "
"back at the Inspector under where you created your shader. You should see a "
"section called \"Shader Param\". Unfold that section and you will see the "
"uniform you just declared. If you change the value in the editor, it will "
"overwrite the default value you provided in the shader."
msgstr ""
"现在你可以在编辑器中改变这个 Sprite2D 的蓝色量。回头看看“检查器”中你创建着色"
"器的地方，你应该会看到一个叫做“Shader Parameters”的部分。展开这个部分就会看到"
"你刚刚声明的 uniform。如果在编辑器中改变这个值，就会覆盖你在着色器中提供的默"
"认值。"

msgid "Interacting with shaders from code"
msgstr "代码与着色器的交互"

msgid ""
"You can change uniforms from code using the function "
"``set_shader_parameter()`` which is called on the node's material resource. "
"With a Sprite2D node, the following code can be used to set the ``blue`` "
"uniform."
msgstr ""
"在代码中，你可以对该节点的材质资源使用 ``set_shader_parameter()`` 函数，从而"
"修改 Uniform。对于 Sprite2D 节点的话，使用下面的代码就可以设置 ``blue`` 这个 "
"Uniform。"

msgid ""
"Note that the name of the uniform is a string. The string must match exactly "
"with how it is written in the shader, including spelling and case."
msgstr ""
"注意，uniform 的名称是一个字符串。该字符串必须与着色器中的写法完全一致，包括"
"拼写和大小写。"

msgid "Your first vertex function"
msgstr "你的第一个顶点函数"

msgid "Now that we have a fragment function, let's write a vertex function."
msgstr "现在我们有了一个片段函数，我们再写一个顶点函数。"

msgid ""
"Use the vertex function to calculate where on the screen each vertex should "
"end up."
msgstr "顶点函数用于计算每个顶点在屏幕上的最终位置。"

msgid ""
"The most important variable in the vertex function is ``VERTEX``. Initially, "
"it specifies the vertex coordinates in your model, but you also write to it "
"to determine where to actually draw those vertices. ``VERTEX`` is a ``vec2`` "
"that is initially presented in local-space (i.e. not relative to the camera, "
"viewport, or parent nodes)."
msgstr ""
"顶点函数中最重要的变量是 ``VERTEX``\\。该变量初始表示模型中的顶点坐标，同时你"
"也可以通过向它赋值来确定这些顶点的最终绘制位置。\\ ``VERTEX`` 是一个 "
"``vec2`` 类型的变量，其坐标初始位于局部空间（即与摄像机、视口、父节点无关）。"

msgid "You can offset the vertices by directly adding to ``VERTEX``."
msgstr "你可以通过直接调整 ``VERTEX`` 来偏移顶点。"

msgid ""
"Combined with the ``TIME`` built-in variable, this can be used for basic "
"animation."
msgstr "结合内置变量 ``TIME`` 就可以制作简单的动画。"

msgid "Conclusion"
msgstr "总结"

msgid ""
"At their core, shaders do what you have seen so far, they compute ``VERTEX`` "
"and ``COLOR``. It is up to you to dream up more complex mathematical "
"strategies for assigning values to those variables."
msgstr ""
"你目前看到的就是着色器的核心部分了，也就是对 ``VERTEX`` 和 ``COLOR`` 的计算。"
"你可以制定更复杂的数学策略来给这些变量赋值。"

msgid ""
"For inspiration, take a look at some of the more advanced shader tutorials, "
"and look at other sites like `Shadertoy <https://www.shadertoy.com/results?"
"query=&sort=popular&from=10&num=4>`_ and `The Book of Shaders <https://"
"thebookofshaders.com>`_."
msgstr ""
"一些更高级的着色器教程可以给你启发, 如 `Shadertoy <https://www.shadertoy.com/"
"results?query=&sort=popular&from=10&num=4>`_ 和 `着色器之书 <https://"
"thebookofshaders.com/?lan=ch>`_ ."
