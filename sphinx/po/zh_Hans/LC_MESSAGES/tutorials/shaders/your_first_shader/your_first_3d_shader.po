#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "你的第一个 3D 着色器"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你已经决定开始编写一个自定义 Spatial 着色器。或许你在网上看到一个很酷的着色器"
"技巧，或许你发现 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 并不能"
"完全满足你的需求。总之，你决定写一个自己的，你想弄清楚从哪里开始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"这个教程将说明如何编写 Spatial 着色器，并将涵盖比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 更多的主题。"

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatial 着色器相比 CanvasItem 着色器内置了更多功能。其设计思路是，由 Godot 为"
"常见用例提供现成功能，用户只需在着色器中设置合适的参数即可。这一点在 PBR（基"
"于物理的渲染）工作流中尤为明显。"

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In "
"the :ref:`second part <doc_your_second_spatial_shader>` we will take the "
"concepts from this tutorial and set up custom materials in a fragment shader "
"by writing an ocean water shader."
msgstr ""
"这个教程分为两个部分。在第一部分中，我们会使用在 vertex 函数中根据高度图进行"
"顶点位移，从而制作地形。在\\ :ref:`第二部分 "
"<doc_your_second_spatial_shader>`\\ 中，我们会使用这个脚本中涉及的概念在片段"
"着色器中设置自定义材质，编写海洋水体着色器。"

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"这个教程假定你对着色器中的类型（\\ ``vec2``\\ 、\\ ``float``\\ 、\\ "
"``sampler2D``\\ ）和函数等基础知识有一定的了解。如果你对这些概念摸不着头脑，"
"那么在完成这个教程之前，你最好先从\\ `《着色器之书》 <https://"
"thebookofshaders.com/?lan=ch>`_\\ 获取一些基本知识。"

msgid "Where to assign my material"
msgstr "在何处设置我的材质"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a "
"few :ref:`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic "
"geometry to a scene without importing Meshes."
msgstr ""
"在 3D 中，物体是使用 :ref:`Meshes（网格） <class_Mesh>` 来绘制的。网格是一种"
"资源类型，它以称为“表面（surfaces）”的单元来存储几何体（物体的形状）和材质"
"（颜色以及物体对光的反应）。一个网格可以拥有多个表面，也可以只有一个。通常，"
"你会从其他程序（例如 Blender）中导入网格。但 Godot 也提供了一"
"些 :ref:`PrimitiveMeshes <class_primitivemesh>` ，允许你无需导入网格即可向场"
"景中添加基础几何体。"

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also "
"use :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"你可以使用多种节点类型来绘制网格。其中最主要的是 :ref:`MeshInstance3D "
"<class_MeshInstance3D>` ，但你也可以使用 :ref:`GPUParticles3D "
"<class_GPUParticles3D>` 、:ref:`MultiMeshes <class_MultiMesh>` （需配"
"合 :ref:`MultiMeshInstance3D <class_MultiMeshInstance3D>` 使用）或其他节点类"
"型。"

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常，材质会与网格中的某个给定表面关联，但有些节点，例如 MeshInstance3D，允许"
"你覆写特定表面或所有表面的材质。"

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或网格本身上设置了材质，那么所有共享该网格的 MeshInstance3D 都共"
"享该材质。但是如果你想在多个网格实例中重用同一个网格，而每个实例又要具有不同"
"的材质，那么你就应该在 MeshInstance3D 上设置材质。"

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"在本教程中，我们将把材质直接设置于网格本身，而非利用 MeshInstance3D 可覆盖材"
"质的功能。"

msgid "Setting up"
msgstr "设置"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "向场景添加一个新的 :ref:`MeshInstance3D <class_MeshInstance3D>` 节点。"

msgid ""
"In the inspector tab, set the MeshInstance3D's **Mesh** property to a "
"new :ref:`PlaneMesh <class_planemesh>` resource, by clicking on ``<empty>`` "
"and choosing **New PlaneMesh**. Then expand the resource by clicking on the "
"image of a plane that appears."
msgstr ""
"在检查器选项卡中，通过点击 ``<空>`` 并选择 **新建 PlaneMesh**\\ ，将 "
"MeshInstance3D 的 **Mesh** 属性设置为一个新的 :ref:`PlaneMesh "
"<class_planemesh>` 资源。然后点击出现的平面图像以展开该资源。"

msgid "This adds a plane to our scene."
msgstr "这将在我们的场景中添加一个平面。"

msgid ""
"Then, in the viewport, click in the upper left corner on the **Perspective** "
"button. In the menu that appears, select **Display Wireframe**."
msgstr ""
"然后，单击视口左上角的\\ **透视**\\ 按钮。在出现的菜单中，选择\\ **显示线框"
"**\\ 。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "这将允许你查看构成平面的三角形."

msgid ""
"Now set **Subdivide Width** and **Subdivide Depth** of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"现在将 :ref:`PlaneMesh <class_planemesh>` 的 **Subdivide Width** 和 "
"**Subdivide Depth** 设置为 ``32``\\ 。"

msgid ""
"You can see that there are now many more triangles in "
"the :ref:`MeshInstance3D<class_MeshInstance3D>`. This will give us more "
"vertices to work with and thus allow us to add more detail."
msgstr ""
"现在你可以看到，在 :ref:`MeshInstance3D<class_MeshInstance3D>` 中有了更多的三"
"角形。这将为我们提供更多可操作的顶点，从而能够添加更多细节。"

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Set the "
"**Material** to a new ShaderMaterial, then expand the material by clicking "
"on the sphere that appears."
msgstr ""
":ref:`PrimitiveMeshes <class_primitivemesh>`\\ ，比如平面网格（PlaneMesh），"
"仅包含一个表面，因此材质不是数组形式而是只有一个。将 **Material** 设置为新的 "
"ShaderMaterial，然后点击出现的球体以展开材质设置。"

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
"继承自 :ref:`class_Material` 资源的材质，例"
"如 :ref:`class_StandardMaterial3D` 和 :ref:`class_ParticleProcessMaterial`，"
"可以转换为 :ref:`class_ShaderMaterial`，并且它们现有的属性将被转换为附带的文"
"本着色器。要执行此操作，请在文件系统面板中右键单击材质并选择**转换为 "
"ShaderMaterial**。你也可以通过在检查器中右键单击任何持有材质引用的属性来完成"
"此操作。"

msgid ""
"Now set the material's **Shader** to a new Shader by clicking ``<empty>`` "
"and select **New Shader...**. Leave the default settings, give your shader a "
"name, and click **Create**."
msgstr ""
"现在通过点击 ``<空>`` 并选择\\ **新建着色器...**\\ ，将材质的 **Shader** 设置"
"为新的着色器。保留默认设置，为你的着色器命名，然后点击\\ **创建**\\ 。"

msgid ""
"Click on the shader in the inspector, and the shader editor should now pop "
"up. You are ready to begin writing your first Spatial shader!"
msgstr ""
"点击检查器中的着色器，着色器编辑器将会弹出。现在你已准备好开始编写第一个 "
"Spatial 着色器了！"

msgid "Shader magic"
msgstr "着色器魔术"

msgid ""
"The new shader is already generated with a ``shader_type`` variable, the "
"``vertex()`` function, and the ``fragment()`` function. The first thing "
"Godot shaders need is a declaration of what type of shader they are. In this "
"case the ``shader_type`` is set to ``spatial`` because this is a spatial "
"shader."
msgstr ""
"新的着色器已生成，包含一个 ``shader_type`` 变量、一个 ``vertex()`` 函数以及一"
"个 ``fragment()`` 函数。Godot 着色器首先需要声明其类型。在本例中，由于这是一"
"个 Spatial 着色器，\\ ``shader_type`` 被设为 ``spatial``\\ 。"

msgid ""
"The ``vertex()`` function determines where the vertices of "
"your :ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. "
"We will be using it to offset the height of each vertex and make our flat "
"plane appear like a little terrain."
msgstr ""
"``vertex()`` 函数决定了 :ref:`MeshInstance3D<class_MeshInstance3D>` 的顶点在"
"最终场景中的位置。我们将通过它来偏移每个顶点的高度，使我们的平面呈现出类似小"
"型地形的外观。"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can start to make changes by adding a single line:"
msgstr ""
"当 ``vertex()`` 函数内没有任何内容时，Godot 将使用其默认的顶点着色器。我们可"
"以通过添加一行代码开始进行修改："

msgid "Adding this line, you should get an image like the one below."
msgstr "添加此行后, 你应该会得到类似下方的图像."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to :ref:`cos() <shader_func_cos>` and :ref:`sin() "
"<shader_func_sin>`; that gives us a wave-like appearance across the ``x`` "
"and ``z`` axes."
msgstr ""
"好的，我们来解读一下这段代码。这里将 ``VERTEX`` 的 ``y`` 值进行了增加。并且，"
"我们将 ``VERTEX`` 的 ``x`` 和 ``z`` 分量作为参数传递给了 :ref:`cos() "
"<shader_func_cos>` 和 :ref:`sin() <shader_func_sin>` 函数；这会在 ``x`` 和 "
"``z`` 轴方向上产生一种波浪状的外观。"

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos()`` "
"and ``sin()`` already look kind of like hills. We do so by scaling the "
"inputs to the ``cos()`` and ``sin()`` functions."
msgstr ""
"毕竟，我们想要实现的是小山丘的效果。而 ``cos()`` 和 ``sin()`` 就已经有点像山"
"丘了。我们可以通过缩放传入 ``cos()`` 和 ``sin()`` 函数的输入参数来实现这一效"
"果。"

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "看起来效果好些了，但波形仍然过于尖锐和重复，让我们把它变得更有趣一点。"

msgid "Noise heightmap"
msgstr "噪声高度图"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"噪声是一种非常流行的模拟地形的工具。可以将它想作类似于能产生重复山丘图案的余"
"弦函数，只是在噪声的影响下每个小山都拥有不同的高度。"

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot提供了 :ref:`NoiseTexture2D <class_noisetexture2D>` 资源，用于生成可在着"
"色器中访问的噪声纹理。"

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"要在着色器中访问纹理，请在着色器顶部附近、\\ ``vertex()`` 函数外部添加以下代"
"码。"

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called **Shader "
"Parameters**. If you open it up, you'll see a parameter called \"Noise\"."
msgstr ""
"这将允许你将噪声纹理发送给着色器。现在查看材质下面的检查器面板，你应该会看到"
"一个名为 **Shader Parameters** 的区域。如果你展开它，就会看到一个叫做 "
"“Noise” 的参数。"

msgid ""
"Set this **Noise** parameter to a new :ref:`NoiseTexture2D "
"<class_noisetexture2D>`. Then in your NoiseTexture2D, set its **Noise** "
"property to a new :ref:`FastNoiseLite <class_fastnoiselite>`. The "
"FastNoiseLite class is used by the NoiseTexture2D to generate a heightmap."
msgstr ""
"将这个 **Noise** 参数设置为一个新的 :ref:`NoiseTexture2D "
"<class_noisetexture2D>`\\ 。接着在你的 NoiseTexture2D 中，将 **Noise** 属性设"
"置为一个新的 :ref:`FastNoiseLite <class_fastnoiselite>`\\ 。FastNoiseLite 类"
"被 NoiseTexture2D 用于生成高度图。"

msgid "Once you set it up and should look like this."
msgstr "设置好后，看起来应该像这样。"

msgid "Now, access the noise texture using the ``texture()`` function:"
msgstr "现在，通过 ``texture()`` 函数访问噪声纹理："

msgid ""
":ref:`texture() <shader_func_texture>` takes a texture as the first argument "
"and a ``vec2`` for the position on the texture as the second argument. We "
"use the ``x`` and ``z`` channels of ``VERTEX`` to determine where on the "
"texture to look up."
msgstr ""
":ref:`texture() <shader_func_texture>` 函数以纹理作为第一个参数，以表示纹理上"
"采样位置的 ``vec2`` 作为第二个参数。我们使用 ``VERTEX`` 的 ``x`` 和 ``z`` 通"
"道来确定在纹理上的采样位置。"

msgid ""
"Since the PlaneMesh coordinates are within the ``[-1.0, 1.0]`` range (for a "
"size of ``2.0``), while the texture coordinates are within ``[0.0, 1.0]``, "
"to remap the coordinates we divide by the size of the PlaneMesh by ``2.0`` "
"and add ``0.5`` ."
msgstr ""
"由于 PlaneMesh 的坐标范围是 ``[-1.0, 1.0]``\\ （对应尺寸为 ``2.0``\\ ），而纹"
"理坐标范围是 ``[0.0, 1.0]``\\ ，我们将坐标除以 PlaneMesh 的尺寸 ``2.0`` 并加"
"上 ``0.5`` 来将坐标进行重映射。"

msgid ""
"``texture()`` returns a ``vec4`` of the ``r, g, b, a`` channels at the "
"position. Since the noise texture is grayscale, all of the values are the "
"same, so we can use any one of the channels as the height. In this case "
"we'll use the ``r``, or ``x`` channel."
msgstr ""
"``texture()`` 函数会返回采样位置处包含 ``r, g, b, a`` 通道的 ``vec4`` 向量。"
"由于噪声纹理是灰度图，所有通道的值均相同，因此我们可以使用任一通道作为高度"
"值。本例中我们将使用 ``r`` 或 ``x`` 通道。"

msgid ""
"``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture().x`` "
"above, we could use ``texture().r``. See the `OpenGL documentation <https://"
"www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more details."
msgstr ""
"在 GLSL 中，\\ ``xyzw`` 与 ``rgba`` 是等效的，因此，除了上面使用的 "
"``texture().x``\\ ，我们也可以使用 ``texture().r``\\ 。更多细节请参阅 "
"`OpenGL 文档 <https://www.khronos.org/opengl/wiki/"
"Data_Type_(GLSL)#Vectors>`_\\ 。"

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用此代码后，你可以看到纹理创建了随机外观的山峰。"

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前山峰还是很尖锐，我们需要稍微柔化一下。为此，我们将使用 uniform 变量。 你"
"在之前已经使用了 uniform 来传递噪声纹理，现在让我们来学习一下其中的工作原理。"

msgid "Uniforms"
msgstr "Uniform"

msgid ""
":ref:`Uniform variables <doc_shading_language_uniforms>` allow you to pass "
"data from the game into the shader. They are very useful for controlling "
"shader effects. Uniforms can be almost any datatype that can be used in the "
"shader. To use a uniform, you declare it in your :ref:`Shader<class_Shader>` "
"using the keyword ``uniform``."
msgstr ""
":ref:`Uniform 变量 <doc_shading_language_uniforms>` 允许你将数据从游戏传递到"
"着色器中。它们对于控制着色器效果非常有用。几乎所有在着色器中可用的数据类型都"
"可以用作 uniform。要使用 uniform，你需要在 :ref:`Shader<class_Shader>` 中通"
"过 ``uniform`` 关键字来声明它。"

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "让我们创建一个改变地形高度的 uniform。"

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the "
"function :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` on the material "
"corresponding to the shader. The value passed from GDScript takes precedence "
"over the value used to initialize it in the shader."
msgstr ""
"Godot 允许你使用值来初始化 uniform 变量；在这里， ``height_scale`` 被设置为 "
"``0.5``\\。你可以在 GDScript 中通过调用与该着色器对应材质上"
"的 :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` 函数来设置 uniform。从 "
"GDScript 传递的值将优先于着色器中用于初始化该 uniform 的值。"

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"在基于 Spatial 的节点中修改 uniform 与基于 CanvasItem 的节点有所不同。在这"
"里，我们是在 PlaneMesh 资源内部设置材质的。对于其他网格资源，你可能需要先通过"
"调用 ``surface_get_material()`` 来访问材质。而对于 MeshInstance3D，你则需要使"
"用 ``get_surface_material()`` 或 ``material_override`` 来访问材质。"

msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the shader. You can use the uniform "
"variable anywhere inside your shader. Here, we will use it to set the height "
"value instead of arbitrarily multiplying by ``0.5``."
msgstr ""
"请记住，传入 ``set_shader_parameter()`` 的字符串必须与着色器中 uniform 变量的"
"名称完全一致。你可以在着色器内的任意位置使用 uniform 变量。在这里，我们将用它"
"来设置高度值，而不是随意地乘以 ``0.5``\\ 。"

msgid "Now it looks much better."
msgstr "现在它看起来好多了。"

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"利用 uniform 变量，我们甚至可以在每帧修改数值来实现地形的动态高度变化。结合使"
"用 :ref:`Tweens <class_Tween>` ，对实现动画效果尤为实用。"

msgid "Interacting with light"
msgstr "与光交互"

msgid ""
"First, turn wireframe off. To do so, open the **Perspective** menu in the "
"upper-left of the viewport again, and select **Display Normal**. "
"Additionally in the 3D scene toolbar, turn off preview sunlight."
msgstr ""
"首先，关闭线框显示。再次打开视口左上角的\\ **透视**\\ 菜单，选择\\ **显示标准"
"**\\ 。同时在 3D 场景工具栏中关闭预览阳光功能。"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"注意到网格颜色变得平坦了吗？这是因为当前的光照效果是均匀的。让我们来添加一个"
"光源吧！"

msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene, "
"and drag it up so it is above the terrain."
msgstr ""
"首先，我们在场景中添加一个 :ref:`OmniLight3D<class_OmniLight3D>` ，并将它向上"
"拖动至地形上方。"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你会看到光照已对地形产生了影响，但这看起来很奇怪。问题在于光照作用于地形时仍"
"将其视为平面处理，这是因为光照着色器使用的是 :ref:`网格 <class_mesh>` 中的法"
"线信息来计算光照。"

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法线信息存储于网格数据中，但是我们在着色器中改变了网格的形状，所以法线数据不"
"再准确。为了解决这个问题，我们可以在着色器中重新计算法线，或使用与噪声纹理对"
"应的法线纹理。Godot 为这两种方案都提供了便捷的实现方式。"

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"你可以在顶点函数中手动计算新的法线，然后只需设置法线 ``NORMAL``\\ 。设置好 "
"``NORMAL`` 后，Godot 将为我们完成所有困难的光照计算。我们将在本教程的下一部分"
"介绍这种方法，现在我们将从纹理中读取法线。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"这次我们将再次利用 NoiseTexture 来为我们计算法线。具体做法是传入第二张噪声纹"
"理。"

msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normal Map**."
msgstr ""
"将第二个 uniform 纹理设置为另一个包含 :ref:`FastNoiseLite "
"<class_fastnoiselite>` 的 :ref:`NoiseTexture2D <class_noisetexture2D>`\\ ，但"
"这次，勾选 **As Normal Map** 选项。"

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP`` in the ``fragment()`` function. This way Godot will handle "
"wrapping the texture around the mesh automatically."
msgstr ""
"当我们需要设置与特定顶点对应的法线时，使用 ``NORMAL``\\ ；但如果你有一个来自"
"纹理的法线贴图，则应在 ``fragment()`` 函数中通过 ``NORMAL_MAP`` 来设置法线。"
"这样 Godot 会自动处理纹理在网格表面的映射。"

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the "
"``VERTEX.xz`` position from the ``vertex()`` function to the ``fragment()`` "
"function. We do that using a :ref:`varying <doc_shading_language_varyings>`."
msgstr ""
"最后，为了确保从噪声纹理和法线贴图的相同位置进行采样，我们将 ``VERTEX.xz`` 坐"
"标从 ``vertex()`` 函数传递到 ``fragment()`` 函数。我们可以通过 :ref:`varying "
"<doc_shading_language_varyings>` 来实现。"

msgid ""
"Above the ``vertex()`` define a ``varying vec2`` called ``tex_position``. "
"And inside the ``vertex()`` function assign ``VERTEX.xz`` to "
"``tex_position``."
msgstr ""
"在 ``vertex()`` 函数上方定义一个名为 ``tex_position`` 的 ``varying vec2`` 变"
"量。然后在 ``vertex()`` 函数内部将 ``VERTEX.xz`` 赋值给 ``tex_position``\\ 。"

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "现在我们可以从 ``fragment()`` 函数中访问 ``tex_position``\\ 。"

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法线贴图就位后，光照现在能够根据网格的高度产生动态响应效果。"

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "我们甚至可以把光源拖来拖去，光照效果会自动更新。"

msgid "Full code"
msgstr "完整代码"

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教程的完整代码。你可以看到代码并不太长，因为 Godot 已为你处理了大部分"
"繁琐的工作。"

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"这就是这部分的全部内容。希望你现在已了解Godot中顶点着色器的基本知识。在本教程"
"的下一部分中，我们将编写一个片段函数来配合这个顶点函数，并且我们将介绍一种更"
"高级的技术来将这个地形转换成一个移动的波浪海洋。"
