#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Core types"
msgstr "Типи сердечників"

msgid ""
"Godot has a rich set of classes and templates that compose its core, and "
"everything is built upon them."
msgstr ""
"Godot має багатий набір класів і шаблонів, які складають його ядро, і все "
"побудовано на них."

msgid ""
"This reference will try to list them in order for their better understanding."
msgstr "У цьому довіднику спробуємо перерахувати їх для кращого розуміння."

msgid "Definitions"
msgstr "Визначення"

msgid ""
"Godot uses the standard C99 datatypes, such as ``uint8_t``, ``uint32_t``, "
"``int64_t``, etc. which are nowadays supported by every compiler. "
"Reinventing the wheel for those is not fun, as it makes code more difficult "
"to read."
msgstr ""
"Godot використовує стандартні типи даних C99, такі як ``uint8_t``, "
"``uint32_t``, ``int64_t`` тощо, які сьогодні підтримуються кожним "
"компілятором. Перевинаходити колесо для них не весело, оскільки це ускладнює "
"читання коду."

msgid ""
"For Unicode characters, CharType instead of wchar_t is used, because many "
"architectures have 4 bytes long wchar_t, where 2 bytes might be desired. "
"However, by default, this has not been forced and CharType maps directly to "
"wchar_t."
msgstr ""
"Для символів Unicode використовується CharType замість wchar_t, оскільки "
"багато архітектур мають 4 байти wchar_t, де 2 байти можуть бути бажаними. "
"Однак за замовчуванням це не було примусово, і CharType відображається "
"безпосередньо на wchar_t."

msgid ""
"`core/typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"
msgstr ""
"`core/typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"

msgid "Memory model"
msgstr "Модель пам'яті"

msgid ""
"PC is a wonderful architecture. Computers often have gigabytes of RAM, "
"terabytes of storage and gigahertz of CPU, and when an application needs "
"more resources the OS will swap out the inactive ones. Other architectures "
"(like mobile or consoles) are in general more limited."
msgstr ""
"ПК — чудова архітектура. Комп’ютери часто мають гігабайти оперативної "
"пам’яті, терабайти пам’яті та гігагерці ЦП, і коли програмі потрібно більше "
"ресурсів, ОС замінить неактивні. Інші архітектури (наприклад, мобільні або "
"консолі) загалом більш обмежені."

msgid ""
"The most common memory model is the heap, where an application will request "
"a region of memory, and the underlying OS will try to fit it somewhere and "
"return it. This often works best and is flexible, but over time and with "
"abuse, this can lead to segmentation."
msgstr ""
"Найпоширенішою моделлю пам’яті є купа, де програма запитує область пам’яті, "
"а базова ОС намагатиметься її десь вмістити та повертати. Це часто працює "
"найкраще та є гнучким, але з часом і через зловживання це може призвести до "
"сегментації."

msgid ""
"Segmentation slowly creates holes that are too small for most common "
"allocations, so that memory is wasted. There is a lot of literature about "
"heap and segmentation, so this topic will not be developed further here. "
"Modern operating systems use paged memory, which helps mitigate the problem "
"of segmentation but doesn't solve it."
msgstr ""
"Сегментація повільно створює діри, які є занадто малими для більшості "
"поширених розподілів, тому пам’ять витрачається даремно. Існує багато "
"літератури про купу та сегментацію, тому ця тема не буде розвиватися далі. "
"Сучасні операційні системи використовують сторінкову пам’ять, що допомагає "
"пом’якшити проблему сегментації, але не вирішує її."

msgid ""
"However, in many studies and tests, it is shown that given enough memory, if "
"the maximum allocation size is below a given threshold in proportion to the "
"maximum heap size and proportion of memory intended to be unused, "
"segmentation will not be a problem over time as it will remain constant. In "
"other words, leave 10-20% of your memory free and perform all small "
"allocations and you are fine."
msgstr ""
"Однак у багатьох дослідженнях і тестах було показано, що за наявності "
"достатньої кількості пам’яті, якщо максимальний розмір виділення нижче "
"заданого порогу пропорційно максимальному розміру купи та частці пам’яті, "
"яка має бути невикористаною, сегментація не буде проблемою з часом. оскільки "
"він залишатиметься постійним. Іншими словами, залиште 10-20% пам’яті вільною "
"та виконайте всі невеликі розподіли, і все гаразд."

msgid "Allocating memory"
msgstr "Виділення пам'яті"

msgid ""
"Godot has many tools for tracking memory usage in a game, especially during "
"debug. Because of this, the regular C and C++ library calls should not be "
"used. Instead, a few other ones are provided."
msgstr ""
"Godot має багато інструментів для відстеження використання пам’яті в грі, "
"особливо під час налагодження. Через це не слід використовувати звичайні "
"виклики бібліотек C і C++. Натомість надано кілька інших."

msgid "For C-style allocation, Godot provides a few macros:"
msgstr "Для розподілу в стилі C Godot надає кілька макросів:"

msgid "For C++-style allocation, special macros are provided:"
msgstr "Для розподілу в стилі C++ передбачені спеціальні макроси:"

msgid ""
"memnew/memdelete also use a little C++ magic and notify Objects right after "
"they are created, and right before they are deleted."
msgstr ""
"memnew/memdelete також використовує трохи магії C++ і сповіщає об’єкти "
"відразу після їх створення та безпосередньо перед їх видаленням."

msgid ""
"For dynamic memory, use one of Godot's sequence types such as ``Vector<>`` "
"or ``LocalVector<>``. ``Vector<>`` behaves much like an STL "
"``std::vector<>``, but is simpler and uses Copy-On-Write (CoW) semantics. "
"CoW copies of ``Vector<>`` can safely access the same data from different "
"threads, but several threads cannot access the same ``Vector<>`` instance "
"safely. It can be safely passed via public API if it has a ``Packed`` alias."
msgstr ""
"Для динамічної пам’яті використовуйте один із типів послідовності Godot, "
"наприклад ``Vector<>`` або ``LocalVector<>``. ``Vector<>`` поводиться так "
"само, як STL ``std::vector<>``, але він простіший і використовує семантику "
"Copy-On-Write (CoW). Копії CoW ``Vector<>`` можуть безпечно отримувати "
"доступ до тих самих даних з різних потоків, але кілька потоків не можуть "
"безпечно отримати доступ до того самого екземпляра ``Vector<>``. Його можна "
"безпечно передати через публічний API, якщо він має псевдонім ``Packed``."

msgid ""
"The ``Packed*Array`` :ref:`types <doc_gdscript_packed_arrays>` are aliases "
"for specific ``Vector<*>`` types (e.g., ``PackedByteArray``, "
"``PackedInt32Array``) that are accessible via GDScript. Outside of core, "
"prefer using the ``Packed*Array`` aliases for functions exposed to scripts, "
"and ``Vector<>`` for other occasions."
msgstr ""
"``Packed*Array`` :ref:`types <doc_gdscript_packed_arrays>` є псевдонімами "
"для конкретних типів ``Vector<*>`` (наприклад, ``PackedByteArray``, "
"``PackedInt32Array``), які доступні через GDScript. За межами ядра віддайте "
"перевагу використанню псевдонімів ``Packed*Array`` для функцій, які "
"піддаються сценаріям, і ``Vector<>`` для інших випадків."

msgid ""
"``LocalVector<>`` is much more like ``std::vector`` than ``Vector<>``. It is "
"non-CoW, with less overhead. It is intended for internal use where the "
"benefits of CoW are not needed. Note that neither ``LocalVector<>`` nor "
"``Vector<>`` are drop-in replacements for each other. They are two unrelated "
"types with similar interfaces, both using a buffer as their storage strategy."
msgstr ""
"``LocalVector<>`` більше схожий на ``std::vector``, ніж ``Vector<>``. Це не "
"CoW, з меншими накладними витратами. Він призначений для внутрішнього "
"використання, де переваги CoW не потрібні. Зауважте, що ні "
"``LocalVector<>``, ні ``Vector<>`` не замінюють один одного. Це два "
"непов’язані типи з подібними інтерфейсами, обидва використовують буфер як "
"стратегію зберігання."

msgid ""
"``List<>`` is another Godot sequence type, using a doubly-linked list as its "
"storage strategy. Prefer ``Vector<>`` (or ``LocalVector<>``) over ``List<>`` "
"unless you're sure you need it, as cache locality and memory fragmentation "
"tend to be more important with small collections."
msgstr ""
"``List<>`` — ще один тип послідовності Godot, який використовує подвійний "
"зв’язаний список як стратегію зберігання. Віддавайте перевагу ``Vector<>`` "
"(або ``LocalVector<>``) над ``List<>``, якщо ви не впевнені, що він вам "
"потрібен, оскільки локальність кешу та фрагментація пам’яті, як правило, "
"більш важливі для малих колекцій."

msgid ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"
msgstr ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"

msgid "Containers"
msgstr "Контейнери"

msgid "Comment"
msgstr "Коментар"

msgid "|vector|"
msgstr "|vector|"

msgid "Math types"
msgstr "Типи математики"

msgid ""
"`core/math <https://github.com/godotengine/godot/tree/master/core/math>`__"
msgstr ""
"`основний/математика <https://github.com/godotengine/godot/tree/master/core/"
"math>`__"

msgid "NodePath"
msgstr "Шлях до вузла"

msgid ""
"`core/string/node_path.h <https://github.com/godotengine/godot/blob/master/"
"core/string/node_path.h>`__"
msgstr ""
"`core/string/node_path.h <https://github.com/godotengine/godot/blob/master/"
"core/string/node_path.h>`__"

msgid "RID"
msgstr "RID"

msgid ""
"`core/templates/rid.h <https://github.com/godotengine/godot/blob/master/core/"
"templates/rid.h>`__"
msgstr ""
"`core/templates/rid.h <https://github.com/godotengine/godot/blob/master/core/"
"templates/rid.h>`__"
