#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Designing the mob scene"
msgstr "Проектування сцени монстра"

msgid ""
"In this part, you're going to code the monsters, which we'll call mobs. In "
"the next lesson, we'll spawn them randomly around the playable area."
msgstr ""
"У цій частині ви збираєтеся кодувати монстрів, яких будемо називати мобами. "
"На наступному уроці ми будемо розміщувати їх випадковим чином навколо "
"ігрової області."

msgid ""
"Let's design the monsters themselves in a new scene. The node structure is "
"going to be similar to the ``player.tscn`` scene."
msgstr ""
"Давайте створимо самих монстрів у новій сцені. Структура вузла буде схожа на "
"сцену ``player.tscn``."

msgid ""
"Create a scene with, once again, a :ref:`CharacterBody3D "
"<class_CharacterBody3D>` node as its root. Name it ``Mob``. Add a child "
"node :ref:`Node3D <class_Node3D>`, name it ``Pivot``. And drag and drop the "
"file ``mob.glb`` from the *FileSystem* dock onto the ``Pivot`` to add the "
"monster's 3D model to the scene."
msgstr ""
"Знову створіть сцену з кореневим вузлом :ref:`CharacterBody3D "
"<class_CharacterBody3D>`. Назвіть його ``Mob``. Додайте дочірній вузол :ref:"
"`Node3D <class_Node3D>`, назвіть його ``Pivot``. Перетягніть файл ``mob."
"glb`` із док-станції *FileSystem* на ``Pivot``, щоб додати 3D-модель монстра "
"до сцени."

msgid "You can rename the newly created ``mob`` node into ``Character``."
msgstr "Ви можете перейменувати новостворений вузол ``mob`` в `Character``."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"We need a collision shape for our body to work. Right-click on the ``Mob`` "
"node, the scene's root, and click *Add Child Node*."
msgstr ""
"Нам потрібна форма зіткнення, щоб наше тіло працювало. Клацніть правою "
"кнопкою миші вузол ``Mob``, корінь сцени, і натисніть *Додати дочірній "
"вузол*."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid "Add a :ref:`CollisionShape3D <class_CollisionShape3D>`."
msgstr "Додати :ref:`CollisionShape3D <class_CollisionShape3D>`."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid "In the *Inspector*, assign a *BoxShape3D* to the *Shape* property."
msgstr "В *Інспекторі* призначте *BoxShape3D* властивості *Shape*."

msgid ""
"We should change its size to fit the 3D model better. You can do so "
"interactively by clicking and dragging on the orange dots."
msgstr ""
"Ми повинні змінити його розмір, щоб краще відповідати розміру 3D-моделі. Ви "
"можете зробити це інтерактивно, натиснувши та перетягнувши помаранчеві точки."

msgid ""
"The box should touch the floor and be a little thinner than the model. "
"Physics engines work in such a way that if the player's sphere touches even "
"the box's corner, a collision will occur. If the box is a little too big "
"compared to the 3D model, you may die at a distance from the monster, and "
"the game will feel unfair to the players."
msgstr ""
"Коробка повинна торкатися підлоги і бути трохи тонше моделі. Фізичні рушії "
"працюють таким чином, що якщо сфера гравця торкнеться навіть кута коробки, "
"відбудеться зіткнення. Якщо коробка трохи завелика в порівнянні з 3D-"
"моделлю, ви можете померти на відстані від монстра, і гра буде "
"несправедливою по відношенню до гравців."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"Notice that my box is taller than the monster. It is okay in this game "
"because we're looking at the scene from above and using a fixed perspective. "
"Collision shapes don't have to match the model exactly. It's the way the "
"game feels when you test it that should dictate their form and size."
msgstr ""
"Зверніть увагу, що моя коробка вище, ніж монстр. Це нормально в цій грі, "
"тому що ми дивимося на сцену зверху і використовуємо фіксовану перспективу. "
"Форми зіткнення не повинні точно відповідати моделі. Це та форма та розмір, "
"які гра відчуває, коли ви тестуєте її."

msgid "Removing monsters off-screen"
msgstr "Видалення монстрів поза екраном"

msgid ""
"We're going to spawn monsters at regular time intervals in the game level. "
"If we're not careful, their count could increase to infinity, and we don't "
"want that. Each mob instance has both a memory and a processing cost, and we "
"don't want to pay for it when the mob is outside the screen."
msgstr ""
"Ми будемо породжувати монстрів через рівні проміжки часу на рівні гри. Якщо "
"ми не будемо обережні, їх кількість може зрости до нескінченності, а ми "
"цього не хочемо. Кожен екземпляр мобу має як пам’ять, так і вартість "
"обробки, і ми не хочемо платити за це, коли моб знаходиться поза екраном."

msgid ""
"Once a monster leaves the screen, we don't need it anymore, so we should "
"delete it. Godot has a node that detects when objects leave the screen, :ref:"
"`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, and we're "
"going to use it to destroy our mobs."
msgstr ""
"Як тільки монстр покидає екран, він нам більше не потрібен, тому ми повинні "
"його видалити. У Godot є вузол, який визначає, коли об’єкти залишають "
"екран, :ref:`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`, і "
"ми збираємося використовувати його, щоб знищувати наших мобів."

msgid ""
"When you keep instancing an object, there's a technique you can use to avoid "
"the cost of creating and destroying instances all the time called pooling. "
"It consists of pre-creating an array of objects and reusing them over and "
"over."
msgstr ""
"Коли ви продовжуєте створювати екземпляри об’єкта, існує техніка, яку можна "
"використовувати, щоб уникнути витрат на постійне створення та знищення "
"екземплярів, що називається об’єднанням. Він складається з попереднього "
"створення масиву об’єктів і повторного їх використання знову і знову."

msgid ""
"When working with GDScript, you don't need to worry about this. The main "
"reason to use pools is to avoid freezes with garbage-collected languages "
"like C# or Lua. GDScript uses a different technique to manage memory, "
"reference counting, which doesn't have that caveat. You can learn more about "
"that here: :ref:`doc_gdscript_basics_memory_management`."
msgstr ""
"Працюючи з GDScript, вам не потрібно турбуватися про це. Основною причиною "
"використання пулів є уникнення зависань у мовах зі збиранням сміття, таких "
"як C# або Lua. GDScript використовує іншу техніку для керування пам’яттю, "
"підрахунок посилань, яка не має цього застереження. Ви можете дізнатися "
"більше про це тут: :ref:`doc_gdscript_basics_memory_management`."

msgid ""
"Select the ``Mob`` node and add a child node :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>`. Another box, pink this time, appears. "
"When this box completely leaves the screen, the node will emit a signal."
msgstr ""
"Виберіть вузол ``Mob`` і додайте дочірній вузол :ref:"
"`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>`. З’являється "
"інша коробка, цього разу рожева. Коли це вікно повністю залишить екран, "
"вузол випустить сигнал."

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid "Resize it using the orange dots until it covers the entire 3D model."
msgstr ""
"Змініть коробку за допомогою помаранчевих точок, щоб вона охопила всю 3D-"
"модель."

msgid "|image6|"
msgstr "Зображення"

msgid "image6"
msgstr "image6"

msgid "Coding the mob's movement"
msgstr "Кодування руху монстра"

msgid ""
"Let's implement the monster's motion. We're going to do this in two steps. "
"First, we'll write a script on the ``Mob`` that defines a function to "
"initialize the monster. We'll then code the randomized spawn mechanism in "
"the ``main.tscn`` scene and call the function from there."
msgstr ""
"Здійснюємо рух монстра. Ми зробимо це в два кроки. Спочатку ми напишемо "
"сценарій для ``Mob``, який визначає функцію для ініціалізації монстра. Потім "
"ми закодуємо рандомізований механізм породження в сцені ``main.tscn`` і "
"викличемо функцію звідти."

msgid "Attach a script to the ``Mob``."
msgstr "Додайте сценарій до ``Mob``."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"Here's the movement code to start with. We define two properties, "
"``min_speed`` and ``max_speed``, to define a random speed range, which we "
"will later use to define ``CharacterBody3D.velocity``."
msgstr ""
"Ось код руху для початку. Ми визначаємо дві властивості, ``min_speed`` і "
"``max_speed``, щоб визначити випадковий діапазон швидкості, який ми пізніше "
"використаємо для визначення ``CharacterBody3D.velocity``."

msgid ""
"Similarly to the player, we move the mob every frame by calling the function "
"``CharacterBody3D.move_and_slide()``. This time, we don't update the "
"``velocity`` every frame; we want the monster to move at a constant speed "
"and leave the screen, even if it were to hit an obstacle."
msgstr ""
"Подібно до гравця, ми переміщуємо моба кожного кадру, викликаючи функцію "
"``CharacterBody3D.move_and_slide()``. Цього разу ми не оновлюємо "
"``velocity`` кожного кадру; ми хочемо, щоб монстр рухався з постійною "
"швидкістю та залишав екран, навіть якщо він зіткнеться з перешкодою."

msgid ""
"We need to define another function to calculate the ``CharacterBody3D."
"velocity``. This function will turn the monster towards the player and "
"randomize both its angle of motion and its velocity."
msgstr ""
"Нам потрібно визначити іншу функцію для обчислення ``CharacterBody3D."
"velocity``. Ця функція повертатиме монстра до гравця та рандомізує як кут "
"його руху, так і швидкість."

msgid ""
"The function will take a ``start_position``,the mob's spawn position, and "
"the ``player_position`` as its arguments."
msgstr ""
"Функція прийматиме ``start_position``, позицію появи мобу та "
"``player_position`` як свої аргументи."

msgid ""
"We position the mob at ``start_position`` and turn it towards the player "
"using the ``look_at_from_position()`` method, and randomize the angle by "
"rotating a random amount around the Y axis. Below, ``randf_range()`` outputs "
"a random value between ``-PI / 4`` radians and ``PI / 4`` radians."
msgstr ""
"Ми розміщуємо моба в ``start_position`` і повертаємо його до гравця за "
"допомогою методу ``look_at_from_position()``, і рандомізуємо кут, обертаючи "
"випадкову величину навколо осі Y. Нижче ``randf_range()`` виводить випадкове "
"значення між ``-PI / 4`` радіан і ``PI / 4`` радіан."

msgid ""
"We got a random position, now we need a ``random_speed``. ``randi_range()`` "
"will be useful as it gives random int values, and we will use ``min_speed`` "
"and ``max_speed``. ``random_speed`` is just an integer, and we just use it "
"to multiply our ``CharacterBody3D.velocity``. After ``random_speed`` is "
"applied, we rotate ``CharacterBody3D.velocity`` Vector3 towards the player."
msgstr ""
"Ми отримали випадкову позицію, тепер нам потрібна ``random_speed``. "
"``randi_range()`` буде корисним, оскільки він дає випадкові значення int, і "
"ми будемо використовувати ``min_speed`` і ``max_speed``. "
"``випадкова_швидкість`` — це просто ціле число, і ми просто використовуємо "
"його для множення нашого ``CharacterBody3D.velocity``. Після застосування "
"``random_speed`` ми повертаємо ``CharacterBody3D.velocity`` Vector3 до "
"гравця."

msgid "Leaving the screen"
msgstr "Залишання екрану"

msgid ""
"We still have to destroy the mobs when they leave the screen. To do so, "
"we'll connect our :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node's ``screen_exited`` signal to the "
"``Mob``."
msgstr ""
"Нам все ще потрібно знищувати мобів, коли вони залишають екран. Для цього ми "
"підключимо сигнал ``screen_exited`` нашого вузла :ref:"
"`VisibleOnScreenNotifier3D <class_VisibleOnScreenNotifier3D>` до ``Mob``."

msgid ""
"Head back to the 3D viewport by clicking on the *3D* label at the top of the "
"editor. You can also press :kbd:`Ctrl + F2` (:kbd:`Opt + 2` on macOS)."
msgstr ""
"Поверніться до 3D вікна перегляду, клацнувши ярлик *3D* у верхній частині "
"редактора. Ви також можете натиснути :kbd:`Ctrl + F2` (:kbd:`Opt + 2` на "
"macOS)."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"Select the :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` node and on the right side of the "
"interface, navigate to the *Node* dock. Double-click the ``screen_exited()`` "
"signal."
msgstr ""
"Виберіть вузол :ref:`VisibleOnScreenNotifier3D "
"<class_VisibleOnScreenNotifier3D>` і в правій частині інтерфейсу перейдіть "
"до док-станції *Node*. Двічі клацніть сигнал ``screen_exited()``."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid "Connect the signal to the ``Mob``"
msgstr "Підключіть сигнал до ``Mob``"

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"This will add a new function for you in your mob script, "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. From it, call the "
"``queue_free()`` method. This function destroys the instance it's called on."
msgstr ""
"Це додасть нову функцію для вас у ваш моб-скрипт, "
"``_on_visible_on_screen_notifier_3d_screen_exited()``. З нього викличте "
"метод ``queue_free()``. Ця функція знищує екземпляр, який вона викликала."

msgid ""
"Our monster is ready to enter the game! In the next part, you will spawn "
"monsters in the game level."
msgstr ""
"Наш монстр готовий появитися в грі! У наступній частині ви будете "
"породжувати монстрів на ігровому рівні."

msgid "Here is the complete ``mob.gd`` script for reference."
msgstr "Ось повний сценарій ``mob.gd`` для довідки."
