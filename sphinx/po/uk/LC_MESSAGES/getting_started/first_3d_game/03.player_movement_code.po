#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Moving the player with code"
msgstr "Кодування переміщення гравця"

msgid ""
"It's time to code! We're going to use the input actions we created in the "
"last part to move the character."
msgstr ""
"Настав час коду! Ми будемо використовувати дії введення, які створили в "
"останній частині, для переміщення персонажа."

msgid "For this project, we will be following the Godot naming conventions."
msgstr "У цьому проєкті ми будемо дотримуватися правил іменування Godot."

msgid ""
"**GDScript**: Classes (nodes) use PascalCase, variables and functions use "
"snake_case, and constants use ALL_CAPS (See :ref:`doc_gdscript_styleguide`)."
msgstr ""
"**GDScript**: Класи (вузли) використовують PascalCase, змінні та функції "
"використовують snake_case, а константи використовують ALL_CAPS "
"(Дивіться :ref:`doc_gdscript_styleguide` )."

msgid ""
"**C#**: Classes, export variables and methods use PascalCase, private fields "
"use _camelCase, local variables and parameters use camelCase "
"(See :ref:`doc_c_sharp_styleguide`). Be careful to type the method names "
"precisely when connecting signals."
msgstr ""
"**C#**: Класи, експортовані змінні та методи використовують PascalCase, "
"приватні поля використовують _camelCase, локальні змінні та параметри "
"використовують camelCase (Дивіться :ref:`doc_c_sharp_styleguide` ). Будьте "
"обережні, вводячи назви методів саме під час підключення сигналів."

msgid ""
"Right-click the ``Player`` node and select *Attach Script* to add a new "
"script to it. In the popup, set the *Template* to *Empty* before pressing "
"the *Create* button. We set it to *Empty* because we want to write our own "
"code for player movement."
msgstr ""
"Клацніть правою кнопкою миші вузол ``Програвач`` і виберіть *Приєднати "
"сценарій*, щоб додати до нього новий сценарій. У спливаючому вікні "
"встановіть *Шаблон* на *Пустий* перед натисканням кнопки *Створити*. Ми "
"встановили для нього значення *Empty*, тому що ми хочемо написати власний "
"код для руху гравців."

msgid "|image0|"
msgstr "|image0|"

msgid "image0"
msgstr "image0"

msgid ""
"Let's start with the class's properties. We're going to define a movement "
"speed, a fall acceleration representing gravity, and a velocity we'll use to "
"move the character."
msgstr ""
"Почнемо з властивостей класу. Ми збираємося визначити швидкість руху, "
"прискорення падіння, що являє собою гравітацію, і швидкість, яку ми будемо "
"використовувати для переміщення персонажа."

msgid ""
"These are common properties for a moving body. The ``target_velocity`` is "
"a :ref:`3D vector <class_Vector3>` combining a speed with a direction. Here, "
"we define it as a property because we want to update and reuse its value "
"across frames."
msgstr ""
"Це загальні властивості для рухомого тіла. ``target_velocity`` — це :ref:`3D-"
"вектор <class_Vector3>`, який поєднує швидкість із напрямком. Тут ми "
"визначаємо його як властивість, оскільки хочемо оновлювати та повторно "
"використовувати його значення в кадрах."

msgid ""
"The values are quite different from 2D code because distances are in meters. "
"While in 2D, a thousand units (pixels) may only correspond to half of your "
"screen's width, in 3D, it's a kilometer."
msgstr ""
"Значення сильно відрізняються від 2D-коду, тому що відстані вимірюються в "
"метрах. У той час як в 2D, тисяча одиниць (пікселів) може відповідати тільки "
"половині ширини вашого екрану, в 3D, це кілометр."

msgid ""
"Let's code the movement. We start by calculating the input direction vector "
"using the global ``Input`` object, in ``_physics_process()``."
msgstr ""
"Давайте закодуємо рух. Ми починаємо з обчислення вектора напрямку введення "
"за допомогою глобального об’єкта ``Input`` у ``_physics_process()``."

msgid ""
"Here, instead of ``_process()``, we're going to make all calculations using "
"the ``_physics_process()`` virtual function. It's designed specifically for "
"physics-related code like moving a kinematic or rigid body. It updates the "
"node using fixed time intervals."
msgstr ""
"Тут замість ``_process()`` ми будемо робити всі обчислення за допомогою "
"віртуальної функції ``_physics_process()``. Він розроблений спеціально для "
"коду, пов’язаного з фізикою, наприклад переміщення кінематичного або "
"твердого тіла. Він оновлює вузол з використанням фіксованих інтервалів часу."

msgid ""
"To learn more about the difference between ``_process()`` and "
"``_physics_process()``, see :ref:`doc_idle_and_physics_processing`."
msgstr ""
"Щоб дізнатися більше про різницю між ``_process()`` та "
"``_physics_process()`` дивіться :ref:`doc_idle_and_physics_processing`."

msgid ""
"We start by initializing a ``direction`` variable to ``Vector3.ZERO``. Then, "
"we check if the player is pressing one or more of the ``move_*`` inputs and "
"update the vector's ``x`` and ``z`` components accordingly. These correspond "
"to the ground plane's axes."
msgstr ""
"Починаємо з ініціалізації змінної ``direction`` з ``Vector3.ZERO``. Потім ми "
"перевіряємо, чи натискає гравець один, чи кілька, вводів ``move_*``, і "
"відповідно оновлюємо компоненти вектора ``x`` та ``z``. Вони відповідають "
"осям площини землі."

msgid ""
"These four conditions give us eight possibilities and eight possible "
"directions."
msgstr ""
"Ці чотири умови дають нам вісім можливостей і вісім можливих напрямків."

msgid ""
"In case the player presses, say, both W and D simultaneously, the vector "
"will have a length of about ``1.4``. But if they press a single key, it will "
"have a length of ``1``. We want the vector's length to be consistent, and "
"not move faster diagonally. To do so, we can call its ``normalized()`` "
"method."
msgstr ""
"Якщо гравець натисне, скажімо, W і D одночасно, вектор матиме довжину "
"приблизно ``1,4``. Але якщо вони натиснуть одну клавішу, вона матиме довжину "
"``1``. Ми хочемо, щоб довжина вектора була постійною, а не рухався швидше по "
"діагоналі. Для цього ми можемо викликати його метод ``normalized()``."

msgid ""
"Here, we only normalize the vector if the direction has a length greater "
"than zero, which means the player is pressing a direction key."
msgstr ""
"Тут ми нормалізуємо вектор тільки в тому випадку, якщо напрямок має довжину "
"більше нуля, а це означає, що гравець натискає дві клавіші напрямку."

msgid ""
"We compute the direction the ``$Pivot`` is looking by creating a :ref:`Basis "
"<class_Basis>` that looks in the ``direction`` direction."
msgstr ""
"Ми обчислюжмо напрямок в якому дивиться``$Pivot`` створюючи :ref:`Basis "
"<class_Basis>` який дивиться в напрямку``direction``."

msgid ""
"Then, we update the velocity. We have to calculate the ground velocity and "
"the fall speed separately. Be sure to go back one tab so the lines are "
"inside the ``_physics_process()`` function but outside the condition we just "
"wrote above."
msgstr ""
"Потім ми оновлюємо швидкість. Ми повинні обчислити швидкість руху землі та "
"швидкість падіння окремо. Обов’язково поверніться на одну вкладку назад, щоб "
"рядки були всередині функції ``_physics_process()``, але поза умовою, яку ми "
"щойно написали вище."

msgid ""
"The ``CharacterBody3D.is_on_floor()`` function returns ``true`` if the body "
"collided with the floor in this frame. That's why we apply gravity to the "
"``Player`` only while it is in the air."
msgstr ""
"Функція ``CharacterBody3D.is_on_floor()`` повертає ``true``, якщо тіло "
"зіткнулося з підлогою в цьому кадрі. Ось чому ми застосовуємо силу тяжіння "
"до ``Player`` лише тоді, коли він знаходиться в повітрі."

msgid ""
"For the vertical velocity, we subtract the fall acceleration multiplied by "
"the delta time every frame. This line of code will cause our character to "
"fall in every frame, as long as it is not on or colliding with the floor."
msgstr ""
"Для вертикальної швидкості ми віднімаємо прискорення падіння, помножене на "
"дельта-час кожного кадру. Цей рядок коду змушуватиме нашого персонажа падати "
"в кожному кадрі, якщо він не буде на підлозі або не стикається з нею."

msgid ""
"The physics engine can only detect interactions with walls, the floor, or "
"other bodies during a given frame if movement and collisions happen. We will "
"use this property later to code the jump."
msgstr ""
"Фізичний рушій може виявляти взаємодії зі стінами, підлогою або іншими "
"тілами під час заданого кадру тільки в тому випадку, якщо відбуваються рухи "
"і зіткнення. Ми скористаємося цією властивістю пізніше, щоб закодувати "
"стрибок."

msgid ""
"On the last line, we call ``CharacterBody3D.move_and_slide()`` which is a "
"powerful method of the ``CharacterBody3D`` class that allows you to move a "
"character smoothly. If it hits a wall midway through a motion, the engine "
"will try to smooth it out for you. It uses the *velocity* value native to "
"the :ref:`CharacterBody3D <class_CharacterBody3D>`"
msgstr ""
"В останньому рядку ми викликаємо ``CharacterBody3D.move_and_slide()``, який "
"є потужним методом класу ``CharacterBody3D``, що дозволяє плавно "
"переміщувати персонажа. Якщо він вдаряється об стіну посеред руху, рушій "
"спробує згладити це для вас. Для цього використовується значення *velocity*, "
"що належить класу :ref:`CharacterBody3D <class_CharacterBody3D>`"

msgid "And that's all the code you need to move the character on the floor."
msgstr "І це весь код, який вам потрібен для переміщення персонажа по підлозі."

msgid "Here is the complete ``player.gd`` code for reference."
msgstr "Ось повний код ``player.gd`` для довідки."

msgid "Testing our player's movement"
msgstr "Тестування руху нашого гравця"

msgid ""
"We're going to put our player in the ``Main`` scene to test it. To do so, we "
"need to instantiate the player and then add a camera. Unlike in 2D, in 3D, "
"you won't see anything if your viewport doesn't have a camera pointing at "
"something."
msgstr ""
"Ми розмістимо наш гравець на ``основній сцені``, щоб перевірити його. Для "
"цього нам потрібно створити екземпляр програвача, а потім додати камеру. На "
"відміну від 2D, у 3D ви нічого не побачите, якщо у вікні перегляду немає "
"камери, спрямованої на щось."

msgid ""
"Save your ``Player`` scene and open the ``Main`` scene. You can click on the "
"*Main* tab at the top of the editor to do so."
msgstr ""
"Збережіть свою сцену ``Гравець`` і відкрийте ``Головну`` сцену. Щоб зробити "
"це, ви можете натиснути вкладку *Головна* у верхній частині редактора."

msgid "|image1|"
msgstr "|image1|"

msgid "image1"
msgstr "image1"

msgid ""
"If you closed the scene before, head to the *FileSystem* dock and double-"
"click ``main.tscn`` to re-open it."
msgstr ""
"Якщо ви закрили сцену раніше, перейдіть до док-станції *FileSystem* і двічі "
"клацніть ``main.tscn``, щоб знову відкрити її."

msgid ""
"To instantiate the ``Player``, right-click on the ``Main`` node and select "
"*Instantiate Child Scene*."
msgstr ""
"Щоб створити екземпляр ``Player``, клацніть правою кнопкою миші вузол "
"``Main`` і виберіть *Instantiate Child Scene*."

msgid "|image2|"
msgstr "|image2|"

msgid "image2"
msgstr "image2"

msgid ""
"In the popup, double-click ``player.tscn``. The character should appear in "
"the center of the viewport."
msgstr ""
"У спливаючому вікні двічі клацніть ``player.tscn``. Символ має з’явитися в "
"центрі вікна перегляду."

msgid "Adding a camera"
msgstr "Додавання камери"

msgid ""
"Let's add the camera next. Like we did with our *Player*\\ 's *Pivot*, we're "
"going to create a basic rig. Right-click on the ``Main`` node again and "
"select *Add Child Node*. Create a new :ref:`Marker3D <class_Marker3D>`, and "
"name it ``CameraPivot``. Select ``CameraPivot`` and add a child "
"node :ref:`Camera3D <class_Camera3D>` to it. Your scene tree should look "
"similar to this."
msgstr ""
"Далі додамо камеру. Як ми робили з *Pivot* нашого *Player*\\, ми збираємося "
"створити базову установку. Ще раз клацніть правою кнопкою миші на вузлі "
"``Main`` і виберіть *Add Child Node*. Створіть новий :ref:`Marker3D "
"<class_Marker3D>` і назвіть його ``CameraPivot``. Виберіть ``CameraPivot`` і "
"додайте до нього дочірній вузол :ref:`Camera3D <class_Camera3D>`. Ваше "
"дерево сцени має виглядати приблизно так."

msgid "|image3|"
msgstr "|image3|"

msgid "image3"
msgstr "image3"

msgid ""
"Notice the *Preview* checkbox that appears in the top-left of the 3D view "
"when you have the *Camera* selected. You can click it to preview the in-game "
"camera projection."
msgstr ""
"Зверніть увагу на прапорець *Попередній перегляд*, який з’являється у "
"верхньому лівому куті тривимірного перегляду, коли ви вибрали *Камеру*. Ви "
"можете натиснути її, щоб переглянути проекцію камери в грі."

msgid "|image4|"
msgstr "|image4|"

msgid "image4"
msgstr "image4"

msgid ""
"We're going to use the *Pivot* to rotate the camera as if it was on a crane. "
"Let's first split the 3D view to be able to freely navigate the scene and "
"see what the camera sees."
msgstr ""
"Ми збираємося використовувати *Pivot* для повороту камери, ніби вона крані. "
"Давайте спочатку розділимо 3D-вигляд, щоб мати можливість вільно "
"переміщатися по сцені і бачити, що бачить камера."

msgid ""
"In the toolbar right above the viewport, click on *View*, then *2 "
"Viewports*. You can also press :kbd:`Ctrl + 2` (:kbd:`Cmd + 2` on macOS)."
msgstr ""
"На панелі інструментів прямо над вікном перегляду, натисніть на *Перегляд*, "
"а потім *2 Панелі перегляду*. Ви також можете натиснути :kbd:`Ctrl + 2` "
"(:kbd:`Cmd + 2` на macOS)."

msgid "|image11|"
msgstr "|image11|"

msgid "image11"
msgstr "image11"

msgid "|image5|"
msgstr "|image5|"

msgid "image5"
msgstr "image5"

msgid ""
"On the bottom view, select your :ref:`Camera3D <class_Camera3D>` and turn on "
"camera Preview by clicking the checkbox."
msgstr ""
"У нижньому поданні виберіть свій :ref:`Camera3D <class_Camera3D>` та "
"ввімкніть попередній перегляд камери, натиснувши прапорець."

msgid "|image6|"
msgstr "|image6|"

msgid "image6"
msgstr "image6"

msgid ""
"In the top view, make sure your *Camera3D* is selected and move the camera "
"about ``19`` units on the Z axis (drag the blue arrow)."
msgstr ""
"У верхньому поданні переконайтеся, що вибрано *Camera3D*, і перемістіть "
"камеру навколо одиниць ``19`` по осі Z (перетягніть синю стрілку)."

msgid "|image7|"
msgstr "|image7|"

msgid "image7"
msgstr "image7"

msgid ""
"Here's where the magic happens. Select the *CameraPivot* and rotate it "
"``-45`` degrees around the X axis (using the red circle). You'll see the "
"camera move as if it was attached to a crane."
msgstr ""
"Ось де відбувається магія. Виберіть *CameraPivot* і поверніть його на "
"``-45`` градусів навколо осі X (використовуючи червоне коло). Ви побачите, "
"як камера рухається, ніби її прикріпили до крана."

msgid "|image8|"
msgstr "|image8|"

msgid "image8"
msgstr "image8"

msgid ""
"You can run the scene by pressing :kbd:`F6` and press the arrow keys to move "
"the character."
msgstr ""
"Ви можете запустити сцену, натиснувши :kbd:`F6` та скористатися клавішами зі "
"стрілками для переміщення персонажа."

msgid "|image9|"
msgstr "|image9|"

msgid "image9"
msgstr "image9"

msgid ""
"We can see some empty space around the character due to the perspective "
"projection. In this game, we're going to use an orthographic projection "
"instead to better frame the gameplay area and make it easier for the player "
"to read distances."
msgstr ""
"Ми можемо бачити деякий порожній простір навколо персонажа завдяки "
"перспективній проекції. У цій грі ми збираємося використовувати ортографічну "
"проекцію, щоб краще обрамити ігрову зону та полегшити гравцеві читання "
"відстаней."

msgid ""
"Select the *Camera* again and in the *Inspector*, set the *Projection* to "
"*Orthogonal* and the *Size* to ``19``. The character should now look flatter "
"and the ground should fill the background."
msgstr ""
"Знову виберіть камеру і в *Інспекторі* встановіть для *Projection* значення "
"*Orthogonal* і *Size* на ``19``. Персонаж тепер повинен виглядати плоскішим, "
"а земля повинна заповнити фон."

msgid ""
"When using an orthogonal camera in Godot 4, directional shadow quality is "
"dependent on the camera's *Far* value. The higher the *Far* value, the "
"further away the camera will be able to see. However, higher *Far* values "
"also decrease shadow quality as the shadow rendering has to cover a greater "
"distance."
msgstr ""
"Коли в Godot 4 використовується ортогональна камера, якість направленних "
"тіней залежить від значення дальності *Far* камери. Чим більше значення "
"*Far*, тим далі камера буде бачити. Водночас більше значення *Far* також "
"знижує якість тіней так як рендер тіней має покрити більшу відстань."

msgid ""
"If directional shadows look too blurry after switching to an orthogonal "
"camera, decrease the camera's *Far* property to a lower value such as "
"``100``. Don't decrease this *Far* property too much, or objects in the "
"distance will start disappearing."
msgstr ""
"Якщо направлені тіні виглядають занадто розмотими після переходу на "
"ортогональну камеру, зменшіть значення дальності *Far* камери на менше, таке "
"як ``100``. Не зменшуйте значення *Far* занадто, інакше обʼєкти розташовані "
"на відстані почнуть зникати."

msgid "|image10|"
msgstr "|image10|"

msgid "image10"
msgstr "image10"

msgid ""
"Test your scene and you should be able to move in all 8 directions and not "
"glitch through the floor!"
msgstr ""
"Протестуйте вашу сцену, ви повинні бути в змозі рухатися в усих 8ми "
"напрямках і не провалюватись крізь підлогу!"

msgid ""
"Ultimately, we have both player movement and the view in place. Next, we "
"will work on the monsters."
msgstr ""
"Зрештою, у нас є як рух гравця, так і вид. Далі ми попрацюємо над монстрами."
