#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The main game scene"
msgstr "Головна сцена гри"

msgid ""
"Now it's time to bring everything we did together into a playable game scene."
msgstr "Тепер настав час об'єднати все, що ми зробили, разом, в ігрову сцену."

msgid ""
"Create a new scene and add a :ref:`Node <class_Node>` named ``Main``. (The "
"reason we are using Node instead of Node2D is because this node will be a "
"container for handling game logic. It does not require 2D functionality "
"itself.)"
msgstr ""
"Створіть нову сцену та додайте :ref:`Node <class_Node>`*(Вузол)* з ім'ям "
"``Main``. (Ми використовуємо Node, а не Node2D, тому що саме цей вузол буде "
"контейнером для обробки логіки гри. Він не вимагає 2D-функціональності.)"

msgid ""
"Click the **Instance** button (represented by a chain link icon) and select "
"your saved ``player.tscn``."
msgstr ""
"Клацніть кнопку **Створити екземпляр дочірньої сцени** (іконка ланцюжка) і "
"виберіть збережений ``player.tscn``."

msgid ""
"Now, add the following nodes as children of ``Main``, and name them as shown:"
msgstr ""
"Тепер додайте наступні вузли як дочірні вузли ``Main`` і назвіть їх, як "
"показано:"

msgid ""
":ref:`Timer <class_Timer>` (named ``MobTimer``) - to control how often mobs "
"spawn"
msgstr ""
":ref:`Timer <class_Timer>` (названий ``MobTimer``) - щоб контролювати, як "
"часто виникають моби"

msgid ""
":ref:`Timer <class_Timer>` (named ``ScoreTimer``) - to increment the score "
"every second"
msgstr ""
":ref:`Timer <class_Timer>` (названий ``ScoreTimer``) - збільшуватиме рахунок "
"щосекунди"

msgid ""
":ref:`Timer <class_Timer>` (named ``StartTimer``) - to give a delay before "
"starting"
msgstr ""
":ref:`Timer <class_Timer>` (названий ``StartTimer``) - щоб дати затримку "
"перед запуском"

msgid ""
":ref:`Marker2D <class_Marker2D>` (named ``StartPosition``) - to indicate the "
"player's start position"
msgstr ""
":ref:`Marker2D <class_Marker2D>` (названий ``StartPosition``) - для "
"визначення стартової позиції гравця"

msgid ""
"Set the ``Wait Time`` property of each of the ``Timer`` nodes as follows "
"(values are in seconds):"
msgstr ""
"Встановіть властивість ``Час очікування`` кожного з вузлів ``Таймер`` "
"наступним чином (значення в секундах):"

msgid "``MobTimer``: ``0.5``"
msgstr "``MobTimer``: ``0.5``"

msgid "``ScoreTimer``: ``1``"
msgstr "``ScoreTimer``: ``1``"

msgid "``StartTimer``: ``2``"
msgstr "``StartTimer``: ``2``"

msgid ""
"In addition, set the ``One Shot`` property of ``StartTimer`` to \"On\" and "
"set ``Position`` of the ``StartPosition`` node to ``(240, 450)``."
msgstr ""
"Крім того, встановіть властивість ``One Shot`` *(одна спроба)* в "
"``StartTimer`` на \"включено\" і задайте ``Position`` *(позиція)* в "
"``StartPosition`` на ``(240, 450)``."

msgid "Spawning mobs"
msgstr "Поява мобів"

msgid ""
"The Main node will be spawning new mobs, and we want them to appear at a "
"random location on the edge of the screen. Click the ``Main`` node in the "
"Scene dock, then add a child :ref:`Path2D <class_Path2D>` node named "
"``MobPath``. When you select ``Path2D``, you will see some new buttons at "
"the top of the editor:"
msgstr ""
"Головний вузол породжуватиме нових мобів, і ми хочемо, щоб вони з'являлися у "
"випадковому місці на краю екрана. Клацніть вузол ``Головний`` на панелі "
"сцени, потім додайте дочірній вузол :ref:`Path2D <class_Path2D>` з назвою "
"``MobPath``. Коли ви виберете ``Path2D``, ви побачите кілька нових кнопок у "
"верхній частині редактора:"

msgid ""
"Select the middle one (\"Add Point\") and draw the path by clicking to add "
"the points at the corners shown. To have the points snap to the grid, make "
"sure \"Use Grid Snap\" and \"Use Smart Snap\" are both selected. These "
"options can be found to the left of the \"Lock\" button, appearing as a "
"magnet next to some dots and intersecting lines, respectively."
msgstr ""
"Виберіть середню (\"Додати точку\") та намалюйте шлях, клацнувши, щоб додати "
"точки у вказаних кутах. Щоб точки прикріпилися до сітки (ґратки), "
"переконайтеся, що опції \"Використати до ґратки\" та \"Використати "
"прив'язку\", обидві включені. Ці опції можна знайти зліва від кнопки "
"«Блокування», виглядає як магніт з кількома лініями, що перетинаються."

msgid ""
"Draw the path in *clockwise* order, or your mobs will spawn pointing "
"*outwards* instead of *inwards*!"
msgstr ""
"Малюйте доріжку *за годинниковою стрілкою* , інакше ваші моби будуть "
"виникати спрямовані *назовні*, а не *всередину*!"

msgid ""
"After placing point ``4`` in the image, click the \"Close Curve\" button and "
"your curve will be complete."
msgstr ""
"Після розміщення четвертої точки на зображенні натисніть кнопку \"Закрити "
"криву\", і ваша крива буде завершена."

msgid ""
"Now that the path is defined, add a :ref:`PathFollow2D <class_PathFollow2D>` "
"node as a child of ``MobPath`` and name it ``MobSpawnLocation``. This node "
"will automatically rotate and follow the path as it moves, so we can use it "
"to select a random position and direction along the path."
msgstr ""
"Тепер, коли шлях визначений, додайте вузол :ref:`PathFollow2D "
"<class_PathFollow2D>` (слідувати за шляхом 2D) нащадком ``MobPath`` та "
"назвіть його ``MobSpawnLocation``. Цей вузол автоматично обертатиметься та "
"рухатиметься по шляху, тому ми можемо використовувати його для вибору "
"випадкової позиції та напрямку вздовж шляху."

msgid "Your scene should look like this:"
msgstr "Ваше сцена має виглядати так:"

msgid "Main script"
msgstr "Головний скрипт"

msgid ""
"Add a script to ``Main``. At the top of the script, we use ``@export var "
"mob_scene: PackedScene`` to allow us to choose the Mob scene we want to "
"instance."
msgstr ""
"Додайте скрипт до вузла ``Main``. У верхній частині скрипту ми "
"використовуємо ``@export var mob_scene: PackedScene``, щоб ми могли вибрати "
"сцену ``Mob``, екземпляр якої ми хочемо створити."

msgid ""
"Click the ``Main`` node and you will see the ``Mob Scene`` property in the "
"Inspector under \"Main.gd\"."
msgstr ""
"Натисніть вузол ``Main``, і ви побачите властивість ``Mob Scene`` в "
"інспекторі під \"Main.gd\"."

msgid "You can assign this property's value in two ways:"
msgstr "Ви можете змінити значення цієї властивості двома шляхами:"

msgid ""
"Drag ``mob.tscn`` from the \"FileSystem\" dock and drop it in the **Mob "
"Scene** property."
msgstr ""
"Перетягнути ``mob.tscn`` з панелі \"Файлова система\" у властивість ``Mob "
"Scene``."

msgid ""
"Click the down arrow next to \"[empty]\" and choose \"Load\". Select "
"``mob.tscn``."
msgstr ""
"Клацнути стрілочку вниз поряд з \"[empty]\"(пусто) і вибрати \"Load\" "
"(Завантажити). Виберіть ``mob.tscn``."

msgid ""
"Next, select the instance of the ``Player`` scene under ``Main`` node in the "
"Scene dock, and access the Node dock on the sidebar. Make sure to have the "
"Signals tab selected in the Node dock."
msgstr ""
"Далі виберіть вузол ``Player`` на вузлі ``Main`` на панелі Сцена і відкрийте "
"панель Вузла збоку. Переконайтесь, що на панелі Вузла вибрано Сигнали."

msgid ""
"You should see a list of the signals for the ``Player`` node. Find and "
"double-click the ``hit`` signal in the list (or right-click it and select "
"\"Connect...\"). This will open the signal connection dialog. We want to "
"make a new function named ``game_over``, which will handle what needs to "
"happen when a game ends. Type \"game_over\" in the \"Receiver Method\" box "
"at the bottom of the signal connection dialog and click \"Connect\". You are "
"aiming to have the ``hit`` signal emitted from ``Player`` and handled in the "
"``Main`` script. Add the following code to the new function, as well as a "
"``new_game`` function that will set everything up for a new game:"
msgstr ""
"Ви повинні побачити список сигналів для вузла ``Гравець``. Знайдіть і двічі "
"клацніть сигнал ``hit`` у списку (або клацніть його правою кнопкою миші та "
"виберіть «Підключити...»). Відкриється діалогове вікно підключення сигналу. "
"Ми хочемо створити нову функцію під назвою ``game_over``, яка оброблятиме "
"те, що має статися після закінчення гри. Введіть «game_over» у полі «Метод "
"приймача» внизу діалогового вікна підключення сигналу та натисніть "
"«Підключити». Ви прагнете, щоб сигнал ``хіт`` надсилався з ``Player`` і "
"оброблявся в ``Main`` сценарії. Додайте наступний код до нової функції, а "
"також функцію ``new_game``, яка налаштує все для нової гри:"

msgid ""
"Now we'll connect the ``timeout()`` signal of each Timer node "
"(``StartTimer``, ``ScoreTimer``, and ``MobTimer``) to the main script. For "
"each of the three timers, select the timer in the Scene dock, open the "
"Signals tab of the Node dock, then double-click the ``timeout()`` signal in "
"the list. This will open a new signal connection dialog. The default "
"settings in this dialog should be fine, so select **Connect** to create a "
"new signal connection."
msgstr ""
"Тепер ми підключимо сигнал ``timeout()`` кожного вузла Таймера "
"(``StartTimer``, ``ScoreTimer`` та ``MobTimer``) до основного скрипта. Для "
"кожного з трьох таймерів виберіть таймер на панелі Сцена, відкрийте вкладку "
"Сигнали на панелі Вузлів, потім двічі клацніть сигнал ``timeout()`` у "
"списку. Це відкриє діалогове вікно підключення нового сигналу. Налаштування "
"за замовчуванням у цьому діалоговому вікні мають бути влаштовними, тому "
"виберіть **Підключити**, щоб створити нове підключення сигналу."

msgid ""
"Once all three timers have this set up, you should be able to see each timer "
"have a Signal connection for their respective ``timeout()`` signal, showing "
"in green, within their respective Signals tabs:"
msgstr ""
"Після того, як усі три таймери налаштовано, ви зможете побачити, що кожен "
"таймер має підключення Signal для відповідного сигналу ``timeout()``, що "
"відображається зеленим кольором, у відповідних вкладках Signals:"

msgid "(For MobTimer): ``_on_mob_timer_timeout()``"
msgstr "(Для MobTimer): ``_on_mob_timer_timeout()``"

msgid "(For ScoreTimer): ``_on_score_timer_timeout()``"
msgstr "(Для ScoreTimer): ``_on_score_timer_timeout()``"

msgid "(For StartTimer): ``_on_start_timer_timeout()``"
msgstr "(Для StartTimer): ``_on_start_timer_timeout()``"

msgid ""
"Now we define how each of these timers operate by adding the code below. "
"Notice that ``StartTimer`` will start the other two timers, and that "
"``ScoreTimer`` will increment the score by 1."
msgstr ""
"Тепер ми визначимо, як працює кожен із цих таймерів, додавши наведений нижче "
"код. Зверніть увагу, що ``StartTimer`` запустить два інших таймери, а "
"``ScoreTimer`` збільшить рахунок на 1."

msgid ""
"In ``_on_mob_timer_timeout()``, we will create a mob instance, pick a random "
"starting location along the ``Path2D``, and set the mob in motion. The "
"``PathFollow2D`` node will automatically rotate as it follows the path, so "
"we will use that to select the mob's direction as well as its position. When "
"we spawn a mob, we'll pick a random value between ``150.0`` and ``250.0`` "
"for how fast each mob will move (it would be boring if they were all moving "
"at the same speed)."
msgstr ""
"У функції ``_on_mob_timer_timeout()`` ми створимо екземпляр моба, підберемо "
"випадкове початкове місце уздовж ``Path2D`` та приведемо моба у рух. Вузол "
"``PathFollow2D`` буде автоматично обертатися по мірі просування по шляху, "
"так що ми будемо використовувати його, щоб вибрати напрямок моба, а також "
"його позицію. Під час появи моба, ми вибираємо випадкове значення між "
"``150.0`` і ``250.0`` визначаючи швидкість руху (було б нудно, якби всі вони "
"рухалися з однаковою швидкістю)."

msgid ""
"Note that a new instance must be added to the scene using ``add_child()``."
msgstr ""
"Зауважте, що новий екземпляр потрібно додати до сцени за допомогою "
"``add_child()``."

msgid ""
"Why ``PI``? In functions requiring angles, Godot uses *radians*, not "
"degrees. Pi represents a half turn in radians, about ``3.1415`` (there is "
"also ``TAU`` which is equal to ``2 * PI``). If you're more comfortable "
"working with degrees, you'll need to use the ``deg_to_rad()`` and "
"``rad_to_deg()`` functions to convert between the two."
msgstr ""
"Чому ``PI``? У функціях, що вимагають кутів, Godot використовує *радіани* , "
"а не градуси. Пі являє собою половину повороту в радіанах, близько "
"``3.1415`` (є також ``TAU``, що дорівнює ``2 * PI``). Якщо вам зручніше "
"працювати з градусами, вам потрібно буде скористатися функціями "
"``deg_to_rad()`` та ``rad_to_deg()`` для перетворення між ними."

msgid "Testing the scene"
msgstr "Тестування сцени"

msgid ""
"Let's test the scene to make sure everything is working. Add this "
"``new_game`` call to ``_ready()``:"
msgstr ""
"Давайте протестуємо сцену, щоб переконати, що все працює. Додайте "
"``new_game`` до ``_ready()``:"

msgid ""
"Let's also assign ``Main`` as our \"Main Scene\" - the one that runs "
"automatically when the game launches. Press the \"Play\" button and select "
"``main.tscn`` when prompted."
msgstr ""
"Також визначимо ``Main``, як нашу \"Головну Сцену\" - вона буде запускатися "
"автоматично при кожному запуску гри. Натисніть кнопку \"Відтворити\" і "
"виберіть ``main.tscn`` при появі запиту."

msgid ""
"If you had already set another scene as the \"Main Scene\", you can right "
"click ``main.tscn`` in the FileSystem dock and select \"Set As Main Scene\"."
msgstr ""
"Якщо ви вже встановили іншу сцену як \"Головну сцену\", ви можете клацнути "
"правою кнопкою мишки по ``main.tscn`` на панелі Файлова система і вибрати "
"\"Встановити головною сценою\"."

msgid ""
"You should be able to move the player around, see mobs spawning, and see the "
"player disappear when hit by a mob."
msgstr ""
"Ви мали би успішно переміщати повсюди гравця, спостерігати, як народжуються "
"моби, і бачити, як зникає гравець при зіткненні з мобом."

msgid ""
"When you're sure everything is working, remove the call to ``new_game()`` "
"from ``_ready()`` and replace it with ``pass``."
msgstr ""
"Переконавшись, що все працює вилучає виклик ``new_game()`` з ``_ready()`` і "
"замініть його на ``pass``."

msgid ""
"What's our game lacking? Some user interface. In the next lesson, we'll add "
"a title screen and display the player's score."
msgstr ""
"Чого не вистачає нашій грі? Деякого інтерфейсу. На наступному уроці ми "
"додамо титульний екран і відображення рахунку гравця."
