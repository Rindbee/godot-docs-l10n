#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom modules in C++"
msgstr "Спеціальні модулі в C++"

msgid "Modules"
msgstr "Модулі"

msgid ""
"Godot allows extending the engine in a modular way. New modules can be "
"created and then enabled/disabled. This allows for adding new engine "
"functionality at every level without modifying the core, which can be split "
"for use and reuse in different modules."
msgstr ""
"Godot дозволяє розширити двигун за модульним принципом. Нові модулі можна "
"створювати, а потім увімкнути/вимкнути. Це дозволяє додавати нові функції "
"двигуна на кожному рівні без модифікації ядра, яке можна розділити для "
"використання та повторного використання в різних модулях."

msgid ""
"Modules are located in the ``modules/`` subdirectory of the build system. By "
"default, dozens of modules are enabled, such as GDScript (which, yes, is not "
"part of the base engine), the Mono runtime, a regular expressions module, "
"and others. As many new modules as desired can be created and combined. The "
"SCons build system will take care of it transparently."
msgstr ""
"Модулі знаходяться в підкаталозі ``modules/`` системи збирання. За "
"замовчуванням увімкнено десятки модулів, таких як GDScript (який, так, не є "
"частиною базового механізму), середовище виконання Mono, модуль регулярних "
"виразів та інші. Можна створювати та комбінувати скільки завгодно нових "
"модулів. Система збірки SCons подбає про це прозоро."

msgid "What for?"
msgstr "для чого?"

msgid ""
"While it's recommended that most of a game be written in scripting (as it is "
"an enormous time saver), it's perfectly possible to use C++ instead. Adding "
"C++ modules can be useful in the following scenarios:"
msgstr ""
"Незважаючи на те, що більшість ігор рекомендується писати за допомогою "
"сценаріїв (оскільки це значно економить час), замість цього цілком можливо "
"використовувати C++. Додавання модулів C++ може бути корисним у таких "
"випадках:"

msgid "Binding an external library to Godot (like PhysX, FMOD, etc)."
msgstr ""
"Прив’язка зовнішньої бібліотеки до Godot (наприклад, PhysX, FMOD тощо)."

msgid "Optimize critical parts of a game."
msgstr "Оптимізуйте важливі частини гри."

msgid "Adding new functionality to the engine and/or editor."
msgstr "Додавання нових функцій до движка та/або редактора."

msgid "Porting an existing game to Godot."
msgstr "Перенесення існуючої гри на Godot."

msgid "Write a whole, new game in C++ because you can't live without C++."
msgstr "Напишіть цілу нову гру на C++, тому що ви не можете жити без C++."

msgid "Creating a new module"
msgstr "Створення модуля"

msgid ""
"Before creating a module, make sure to :ref:`download the source code of "
"Godot and compile it <toc-devel-compiling>`."
msgstr ""
"Перед створенням модуля обов’язково :ref:`download the source code of Godot "
"and compile it <toc-devel-compiling>`."

msgid ""
"To create a new module, the first step is creating a directory inside "
"``modules/``. If you want to maintain the module separately, you can "
"checkout a different VCS into modules and use it."
msgstr ""
"Щоб створити новий модуль, першим кроком є створення каталогу всередині "
"``modules/``. Якщо ви хочете підтримувати модуль окремо, ви можете розділити "
"інший VCS на модулі та використовувати його."

msgid ""
"The example module will be called \"summator\" (``godot/modules/summator``). "
"Inside we will create a summator class:"
msgstr ""
"Приклад модуля буде називатися \"summator\" (``godot/modules/summator``). "
"Всередині ми створимо клас суматора:"

msgid "godot/modules/summator/summator.h"
msgstr "godot/modules/summator/summator.h"

msgid "And then the cpp file."
msgstr "А потім файл cpp."

msgid "godot/modules/summator/summator.cpp"
msgstr "godot/modules/summator/summator.cpp"

msgid ""
"Then, the new class needs to be registered somehow, so two more files need "
"to be created:"
msgstr ""
"Потім новий клас потрібно якимось чином зареєструвати, тому необхідно "
"створити ще два файли:"

msgid ""
"These files must be in the top-level folder of your module (next to your "
"``SCsub`` and ``config.py`` files) for the module to be registered properly."
msgstr ""
"Ці файли мають бути у папці верхнього рівня вашого модуля (поруч із файлами "
"``SCsub`` і ``config.py``), щоб модуль було зареєстровано належним чином."

msgid "These files should contain the following:"
msgstr "Ці файли повинні містити наступне:"

msgid "godot/modules/summator/register_types.h"
msgstr "godot/modules/summator/register_types.h"

msgid "godot/modules/summator/register_types.cpp"
msgstr "godot/modules/summator/register_types.cpp"

msgid ""
"Next, we need to create an ``SCsub`` file so the build system compiles this "
"module:"
msgstr ""
"Далі нам потрібно створити файл ``SCsub``, щоб система збірки скомпілювала "
"цей модуль:"

msgid "godot/modules/summator/SCsub"
msgstr "godot/modules/summator/SCsub"

msgid ""
"With multiple sources, you can also add each file individually to a Python "
"string list:"
msgstr ""
"З кількома джерелами ви також можете додати кожен файл окремо до списку "
"рядків Python:"

msgid ""
"This allows for powerful possibilities using Python to construct the file "
"list using loops and logic statements. Look at some modules that ship with "
"Godot by default for examples."
msgstr ""
"Це дає потужні можливості за допомогою Python для створення списку файлів за "
"допомогою циклів і логічних операторів. Подивіться на приклади деяких "
"модулів, які стандартно поставляються з Godot."

msgid ""
"To add include directories for the compiler to look at you can append it to "
"the environment's paths:"
msgstr ""
"Щоб додати каталоги include для перегляду компілятором, ви можете додати "
"його до шляхів середовища:"

msgid ""
"If you want to add custom compiler flags when building your module, you need "
"to clone ``env`` first, so it won't add those flags to whole Godot build "
"(which can cause errors). Example ``SCsub`` with custom flags:"
msgstr ""
"Якщо ви хочете додати власні прапорці компілятора під час створення свого "
"модуля, вам потрібно спочатку клонувати ``env``, щоб він не додавав ці "
"прапорці до всієї збірки Godot (що може спричинити помилки). Приклад "
"``SCsub`` із спеціальними прапорцями:"

msgid ""
"And finally, the configuration file for the module, this is a Python script "
"that must be named ``config.py``:"
msgstr ""
"І, нарешті, файл конфігурації для модуля, це сценарій Python, який повинен "
"мати назву ``config.py``:"

msgid "godot/modules/summator/config.py"
msgstr "godot/modules/summator/config.py"

msgid ""
"The module is asked if it's OK to build for the specific platform (in this "
"case, ``True`` means it will build for every platform)."
msgstr ""
"Модуль запитується, чи його можна створювати для конкретної платформи (у "
"цьому випадку ``True`` означає, що він збиратиметься для кожної платформи)."

msgid ""
"And that's it. Hope it was not too complex! Your module should look like "
"this:"
msgstr ""
"І все. Сподіваюся, це було не надто складно! Ваш модуль має виглядати так:"

msgid ""
"You can then zip it and share the module with everyone else. When building "
"for every platform (instructions in the previous sections), your module will "
"be included."
msgstr ""
"Потім ви можете заархівувати його та поділитися модулем з усіма іншими. Під "
"час створення для кожної платформи (інструкції в попередніх розділах) ваш "
"модуль буде включено."

msgid "Using the module"
msgstr "Користування модулем"

msgid "You can now use your newly created module from any script:"
msgstr ""
"Тепер ви можете використовувати ваш щойно створений модуль з будь-якого "
"сценарію:"

msgid "The output will be ``60``."
msgstr "Результатом буде ``60``."

msgid ""
"The previous Summator example is great for small, custom modules, but what "
"if you want to use a larger, external library? Refer "
"to :ref:`doc_binding_to_external_libraries` for details about binding to "
"external libraries."
msgstr ""
"Попередній приклад Summator чудово підходить для невеликих спеціальних "
"модулів, але що, якщо ви хочете використовувати більшу зовнішню бібліотеку? "
"Зверніться до :ref:`doc_binding_to_external_libraries`, щоб дізнатися більше "
"про прив’язку до зовнішніх бібліотек."

msgid ""
"If your module is meant to be accessed from the running project (not just "
"from the editor), you must also recompile every export template you plan to "
"use, then specify the path to the custom template in each export preset. "
"Otherwise, you'll get errors when running the project as the module isn't "
"compiled in the export template. See the :ref:`Compiling <toc-devel-"
"compiling>` pages for more information."
msgstr ""
"Якщо ваш модуль призначений для доступу з запущеного проекту (а не лише з "
"редактора), ви також повинні перекомпілювати кожен шаблон експорту, який ви "
"плануєте використовувати, а потім указати шлях до спеціального шаблону в "
"кожному стилі експорту. Інакше ви отримаєте помилки під час запуску проекту, "
"оскільки модуль не скомпільовано в шаблон експорту. Перегляньте "
"сторінки :ref:`Compiling <toc-devel-compiling>` для отримання додаткової "
"інформації."

msgid "Compiling a module externally"
msgstr "Зовнішня компіляція модуля"

msgid ""
"Compiling a module involves moving the module's sources directly under the "
"engine's ``modules/`` directory. While this is the most straightforward way "
"to compile a module, there are a couple of reasons as to why this might not "
"be a practical thing to do:"
msgstr ""
"Компіляція модуля передбачає переміщення вихідних кодів модуля безпосередньо "
"в каталог ``modules/`` механізму. Хоча це найпростіший спосіб компіляції "
"модуля, є кілька причин, чому це може бути непрактично:"

msgid ""
"Having to manually copy modules sources every time you want to compile the "
"engine with or without the module, or taking additional steps needed to "
"manually disable a module during compilation with a build option similar to "
"``module_summator_enabled=no``. Creating symbolic links may also be a "
"solution, but you may additionally need to overcome OS restrictions like "
"needing the symbolic link privilege if doing this via script."
msgstr ""
"Потрібно вручну копіювати вихідні коди модулів кожного разу, коли ви хочете "
"скомпілювати механізм з модулем або без нього, або вживати додаткових "
"кроків, необхідних для ручного вимкнення модуля під час компіляції за "
"допомогою параметра збірки, подібного до ``module_summator_enabled=no``. "
"Створення символічних посилань також може бути рішенням, але вам може "
"додатково знадобитися подолати обмеження ОС, як-от потреба в привілеї "
"символічного посилання, якщо це робити за допомогою сценарію."

msgid ""
"Depending on whether you have to work with the engine's source code, the "
"module files added directly to ``modules/`` changes the working tree to the "
"point where using a VCS (like ``git``) proves to be cumbersome as you need "
"to make sure that only the engine-related code is committed by filtering "
"changes."
msgstr ""
"Залежно від того, чи потрібно вам працювати з вихідним кодом двигуна, файли "
"модулів, додані безпосередньо до ``modules/``, змінюють робоче дерево до "
"точки, коли використання VCS (наприклад, ``git``) виявляється громіздким, "
"оскільки ви необхідно переконатися, що лише пов’язаний з двигуном код "
"фіксується шляхом фільтрації змін."

msgid ""
"So if you feel like the independent structure of custom modules is needed, "
"lets take our \"summator\" module and move it to the engine's parent "
"directory:"
msgstr ""
"Отже, якщо ви вважаєте, що потрібна незалежна структура користувальницьких "
"модулів, візьмемо наш модуль «summator» і перемістимо його до батьківського "
"каталогу механізму:"

msgid ""
"Compile the engine with our module by providing ``custom_modules`` build "
"option which accepts a comma-separated list of directory paths containing "
"custom C++ modules, similar to the following:"
msgstr ""
"Скомпілюйте движок із нашим модулем, надавши опцію збірки "
"``custom_modules``, яка приймає розділений комами список шляхів до каталогу, "
"що містить спеціальні модулі C++, подібно до наступного:"

msgid ""
"The build system shall detect all modules under the ``../modules`` directory "
"and compile them accordingly, including our \"summator\" module."
msgstr ""
"Система збірки має виявити всі модулі в каталозі ``../modules`` і "
"скомпілювати їх відповідно, включаючи наш модуль «summator»."

msgid ""
"Any path passed to ``custom_modules`` will be converted to an absolute path "
"internally as a way to distinguish between custom and built-in modules. It "
"means that things like generating module documentation may rely on a "
"specific path structure on your machine."
msgstr ""
"Будь-який шлях, переданий до ``custom_modules``, буде внутрішньо перетворено "
"на абсолютний шлях, щоб відрізнити спеціальні та вбудовані модулі. Це "
"означає, що такі речі, як створення документації модуля, можуть покладатися "
"на певну структуру шляху на вашій машині."

msgid ""
":ref:`Introduction to the buildsystem - Custom modules build option "
"<doc_buildsystem_custom_modules>`."
msgstr ""
":ref:`Introduction to the buildsystem - Custom modules build option "
"<doc_buildsystem_custom_modules>`."

msgid "Customizing module types initialization"
msgstr "Налаштування ініціалізації типів модулів"

msgid ""
"Modules can interact with other built-in engine classes during runtime and "
"even affect the way core types are initialized. So far, we've been using "
"``register_summator_types`` as a way to bring in module classes to be "
"available within the engine."
msgstr ""
"Модулі можуть взаємодіяти з іншими вбудованими класами двигуна під час "
"виконання та навіть впливати на спосіб ініціалізації основних типів. Поки що "
"ми використовували ``register_summator_types`` як спосіб додати класи "
"модулів, які будуть доступні в механізмі."

msgid ""
"A crude order of the engine setup can be summarized as a list of the "
"following type registration methods:"
msgstr ""
"Приблизний порядок налаштування двигуна можна підсумувати як список таких "
"методів реєстрації типів:"

msgid ""
"Our ``Summator`` class is initialized during the ``register_module_types()`` "
"call. Imagine that we need to satisfy some common module runtime dependency "
"(like singletons), or allow us to override existing engine method callbacks "
"before they can be assigned by the engine itself. In that case, we want to "
"ensure that our module classes are registered *before* any other built-in "
"type."
msgstr ""
"Наш клас ``Summator`` ініціалізується під час виклику "
"``register_module_types()``. Уявіть, що нам потрібно задовольнити якусь "
"загальну залежність середовища виконання модуля (наприклад, одиночних "
"елементів) або дозволити нам перевизначати існуючі зворотні виклики методів "
"двигуна, перш ніж їх зможе призначити сам механізм. У цьому випадку ми "
"хочемо переконатися, що наші класи модулів зареєстровані *перед* будь-яким "
"іншим вбудованим типом."

msgid ""
"This is where we can define an optional ``preregister_summator_types()`` "
"method which will be called before anything else during the "
"``preregister_module_types()`` engine setup stage."
msgstr ""
"Тут ми можемо визначити необов’язковий метод "
"``preregister_summator_types()``, який буде викликаний перед будь-яким іншим "
"під час етапу налаштування двигуна ``preregister_module_types()``."

msgid ""
"We now need to add this method to ``register_types`` header and source files:"
msgstr ""
"Тепер нам потрібно додати цей метод до заголовка ``register_types`` і "
"вихідних файлів:"

msgid ""
"Unlike other register methods, we have to explicitly define "
"``MODULE_SUMMATOR_HAS_PREREGISTER`` to let the build system know what "
"relevant method calls to include at compile time. The module's name has to "
"be converted to uppercase as well."
msgstr ""
"На відміну від інших методів реєстру, ми повинні явно визначити "
"``MODULE_SUMMATOR_HAS_PREREGISTER``, щоб дозволити системі збирання знати, "
"які відповідні виклики методів слід включити під час компіляції. Ім'я модуля "
"також має бути перетворено у верхній регістр."

msgid "Improving the build system for development"
msgstr "Удосконалення системи побудови для розробки"

msgid ""
"This shared library support is not designed to support distributing a module "
"to other users without recompiling the engine. For that purpose, use a "
"GDExtension instead."
msgstr ""
"Ця підтримка спільної бібліотеки не призначена для підтримки розповсюдження "
"модуля іншим користувачам без перекомпіляції механізму. Для цього замість "
"цього використовуйте GDExtension."

msgid ""
"So far, we defined a clean SCsub that allows us to add the sources of our "
"new module as part of the Godot binary."
msgstr ""
"Наразі ми визначили чистий SCsub, який дозволяє нам додавати вихідні коди "
"нашого нового модуля як частину двійкового файлу Godot."

msgid ""
"This static approach is fine when we want to build a release version of our "
"game, given we want all the modules in a single binary."
msgstr ""
"Цей статичний підхід підходить, коли ми хочемо створити випускну версію "
"нашої гри, враховуючи, що всі модулі потрібні в одному двійковому файлі."

msgid ""
"However, the trade-off is that every single change requires a full "
"recompilation of the game. Even though SCons is able to detect and recompile "
"only the file that was changed, finding such files and eventually linking "
"the final binary takes a long time."
msgstr ""
"Однак компроміс полягає в тому, що кожна зміна вимагає повної перекомпіляції "
"гри. Незважаючи на те, що SCons здатний виявити та перекомпілювати лише "
"файл, який було змінено, пошук таких файлів і зрештою зв’язування "
"остаточного двійкового файлу займає багато часу."

msgid ""
"The solution to avoid such a cost is to build our own module as a shared "
"library that will be dynamically loaded when starting our game's binary."
msgstr ""
"Щоб уникнути таких витрат, ми можемо створити наш власний модуль як спільну "
"бібліотеку, яка динамічно завантажуватиметься під час запуску двійкового "
"файлу нашої гри."

msgid ""
"Once compiled, we should end up with a ``bin`` directory containing both the "
"``godot*`` binary and our ``libsummator*.so``. However given the .so is not "
"in a standard directory (like ``/usr/lib``), we have to help our binary find "
"it during runtime with the ``LD_LIBRARY_PATH`` environment variable:"
msgstr ""
"Після компіляції ми маємо отримати каталог ``bin``, що містить двійковий "
"файл ``godot*`` і наш ``libsummator*.so``. Однак, враховуючи, що .so не "
"знаходиться в стандартному каталозі (наприклад, ``/usr/lib``), ми повинні "
"допомогти нашому двійковому файлу знайти його під час виконання за допомогою "
"змінної середовища ``LD_LIBRARY_PATH``:"

msgid ""
"You have to ``export`` the environment variable. Otherwise, you won't be "
"able to run your project from the editor."
msgstr ""
"Ви повинні ``експортувати`` змінну середовища. Інакше ви не зможете "
"запустити свій проект із редактора."

msgid ""
"On top of that, it would be nice to be able to select whether to compile our "
"module as shared library (for development) or as a part of the Godot binary "
"(for release). To do that we can define a custom flag to be passed to SCons "
"using the ``ARGUMENT`` command:"
msgstr ""
"Крім того, було б добре мати можливість вибрати, чи скомпілювати наш модуль "
"як спільну бібліотеку (для розробки) чи як частину двійкового файлу Godot "
"(для випуску). Для цього ми можемо визначити спеціальний прапор, який буде "
"передано SCons за допомогою команди ``ARGUMENT``:"

msgid ""
"Now by default ``scons`` command will build our module as part of Godot's "
"binary and as a shared library when passing ``summator_shared=yes``."
msgstr ""
"Тепер за замовчуванням команда ``scons`` побудує наш модуль як частину "
"двійкового файлу Godot та як спільну бібліотеку, якщо передати "
"``summator_shared=yes``."

msgid ""
"Finally, you can even speed up the build further by explicitly specifying "
"your shared module as target in the SCons command:"
msgstr ""
"Нарешті, ви навіть можете ще більше прискорити збірку, явно вказавши свій "
"спільний модуль як ціль у команді SCons:"

msgid "Writing custom documentation"
msgstr "Написання індивідуальної документації"

msgid ""
"Writing documentation may seem like a boring task, but it is highly "
"recommended to document your newly created module to make it easier for "
"users to benefit from it. Not to mention that the code you've written one "
"year ago may become indistinguishable from the code that was written by "
"someone else, so be kind to your future self!"
msgstr ""
"Написання документації може здатися нудним завданням, але настійно "
"рекомендуємо задокументувати ваш щойно створений модуль, щоб користувачам "
"було легше використовувати його. Не кажучи вже про те, що код, який ви "
"написали рік тому, може стати невідрізнимим від коду, написаного кимось "
"іншим, тому будьте добрі до себе в майбутньому!"

msgid "There are several steps in order to setup custom docs for the module:"
msgstr "Існує кілька кроків, щоб налаштувати власні документи для модуля:"

msgid ""
"Make a new directory in the root of the module. The directory name can be "
"anything, but we'll be using the ``doc_classes`` name throughout this "
"section."
msgstr ""
"Створіть новий каталог у корені модуля. Ім’я каталогу може бути будь-яким, "
"але в цьому розділі ми використовуватимемо ім’я ``doc_classes``."

msgid "Now, we need to edit ``config.py``, add the following snippet:"
msgstr ""
"Тепер нам потрібно відредагувати ``config.py``, додати наступний фрагмент:"

msgid ""
"The ``get_doc_path()`` function is used by the build system to determine the "
"location of the docs. In this case, they will be located in the ``modules/"
"summator/doc_classes`` directory. If you don't define this, the doc path for "
"your module will fall back to the main ``doc/classes`` directory."
msgstr ""
"Функція ``get_doc_path()`` використовується системою збирання для визначення "
"розташування документів. У цьому випадку вони будуть розташовані в каталозі "
"``modules/summator/doc_classes``. Якщо ви не визначите це, шлях документа "
"для вашого модуля повертатиметься до головного каталогу ``doc/classes``."

msgid ""
"The ``get_doc_classes()`` method is necessary for the build system to know "
"which registered classes belong to the module. You need to list all of your "
"classes here. The classes that you don't list will end up in the main ``doc/"
"classes`` directory."
msgstr ""
"Метод ``get_doc_classes()`` необхідний, щоб система збирання знала, які "
"зареєстровані класи належать до модуля. Тут потрібно вказати всі свої класи. "
"Класи, які ви не вказали, потраплять у головний каталог ``doc/classes``."

msgid ""
"You can use Git to check if you have missed some of your classes by checking "
"the untracked files with ``git status``. For example:"
msgstr ""
"Ви можете використовувати Git, щоб перевірити, чи пропустили ви деякі "
"заняття, перевіривши невідстежувані файли за допомогою ``git status``. "
"Наприклад:"

msgid "Example output:"
msgstr "Приклад виводу:"

msgid "Now we can generate the documentation:"
msgstr "Тепер ми можемо створити документацію:"

msgid ""
"We can do this via running Godot's doctool i.e. ``godot --doctool <path>``, "
"which will dump the engine API reference to the given ``<path>`` in XML "
"format."
msgstr ""
"Ми можемо зробити це, запустивши doctool Godot, наприклад ``godot --doctool "
"<path>``, який створить дамп посилання API механізму на заданий ``<path>`` у "
"форматі XML."

msgid ""
"In our case we'll point it to the root of the cloned repository. You can "
"point it to an another folder, and just copy over the files that you need."
msgstr ""
"У нашому випадку ми вкажемо його на корінь клонованого сховища. Ви можете "
"вказати його в іншу папку та просто скопіювати файли, які вам потрібні."

msgid "Run command:"
msgstr "Виконати команду:"

msgid ""
"Now if you go to the ``godot/modules/summator/doc_classes`` folder, you will "
"see that it contains a ``Summator.xml`` file, or any other classes, that you "
"referenced in your ``get_doc_classes`` function."
msgstr ""
"Тепер, якщо ви перейдете до папки ``godot/modules/summator/doc_classes``, ви "
"побачите, що вона містить файл ``Summator.xml`` або будь-які інші класи, на "
"які ви посилалися у ``get_doc_classes`` функція."

msgid ""
"Once the compilation process is finished, the docs will become accessible "
"within the engine's built-in documentation system."
msgstr ""
"Після завершення процесу компіляції документи стануть доступними у "
"вбудованій системі документації двигуна."

msgid ""
"In order to keep documentation up-to-date, all you'll have to do is simply "
"modify one of the XML files and recompile the engine from now on."
msgstr ""
"Щоб підтримувати документацію в актуальному стані, все, що вам потрібно "
"зробити, це просто змінити один із файлів XML і відтепер перекомпілювати "
"механізм."

msgid ""
"If you change your module's API, you can also re-extract the docs, they will "
"contain the things that you previously added. Of course if you point it to "
"your godot folder, make sure you don't lose work by extracting older docs "
"from an older engine build on top of the newer ones."
msgstr ""
"Якщо ви зміните API свого модуля, ви також можете повторно розпакувати "
"документи, вони міститимуть те, що ви додали раніше. Звичайно, якщо ви "
"вказуєте його на свою папку godot, переконайтеся, що ви не втратите роботу, "
"витягнувши старіші документи зі старішої збірки двигуна поверх новіших."

msgid ""
"Note that if you don't have write access rights to your supplied ``<path>``, "
"you might encounter an error similar to the following:"
msgstr ""
"Зауважте, що якщо у вас немає прав доступу на запис до наданого ``<path>``, "
"ви можете зіткнутися з помилкою, подібною до наведеної нижче:"

msgid "Writing custom unit tests"
msgstr "Написання індивідуальних тестів"

msgid ""
"It's possible to write self-contained unit tests as part of a C++ module. If "
"you are not familiar with the unit testing process in Godot yet, please "
"refer to :ref:`doc_unit_testing`."
msgstr ""
"Можна писати самодостатні модульні тести як частину модуля C++. Якщо ви ще "
"не знайомі з процесом модульного тестування в Godot, зверніться "
"до :ref:`doc_unit_testing`."

msgid "The procedure is the following:"
msgstr "Процедура така:"

msgid "Create a new directory named ``tests/`` under your module's root:"
msgstr "Створіть новий каталог під назвою ``tests/`` у корені вашого модуля:"

msgid ""
"Create a new test suite: ``test_summator.h``. The header must be prefixed "
"with ``test_`` so that the build system can collect it and include it as "
"part of the ``tests/test_main.cpp`` where the tests are run."
msgstr ""
"Створіть новий набір тестів: ``test_summator.h``. Заголовок має мати префікс "
"``test_``, щоб система збірки могла зібрати його та включити як частину "
"``tests/test_main.cpp``, де виконуються тести."

msgid "Write some test cases. Here's an example:"
msgstr "Напишіть кілька тестів. Ось приклад:"

msgid "godot/modules/summator/tests/test_summator.h"
msgstr "godot/modules/summator/tests/test_summator.h"

msgid ""
"Compile the engine with ``scons tests=yes``, and run the tests with the "
"following command:"
msgstr ""
"Скомпілюйте механізм за допомогою ``scons tests=yes`` і запустіть тести за "
"допомогою такої команди:"

msgid "You should see the passing assertions now."
msgstr "Тепер ви повинні побачити мимохідні твердження."

msgid "Adding custom editor icons"
msgstr "Додавання власних піктограм редактора"

msgid ""
"Similarly to how you can write self-contained documentation within a module, "
"you can also create your own custom icons for classes to appear in the "
"editor."
msgstr ""
"Подібно до того, як ви можете писати самодостатню документацію в модулі, ви "
"також можете створювати власні значки для класів, які відображатимуться в "
"редакторі."

msgid ""
"For the actual process of creating editor icons to be integrated within the "
"engine, please refer to :ref:`doc_editor_icons` first."
msgstr ""
"Для фактичного процесу створення піктограм редактора, які будуть інтегровані "
"в механізм, будь ласка, спочатку зверніться до :ref:`doc_editor_icons`."

msgid "Once you've created your icon(s), proceed with the following steps:"
msgstr "Створивши піктограми, виконайте такі дії:"

msgid ""
"Make a new directory in the root of the module named ``icons``. This is the "
"default path for the engine to look for module's editor icons."
msgstr ""
"Створіть новий каталог у корені модуля під назвою ``icons``. Це типовий шлях "
"для механізму пошуку піктограм редактора модуля."

msgid ""
"Move your newly created ``svg`` icons (optimized or not) into that folder."
msgstr ""
"Перемістіть щойно створені піктограми ``svg`` (оптимізовані чи ні) до цієї "
"папки."

msgid ""
"Recompile the engine and run the editor. Now the icon(s) will appear in "
"editor's interface where appropriate."
msgstr ""
"Перекомпілюйте двигун і запустіть редактор. Тепер піктограми з’являться в "
"інтерфейсі редактора, де це необхідно."

msgid ""
"If you'd like to store your icons somewhere else within your module, add the "
"following code snippet to ``config.py`` to override the default path:"
msgstr ""
"Якщо ви хочете зберігати свої піктограми десь у своєму модулі, додайте "
"наступний фрагмент коду до ``config.py``, щоб замінити шлях за замовчуванням:"

msgid "Summing up"
msgstr "Підведення підсумків"

msgid "Remember to:"
msgstr "Не забудьте:"

msgid "Use ``GDCLASS`` macro for inheritance, so Godot can wrap it."
msgstr ""
"Використовуйте макрос ``GDCLASS`` для успадкування, щоб Godot міг його "
"обернути."

msgid ""
"Use ``_bind_methods`` to bind your functions to scripting, and to allow them "
"to work as callbacks for signals."
msgstr ""
"Використовуйте ``_bind_methods``, щоб прив’язати свої функції до сценаріїв і "
"дозволити їм працювати як зворотні виклики для сигналів."

msgid ""
"**Avoid multiple inheritance for classes exposed to Godot**, as ``GDCLASS`` "
"doesn't support this. You can still use multiple inheritance in your own "
"classes as long as they're not exposed to Godot's scripting API."
msgstr ""
"**Уникайте множинного успадкування для класів, які піддаються Godot**, "
"оскільки ``GDCLASS`` не підтримує це. Ви все ще можете використовувати "
"множинне успадкування у своїх власних класах, якщо вони не піддаються дії "
"API сценаріїв Godot."

msgid ""
"But this is not all, depending what you do, you will be greeted with some "
"(hopefully positive) surprises."
msgstr ""
"Але це ще не все, залежно від того, що ви робите, вас чекають деякі "
"(сподіваємось, позитивні) сюрпризи."

msgid ""
"If you inherit from :ref:`class_Node` (or any derived node type, such as "
"Sprite2D), your new class will appear in the editor, in the inheritance tree "
"in the \"Add Node\" dialog."
msgstr ""
"Якщо ви успадкуєте від :ref:`class_Node` (або будь-якого похідного типу "
"вузла, наприклад Sprite2D), ваш новий клас з’явиться в редакторі в дереві "
"успадкування в діалоговому вікні «Додати вузол»."

msgid ""
"If you inherit from :ref:`class_Resource`, it will appear in the resource "
"list, and all the exposed properties can be serialized when saved/loaded."
msgstr ""
"Якщо ви успадкуєте від :ref:`class_Resource`, він з’явиться у списку "
"ресурсів, і всі доступні властивості можна буде серіалізувати під час "
"збереження/завантаження."

msgid ""
"By this same logic, you can extend the Editor and almost any area of the "
"engine."
msgstr ""
"За цією ж логікою ви можете розширити редактор і майже будь-яку область "
"движка."
