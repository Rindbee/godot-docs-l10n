#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "Використання вікон перегляду"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"Подумайте про :ref:`Viewport <class_Viewport>` як про екран, на який "
"проектується гра. Щоб побачити гру, нам потрібна поверхня, на якій можна її "
"намалювати. Ця поверхня є кореневим вікном перегляду."

msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`SubViewports <class_SubViewport>` — це свого роду вікно перегляду, яке "
"можна додати до сцени, щоб мати кілька поверхонь для малювання. Коли ми "
"малюємо до SubViewport, ми називаємо це метою візуалізації. Ми можемо "
"отримати доступ до вмісту мети візуалізації, отримавши доступ до "
"відповідної :ref:`texture <class_Viewport_method_get_texture>`. "
"Використовуючи SubViewport як ціль візуалізації, ми можемо або рендерити "
"кілька сцен одночасно, або ми можемо рендерити до :ref:`ViewportTexture "
"<class_ViewportTexture>`, яка застосовується до об’єкта в сцені, наприклад, "
"динамічного скайбокса."

msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ""
":ref:`SubViewports <class_SubViewport>` мають різні варіанти використання, "
"зокрема:"

msgid "Rendering 3D objects within a 2D game"
msgstr "Візуалізація 3D-об’єктів у 2D-грі"

msgid "Rendering 2D elements in a 3D game"
msgstr "Візуалізація 2D-елементів у 3D-грі"

msgid "Rendering dynamic textures"
msgstr "Відтворення динамічних текстур"

msgid "Generating procedural textures at runtime"
msgstr "Створення процедурних текстур під час виконання"

msgid "Rendering multiple cameras in the same scene"
msgstr "Візуалізація кількох камер в одній сцені"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"Спільним для всіх цих варіантів використання є те, що вам надається "
"можливість малювати об’єкти на текстурі, ніби це інший екран, а потім ви "
"можете вибрати, що робити з отриманою текстурою."

msgid ""
"Another kind of Viewports in Godot are :ref:`Windows <class_Window>`. They "
"allow their content to be projected onto a window. While the Root Viewport "
"is a Window, they are less flexible. If you want to use the texture of a "
"Viewport, you'll be working with :ref:`SubViewports <class_SubViewport>` "
"most of the time."
msgstr ""
"Ще один вид вікон перегляду в Godot — :ref:`Windows <class_Window>`. Вони "
"дозволяють проектувати свій вміст на вікно. Хоча кореневий вікно перегляду є "
"вікном, вони менш гнучкі. Якщо ви хочете використовувати текстуру Viewport, "
"ви будете працювати з :ref:`SubViewports <class_SubViewport>` більшу частину "
"часу."

msgid "Input"
msgstr "Введення"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewports <class_Viewport>` також відповідають за доставку правильно "
"налаштованих і масштабованих вхідних подій до своїх дочірніх вузлів. За "
"замовчуванням :ref:`SubViewports <class_SubViewport>` не отримують "
"автоматично вхідні дані, якщо тільки вони не отримують їх від свого "
"прямого :ref:`SubViewportContainer <class_SubViewportContainer>` "
"батьківського вузла. У цьому випадку введення можна вимкнути за допомогою "
"властивості :ref:`Disable Input <class_Viewport_property_gui_disable_input>`."

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"Для отримання додаткової інформації про те, як Godot обробляє вхідні дані, "
"прочитайте :ref:`Навчальний посібник з подій введення <doc_inputevent>`."

msgid "Listener"
msgstr "Listener"

msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes). More on this can be found "
"in the :ref:`Audio Streams Tutorial <doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a :ref:`SubViewport "
"<class_SubViewport>` to display your :ref:`World3D <class_World3D>` "
"or :ref:`World2D <class_World2D>`, don't forget to enable this!"
msgstr ""
"Godot підтримує 3D-звук (у 2D- і 3D-вузлах). Більше про це можна знайти "
"в :ref:`Посібнику з аудіопотоків <doc_audio_streams>`. Щоб цей тип звуку "
"було чутно, :ref:`Viewport <class_Viewport>` потрібно ввімкнути як слухач "
"(для 2D або 3D). Якщо ви використовуєте :ref:`SubViewport "
"<class_SubViewport>` для відображення вашого :ref:`World3D <class_World3D>` "
"або :ref:`World2D <class_World2D>`, не забудьте ввімкнути це!"

msgid "Cameras (2D & 3D)"
msgstr "Камери (2D і 3D)"

msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest "
"parent :ref:`Viewport <class_Viewport>` (going towards the root). For "
"example, in the following hierarchy:"
msgstr ""
"Якщо використовується :ref:`Camera3D <class_Camera3D>` або :ref:`Camera2D "
"<class_Camera2D>`, він завжди відображатиметься на найближчому "
"батьківському :ref:`Viewport <class_Viewport>` (прямуючи до кореня). "
"Наприклад, у такій ієрархії:"

msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"``CameraA`` відображатиметься в кореневому :ref:`Viewport <class_Viewport>` "
"і буде малювати ``MeshA``. ``CameraB`` буде захоплено :ref:`SubViewport "
"<class_SubViewport>` разом із ``MeshB``. Незважаючи на те, що ``MeshB`` "
"знаходиться в ієрархії сцени, він все одно не буде намальовано до кореневого "
"вікна перегляду. Подібним чином, ``MeshA`` не буде видно з SubViewport, "
"оскільки SubViewports захоплюють лише вузли, розташовані під ними в ієрархії."

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has "
"the :ref:`current <class_Camera3D_property_current>` property set, or make "
"it the current camera by calling:"
msgstr ""
"Може бути лише одна активна камера на :ref:`Viewport <class_Viewport>`, "
"тому, якщо їх більше однієї, переконайтеся, що для потрібної камери "
"встановлено властивість :ref:`current <class_Camera3D_property_current>`, "
"або зробіть її поточну камеру за телефоном:"

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's "
"<class_VisualInstance3D>` :ref:`layer "
"<class_VisualInstance3D_property_layers>` property to restrict which objects "
"are rendered."
msgstr ""
"За замовчуванням камери візуалізують усі об’єкти у своєму світі. У 3D камери "
"можуть використовувати свою властивість :ref:`cull_mask "
"<class_Camera3D_property_cull_mask>` у поєднанні з "
"властивістю :ref:`VisualInstance3D <class_VisualInstance3D>` :ref:`layer "
"<class_VisualInstance3D_property_layers>`, щоб обмежити, які об’єкти "
"відображаються."

msgid "Scale & stretching"
msgstr "Масштаб і розтяжка"

msgid ""
":ref:`SubViewports <class_SubViewport>` have "
"a :ref:`size<class_SubViewport_property_size>` property, which represents "
"the size of the SubViewport in pixels. For SubViewports which are children "
"of :ref:`SubViewportContainers <class_SubViewportContainer>`, these values "
"are overridden, but for all others, this sets their resolution."
msgstr ""
":ref:`SubViewports <class_SubViewport>` мають "
"властивість :ref:`size<class_SubViewport_property_size>`, яка представляє "
"розмір SubViewport у пікселях. Для SubViewports, які є "
"нащадками :ref:`SubViewportContainers <class_SubViewportContainer>`, ці "
"значення замінюються, але для всіх інших це встановлює їх роздільну "
"здатність."

msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"Також можна масштабувати 2D-вміст і зробити роздільну "
"здатність :ref:`SubViewport <class_SubViewport>` відмінною від зазначеної у "
"розмірі, викликавши:"

msgid ""
"For information on scaling and stretching with the Root Viewport visit "
"the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"Щоб отримати інформацію про масштабування та розтягування за допомогою "
"кореневого вікна перегляду, відвідайте :ref:`Навчальний посібник із кількох "
"роздільних здатностей <doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "Світи"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World3D "
"<class_World3D>`. This is basically the universe that links physics and "
"rendering together. Node3D-based nodes will register using the World3D of "
"the closest Viewport. By default, newly created Viewports do not contain a "
"World3D but use the same as their parent Viewport. The Root Viewport always "
"contains a World3D, which is the one objects are rendered to by default."
msgstr ""
"Для 3D :ref:`Viewport <class_Viewport>` міститиме :ref:`World3D "
"<class_World3D>`. По суті, це всесвіт, який поєднує фізику та рендеринг. "
"Вузли на основі Node3D реєструватимуться за допомогою World3D найближчого "
"вікна перегляду. За замовчуванням, щойно створені вікна перегляду не містять "
"World3D, але використовують те саме, що й їхнє батьківське вікно перегляду. "
"Кореневе вікно перегляду завжди містить World3D, який об’єкти відображаються "
"за замовчуванням."

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""
":ref:`World3D <class_World3D>` можна встановити у :ref:`Viewport "
"<class_Viewport>` за допомогою властивості :ref:`World "
"3D<class_Viewport_property_world_3d>`, яка відокремить усі дочірні вузли "
"цього :ref:`Viewport <class_Viewport>` і не дозволить їм взаємодіяти з "
"батьківським Viewport World3D. Це особливо корисно в ситуаціях, коли, "
"наприклад, ви можете показати окремого персонажа в 3D, накладеного на гру "
"(як у StarCraft)."

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create "
"a :ref:`World3D <class_World3D>`, Viewport has the option to use "
"its :ref:`Own World3D <class_Viewport_property_own_world_3d>`. This is "
"useful when you want to instance 3D characters or objects in :ref:`World2D "
"<class_World2D>`."
msgstr ""
"Як помічник у ситуаціях, коли ви хочете створити :ref:`Viewports "
"<class_Viewport>`, які відображають окремі об’єкти і не хочуть "
"створювати :ref:`World3D <class_World3D>`, Viewport має можливість "
"використовувати його :ref:`Own World3D "
"<class_Viewport_property_own_world_3d>`. Це корисно, коли ви хочете створити "
"3D-символи чи об’єкти :ref:`World2D <class_World2D>`."

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its "
"own :ref:`World2D <class_World2D>`. This suffices in most cases, but in case "
"sharing them may be desired, it is possible to do so by "
"setting :ref:`world_2d<class_Viewport_property_world_2d>` on the Viewport "
"through code."
msgstr ""
"Для 2D кожен :ref:`Viewport <class_Viewport>` завжди містить "
"свій :ref:`World2D <class_World2D>`. У більшості випадків цього достатньо, "
"але якщо є бажання надати спільний доступ до них, це можна зробити, "
"встановивши :ref:`world_2d<class_Viewport_property_world_2d>` у вікні "
"перегляду через код."

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"Для прикладу того, як це працює, перегляньте демонстраційні проекти `«3D у "
"2D <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"3d_in_2d>`_ та `2D у 3D <https://github.com/godotengine/godot-demo-projects/"
"tree/master/viewport/2d_in_3d>`_ відповідно."

msgid "Capture"
msgstr "Захоплення"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"Можна запитати захоплення вмісту :ref:`Viewport <class_Viewport>`. Для "
"кореневого вікна перегляду це фактично знімок екрана. Це робиться за "
"допомогою такого коду:"

msgid ""
"But if you use this in ``_ready()`` or from the first frame of "
"the :ref:`Viewport's <class_Viewport>` initialization, you will get an empty "
"texture because there is nothing to get as texture. You can deal with it "
"using (for example):"
msgstr ""
"Але якщо ви використовуєте це в ``_ready()`` або з першого кадру "
"ініціалізації :ref:`Viewport <class_Viewport>`, ви отримаєте порожню "
"текстуру, оскільки нема чого отримати як текстуру. Ви можете впоратися з цим "
"за допомогою (наприклад):"

msgid "Viewport Container"
msgstr "Контейнер поля перегляду"

msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of "
"a :ref:`SubViewportContainer <class_SubViewportContainer>`, it will become "
"active and display anything it has inside. The layout looks like this:"
msgstr ""
"Якщо :ref:`SubViewport <class_SubViewport>` є дочірнім "
"елементом :ref:`SubViewportContainer <class_SubViewportContainer>`, він "
"стане активним і відображатиме все, що містить. Макет виглядає так:"

msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
":ref:`SubViewport <class_SubViewport>` повністю покриватиме область свого "
"батьківського :ref:`SubViewportContainer <class_SubViewportContainer>` "
"повністю, якщо "
"для :ref:`Stretch<class_SubViewportContainer_property_stretch>` встановлено "
"значення ``true`` у SubViewportContainer."

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
"Розмір :ref:`SubViewportContainer <class_SubViewportContainer>` не може бути "
"меншим за розмір :ref:`SubViewport <class_SubViewport>`."

msgid "Rendering"
msgstr "Рендеринг"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"Через те, що :ref:`Viewport <class_Viewport>` є входом до іншої поверхні "
"візуалізації, він відкриває кілька властивостей візуалізації, які можуть "
"відрізнятися від параметрів проекту. Ви можете використовувати інший "
"рівень :ref:`MSAA <class_Viewport_property_msaa_2d>` для кожного вікна "
"перегляду. Поведінка за замовчуванням – ``Вимкнено``."

msgid ""
"If you know that the :ref:`Viewport <class_Viewport>` is only going to be "
"used for 2D, you can :ref:`Disable 3D<class_Viewport_property_disable_3d>`. "
"Godot will then restrict how the Viewport is drawn. Disabling 3D is slightly "
"faster and uses less memory compared to enabled 3D. It's a good idea to "
"disable 3D if your viewport doesn't render anything in 3D."
msgstr ""
"Якщо ви знаєте, що :ref:`Viewport <class_Viewport>` буде використовуватися "
"лише для 2D, ви можете :ref:`Вимкнути "
"3D<class_Viewport_property_disable_3d>`. Тоді Godot обмежить спосіб "
"малювання вікна перегляду. Вимкнення 3D відбувається трохи швидше та "
"використовує менше пам’яті порівняно з увімкненим 3D. Варто вимкнути 3D, "
"якщо ваше вікно перегляду не відображає нічого у 3D."

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"Якщо вам потрібно відобразити тривимірні тіні у вікні перегляду, обов’язково "
"встановіть для "
"властивості :ref:`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"вікна перегляду значення вище за 0. Інакше тіні не відображатимуться. За "
"умовчанням еквівалентний параметр проекту встановлено на 4096 на настільних "
"платформах та 2048 на мобільних платформах."

msgid ""
"Godot also provides a way of customizing how everything is drawn "
"inside :ref:`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot також надає можливість настроїти те, як все малюється "
"всередині :ref:`Viewports <class_Viewport>` за допомогою :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw дозволяє вказати "
"режим, який визначає, як у вікні перегляду відображатимуться речі, "
"намальовані всередині нього. За умовчанням Debug Draw ``вимкнено``. Деякі "
"інші параметри: ``Unshaded``, ``Overdraw`` і ``Wireframe``. Щоб отримати "
"повний список, зверніться до :ref:`Viewport "
"Documentation<class_Viewport_property_debug_draw>`."

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr ""
"**Debug Draw = Disabled** (за замовчуванням): сцена малюється нормально."

msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"**Debug Draw = Unshaded**: Unshaded малює сцену без використання інформації "
"про освітлення, тому всі об’єкти виглядають однорідно забарвленими в колір "
"альбедо."

msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr ""
"**Debug Draw = Overdraw**: Overdraw малює сітки напівпрозорими за допомогою "
"додаткової суміші, щоб ви могли бачити, як сітки перекриваються."

msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr ""
"**Debug Draw = Wireframe**: Wireframe малює сцену, використовуючи лише краї "
"трикутників у сітках."

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""
"Режими налагодження малювання наразі **не** підтримуються під час "
"використання методу відтворення сумісності. Вони відображатимуться як "
"звичайні режими малювання."

msgid "Render target"
msgstr "Ціль візуалізації"

msgid ""
"When rendering to a :ref:`SubViewport <class_SubViewport>`, whatever is "
"inside will not be visible in the scene editor. To display the contents, you "
"have to draw the SubViewport's :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"Під час візуалізації у :ref:`SubViewport <class_SubViewport>` все, що "
"знаходиться всередині, не буде видно в редакторі сцени. Щоб відобразити "
"вміст, вам потрібно десь намалювати :ref:`ViewportTexture "
"<class_ViewportTexture>` SubViewport. Це можна запитати за допомогою коду, "
"використовуючи (наприклад):"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "Або його можна призначити в редакторі, вибравши «New ViewportTexture»"

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr ""
"а потім виберіть :ref:`Viewport <class_Viewport>`, який ви хочете "
"використовувати."

msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"У кожному кадрі текстура :ref:`Viewport <class_Viewport>` видаляється "
"стандартним прозорим кольором (або прозорим кольором, якщо "
"для :ref:`Transparent BG<class_Viewport_property_transparent_bg>` "
"встановлено значення ``true``). Це можна змінити, встановивши :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` на ``Never`` або "
"``Next Frame``. Як випливає з назви, Ніколи означає, що текстура ніколи не "
"буде очищена, тоді як наступний кадр очищає текстуру наступного кадру, а "
"потім встановлює значення Ніколи."

msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"За замовчуванням повторне відтворення :ref:`SubViewport <class_SubViewport>` "
"відбувається, коли його :ref:`ViewportTexture <class_ViewportTexture>` було "
"намальовано у кадрі. Якщо видимий, він буде відтворений, інакше – ні. Цю "
"поведінку можна змінити, встановивши для :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` значення "
"``Never``, ``Once``, ``Always`` або ``When Parent Visible``. Ніколи та "
"Завжди ніколи або завжди повторно відображатимуться відповідно. Один раз "
"повторно візуалізує наступний кадр, а потім зміниться на Ніколи. Це можна "
"використовувати для ручного оновлення вікна перегляду. Ця гнучкість дозволяє "
"користувачам відтворювати зображення один раз, а потім використовувати "
"текстуру без витрат на відтворення кожного кадру."

msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"Обов’язково перевірте демонстраційні ролики Viewport. Вони доступні в папці "
"вікна перегляду архіву демонстрацій або за адресою https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport."
