#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The Compositor"
msgstr "Композитор"

msgid ""
"The compositor is a new feature in Godot 4 that allows control over the "
"rendering pipeline when rendering the contents of a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"Композитор — це нова функція в Godot 4, яка дозволяє контролювати конвеєр "
"відтворення під час відтворення вмісту :ref:`Viewport <class_Viewport>`."

msgid ""
"It can be configured on a :ref:`WorldEnvironment <class_WorldEnvironment>` "
"node where it applies to all Viewports, or it can be configured on "
"a :ref:`Camera3D <class_Camera3D>` and apply only to the Viewport using that "
"camera."
msgstr ""
"Його можна налаштувати на вузлі :ref:`WorldEnvironment "
"<class_WorldEnvironment>`, де він застосовується до всіх вікон перегляду, "
"або його можна налаштувати на :ref:`Camera3D <class_Camera3D>` і "
"застосовувати лише до вікна перегляду, що використовує цю камеру."

msgid ""
"The :ref:`Compositor <class_Compositor>` resource is used to configure the "
"compositor. To get started, create a new compositor on the appropriate node:"
msgstr ""
"Ресурс :ref:`Compositor <class_Compositor>` використовується для "
"налаштування композитора. Щоб почати, створіть новий композитор на "
"відповідному вузлі:"

msgid ""
"The compositor is currently a feature that is only supported by the Mobile "
"and Forward+ renderers."
msgstr ""
"Композитор наразі є функцією, яка підтримується лише модулями Mobile та "
"Forward+."

msgid "Compositor effects"
msgstr "Ефекти композитора"

msgid ""
"Compositor effects allow you to insert additional logic into the rendering "
"pipeline at various stages. This is an advanced feature that requires a high "
"level of understanding of the rendering pipeline to use to its best "
"advantage."
msgstr ""
"Ефекти композитора дозволяють вставляти додаткову логіку в конвеєр "
"рендерингу на різних етапах. Це розширена функція, яка потребує високого "
"рівня розуміння конвеєра візуалізації, щоб використовувати її якнайкраще."

msgid ""
"As the core logic of the compositor effect is called from the rendering "
"pipeline it is important to note that this logic will thus run within the "
"thread on which rendering takes place. Care needs to be taken to ensure we "
"don't run into threading issues."
msgstr ""
"Оскільки основна логіка ефекту композитора викликається з конвеєра "
"візуалізації, важливо зазначити, що ця логіка, таким чином, працюватиме в "
"потоці, у якому відбувається рендеринг. Потрібно бути обережним, щоб ми не "
"зіткнулися з проблемами потоків."

msgid ""
"To illustrate how to use compositor effects we'll create a simple post "
"processing effect that allows you to write your own shader code and apply "
"this full screen through a compute shader. You can find the finished demo "
"project `here <https://github.com/godotengine/godot-demo-projects/tree/"
"master/compute/post_shader>`_."
msgstr ""
"Щоб проілюструвати, як використовувати ефекти композитора, ми створимо "
"простий ефект постобробки, який дозволить вам написати власний код шейдера "
"та застосувати його на весь екран через обчислювальний шейдер. Ви можете "
"знайти готовий демонстраційний проект `тут <https://github.com/godotengine/"
"godot-demo-projects/tree/master/compute/post_shader>`_."

msgid ""
"We start by creating a new script called ``post_process_shader.gd``. We'll "
"make this a tool script so we can see the compositor effect work in the "
"editor. We need to extend our node from :ref:`CompositorEffect "
"<class_CompositorEffect>`. We must also give our script a class name."
msgstr ""
"Ми починаємо зі створення нового сценарію під назвою "
"``post_process_shader.gd``. Ми зробимо це інструментальним сценарієм, щоб ми "
"могли бачити, як ефект композитора працює в редакторі. Нам потрібно "
"розширити наш вузол із :ref:`CompositorEffect <class_CompositorEffect>`. Ми "
"також повинні дати нашому сценарію назву класу."

msgid "post_process_shader.gd"
msgstr "post_process_shader.gd"

msgid ""
"Next we're going to define a constant for our shader template code. This is "
"the boilerplate code that makes our compute shader work."
msgstr ""
"Далі ми визначимо константу для нашого коду шаблону шейдера. Це шаблонний "
"код, завдяки якому працює наш обчислювальний шейдер."

msgid ""
"For more information on how compute shaders work, please check :ref:`Using "
"compute shaders <doc_compute_shaders>`."
msgstr ""
"Щоб дізнатися більше про те, як працюють обчислювальні шейдери, "
"перегляньте :ref:`Using compute shaders <doc_compute_shaders>`."

msgid ""
"The important bit here is that for every pixel on our screen, our ``main`` "
"function is executed and inside of this we load the current color value of "
"our pixel, execute our user code, and write our modified color back to our "
"color image."
msgstr ""
"Важливим тут є те, що для кожного пікселя на нашому екрані виконується наша "
"функція ``main``, і всередині неї ми завантажуємо поточне значення кольору "
"нашого пікселя, виконуємо наш код користувача та записуємо наш змінений "
"колір назад у наш колір зображення."

msgid "``#COMPUTE_CODE`` gets replaced by our user code."
msgstr "``#COMPUTE_CODE`` замінюється нашим кодом користувача."

msgid ""
"In order to set our user code, we need an export variable. We'll also define "
"a few script variables we'll be using:"
msgstr ""
"Щоб встановити наш код користувача, нам потрібна змінна експорту. Ми також "
"визначимо кілька змінних сценарію, які будемо використовувати:"

msgid ""
"Note the use of a :ref:`Mutex <class_Mutex>` in our code. Most of our "
"implementation gets called from the rendering engine and thus runs within "
"our rendering thread."
msgstr ""
"Зверніть увагу на використання :ref:`Mutex <class_Mutex>` у нашому коді. "
"Більшість наших реалізацій викликається механізмом візуалізації і, таким "
"чином, працює в нашому потоці візуалізації."

msgid ""
"We need to ensure that we set our new shader code, and mark our shader code "
"as dirty, without our render thread accessing this data at the same time."
msgstr ""
"Нам потрібно переконатися, що ми встановили наш новий шейдерний код і "
"позначили наш шейдерний код як брудний, без того, щоб наш потік візуалізації "
"одночасно отримував доступ до цих даних."

msgid "Next we initialize our effect."
msgstr "Далі ми ініціалізуємо наш ефект."

msgid ""
"The main thing here is setting our ``effect_callback_type`` which tells the "
"rendering engine at what stage of the render pipeline to call our code."
msgstr ""
"Головне тут — це встановити наш ``effect_callback_type``, який повідомляє "
"механізму візуалізації, на якому етапі конвеєра візуалізації викликати наш "
"код."

msgid ""
"Currently we only have access to the stages of the 3D rendering pipeline!"
msgstr "Наразі ми маємо доступ лише до етапів конвеєра 3D-візуалізації!"

msgid ""
"We also get a reference to our rendering device, which will come in very "
"handy."
msgstr ""
"Ми також отримуємо посилання на наш пристрій візуалізації, що стане в нагоді."

msgid ""
"We also need to clean up after ourselves, for this we react to the "
"``NOTIFICATION_PREDELETE`` notification:"
msgstr ""
"Нам також потрібно прибрати за собою, для цього ми реагуємо на сповіщення "
"``NOTIFICATION_PREDELETE``:"

msgid ""
"Note that we do not use our mutex here even though we create our shader "
"inside of our render thread. The methods on our rendering server are thread "
"safe and ``free_rid`` will be postponed cleaning up the shader until after "
"any frames currently being rendered are finished."
msgstr ""
"Зауважте, що ми не використовуємо наш м’ютекс тут, хоча ми створюємо наш "
"шейдер всередині нашого потоку візуалізації. Методи на нашому сервері "
"візуалізації є потокобезпечними, і ``free_rid`` буде відкладено очищення "
"шейдера до завершення будь-яких кадрів, які зараз візуалізуються."

msgid ""
"Also note that we are not freeing our pipeline. The rendering device does "
"dependency tracking and as the pipeline is dependent on the shader, it will "
"be automatically freed when the shader is destructed."
msgstr ""
"Також зауважте, що ми не звільняємо наш трубопровід. Пристрій візуалізації "
"виконує відстеження залежностей, і оскільки конвеєр залежить від шейдера, "
"він буде автоматично звільнено, коли шейдер буде знищено."

msgid "From this point onwards our code will run on the rendering thread."
msgstr "З цього моменту наш код буде працювати в потоці візуалізації."

msgid ""
"Our next step is a helper function that will recompile the shader if the "
"user code was changed."
msgstr ""
"Наш наступний крок — допоміжна функція, яка перекомпілює шейдер, якщо код "
"користувача було змінено."

msgid ""
"At the top of this method we again use our mutex to protect accessing our "
"user shader code and our is dirty flag. We make a local copy of the user "
"shader code if our user shader code is dirty."
msgstr ""
"У верхній частині цього методу ми знову використовуємо наш м’ютекс, щоб "
"захистити доступ до нашого коду шейдера користувача та прапор брудний. Ми "
"робимо локальну копію коду шейдера користувача, якщо наш код шейдера "
"користувача брудний."

msgid ""
"If we don't have a new code fragment, we return true if we already have a "
"valid pipeline."
msgstr ""
"Якщо у нас немає нового фрагмента коду, ми повертаємо true, якщо ми вже "
"маємо дійсний конвеєр."

msgid ""
"If we do have a new code fragment we embed it in our template code and then "
"compile it."
msgstr ""
"Якщо у нас є новий фрагмент коду, ми вставляємо його в код нашого шаблону, а "
"потім компілюємо."

msgid ""
"The code shown here compiles our new code in runtime. This is great for "
"prototyping as we can immediately see the effect of the changed shader."
msgstr ""
"Показаний тут код компілює наш новий код під час виконання. Це чудово "
"підходить для прототипування, оскільки ми можемо відразу побачити ефект "
"зміненого шейдера."

msgid ""
"This prevents precompiling and caching this shader which may be an issues on "
"some platforms such as consoles. Note that the demo project comes with an "
"alternative example where a ``glsl`` file contains the entire compute shader "
"and this is used. Godot is able to precompile and cache the shader with this "
"approach."
msgstr ""
"Це запобігає попередній компіляції та кешування цього шейдера, що може бути "
"проблемою на деяких платформах, таких як консолі. Зауважте, що "
"демонстраційний проект постачається з альтернативним прикладом, де файл "
"``glsl`` містить весь обчислювальний шейдер, і це використовується. За "
"допомогою цього підходу Godot може попередньо скомпілювати та кешувати "
"шейдер."

msgid ""
"Finally we need to implement our effect callback, the rendering engine will "
"call this at the right stage of rendering."
msgstr ""
"Нарешті, нам потрібно реалізувати наш зворотний виклик ефекту, механізм "
"візуалізації викличе це на потрібному етапі рендерингу."

msgid ""
"At the start of this method we check if we have a rendering device, if our "
"callback type is the correct one, and check if we have our shader."
msgstr ""
"На початку цього методу ми перевіряємо, чи є у нас пристрій візуалізації, чи "
"є наш тип зворотного виклику правильним, а також перевіряємо, чи є у нас "
"шейдер."

msgid ""
"The check for the effect type is only a safety mechanism. We've set this in "
"our ``_init`` function, however it is possible for the user to change this "
"in the UI."
msgstr ""
"Перевірка типу ефекту є лише механізмом безпеки. Ми встановили це у нашій "
"функції ``_init``, однак користувач може змінити це в інтерфейсі користувача."

msgid ""
"Our ``p_render_data`` parameter gives us access to an object that holds data "
"specific to the frame we're currently rendering. We're currently only "
"interested in our render scene buffers, which provide us access to all the "
"internal buffers used by the rendering engine. Note that we cast this "
"to :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>` to expose the "
"full API to this data."
msgstr ""
"Наш параметр ``p_render_data`` надає нам доступ до об’єкта, який містить "
"дані, специфічні для кадру, який ми зараз візуалізуємо. Наразі нас цікавлять "
"лише наші буфери сцени візуалізації, які надають нам доступ до всіх "
"внутрішніх буферів, що використовуються механізмом рендерингу. Зауважте, що "
"ми передаємо це в :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>`, "
"щоб відкрити повний API для цих даних."

msgid ""
"Next we obtain our ``internal size`` which is the resolution of our 3D "
"render buffers before they are upscaled (if applicable), upscaling happens "
"after our post processes have run."
msgstr ""
"Далі ми отримуємо наш ``внутрішній розмір``, який є роздільною здатністю "
"наших буферів 3D-рендерінгу перед їх збільшенням (якщо застосовно), "
"збільшення відбувається після виконання наших постпроцесів."

msgid ""
"From our internal size we calculate our group size, see our local size in "
"our template shader."
msgstr ""
"Виходячи з нашого внутрішнього розміру, ми обчислюємо розмір нашої групи, "
"дивіться наш локальний розмір у нашому шейдері шаблону."

msgid ""
"We also populate our push constant so our shader knows our size. Godot does "
"not support structs here **yet** so we use a ``PackedFloat32Array`` to store "
"this data into. Note that we have to pad this array with a 16 byte "
"alignment. In other words, the length of our array needs to be a multiple of "
"4."
msgstr ""
"Ми також заповнюємо константу push, щоб наш шейдер знав наш розмір. Godot "
"**поки що** не підтримує структури, тому ми використовуємо "
"``PackedFloat32Array`` для зберігання цих даних. Зверніть увагу, що ми "
"повинні доповнити цей масив 16-байтовим вирівнюванням. Іншими словами, "
"довжина нашого масиву має бути кратною 4."

msgid ""
"Now we loop through our views, this is in case we're using multiview "
"rendering which is applicable for stereo rendering (XR). In most cases we "
"will only have one view."
msgstr ""
"Тепер ми переглядаємо наші перегляди, це на випадок, якщо ми використовуємо "
"мультиракурсний рендеринг, який застосовний для стереорендерінгу (XR). У "
"більшості випадків ми матимемо лише один вид."

msgid ""
"There is no performance benefit to use multiview for post processing here, "
"handling the views separately like this will still enable the GPU to use "
"parallelism if beneficial."
msgstr ""
"Немає ніякої переваги в продуктивності від використання multiview для "
"постобробки тут, обробка переглядів окремо, як це, все одно дозволить GPU "
"використовувати паралелізм, якщо це вигідно."

msgid ""
"Next we obtain the color buffer for this view. This is the buffer into which "
"our 3D scene has been rendered."
msgstr ""
"Далі ми отримуємо кольоровий буфер для цього перегляду. Це буфер, у який "
"було відтворено нашу 3D-сцену."

msgid ""
"We then prepare a uniform set so we can communicate the color buffer to our "
"shader."
msgstr ""
"Потім ми готуємо однорідний набір, щоб ми могли передати колірний буфер "
"нашому шейдеру."

msgid ""
"Note the use of our :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` cache "
"which ensures we can check for our uniform set each frame. As our color "
"buffer can change from frame to frame and our uniform cache will "
"automatically clean up uniform sets when buffers are freed, this is the safe "
"way to ensure we do not leak memory or use an outdated set."
msgstr ""
"Зверніть увагу на використання нашого :ref:`UniformSetCacheRD "
"<class_UniformSetCacheRD>` кешу, який гарантує, що ми можемо перевіряти наш "
"уніфікований набір кожного кадру. Оскільки наш буфер кольорів може "
"змінюватися від кадру до кадру, а наш уніфікований кеш автоматично очищатиме "
"уніфіковані набори, коли буфери звільняються, це безпечний спосіб "
"гарантувати, що ми не втратимо пам’ять або не використаємо застарілий набір."

msgid ""
"Finally we build our compute list by binding our pipeline, binding our "
"uniform set, pushing our push constant data, and calling dispatch for our "
"groups."
msgstr ""
"Нарешті ми створюємо наш список обчислень, прив’язуючи наш конвеєр, "
"прив’язуючи наш уніфікований набір, надсилаючи наші дані push-константи та "
"викликаючи диспетчеризацію для наших груп."

msgid ""
"With our compositor effect completed, we now need to add it to our "
"compositor."
msgstr ""
"Коли наш композитор завершено, тепер нам потрібно додати його до нашого "
"композитора."

msgid ""
"On our compositor we expand the compositor effects property and press ``Add "
"Element``."
msgstr ""
"У нашому композиторі ми розгортаємо властивість ефектів композитора та "
"натискаємо ``Додати елемент``."

msgid "Now we can add our compositor effect:"
msgstr "Тепер ми можемо додати наш ефект композитора:"

msgid ""
"After selecting our ``PostProcessShader`` we need to set our user shader "
"code:"
msgstr ""
"Після вибору нашого ``Post Process Shader`` нам потрібно встановити код "
"користувача шейдера:"

msgid "With that all done, our output is in grayscale."
msgstr "Після того, як усе зроблено, наш результат буде у відтінках сірого."

msgid ""
"For a more advanced example of post effects, check out the `Radial blur "
"based sky rays <https://github.com/BastiaanOlij/RERadialSunRays>`_ example "
"project created by Bastiaan Olij."
msgstr ""
"Щоб отримати більш складний приклад постефектів, ознайомтеся з прикладом "
"проекту `Промені неба на основі радіального розмиття <https://github.com/"
"BastiaanOlij/RERadialSunRays>`_, створеного Бастіаном Олієм."
