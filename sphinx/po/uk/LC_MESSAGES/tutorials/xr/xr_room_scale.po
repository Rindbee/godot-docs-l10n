#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Room scale in XR"
msgstr "Кімнатні ваги в XR"

msgid ""
"One of the staples of XR projects is the ability to walk around freely in a "
"large space. This space is often constrained by the room the player is "
"physically in with tracking sensors placed within this space. With the "
"advent of inside out tracking however ever larger play spaces are possible."
msgstr ""
"Одна з головних переваг XR-проектів — можливість вільно пересуватися у "
"великому просторі. Цей простір часто обмежений кімнатою, у якій фізично "
"перебуває гравець, із датчиками відстеження, розміщеними в цьому просторі. З "
"появою відстеження навиворіт, однак ігровий простір стає більшим."

msgid ""
"As a developer this introduces a number of interesting challenges. In this "
"document we will look at a number of the challenges you may face and outline "
"some solutions. We'll discuss the issues and challenges for seated XR games "
"in another document."
msgstr ""
"Для розробника це створює ряд цікавих завдань. У цьому документі ми "
"розглянемо ряд проблем, з якими ви можете зіткнутися, і окреслимо деякі "
"рішення. Ми обговоримо проблеми та виклики сидячих ігор XR в іншому "
"документі."

msgid ""
"Often developers sit behind their desk while building the foundation to "
"their game. In this mode the issues with developing for room scale don't "
"show themselves until it is too late. The advice here is to start testing "
"while standing up and walking around as early as possible. Once you are "
"happy your foundation is solid, you can develop in comfort while remaining "
"seated."
msgstr ""
"Часто розробники сидять за робочим столом, будуючи основу своєї гри. У цьому "
"режимі проблеми з розробкою для масштабу кімнати не виявляються, доки не "
"стане надто пізно. Порада полягає в тому, щоб якомога раніше починати "
"тестування, стоячи та ходячи. Коли ви задоволені, що ваша основа міцна, ви "
"можете комфортно розвиватися, сидячи."

msgid ""
"In traditional first person games a player is represented by "
"a :ref:`CharacterBody3D <class_characterbody3d>` node. This node is moved by "
"processing traditional controller, mouse or keyboard input. A camera is "
"attached to this node at a location roughly where the player's head will be."
msgstr ""
"У традиційних іграх від першої особи гравець представлений "
"вузлом :ref:`CharacterBody3D <class_characterbody3d>`. Цей вузол "
"переміщується шляхом обробки традиційного введення з контролера, миші або "
"клавіатури. Камера прикріплена до цього вузла приблизно в тому місці, де "
"буде голова гравця."

msgid ""
"Applying this model to the XR setup, we add an :ref:`XROrigin3D "
"<class_xrorigin3d>` node as a child of the character body, and add "
"an :ref:`XRCamera3D <class_xrcamera3d>` as a child of the origin node. At "
"face value this seems to work. However, upon closer examination this model "
"does not take into account that there are two forms of movement in XR. The "
"movement through controller input, and the physical movement of the player "
"in the real world."
msgstr ""
"Застосовуючи цю модель до налаштувань XR, ми додаємо вузол :ref:`XROrigin3D "
"<class_xrorigin3d>` як дочірній вузол до тіла персонажа та "
"додаємо :ref:`XRCamera3D <class_xrcamera3d>` як дочірній вузол для "
"початкового вузла. За номіналом це, здається, працює. Однак при більш "
"детальному розгляді ця модель не враховує, що в XR існують дві форми руху. "
"Рух через введення контролера та фізичний рух гравця в реальному світі."

msgid ""
"The first problem this causes is fairly obvious. When the player moves with "
"controller input, we can use the same approach in normal games and move the "
"player in a forward direction. However the player isn't where we think they "
"are and as we move forward we're checking collisions in the wrong location."
msgstr ""
"Перша проблема, яку це викликає, досить очевидна. Коли гравець рухається за "
"допомогою контролера, ми можемо використовувати той самий підхід у звичайних "
"іграх і рухати гравця вперед. Однак гравець знаходиться не там, де ми "
"думаємо, і, рухаючись вперед, ми перевіряємо зіткнення в неправильному місці."

msgid ""
"The second problem really shows itself when the player walks further away "
"from the center of the tracking space and uses controller input to turn. If "
"we rotate our character body, the player will be moved around the room in a "
"circular fashion."
msgstr ""
"Друга проблема справді проявляється, коли гравець відходить далі від центру "
"трекінгового простору та використовує вхідні дані контролера для повороту. "
"Якщо ми обертаємо тіло нашого персонажа, гравець рухатиметься кімнатою по "
"колу."

msgid ""
"If we fix the above issues, we will find a third issue. When the path for "
"the player is blocked in the virtual world, the player can still physically "
"move forward."
msgstr ""
"Якщо ми вирішимо вищезгадані проблеми, ми знайдемо третю проблему. Коли шлях "
"для гравця заблоковано у віртуальному світі, гравець може фізично рухатися "
"вперед."

msgid ""
"We will look at solving the first two problem with two separate solutions, "
"and then discuss dealing with the third."
msgstr ""
"Ми розглянемо вирішення перших двох проблем за допомогою двох окремих "
"рішень, а потім обговоримо вирішення третьої."

msgid "Origin centric solution"
msgstr "Оригінально-центричне рішення"

msgid ""
"Looking at the first approach for solving this we are going to change our "
"structure. This is the approach currently implemented in XR Tools."
msgstr ""
"Дивлячись на перший підхід до вирішення цього питання, ми збираємося змінити "
"нашу структуру. Це підхід, який зараз реалізовано в XR Tools."

msgid ""
"In this setup we mark the character body as top level so it does not move "
"with the origin."
msgstr ""
"У цьому налаштуванні ми позначаємо тіло персонажа як верхній рівень, щоб "
"воно не рухалося разом з початком координат."

msgid ""
"We also have a helper node that tells us where our neck joint is in relation "
"to our camera. We use this to determine where our body center is."
msgstr ""
"У нас також є допоміжний вузол, який повідомляє нам, де знаходиться наш "
"шийний суглоб по відношенню до нашої камери. Ми використовуємо це, щоб "
"визначити, де знаходиться центр нашого тіла."

msgid "Processing our character movement is now done in three steps."
msgstr "Обробка руху нашого персонажа тепер виконується в три етапи."

msgid ""
"The `Origin centric movement demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/xr/openxr_origin_centric_movement>`__ contains a more "
"elaborate example of the technique described below."
msgstr ""
"`Демонстрація орієнтованого руху Origin <https://github.com/godotengine/"
"godot-demo-projects/tree/master/xr/openxr_origin_centric_movement>`__ "
"містить детальніший приклад техніки, описаної нижче."

msgid "Step 1"
msgstr "Крок 1"

msgid ""
"In the first step we're going to process the physical movement of the "
"player. We determine where the player is right now, and attempt to move our "
"character body there."
msgstr ""
"На першому кроці ми обробимо фізичний рух гравця. Ми визначаємо, де зараз "
"знаходиться гравець, і намагаємося перемістити туди своє тіло персонажа."

msgid ""
"Note that we're returning ``true`` from our "
"``_process_on_physical_movement`` function when we couldn't move our player "
"all the way."
msgstr ""
"Зверніть увагу, що ми повертаємо ``true`` з нашої функції "
"``_process_on_physical_movement``, коли ми не можемо перемістити нашого "
"гравця до кінця."

msgid "Step 2"
msgstr "Крок 2"

msgid ""
"The second step is to handle rotation of the player as a result of user "
"input."
msgstr ""
"Другим кроком є обробка обертання гравця в результаті введення користувача."

msgid ""
"As the input used can differ based on your needs we are simply calling the "
"function ``_get_rotational_input``. This function should obtain the "
"necessary input and return the rotational speed in radians per second."
msgstr ""
"Оскільки використовувані вхідні дані можуть відрізнятися залежно від ваших "
"потреб, ми просто викликаємо функцію ``_get_rotational_input``. Ця функція "
"повинна отримати необхідні вхідні дані та повернути швидкість обертання в "
"радіанах на секунду."

msgid ""
"For our example we are going to keep this simple and straight forward. We "
"are not going to worry about comfort features such as snap turning and "
"applying a vignette. We highly recommend implementing such comfort features."
msgstr ""
"Для нашого прикладу ми збираємося зберегти це просто і прямо вперед. Ми не "
"збираємося турбуватися про комфортні функції, такі як поворот і накладення "
"віньєтки. Ми настійно рекомендуємо реалізувати такі функції комфорту."

msgid ""
"We've added the call for processing our rotation to our physics process but "
"we are only executing this if we were able to move our player fully. This "
"means that if the player moves somewhere they shouldn't, we don't process "
"further movement."
msgstr ""
"Ми додали виклик для обробки нашого обертання до нашого фізичного процесу, "
"але ми виконуємо це, лише якщо ми змогли повністю перемістити нашого гравця. "
"Це означає, що якщо гравець рухається кудись, де він не повинен, ми не "
"обробляємо подальший рух."

msgid "Step 3"
msgstr "Крок 3"

msgid ""
"The third and final step is moving the player forwards, backwards or "
"sideways as a result of user input."
msgstr ""
"Третій і останній крок - це переміщення гравця вперед, назад або вбік у "
"результаті введення користувача."

msgid ""
"Just like with the rotation the inputs differ from project to project so we "
"are simply calling the function ``_get_movement_input``. This function "
"should obtain the necessary input and return a directional vector scaled to "
"the required velocity."
msgstr ""
"Як і у випадку з обертанням, вхідні дані відрізняються від проекту до "
"проекту, тому ми просто викликаємо функцію ``_get_movement_input``. Ця "
"функція повинна отримати необхідні вхідні дані та повернути направлений "
"вектор, масштабований до необхідної швидкості."

msgid ""
"Just like with rotation we're keeping it simple. Here too it is advisable to "
"look at adding comfort settings."
msgstr ""
"Так само, як і з ротацією, ми робимо це просто. Тут також бажано звернути "
"увагу на додавання налаштувань комфорту."

msgid "Character body centric solution"
msgstr "Рішення, орієнтоване на тіло персонажа"

msgid ""
"In this setup we are going to keep our character body as our root node and "
"as such is easier to combine with traditional game mechanics."
msgstr ""
"У цьому налаштуванні ми збережемо тіло нашого персонажа як наш кореневий "
"вузол, і тому його легше поєднувати з традиційною ігровою механікою."

msgid ""
"Here we have a standard character body with collision shape, and our XR "
"origin node and camera as normal children. We also have our neck helper node."
msgstr ""
"Тут ми маємо стандартне тіло персонажа з формою зіткнення, а також наш "
"вихідний вузол XR і камеру як звичайні діти. У нас також є допоміжний вузол "
"шиї."

msgid ""
"Processing our character movement is done in the same three steps but "
"implemented slightly differently."
msgstr ""
"Обробка руху нашого персонажа виконується в ті самі три кроки, але "
"реалізується дещо по-іншому."

msgid ""
"The `Character centric movement demo <https://github.com/godotengine/godot-"
"demo-projects/tree/master/xr/openxr_character_centric_movement>`__ contains "
"a more elaborate example of the technique described below."
msgstr ""
"`Демонстрація руху персонажів <https://github.com/godotengine/godot-demo-"
"projects/tree/master/xr/openxr_character_centric_movement>`__ містить "
"детальніший приклад техніки, описаної нижче."

msgid ""
"In this approach step 1 is where all the magic happens. Just like with our "
"previous approach we will be applying our physical movement to the character "
"body, but we will counter that movement on the origin node."
msgstr ""
"У цьому підході на кроці 1 відбувається вся магія. Так само, як і в нашому "
"попередньому підході, ми будемо застосовувати наш фізичний рух до тіла "
"персонажа, але ми будемо протидіяти цьому руху на початковому вузлі."

msgid ""
"In essence the code above will move the character body to where the player "
"is, and then move the origin node back in equal amounts. The result is that "
"the player stays centered above the character body."
msgstr ""
"По суті, наведений вище код перемістить тіло персонажа туди, де знаходиться "
"гравець, а потім перемістить вихідний вузол рівними кількостями. Результатом "
"є те, що гравець залишається в центрі над тілом персонажа."

msgid ""
"We start with applying the rotation. The character body should be facing "
"where the player was looking the previous frame. We calculate our camera "
"orientation in the space of the character body. We can now calculate the "
"angle by which the player has rotated their head. We rotate our character "
"body by the same amount so our character body faces the same direction as "
"the player. And then we reverse the rotation on the origin node so the "
"camera ends up aligned with the player again."
msgstr ""
"Починаємо із застосування обертання. Тіло персонажа має бути повернуто туди, "
"куди гравець дивився в попередньому кадрі. Розраховуємо орієнтацію нашої "
"камери в просторі тіла персонажа. Тепер ми можемо обчислити кут, на який "
"гравець повернув голову. Ми обертаємо тіло нашого персонажа на таку саму "
"величину, щоб тіло нашого персонажа дивилося в тому ж напрямку, що й "
"гравець. Потім ми змінюємо обертання початкового вузла, щоб камера знову "
"вирівнялася з гравцем."

msgid ""
"For the movement we do much the same. The character body should be where the "
"player was standing the previous frame. We calculate by how much the player "
"has moved from this location. Then we attempt to move the character body to "
"this location."
msgstr ""
"Для руху ми робимо приблизно те саме. Тіло персонажа має бути там, де "
"гравець стояв у попередньому кадрі. Розраховуємо, на скільки гравець "
"перемістився з цієї локації. Потім ми намагаємося перемістити тіло персонажа "
"в це місце."

msgid ""
"As the player may hit a collision body and be stopped, we only move the "
"origin point back by the amount we actually moved the character body. The "
"player may thus move away from this location but that will be reflected in "
"the positioning of the player."
msgstr ""
"Оскільки гравець може натрапити на тіло зіткнення й бути зупиненим, ми "
"переміщуємо вихідну точку назад лише на ту величину, на яку фактично "
"перемістили тіло персонажа. Таким чином, гравець може відійти від цього "
"місця, але це відобразиться на позиціонуванні гравця."

msgid "As with our previous solution we return true if this is the case."
msgstr "Як і в нашому попередньому рішенні, ми повертаємо true, якщо це так."

msgid ""
"In this step we again apply the rotation based on controller input. However "
"in this case the code is nearly identical to how one would implement this in "
"a normal first person game."
msgstr ""
"На цьому кроці ми знову застосовуємо обертання на основі вхідних даних "
"контролера. Однак у цьому випадку код майже ідентичний тому, як це можна "
"реалізувати у звичайній грі від першої особи."

msgid ""
"For step three we again apply the movement based on controller input. "
"However just like at step 2, we can now implement this as we would in a "
"normal first person game."
msgstr ""
"Для третього кроку ми знову застосовуємо рух на основі введення контролера. "
"Однак, як і на кроці 2, тепер ми можемо реалізувати це, як у звичайній грі "
"від першої особи."

msgid "When the player walks to somewhere they shouldn't"
msgstr "Коли гравець йде туди, куди не повинен"

msgid ""
"Think of a situation where the player is outside a locked room. You don't "
"want the player to go into that room until the door is unlocked. You also "
"don't want the player to see what is in this room."
msgstr ""
"Подумайте про ситуацію, коли гравець знаходиться за межами зачиненої "
"кімнати. Ви не хочете, щоб гравець заходив у цю кімнату, доки двері не "
"відчинено. Ви також не хочете, щоб гравець бачив, що знаходиться в цій "
"кімнаті."

msgid ""
"The logic for moving the player through controller input nicely prevents "
"this. The player encounters a static body, and the code prevents the player "
"from moving into the room."
msgstr ""
"Логіка переміщення програвача через вхід контролера чудово запобігає цьому. "
"Гравець стикається зі статичним тілом, і код не дозволяє гравцеві перейти до "
"кімнати."

msgid ""
"However with XR, nothing is preventing the player from taking a real step "
"forward."
msgstr "Проте з XR ніщо не заважає гравцеві зробити справжній крок вперед."

msgid ""
"With both the approaches worked out up above we will prevent the character "
"body from moving where the player can't go. As the player has physically "
"moved to this location, the camera will now have moved into the room."
msgstr ""
"За допомогою обох підходів, розроблених вище, ми не дамо тілу персонажа "
"рухатися туди, де гравець не може потрапити. Оскільки гравець фізично "
"перемістився в це місце, камера тепер переміститься в кімнату."

msgid ""
"The logical solution would be to prevent the movement altogether and adjust "
"the placement of the XR origin point so the player stays outside of the room."
msgstr ""
"Логічним рішенням було б повністю запобігти переміщенню та налаштувати "
"розташування початкової точки XR, щоб гравець залишався поза кімнатою."

msgid ""
"The problem with this approach is that physical movement is now not "
"replicated in the virtual space. This will cause nausea for the player."
msgstr ""
"Проблема цього підходу полягає в тому, що фізичний рух тепер не "
"відтворюється у віртуальному просторі. Це спричинить нудоту у гравця."

msgid ""
"Our solutions up above would allow us to add this logic into the code at the "
"end of step 1."
msgstr ""
"Наші рішення, наведені вище, дозволять нам додати цю логіку в код наприкінці "
"кроку 1."

msgid "Further improvements to the code presented could be:"
msgstr "Подальші вдосконалення представленого коду можуть бути:"

msgid "allowing controller input as long as this distance is still small,"
msgstr "дозволяючи ввод контролера, поки ця відстань все ще мала,"

msgid ""
"still applying gravity to the player even when controller input is disabled."
msgstr ""
"все ще застосовуючи силу тяжіння до гравця, навіть якщо вхід контролера "
"вимкнено."

msgid ""
"The movement demos in our demo repository contain an example of blacking out "
"the screen when a user walks into restricted areas."
msgstr ""
"Демонстрації руху в нашому демонстраційному репозиторії містять приклад "
"затемнення екрана, коли користувач заходить у зони обмеженого доступу."

msgid "Further suggestions for improvements"
msgstr "Подальші пропозиції щодо покращення"

msgid ""
"The above provides two good options as starting points for implementing room "
"scale XR games."
msgstr ""
"Вище наведено два хороші варіанти як відправні точки для реалізації ігор XR "
"масштабу кімнати."

msgid ""
"A few more things that are worth pointing out that you will likely want to "
"implement:"
msgstr ""
"Ще кілька речей, на які варто звернути увагу, які ви, ймовірно, захочете "
"реалізувати:"

msgid ""
"The height of the camera can be used to detect whether the player is "
"standing up, crouching, jumping or lying down. You can adjust the size and "
"orientation of the collision shape accordingly. Extra bonus points for "
"adding multiple collision shapes so the head and body have their own, more "
"accurately sized, shapes."
msgstr ""
"За висотою камери можна визначити, чи гравець стоїть, присідає, стрибає чи "
"лежить. Ви можете відповідно налаштувати розмір і орієнтацію форми "
"зіткнення. Додаткові бонусні бали за додавання кількох форм зіткнень, щоб "
"голова та тіло мали власні форми точнішого розміру."

msgid ""
"When a scene first loads, the player may be far away from the center of the "
"tracking space. This could result in the player spawning into a different "
"room than our origin point. The game will now attempt, and fail, to move the "
"player body from the starting point to where the player is standing. You "
"should implement a reset function that moves the origin point so the player "
"is in the correct starting position."
msgstr ""
"Коли сцена завантажується вперше, гравець може бути далеко від центру "
"простору відстеження. Це може призвести до появи гравця в кімнаті, відмінній "
"від нашої вихідної точки. Тепер гра намагатиметься, але не вдасться, "
"перемістити тіло гравця з початкової точки до місця, де гравець стоїть. Ви "
"повинні застосувати функцію скидання, яка переміщує початкову точку, щоб "
"гравець перебував у правильному початковому положенні."

msgid ""
"Both of the above improvements require the player to be ready and standing "
"up straight. There is no guarantee as the player may still be putting their "
"headset on."
msgstr ""
"Обидва вищезазначені вдосконалення вимагають, щоб гравець був готовий і "
"стояв прямо. Гарантії немає, оскільки гравець може все ще одягати гарнітуру."

msgid ""
"Many games, including XR Tools, solve this by introducing an intro screen or "
"loading screen where the player must press a button when they are ready. "
"This starting environment is often a large location where the positioning of "
"the player has little impact on what the player sees. When the player is "
"ready, and presses the button, this is the moment you record the position "
"and height of the camera."
msgstr ""
"Багато ігор, у тому числі XR Tools, вирішують це, вводячи вступний екран або "
"екран завантаження, де гравець повинен натиснути кнопку, коли він буде "
"готовий. Це початкове середовище часто є великою локацією, де позиціонування "
"гравця мало впливає на те, що гравець бачить. Коли гравець готовий і "
"натискає кнопку, це момент, коли ви записуєте положення та висоту камери."
