#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The XR action map"
msgstr "Карта дій XR"

msgid ""
"Godot has an action map feature as part of the XR system. At this point in "
"time this system is part of the OpenXR module. There are plans to encompass "
"WebXR into this in the near future hence we call it the XR action map system "
"in this document. It implements the built-in action map system of OpenXR "
"mostly exactly as it is offered."
msgstr ""
"Godot має функцію карти дій як частину системи XR. На даний момент ця "
"система є частиною модуля OpenXR. У найближчому майбутньому планується "
"включити WebXR до цього, тому в цьому документі ми називаємо це системою "
"карти дій XR. Він реалізує вбудовану систему карт дій OpenXR переважно точно "
"так, як вона пропонується."

msgid ""
"The XR action map system exposes input, positional data and output for XR "
"controllers to your game/application. It does this by exposing named actions "
"that can be tailored to your game/application and binding these to the "
"actual inputs and outputs on your XR devices."
msgstr ""
"Система карти дій XR надає вхідні, позиційні дані та вихід для контролерів "
"XR вашій грі/додатку. Це робиться шляхом надання іменованих дій, які можна "
"адаптувати до вашої гри/програми, і прив’язування їх до фактичних входів і "
"виходів на ваших пристроях XR."

msgid ""
"As the XR action map is currently part of the OpenXR module, OpenXR needs to "
"be enabled in your project settings to expose it:"
msgstr ""
"Оскільки карта дій XR наразі є частиною модуля OpenXR, OpenXR потрібно "
"ввімкнути в налаштуваннях вашого проекту, щоб відкрити її:"

msgid ""
"You will then find the XR Action Map interface in the bottom of the screen:"
msgstr "Потім ви знайдете інтерфейс карти дій XR у нижній частині екрана:"

msgid ""
"Godot's built-in input system has many things in common with the XR action "
"map system. In fact our original idea was to add functionality to the "
"existing input system and expose the data to the OpenXR action map system. "
"We may revisit that idea at some point but as it turns out there were just "
"too many problems to overcome. To name a few:"
msgstr ""
"Вбудована система введення Godot має багато спільного з системою карт дій "
"XR. Фактично, наша початкова ідея полягала в тому, щоб додати "
"функціональність до існуючої системи введення та надати дані системі карти "
"дій OpenXR. Ми можемо повернутися до цієї ідеї в якийсь момент, але, як "
"виявилося, було занадто багато проблем, які потрібно було подолати. Щоб "
"назвати декілька:"

msgid ""
"Godot's input system mainly centers around button inputs, XR adds triggers, "
"axis, poses and haptics (output) into the mix. This would greatly complicate "
"the input system with features that won't work for normal controllers or "
"contrast with the current approach. It was felt this would lead to confusion "
"for the majority of Godot users."
msgstr ""
"Система введення Godot здебільшого зосереджена навколо кнопкових вводів, XR "
"додає в мікс тригери, вісь, пози та тактильні ефекти (вихід). Це значно "
"ускладнить систему введення завдяки функціям, які не працюватимуть для "
"звичайних контролерів, або контрастуватиме з поточним підходом. Вважалося, "
"що це призведе до плутанини для більшості користувачів Godot."

msgid ""
"Godot's input system works with raw input data that is parsed and triggers "
"emitting actions. This input data is made available to the end user. OpenXR "
"completely hides raw data and does all the parsing for us, we only get "
"access to already parsed action data. This inconsistency is likely to lead "
"to bugs when an unsuspecting user tries to use an XR device as a normal "
"input device."
msgstr ""
"Система введення Godot працює з необробленими вхідними даними, які "
"аналізуються та запускають дії, що видають. Ці вхідні дані стають доступними "
"для кінцевого користувача. OpenXR повністю приховує необроблені дані та "
"виконує весь аналіз за нас, ми отримуємо доступ лише до вже проаналізованих "
"даних дій. Ця невідповідність може призвести до помилок, коли нічого не "
"підозрюючий користувач намагатиметься використовувати пристрій XR як "
"звичайний пристрій введення."

msgid ""
"Godot's input system allows changes to what inputs are bound to actions in "
"runtime, OpenXR does not."
msgstr ""
"Система введення Godot дозволяє змінювати те, які вхідні дані прив’язані до "
"дій під час виконання, а OpenXR — ні."

msgid ""
"Godot's input system is based on device ids which are meaningless in OpenXR."
msgstr ""
"Система введення Godot базується на ідентифікаторах пристроїв, які не мають "
"сенсу в OpenXR."

msgid ""
"This does mean that a game/application that mixes traditional inputs with XR "
"controllers will have a separation. For most applications either one or the "
"other is used and this is not seen as a problem. In the end, it's a "
"limitation of the system."
msgstr ""
"Це означає, що гра/програма, яка поєднує традиційні входи з контролерами XR, "
"матиме розділення. Для більшості програм використовується або один, або "
"інший, і це не розглядається як проблема. Зрештою, це обмеження системи."

msgid "The default action map"
msgstr "Стандартна карта дій"

msgid ""
"Godot will automatically create a default action map if no action map file "
"is found."
msgstr ""
"Godot автоматично створить карту дій за замовчуванням, якщо файл карти дій "
"не знайдено."

msgid ""
"This default map was designed to help developers port their XR games/"
"applications from Godot 3 to Godot 4. As a result this map essentially binds "
"all known inputs on all controllers supported by default, to actions one on "
"one. This is not a good example of setting up an action map. It does allow a "
"new developer to have a starting point when they want to become familiar "
"with Godot XR. It prevents having to design a proper action map for their "
"game/application first."
msgstr ""
"Цю мапу за замовчуванням було розроблено, щоб допомогти розробникам "
"перенести свої ігри/програми XR з Godot 3 на Godot 4. У результаті ця карта "
"по суті пов’язує всі відомі входи на всіх контролерах, які підтримуються за "
"замовчуванням, до дій один на один. Це невдалий приклад створення карти дій. "
"Це дійсно дозволяє новому розробнику мати відправну точку, коли він хоче "
"ознайомитися з Godot XR. Це запобігає необхідності спочатку розробити "
"відповідну карту дій для їхньої гри/програми."

msgid ""
"For this walkthrough we're going to start with a blank action map. You can "
"simply delete the \"Godot action set\" entry at the top by pressing the "
"trash can icon. This will clear out all actions. You might also want to "
"remove the controllers that you do not wish to setup, more on this later."
msgstr ""
"У цій інструкції ми почнемо з порожньої карти дій. Ви можете просто видалити "
"запис «Набір дій Годо» вгорі, натиснувши значок кошика. Це скасує всі дії. "
"Ви також можете видалити контролери, які не бажаєте налаштовувати, "
"докладніше про це пізніше."

msgid "Action sets"
msgstr "Набори дій"

msgid ""
"Before we dive in, you will see the term XR runtime used throughout this "
"document. With XR runtime we mean the software that is controlling and "
"interacting with the AR or VR headset. The XR runtime then exposes this to "
"us through an API such as OpenXR. So:"
msgstr ""
"Перш ніж ми зануримося, ви побачите термін XR runtime, який використовується "
"в цьому документі. Під середовищем виконання XR ми маємо на увазі програмне "
"забезпечення, яке контролює та взаємодіє з гарнітурою AR або VR. Потім "
"середовище виконання XR надає нам це через API, наприклад OpenXR. Отже:"

msgid "for Steam this is SteamVR,"
msgstr "для Steam це SteamVR,"

msgid ""
"for Meta on desktop this is the Oculus Client (including when using Quest "
"link),"
msgstr ""
"для Meta на настільному комп’ютері це клієнт Oculus (включно з використанням "
"посилання Quest),"

msgid "for Meta on Quest this is the Quest's native OpenXR client,"
msgstr "для Meta on Quest це рідний клієнт Quest OpenXR,"

msgid "on Linux this could be Monado, etc."
msgstr "у Linux це може бути Monado тощо."

msgid ""
"The action map allows us to organize our actions in sets. Each set can be "
"enabled or disabled on its own."
msgstr ""
"Карта дій дозволяє нам організувати наші дії за наборами. Кожен набір можна "
"ввімкнути або вимкнути самостійно."

msgid ""
"The concept here is that you could have different sets that provide bindings "
"in different scenarios. You could have:"
msgstr ""
"Ідея полягає в тому, що ви можете мати різні набори, які забезпечують "
"прив’язки в різних сценаріях. Ви можете мати:"

msgid "a ``Character control`` set for when you're walking around,"
msgstr "набір ``Character control``, коли ви ходите,"

msgid "a ``Vehicle control`` set for when you're operating a vehicle,"
msgstr ""
"набір ``Керування транспортним засобом``, коли ви керуєте транспортним "
"засобом,"

msgid "a ``Menu`` set for when a menu is open."
msgstr "набір ``Меню``, коли меню відкрито."

msgid ""
"Only the action set applicable to the current state of your game/application "
"can then be enabled."
msgstr ""
"Після цього можна ввімкнути лише набір дій, застосовний до поточного стану "
"вашої гри/програми."

msgid ""
"This is especially important if you wish to bind the same input on a "
"controller to a different action. For instance:"
msgstr ""
"Це особливо важливо, якщо ви бажаєте прив’язати той самий вхід на контролері "
"до іншої дії. наприклад:"

msgid "in your ``Character control`` set you may have an action ``Jump``,"
msgstr "у вашому наборі ``Character control`` ви можете мати дію ``Jump``,"

msgid "in your ``Vehicle control`` set you may have an action ``Accelerate``,"
msgstr ""
"у вашому наборі ``Керування транспортним засобом`` ви можете мати дію "
"``Прискорити``,"

msgid "in your ``Menu`` set you may have an action ``Select``."
msgstr "у вашому наборі ``Меню`` ви можете мати дію ``Вибрати``."

msgid "All are bound to the trigger on your controller."
msgstr "Усі вони прив’язані до тригера на контролері."

msgid ""
"OpenXR will only bind an input or output to a single action. If the same "
"input or output is bound to multiple actions the one in the active action "
"set with the highest priority will be the one updated/used. So in our above "
"example it will thus be important that only one action set is active."
msgstr ""
"OpenXR прив’язуватиме вхід або вихід лише до однієї дії. Якщо один і той "
"самий вхід або вихід пов’язано з декількома діями, оновленою/використаною "
"буде одна з активних дій із найвищим пріоритетом. Таким чином, у нашому "
"прикладі вище буде важливо, щоб лише один набір дій був активним."

msgid ""
"For your first XR game/application we highly recommend starting with just a "
"single action set and to not over-engineer things."
msgstr ""
"Для вашої першої гри/програми XR ми наполегливо рекомендуємо почати лише з "
"одного набору дій і не надто розробляти речі."

msgid ""
"For our walkthrough in this document we will thus create a single action set "
"called ``my_first_action_set``. We do this by pressing the ``Add action "
"set`` button:"
msgstr ""
"Таким чином, для нашого покрокового керівництва в цьому документі ми "
"створимо один набір дій під назвою ``my_first_action_set``. Ми робимо це, "
"натискаючи кнопку ``Додати набір дій``:"

msgid "The columns in our table are as follows:"
msgstr "Стовпці в нашій таблиці такі:"

msgid "Col"
msgstr "Кол"

msgid "Value"
msgstr "Значення"

msgid "Description"
msgstr "Опис"

msgid "1"
msgstr "1"

msgid "my_first_action_set"
msgstr "My_first_action_set"

msgid ""
"This is the internal name of the action set. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"Це внутрішня назва набору дій. OpenXR не визначає конкретних обмежень для "
"цього імені, окрім розміру, однак деякі середовища виконання XR не люблять "
"пробіли чи спеціальні символи."

msgid "2"
msgstr "2"

msgid "My first action set"
msgstr "Мій перший набір дій"

msgid ""
"This is a human-readable name for the action set. Some XR runtimes will "
"display this name to the end user, for example in configuration dialogs."
msgstr ""
"Це зрозуміла для людини назва набору дій. Деякі середовища виконання XR "
"відображатимуть це ім’я для кінцевого користувача, наприклад, у діалогових "
"вікнах налаштування."

msgid "3"
msgstr "3"

msgid "0"
msgstr "0"

msgid ""
"This is the priority of the action set. If multiple active action sets have "
"actions bound to the same controllers inputs or outputs, the action set with "
"the highest priority value will determine the action that is updated."
msgstr ""
"Це пріоритет набору дій. Якщо кілька активних наборів дій мають дії, "
"прив’язані до тих самих входів або виходів контролерів, набір дій із "
"значенням найвищого пріоритету визначить дію, яка оновлюється."

msgid "Actions"
msgstr "Дії"

msgid ""
"In the XR action map, actions are the entities that your game/application "
"will interact with. For instance, we can define an action ``Shoot`` and the "
"input bound to that action will trigger the ``button_pressed`` signal on the "
"relevant :ref:`XRController3D <class_xrcontroller3d>` node in your scene "
"with ``Shoot`` as the ``name`` parameter of the signal."
msgstr ""
"У карті дій XR дії — це сутності, з якими ваша гра/програма взаємодіятиме. "
"Наприклад, ми можемо визначити дію ``Shoot``, і введення, пов’язане з цією "
"дією, ініціюватиме сигнал ``button_pressed`` у відповідному вузлі :ref:"
"`XRController3D <class_xrcontroller3d>` у вашій сцені з ``Shoot` ` як "
"параметр ``name`` сигналу."

msgid ""
"You can also poll the current state of an action. :ref:`XRController3D "
"<class_xrcontroller3d>` for instance has an ``is_button_pressed`` method."
msgstr ""
"Ви також можете опитувати поточний стан дії. :ref:`XRController3D "
"<class_xrcontroller3d>`, наприклад, має метод ``is_button_pressed``."

msgid ""
"Actions can be used for both input and output and each action has a type "
"that defines its behavior."
msgstr ""
"Дії можна використовувати як для введення, так і для виведення, і кожна дія "
"має тип, який визначає її поведінку."

msgid "The ``Bool`` type is used for discrete input like buttons."
msgstr "Тип ``Bool`` використовується для дискретного введення, як кнопки."

msgid "The ``Float`` type is used for analogue input like triggers."
msgstr "Тип ``Float`` використовується для аналогового введення, як тригери."

msgid ""
"These two are special as they are the only ones that are interchangeable. "
"OpenXR will handle conversions between ``Bool`` and ``Float`` inputs and "
"actions. You can get the value of a ``Float`` type action by calling the "
"method ``get_float`` on your :ref:`XRController3D <class_xrcontroller3d>` "
"node. It emits the ``input_float_changed`` signal when changed."
msgstr ""
"Ці два є особливими, оскільки вони єдині взаємозамінні. OpenXR оброблятиме "
"перетворення між входами та діями ``Bool`` і ``Float``. Ви можете отримати "
"значення дії типу ``Float``, викликавши метод ``get_float`` на вашому вузлі :"
"ref:`XRController3D <class_xrcontroller3d>`. Під час зміни він видає сигнал "
"``input_float_changed``."

msgid ""
"Where analogue inputs are queried as buttons a threshold is applied. This "
"threshold is currently managed exclusively by the XR runtime. There are "
"plans to extend Godot to provide some level of control over these thresholds "
"in the future."
msgstr ""
"Якщо аналогові входи запитуються як кнопки, застосовується порогове "
"значення. Наразі цим порогом керує виключно середовище виконання XR. Є плани "
"розширити Годо, щоб забезпечити певний рівень контролю над цими порогами в "
"майбутньому."

msgid ""
"The ``Vector2`` type defines the input as an axis input. Touchpads, "
"thumbsticks and similar inputs are exposed as vectors. You can get the value "
"of a ``Vector2`` type action by calling the method ``get_vector2`` on your :"
"ref:`XRController3D <class_xrcontroller3d>` node. It emits the "
"``input_vector2_changed`` signal when changed."
msgstr ""
"Тип ``Vector2`` визначає введення як вхід осі. Сенсорні панелі, джойстики та "
"подібні елементи вводу представлені як вектори. Ви можете отримати значення "
"дії типу ``Vector2``, викликавши метод ``get_vector2`` на вашому вузлі :ref:"
"`XRController3D <class_xrcontroller3d>`. Під час зміни він видає сигнал "
"``input_vector2_changed``."

msgid ""
"The ``Pose`` type defines a spatially tracked input. Multiple \"pose\" "
"inputs are available in OpenXR: ``aim``, ``grip`` and ``palm``. Your :ref:"
"`XRController3D <class_xrcontroller3d>` node is automatically positioned "
"based on the pose action assigned to ``pose`` property of this node. More "
"about poses later."
msgstr ""
"Тип ``Pose`` визначає просторово відстежуваний вхід. У OpenXR доступні "
"кілька вводів «пози»: ``aim``, ``grip`` і ``palm``. Ваш вузол :ref:"
"`XRController3D <class_xrcontroller3d>` автоматично позиціонується на основі "
"дії пози, призначеної властивості ``pose`` цього вузла. Про пози пізніше."

msgid ""
"The OpenXR implementation in Godot also exposes a special pose called "
"``Skeleton``. This is part of the hand tracking implementation. This pose is "
"exposed through the ``skeleton`` action that is supported outside of the "
"action map system. It is thus always present if hand tracking is supported. "
"You don't need to bind actions to this pose to use it."
msgstr ""
"Реалізація OpenXR у Godot також відкриває спеціальну позу під назвою "
"``Skeleton``. Це частина реалізації відстеження руки. Ця поза відображається "
"через дію ``скелет``, яка підтримується за межами системи карти дій. Таким "
"чином, він завжди присутній, якщо підтримується відстеження руки. Вам не "
"потрібно прив’язувати дії до цієї пози, щоб використовувати її."

msgid ""
"Finally, the only output type is ``Haptic`` and it allows us to set the "
"intensity of haptic feedback, such as controller vibration. Controllers can "
"have multiple haptic outputs and support for haptic vests is coming to "
"OpenXR."
msgstr ""
"Нарешті, єдиним типом виведення є ``Haptic``, і він дозволяє нам встановити "
"інтенсивність тактильного зворотного зв’язку, наприклад вібрації контролера. "
"Контролери можуть мати кілька тактильних виходів, а підтримка тактильних "
"жилетів з’являється в OpenXR."

msgid ""
"So lets add an action for our aim pose, we do this by clicking on the ``+`` "
"button for our action set:"
msgstr ""
"Отже, давайте додамо дію для нашої прицільної пози, ми робимо це, натиснувши "
"кнопку ``+`` для нашого набору дій:"

msgid "aim_pose"
msgstr "Aim_pose"

msgid ""
"This is the internal name of the action. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"Це внутрішня назва дії. OpenXR не визначає конкретних обмежень для цього "
"імені, окрім розміру, однак деякі середовища виконання XR не люблять пробіли "
"чи спеціальні символи."

msgid "Aim pose"
msgstr "Прицільна поза"

msgid ""
"This is a human-readable name for the action. Some XR runtimes will display "
"this name to the end user, for example in configuration dialogs."
msgstr ""
"Це зрозуміла назва дії. Деякі середовища виконання XR відображатимуть це "
"ім’я для кінцевого користувача, наприклад, у діалогових вікнах налаштування."

msgid "Pose"
msgstr "Поза"

msgid "The type of this action."
msgstr "Тип цієї дії."

msgid ""
"OpenXR defines a number of bindable input poses that are commonly available "
"for controllers. There are no rules for which poses are supported for "
"different controllers. The poses OpenXR currently defines are:"
msgstr ""
"OpenXR визначає низку прив’язаних поз введення, які зазвичай доступні для "
"контролерів. Немає правил, які пози підтримуються для різних контролерів. "
"OpenXR наразі визначає такі пози:"

msgid ""
"The aim pose on most controllers is positioned slightly in front of the "
"controller and aims forward. This is a great pose to use for laser pointers "
"or to align the muzzle of a weapon with."
msgstr ""
"Поза прицілювання на більшості контролерів розташована трохи попереду "
"контролера та спрямована вперед. Це чудова поза для лазерних указок або для "
"вирівнювання дула зброї."

msgid ""
"The grip pose on most controllers is positioned where the grip button is "
"placed on the controller. The orientation of this pose differs between "
"controllers and can differ for the same controller on different XR runtimes."
msgstr ""
"Поза рукоятки на більшості контролерів розташована там, де розташована "
"кнопка ручки на контролері. Орієнтація цієї пози відрізняється між "
"контролерами та може відрізнятися для того самого контролера в різних "
"середовищах виконання XR."

msgid ""
"The palm pose on most controllers is positioned in the center of the palm of "
"the hand holding the controller. This is a new pose that is not available on "
"all XR runtimes."
msgstr ""
"Поза долоні на більшості контролерів розташована в центрі долоні, яка тримає "
"контролер. Це нова поза, яка доступна не в усіх середовищах виконання XR."

msgid ""
"If hand tracking is used, there are currently big differences in "
"implementations between the different XR runtimes. As a result the action "
"map is currently not suitable for hand tracking. Work is being done on this "
"so stay tuned."
msgstr ""
"Якщо використовується відстеження рук, наразі існують великі відмінності в "
"реалізації між різними середовищами виконання XR. У результаті карта дій "
"наразі не підходить для відстеження рук. Над цим ведеться робота, тому "
"слідкуйте за оновленнями."

msgid ""
"Let's complete our list of actions for a very simple shooting game/"
"application:"
msgstr ""
"Давайте завершимо наш список дій для дуже простої гри/програми-стрілялки:"

msgid "The actions we have added are:"
msgstr "Дії, які ми додали:"

msgid ""
"movement, which allows the user to move around outside of normal room scale "
"tracking."
msgstr ""
"рух, що дозволяє користувачеві пересуватися за межами звичайного відстеження "
"масштабу кімнати."

msgid "grab, which detects that the user wants to hold something."
msgstr "grab, який виявляє, що користувач хоче щось утримати."

msgid ""
"shoot, which detects that the user wants to fire the weapon they are holding."
msgstr ""
"стріляти, який визначає, що користувач хоче вистрілити зі зброї, яку він "
"тримає."

msgid "haptic, which allows us to output haptic feedback."
msgstr "тактильний, що дозволяє виводити тактильний зворотний зв’язок."

msgid ""
"Now note that we don't distinguish between the left and right hand. This is "
"something that is determined at the next stage. We've implemented the action "
"system in such a way that you can bind the same action to both hands. The "
"appropriate :ref:`XRController3D <class_xrcontroller3d>` node will emit the "
"signal."
msgstr ""
"Тепер зауважте, що ми не розрізняємо ліву та праву руку. Це те, що "
"визначається на наступному етапі. Ми реалізували систему дій таким чином, що "
"ви можете прив'язати ту саму дію до обох рук. Відповідний вузол :ref:"
"`XRController3D <class_xrcontroller3d>` видаватиме сигнал."

msgid ""
"For both grab and shoot we've used the ``Bool`` type. As mentioned before, "
"OpenXR does automatic conversions from an analogue controls however not all "
"XR Runtimes currently apply sensible thresholds."
msgstr ""
"І для захоплення, і для стрілянини ми використовували тип ``Bool``. Як "
"згадувалося раніше, OpenXR виконує автоматичні перетворення з аналогових "
"елементів керування, однак не всі XR Runtimes наразі застосовують розумні "
"порогові значення."

msgid ""
"We recommend as a workaround to use the ``Float`` type when interacting with "
"triggers and grip buttons and apply your own threshold."
msgstr ""
"Ми рекомендуємо як обхідний шлях використовувати тип ``Float`` під час "
"взаємодії з тригерами та кнопками ручки та застосувати власне порогове "
"значення."

msgid ""
"For buttons like A/B/X/Y and similar where there is no analogue option, the "
"``Bool`` type works fine."
msgstr ""
"Для таких кнопок, як A/B/X/Y і подібних, де немає аналогової опції, тип "
"``Bool`` працює добре."

msgid ""
"You can bind the same action to multiple inputs for the same controller on "
"the same profile. In this case the XR runtime will attempt to combine the "
"inputs."
msgstr ""
"Ви можете прив’язати ту саму дію до кількох входів для того самого "
"контролера в одному профілі. У цьому випадку середовище виконання XR спробує "
"об’єднати вхідні дані."

msgid ""
"For ``Bool`` inputs, this will perform an ``OR`` operation between the "
"buttons."
msgstr "Для входів ``Bool`` це виконає операцію ``OR`` між кнопками."

msgid ""
"For ``Float`` inputs, this will take the highest value of the bound inputs."
msgstr ""
"Для вхідних даних ``Float`` буде прийнято найвище значення з прив’язаних "
"вхідних даних."

msgid ""
"The behavior for ``Pose`` inputs is undefined, but the first bound input is "
"likely to be used."
msgstr ""
"Поведінка для входів ``Pose`` не визначена, але, ймовірно, буде використано "
"перший зв’язаний вхід."

msgid ""
"You shouldn't bind multiple actions of the same action set to the same "
"controller input. If you do this, or if actions are bound from multiple "
"action sets but they have overlapping priorities, the behavior is undefined. "
"The XR runtime may simply not accept your action map, or it may take this on "
"a first come first serve basis."
msgstr ""
"Ви не повинні прив’язувати кілька дій одного набору дій до одного входу "
"контролера. Якщо ви це зробите або якщо дії пов’язані з кількома наборами "
"дій, але вони мають збігаються пріоритети, поведінка буде невизначеною. "
"Середовище виконання XR може просто не прийняти вашу карту дій або прийняти "
"її за принципом «хто прийшов, перший обслужився»."

msgid ""
"We are still investigating the restrictions around binding multiple actions "
"to the same output as this scenario makes sense. The OpenXR specification "
"seems to not allow this."
msgstr ""
"Ми все ще вивчаємо обмеження щодо прив’язки кількох дій до одного "
"результату, оскільки цей сценарій має сенс. Здається, специфікація OpenXR не "
"дозволяє цього."

msgid "Now that we have our basic actions defined, it's time to hook them up."
msgstr "Тепер, коли ми визначили основні дії, настав час їх підключити."

msgid "Profiles"
msgstr "Профілі"

msgid ""
"In OpenXR controller bindings are captured in so-called \"Interaction "
"Profiles\". We've simply shortened it to \"Profiles\" because it takes up "
"less space."
msgstr ""
"У OpenXR прив’язки контролера фіксуються в так званих «Профілях взаємодії». "
"Ми просто скоротили його до «Профілів», оскільки він займає менше місця."

msgid ""
"This generic name is chosen because controllers don't cover the entire "
"system. Currently there are also profiles for trackers, remotes and tracked "
"pens. There are also provisions for devices such as treadmills, haptic vests "
"and such even though those are not part of the specification yet."
msgstr ""
"Цю загальну назву обрано тому, що контролери не охоплюють всю систему. На "
"даний момент також існують профілі для трекерів, пультів і гусеничних ручок. "
"Існують також положення щодо таких пристроїв, як бігові доріжки, тактильні "
"жилети тощо, хоча вони ще не є частиною специфікації."

msgid ""
"It is important to know that OpenXR has strict checking on supported "
"devices. The core specification identifies a number of controllers and "
"similar devices with their supported inputs and outputs. Every XR runtime "
"must accept these interaction profiles even if they aren't applicable."
msgstr ""
"Важливо знати, що OpenXR суворо перевіряє підтримувані пристрої. Основна "
"специфікація визначає низку контролерів і подібних пристроїв з їх "
"підтримуваними входами та виходами. Кожне середовище виконання XR має "
"приймати ці профілі взаємодії, навіть якщо вони не застосовуються."

msgid ""
"New devices are added through extensions and XR runtimes must specify which "
"ones they support. XR runtimes that do not support a device added through "
"extensions will not accept these profiles. XR runtimes that do not support "
"added input or output types will often crash if supplied."
msgstr ""
"Нові пристрої додаються через розширення, а середовища виконання XR повинні "
"вказувати, які з них вони підтримують. Середи виконання XR, які не "
"підтримують пристрій, доданий через розширення, не сприйматимуть ці профілі. "
"Середи виконання XR, які не підтримують додані типи вводу або виводу, часто "
"аварійно завершують роботу."

msgid ""
"As such Godot keeps meta data of all available devices, their inputs and "
"outputs and which extension adds support for them. You can create "
"interaction profiles for all devices you wish to support. Godot will filter "
"out those not supported by the XR runtime the user is using."
msgstr ""
"Таким чином, Godot зберігає метадані всіх доступних пристроїв, їхні входи та "
"виходи, а також те, яке розширення додає підтримку для них. Ви можете "
"створити профілі взаємодії для всіх пристроїв, які бажаєте підтримувати. "
"Godot відфільтровує ті, які не підтримуються середовищем виконання XR, яке "
"використовує користувач."

msgid ""
"This does mean that in order to support new devices, you might need to "
"update to a more recent version of Godot."
msgstr ""
"Це означає, що для підтримки нових пристроїв вам може знадобитися оновлення "
"до новішої версії Godot."

msgid ""
"It is however also important to note that the action map has been designed "
"with this in mind. When new devices enter the market, or when your users use "
"devices that you do not have access to, the action map system relies on the "
"XR runtime. It is the XR runtime's job to choose the best fitting "
"interaction profile that has been specified and adapt it for the controller "
"the user is using."
msgstr ""
"Однак також важливо зазначити, що карту дій було розроблено з урахуванням "
"цього. Коли нові пристрої з’являються на ринку або коли ваші користувачі "
"використовують пристрої, до яких у вас немає доступу, система карт дій "
"покладається на середовище виконання XR. Завдання середовища виконання XR — "
"вибрати найкращий профіль взаємодії, який було зазначено, і адаптувати його "
"для контролера, який використовує користувач."

msgid ""
"How the XR runtime does this is left to the implementation of the runtime "
"and there are thus vast differences between the runtimes. Some runtimes "
"might even permit users to edit the bindings themselves."
msgstr ""
"Те, як середовище виконання XR це робить, залежить від реалізації середовища "
"виконання, тому між середовищами виконання існують великі відмінності. Деякі "
"середовища виконання можуть навіть дозволяти користувачам самостійно "
"редагувати прив’язки."

msgid ""
"A common approach for a runtime is to look for a matching interaction "
"profile first. If this is not found it will check the most common profiles "
"such as that of the \"Touch controller\" and do a conversion. If all else "
"fails, it will check the generic :ref:`\"Simple controller\" "
"<doc_xr_action_map_simple>`."
msgstr ""
"Загальний підхід до середовища виконання полягає в тому, щоб спочатку знайти "
"відповідний профіль взаємодії. Якщо цього не знайдено, він перевірить "
"найпоширеніші профілі, такі як «Touch controller», і виконає перетворення. "
"Якщо нічого не допомагає, він перевірить загальний :ref:`\"Простий "
"контролер\" <doc_xr_action_map_simple>`."

msgid ""
"There is an important conclusion to be made here: When a controller is "
"found, and the action map is applied to it, the XR runtime is not limited to "
"the exact configurations you set up in Godot's action map editor. While the "
"runtime will generally choose a suitable mapping based on one of the "
"bindings you set up in the action map, it can deviate from it."
msgstr ""
"Тут слід зробити важливий висновок: коли контролер знайдено та до нього "
"застосовано карту дій, час виконання XR не обмежується точними "
"конфігураціями, які ви встановили в редакторі карти дій Godot. Хоча "
"середовище виконання зазвичай вибирає відповідне відображення на основі "
"одного з прив’язок, які ви встановили в карті дій, воно може відхилятися від "
"нього."

msgid ""
"For example, when the Touch controller profile is used any of the following "
"scenarios could be true:"
msgstr ""
"Наприклад, коли використовується профіль сенсорного контролера, може мати "
"місце будь-який із наведених нижче сценаріїв:"

msgid "we could be using a Quest 1 controller,"
msgstr "ми могли б використовувати контролер Quest 1,"

msgid "we could be using a Quest 2 controller,"
msgstr "ми могли б використовувати контролер Quest 2,"

msgid ""
"we could be using a Quest Pro controller but no Quest Pro profile was given "
"or the XR runtime being used does not support the Quest Pro controller,"
msgstr ""
"ми могли використовувати контролер Quest Pro, але не було надано профілю "
"Quest Pro або використовуване середовище виконання XR не підтримує контролер "
"Quest Pro,"

msgid ""
"it could be a completely different controller for which no profile was given "
"but the XR runtime is using the touch bindings as a base."
msgstr ""
"це може бути зовсім інший контролер, для якого не було надано жодного "
"профілю, але середовище виконання XR використовує сенсорні прив’язки як "
"основу."

msgid ""
"Ergo, there currently is no way to know with certainty, which controller the "
"user is actually using."
msgstr ""
"Таким чином, зараз немає способу точно дізнатися, який контролер насправді "
"використовує користувач."

msgid ""
"Finally, and this trips up a lot of people, the bindings aren't set in "
"stone. It is fully allowed, and even expected, that an XR runtime allows a "
"user to customise the bindings."
msgstr ""
"Нарешті, і це спотикає багатьох людей, прив’язки не висічені в камені. "
"Цілком допустимо і навіть очікується, що середовище виконання XR дозволяє "
"користувачеві налаштовувати прив’язки."

msgid ""
"At the moment none of the XR runtimes offer this functionality though "
"SteamVR has an existing UI from OpenVRs action map system that is still "
"accessible. This is actively being worked on however."
msgstr ""
"На даний момент жодне із середовищ виконання XR не пропонує такої функції, "
"хоча SteamVR має наявний інтерфейс користувача від системи карт дій OpenVR, "
"який все ще доступний. Проте над цим активно працюють."

msgid "Our first controller binding"
msgstr "Наша перша прив'язка контролера"

msgid ""
"Let's set up our first controller binding, using the Touch controller as an "
"example."
msgstr ""
"Давайте налаштуємо наше перше прив’язування контролера, використовуючи "
"контролер Touch як приклад."

msgid ""
"Press \"Add profile\", find the Touch controller, and add it. If it is not "
"in the list, then it may already have been added."
msgstr ""
"Натисніть «Додати профіль», знайдіть сенсорний контролер і додайте його. "
"Якщо його немає в списку, можливо, його вже додано."

msgid ""
"Our UI now shows panels for both the left and right controllers. The panels "
"contain all of the possible inputs and outputs for each controller. We can "
"use the ``+`` next to each entry to bind it to an action:"
msgstr ""
"Наш інтерфейс користувача тепер показує панелі як для лівого, так і для "
"правого контролерів. Панелі містять усі можливі входи та виходи для кожного "
"контролера. Ми можемо використовувати ``+`` біля кожного запису, щоб "
"прив’язати його до дії:"

msgid "Let's finish our configuration:"
msgstr "Завершуємо налаштування:"

msgid ""
"Each action is bound the given input or output for both controllers to "
"indicate that we support the action on either controller. The exception is "
"the movement action which is bound only to the right hand controller. It is "
"likely that we would want to use the left hand thumbstick for a different "
"purpose, say a teleport function."
msgstr ""
"Кожна дія пов’язана з даним входом або виходом для обох контролерів, щоб "
"вказати, що ми підтримуємо дію на будь-якому контролері. Винятком є дія "
"руху, яка прив'язана лише до правого контролера. Ймовірно, ми захочемо "
"використовувати джойстик лівої руки для іншої мети, скажімо, для функції "
"телепорту."

msgid ""
"In developing your game/application you have to account for the possibility "
"that the user changes the binding and binds the movement to the left hand "
"thumbstick."
msgstr ""
"Розробляючи свою гру/додаток, ви повинні враховувати можливість того, що "
"користувач змінює прив’язку та прив’язує рух до джойстика лівої руки."

msgid ""
"Also note that our shoot and grab boolean actions are linked to inputs of "
"type ``Float``. As mentioned before OpenXR will do conversions between the "
"two, but do read the warning given on that subject earlier in this document."
msgstr ""
"Також зауважте, що наші булеві дії «стріляти» та «захоплювати» пов’язані з "
"входами типу «Float». Як згадувалося раніше, OpenXR виконуватиме "
"перетворення між ними, але прочитайте попередження, надане на цю тему раніше "
"в цьому документі."

msgid "Some of the inputs seem to appear in our list multiple times."
msgstr "Здається, деякі вхідні дані з’являються в нашому списку кілька разів."

msgid ""
"For instance we can find the ``X`` button twice, once as ``X click`` and "
"then as ``X touch``. This is due to the Touch controller having a capacitive "
"sensor."
msgstr ""
"Наприклад, ми можемо знайти кнопку ``X`` двічі, один раз як ``X click``, а "
"потім як ``X touch``. Це пов’язано з тим, що сенсорний контролер має "
"ємнісний датчик."

msgid "``X touch`` will be true if the user is merely touching the X button."
msgstr "``X touch`` буде істинним, якщо користувач просто торкається кнопки X."

msgid ""
"``X click`` will be true when the user is actually pressing down on the "
"button."
msgstr "``X click`` буде істинним, коли користувач фактично натискає кнопку."

msgid "Similarly for the thumbstick we have:"
msgstr "Аналогічно для джойстика ми маємо:"

msgid ""
"``Thumbstick touch`` which will be true if the user is touching the "
"thumbstick."
msgstr ""
"``Thumbstick touch``, що буде істинним, якщо користувач торкається великого "
"пальця."

msgid ""
"``Thumbstick`` which gives a value for the direction the thumbstick is "
"pushed to."
msgstr ""
"``Thumbstick``, який дає значення напрямку, у якому натискається джойстик."

msgid ""
"``Thumbstick click`` which is true when the user is pressing down on the "
"thumbstick."
msgstr ""
"``Клацання джойстиком``, яке є істинним, коли користувач натискає джойстик."

msgid ""
"It is important to note that only a select number of XR controllers support "
"touch sensors or have click features on thumbsticks. Keep that in mind when "
"designing your game/application. Make sure these are used for optional "
"features of your game/application."
msgstr ""
"Важливо зазначити, що лише певна кількість контролерів XR підтримує сенсорні "
"датчики або мають функції клацання на джойстиках. Майте це на увазі під час "
"розробки вашої гри/програми. Переконайтеся, що вони використовуються для "
"додаткових функцій вашої гри/програми."

msgid "The simple controller"
msgstr "Простий контролер"

msgid ""
"The \"Simple controller\" is a generic controller that OpenXR offers as a "
"fallback. We'll apply our mapping:"
msgstr ""
"«Простий контролер» — це загальний контролер, який OpenXR пропонує як "
"запасний варіант. Ми застосуємо наше відображення:"

msgid ""
"As becomes painfully clear, the simple controller is often far too simple "
"and falls short for anything but the simplest of VR games/applications."
msgstr ""
"Як стає до болю ясно, простий контролер часто надто простий і не підходить "
"ні для чого, крім найпростіших ігор/додатків VR."

msgid ""
"This is why many XR runtimes only use it as a last resort and will attempt "
"to use bindings from one of the more popular systems as a fallback first."
msgstr ""
"Ось чому багато середовищ виконання XR використовують його лише як крайній "
"засіб і спочатку намагатимуться використати прив’язки з однієї з найбільш "
"популярних систем як запасний варіант."

msgid ""
"Due to the simple controller likely not covering the needs of your game, it "
"is tempting to provide bindings for every controller supported by OpenXR. "
"The default action map seems to suggest this as a valid course of action. As "
"mentioned before, the default action map was designed for ease of migration "
"from Godot 3."
msgstr ""
"Через те, що простий контролер, ймовірно, не відповідає потребам вашої гри, "
"виникає спокуса забезпечити прив’язки для кожного контролера, що "
"підтримується OpenXR. Здається, стандартна карта дій пропонує це як "
"правильний курс дій. Як згадувалося раніше, стандартну карту дій було "
"розроблено для полегшення міграції з Godot 3."

msgid ""
"It is the recommendation from the OpenXR Working Group that only bindings "
"for controllers actually tested by the developer are setup. The XR runtimes "
"are designed with this in mind. They can perform a better job of rebinding a "
"provided binding than a developer can make educated guesses. Especially as "
"the developer can't test if this leads to a comfortable experience for the "
"end user."
msgstr ""
"Робоча група OpenXR рекомендує встановлювати лише прив’язки для контролерів, "
"фактично протестованих розробником. Середовище виконання XR розроблено з "
"урахуванням цього. Вони можуть краще виконати повторне прив’язування "
"наданого зв’язування, ніж розробник може зробити обґрунтовані припущення. "
"Особливо тому, що розробник не може перевірити, чи це забезпечує комфортний "
"досвід для кінцевого користувача."

msgid ""
"This is our advice as well: limit your action map to the interaction "
"profiles for devices you have actually tested your game with. The Oculus "
"Touch controller is widely used as a fallback controller by many runtimes. "
"If you are able to test your game using a Meta Rift or Quest and add this "
"profile there is a high probability your game will work with other headsets."
msgstr ""
"Це також наша порада: обмежте свою карту дій профілями взаємодії для "
"пристроїв, на яких ви фактично тестували свою гру. Контролер Oculus Touch "
"широко використовується як резервний контролер багатьма середовищами "
"виконання. Якщо ви можете протестувати свою гру за допомогою Meta Rift або "
"Quest і додати цей профіль, висока ймовірність того, що ваша гра працюватиме "
"з іншими гарнітурами."
