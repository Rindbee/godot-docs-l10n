#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR Render Models"
msgstr "Моделі рендерингу OpenXR"

msgid ""
"A cornerstone of OpenXR's API design is being as platform agnostic as "
"possible. A great example of this is OpenXR's action map system where XR "
"runtimes have to support core interaction profiles to fall back on, if no "
"interaction profile exists for the hardware being used. This ensures that "
"OpenXR applications keep functioning even when used on hardware that didn't "
"exist when the application was released, or that the developers of the "
"application did not have access too."
msgstr ""
"Наріжним каменем дизайну API OpenXR є максимально можлива "
"платформонезалежність. Чудовим прикладом цього є система карт дій OpenXR, де "
"середовища виконання XR повинні підтримувати основні профілі взаємодії, до "
"яких можна повернутися, якщо для використовуваного обладнання не існує "
"профілю взаємодії. Це гарантує, що програми OpenXR продовжуватимуть "
"функціонувати навіть під час використання на обладнанні, якого не існувало "
"на момент випуску програми, або до якого розробники програми не мали доступу."

msgid ""
"A consequence of this is that the application developer doesn't know with "
"any certainty what hardware is being used, as the XR runtime could be "
"mimicking other hardware. The application developer thus can't show anything "
"in relation to the actual hardware used, the most common use case being "
"showing the controllers the user is currently holding."
msgstr ""
"Наслідком цього є те, що розробник застосунку не знає з певністю, яке "
"обладнання використовується, оскільки середовище виконання XR може імітувати "
"інше обладнання. Таким чином, розробник застосунку не може показати нічого, "
"що стосується фактично використаного обладнання, найпоширенішим випадком "
"використання є показ контролерів, які користувач наразі тримає."

msgid ""
"Showing the correct controller models and having these models correctly "
"positioned is important to a proper sense of immersion."
msgstr ""
"Для належного відчуття занурення важливо відобразити правильні моделі "
"контролерів та їх правильне розташування."

msgid ""
"This is where OpenXR's `render models API <https://registry.khronos.org/"
"OpenXR/specs/1.1/html/xrspec.html#XR_EXT_render_models>`_ comes in. This API "
"allows us to query the XR runtime for 3D assets that are correct for the "
"physical hardware being used. The API also allows us to query the position "
"of this hardware within the tracking volume and the correct positioning of "
"subcomponents of this hardware."
msgstr ""
"Саме тут і з'являється API моделей рендерингу OpenXR <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_render_models>`_. Цей API дозволяє нам запитувати "
"середовище виконання XR на наявність 3D-ресурсів, які відповідають "
"використовуваному фізичному обладнанню. API також дозволяє нам запитувати "
"положення цього обладнання в об'ємі відстеження та правильне розташування "
"підкомпонентів цього обладнання."

msgid ""
"For instance, we can correctly position and animate the trigger or show "
"buttons being pressed."
msgstr ""
"Наприклад, ми можемо правильно розташувати та анімувати тригер або "
"відображати натискання кнопок."

msgid ""
"For those runtimes that support the `controller data source for hand "
"tracking <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_tracking_data_source>`_ , we can also correctly "
"position the user's fingers and hand according to the shape of the "
"controller. Do note that this works in combination with the `hand joints "
"motion range extension <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_joints_motion_range>`_ to prevent clipping of the "
"fingers."
msgstr ""
"Для тих середовищ виконання, що підтримують `джерело даних контролера для "
"відстеження руки <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_tracking_data_source>`_, ми також можемо правильно "
"розташувати пальці та руку користувача відповідно до форми контролера. "
"Зверніть увагу, що це працює в поєднанні з `розширенням діапазону руху "
"суглобів кисті <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_joints_motion_range>`_, щоб запобігти обрізанню "
"пальців."

msgid "OpenXR Render models node"
msgstr "Вузол моделей рендерингу OpenXR"

msgid ""
"The :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node can "
"be used to automate most of the render models functionality. This node keeps "
"track of the active render models currently made available by the XR runtime."
msgstr ""
"Вузол :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` можна "
"використовувати для автоматизації більшості функцій моделей рендерингу. Цей "
"вузол відстежує активні моделі рендерингу, які наразі доступні у середовищі "
"виконання XR."

msgid ""
"It will create child nodes for each active render model resulting in that "
"render model being displayed."
msgstr ""
"Він створить дочірні вузли для кожної активної моделі рендерингу, що "
"призведе до відображення цієї моделі рендерингу."

msgid ""
"This node must have an :ref:`XROrigin3D<class_XROrigin3D>` node as an "
"ancestor."
msgstr ""
"Цей вузол повинен мати вузол :ref:`XROrigin3D<class_XROrigin3D>` як предка."

msgid ""
"If ``tracker`` is set to ``Any`` our node will show all render models "
"currently being tracked. In this scenario this node must be a direct child "
"of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"Якщо для параметра ``tracker`` встановлено значення ``Any``, наш вузол "
"показуватиме всі моделі рендерингу, які наразі відстежуються. У цьому "
"сценарії цей вузол має бути прямим дочірнім елементом нашого "
"вузла :ref:`XROrigin3D<class_XROrigin3D>`."

msgid ""
"If ``tracker`` is set to ``None set`` our node will only show render models "
"for which no tracker has been identified. In this scenario this node must "
"also be a direct child of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"Якщо для параметра ``tracker`` встановлено значення ``None set``, наш вузол "
"показуватиме лише ті моделі рендерингу, для яких не було ідентифіковано "
"трекер. У цьому сценарії цей вузол також має бути прямим дочірнім елементом "
"нашого вузла :ref:`XROrigin3D<class_XROrigin3D>`."

msgid ""
"If ``tracker`` is set to ``Left Hand`` or ``Right Hand`` our node will only "
"show render models related to our left or right hand respectively. In this "
"scenario, our node can be placed deeper in the scene tree."
msgstr ""
"Якщо для параметра ``tracker`` встановлено значення ``Left Hand`` або "
"``Right Hand``, наш вузол відображатиме лише моделі рендерингу, пов'язані з "
"нашою лівою або правою рукою відповідно. У цьому випадку наш вузол можна "
"розмістити глибше в дереві сцени."

msgid ""
"For most XR runtimes this means the render model represents a controller "
"that is actually being held by the user but this is not a guarantee. Some XR "
"runtimes will always set the tracker to either the left or right hand even "
"if the controller is not currently held but is being tracked. You should "
"always test this as this will lead to unwanted behavior."
msgstr ""
"Для більшості середовищ виконання XR це означає, що модель рендерингу "
"представляє контролер, який фактично тримає користувач, але це не "
"гарантовано. Деякі середовища виконання XR завжди встановлюють трекер на "
"ліву або праву руку, навіть якщо контролер наразі не тримається, але "
"відстежується. Вам завжди слід перевіряти це, оскільки це призведе до "
"небажаної поведінки."

msgid ""
"In this scenario we can also specify an action for a pose in the action map "
"by setting the ``make_local_to_pose`` property to the pose action. Use this "
"in combination with an :ref:`XRController3D<class_XRController3D>` node that "
"is using the same pose and you can now add a layer that allows you to "
"deviate from the tracked position of both your controller and the related "
"render model (see example below)."
msgstr ""
"У цьому сценарії ми також можемо вказати дію для пози на карті дій, "
"встановивши властивість ``make_local_to_pose`` для дії пози. Використовуйте "
"це в поєднанні з вузлом :ref:`XRController3D<class_XRController3D>`, який "
"використовує ту саму позу, і тепер ви можете додати шар, який дозволить вам "
"відхилятися від відстеженої позиції як вашого контролера, так і пов'язаної з "
"ним моделі рендерингу (див. приклад нижче)."

msgid ""
"Combining the above with hand tracking does introduce the problem that hand "
"tracking is completely independent from the action map system. You will need "
"to combine the hand tracking and controller tracking poses to properly "
"offset the render models."
msgstr ""
"Поєднання вищезазначеного з відстеженням рук створює проблему, оскільки "
"відстеження рук повністю незалежне від системи карти дій. Вам потрібно буде "
"поєднати відстеження рук та відстеження пози контролера, щоб правильно "
"змістити моделі рендерингу."

msgid "This falls beyond the scope of this documentation."
msgstr "Це виходить за рамки цієї документації."

msgid "Render model manager example"
msgstr "Приклад менеджера моделей рендерингу"

msgid ""
"You can download `our render models demo <https://github.com/godotengine/"
"godot-demo-projects/tree/master/xr/openxr_render_models>`_ which implements "
"the setup described below."
msgstr ""
"Ви можете завантажити `нашу демонстраційну версію моделей рендерингу "
"<https://github.com/godotengine/godot-demo-projects/tree/master/xr/"
"openxr_render_models>`_, яка реалізує описану нижче налаштування."

msgid ""
"In this setup we find "
"an :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node "
"directly underneath our :ref:`XROrigin3D<class_XROrigin3D>` node. On this "
"node our ``target`` property is set to ``None set`` and will handle showing "
"all render models that are currently not related to our left or right hand "
"controllers."
msgstr ""
"У цій конфігурації ми знаходимо "
"вузол :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` "
"безпосередньо під нашим вузлом :ref:`XROrigin3D<class_XROrigin3D>`. На цьому "
"вузлі наша властивість ``target`` встановлена на ``None set`` і оброблятиме "
"відображення всіх моделей рендерингу, які наразі не пов'язані з нашими лівим "
"або правим контролерами."

msgid ""
"We then see the same setup for our left and right hand so we'll focus on "
"just the left hand."
msgstr ""
"Потім ми бачимо однакову конфігурацію для лівої та правої руки, тому "
"зосередимося лише на лівій руці."

msgid ""
"We have an :ref:`XRController3D<class_XRController3D>` that will track the "
"location of our hand."
msgstr ""
"У нас є :ref:`XRController3D<class_XRController3D>`, який відстежуватиме "
"місцезнаходження нашої руки."

msgid ""
"We are using the ``grip`` pose in this example. The ``palm`` pose is "
"arguably more suitable and predictable however it is not supported by all XR "
"runtimes. See the hand tracking demo project for a solution to switching "
"between these poses based on what is supported."
msgstr ""
"Ми використовуємо ``grip`` поза в цьому прикладі. ``palm`` поза, можливо, "
"більш підходяща та передбачувана, проте вона підтримується не всіма "
"середовищами виконання XR. Дивіться демонстраційний проект відстеження рук, "
"щоб знайти рішення для перемикання між цими позами залежно від того, що "
"підтримується."

msgid ""
"As a child of the node we have "
"an :ref:`AnimatableBody3D<class_AnimatableBody3D>` node that follows the "
"tracked location of the hand **but** will interact with physics objects to "
"stop the player's hand from going through walls etc. This node has a "
"collision shape that encapsulates the hand."
msgstr ""
"Як дочірній елемент вузла, у нас є "
"вузол :ref:`AnimatableBody3D<class_AnimatableBody3D>`, який слідкує за "
"відстежуваним розташуванням руки, **але** взаємодіятиме з фізичними "
"об'єктами, щоб запобігти проходженню руки гравця крізь стіни тощо. Цей вузол "
"має форму зіткнення, яка інкапсулює руку."

msgid ""
"It is important to set the physics priority so that this logic runs after "
"any physics logic that moves the XROrigin3D node or the hand will lag a "
"frame behind."
msgstr ""
"Важливо встановити пріоритет фізики таким чином, щоб ця логіка виконувалася "
"після будь-якої фізичної логіки, яка переміщує вузол XROrigin3D, інакше рука "
"відставатиме на кадр."

msgid ""
"The script below shows a basic implementation for this that you can build "
"upon."
msgstr ""
"Наведений нижче скрипт показує базову реалізацію, на якій ви можете будувати "
"далі."

msgid ""
"Finally we see "
"another :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` "
"node, this one with ``target`` set to the appropriate hand and "
"``make_local_to_pose`` set to the correct pose. This will ensure that the "
"render models related to this hand are properly shown and offset if our "
"collision handler has altered the location."
msgstr ""
"Нарешті ми бачимо ще один "
"вузол :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>`, цього "
"разу з ``target``, встановленим на відповідну руку, та "
"``make_local_to_pose``, встановленим на правильну позу. Це гарантуватиме, що "
"моделі рендерингу, пов'язані з цією рукою, будуть правильно відображені та "
"зміщені, якщо наш обробник колізій змінив розташування."

msgid "Render model node"
msgstr "Вузол рендерингу моделі"

msgid ""
"The :ref:`OpenXRRenderModel<class_OpenXRRenderModel>` node implements all "
"the logic to display and position a given render model provided by the "
"render models API."
msgstr ""
"Вузол :ref:`OpenXRRenderModel<class_OpenXRRenderModel>` реалізує всю логіку "
"для відображення та позиціонування заданої моделі рендерингу, що надається "
"API моделей рендерингу."

msgid ""
"Instances of this node are added by the render model manager node we used up "
"above but you can interact with these directly if you wish."
msgstr ""
"Екземпляри цього вузла додаються вузлом менеджера моделей рендерингу, який "
"ми використовували вище, але ви можете взаємодіяти з ними безпосередньо, "
"якщо бажаєте."

msgid ""
"Whenever Godot obtains information about a new render model an RID is "
"created to reference that render model."
msgstr ""
"Щоразу, коли Godot отримує інформацію про нову модель рендерингу, "
"створюється RID для посилання на цю модель рендерингу."

msgid ""
"By assigning that RID to the ``render_model`` property on this node, the "
"node will start displaying the render model and manage both the transform "
"that places the render model in the correct place and animates all the sub "
"objects."
msgstr ""
"Призначивши цей RID властивості ``render_model`` цього вузла, вузол почне "
"відображати модель рендерингу та керувати як перетворенням, яке розміщує "
"модель рендерингу в правильному місці, так і анімує всі підоб'єкти."

msgid ""
"The ``get_top_level_path`` function will return the top level path "
"associated with this render model. This will point to either the left or "
"right hand. As the top level path can be set or cleared depending on whether "
"the user picks up, or puts down, the controller you can connect to the "
"``render_model_top_level_path_changes`` signal and react to these changes."
msgstr ""
"Функція ``get_top_level_path`` поверне шлях верхнього рівня, пов'язаний з "
"цією моделлю рендерингу. Він вказуватиме на ліву або праву руку. Оскільки "
"шлях верхнього рівня можна встановити або очистити залежно від того, чи "
"користувач бере контролер, чи опускає його, ви можете підключитися до "
"сигналу ``render_model_top_level_path_changes`` та реагувати на ці зміни."

msgid ""
"Depending on your setup of "
"the :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` nodes, "
"render models will be removed or added as their top level path changes."
msgstr ""
"Залежно від налаштувань "
"вузлів :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>`, "
"моделі рендерингу будуть видалятися або додаватися, коли змінюється шлях "
"їхнього верхнього рівня."

msgid "Backend access"
msgstr "Доступ до серверної частини"

msgid ""
"The nodes we've detailed out above handle all the display logic for us but "
"it is possible to interact with the data that drives this directly and "
"create your own implementation."
msgstr ""
"Вузли, які ми детально описали вище, обробляють всю логіку відображення, але "
"ви можете взаємодіяти з даними, які безпосередньо цим керують, і створювати "
"власну реалізацію."

msgid ""
"For this you can access "
"the :ref:`OpenXRRenderModelExtension<class_OpenXRRenderModelExtension>` "
"singleton."
msgstr ""
"Для цього ви можете отримати доступ до "
"синглтона :ref:`OpenXRRenderModelExtension<class_OpenXRRenderModelExtension>`."

msgid ""
"This object also lets you query whether render models are supported and "
"enabled on the device currently being used by calling the ``is_active`` "
"function on this object."
msgstr ""
"Цей об'єкт також дозволяє запитувати, чи підтримуються та чи ввімкнені "
"моделі рендерингу на пристрої, що використовується на даний момент, "
"викликаючи функцію ``is_active`` на цьому об'єкті."

msgid ""
"The built-in logic implements the `interaction render model API <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_interaction_render_model>`_ that lists all render models "
"related to controllers and similar devices that are present in the action "
"map. It will automatically create and remove render model entities that are "
"exposed through this API."
msgstr ""
"Вбудована логіка реалізує `interaction render model API <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_interaction_render_model>`_, який відображає список усіх "
"моделей рендерингу, пов'язаних з контролерами та подібними пристроями, "
"присутніми на карті дій. Він автоматично створюватиме та видалятиме сутності "
"моделей рендерингу, що відображаються через цей API."

msgid ""
"As other extensions become available these can be implemented in a "
"GDExtension plugin. Such a plugin can call ``render_model_create`` and "
"``render_model_destroy`` to create the object that will provide access to "
"that render model through the core render models API."
msgstr ""
"Коли з'являться інші розширення, їх можна буде реалізувати в плагіні "
"GDExtension. Такий плагін може викликати ``render_model_create`` та "
"``render_model_destroy`` для створення об'єкта, який надаватиме доступ до "
"цієї моделі рендерингу через основний API моделей рендерингу."

msgid "You should not destroy a render model outside of this logic."
msgstr "Не слід знищувати модель рендерингу поза цією логікою."

msgid ""
"You can connect to the ``render_model_added`` and ``render_model_removed`` "
"signals to be informed when new render models are added or removed."
msgstr ""
"Ви можете підключитися до сигналів ``render_model_added`` та "
"``render_model_removed``, щоб отримувати інформацію про додавання або "
"видалення нових моделей рендерингу."

msgid "The core methods for working with this API are listed below:"
msgstr "Основні методи роботи з цим API перелічені нижче:"

msgid "Render modele extension functions"
msgstr "Функції розширення моделей візуалізації"

msgid "Function"
msgstr "Function"

msgid "Description"
msgstr "Опис"

msgid "render_model_get_all"
msgstr "render_model_get_all"

msgid "Provides an array of RIDs for all render models that are being tracked."
msgstr "Надає масив RID для всіх моделей рендерингу, які відстежуються."

msgid "render_model_new_scene_instance"
msgstr "render_model_new_scene_instance"

msgid ""
"Provides a new scene that contains all meshes needed to display the render "
"model."
msgstr ""
"Надає нову сцену, яка містить усі сітки, необхідні для відображення моделі "
"рендерингу."

msgid "render_model_get_subaction_paths"
msgstr "render_model_get_subaction_paths"

msgid ""
"Provides a list of subaction paths from your action map related to this "
"render mode."
msgstr ""
"Надає список шляхів піддій з вашої карти дій, пов'язаних з цим режимом "
"рендерингу."

msgid "render_model_get_top_level_path"
msgstr "render_model_get_top_level_path"

msgid ""
"Returns the top level path associated with this render model (if any). Use "
"the ``render_model_top_level_path_changed`` signal to react to this changing."
msgstr ""
"Повертає шлях верхнього рівня, пов'язаний з цією моделлю рендерингу (якщо "
"така є). Використовуйте сигнал ``render_model_top_level_path_changed`` для "
"реагування на цю зміну."

msgid "render_model_get_confidence"
msgstr "render_model_get_confidence"

msgid ""
"Returns the tracking confidence for the tracking data for this render model."
msgstr ""
"Повертає впевненість відстеження для даних відстеження для цієї моделі "
"рендерингу."

msgid "render_model_get_root_transform"
msgstr "render_model_get_root_transform"

msgid ""
"Returns the root transform for this render model within our current "
"reference space. This can be used to place the render model in space."
msgstr ""
"Повертає кореневе перетворення для цієї моделі візуалізації в межах нашого "
"поточного простору відліку. Це можна використовувати для розміщення моделі "
"візуалізації в просторі."

msgid "render_model_get_animatable_node_count"
msgstr "render_model_get_animatable_node_count"

msgid ""
"Returns the number of nodes in our render model scene that can be animated"
msgstr ""
"Повертає кількість вузлів у нашій сцені моделі рендерингу, які можна "
"анімувати"

msgid "render_model_get_animatable_node_name"
msgstr "render_model_get_animatable_node_name"

msgid ""
"Returns the name of the node that we can animate. Note that this node can be "
"any number of levels deep within the scene."
msgstr ""
"Повертає назву вузла, який ми можемо анімувати. Зверніть увагу, що цей вузол "
"може бути на будь-якій кількості рівнів глибини в сцені."

msgid "render_model_is_animatable_node_visible"
msgstr "render_model_is_animatable_node_visible"

msgid "Returns true if this animatable node should be visible"
msgstr "Повертає значення true, якщо цей анімований вузол має бути видимим"

msgid "render_model_get_animatable_node_transform"
msgstr "render_model_get_animatable_node_transform"

msgid ""
"Returns the transform for this animatable node. This is a local transform "
"that can be directly applied."
msgstr ""
"Повертає перетворення для цього анімованого вузла. Це локальне перетворення, "
"яке можна застосувати безпосередньо."
