#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "Налаштування XR"

msgid "Introduction to the XR system in Godot"
msgstr "Знайомство з системою XR в Годо"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot пропонує модульну систему XR, яка абстрагує багато різних особливостей "
"платформи XR від користувача. В основі лежить :ref:`XRServer "
"<class_xrserver>`, який діє як центральний інтерфейс до системи XR, що "
"дозволяє користувачам відкривати інтерфейси та взаємодіяти з компонентами "
"системи XR."

msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with the :ref:"
"`XRServer <class_xrserver>` and can be queried with the ``find_interface`` "
"method on the :ref:`XRServer <class_xrserver>`. When the desired interface "
"is found it can be initialized by calling ``initialize`` on the interface."
msgstr ""
"Кожна підтримувана платформа XR реалізована як :ref:`XRInterface "
"<class_xrinterface>`. Підтримувані інтерфейси реєструються в :ref:`XRServer "
"<class_xrserver>`, і їх можна запитувати за допомогою методу "
"``find_interface`` на :ref:`XRServer <class_xrserver>`. Коли потрібний "
"інтерфейс знайдено, його можна ініціалізувати, викликавши ``ініціалізувати`` "
"на інтерфейсі."

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"Зареєстрований інтерфейс означає лише те, що інтерфейс доступний. Якщо "
"інтерфейс не підтримується хост-системою, ініціалізація може завершитися "
"помилкою та повернути ``false``. Це може мати багато причин, і, на жаль, "
"причини відрізняються від платформи до платформи. Причиною може бути те, що "
"користувач не встановив необхідне програмне забезпечення або просто не "
"підключив гарнітуру. Таким чином, ви як розробник повинні правильно "
"реагувати на інтерфейс, який не вдається ініціалізувати."

msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"У зв’язку з особливими вимогами до виведення в XR, особливо для пристроїв на "
"голові, які надають різні зображення для кожного ока, :ref:`XRServer "
"<class_xrserver>` у Godot замінить різні функції в системі відтворення. Для "
"автономних пристроїв це означає, що кінцевий вивід обробляється :ref:"
"`XRInterface <class_xrinterface>`, а звичайна система виведення Godot "
"вимкнена. Для настільних пристроїв XR, які працюють як другий екран, можна "
"виділити окремий :ref:`Viewport <class_viewport>` для обробки виводу XR, "
"залишаючи головне вікно Godot доступним для відображення альтернативного "
"вмісту."

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"Зауважте, що лише один інтерфейс може відповідати за обробку виводу на "
"пристрій XR, він відомий як основний інтерфейс і за замовчуванням буде "
"першим інтерфейсом, який ініціалізується. Таким чином, Godot наразі "
"підтримує лише впровадження з однією гарнітурою. Можливо, але все рідше, "
"мати вторинний інтерфейс, наприклад, щоб додати відстеження до пристрою, "
"який інакше підтримує лише 3DOF."

msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr "Існує три типи вузлів XR, які можна знайти майже в усіх програмах XR:"

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` представляє, для всіх намірів і цілей, "
"центральну точку вашого ігрового простору. Це надто спрощене твердження, але "
"ми розглянемо його докладніше пізніше. Усі об’єкти, які відстежуються у "
"фізичному просторі платформою XR, розташовані відносно цієї точки."

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` представляє (стерео)камеру, яка "
"використовується під час візуалізації виведення для пристрою XR. "
"Позиціонування цього вузла контролюється системою XR і автоматично "
"оновлюється за допомогою інформації відстеження, наданої платформою XR."

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` представляє контролер, який "
"використовується гравцем, зазвичай їх два, по одному в кожній руці. Ці вузли "
"надають доступ до різних станів цих контролерів і надсилають сигнали, коли "
"гравець натискає на них кнопки. Позиціонування цього вузла контролюється "
"системою XR і автоматично оновлюється за допомогою інформації відстеження, "
"наданої платформою XR."

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"Існують інші вузли, пов’язані з XR, і про ці три вузли можна сказати ще "
"багато, але ми поговоримо про це пізніше."

msgid "Prerequisites for XR in Godot 4"
msgstr "Передумови для XR у Godot 4"

msgid ""
"While in Godot 3 most things worked out of the box, Godot 4 needs a little "
"more setup. This is mainly due to the more advanced nature of the Vulkan "
"renderer. There are many rendering features in Vulkan the XR system uses "
"that aren't enabled by default. They are very easy to turn on, simply open "
"up your project settings and tick the XR shaders tickbox in the XR section:"
msgstr ""
"У той час як у Godot 3 більшість речей працювало з коробки, Godot 4 потребує "
"трохи додаткових налаштувань. Головним чином це пов’язано з більш просунутою "
"природою рендерера Vulkan. У Vulkan система XR використовує багато функцій "
"візуалізації, які не ввімкнено за замовчуванням. Їх дуже легко ввімкнути, "
"просто відкрийте налаштування проекту та поставте прапорець XR shaders у "
"розділі XR:"

msgid ""
"As Godot 4 is still in development, many post process effects have not yet "
"been updated to support stereoscopic rendering. Using these will have "
"adverse effects."
msgstr ""
"Оскільки Godot 4 все ще розробляється, багато ефектів після обробки ще не "
"оновлено для підтримки стереоскопічного рендерингу. Їх використання призведе "
"до негативних наслідків."

msgid ""
"Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the "
"future XR desktop projects should use Forward+, and projects for stand-alone "
"headsets should use Mobile. However Compatibility is the recommended "
"renderer for now due to it having the best XR performance."
msgstr ""
"У Godot 4 є 3 варіанти візуалізації: сумісність, мобільний і вперед+. У "
"майбутньому настільні проекти XR повинні використовувати Forward+, а проекти "
"для автономних гарнітур — Mobile. Однак наразі рекомендованим рендерером є "
"Compatibility, оскільки він має найкращу продуктивність XR."

msgid "OpenXR"
msgstr "openXR"

msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR — це новий галузевий стандарт, який дозволяє різним платформам XR "
"представляти себе через стандартизований API для програм XR. Цей стандарт є "
"відкритим стандартом, який підтримується групою Khronos і тому дуже добре "
"узгоджується з інтересами Годо."

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"Реалізація OpenXR від Vulkan тісно інтегрована з Vulkan, зайнявши частину "
"системи Vulkan. Це вимагає тісної інтеграції певних основних графічних "
"функцій у рендерер Vulkan, які необхідні перед налаштуванням системи XR. Це "
"було одним із головних вирішальних факторів для включення OpenXR як "
"основного інтерфейсу."

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. The required setting can be found in your project "
"settings:"
msgstr ""
"Це також означає, що OpenXR потрібно ввімкнути під час запуску Godot, щоб "
"налаштувати все правильно. Необхідне налаштування можна знайти в "
"налаштуваннях проекту:"

msgid ""
"As setup is brought forward with OpenXR you can find several other settings "
"related to OpenXR here as well. These can't be changed while your "
"application is running. The default settings will get us started and we will "
"go into detail in another section of the documentation."
msgstr ""
"Оскільки налаштування перенесено з OpenXR, тут також можна знайти кілька "
"інших параметрів, пов’язаних з OpenXR. Їх не можна змінити під час роботи "
"програми. Параметри за замовчуванням допоможуть нам почати роботу, і ми "
"розглянемо докладніше в іншому розділі документації."

msgid "Setting up the XR scene"
msgstr "Налаштування сцени XR"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have two :ref:"
"`XRController3D <class_xrcontroller3d>`, one for the left hand and one for "
"the right. Keep in mind that the camera and controller nodes should be "
"children of the origin node. Add these nodes to a new scene and rename the "
"controller nodes to ``LeftHand`` and ``RightHand``, your scene should look "
"something like this:"
msgstr ""
"Для кожної програми XR потрібен принаймні вузол :ref:`XROrigin3D "
"<class_xrorigin3d>` і :ref:`XRCamera3D <class_xrcamera3d>`. Більшість матиме "
"два :ref:`XRController3D <class_xrcontroller3d>`, один для лівої руки та "
"один для правої. Майте на увазі, що вузли камери та контролера мають бути "
"дочірніми вузлами походження. Додайте ці вузли до нової сцени та "
"перейменуйте вузли контролера на ``LeftHand`` і ``RightHand``, ваша сцена "
"має виглядати приблизно так:"

msgid ""
"Next you need to configure the controllers, select the left hand and set it "
"up as follows:"
msgstr ""
"Далі потрібно налаштувати контролери, вибрати ліву руку і налаштувати її "
"наступним чином:"

msgid "And the right hand:"
msgstr "І праву руку:"

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"Прямо зараз усі ці вузли знаходяться на підлозі, вони будуть правильно "
"розташовані під час виконання. Щоб допомогти під час розробки, може бути "
"корисно перемістити камеру вгору, щоб її ``y`` було встановлено на ``1.7``, "
"і перемістити вузли контролера на ``-0.5, 1.0, -0.5`` і `` 0,5, 1,0, -0,5`` "
"відповідно для лівої та правої руки."

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr ""
"Далі нам потрібно додати сценарій до нашого кореневого вузла. Додайте "
"наступний код у цей сценарій:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"Цей фрагмент коду припускає, що ми використовуємо OpenXR, якщо ви бажаєте "
"використовувати будь-який з інших інтерфейсів, ви можете змінити виклик "
"``find_interface``."

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"Як ви можете бачити у фрагменті коду вище, ми вимикаємо v-sync. Під час "
"використання OpenXR ви виводите результати візуалізації на HMD, який часто "
"вимагає від нас роботи з частотою 90 Гц або вище. Якщо ваш монітор має "
"частоту 60 Гц і ввімкнено V-sync, ви обмежите вихід до 60 кадрів на секунду."

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "Інтерфейси XR, такі як OpenXR, виконують власну синхронізацію."

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set ``Engine."
"physics_ticks_per_second`` to a higher value."
msgstr ""
"Також зауважте, що за замовчуванням фізичний движок також працює на частоті "
"60 Гц, і це може призвести до переривчастої фізики. Ви повинні встановити "
"для ``Engine.physics_ticks_per_second`` більше значення."

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add a :ref:"
"`DirectionalLight3D <class_directionallight3d>` and a :ref:`WorldEnvironment "
"<class_worldenvironment>` node to your scene. You may wish to also add a "
"mesh instance as a child to each controller node just to temporarily "
"visualise them. Make sure you configure a sky in your world environment."
msgstr ""
"Якщо ви запустите свій проект у цей момент часу, все працюватиме, але ви "
"опинитесь у темному світі. Отже, щоб завершити нашу відправну точку, "
"додайте :ref:`DirectionalLight3D <class_directionallight3d>` і :ref:"
"`WorldEnvironment <class_worldenvironment>` вузол до вашої сцени. Ви також "
"можете додати екземпляр mesh як дочірній елемент до кожного вузла "
"контролера, щоб тимчасово візуалізувати їх. Переконайтеся, що ви налаштували "
"небо у своєму світовому середовищі."

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr ""
"Тепер запустіть свій проект, ви повинні парити десь у космосі та мати "
"можливість оглядатися навколо."

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"Хоча традиційне перемикання рівнів безперечно можна використовувати з "
"додатками XR, де це налаштування сцени повторюється на кожному рівні, "
"більшість вважає, що легше налаштувати це один раз і завантажувати рівні як "
"підсцени. Якщо ви змінюєте сцени та повторюєте налаштування XR у кожній з "
"них, переконайтеся, що ви не запускаєте ``ініціалізацію`` кілька разів. "
"Ефект може бути непередбачуваним залежно від використовуваного інтерфейсу XR."

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr ""
"Для решти цієї базової серії посібників ми створимо гру, яка використовує "
"одну сцену."
