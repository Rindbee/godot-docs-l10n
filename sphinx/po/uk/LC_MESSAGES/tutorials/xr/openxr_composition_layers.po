#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR composition layers"
msgstr "Шари композиції OpenXR"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"In XR games you generally want to create user interactions that happen in 3D "
"space and involve users touching objects as if they are touching them in "
"real life."
msgstr ""
"В іграх XR ви зазвичай хочете створити взаємодію користувачів, яка "
"відбувається в 3D-просторі та залучати користувачів доторкатися до об’єктів "
"так, ніби вони торкаються до них у реальному житті."

msgid ""
"Sometimes however creating a more traditional 2D interface is unavoidable. "
"In XR however you can't just add 2D components to your scene. Godot needs "
"depth information to properly position these elements so they appear at a "
"comfortable place for the user. Even with depth information there are "
"headsets with slanted displays that make it impossible for the standard 2D "
"pipeline to correctly render the 2D elements."
msgstr ""
"Однак іноді створення більш традиційного 2D-інтерфейсу неминуче. Однак у XR "
"ви не можете просто додати 2D-компоненти до вашої сцени. Godot потребує "
"інформації про глибину, щоб правильно розташувати ці елементи, щоб вони "
"відображалися в зручному місці для користувача. Навіть з інформацією про "
"глибину є гарнітури з похилими дисплеями, які не дозволяють стандартному 2D-"
"конвеєру правильно відтворювати 2D-елементи."

msgid ""
"The solution then is to render the UI to a :ref:`SubViewport "
"<class_subviewport>` and display the result of this using "
"a :ref:`ViewportTexture <class_viewporttexture>` on a 3D mesh. "
"The :ref:`QuadMesh <class_quadmesh>` is a suitable option for this."
msgstr ""
"Рішення полягає в тому, щоб відобразити UI у :ref:`SubViewport "
"<class_subviewport>` і відобразити результат цього за "
"допомогою :ref:`ViewportTexture <class_viewporttexture>` на 3D-"
"сіті. :ref:`QuadMesh <class_quadmesh>` є підходящим варіантом для цього."

msgid ""
"See the `GUI in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/gui_in_3d>`_ example project for an example of this approach."
msgstr ""
"Перегляньте приклад проекту `GUI у 3D <https://github.com/godotengine/godot-"
"demo-projects/tree/master/viewport/gui_in_3d>`_ для прикладу цього підходу."

msgid ""
"The problem with displaying the viewport in this way is that the rendered "
"result is sampled for lens distortion by the XR runtime and the resulting "
"quality loss can make UI text hard to read."
msgstr ""
"Проблема з відображенням вікна перегляду таким чином полягає в тому, що "
"відтворений результат перевіряється на спотворення об’єктива за допомогою "
"середовища виконання XR, і результуюча втрата якості може ускладнити читання "
"тексту інтерфейсу користувача."

msgid ""
"OpenXR offers a solution to this problem through composition layers. With "
"composition layers it is possible for the contents of a viewport to be "
"projected on a surface after lens distortion resulting in a much higher "
"quality end result."
msgstr ""
"OpenXR пропонує вирішення цієї проблеми за допомогою композиційних шарів. "
"Завдяки композиційним шарам вміст вікна перегляду може бути спроектовано на "
"поверхню після спотворення лінзи, що призводить до набагато вищої якості "
"кінцевого результату."

msgid ""
"As not all XR runtimes support all composition layer types, Godot implements "
"a fallback solution where we render the viewport as part of the normal scene "
"but with the aforementioned quality limitations."
msgstr ""
"Оскільки не всі середовища виконання XR підтримують усі типи шарів "
"композиції, Godot реалізує резервне рішення, де ми візуалізуємо вікно "
"перегляду як частину звичайної сцени, але з вищезазначеними обмеженнями "
"якості."

msgid ""
"When the composition layer is supported, it is the XR runtime that presents "
"the subviewport. This means the UI is only visible in the headset, it will "
"not be accessible by Godot and will thus not be shown when you have a "
"spectator view on the desktop."
msgstr ""
"Якщо композиційний рівень підтримується, саме середовище виконання XR "
"представляє підокно перегляду. Це означає, що користувальницький інтерфейс "
"видно лише в гарнітурі, Godot не матиме доступу до нього, і, отже, не "
"відображатиметься, коли на робочому столі є глядач."

msgid "There are currently 3 nodes that expose this functionality:"
msgstr "Наразі існує 3 вузли, які надають цю функцію:"

msgid ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a cylinder (or "
"\"slice\" of a cylinder)."
msgstr ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"показує вміст SubViewport всередині циліндра (або «зрізу» циліндра)."

msgid ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a sphere (or "
"\"slice\" of a sphere)."
msgstr ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"показує вміст SubViewport всередині сфери (або «зрізу» сфери)."

msgid ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a flat rectangle."
msgstr ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` показує "
"вміст SubViewport на плоскому прямокутнику."

msgid "Setting up the SubViewport"
msgstr "Налаштування SubViewport"

msgid ""
"The first step is adding a SubViewport for our 2D UI, this doesn't require "
"any specific steps. For our example we do mark the viewport as transparent."
msgstr ""
"Першим кроком є додавання SubViewport для нашого двовимірного інтерфейсу, "
"для цього не потрібно виконувати жодних особливих кроків. У нашому прикладі "
"ми позначаємо вікно перегляду як прозоре."

msgid ""
"You can now create the 2D UI by adding child nodes to the SubViewport as you "
"normally would. It is advisable to save the 2D UI in a subscene, this makes "
"it easier to do your layout."
msgstr ""
"Тепер ви можете створити 2D UI, додавши дочірні вузли до SubViewport, як "
"зазвичай. Бажано зберегти 2D UI у підсцені, це полегшить створення макета."

msgid ""
"The update mode \"When Visible\" will not work as Godot can't determine "
"whether the viewport is visible to the user. When assigning our viewport to "
"a composition layer Godot will automatically adjust this."
msgstr ""
"Режим оновлення «Коли видно» не працюватиме, оскільки Godot не може "
"визначити, чи вікно перегляду видиме для користувача. При призначенні нашого "
"вікна перегляду шару композиції Godot автоматично налаштує це."

msgid "Adding a composition layer"
msgstr "Додавання композиційного шару"

msgid ""
"The second step is adding our composition layer. We can add the correct "
"composition layer node as a child node of our :ref:`XROrigin3D "
"<class_xrorigin3d>` node. This is very important as the XR runtime positions "
"everything in relation to our origin."
msgstr ""
"Другим кроком є додавання шару композиції. Ми можемо додати правильний вузол "
"шару композиції як дочірній вузол нашого вузла :ref:`XROrigin3D "
"<class_xrorigin3d>`. Це дуже важливо, оскільки середовище виконання XR "
"позиціонує все відносно нашого походження."

msgid ""
"We want to position the composition layer so it is at eye height and roughly "
"1 to 1.5 meters away from the player."
msgstr ""
"Ми хочемо розташувати шар композиції так, щоб він знаходився на висоті очей "
"і приблизно на 1-1,5 метри від гравця."

msgid ""
"We now assign the SubViewport to the ``Layer Viewport`` property and enable "
"Alpha Blend."
msgstr ""
"Тепер ми призначаємо SubViewport властивості ``Layer Viewport`` і вмикаємо "
"Alpha Blend."

msgid ""
"As the player can walk away from the origin point, you will want to "
"reposition the composition layer when the player recenters the view. Using "
"the reference space ``Local Floor`` will apply this logic automatically."
msgstr ""
"Оскільки гравець може відійти від початкової точки, ви захочете змінити "
"положення шару композиції, коли гравець відцентрує перегляд. Використання "
"довідкового простору ``Місцевий поверх`` автоматично застосує цю логіку."

msgid "Making the interface work"
msgstr "Змусити інтерфейс працювати"

msgid ""
"So far we're only displaying our UI, to make it work we need to add some "
"code. For this example we're going to keep things simple and make one of the "
"controllers work as a pointer. We'll then simulate mouse actions with this "
"pointer."
msgstr ""
"Поки що ми лише відображаємо наш інтерфейс користувача, щоб він працював, "
"нам потрібно додати код. У цьому прикладі ми зробимо все просто і змусимо "
"один із контролерів працювати як покажчик. Потім ми імітуємо дії миші за "
"допомогою цього вказівника."

msgid ""
"This code also requires a ``MeshInstance3D`` node called ``Pointer`` to be "
"added as a child to our ``OpenXRCompositionLayerQuad`` node. We configure a "
"``SphereMesh`` with a radius ``0.01`` meters. We'll be using this as a "
"helper to visualize where the user is pointing."
msgstr ""
"Цей код також вимагає додавання вузла ``MeshInstance3D`` під назвою "
"``Pointer`` як дочірнього до нашого вузла ``OpenXRCompositionLayerQuad``. Ми "
"налаштовуємо ``SphereMesh`` з радіусом ``0.01`` метра. Ми будемо "
"використовувати це як помічник для візуалізації того, куди вказує користувач."

msgid ""
"The main function that drives this functionality is the ``intersects_ray`` "
"function on our composition layer node. This function takes the global "
"position and orientation of our pointer and returns the UV where our ray "
"intersects our viewport. It returns ``Vector2(-1.0, -1.0)`` if we're not "
"pointing at our viewport."
msgstr ""
"Основною функцією, яка керує цією функціональністю, є функція "
"``intersects_ray`` на нашому вузлі шару композиції. Ця функція приймає "
"глобальне положення та орієнтацію нашого вказівника та повертає UV, де наш "
"промінь перетинає наше вікно перегляду. Він повертає ``Vector2(-1.0, "
"-1.0)``, якщо ми не вказуємо на наше вікно перегляду."

msgid ""
"We start with setting up some variables, important here are the export "
"variables which identify our controller node with which we point to our "
"screen."
msgstr ""
"Ми починаємо з налаштування деяких змінних, важливими тут є експортні "
"змінні, які ідентифікують наш вузол контролера, за допомогою якого ми "
"вказуємо на наш екран."

msgid ""
"Next we define a helper function that takes the value returned from "
"``intersects_ray`` and gives us the global position for that intersection "
"point. This implementation only works for our ``OpenXRCompositionLayerQuad`` "
"node."
msgstr ""
"Далі ми визначаємо допоміжну функцію, яка приймає значення, повернене з "
"``intersects_ray``, і дає нам глобальне положення для цієї точки перетину. "
"Ця реалізація працює лише для нашого вузла ``OpenXRCompositionLayerQuad``."

msgid ""
"We also define a helper function that takes our ``intersect`` value and "
"returns our location in the viewport's local coordinate system:"
msgstr ""
"Ми також визначаємо допоміжну функцію, яка приймає значення нашого "
"``intersect`` та повертає наше розташування в локальній системі координат "
"області перегляду:"

msgid ""
"The main logic happens in our ``_process`` function. Here we start by hiding "
"our pointer, we then check if we have a valid controller and viewport, and "
"we call ``intersects_ray`` with the position and orientation of our "
"controller:"
msgstr ""
"Основна логіка відбувається в нашій функції ``_process``. Тут ми починаємо з "
"приховування вказівника, потім перевіряємо, чи є у нас дійсний контролер і "
"вікно перегляду, і викликаємо ``intersects_ray`` з положенням і орієнтацією "
"нашого контролера:"

msgid ""
"Next we check if we're intersecting with our viewport. If so, we check if "
"our button is pressed and place our pointer at our intersection point."
msgstr ""
"Далі ми перевіряємо, чи ми перетинаємося з нашим вікном перегляду. Якщо так, "
"ми перевіряємо, чи наша кнопка натиснута, і розміщуємо покажчик у точці "
"перетину."

msgid ""
"If we were intersecting in our previous process call and our pointer has "
"moved, we prepare an :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` object to simulate our mouse moving and send "
"that to our viewport for further processing."
msgstr ""
"Якщо під час попереднього виклику процесу ми перетиналися, і наш вказівник "
"перемістився, ми готуємо об'єкт :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` для імітації руху миші та надсилаємо це до "
"області перегляду для подальшої обробки."

msgid ""
"If we've just released our button we also prepare "
"an :ref:`InputEventMouseButton <class_InputEventMouseButton>` object to "
"simulate a button release and send that to our viewport for further "
"processing."
msgstr ""
"Якщо ми щойно відпустили кнопку, ми також готуємо "
"об'єкт :ref:`InputEventMouseButton <class_InputEventMouseButton>` для "
"імітації відпускання кнопки та надсилаємо його до нашого вікна перегляду для "
"подальшої обробки."

msgid ""
"Or if we've just pressed our button we prepare "
"an :ref:`InputEventMouseButton <class_InputEventMouseButton>` object to "
"simulate a button press and send that to our viewport for further processing."
msgstr ""
"Або, якщо ми щойно натиснули кнопку, ми готуємо "
"об'єкт :ref:`InputEventMouseButton <class_InputEventMouseButton>` для "
"імітації натискання кнопки та надсилаємо його до нашого вікна перегляду для "
"подальшої обробки."

msgid "Next we remember our state for next frame."
msgstr "Далі ми запам’ятовуємо наш стан для наступного кадру."

msgid "Finally, if we aren't intersecting, we clear our state."
msgstr "Нарешті, якщо ми не перетинаємося, ми очищаємо наш стан."

msgid "Hole punching"
msgstr "Пробивання отворів"

msgid ""
"As the composition layer is composited on top of the render result, it can "
"be rendered in front of objects that are actually forward of the viewport."
msgstr ""
"Оскільки шар композиції складається поверх результату візуалізації, його "
"можна відобразити перед об’єктами, які фактично знаходяться перед вікном "
"перегляду."

msgid ""
"By enabling hole punch you instruct Godot to render a transparent object "
"where our viewport is displayed. It does this in a way that fills the depth "
"buffer and clears the current rendering result. Anything behind our viewport "
"will now be cleared, while anything in front of our viewport will be "
"rendered as usual."
msgstr ""
"Увімкнувши перфорацію, ви наказуєте Godot відобразити прозорий об’єкт там, "
"де відображається наше вікно перегляду. Він робить це таким чином, що "
"заповнює буфер глибини та очищає поточний результат візуалізації. Все, що "
"знаходиться позаду нашого вікна перегляду, тепер буде очищено, а все, що "
"знаходиться перед нашим вікном перегляду, відображатиметься як зазвичай."

msgid ""
"You also need to set ``Sort Order`` to a negative value, the XR compositor "
"will now draw the viewport first, and then overlay our rendering result."
msgstr ""
"Вам також потрібно встановити ``Порядок сортування`` на від’ємне значення, "
"компонувальник XR тепер спочатку намалює вікно перегляду, а потім накладе "
"наш результат візуалізації."

msgid ""
"Use case showing how the user's hand is incorrectly obscured by a "
"composition layer when hole punching is not used."
msgstr ""
"Приклад використання, що показує, як рука користувача неправильно "
"закривається композиційним шаром, коли не використовується перфорація."
