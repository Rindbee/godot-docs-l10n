#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "A better XR start script"
msgstr "Кращий сценарій запуску XR"

msgid ""
"In :ref:`doc_setting_up_xr` we introduced a startup script that initialises "
"our setup which we used as our script on our main node. This script performs "
"the minimum steps required for any given interface."
msgstr ""
"У :ref:`doc_setting_up_xr` ми представили сценарій запуску, який ініціалізує "
"наші налаштування, які ми використовували як наш сценарій на нашому "
"головному вузлі. Цей сценарій виконує мінімальну кількість кроків, "
"необхідних для будь-якого заданого інтерфейсу."

msgid ""
"When using OpenXR there are a number of improvements we should do here. For "
"this we've created a more elaborate starting script. You will find these "
"used in our demo projects."
msgstr ""
"Під час використання OpenXR ми маємо зробити ряд покращень. Для цього ми "
"створили більш складний стартовий сценарій. Ви знайдете їх у наших "
"демонстраційних проектах."

msgid ""
"Alternatively, if you are using XR Tools (see :ref:"
"`doc_introducing_xr_tools`) it contains a version of this script updated "
"with some features related to XR tools."
msgstr ""
"Крім того, якщо ви використовуєте інструменти XR (див. :ref:"
"`doc_introducing_xr_tools`), він містить версію цього сценарію, оновлену "
"деякими функціями, пов’язаними з інструментами XR."

msgid ""
"Below we will detail out the script used in our demos and explain the parts "
"that are added."
msgstr ""
"Нижче ми докладно розглянемо сценарій, який використовується в наших "
"демонстраціях, і пояснимо частини, які додаються."

msgid "Signals for our script"
msgstr "Сигнали для нашого сценарію"

msgid ""
"We are introducing 3 signals to our script so that our game can add further "
"logic:"
msgstr ""
"Ми вводимо 3 сигнали до нашого сценарію, щоб наша гра могла додати додаткову "
"логіку:"

msgid ""
"``focus_lost`` is emitted when the player takes off their headset or when "
"the player enters the menu system of the headset."
msgstr ""
"``focus_lost`` видається, коли гравець знімає гарнітуру або коли гравець "
"входить до системи меню гарнітури."

msgid ""
"``pose_recentered`` is emitted when the headset requests the players "
"position to be reset."
msgstr ""
"``pose_recentered`` видається, коли гарнітура запитує скидання позиції "
"гравців."

msgid "Our game should react accordingly to these signals."
msgstr "Наша гра має відповідним чином реагувати на ці сигнали."

msgid "Variables for our script"
msgstr "Змінні для нашого сценарію"

msgid "We introduce a few new variables to our script as well:"
msgstr "Ми також вводимо кілька нових змінних у наш сценарій:"

msgid ""
"``maximum_refresh_rate`` will control the headsets refresh rate if this is "
"supported by the headset."
msgstr ""
"``maximum_refresh_rate`` керуватиме частотою оновлення гарнітури, якщо це "
"підтримується гарнітурою."

msgid ""
"``xr_interface`` holds a reference to our XR interface, this already existed "
"but we now type it to get full access to our :ref:`XRInterface "
"<class_xrinterface>` API."
msgstr ""
"``xr_interface`` містить посилання на наш інтерфейс XR, він уже існував, але "
"тепер ми вводимо його, щоб отримати повний доступ до нашого :ref:"
"`XRInterface <class_xrinterface>` API."

msgid "``xr_is_focussed`` will be set to true whenever our game has focus."
msgstr ""
"``xr_is_focussed`` буде встановлюватися на true щоразу, коли наша гра має "
"фокус."

msgid "Our updated ready function"
msgstr "Наша оновлена готова функція"

msgid "We add a few things to the ready function."
msgstr "Ми додаємо кілька речей до готової функції."

msgid ""
"If we're using the mobile or forward+ renderer we set the viewports "
"``vrs_mode`` to ``VRS_XR``. On platforms that support this, this will enable "
"foveated rendering."
msgstr ""
"Якщо ми використовуємо мобільний рендерер або рендерер forward+, ми "
"встановлюємо вікна перегляду ``vrs_mode`` на ``VRS_XR``. На платформах, які "
"підтримують це, це увімкне фовеативне рендеринг."

msgid ""
"If we're using the compatibility renderer, we check if the OpenXR foveated "
"rendering settings are configured and if not, we output a warning. See :ref:"
"`OpenXR Settings <doc_openxr_settings>` for further details."
msgstr ""
"Якщо ми використовуємо рендерер сумісності, ми перевіряємо, чи налаштовано "
"параметри візуалізації OpenXR foveated, і якщо ні, ми виводимо попередження. "
"Перегляньте :ref:`Налаштування OpenXR <doc_openxr_settings>` для отримання "
"додаткової інформації."

msgid ""
"We hook up a number of signals that will be emitted by the :ref:`XRInterface "
"<class_xrinterface>`. We'll provide more detail about these signals as we "
"implement them."
msgstr ""
"Ми підключаємо декілька сигналів, які випромінює :ref:`XRInterface "
"<class_xrinterface>`. Ми надамо більше деталей про ці сигнали, коли ми їх "
"запровадимо."

msgid ""
"We also quit our application if we couldn't successfully initialise OpenXR. "
"Now this can be a choice. If you are making a mixed mode game you setup the "
"VR mode of your game on success, and setup the non-VR mode of your game on "
"failure. However, when running a VR only application on a standalone "
"headset, it is nicer to exit on failure than to hang the system."
msgstr ""
"Ми також закриваємо нашу програму, якщо не можемо успішно ініціалізувати "
"OpenXR. Тепер це може бути вибір. Якщо ви створюєте гру в змішаному режимі, "
"ви встановлюєте режим віртуальної реальності вашої гри в разі успіху та "
"встановлюєте режим без віртуальної реальності вашої гри в разі невдачі. "
"Однак під час запуску лише програми VR на автономній гарнітурі зручніше "
"вийти у разі помилки, ніж зависати систему."

msgid "On session begun"
msgstr "На початку сесії"

msgid ""
"This signal is emitted by OpenXR when our session is setup. This means the "
"headset has run through setting everything up and is ready to begin "
"receiving content from us. Only at this time various information is properly "
"available."
msgstr ""
"Цей сигнал випромінює OpenXR під час налаштування нашого сеансу. Це означає, "
"що гарнітура пройшла всі налаштування та готова почати отримувати від нас "
"вміст. Тільки в цей час різноманітна інформація доступна належним чином."

msgid ""
"The main thing we do here is to check our headsets refresh rate. We also "
"check the available refresh rates reported by the XR runtime to determine if "
"we want to set our headset to a higher refresh rate."
msgstr ""
"Головне, що ми робимо тут, це перевірити частоту оновлення наших гарнітур. "
"Ми також перевіряємо доступні частоти оновлення, які повідомляє середовище "
"виконання XR, щоб визначити, чи хочемо ми налаштувати гарнітуру на вищу "
"частоту оновлення."

msgid ""
"Finally we match our physics update rate to our headset update rate. Godot "
"runs at a physics update rate of 60 updates per second by default while "
"headsets run at a minimum of 72, and for modern headsets often up to 144 "
"frames per second. Not matching the physics update rate will cause "
"stuttering as frames are rendered without objects moving."
msgstr ""
"Нарешті ми порівнюємо швидкість оновлення фізики з частотою оновлення "
"гарнітури. Godot за замовчуванням працює зі швидкістю оновлення фізики 60 "
"оновлень на секунду, тоді як гарнітури працюють із мінімумом 72, а для "
"сучасних гарнітур часто до 144 кадрів на секунду. Невідповідність швидкості "
"оновлення фізики спричинить заїкання, оскільки кадри візуалізуються без "
"рухомих об’єктів."

msgid "On visible state"
msgstr "На видимому стані"

msgid ""
"This signal is emitted by OpenXR when our game becomes visible but is not "
"focussed. This is a bit of a weird description in OpenXR but it basically "
"means that our game has just started and we're about to switch to the "
"focussed state next, that the user has opened a system menu or the users has "
"just took their headset off."
msgstr ""
"Цей сигнал випромінює OpenXR, коли наша гра стає видимою, але не "
"фокусується. Це дещо дивний опис у OpenXR, але в основному це означає, що "
"наша гра щойно почалася, і ми збираємося перейти у фокусований стан, що "
"користувач відкрив системне меню або користувач щойно зняв гарнітуру ."

msgid ""
"On receiving this signal we'll update our focussed state, we'll change the "
"process mode of our node to disabled which will pause processing on this "
"node and it's children, and emit our ``focus_lost`` signal."
msgstr ""
"Отримавши цей сигнал, ми оновимо наш сфокусований стан, ми змінимо режим "
"процесу нашого вузла на вимкнений, що призупинить обробку на цьому вузлі та "
"його дочірніх елементах і видасть наш сигнал ``focus_lost``."

msgid ""
"If you've added this script to your root node, this means your game will "
"automatically pause when required. If you haven't, you can connect a method "
"to the signal that performs additional changes."
msgstr ""
"Якщо ви додали цей сценарій до свого кореневого вузла, це означає, що ваша "
"гра буде автоматично призупинятися, коли потрібно. Якщо ви цього не зробили, "
"ви можете підключити до сигналу метод, який виконує додаткові зміни."

msgid ""
"While your game is in visible state because the user has opened a system "
"menu, Godot will keep rendering frames and head tracking will remain active "
"so your game will remain visible in the background. However controller and "
"hand tracking will be disabled until the user exits the system menu."
msgstr ""
"Поки ваша гра перебуває у видимому стані, оскільки користувач відкрив "
"системне меню, Godot продовжуватиме відображати кадри, а відстеження голови "
"залишатиметься активним, тому ваша гра залишатиметься видимою у фоновому "
"режимі. Однак контролер і відстеження рук будуть вимкнені, доки користувач "
"не вийде із системного меню."

msgid "On focussed state"
msgstr "У зосередженому стані"

msgid ""
"This signal is emitted by OpenXR when our game gets focus. This is done at "
"the completion of our startup, but it can also be emitted when the user "
"exits a system menu, or put their headset back on."
msgstr ""
"Цей сигнал випромінює OpenXR, коли наша гра отримує фокус. Це робиться після "
"завершення нашого запуску, але також може видаватись, коли користувач "
"виходить із системного меню або знову вдягає гарнітуру."

msgid ""
"Note also that when your game starts while the user is not wearing their "
"headset, the game stays in 'visible' state until the user puts their headset "
"on."
msgstr ""
"Зауважте також, що коли ваша гра починається, коли користувач не носить "
"гарнітуру, гра залишається у «видимому» стані, доки користувач не одягне "
"гарнітуру."

msgid ""
"It is thus important to keep your game paused while in visible mode. If you "
"don't the game will keep on running while your user isn't interacting with "
"your game. Also when the game returns to focussed mode, suddenly all "
"controller and hand tracking is re-enabled and could have game breaking "
"consequences if you do not react to this accordingly. Be sure to test this "
"behaviour in your game!"
msgstr ""
"Тому важливо тримати вашу гру на паузі під час видимого режиму. Якщо ви "
"цього не зробите, гра працюватиме, поки ваш користувач не взаємодітиме з "
"вашою грою. Крім того, коли гра повертається до зосередженого режиму, "
"раптово всі контролери та відстеження рук знову вмикаються, і це може "
"призвести до поломки гри, якщо ви не відреагуєте на це належним чином. "
"Обов’язково перевірте цю поведінку у своїй грі!"

msgid ""
"While handling our signal we will update the focusses state, unpause our "
"node and emit our ``focus_gained`` signal."
msgstr ""
"Під час обробки нашого сигналу ми будемо оновлювати стан фокусів, відключати "
"паузу вашого носа та видавати наш сигнал ``фокус отримано``."

msgid "On stopping state"
msgstr "У стані зупинки"

msgid ""
"This signal is emitted by OpenXR when we enter our stop state. There are "
"some differences between platforms when this happens. On some platforms this "
"is only emitted when the game is being closed. But on other platforms this "
"will also be emitted every time the player takes off their headset."
msgstr ""
"Цей сигнал випромінює OpenXR, коли ми входимо в стан зупинки. Існують певні "
"відмінності між платформами, коли це відбувається. На деяких платформах це "
"видається лише під час закриття гри. Але на інших платформах це також "
"видаватиметься кожного разу, коли гравець зніматиме гарнітуру."

msgid "For now this method is only a place holder."
msgstr "Наразі цей метод є лише заповнювачем."

msgid "On pose recentered"
msgstr "У позі відцентровано"

msgid ""
"This signal is emitted by OpenXR when the user requests their view to be "
"recentered. Basically this communicates to your game that the user is now "
"facing forward and you should re-orient the player so they are facing "
"forward in the virtual world."
msgstr ""
"Цей сигнал випромінює OpenXR, коли користувач запитує повторне центрування "
"свого перегляду. По суті, це повідомляє вашій грі, що користувач зараз "
"дивиться вперед, і ви повинні переорієнтувати гравця, щоб він дивився вперед "
"у віртуальному світі."

msgid ""
"As doing so is dependent on your game, your game needs to react accordingly."
msgstr ""
"Оскільки це залежить від вашої гри, ваша гра повинна відповідним чином "
"реагувати."

msgid ""
"All we do here is emit the ``pose_recentered`` signal. You can connect to "
"this signal and implement the actual recenter code. Often it is enough to "
"call :ref:`center_on_hmd() <class_XRServer_method_center_on_hmd>`."
msgstr ""
"Все, що ми робимо тут, це випромінюємо сигнал ``pose_recentered``. Ви можете "
"підключитися до цього сигналу та впровадити фактичний код рецентратора. "
"Часто достатньо викликати :ref:`center_on_hmd() "
"<class_XRServer_method_center_on_hmd>`."

msgid ""
"And that finished our script. It was written so that it can be re-used over "
"multiple projects. Just add it as the script on your main node (and extend "
"it if needed) or add it on a child node specific for this script."
msgstr ""
"На цьому наш сценарій закінчився. Він був написаний для того, щоб його можна "
"було повторно використовувати в кількох проектах. Просто додайте його як "
"сценарій на вашому головному вузлі (і розширте його, якщо потрібно) або "
"додайте його на дочірньому вузлі, спеціальному для цього сценарію."
