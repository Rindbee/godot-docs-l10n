#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "Організація сцени"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should you use? Where should you place them? How should "
"they interact?"
msgstr ""
"Ця стаття охоплює теми, пов’язані з ефективною організацією вмісту сцени. "
"Які вузли слід використовувати? Де їх розмістити? Як вони повинні "
"взаємодіяти?"

msgid "How to build relationships effectively"
msgstr "Як ефективно будувати залежності"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr ""
"Коли користувачі Godot починають створювати свої сцени, вони часто "
"стикаються з такою проблемою:"

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"Вони створюють свою першу сцену і наповнюють її вмістом лише для того, щоб "
"врешті-решт зберегти гілки своєї сцени в окремі сцени, оскільки починає "
"накопичуватися неприємне відчуття, що сцену потрібно розбити на кілька "
"окремих. Однак тоді вони помічають, що надійні посилання, на які вони могли "
"покластися раніше, стають непрацездатними. Повторне використання сцени в "
"кількох місцях створює проблеми, оскільки шляхи вузлів не знаходять своїх "
"цілей і встановлені сигнальні зв’язки розірвані."

msgid ""
"To fix these problems, you must instantiate the sub-scenes without them "
"requiring details about their environment. You need to be able to trust that "
"the sub-scene will create itself without being picky about how it's used."
msgstr ""
"Щоб вирішити ці проблеми, ви повинні створити екземпляри підсцени, не "
"вимагаючи для них деталей про своє середовище. Ви повинні бути в змозі "
"повірити в те, що підсцена створиться сама, не будучи вибагливими щодо того, "
"як її використовувати."

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"Одна з найбільших речей, яку слід враховувати в ООП, - це підтримка "
"цілеспрямованих класів особливого призначення з `вільним зв'язком <https://"
"en.wikipedia.org/wiki/Loose_coupling>`_ з іншими частинами кодової бази. Це "
"зменшує розмір об’єктів (для ремонтопридатності) та покращує їх повторне "
"використання."

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr ""
"Ці найкращі практики ООП мають *деяку* причетність до найкращих практик у "
"структурі сцени та використанні скриптів."

msgid ""
"**If at all possible, you should design scenes to have no dependencies.** "
"That is, you should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**Якщо це взагалі можливо, ви повинні створювати сцени без залежностей.** "
"Тобто ви повинні створювати сцени, які зберігають у собі все необхідне."

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"Якщо сцена повинна взаємодіяти із зовнішнім контекстом, досвідчені "
"розробники рекомендують використовувати `Dependency Injection (Ін'єкцію "
"Залежності) <https://en.wikipedia.org/wiki/Dependency_injection>`_. Ця "
"техніка передбачає наявність API високого рівня, що забезпечує залежності "
"API низького рівня. Навіщо це робити? Просто класи, які покладаються на своє "
"зовнішнє середовище, можуть ненавмисно викликати помилки та несподівану "
"поведінку."

msgid ""
"To do this, you must expose data and then rely on a parent context to "
"initialize it:"
msgstr ""
"Щоб зробити це, ви повинні виставити дані, а потім покластися на "
"батьківський контекст для їх ініціалізації:"

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"Підключення до сигналу. Надзвичайно безпечний, але повинен використовуватися "
"лише для \"реагування\" на поведінку, а не для її запуску. Зазвичай назви "
"сигналів - це дієслова в минулому часі, як-от \"увійшов\", \"уміння "
"активовано\" або \"предмет зібрано\"."

msgid "Call a method. Used to start behavior."
msgstr "Викличте метод. Використовується для початку поведінки."

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"Ініціалізувати властивість :ref:`Callable <class_Callable>`. Безпечніше, ніж "
"метод, оскільки володіння методом не є обов'язковим. Використовується для "
"запуску поведінки."

msgid "Initialize a Node or other Object reference."
msgstr "Ініціалізуйте посилання на Вузол або інший Об’єкт."

msgid "Initialize a NodePath."
msgstr "Ініціалізуйте NodePath *(Шлях вузла)*."

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. You can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"Ці параметри приховують точки доступу від дочірнього вузла. Це, у свою "
"чергу, тримає дитину **слабко пов’язаною** з навколишнім середовищем. Ви "
"можете повторно використовувати його в іншому контексті без будь-яких "
"додаткових змін у його API."

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their own hierarchies while an ancestor mediates "
"their communications and references."
msgstr ""
"Хоча наведені вище приклади ілюструють стосунки «батьки-дочірні», ті ж "
"принципи застосовуються до всіх об’єктних відносин. Вузли, які є братами та "
"сестрами, повинні знати лише про свої власні ієрархії, тоді як предок є "
"посередником у їхніх зв’язках і посиланнях."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object owns the other objects "
"should manage the relationships between them."
msgstr ""
"Ці ж принципи також застосовуються до об’єктів, що не належать до Node і "
"підтримують залежності від інших об’єктів. Незалежно від того, який об’єкт "
"володіє іншими об’єктами, він повинен керувати зв’язками між ними."

msgid ""
"You should favor keeping data in-house (internal to a scene), though, as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation to use it safely is error-prone by default."
msgstr ""
"Ви повинні віддавати перевагу зберіганню даних усередині (всередині сцени), "
"однак, оскільки розміщення залежності від зовнішнього контексту, навіть "
"слабко пов’язаного, все одно означає, що вузол очікуватиме, що щось у його "
"середовищі буде істинним. Філософія дизайну проекту повинна запобігти цьому. "
"Якщо ні, властиві зобов'язання коду змусять розробників використовувати "
"документацію для відстеження об'єктних зв'язків у мікроскопічному масштабі; "
"це ще називають пеклом розробки. Написання коду, який покладається на "
"зовнішню документацію для його безпечного використання, за замовчуванням є "
"схильним до помилок."

msgid ""
"To avoid creating and maintaining such documentation, you convert the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no "
"child :ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The "
"editor then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""
"Щоб уникнути створення та підтримки такої документації, ви перетворюєте "
"залежний вузол (\"дочірній\" вище) у сценарій інструменту, який реалізує "
"``_get_configuration_warnings()``. Повернення з нього непорожнього "
"PackedStringArray змусить док-станцію Scene створити піктограму попередження "
"з рядком(ами) як спливаючу підказку вузлом. Це та сама піктограма, яка "
"з’являється для таких вузлів, як вузол :ref:`Area2D <class_Area2D>`, якщо "
"він не має визначених дочірніх вузлів :ref:`CollisionShape2D "
"<class_CollisionShape2D>`. Потім редактор самостійно документує сцену за "
"допомогою коду сценарію. Дублювання вмісту через документацію не потрібне."

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"Такий графічний інтерфейс може краще інформувати користувачів проєкту про "
"критичну інформацію про Вузол. Чи є у нього зовнішні залежності? Чи були "
"задоволені ці залежності? Іншим програмістам, а особливо дизайнерам і "
"авторам, у повідомленнях будуть потрібні чіткі інструкції, які "
"вказуватимуть, що робити для його налаштування."

msgid ""
"So, why does all this complex switcheroo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class, and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely affecting other classes dependent on it."
msgstr ""
"Отже, чому весь цей складний switcheroo працює? Ну, тому що сцени працюють "
"найкраще, коли вони працюють поодинці. Якщо ви не можете працювати поодинці, "
"тоді найкраще працювати з іншими анонімно (з мінімальними жорсткими "
"залежностями, тобто слабким зв’язком). Неминуче може знадобитися внести "
"зміни в клас, і якщо ці зміни спричинять його непередбачувану взаємодію з "
"іншими сценами, тоді все почне ламатися. Суть усього цього непрямого напряму "
"полягає в тому, щоб уникнути ситуації, коли зміна одного класу призведе до "
"негативного впливу на інші залежні від нього класи."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"Скрипти та сцени, як продовження класів движка, повинні дотримуватися *всіх* "
"принципів ООП. Приклади включають ..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://uk.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://uk.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr ""
"`KISS <https://uk.wikipedia.org/wiki/"
"%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%C2%ABKISS%C2%BB>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr ""
"`YAGNI <https://uk.wikipedia.org/wiki/"
"%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_YAGNI>`_"

msgid "Choosing a node tree structure"
msgstr "Вибір дерева структури вузла"

msgid ""
"You might start to work on a game but get overwhelmed by the vast "
"possibilities before you. You might know what you want to do, what systems "
"you want to have, but *where* do you put them all? How you go about making "
"your game is always up to you. You can construct node trees in countless "
"ways. If you are unsure, this guide can give you a sample of a decent "
"structure to start with."
msgstr ""
"Ви можете почати працювати над грою, але бути приголомшеними величезними "
"можливостями, які відкриваються перед вами. Можливо, ви знаєте, що хочете "
"робити, які системи хочете мати, але *куди* їх усі розмістити? Як ви будете "
"створювати свою гру, завжди залежить від вас. Ви можете будувати дерева "
"вузлів незліченною кількістю способів. Якщо ви не впевнені, цей посібник "
"може дати вам зразок пристойної структури для початку."

msgid ""
"A game should always have an \"entry point\"; somewhere you can definitively "
"track where things begin so that you can follow the logic as it continues "
"elsewhere. It also serves as a bird's eye view of all other data and logic "
"in the program. For traditional applications, this is normally a \"main\" "
"function. In Godot, it's a Main node."
msgstr ""
"Гра завжди повинна мати «точку входу»; десь ви можете остаточно відстежити, "
"з чого все починається, щоб ви могли слідкувати за логікою, як це "
"продовжується в інших місцях. Він також служить для перегляду з висоти "
"пташиного польоту всіх інших даних і логіки в програмі. Для традиційних "
"програм це зазвичай «основна» функція. У Godot це головний вузол."

msgid "Node \"Main\" (main.gd)"
msgstr "Вузол \"Main\" (main.gd)"

msgid ""
"The ``main.gd`` script will serve as the primary controller of your game."
msgstr "Скрипт ``main.gd`` слугуватиме основним контролером вашої гри."

msgid ""
"Then you have an in-game \"World\" (a 2D or 3D one). This can be a child of "
"Main. In addition, you will need a primary GUI for your game that manages "
"the various menus and widgets the project needs."
msgstr ""
"Тоді у вас є внутрішньоігровий «Світ» (2D або 3D). Це може бути дочірній "
"елемент Main. Крім того, вам знадобиться основний графічний інтерфейс для "
"вашої гри, який керує різними меню та віджетами, потрібними проекту."

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D \"Світ\" (game_world.gd)"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Керування \"GUI\" (gui.gd)"

msgid ""
"When changing levels, you can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives you "
"full control over how your game world transitions."
msgstr ""
"Змінюючи рівні, ви можете поміняти дочірні елементи вузла "
"«Світ». :ref:`Changing scenes manually <doc_change_scenes_manually>` дає вам "
"повний контроль над тим, як ваш ігровий світ змінюється."

msgid ""
"The next step is to consider what gameplay systems your project requires. If "
"you have a system that..."
msgstr ""
"Наступний крок — розглянути, які ігрові системи потрібні вашому проекту. "
"Якщо у вас є система, яка..."

msgid "tracks all of its data internally"
msgstr "відстежує всі свої дані зсередини"

msgid "should be globally accessible"
msgstr "має бути доступною глобально"

msgid "should exist in isolation"
msgstr "може існувати ізольовано"

msgid ""
"... then you should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"... то вам слід створити :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method to swap out the main "
"scene's content. This structure more or less keeps the \"World\" as the main "
"game node."
msgstr ""
"Для невеликих ігор простішою альтернативою з меншим контролем буде синглтон "
"\"Game\", який просто викликає метод :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>`, щоб замінити вміст головної "
"сцени. Ця структура більш-менш зберігає \"Світ\" як основний вузол гри."

msgid ""
"Any GUI would also need to be either a singleton, a transitory part of the "
"\"World\", or manually added as a direct child of the root. Otherwise, the "
"GUI nodes would also delete themselves during scene transitions."
msgstr ""
"Будь-який графічний інтерфейс також повинен бути або єдиним елементом, "
"тимчасовою частиною \"Світу\", або доданим вручну як прямий дочірній елемент "
"кореня. Інакше вузли графічного інтерфейсу також видалятимуться під час "
"переходів між сценами."

msgid ""
"If you have systems that modify other systems' data, you should define those "
"as their own scripts or scenes, rather than autoloads. For more information, "
"see :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>`."
msgstr ""
"Якщо у вас є системи, які змінюють дані інших систем, вам слід визначити їх "
"як власні сценарії або сцени, а не як автозавантаження. Для отримання "
"додаткової інформації див. :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>`."

msgid ""
"Each subsystem within your game should have its own section within the "
"SceneTree. You should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that the children should also be removed? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"Кожна підсистема у вашій грі повинна мати власний розділ у SceneTree. "
"Відносини «батьки-нащадки» слід використовувати лише у випадках, коли вузли "
"фактично є елементами своїх батьків. Чи розумно вилучення батьків означає, "
"що діти також повинні бути вилучені? Якщо ні, то він повинен мати власне "
"місце в ієрархії як рідний брат або інший родич."

msgid ""
"In some cases, you need these separated nodes to *also* position themselves "
"relative to each other. You can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"У деяких випадках вам потрібно, щоб ці розділені вузли *також* "
"розташовувалися відносно один одного. Для цього можна використовувати "
"вузли :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>`. Вони дозволять цільовому вузлу умовно "
"успадковувати вибрані елементи перетворення від вузла Remote\\*. Щоб "
"призначити ``target`` :ref:`NodePath <class_NodePath>`, скористайтеся одним "
"із наступного:"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr ""
"Надійну третю сторону, ймовірно, батьківський вузол, який буде посередником "
"у призначенні."

msgid ""
"A group, to pull a reference to the desired node (assuming there will only "
"ever be one of the targets)."
msgstr ""
"Група, щоб отримати посилання на потрібний вузол (припускаючи, що завжди "
"буде лише одна ціль)."

msgid ""
"When you should do this is subjective. The dilemma arises when you must "
"micro-manage when a node must move around the SceneTree to preserve itself. "
"For example..."
msgstr ""
"Коли ви повинні це зробити, суб’єктивно. Дилема виникає, коли вам потрібно "
"мікрокерувати, коли вузол повинен рухатися навколо SceneTree, щоб зберегти "
"себе. наприклад..."

msgid "Add a \"player\" node to a \"room\"."
msgstr "Додайте вузол \"player\" до \"room\"."

msgid "Need to change rooms, so you must delete the current room."
msgstr "Необхідно змінити кімнати, тому ви повинні видалити поточну кімнату."

msgid ""
"Before the room can be deleted, you must preserve and/or move the player."
msgstr ""
"Перш ніж кімнату можна буде видалити, ви повинні зберегти та/або перемістити "
"гравця."

msgid "If memory is not a concern, you can..."
msgstr "Якщо пам’ять не турбує, ви можете..."

msgid "Create the new room."
msgstr "Створіть нову кімнату."

msgid "Move the player to the new room."
msgstr "Перемістіть гравця в нову кімнату."

msgid "Delete the old room."
msgstr "Видалити стару кімнату."

msgid "If memory is a concern, instead you will need to..."
msgstr "Якщо пам’ять викликає занепокоєння, замість цього вам потрібно буде..."

msgid "Move the player somewhere else in the tree."
msgstr "Перемістити гравця ще кудись на дереві."

msgid "Delete the room."
msgstr "Видалити кімнату."

msgid "Instantiate and add the new room."
msgstr "Створити і додати нову кімнату."

msgid "Re-add the player to the new room."
msgstr "Повторно додайте гравця до нової кімнати."

msgid ""
"The issue is that the player here is a \"special case\" where the developers "
"must *know* that they need to handle the player this way for the project. "
"The only way to reliably share this information as a team is to *document* "
"it. Keeping implementation details in documentation is dangerous. It's a "
"maintenance burden, strains code readability, and unnecessarily bloats the "
"intellectual content of a project."
msgstr ""
"Проблема полягає в тому, що програвач тут є «особливим випадком», коли "
"розробники повинні *знати*, що вони повинні обробляти програвач таким чином "
"для проекту. Єдиний спосіб надійно поділитися цією інформацією в команді — "
"*задокументувати* її. Зберігати деталі реалізації в документації небезпечно. "
"Це тягар обслуговування, погіршує читабельність коду та надмірно роздуває "
"інтелектуальний вміст проекту."

msgid ""
"In a more complex game with larger assets, it can be a better idea to keep "
"the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"У складнішій грі з більшими активами краще залишити гравця в іншому місці "
"SceneTree. Це призводить до:"

msgid "More consistency."
msgstr "Більшої послідовності."

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr ""
"Ніяких \"особливих випадків\", які потрібно десь задокументувати та "
"підтримувати."

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "Уникнення помилок, оскільки ці деталі не враховуються."

msgid ""
"In contrast, if you ever need a child node that does *not* inherit the "
"transform of its parent, you have the following options:"
msgstr ""
"Навпаки, якщо вам колись знадобиться дочірній вузол, який *не* успадковує "
"перетворення свого батьківського, у вас є такі варіанти:"

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. Since it doesn't have a transform, they won't pass this information to "
"its children."
msgstr ""
"**Декларативне** рішення: помістіть :ref:`Node <class_Node>` між ними. "
"Оскільки він не має перетворення, вони не передадуть цю інформацію своїм "
"нащадкам."

msgid ""
"The **imperative** solution: Use the ``top_level`` property for "
"the :ref:`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"Імперативне рішення: Використовуйте властивість ``top_level`` для "
"вузла :ref:`CanvasItem <class_CanvasItem_property_top_level>` "
"або :ref:`Node3D <class_Node3D_property_top_level>`. Це змусить вузол "
"ігнорувати успадковане перетворення."

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic - they only need their own. Keeping them in a "
"separate branch from the \"world\" can help simplify the management of game "
"connections and the like."
msgstr ""
"Створюючи мережеву гру, майте на увазі, які вузли та ігрові системи "
"стосуються всіх гравців, а не ті, що стосуються лише авторитетного сервера. "
"Наприклад, не всім користувачам потрібно мати копію логіки "
"«PlayerController» кожного гравця — їм потрібна лише власна. Зберігання їх в "
"окремій гілці від «світу» може допомогти спростити керування підключеннями "
"до гри тощо."

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"Ключ до організації сцени - розглядати Дерево Сцени в реляційних термінах, а "
"не просторових. Чи залежать вузли від існування предків? Якщо ні, то вони "
"можуть процвітати самі десь в іншому місці. Якщо вони залежать, то цілком "
"зрозуміло, що вони повинні бути нащадками цього предка (і, можливо, частиною "
"сцени цього предка, якщо вони ще не є такими)."

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"you still have the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"Чи означає це, що самі вузли є компонентами? Зовсім ні. Дерева вузлів Godot "
"формують зв’язок агрегації, а не композиції. Але хоча ви все ще маєте "
"можливість переміщати вузли, усе одно найкраще, коли такі переміщення за "
"замовчуванням непотрібні."
