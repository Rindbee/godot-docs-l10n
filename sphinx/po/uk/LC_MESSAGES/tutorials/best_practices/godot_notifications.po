#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Godot notifications"
msgstr "Сповіщення Godot"

msgid ""
"Every Object in Godot implements a :ref:`_notification "
"<class_Object_private_method__notification>` method. Its purpose is to allow "
"the Object to respond to a variety of engine-level callbacks that may relate "
"to it. For example, if the engine tells a :ref:`CanvasItem "
"<class_CanvasItem>` to \"draw\", it will call "
"``_notification(NOTIFICATION_DRAW)``."
msgstr ""
"Кожен об’єкт у Godot реалізує метод :ref:`_notification "
"<class_Object_private_method__notification>`. Його мета — дозволити Об’єкту "
"реагувати на різноманітність зворотних викликів на рівні двигуна, які можуть "
"бути пов’язані з ним. Наприклад, якщо механізм каже :ref:`CanvasItem "
"<class_CanvasItem>` «малювати», він викличе "
"``_notification(NOTIFICATION_DRAW)``."

msgid ""
"Some of these notifications, like draw, are useful to override in scripts. "
"So much so that Godot exposes many of them with dedicated functions:"
msgstr ""
"Деякі з цих сповіщень, наприклад, малювання (draw), корисно замінити у "
"скриптах. Настільки, що Godot поставляє багатьох із них зі спеціальними "
"функціями:"

msgid "``_ready()``: ``NOTIFICATION_READY``"
msgstr "``_ready()``: ``ПОВІДОМЛЕННЯ_ГОТОВЕ``"

msgid "``_enter_tree()``: ``NOTIFICATION_ENTER_TREE``"
msgstr "``_enter_tree()``: ``NOTIFICATION_ENTER_TREE``"

msgid "``_exit_tree()``: ``NOTIFICATION_EXIT_TREE``"
msgstr "``_exit_tree()`` : ДЕРЕВО_ВИХОДУ_ПОВІДОМЛЕННЯ"

msgid "``_process(delta)``: ``NOTIFICATION_PROCESS``"
msgstr "``_process(delta)`` : ПРОЦЕС_ПОВІДОМЛЕННЯ"

msgid "``_physics_process(delta)``: ``NOTIFICATION_PHYSICS_PROCESS``"
msgstr "``_physics_process(delta)``: ``ПОВІДОМЛЕННЯ_ФІЗИЧНОГО_ПРОЦЕСУ``"

msgid "``_draw()``: ``NOTIFICATION_DRAW``"
msgstr "``_draw()`` : ПОВІДОМЛЕННЯ"

msgid ""
"What users might *not* realize is that notifications exist for types other "
"than Node alone, for example:"
msgstr ""
"Користувачі можуть *не* розуміти, що сповіщення існують і для інших типів, "
"окрім, наприклад, Node:"

msgid ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: a callback that "
"triggers during object initialization. Not accessible to scripts."
msgstr ""
":ref:`Object::NOTIFICATION_POSTINITIALIZE "
"<class_Object_constant_NOTIFICATION_POSTINITIALIZE>`: зворотний виклик, який "
"спрацьовує під час ініціалізації об’єкта. Не доступний для скриптів."

msgid ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: a callback that triggers "
"before the engine deletes an Object, i.e. a \"destructor\"."
msgstr ""
":ref:`Object::NOTIFICATION_PREDELETE "
"<class_Object_constant_NOTIFICATION_PREDELETE>`: зворотний виклик, який "
"спрацьовує перед тим, як рушій видалить об'єкт, тобто \"деструктор\"."

msgid ""
"And many of the callbacks that *do* exist in Nodes don't have any dedicated "
"methods, but are still quite useful."
msgstr ""
"І багато зворотних викликів, які *існують* у вузлах, не мають спеціальних "
"методів, але все ще є досить корисними."

msgid ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: a callback that triggers "
"anytime one adds a child node to another node."
msgstr ""
":ref:`Node::NOTIFICATION_PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`: зворотний виклик, який "
"запускається щоразу, коли один додає дочірній вузол до іншого вузла."

msgid ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: a callback that triggers "
"anytime one removes a child node from another node."
msgstr ""
":ref:`Node::NOTIFICATION_UNPARENTED "
"<class_Node_constant_NOTIFICATION_UNPARENTED>`: зворотний виклик, який "
"запускається в будь-який час, коли один видаляє дочірній вузол з іншого "
"вузла."

msgid ""
"One can access all these custom notifications from the universal "
"``_notification()`` method."
msgstr ""
"Доступ до всіх цих кастомних сповіщень можна отримати за допомогою "
"універсального методу ``_notification()``."

msgid ""
"Methods in the documentation labeled as \"virtual\" are also intended to be "
"overridden by scripts."
msgstr ""
"Методи в документації, позначені як \"virtual\" *(віртуальні)*, також "
"призначені для перевизначення у скриптах."

msgid ""
"A classic example is the :ref:`_init <class_Object_private_method__init>` "
"method in Object. While it has no ``NOTIFICATION_*`` equivalent, the engine "
"still calls the method. Most languages (except C#) rely on it as a "
"constructor."
msgstr ""
"Класичним прикладом є метод :ref:`_init <class_Object_private_method__init>` "
"в Object. Хоча він не має еквівалента ``NOTIFICATION_*``, рушій все одно "
"викликає цей метод. Більшість мов (крім C#) використовують його як "
"конструктор."

msgid ""
"So, in which situation should one use each of these notifications or virtual "
"functions?"
msgstr ""
"Отже, в якій ситуації слід використовувати кожне з цих сповіщень або "
"віртуальні функції?"

msgid "_process vs. _physics_process vs. \\*_input"
msgstr "_process та _physics_process vs. \\*_input"

msgid ""
"Use ``_process()`` when one needs a framerate-dependent delta time between "
"frames. If code that updates object data needs to update as often as "
"possible, this is the right place. Recurring logic checks and data caching "
"often execute here, but it comes down to the frequency at which one needs "
"the evaluations to update. If they don't need to execute every frame, then "
"implementing a Timer-timeout loop is another option."
msgstr ""
"Використовуйте ``_process()``, коли потрібен дельта-час між кадрами, що "
"залежить від частоти кадрів. Якщо код, який оновлює дані об’єкта, потребує "
"оновлення якомога частіше, це правильне місце. Тут часто виконуються "
"регулярні перевірки логіки та кешування даних, але це зводиться до частоти, "
"з якою потрібно оновлювати оцінки. Якщо їм не потрібно виконувати кожен "
"кадр, то ще одним варіантом є реалізація циклу тайм-ауту."

msgid ""
"Use ``_physics_process()`` when one needs a framerate-independent delta time "
"between frames. If code needs consistent updates over time, regardless of "
"how fast or slow time advances, this is the right place. Recurring kinematic "
"and object transform operations should execute here."
msgstr ""
"Використовуйте ``_physics_process()``, коли потрібен дельта-час між кадрами, "
"не залежний від частоти кадрів. Якщо код потребує постійного оновлення з "
"часом, незалежно від того, наскільки швидко чи повільно просувається час, це "
"правильне місце. Тут повинні виконуватися повторювані кінематичні операції "
"та операції перетворення об’єктів."

msgid ""
"While it is possible, to achieve the best performance, one should avoid "
"making input checks during these callbacks. ``_process()`` and "
"``_physics_process()`` will trigger at every opportunity (they do not "
"\"rest\" by default). In contrast, ``*_input()`` callbacks will trigger only "
"on frames in which the engine has actually detected the input."
msgstr ""
"Хоча це можливо, щоб досягти найкращої продуктивності, слід уникати "
"перевірки введення під час цих зворотних викликів. ``_process()`` і "
"``_physics_process()`` запускатимуться при кожній нагоді (вони не "
"«відпочивають» за замовчуванням). На відміну від цього, зворотні виклики "
"``*_input()`` запускатимуться лише на кадрах, у яких механізм фактично "
"виявив введення."

msgid ""
"One can check for input actions within the input callbacks just the same. If "
"one wants to use delta time, one can fetch it from the related delta time "
"methods as needed."
msgstr ""
"Так само можна перевірити дії введення в зворотних викликах введення. Якщо "
"потрібно використовувати дельта-час, його можна отримати за потреби з "
"відповідних методів дельта-часу."

msgid "_init vs. initialization vs. export"
msgstr "_init, initialization та export"

msgid ""
"If the script initializes its own node subtree, without a scene, that code "
"should execute in ``_init()``. Other property or SceneTree-independent "
"initializations should also run here."
msgstr ""
"Якщо сценарій ініціалізує власне піддерево вузлів без сцени, цей код має "
"виконуватися в ``_init()``. Інші властивості або незалежні від SceneTree "
"ініціалізації також повинні виконуватися тут."

msgid "The C# equivalent to GDScript's ``_init()`` method is the constructor."
msgstr "Конструктором є еквівалент C# методу ``_init()`` GDScript."

msgid ""
"``_init()`` triggers before ``_enter_tree()`` or ``_ready()``, but after a "
"script creates and initializes its properties. When instantiating a scene, "
"property values will set up according to the following sequence:"
msgstr ""
"``_init()`` запускається перед ``_enter_tree()`` або ``_ready()``, але після "
"того, як сценарій створює та ініціалізує свої властивості. Під час створення "
"екземпляра сцени значення властивостей буде встановлено відповідно до такої "
"послідовності:"

msgid ""
"**Initial value assignment:** the property is assigned its initialization "
"value, or its default value if one is not specified. If a setter exists, it "
"is not used."
msgstr ""
"**Початкове призначення значення:** властивості присвоюється значення "
"ініціалізації або значення за замовчуванням, якщо воно не вказано. Якщо "
"сеттер існує, він не використовується."

msgid ""
"``_init()`` **assignment:** the property's value is replaced by any "
"assignments made in ``_init()``, triggering the setter."
msgstr ""
"``_init()`` **присвоєння:** значення властивості замінюється будь-якими "
"призначеннями, зробленими в ``_init()``, що запускає установщик."

msgid ""
"**Exported value assignment:** an exported property's value is again "
"replaced by any value set in the Inspector, triggering the setter."
msgstr ""
"**Експортоване призначення значення:** значення експортованої властивості "
"знову замінюється будь-яким значенням, установленим в інспекторі, що "
"запускає установщик."

msgid ""
"As a result, instantiating a script versus a scene may affect both the "
"initialization *and* the number of times the engine calls the setter."
msgstr ""
"Як наслідок, створення екземпляра сценарію проти сцени може вплинути як на "
"ініціалізацію *та* на кількість викликів механізму налаштування."

msgid "_ready vs. _enter_tree vs. NOTIFICATION_PARENTED"
msgstr "_ready, _enter_tree та NOTIFICATION_PARENTED"

msgid ""
"When instantiating a scene connected to the first executed scene, Godot will "
"instantiate nodes down the tree (making ``_init()`` calls) and build the "
"tree going downwards from the root. This causes ``_enter_tree()`` calls to "
"cascade down the tree. Once the tree is complete, leaf nodes call "
"``_ready``. A node will call this method once all child nodes have finished "
"calling theirs. This then causes a reverse cascade going up back to the "
"tree's root."
msgstr ""
"Під час створення екземпляра сцени, пов’язаної з першою виконаною сценою, "
"Godot створюватиме екземпляри вузлів вниз по дереву (здійснюючи виклики "
"``_init()``) і створюватиме дерево вниз від кореня. Це спричиняє каскад "
"викликів ``_enter_tree()`` вниз по дереву. Після завершення дерева листові "
"вузли викликають ``_ready``. Вузол викличе цей метод, коли всі дочірні вузли "
"завершать виклик своїх. Потім це викликає зворотний каскад, що йде вгору до "
"кореня дерева."

msgid ""
"When instantiating a script or a standalone scene, nodes are not added to "
"the SceneTree upon creation, so no ``_enter_tree()`` callbacks trigger. "
"Instead, only the ``_init()`` call occurs. When the scene is added to the "
"SceneTree, the ``_enter_tree()`` and ``_ready()`` calls occur."
msgstr ""
"Під час створення екземпляра сценарію або окремої сцени вузли не додаються "
"до SceneTree після створення, тому зворотні виклики ``_enter_tree()`` не "
"запускаються. Замість цього відбувається лише виклик ``_init()``. Коли сцену "
"додають до SceneTree, відбуваються виклики ``_enter_tree()`` і ``_ready()``."

msgid ""
"If one needs to trigger behavior that occurs as nodes parent to another, "
"regardless of whether it occurs as part of the main/active scene or not, one "
"can use the :ref:`PARENTED <class_Node_constant_NOTIFICATION_PARENTED>` "
"notification. For example, here is a snippet that connects a node's method "
"to a custom signal on the parent node without failing. Useful on data-"
"centric nodes that one might create at runtime."
msgstr ""
"Якщо потрібно ініціювати поведінку, яка виникає як поведінка батьківського "
"вузла до іншого, незалежно від того, відбувається вона як частина основної/"
"активної сцени чи ні, можна використовувати сповіщення :ref:`PARENTED "
"<class_Node_constant_NOTIFICATION_PARENTED>`. Наприклад, ось фрагмент, який "
"підключає метод вузла до користувацького сигналу на батьківському вузлі без "
"збоїв. Корисно для вузлів, орієнтованих на дані, які можна створити під час "
"виконання."
