#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "When and how to avoid using nodes for everything"
msgstr "Коли і як уникати використання вузлів для всього"

msgid ""
"Nodes are cheap to produce, but even they have their limits. A project may "
"have tens of thousands of nodes all doing things. The more complex their "
"behavior though, the larger the strain each one adds to a project's "
"performance."
msgstr ""
"Вузли дешеві у виробництві, але навіть вони мають свої межі. Проєкт може "
"мати десятки тисяч вузлів, які все роблять. Чим складнішою є їх поведінка, "
"тим більше напруження кожен з них додає до проєкту."

msgid ""
"Godot provides more lightweight objects for creating APIs which nodes use. "
"Be sure to keep these in mind as options when designing how you wish to "
"build your project's features."
msgstr ""
"Godot забезпечує легкіші об'єкти для створення API, які використовують "
"вузли. Обов’язково пам’ятайте про них, як про варіанти, під час розробки "
"функцій свого проєкту."

msgid ""
":ref:`Object <class_Object>`: The ultimate lightweight object, the original "
"Object must use manual memory management. With that said, it isn't too "
"difficult to create one's own custom data structures, even node structures, "
"that are also lighter than the :ref:`Node <class_Node>` class."
msgstr ""
":ref:`Об'єкт <class_Object>`: Самий легкий об'єкт, оригінальний Об'єкт "
"повинен використовувати ручне управління пам'яттю. З огляду на це, не надто "
"складно створити свої власні структури даних, навіть структури вузлів, які "
"також легші за клас :ref:`Вузла <class_Node>`."

msgid ""
"**Example:** See the :ref:`Tree <class_Tree>` node. It supports a high level "
"of customization for a table of content with an arbitrary number of rows and "
"columns. The data that it uses to generate its visualization though is "
"actually a tree of :ref:`TreeItem <class_TreeItem>` Objects."
msgstr ""
"**Зразок**: Дивіться вузол :ref:`Дерево<class_Tree>`. Він підтримує високий "
"рівень налаштування змісту із довільною кількістю рядків і стовпців. Дані, "
"які він використовує для створення своєї візуалізації, насправді є деревом "
"об'єктів :ref:`TreeItem <class_TreeItem>`."

msgid ""
"**Advantages:** Simplifying one's API to smaller scoped objects helps "
"improve its accessibility and improve iteration time. Rather than working "
"with the entire Node library, one creates an abbreviated set of Objects from "
"which a node can generate and manage the appropriate sub-nodes."
msgstr ""
"**Переваги:** Спрощення власного API для об’єктів меншого масштабу допомагає "
"покращити його доступність і покращити час ітерації. Замість того, щоб "
"працювати з усією бібліотекою Вузлів, ви створюєте скорочений набір "
"Об’єктів, з яких вузол може генерувати та управляти відповідними під-вузлами."

msgid ""
"One should be careful when handling them. One can store an Object into a "
"variable, but these references can become invalid without warning. For "
"example, if the object's creator decides to delete it out of nowhere, this "
"would trigger an error state when one next accesses it."
msgstr ""
"Потрібно бути обережним при поводженні з ними. Можна зберегти об’єкт у "
"змінній, але ці посилання без попередження можуть стати недійсними. "
"Наприклад, якщо творець об’єкта вирішить видалити його з нізвідки, це "
"спричинить стан помилки, при наступній спробі отримати доступ до нього."

msgid ""
":ref:`RefCounted <class_RefCounted>`: Only a little more complex than "
"Object. They track references to themselves, only deleting loaded memory "
"when no further references to themselves exist. These are useful in the "
"majority of cases where one needs data in a custom class."
msgstr ""
":ref:`RefCounted <class_RefCounted>`: Тільки трохи складніше, ніж Object. "
"Вони відстежують посилання на себе, видаляючи завантажену пам’ять лише тоді, "
"коли ні існують інші посилання на себе. Це корисно в більшості випадків, "
"коли потрібні дані в спеціальному класі."

msgid ""
"**Example:** See the :ref:`FileAccess <class_FileAccess>` object. It "
"functions just like a regular Object except that one need not delete it "
"themselves."
msgstr ""
"**Приклад:** Перегляньте об’єкт :ref:`FileAccess <class_FileAccess>`. Він "
"функціонує так само, як звичайний об’єкт, за винятком того, що його не "
"потрібно видаляти самостійно."

msgid "**Advantages:** same as the Object."
msgstr "** Переваги: ** ті самі, що і в Об'єкта."

msgid ""
":ref:`Resource <class_Resource>`: Only slightly more complex than "
"RefCounted. They have the innate ability to serialize/deserialize (i.e. save "
"and load) their object properties to/from Godot resource files."
msgstr ""
":ref:`Resource <class_Resource>`: Лише трохи складніше, ніж RefCounted. Вони "
"мають вроджену здатність серіалізувати/десеріалізувати (тобто зберігати та "
"завантажувати) свої властивості об’єктів до/з файлів ресурсів Godot."

msgid ""
"**Example:** Scripts, PackedScene (for scene files), and other types like "
"each of the :ref:`AudioEffect <class_AudioEffect>` classes. Each of these "
"can be saved and loaded, therefore they extend from Resource."
msgstr ""
"**Приклад:** Сценарії, PackedScene (для файлів сцен) та інші типи, такі як "
"кожен із класів :ref:`AudioEffect <class_AudioEffect>`. Кожне з них можна "
"зберегти та завантажити, тому вони поширюються з Resource."

msgid ""
"**Advantages:** Much has :ref:`already been said <doc_resources>` on :ref:"
"`Resource <class_Resource>`'s advantages over traditional data storage "
"methods. In the context of using Resources over Nodes though, their main "
"advantage is in Inspector-compatibility. While nearly as lightweight as "
"Object/RefCounted, they can still display and export properties in the "
"Inspector. This allows them to fulfill a purpose much like sub-Nodes on the "
"usability front, but also improve performance if one plans to have many such "
"Resources/Nodes in their scenes."
msgstr ""
"**Переваги:** Багато :ref:`already been said <doc_resources>` про переваги :"
"ref:`Resource <class_Resource>` над традиційними даними способи зберігання. "
"Однак у контексті використання Resources over Nodes їх головною перевагою є "
"сумісність з Inspector. Хоча майже така ж легка, як Object/RefCounted, вони "
"все ще можуть відображати та експортувати властивості в інспекторі. Це "
"дозволяє їм виконувати завдання, схожі на підвузли щодо зручності "
"використання, але також підвищити продуктивність, якщо планується мати "
"багато таких ресурсів/вузлів у своїх сценах."
