#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Playing videos"
msgstr "Відтворення відео"

msgid ""
"Godot supports video playback with the :ref:`class_VideoStreamPlayer` node."
msgstr ""
"Godot підтримує відтворення відео за допомогою вузла :ref:"
"`class_VideoStreamPlayer`."

msgid "Supported playback formats"
msgstr "Підтримувані формати відтворення"

msgid ""
"The only supported format in core is **Ogg Theora** (not to be confused with "
"Ogg Vorbis audio). It's possible for extensions to bring support for "
"additional formats, but no such extensions exist yet as of July 2022."
msgstr ""
"Єдиним підтримуваним форматом в ядрі є **Ogg Theora** (не плутати з Ogg "
"Vorbis audio). Розширення можуть додавати підтримку додаткових форматів, але "
"станом на липень 2022 року таких розширень ще не існує."

msgid ""
"H.264 and H.265 cannot be supported in core Godot, as they are both "
"encumbered by software patents. AV1 is royalty-free, but it remains slow to "
"decode on the CPU and hardware decoding support isn't readily available on "
"all GPUs in use yet."
msgstr ""
"H.264 і H.265 не підтримуються в ядрі Godot, оскільки обидва вони обтяжені "
"патентами на програмне забезпечення. AV1 не потребує ліцензійних "
"відрахувань, але він повільно декодується на CPU, а апаратна підтримка "
"декодування поки що доступна не на всіх графічних процесорах, що "
"використовуються."

msgid ""
"WebM was supported in core in Godot 3.x, but support for it was removed in "
"4.0 as it was too buggy and difficult to maintain."
msgstr ""
"WebM підтримувався в основному в Godot 3.x, але його підтримку було вилучено "
"в 4.0, оскільки він був надто глюковим і важким у підтримці."

msgid ""
"You may find videos with an ``.ogg`` or ``.ogx`` extensions, which are "
"generic extensions for data within an Ogg container."
msgstr ""
"Ви можете знайти відео з розширеннями ``.ogg`` або ``.ogx``, які є "
"загальними розширеннями даних у контейнері Ogg."

msgid ""
"Renaming these file extensions to ``.ogv`` *may* allow the videos to be "
"imported in Godot. However, not all files with ``.ogg`` or ``.ogx`` "
"extensions are videos - some of them may only contain audio."
msgstr ""
"Перейменування цих розширень на ``.ogv`` *може* дозволити імпортувати відео "
"до Godot. Однак не всі файли з розширеннями ``.ogg`` або ``.ogx`` є відео - "
"деякі з них можуть містити лише аудіо."

msgid "Setting up VideoStreamPlayer"
msgstr "Налаштування VideoStreamPlayer"

msgid "Create a VideoStreamPlayer node using the Create New Node dialog."
msgstr ""
"Створіть вузол VideoStreamPlayer за допомогою діалогового вікна «Створити "
"новий вузол»."

msgid ""
"Select the VideoStreamPlayer node in the scene tree dock, go to the "
"inspector and load an ``.ogv`` file in the Stream property."
msgstr ""
"Виберіть вузол VideoStreamPlayer у доці дерева сцен, перейдіть до інспектора "
"та завантажте файл ``.ogv`` у властивості Stream."

msgid ""
"If you don't have your video in Ogg Theora format yet, jump to :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`."
msgstr ""
"Якщо у вас ще немає відео у форматі Ogg Theora, перейдіть за посиланням :ref:"
"`doc_playing_videos_recommended_theora_encoding_settings`."

msgid ""
"If you want the video to play as soon as the scene is loaded, check "
"**Autoplay** in the inspector. If not, leave **Autoplay** disabled and call "
"``play()`` on the VideoStreamPlayer node in a script to start playback when "
"desired."
msgstr ""
"“ ви хочете, щоб відео почало відтворюватися відразу після завантаження "
"сцени, встановіть галочку **Autoplay** в інспекторі. Якщо ні, залиште "
"**Autoplay** вимкненим і викличте ``play()`` на вузлі VideoPlayer у скрипті, "
"щоб почати відтворення по необхідності."

msgid "Handling resizing and different aspect ratios"
msgstr "Робота зі зміною розміру та різними співвідношеннями сторін"

msgid ""
"By default in Godot 4.0, the VideoStreamPlayer will automatically be resized "
"to match the video's resolution. You can make it follow usual :ref:"
"`class_Control` sizing by enabling **Expand** on the VideoStreamPlayer node."
msgstr ""
"За замовчуванням у Godot 4.0 розмір VideoStreamPlayer буде автоматично "
"змінено відповідно до роздільної здатності відео. Ви можете зробити так, щоб "
"він відповідав звичайному розміру :ref:`class_Control`, увімкнувши "
"**Expand** у вузлі VideoStreamPlayer."

msgid ""
"To adjust how the VideoStreamPlayer node resizes depending on window size, "
"adjust the anchors using the **Layout** menu at the top of the 2D editor "
"viewport. However, this setup may not be powerful enough to handle all use "
"cases, such as playing fullscreen videos without distorting the video (but "
"with empty space on the edges instead). For more control, you can use an :"
"ref:`class_AspectRatioContainer` node, which is designed to handle this kind "
"of use case:"
msgstr ""
"Щоб налаштувати спосіб зміни розміру вузла VideoStreamPlayer залежно від "
"розміру вікна, налаштуйте прив’язки за допомогою меню **Макет** у верхній "
"частині вікна перегляду 2D-редактора. Однак це налаштування може бути "
"недостатньо потужним, щоб впоратися з усіма випадками використання, як-от "
"відтворення повноекранного відео без спотворення відео (але замість цього з "
"порожнім простором по краях). Для більшого контролю ви можете "
"використовувати вузол :ref:`class_AspectRatioContainer`, який призначений "
"для обробки таких варіантів використання:"

msgid ""
"Add an AspectRatioContainer node. Make sure it is not a child of any other "
"container node. Select the AspectRatioContainer node, then set its "
"**Layout** at the top of the 2D editor to **Full Rect**. Set **Ratio** in "
"the AspectRatioContainer node to match your video's aspect ratio. You can "
"use math formulas in the inspector to help yourself. Remember to make one of "
"the operands a float. Otherwise, the division's result will always be an "
"integer."
msgstr ""
"Додайте вузол AspectRatioContainer. Переконайтеся, що він не є нащадком "
"іншого вузла контейнера. Виділіть вузол AspectRatioContainer, а потім "
"встановіть його **Макет** у верхній частині 2D-редактора на **Увесь "
"прямокутник**. Встановіть **Ratio** у вузлі AspectRatioContainer відповідно "
"до співвідношення сторін вашого відео. Ви можете використовувати математичні "
"формули в інспекторі, щоб допомогти собі. Не забудьте зробити один з "
"операндів десятковим. Інакше результат ділення завжди буде цілим числом."

msgid ""
"AspectRatioContainer's Ratio property being modified in the editor inspector"
msgstr ""
"Властивість Ratio вузла AspectRatioContainer змінюється в інспекторі "
"редактора"

msgid "This will evaluate to (approximately) 1.777778"
msgstr "Результат буде (приблизно) 1.777778"

msgid ""
"Once you've configured the AspectRatioContainer, reparent your "
"VideoStreamPlayer node to be a child of the AspectRatioContainer node. Make "
"sure **Expand** is enabled on the VideoStreamPlayer. Your video should now "
"scale automatically to fit the whole screen while avoiding distortion."
msgstr ""
"Після того, як ви налаштували AspectRatioContainer, повторно створіть свій "
"вузол VideoStreamPlayer, щоб він був дочірнім вузлом AspectRatioContainer. "
"Переконайтеся, що **Розгорнути** увімкнено у VideoStreamPlayer. Тепер ваше "
"відео має автоматично змінюватися на весь екран, уникаючи спотворень."

msgid ""
"See :ref:`doc_multiple_resolutions` for more tips on supporting multiple "
"aspect ratios in your project."
msgstr ""
"Дивіться :ref:`doc_multiple_resolutions` для отримання додаткових порад щодо "
"підтримки різних співвідношень сторін у вашому проекті."

msgid "Displaying a video on a 3D surface"
msgstr "Відображення відео на 3D-поверхні"

msgid ""
"Using a VideoStreamPlayer node as a child of a :ref:`class_SubViewport` "
"node, it's possible to display any 2D node on a 3D surface. For example, "
"this can be used to display animated billboards when frame-by-frame "
"animation would require too much memory."
msgstr ""
"Використовуючи вузол VideoStreamPlayer як дочірнього вузла :ref:"
"`class_SubViewport`, можна відобразити будь-який 2D-вузол на 3D-поверхні. "
"Наприклад, це можна використовувати для відображення анімованих рекламних "
"щитів, коли покадрова анімація вимагає забагато пам’яті."

msgid "This can be done with the following steps:"
msgstr "Це можна зробити за допомогою наступних кроків:"

msgid ""
"Create a :ref:`class_SubViewport` node. Set its size to match your video's "
"size in pixels."
msgstr ""
"Створіть вузол :ref:`class_SubViewport`. Установіть його розмір відповідно "
"до розміру вашого відео в пікселях."

msgid ""
"Create a VideoStreamPlayer node *as a child of the SubViewport node* and "
"specify a video path in it. Make sure **Expand** is disabled, and enable "
"**Autoplay** if needed."
msgstr ""
"Створіть вузол VideoStreamPlayer *як дочірній вузол SubViewport* і вкажіть у "
"ньому відеошлях. Переконайтеся, що **Розгорнути** вимкнено, і за потреби "
"увімкніть **Автовідтворення**."

msgid ""
"Create a MeshInstance3D node with a PlaneMesh or QuadMesh resource in its "
"Mesh property. Resize the mesh to match the video's aspect ratio (otherwise, "
"it will appear distorted)."
msgstr ""
"Створіть вузол MeshInstance3D із ресурсом PlaneMesh або QuadMesh у його "
"властивості Mesh. Змініть розмір сітки відповідно до формату відео (інакше "
"воно виглядатиме спотвореним)."

msgid ""
"Create a new StandardMaterial3D resource in the **Material Override** "
"property in the GeometryInstance3D section."
msgstr ""
"Створіть новий ресурс StandardMaterial3D у властивості **Material Override** "
"у розділі GeometryInstance3D."

msgid ""
"Enable **Local To Scene** in the StandardMaterial3D's Resource section (at "
"the bottom). This is *required* before you can use a ViewportTexture in its "
"Albedo Texture property."
msgstr ""
"Увімкніть **Local To Scene** у розділі ресурсів StandardMaterial3D (внизу). "
"Це *обов’язково* перед використанням ViewportTexture у властивості Albedo "
"Texture."

msgid ""
"In the StandardMaterial3D, set the **Albedo > Texture** property to **New "
"ViewportTexture**. Edit the new resource by clicking it, then specify the "
"path to the SubViewport node in the **Viewport Path** property."
msgstr ""
"У StandardMaterial3D встановіть для властивості **Albedo > Texture** "
"значення **New ViewportTexture**. Відредагуйте новий ресурс, клацнувши його, "
"а потім укажіть шлях до вузла SubViewport у властивості **Viewport Path**."

msgid ""
"Enable **Albedo Texture Force sRGB** in the StandardMaterial3D to prevent "
"colors from being washed out."
msgstr ""
"Увімкніть **Albedo Texture Force sRGB** у StandardMaterial3D, щоб запобігти "
"розмиванню кольорів."

msgid ""
"If the billboard is supposed to emit its own light, set **Shading Mode** to "
"**Unshaded** to improve rendering performance."
msgstr ""
"Якщо рекламний щит має випромінювати власне світло, встановіть для **Shading "
"Mode** значення **Unshaded**, щоб покращити продуктивність візуалізації."

msgid ""
"See :ref:`doc_viewports` and the `GUI in 3D demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d>`__ for more "
"information on setting this up."
msgstr ""
"Дивіться :ref:`doc_viewports` та демонстрацію графічного інтерфейсу `у 3D "
"<https://github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"gui_in_3d>`__ для отримання додаткової інформації про налаштування."

msgid "Looping a video"
msgstr "Зациклення відео"

msgid ""
"For looping a video, the **Loop** property can be enabled. This will "
"seamlessly restart the video when it reaches its end."
msgstr ""
"Для циклічного відтворення відео можна ввімкнути властивість **Loop**. Це "
"плавно перезапустить відео, коли воно досягне кінця."

msgid ""
"Note that setting the project setting **Video Delay Compensation** to a non-"
"zero value might cause your loop to not be seamless, because the "
"synchronization of audio and video takes place at the start of each loop "
"causing occasional missed frames. Set **Video Delay Compensation** in your "
"project settings to **0** to avoid frame drop issues."
msgstr ""
"Зауважте, що налаштування параметра проекту **Компенсація затримки відео** "
"на відмінне від нуля значення може призвести до того, що ваш цикл не буде "
"безперебійним, оскільки синхронізація аудіо та відео відбувається на початку "
"кожного циклу, спричиняючи випадкові пропуски кадрів. Встановіть "
"**Компенсацію затримки відео** в налаштуваннях проекту на **0**, щоб "
"уникнути проблем із пропуском кадрів."

msgid "Video decoding conditions and recommended resolutions"
msgstr "Умови декодування відео та рекомендована роздільна здатність"

msgid ""
"Video decoding is performed on the CPU, as GPUs don't have hardware "
"acceleration for decoding Theora videos. Modern desktop CPUs can decode Ogg "
"Theora videos at 1440p @ 60 FPS or more, but low-end mobile CPUs will likely "
"struggle with high-resolution videos."
msgstr ""
"Декодування відео виконується на центральному процесорі, оскільки графічні "
"процесори не мають апаратного прискорення для декодування відео Theora. "
"Сучасні настільні центральні процесори можуть декодувати відео Ogg Theora з "
"роздільною здатністю 1440p при 60 FPS або більше, але мобільні процесори "
"низького класу, швидше за все, не зможуть впоратися з відео високої "
"роздільної здатності."

msgid "To ensure your videos decode smoothly on varied hardware:"
msgstr "Щоб забезпечити плавне декодування ваших відео на різному обладнанні:"

msgid ""
"When developing games for desktop platforms, it's recommended to encode in "
"1080p at most (preferably at 30 FPS). Most people are still using 1080p or "
"lower resolution displays, so encoding higher-resolution videos may not be "
"worth the increased file size and CPU requirements."
msgstr ""
"При розробці ігор для настільних платформ рекомендується кодувати відео з "
"роздільною здатністю не вище 1080p (бажано з частотою 30 кадрів в секунду). "
"Більшість людей все ще використовують дисплеї з роздільною здатністю 1080p "
"або нижчою, тому кодування відео з вищою роздільною здатністю може бути не "
"варте збільшення розміру файлу та вимог до процесора."

msgid ""
"When developing games for mobile or web platforms, it's recommended to "
"encode in 720p at most (preferably at 30 FPS or even lower). The visual "
"difference between 720p and 1080p videos on a mobile device is usually not "
"that noticeable."
msgstr ""
"При розробці ігор для мобільних або веб-платформ рекомендується кодувати в "
"720p максимум (бажано з частотою 30 кадрів в секунду або навіть нижче). "
"Візуальна різниця між відео 720p і 1080p на мобільному пристрої зазвичай не "
"дуже помітна."

msgid "Playback limitations"
msgstr "Обмеження відтворення"

msgid ""
"There are several limitations with the current implementation of video "
"playback in Godot:"
msgstr "Існує кілька обмежень у поточній реалізації відтворення відео в Godot:"

msgid "Seeking a video to a certain point is not supported."
msgstr "Перегляд відео з певної точки не підтримується."

msgid ""
"Changing playback speed is not supported. VideoStreamPlayer also won't "
"follow :ref:`Engine.time_scale<class_Engine_property_time_scale>`."
msgstr ""
"Зміна швидкості відтворення не підтримується. VideoStreamPlayer також не "
"слідуватиме :ref:`Engine.time_scale<class_Engine_property_time_scale>`."

msgid "Streaming a video from a URL is not supported."
msgstr "Потокове відео з URL-адреси не підтримується."

msgid "Recommended Theora encoding settings"
msgstr "Рекомендовані параметри кодування Theora"

msgid ""
"A word of advice is to **avoid relying on built-in Ogg Theora exporters** "
"(most of the time). There are 2 reasons you may want to favor using an "
"external program to encode your video:"
msgstr ""
"Порада: **не покладайтеся на вбудовані експортери Ogg Theora** "
"(здебільшого). Є 2 причини, чому вам краще віддати перевагу зовнішній "
"програмі для кодування вашого відео:"

msgid ""
"Some programs such as Blender can render to Ogg Theora. However, the default "
"quality presets are usually very low by today's standards. You may be able "
"to increase the quality options in the software you're using, but you may "
"find the output quality to remain less than ideal (given the increased file "
"size). This usually means that the software only supports encoding to "
"constant bit rate (CBR), instead of variable bit rate (VBR). VBR encoding "
"should be preferred in most scenarios as it provides a better quality to "
"file size ratio."
msgstr ""
"Деякі програми, такі як Blender, можуть рендерити в Ogg Theora. Однак, "
"стандартні параметри якості за замовчуванням зазвичай дуже низькі за "
"сучасними стандартами. Ви можете збільшити параметри якості у програмному "
"забезпеченні, яке ви використовуєте, але ви можете виявити, що якість на "
"виході залишається не ідеальною (враховуючи збільшений розмір файлу). "
"Зазвичай це означає, що програмне забезпечення підтримує лише кодування з "
"постійним бітрейтом (CBR), а не зі змінним бітрейтом (VBR). У більшості "
"випадків слід надавати перевагу кодуванню VBR, оскільки воно забезпечує "
"краще співвідношення якості та розміру файлу."

msgid "Some other programs can't render to Ogg Theora at all."
msgstr "Деякі інші програми взагалі не можуть рендерити в Ogg Theora."

msgid ""
"In this case, you can **render the video to an intermediate high-quality "
"format** (such as a high-bitrate H.264 video) then re-encode it to Ogg "
"Theora. Ideally, you should use a lossless or uncompressed format as an "
"intermediate format to maximize the quality of the output Ogg Theora video, "
"but this can require a lot of disk space."
msgstr ""
"У цьому випадку ви можете **рендерити відео у проміжний високоякісний "
"формат** (наприклад, відео з високим бітрейтом H.264), а потім перекодувати "
"його в Ogg Theora. В ідеалі, вам слід використовувати формат без втрат або "
"без стиснення як проміжний формат, щоб максимізувати якість вихідного відео "
"Ogg Theora, але це може вимагати багато місця на диску."

msgid ""
"`HandBrake <https://handbrake.fr/>`__ (GUI) and `FFmpeg <https://ffmpeg.org/"
">`__ (CLI) are popular open source tools for this purpose. FFmpeg has a "
"steeper learning curve, but it's more powerful."
msgstr ""
"`HandBrake <https://handbrake.fr/>`__ (GUI) та `FFmpeg <https://ffmpeg.org/"
">`__ (CLI) - популярні інструменти з відкритим вихідним кодом для цієї мети. "
"FFmpeg має крутішу криву навчання, але він більш потужний."

msgid ""
"Here are example FFmpeg commands to convert an MP4 video to Ogg Theora. "
"Since FFmpeg supports a lot of input formats, you should be able to use the "
"commands below with almost any input video format (AVI, MOV, WebM, …)."
msgstr ""
"Ось приклади команд FFmpeg для перетворення відео MP4 на Ogg Theora. "
"Оскільки FFmpeg підтримує багато вхідних форматів, ви зможете "
"використовувати наведені нижче команди майже з будь-яким вхідним "
"відеоформатом (AVI, MOV, WebM, …)."

msgid ""
"Make sure your copy of FFmpeg is compiled with libtheora and libvorbis "
"support. You can check this by running ``ffmpeg`` without any arguments, "
"then looking at the ``configuration:`` line in the command output."
msgstr ""
"Переконайтеся, що вашу копію FFmpeg скомпільовано з підтримкою libtheora і "
"libvorbis. Ви можете перевірити це, виконавши команду ``ffmpeg`` без жодних "
"аргументів, а потім переглянувши рядок ``configuration:`` у виведенні "
"команди."

msgid "Balancing quality and file size"
msgstr "Баланс якості та розміру файлу"

msgid ""
"The **video quality** level (``-q:v``) must be between ``1`` and ``10``. "
"Quality ``6`` is a good compromise between quality and file size. If "
"encoding at a high resolution (such as 1440p or 4K), you will probably want "
"to decrease ``-q:v`` to ``5`` to keep file sizes reasonable. Since pixel "
"density is higher on a 1440p or 4K video, lower quality presets at higher "
"resolutions will look as good or better compared to low-resolution videos."
msgstr ""
"Рівень **якості відео** (``-q:v``) повинен бути між ``1`` і ``10``. Якість "
"``6`` є хорошим компромісом між якістю та розміром файлу. Якщо ви кодуєте з "
"високою роздільною здатністю (наприклад, 1440p або 4K), ви, ймовірно, "
"захочете зменшити ``-q:v`` до ``5``, щоб зберегти розмір файлу розумним. "
"Оскільки щільність пікселів у відео з роздільною здатністю 1440p, або 4K, "
"вища, пресети з нижчою якістю у вищій роздільній здатності виглядатимуть так "
"само добре, або навіть краще, ніж відео з низькою роздільною здатністю."

msgid ""
"The **audio quality** level (``-q:a``) must be between ``-1`` and ``10``. "
"Quality ``6`` provides a good compromise between quality and file size. In "
"contrast to video quality, increasing audio quality doesn't increase the "
"output file size nearly as much. Therefore, if you want the cleanest audio "
"possible, you can increase this to ``9`` to get *perceptually lossless* "
"audio. This is especially valuable if your input file already uses lossy "
"audio compression. Higher quality audio does increase the CPU usage of the "
"decoder, so it might lead to audio dropouts in case of high system load. See "
"`this page <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__ for a table "
"listing Ogg Vorbis audio quality presets and their respective variable "
"bitrates."
msgstr ""
"Рівень **якості аудіо** (``-q:a``) має бути між ``-1`` і ``10``. Якість "
"``6`` забезпечує хороший компроміс між якістю та розміром файлу. На відміну "
"від якості відео, підвищення якості звуку майже не збільшує розмір вихідного "
"файлу. Тому, якщо вам потрібен найчистіший звук, ви можете збільшити "
"значення до ``9``, щоб отримати звук *без втрат*. Це особливо цінно, якщо "
"ваш вхідний файл уже використовує стиснення звуку з втратами. Аудіо вищої "
"якості дійсно збільшує використання ЦП декодера, тому це може призвести до "
"випадання звуку в разі високого навантаження на систему. Перегляньте `цю "
"сторінку <https://wiki.hydrogenaud.io/index.php?"
"title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings>`__ для таблиці зі "
"списком попередніх налаштувань якості аудіо Ogg Vorbis і відповідних змінних "
"бітрейтів."

msgid "FFmpeg: Convert while preserving original video resolution"
msgstr "FFmpeg: Конвертуйте, зберігаючи оригінальну роздільну здатність відео"

msgid ""
"The following command converts the video while keeping its original "
"resolution. The video and audio's bitrate will be variable to maximize "
"quality while saving space in parts of the video/audio that don't require a "
"high bitrate (such as static scenes)."
msgstr ""
"Наступна команда конвертує відео зі збереженням початкової роздільної "
"здатності. Бітрейт відео та аудіо буде змінюватися, щоб максимізувати якість "
"і заощадити місце в тих частинах відео/аудіо, які не потребують високого "
"бітрейту (наприклад, статичні сцени)."

msgid "FFmpeg: Resize the video then convert it"
msgstr "FFmpeg: Змініть розмір відео, а потім конвертуйте його"

msgid ""
"The following command resizes a video to be 720 pixels tall (720p), while "
"preserving its existing aspect ratio. This helps decrease the file size "
"significantly if the source is recorded at a higher resolution than 720p:"
msgstr ""
"Наступна команда змінює розмір відео до 720 пікселів (720p) зі збереженням "
"існуючого співвідношення сторін. Це допомагає значно зменшити розмір файлу, "
"якщо джерело записано з вищою роздільною здатністю, ніж 720p:"

msgid "Chroma Key Videos"
msgstr "Відео Chroma Key"

msgid ""
"Chroma key, commonly known as the \"green screen\" or \"blue screen\" "
"effect, allows you to remove a specific color from an image or video and "
"replace it with another background. This effect is widely used in video "
"production to composite different elements together seamlessly."
msgstr ""
"Хроматичний ключ, широко відомий як ефект «зеленого екрану» або «синього "
"екрану», дозволяє видалити певний колір із зображення чи відео та замінити "
"його іншим фоном. Цей ефект широко використовується у відеовиробництві для "
"бездоганного поєднання різних елементів."

msgid ""
"We will achieve the chroma key effect by writing a custom shader in GDScript "
"and using a `VideoStreamPlayer` node to display the video content."
msgstr ""
"Ми досягнемо ефекту кольоровості, написавши спеціальний шейдер у GDScript і "
"використовуючи вузол VideoStreamPlayer для відображення відеовмісту."

msgid "Scene Setup"
msgstr "Налаштування сцени"

msgid ""
"Ensure that the scene contains a `VideoStreamPlayer` node to play the video "
"and a `Control` node to hold the UI elements for controlling the chroma key "
"effect."
msgstr ""
"Переконайтеся, що сцена містить вузол «VideoStreamPlayer» для відтворення "
"відео та вузол «Control» для зберігання елементів інтерфейсу користувача для "
"керування ефектом кольоровості."

msgid "Writing the Custom Shader"
msgstr "Написання спеціального шейдера"

msgid "To implement the chroma key effect, follow these steps:"
msgstr "Щоб реалізувати ефект кольоровості, виконайте такі дії:"

msgid ""
"Select the `VideoStreamPlayer` node in the scene and go to its properties. "
"Under `CanvasItem > Material`, create a new shader named \"ChromaKeyShader."
"gdshader.\""
msgstr ""
"Виберіть у сцені вузол VideoStreamPlayer і перейдіть до його властивостей. У "
"розділі «CanvasItem > Material» створіть новий шейдер під назвою "
"«ChromaKeyShader.gdshader»"

msgid ""
"In the \"ChromaKeyShader.gdshader\" file, write the custom shader code as "
"shown below:"
msgstr ""
"У файлі \"ChromaKeyShader.gdshader\" напишіть спеціальний код шейдера, як "
"показано нижче:"

msgid ""
"The shader uses the distance calculation to identify pixels close to the "
"chroma key color and discards them, effectively removing the selected color. "
"Pixels that are slightly further away from the chroma key color are faded "
"based on the fade_factor, blending them smoothly with the surrounding "
"colors. This process creates the desired chroma key effect, making it appear "
"as if the background has been replaced with another image or video."
msgstr ""
"Шейдер використовує обчислення відстані, щоб ідентифікувати пікселі, близькі "
"до кольору кольорового ключа, і відкидає їх, фактично видаляючи вибраний "
"колір. Пікселі, які знаходяться трохи далі від кольору ключа кольоровості, "
"зникають на основі fade_factor, плавно змішуючи їх із навколишніми "
"кольорами. Цей процес створює бажаний ефект кольоровості, створюючи "
"враження, ніби фон було замінено іншим зображенням або відео."

msgid ""
"The code above represents a simple demonstration of the Chroma Key shader, "
"and users can customize it according to their specific requirements."
msgstr ""
"Наведений вище код представляє просту демонстрацію шейдера Chroma Key, і "
"користувачі можуть налаштувати його відповідно до своїх конкретних вимог."

msgid "UI Controls"
msgstr "Елементи керування інтерфейсу користувача"

msgid ""
"To allow users to manipulate the chroma key effect in real-time, we created "
"sliders in the `Control` node. The `Control` node's script contains the "
"following functions:"
msgstr ""
"Щоб дозволити користувачам маніпулювати ефектом кольоровості в режимі "
"реального часу, ми створили повзунки у вузлі «Керування». Сценарій вузла "
"`Control` містить такі функції:"

msgid ""
"also make sure that the range of the sliders are appropriate, our settings "
"are :"
msgstr ""
"також переконайтеся, що діапазон повзунків є відповідним, наші налаштування:"

msgid "Signal Handling"
msgstr "Обробка сигналів"

msgid ""
"Connect the appropriate signal from the UI elements to the `Control` node's "
"script. you created in the `Control` node's script to control the chroma key "
"effect. These signal handlers will update the shader's uniform variables in "
"response to user input."
msgstr ""
"Підключіть відповідний сигнал від елементів UI до сценарію вузла `Control`. "
"ви створили у сценарії вузла `Control` для керування ефектом кольоровості. "
"Ці обробники сигналів оновлюватимуть уніфіковані змінні шейдера у відповідь "
"на введення користувача."

msgid ""
"Save and run the scene to see the chroma key effect in action! With the "
"provided UI controls, you can now adjust the chroma key color, pickup range, "
"and fade amount in real-time, achieving the desired chroma key functionality "
"for your video content."
msgstr ""
"Збережіть і запустіть сцену, щоб побачити ефект кольоровості в дії! За "
"допомогою наданих елементів керування користувальницького інтерфейсу тепер "
"ви можете регулювати колір ключа кольоровості, діапазон звукозапису та "
"ступінь затухання в режимі реального часу, досягаючи бажаної "
"функціональності ключа кольоровості для свого відеовмісту."
