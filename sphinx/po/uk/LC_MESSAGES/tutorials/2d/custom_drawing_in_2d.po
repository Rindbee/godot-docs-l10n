#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "Власне малювання в 2D"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, text, and many other "
"common game development needs. However, if you need something specific not "
"covered with the standard nodes you can make any 2D node (for example, :ref:"
"`Control <class_Control>` or :ref:`Node2D <class_Node2D>`-based) draw on "
"screen using custom commands."
msgstr ""
"Godot має вузли для малювання спрайтів, багатокутників, частинок, тексту та "
"багатьох інших поширених потреб для розробки ігор. Однак, якщо вам потрібно "
"щось конкретне, не охоплене стандартними вузлами, ви можете змусити будь-"
"який 2D-вузол (наприклад, :ref:`Control <class_Control>` або :ref:`Node2D "
"<class_Node2D>`-базований) малювати на екрані за допомогою спеціальних "
"команди."

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr ""
"Власне малювання в 2D вузлах *дійсно* корисне. Ось деякі випадки "
"використання:"

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"Малювання фігур, або логіки, які не можуть зробити існуючі вузли, наприклад, "
"зображення зі слідами, або спеціальний анімований багатокутник."

msgid ""
"Drawing a large number of simple objects, such as a grid or a board for a 2d "
"game. Custom drawing avoids the overhead of using a large number of nodes, "
"possibly lowering memory usage and improving performance."
msgstr ""
"Малювання великої кількості простих об'єктів, таких як сітка або дошка для "
"двовимірної гри. Настроюване креслення дозволяє уникнути накладних витрат на "
"використання великої кількості вузлів, можливо, зменшуючи використання "
"пам’яті та покращуючи продуктивність."

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr ""
"Створення власного елемента керування інтерфейсом користувача. Доступно "
"багато елементів керування, але коли у вас є незвичайні потреби, вам, "
"ймовірно, знадобиться власний контроль."

msgid "Drawing"
msgstr "Малюнок"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, like :"
"ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then override "
"the :ref:`_draw()<class_CanvasItem_private_method__draw>` function."
msgstr ""
"Додайте сценарій до будь-якого похідного вузла :ref:`CanvasItem "
"<class_CanvasItem>`, наприклад :ref:`Control <class_Control>` або :ref:"
"`Node2D <class_Node2D>`. Потім замініть функцію :ref:"
"`_draw()<class_CanvasItem_private_method__draw>`."

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them and we will see some of them in "
"the examples below."
msgstr ""
"Команди малювання описані в довідці про клас :ref:`CanvasItem "
"<class_CanvasItem>`. Їх багато, і ми побачимо деякі з них у прикладах нижче."

msgid "Updating"
msgstr "Оновлення"

msgid ""
"The :ref:`_draw <class_CanvasItem_private_method__draw>` function is only "
"called once, and then the draw commands are cached and remembered, so "
"further calls are unnecessary."
msgstr ""
"Функція :ref:`_draw <class_CanvasItem_private_method__draw>` викликається "
"лише один раз, а потім команди малювання кешуються та запам’ятовуються, тому "
"подальші виклики непотрібні."

msgid ""
"If re-drawing is required because a variable or something else changed, "
"call :ref:`CanvasItem.queue_redraw <class_CanvasItem_method_queue_redraw>` "
"in that same node and a new ``_draw()`` call will happen."
msgstr ""
"Якщо потрібне повторне малювання через зміну змінної або щось інше, "
"викличте :ref:`CanvasItem.queue_redraw "
"<class_CanvasItem_method_queue_redraw>` у тому самому вузлі, і відбудеться "
"новий виклик ``_draw()``."

msgid ""
"Here is a little more complex example, where we have a texture variable that "
"can be modified at any time, and using a :ref:"
"`setter<doc_gdscript_basics_setters_getters>`, it forces a redraw of the "
"texture when modified:"
msgstr ""
"Ось трохи складніший приклад, де у нас є змінна текстури, яку можна змінити "
"в будь-який час, і використовуючи :ref:"
"`setter<doc_gdscript_basics_setters_getters>`, вона примусово перемальовує "
"текстуру під час зміни:"

msgid ""
"To see it in action, you can set the texture to be the Godot icon on the "
"editor by dragging and dropping the default ``icon.svg`` from the "
"``FileSystem`` tab to the Texture property on the ``Inspector`` tab. When "
"changing the ``Texture`` property value while the previous script is "
"running, the texture will also change automatically."
msgstr ""
"Щоб побачити це в дії, ви можете встановити текстуру як піктограму Годо в "
"редакторі, перетягнувши стандартний файл ``icon.svg`` із вкладки ``Файлова "
"система`` у властивість Текстура ``Інспектора` вкладка `. Якщо змінити "
"значення властивості ``Texture`` під час роботи попереднього сценарію, "
"текстура також зміниться автоматично."

msgid ""
"In some cases, we may need to redraw every frame. For this, call :ref:"
"`queue_redraw <class_CanvasItem_method_queue_redraw>` from the :ref:"
"`_process <class_Node_private_method__process>` method, like this:"
msgstr ""
"У деяких випадках може знадобитися перемалювати кожен кадр. Для цього "
"викличте :ref:`queue_redraw <class_CanvasItem_method_queue_redraw>` з "
"методу :ref:`_process <class_Node_private_method__process>`, ось так:"

msgid "Coordinates and line width alignment"
msgstr "Вирівнювання координат і ширини лінії"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. This means ``_draw()`` uses the coordinate space created "
"after applying the CanvasItem's transform. Additionally, you can apply a "
"custom transform on top of it by using :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` or :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"API малювання використовує систему координат CanvasItem, не обов’язково "
"піксельні координати. Це означає, що ``_draw()`` використовує простір "
"координат, створений після застосування перетворення CanvasItem. Крім того, "
"ви можете застосувати спеціальне перетворення поверх нього за допомогою :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` або :ref:"
"`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."

msgid ""
"When using :ref:`draw_line <class_CanvasItem_method_draw_line>`, you should "
"consider the width of the line. When using a width that is an odd size, the "
"position of the start and end points should be shifted by ``0.5`` to keep "
"the line centered, as shown below."
msgstr ""
"Використовуючи :ref:`draw_line <class_CanvasItem_method_draw_line>`, слід "
"враховувати ширину лінії. Якщо використовується ширина непарного розміру, "
"положення початкової та кінцевої точок має бути зміщено на ``0,5``, щоб "
"зберегти лінію по центру, як показано нижче."

msgid ""
"The same applies to the :ref:`draw_rect <class_CanvasItem_method_draw_rect>` "
"method with ``filled = false``."
msgstr ""
"Те саме стосується методу :ref:`draw_rect "
"<class_CanvasItem_method_draw_rect>` із ``filled = false``."

msgid "Antialiased drawing"
msgstr "Згладжування"

msgid ""
"Godot offers method parameters in :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` to enable antialiasing, but "
"not all custom drawing methods offer this ``antialiased`` parameter."
msgstr ""
"Godot пропонує параметри методу в :ref:"
"`draw_line<class_CanvasItem_method_draw_line>` для ввімкнення згладжування, "
"але не всі спеціальні методи малювання пропонують цей параметр "
"``antialiased``."

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"Для спеціальних методів малювання, які не забезпечують параметр "
"``antialiased``, ви можете натомість увімкнути 2D MSAA, що впливає на "
"рендеринг у всьому вікні перегляду. Це забезпечує високоякісне згладжування, "
"але вищу вартість продуктивності та лише для певних елементів. Перегляньте :"
"ref:`doc_2d_antialiasing` для отримання додаткової інформації."

msgid ""
"Here is a comparison of a line of minimal width (``width=-1``) drawn with "
"``antialiased=false``, ``antialiased=true``, and ``antialiased=false`` with "
"2D MSAA 2x, 4x, and 8x enabled."
msgstr ""
"Ось порівняння лінії мінімальної ширини (``width=-1``), намальованої за "
"допомогою ``antialiased=false``, ``antialiased=true`` і "
"``antialiased=false`` з 2D MSAA 2x , 4x і 8x увімкнено."

msgid "Tools"
msgstr "Інструменти"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior."
msgstr ""
"Також може знадобитися малювати власні вузли під час їх запуску в редакторі. "
"Це можна використовувати як попередній перегляд або візуалізацію певної "
"функції чи поведінки."

msgid ""
"To do this, you can use the :ref:`tool annotation<doc_gdscript_tool_mode>` "
"on both GDScript and C#. See :ref:`the example "
"below<doc_draw_show_drawing_while_editing_example>` and :ref:"
"`doc_running_code_in_the_editor` for more information."
msgstr ""
"Для цього ви можете використати :ref:`tool "
"annotation<doc_gdscript_tool_mode>` як на GDScript, так і на C#. "
"Перегляньте :ref:`приклад "
"нижче<doc_draw_show_drawing_while_editing_example>` та :ref:"
"`doc_running_code_in_the_editor` для отримання додаткової інформації."

msgid "Example 1: drawing a custom shape"
msgstr "Приклад 1: малювання нестандартної форми"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. We will recreate the "
"Godot logo but with code- only using drawing functions."
msgstr ""
"Тепер ми скористаємося спеціальними функціями малювання Godot Engine, щоб "
"намалювати щось, для чого Godot не надає функцій. Ми відтворимо логотип "
"Godot, але з кодом, лише за допомогою функцій малювання."

msgid "You will have to code a function to perform this and draw it yourself."
msgstr ""
"Вам доведеться закодувати функцію, щоб виконати це, і намалювати її "
"самостійно."

msgid "Drawing a custom polygon shape"
msgstr "Малювання спеціальної багатокутної форми"

msgid ""
"While there is a dedicated node to draw custom polygons ( :ref:`Polygon2D "
"<class_Polygon2D>`), we will use in this case exclusively lower level "
"drawing functions to combine them on the same node and be able to create "
"more complex shapes later on."
msgstr ""
"Хоча існує спеціальний вузол для малювання власних багатокутників ( :ref:"
"`Polygon2D <class_Polygon2D>`), у цьому випадку ми будемо використовувати "
"функції малювання виключно нижчого рівня, щоб об’єднати їх на одному вузлі "
"та мати можливість створювати більш складні форми пізніше."

msgid ""
"First, we will define a set of points -or X and Y coordinates- that will "
"form the base of our shape:"
msgstr ""
"Спочатку ми визначимо набір точок або координат X і Y, які будуть формувати "
"основу нашої форми:"

msgid ""
"This format, while compact, is not the one that Godot understands to draw a "
"polygon. In a different scenario we could have to load these coordinates "
"from a file or calculate the positions while the application is running, so "
"some transformation may be needed."
msgstr ""
"Цей формат, хоч і компактний, не є тим, який Годо розуміє для малювання "
"багатокутника. В іншому сценарії нам може знадобитися завантажити ці "
"координати з файлу або обчислити положення під час роботи програми, тому "
"може знадобитися певне перетворення."

msgid ""
"To transform these coordinates into the right format, we will create a new "
"method ``float_array_to_Vector2Array()``. Then we will override the "
"``_ready()`` function, which Godot will call only once -at the start of the "
"execution- to load those coordinates into a variable:"
msgstr ""
"Щоб перетворити ці координати в правильний формат, ми створимо новий метод "
"``float_array_to_Vector2Array()``. Тоді ми замінимо функцію ``_ready()``, "
"яку Годо викличе лише один раз - на початку виконання, щоб завантажити ці "
"координати в змінну:"

msgid ""
"To finally draw our first shape, we will use the method :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>` and pass the points (as an array of "
"Vector2 coordinates) and its color, like this:"
msgstr ""
"Щоб нарешті намалювати нашу першу фігуру, ми використаємо метод :ref:"
"`draw_polygon <class_CanvasItem_method_draw_polygon>` і передамо точки (як "
"масив координат Vector2) і їх колір, як це:"

msgid "When running it you should see something like this:"
msgstr "Під час запуску ви повинні побачити щось на зразок цього:"

msgid ""
"Note the lower part of the logo looks segmented- this is because a low "
"amount of points were used to define that part. To simulate a smooth curve, "
"we could add more points to our array, or maybe use a mathematical function "
"to interpolate a curve and create a smooth shape from code (see :ref:"
"`example 2<doc_draw_custom_example_2>`)."
msgstr ""
"Зверніть увагу, що нижня частина логотипу виглядає сегментованою – це тому, "
"що для визначення цієї частини було використано низьку кількість точок. Щоб "
"імітувати плавну криву, ми могли б додати більше точок до нашого масиву або, "
"можливо, використати математичну функцію для інтерполяції кривої та "
"створення плавної форми з коду (див. :ref:`приклад "
"2<doc_draw_custom_example_2>`)."

msgid ""
"Polygons will always **connect its last defined point to its first one** in "
"order to have a closed shape."
msgstr ""
"Багатокутники завжди **з’єднуватимуть свою останню визначену точку з "
"першою**, щоб мати закриту форму."

msgid "Drawing connected lines"
msgstr "Малювання сполучних ліній"

msgid ""
"Drawing a sequence of connected lines that don't close down to form a "
"polygon is very similar to the previous method. We will use a connected set "
"of lines to draw Godot's logo mouth."
msgstr ""
"Малювання послідовності з’єднаних ліній, які не замикаються, утворюючи "
"багатокутник, дуже схоже на попередній метод. Ми використаємо зв’язаний "
"набір ліній, щоб намалювати рот логотипа Годо."

msgid ""
"First, we will define the list of coordinates that form the mouth shape, "
"like this:"
msgstr ""
"Спочатку ми визначимо список координат, які формують форму рота, ось так:"

msgid ""
"We will load these coordinates into a variable and define an additional "
"variable with the configurable line thickness:"
msgstr ""
"Ми завантажимо ці координати в змінну та визначимо додаткову змінну з "
"настроюваною товщиною лінії:"

msgid ""
"And finally we will use the method :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>` to actually draw the line, like "
"this:"
msgstr ""
"І, нарешті, ми використаємо метод :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>`, щоб фактично намалювати лінію, ось "
"так:"

msgid "You should get the following output:"
msgstr "Ви маєте отримати наступний результат:"

msgid ""
"The order of the ``_draw`` calls is important- like with the Node positions "
"on the tree hierarchy, the different shapes will be drawn from top to "
"bottom, resulting in the latest shapes hiding earlier ones if they overlap. "
"In this case we want the mouth drawn over the head, so we put it afterwards."
msgstr ""
"Порядок викликів ``_draw`` важливий — як і у випадку з позиціями Node в "
"ієрархії дерева, різні фігури малюватимуться зверху вниз, у результаті чого "
"останні фігури приховують попередні, якщо вони накладаються. У цьому випадку "
"ми хочемо, щоб рот був намальований над головою, тому ми розміщуємо його "
"пізніше."

msgid ""
"Notice how we can define colors in different ways, either with a hexadecimal "
"code or a predefined color name. Check the class :ref:`Color <class_Color>` "
"for other constants and ways to define Colors."
msgstr ""
"Зверніть увагу, як ми можемо визначати кольори різними способами, або за "
"допомогою шістнадцяткового коду, або попередньо визначеної назви кольору. "
"Перевірте клас :ref:`Color <class_Color>` для інших констант і способів "
"визначення кольорів."

msgid "Drawing circles"
msgstr "Малювання кіл"

msgid ""
"To create the eyes, we are going to add 4 additional calls to draw the eye "
"shapes, in different sizes, colors and positions."
msgstr ""
"Щоб створити очі, ми збираємося додати 4 додаткові виклики для малювання "
"форм очей різних розмірів, кольорів і позицій."

msgid ""
"To draw a circle, you position it based on its center using the :ref:"
"`draw_circle <class_CanvasItem_method_draw_circle>` method. The first "
"parameter is a :ref:`Vector2<class_Vector2>` with the coordinates of its "
"center, the second is its radius, and the third is its color:"
msgstr ""
"Щоб намалювати коло, ви розташовуєте його на основі його центру за допомогою "
"методу :ref:`draw_circle <class_CanvasItem_method_draw_circle>`. Перший "
"параметр — це :ref:`Vector2<class_Vector2>` з координатами його центру, "
"другий — його радіус, а третій — його колір:"

msgid "When executing it, you should have something like this:"
msgstr "Під час його виконання ви повинні мати щось на зразок цього:"

msgid ""
"For partial, unfilled arcs (portions of a circle shape between certain "
"arbitrary angles), you can use the method :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."
msgstr ""
"Для часткових незаповнених дуг (частин форми кола між певними довільними "
"кутами) ви можете використовувати метод :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."

msgid "Drawing lines"
msgstr "Малювання ліній"

msgid ""
"To draw the final shape (the nose) we will use a line to approximate it."
msgstr ""
"Щоб намалювати остаточну форму (ніс), ми використаємо лінію, щоб наблизити "
"її."

msgid ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` can be used to draw a "
"single segment by providing its start and end coordinates as arguments, like "
"this:"
msgstr ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` можна використовувати, "
"щоб намалювати один сегмент, надавши його початкову та кінцеву координати як "
"аргументи, наприклад:"

msgid "You should now be able to see the following shape on screen:"
msgstr "Тепер ви зможете побачити на екрані таку форму:"

msgid ""
"Note that if multiple unconnected lines are going to be drawn at the same "
"time, you may get additional performance by drawing all of them in a single "
"call, using the :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` method."
msgstr ""
"Зауважте, що якщо кілька незв’язаних ліній малюватимуться одночасно, ви "
"можете отримати додаткову продуктивність, намалювавши їх усі за один виклик "
"за допомогою методу :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>`."

msgid "Drawing text"
msgstr "Малювання тексту"

msgid ""
"We will use the :ref:`draw_string <class_CanvasItem_method_draw_string>` "
"method to do it, like this:"
msgstr ""
"Для цього ми використаємо метод :ref:`draw_string "
"<class_CanvasItem_method_draw_string>`, наприклад:"

msgid ""
"Here we first load into the defaultFont variable the configured default "
"theme font (a custom one can be set instead) and then we pass the following "
"parameters: font, position, text, horizontal alignment, width, and font size."
msgstr ""
"Тут ми спочатку завантажуємо в змінну defaultFont налаштований шрифт теми за "
"замовчуванням (замість нього можна встановити спеціальний), а потім "
"передаємо наступні параметри: шрифт, положення, текст, горизонтальне "
"вирівнювання, ширину та розмір шрифту."

msgid "You should see the following on your screen:"
msgstr "Ви повинні побачити на екрані наступне:"

msgid ""
"Additional parameters as well as other methods related to text and "
"characters can be found on the :ref:`CanvasItem <class_CanvasItem>` class "
"reference."
msgstr ""
"Додаткові параметри, а також інші методи, пов’язані з текстом і символами, "
"можна знайти в довідці про клас :ref:`CanvasItem <class_CanvasItem>`."

msgid "Show the drawing while editing"
msgstr "Показувати малюнок під час редагування"

msgid ""
"While the code so far is able to draw the logo on a running window, it will "
"not show up on the ``2D view`` on the editor. In certain cases you would "
"also like to show your custom Node2D or control on the editor, to position "
"and scale it appropriately, like most other nodes do."
msgstr ""
"Хоча код наразі може намалювати логотип у запущеному вікні, він не "
"відображатиметься у ``2D-виді`` редактора. У деяких випадках ви також "
"бажаєте показати свій власний Node2D або елемент керування в редакторі, щоб "
"розташувати та масштабувати його належним чином, як це робить більшість "
"інших вузлів."

msgid ""
"To show the logo directly on the editor (without running it), you can use "
"the :ref:`@tool<doc_gdscript_tool_mode>` annotation to request the custom "
"drawing of the node to also appear while editing, like this:"
msgstr ""
"Щоб показати логотип безпосередньо в редакторі (не запускаючи його), ви "
"можете використати анотацію :ref:`@tool<doc_gdscript_tool_mode>`, щоб "
"надіслати запит на те, щоб настроюваний малюнок вузла також з’являвся під "
"час редагування, ось так:"

msgid ""
"You will need to save your scene, rebuild your project (for C# only) and "
"reload the current scene manually at the menu option ``Scene > Reload Saved "
"Scene`` to refresh the current node in the ``2D`` view the first time you "
"add or remove the ``@tool`` annotation."
msgstr ""
"Вам потрібно буде зберегти свою сцену, перебудувати проект (тільки для C#) і "
"перезавантажити поточну сцену вручну за допомогою пункту меню ``Сцена > "
"Перезавантажити збережену сцену``, щоб оновити поточний вузол у ``2D`` "
"перегляді спочатку коли ви додаєте або видаляєте анотацію ``@tool``."

msgid "Animation"
msgstr "Анімація"

msgid ""
"If we wanted to make the custom shape change at runtime, we could modify the "
"methods called or its arguments at execution time, or apply a transform."
msgstr ""
"Якщо ми хочемо змінити власну форму під час виконання, ми можемо змінити "
"викликані методи або їх аргументи під час виконання, або застосувати "
"перетворення."

msgid ""
"For example, if we want the custom shape we just designed to rotate, we "
"could add the following variable and code to the ``_ready`` and ``_process`` "
"methods:"
msgstr ""
"Наприклад, якщо ми хочемо, щоб власна форма, яку ми щойно створили, "
"оберталася, ми можемо додати таку змінну та код до методів ``_ready`` і "
"``_process``:"

msgid ""
"The problem with the above code is that because we have created the points "
"approximately on a rectangle starting from the upper left corner, the ``(0, "
"0)`` coordinate and extending to the right and down, we see that the "
"rotation is done using the top left corner as pivot. A position transform "
"change on the node won't help us here, as the rotation transform is applied "
"first."
msgstr ""
"Проблема з наведеним вище кодом полягає в тому, що оскільки ми створили "
"точки приблизно на прямокутнику, починаючи з верхнього лівого кута, "
"координати ``(0, 0)`` і простягаючись праворуч і вниз, ми бачимо, що "
"обертання виконано за допомогою верхнього лівого кута як опори. Зміна "
"трансформації позиції на вузлі не допоможе нам тут, оскільки спочатку "
"застосовується трансформація обертання."

msgid ""
"While we could rewrite all of the points' coordinates to be centered around "
"``(0, 0)``, including negative coordinates, that would be a lot of work."
msgstr ""
"Хоча ми могли б переписати всі координати точок, щоб вони були зосереджені "
"навколо ``(0, 0)``, включно з від’ємними координатами, це було б дуже "
"складно."

msgid ""
"One possible way to work around this is to use the lower level :ref:"
"`draw_set_transform<class_CanvasItem_method_draw_set_transform>` method to "
"fix this issue, translating all points in the CanvasItem's own space, and "
"then moving it back to its original place with a regular node transform, "
"either in the editor or in code, like this:"
msgstr ""
"Одним із можливих способів обійти це є використання методу нижнього рівня :"
"ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` для "
"усунення цієї проблеми, перекладаючи всі точки у власному просторі "
"CanvasItem, а потім переміщуючи його назад у вихідне місце за допомогою "
"звичайного вузла перетворення, або в редакторі, або в коді, як це:"

msgid "This is the result, rotating around a pivot now on ``(60, 60)``:"
msgstr "Це результат обертання навколо опорної точки на ``(60, 60)``:"

msgid ""
"If what we wanted to animate was a property inside the ``_draw()`` call, we "
"must remember to call ``queue_redraw()`` to force a refresh, as otherwise it "
"would not be updated on screen."
msgstr ""
"Якщо те, що ми хочемо анімувати, було властивістю всередині виклику "
"``_draw()``, ми повинні не забувати викликати ``queue_redraw()``, щоб "
"примусово оновити, інакше воно не буде оновлено на екрані."

msgid ""
"For example, this is how we can make the robot appear to open and close its "
"mouth, by changing the width of its mouth line follow a sinusoidal (:ref:"
"`sin<class_@globalscope_method_sin>`) curve:"
msgstr ""
"Наприклад, ось як ми можемо зробити так, щоб робот відкривав і закривав рот, "
"змінюючи ширину його лінії рота відповідно до синусоїдальної (:ref:"
"`sin<class_@globalscope_method_sin>`) кривої:"

msgid "It will look somewhat like this when run:"
msgstr "При запуску це виглядатиме приблизно так:"

msgid "Example 2: drawing a dynamic line"
msgstr "Приклад 2: малювання динамічної лінії"

msgid ""
"The previous example was useful to learn how to draw and modify nodes with "
"custom shapes and animations. This could have some advantages, such as using "
"exact coordinates and vectors for drawing, rather than bitmaps -which means "
"they will scale well when transformed on screen. In some cases, similar "
"results could be achieved composing higher level functionality with nodes "
"such as :ref:`sprites<class_Sprite2D>` or :ref:"
"`AnimatedSprites<class_AnimatedSprite2D>` loading SVG resources (which are "
"also images defined with vectors) and the :ref:"
"`AnimationPlayer<class_AnimationPlayer>` node."
msgstr ""
"Попередній приклад був корисним, щоб навчитися малювати та змінювати вузли "
"за допомогою власних форм і анімації. Це може мати деякі переваги, наприклад "
"використання точних координат і векторів для малювання замість растрових "
"зображень, що означає, що вони добре масштабуються під час трансформації на "
"екрані. У деяких випадках подібних результатів можна досягти, створивши "
"функціональні можливості вищого рівня з такими вузлами, як :ref:"
"`sprites<class_Sprite2D>` або :ref:"
"`AnimatedSprites<class_AnimatedSprite2D>`, завантажуючи ресурси SVG (які "
"також є зображеннями, визначеними за допомогою векторів) і :ref:"
"`AnimationPlayer<class_AnimationPlayer>` вузол."

msgid ""
"In other cases that will not be possible because we will not know what the "
"resulting graphical representation will be before running the code. Here we "
"will see how to draw a dynamic line whose coordinates are not known "
"beforehand, and are affected by the user's input."
msgstr ""
"В інших випадках це буде неможливо, оскільки ми не будемо знати, яким буде "
"кінцеве графічне представлення до запуску коду. Тут ми побачимо, як "
"намалювати динамічну лінію, координати якої невідомі заздалегідь і на які "
"впливає введення користувача."

msgid "Drawing a straight line between 2 points"
msgstr "Проведення прямої між 2 точками"

msgid ""
"Let's assume we want to draw a straight line between 2 points, the first one "
"will be fixed on the upper left corner ``(0, 0)`` and the second will be "
"defined by the cursor position on screen."
msgstr ""
"Припустімо, що ми хочемо намалювати пряму лінію між 2 точками, перша з яких "
"буде зафіксована у верхньому лівому куті ``(0, 0)``, а друга буде визначена "
"позицією курсора на екрані."

msgid "We could draw a dynamic line between those 2 points like this:"
msgstr "Ми могли б провести динамічну лінію між цими двома точками так:"

msgid ""
"In this example we obtain the position of the mouse in the default viewport "
"every frame with the method :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. If the position has changed "
"since the last draw request (a small optimization to avoid redrawing on "
"every frame)- we will schedule a redraw. Our ``_draw()`` method only has one "
"line: requesting the drawing of a green line of width 10 pixels between the "
"top left corner and that obtained position."
msgstr ""
"У цьому прикладі ми отримуємо положення миші у вікні перегляду за "
"замовчуванням у кожному кадрі за допомогою методу :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. Якщо позиція змінилася з "
"моменту останнього запиту на розіграш (невелика оптимізація, щоб уникнути "
"перемальовування кожного кадру), ми заплануємо перемальовування. Наш метод "
"``_draw()`` має лише один рядок: запит на малювання зеленої лінії шириною 10 "
"пікселів між верхнім лівим кутом і отриманою позицією."

msgid ""
"The width, color, and position of the starting point can be configured with "
"with the corresponding properties."
msgstr ""
"Ширину, колір і положення початкової точки можна налаштувати за допомогою "
"відповідних властивостей."

msgid "It should look like this when run:"
msgstr "Під час запуску це має виглядати так:"

msgid "Drawing an arc between 2 points"
msgstr "Проведення дуги між 2 точками"

msgid ""
"The above example works, but we may want to join those 2 points with a "
"different shape or function, other than a straight line."
msgstr ""
"Наведений вище приклад працює, але ми можемо захотіти з’єднати ці 2 точки з "
"іншою формою або функцією, відмінною від прямої лінії."

msgid ""
"Let's try now creating an arc (a portion of a circumference) between both "
"points."
msgstr ""
"Давайте спробуємо створити дугу (частину окружності) між обома точками."

msgid ""
"Exporting the line starting point, segments, width, color, and antialiasing "
"will allow us to modify those properties very easily directly from the "
"editor inspector panel:"
msgstr ""
"Експорт початкової точки лінії, сегментів, ширини, кольору та згладжування "
"дозволить нам дуже легко змінювати ці властивості безпосередньо з панелі "
"інспектора редактора:"

msgid ""
"To draw the arc, we can use the method :ref:"
"`draw_arc<class_CanvasItem_method_draw_arc>`. There are many arcs that pass "
"through 2 points, so we will chose for this example the semicircle that has "
"its center in the middle point between the 2 initial points."
msgstr ""
"Щоб намалювати дугу, ми можемо використати метод :ref:"
"`draw_arc<class_CanvasItem_method_draw_arc>`. Є багато дуг, які проходять "
"через 2 точки, тому ми виберемо для цього прикладу півколо, центр якого "
"знаходиться в середній точці між 2 початковими точками."

msgid "Calculating this arc will be more complex than in the case of the line:"
msgstr "Розрахунок цієї дуги буде складнішим, ніж у випадку лінії:"

msgid ""
"The center of the semicircle will be the middle point between both points. "
"The radius will be half the distance between both points. The start and end "
"angles will be the angles of the vector from point1 to point2 and vice-"
"versa. Note we had to normalize the ``end_angle`` in positive values because "
"if ``end_angle`` is less than ``start_angle``, the arc will be drawn counter-"
"clockwise, which we don't want in this case (the arc would be upside-down)."
msgstr ""
"Центр півкола буде серединою між обома точками. Радіус буде дорівнювати "
"половині відстані між обома точками. Початковий і кінцевий кути будуть "
"кутами вектора від точки1 до точки2 і навпаки. Зауважте, що нам довелося "
"нормалізувати ``end_angle`` у додатних значеннях, оскільки якщо "
"``end_angle`` менший за ``start_angle``, дуга буде намальована проти "
"годинникової стрілки, чого ми не хочемо в цьому випадку ( дуга буде "
"перевернута)."

msgid ""
"The result should be something like this, with the arc going down and "
"between the points:"
msgstr ""
"У результаті має вийти щось на кшталт цього з дугою вниз і між точками:"

msgid ""
"Feel free to play with the parameters in the inspector to obtain different "
"results: change the color, the width, the antialiasing, and increase the "
"number of segments to increase the curve smoothness, at the cost of extra "
"performance."
msgstr ""
"Не соромтеся грати з параметрами в інспекторі, щоб отримати різні "
"результати: змініть колір, ширину, згладжування та збільште кількість "
"сегментів, щоб збільшити плавність кривої, ціною додаткової продуктивності."
