#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Singletons (Autoload)"
msgstr "Синглтони (автозавантаження)"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Система сцен Godot, хоча потужна і гнучка, має недолік: не існує способу "
"зберігання інформації (наприклад, рахунок гравця, або інвентар), яка "
"потрібна більше ніж одній сцені."

msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr ""
"Можна вирішити це деякими обхідними шляхами, але вони мають свої обмеження:"

msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"Ви можете використовувати \"майстер-сцену\", яка завантажує та вивантажує "
"інші сцени в вигляді своїх нащадків. Однак це означає, що ви більше не "
"можете запускати ці сцени окремо і очікувати від них правильної роботи."

msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"Інформація може бути збережена на диску в ``user://``, а потім завантажена "
"сценами, які цього потребують, але часте збереження та завантаження даних є "
"громіздкими і може бути повільним."

msgid ""
"The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case, it's possible to reuse "
"the same scene or class for multiple singletons as long as they have "
"different names."
msgstr ""
"`Шаблон Singleton <https://en.wikipedia.org/wiki/Singleton_pattern>`_ є "
"корисним інструментом для вирішення загального випадку, коли вам потрібно "
"зберігати постійну інформацію між сценами. У нашому випадку можливо повторне "
"використання однієї і тієї ж сцени, або класу, для декількох синглтонів, "
"якщо вони мають різні назви."

msgid "Using this concept, you can create objects that:"
msgstr "Використовуючи цю концепцію, ви можете створювати об'єкти, які:"

msgid "Are always loaded, no matter which scene is currently running."
msgstr ""
"Завжди завантажуються, незалежно від того, яка сцена працює в даний момент."

msgid "Can store global variables such as player information."
msgstr "Можуть зберігати глобальні змінні, наприклад інформацію про гравця."

msgid "Can handle switching scenes and between-scene transitions."
msgstr "Можуть працювати з переключенням сцен і переходами між сценами."

msgid ""
"*Act* like a singleton, since GDScript does not support global variables by "
"design."
msgstr ""
"*Діють* як синглтон, оскільки архітектура GDScript не дозволяє підтримувати "
"глобальні змінні."

msgid "Autoloading nodes and scripts can give us these characteristics."
msgstr "Автозавантаження вузлів та скриптів може дати нам ці характеристики."

msgid ""
"Godot won't make an Autoload a \"true\" singleton as per the singleton "
"design pattern. It may still be instanced more than once by the user if "
"desired."
msgstr ""
"Godot не зробить Autoload «справжнім» синглетоном відповідно до шаблону "
"дизайну singleton. За бажання користувач все ще може створювати екземпляри "
"кілька разів."

msgid ""
"If you're creating an autoload as part of an editor plugin, consider :ref:"
"`registering it automatically in the Project Settings "
"<doc_making_plugins_autoload>` when the plugin is enabled."
msgstr ""
"Якщо ви створюєте автозавантаження як частину плагіна редактора, спробуйте :"
"ref:`реєструвати його автоматично в налаштуваннях проекту "
"<doc_making_plugins_autoload>`, коли плагін увімкнено."

msgid "Autoload"
msgstr "Автозавантаження"

msgid ""
"You can create an Autoload to load a scene or a script that inherits from :"
"ref:`class_Node`."
msgstr ""
"Ви можете створити автозавантаження для завантаження сцени або сценарію, "
"який успадковує :ref:`class_Node`."

msgid ""
"When autoloading a script, a :ref:`class_Node` will be created and the "
"script will be attached to it. This node will be added to the root viewport "
"before any other scenes are loaded."
msgstr ""
"При автозавантеженні скрипту буде створений :ref:`class_Node` і цей скрипт "
"буде прикріплений до нього. Цей вузол буде доданий до кореневого вікна "
"перегляду перед завантаженням будь-яких інших сцен."

msgid ""
"To autoload a scene or script, start from the menu and navigate to **Project "
"> Project Settings > Globals > Autoload**."
msgstr ""
"Щоб автоматично завантажити сцену або сценарій, почніть із меню та перейдіть "
"до **Проект > Параметри проекту > Глобальні > Автозавантаження**."

msgid ""
"Here you can add any number of scenes or scripts. Each entry in the list "
"requires a name, which is assigned as the node's ``name`` property. The "
"order of the entries as they are added to the global scene tree can be "
"manipulated using the up/down arrow keys. Like regular scenes, the engine "
"will read these nodes in top-to-bottom order."
msgstr ""
"Тут ви можете додати будь-яку кількість сцен або сценаріїв. Кожному запису в "
"списку потрібне ім’я, яке призначається як властивість ``name`` вузла. "
"Порядком записів, які додаються до глобального дерева сцен, можна керувати "
"за допомогою клавіш зі стрілками вгору/вниз. Як і звичайні сцени, механізм "
"читатиме ці вузли в порядку зверху вниз."

msgid ""
"If the **Enable** column is checked (which is the default), then the "
"singleton can be accessed directly in GDScript:"
msgstr ""
"Якщо стовпець **Увімкнути** позначено (це за замовчуванням), то до синглтона "
"можна отримати доступ безпосередньо в GDScript:"

msgid ""
"The **Enable** column has no effect in C# code. However, if the singleton is "
"a C# script, a similar effect can be achieved by including a static property "
"called ``Instance`` and assigning it in ``_Ready()``:"
msgstr ""
"Стовпець **Enable** не впливає на код C#. Однак, якщо синглтон є сценарієм "
"C#, подібного ефекту можна досягти, включивши статичну властивість під "
"назвою ``Instance`` і призначивши її в ``_Ready()``:"

msgid ""
"This allows the singleton to be accessed from C# code without ``GetNode()`` "
"and without a typecast:"
msgstr ""
"Це дозволяє отримати доступ до синглтона з коду C# без ``GetNode()`` і без "
"приведення типу:"

msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"Зауважте, що до об'єктів автозавантаження (скриптів та/або сцени) доступ "
"такий же, як і до будь-яких інших вузлів у дереві сцен. Насправді, якщо ви "
"подивитесь на дерево запущеної сцени, ви побачите, що автоматично "
"з'являються і завантажені вузли:"

msgid ""
"Autoloads must **not** be removed using ``free()`` or ``queue_free()`` at "
"runtime, or the engine will crash."
msgstr ""
"Автозавантаження **не** можна видаляти за допомогою ``free()`` або "
"``queue_free()`` під час виконання, інакше система призведе до збою."

msgid "Custom scene switcher"
msgstr "Користувацький перемикач сцени"

msgid ""
"This tutorial will demonstrate building a scene switcher using autoloads. "
"For basic scene switching, you can use the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"(see :ref:`doc_scene_tree` for details). However, if you need more complex "
"behavior when changing scenes, this method provides more functionality."
msgstr ""
"Цей посібник продемонструє створення перемикача сцен за допомогою "
"автозавантажень. Для базового перемикання сцен ви можете використовувати "
"метод :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` (докладніше див. :ref:"
"`doc_scene_tree`). Однак, якщо вам потрібна більш складна поведінка під час "
"зміни сцен, цей метод надає більше функціональних можливостей."

msgid ""
"To begin, download the template from here: `singleton_autoload_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/singleton_autoload_starter.zip>`_ and open it in Godot."
msgstr ""
"Для початку завантажте шаблон звідси: `singleton_autoload_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/singleton_autoload_starter.zip>`_ і відкрийте це в Годо."

msgid ""
"The project contains two scenes: ``scene_1.tscn`` and ``scene_2.tscn``. Each "
"scene contains a label displaying the scene name and a button with its "
"``pressed()`` signal connected. When you run the project, it starts in "
"``scene_1.tscn``. However, pressing the button does nothing."
msgstr ""
"Проект містить дві сцени: ``scene_1.tscn`` і ``scene_2.tscn``. Кожна сцена "
"містить мітку з назвою сцени та кнопку з підключеним сигналом ``pressed()``. "
"Коли ви запускаєте проект, він запускається в ``scene_1.tscn``. Однак "
"натискання кнопки нічого не дає."

msgid "Creating the script"
msgstr "Створення сценарію"

msgid ""
"Open the **Script** window and create a new script called ``global.gd``. "
"Make sure it inherits from ``Node``:"
msgstr ""
"Відкрийте вікно **Сценарій** і створіть новий сценарій під назвою ``global."
"gd``. Переконайтеся, що він успадковує від ``Node``:"

msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr ""
"Тепер, при запуску будь-якої сцени проєкту, цей скрипт завжди буде "
"завантажений."

msgid ""
"Returning to the script, it needs to fetch the current scene in the "
"`_ready()` function. Both the current scene (the one with the button) and "
"``global.gd`` are children of root, but autoloaded nodes are always first. "
"This means that the last child of root is always the loaded scene."
msgstr ""
"Повертаючись до сценарію, йому потрібно отримати поточну сцену у функції "
"`_ready()`. І поточна сцена (та, що має кнопку), і ``global.gd`` є нащадками "
"root, але автоматично завантажені вузли завжди перші. Це означає, що остання "
"дочірня частина root завжди є завантаженою сценою."

msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"Тепер нам потрібна функція для зміни сцени. Ця функція повинна звільнити "
"поточну сцену та замінити її на запитувану."

msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""
"Використовуючи :ref:`Object.call_deferred () "
"<class_Object_method_call_deferred>`, друга функція запуститься лише після "
"завершення всього коду з поточної сцени. Таким чином, поточна сцена не буде "
"видалена під час її використання (тобто її код все ще працює)."

msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr ""
"Нарешті, нам потрібно заповнити порожні функції зворотного виклику в обох "
"сценах:"

msgid "and"
msgstr "і"

msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button."
msgstr ""
"Запустіть проєкт і перевірте, чи можете ви перемикатися між сценами при "
"натисканні кнопки."

msgid ""
"When scenes are small, the transition is instantaneous. However, if your "
"scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next tutorial: :ref:"
"`doc_background_loading`."
msgstr ""
"Примітка: Коли сцен мало, перехід відбувається миттєво. Однак якщо ваші "
"сцени складніші, для їх появи може знадобитися значна кількість часу. Щоб "
"дізнатися, як впоратися з цим, дивіться наступний урок: :ref:"
"`doc_background_loading`."

msgid ""
"Alternatively, if the loading time is relatively short (less than 3 seconds "
"or so), you can display a \"loading plaque\" by showing some kind of 2D "
"element just before changing the scene. You can then hide it just after the "
"scene is changed. This can be used to indicate to the player that a scene is "
"being loaded."
msgstr ""
"Як варіант, якщо час завантаження відносно короткий (менше 3 секунд, або "
"близько того), ви можете відобразити \"талицю завантаження\", показавши "
"якийсь 2D-елемент безпосередньо перед зміною сцени. Потім ви можете "
"приховати її відразу після зміни сцени. Це може бути використано, щоб "
"вказати гравцеві, що сцена завантажується."
