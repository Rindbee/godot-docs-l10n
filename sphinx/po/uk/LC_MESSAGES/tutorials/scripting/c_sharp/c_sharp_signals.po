#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "C# signals"
msgstr "Сигнали C#"

msgid ""
"For a detailed explanation of signals in general, see the :ref:`doc_signals` "
"section in the step by step tutorial."
msgstr ""
"Для детального пояснення сигналів загалом перегляньте розділ :ref:"
"`doc_signals` у покроковому посібнику."

msgid ""
"Signals are implemented using C# events, the idiomatic way to represent :ref:"
"`the observer pattern<doc_key_concepts_signals>` in C#. This is the "
"recommended way to use signals in C# and the focus of this page."
msgstr ""
"Сигнали реалізуються за допомогою подій C#, ідіоматичний спосіб "
"представлення :ref:`шаблон спостерігача<doc_key_concepts_signals>` в C#. Це "
"рекомендований спосіб використання сигналів у C#, і в центрі уваги цієї "
"сторінки."

msgid ""
"In some cases it's necessary to use the older :ref:"
"`Connect()<class_object_method_connect>` and :ref:"
"`Disconnect()<class_object_method_disconnect>` APIs. See :ref:"
"`using_connect_and_disconnect` for more details."
msgstr ""
"У деяких випадках необхідно використовувати старіші API :ref:"
"`Connect()<class_object_method_connect>` і :ref:"
"`Disconnect()<class_object_method_disconnect>`. Перегляньте :ref:"
"`using_connect_and_disconnect` для отримання додаткової інформації."

msgid ""
"If you encounter a ``System.ObjectDisposedException`` while handling a "
"signal, you might be missing a signal disconnection. See :ref:"
"`disconnecting_automatically_when_the_receiver_is_freed` for more details."
msgstr ""
"Якщо під час обробки сигналу ви зіткнулися з ``System."
"ObjectDisposedException``, можливо, ви пропускаєте відключення сигналу. "
"Дивіться :ref:`disconnecting_automatically_when_the_receiver_is_freed` для "
"отримання додаткової інформації."

msgid "Signals as C# events"
msgstr "Сигнали як події C#"

msgid ""
"To provide more type-safety, Godot signals are also all available through "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"You can handle these events, as any other event, with the ``+=`` and ``-=`` "
"operators."
msgstr ""
"Щоб забезпечити більшу безпеку типу, усі сигнали Годо також доступні через "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"Ви можете обробляти ці події, як і будь-які інші події, за допомогою "
"операторів ``+=`` і ``-=``."

msgid ""
"In addition, you can always access signal names associated with a node type "
"through its nested ``SignalName`` class. This is useful when, for example, "
"you want to await on a signal (see :ref:`doc_c_sharp_differences_await`)."
msgstr ""
"Крім того, ви завжди можете отримати доступ до імен сигналів, пов’язаних із "
"типом вузла, через його вкладений клас ``SignalName``. Це корисно, "
"наприклад, коли ви хочете очікувати на сигнал (див. :ref:"
"`doc_c_sharp_differences_await`)."

msgid "Custom signals as C# events"
msgstr "Спеціальні сигнали як події C#"

msgid ""
"To declare a custom event in your C# script, use the ``[Signal]`` attribute "
"on a public delegate type. Note that the name of this delegate needs to end "
"with ``EventHandler``."
msgstr ""
"Щоб оголосити спеціальну подію у вашому сценарії C#, використовуйте атрибут "
"``[Signal]`` для загальнодоступного типу делегату. Зауважте, що ім’я цього "
"делегату має закінчуватися на EventHandler."

msgid ""
"Once this is done, Godot will create the appropriate events automatically "
"behind the scenes. You can then use said events as you'd do for any other "
"Godot signal. Note that events are named using your delegate's name minus "
"the final ``EventHandler`` part."
msgstr ""
"Коли це буде зроблено, Годо створить відповідні події автоматично за кадром. "
"Потім ви можете використовувати ці події, як і для будь-якого іншого сигналу "
"Годо. Зауважте, що події називаються з використанням імені вашого делегата "
"без останньої частини ``EventHandler``."

msgid ""
"If you want to connect to these signals in the editor, you will need to "
"(re)build the project to see them appear."
msgstr ""
"Якщо ви хочете підключитися до цих сигналів у редакторі, вам потрібно буде "
"(пере)будувати проект, щоб вони з’явилися."

msgid ""
"You can click the **Build** button in the upper-right corner of the editor "
"to do so."
msgstr ""
"Щоб зробити це, ви можете натиснути кнопку **Створити** у верхньому правому "
"куті редактора."

msgid "Signal emission"
msgstr "Випромінювання сигналу"

msgid ""
"To emit signals, use the ``EmitSignal`` method. Note that, as for signals "
"defined by the engine, your custom signal names are listed under the nested "
"``SignalName`` class."
msgstr ""
"Для випромінювання сигналів використовуйте метод ``EmitSignal``. Зауважте, "
"що, як і для сигналів, визначених механізмом, назви ваших власних сигналів "
"перераховані у вкладеному класі ``SignalName``."

msgid ""
"In contrast with other C# events, you cannot use ``Invoke`` to raise events "
"tied to Godot signals."
msgstr ""
"На відміну від інших подій C#, ви не можете використовувати ``Invoke`` для "
"виклику подій, пов’язаних із сигналами Годо."

msgid ""
"Signals support arguments of any :ref:`Variant-compatible type "
"<c_sharp_variant_compatible_types>`."
msgstr ""
"Сигнали підтримують аргументи будь-якого типу :ref:`Variant-compatible "
"<c_sharp_variant_compatible_types>`."

msgid ""
"Consequently, any ``Node`` or ``RefCounted`` will be compatible "
"automatically, but custom data objects will need to inherit from "
"``GodotObject`` or one of its subclasses."
msgstr ""
"Отже, будь-які ``Node`` або ``RefCounted`` будуть сумісні автоматично, але "
"спеціальні об’єкти даних повинні будуть успадковувати ``GodotObject`` або "
"один із його підкласів."

msgid "Bound values"
msgstr "Зв'язані значення"

msgid ""
"Sometimes you'll want to bind values to a signal when the connection is "
"established, rather than (or in addition to) when the signal is emitted. To "
"do so, you can use an anonymous function like in the following example."
msgstr ""
"Іноді вам потрібно прив’язати значення до сигналу, коли з’єднання "
"встановлено, а не (або на додаток до) під час випромінювання сигналу. Для "
"цього ви можете використати анонімну функцію, як у наступному прикладі."

msgid ""
"Here, the :ref:`Button.Pressed <class_BaseButton_signal_pressed>` signal "
"does not take any argument. But we want to use the same ``ModifyValue`` for "
"both the \"plus\" and \"minus\" buttons. So we bind the modifier value at "
"the time we're connecting the signals."
msgstr ""
"Тут сигнал :ref:`Button.Pressed <class_BaseButton_signal_pressed>` не "
"приймає жодних аргументів. Але ми хочемо використовувати те саме "
"``ModifyValue`` для кнопок «плюс» і «мінус». Отже, ми зв’язуємо значення "
"модифікатора під час підключення сигналів."

msgid "Signal creation at runtime"
msgstr "Створення сигналу під час виконання"

msgid ""
"Finally, you can create custom signals directly while your game is running. "
"Use the ``AddUserSignal`` method for that. Be aware that it should be "
"executed before any use of said signals (either connecting to them or "
"emitting them). Also, note that signals created this way won't be visible "
"through the ``SignalName`` nested class."
msgstr ""
"Нарешті, ви можете створювати власні сигнали безпосередньо під час роботи "
"гри. Для цього використовуйте метод ``AddUserSignal``. Майте на увазі, що "
"його слід виконати перед будь-яким використанням зазначених сигналів "
"(підключенням до них або їх випромінюванням). Також зауважте, що сигнали, "
"створені таким чином, не будуть видимі через вкладений клас ``SignalName``."

msgid "Using Connect and Disconnect"
msgstr "Використання Connect і Disconnect"

msgid ""
"In general, it isn't recommended to use :ref:"
"`Connect()<class_object_method_connect>` and :ref:"
"`Disconnect()<class_object_method_disconnect>`. These APIs don't provide as "
"much type safety as the events. However, they're necessary for :ref:"
"`connecting to signals defined by GDScript "
"<connecting_to_signals_cross_language>` and passing :ref:"
"`ConnectFlags<enum_Object_ConnectFlags>`."
msgstr ""
"Загалом, не рекомендується використовувати :ref:"
"`Connect()<class_object_method_connect>` і :ref:"
"`Disconnect()<class_object_method_disconnect>`. Ці API не забезпечують такої "
"безпеки типу, як події. Однак вони необхідні для :ref:`підключення до "
"сигналів, визначених GDScript <connecting_to_signals_cross_language>` та "
"передачі :ref:`ConnectFlags<enum_Object_ConnectFlags>`."

msgid ""
"In the following example, pressing the button for the first time prints "
"``Greetings!``. ``OneShot`` disconnects the signal, so pressing the button "
"again does nothing."
msgstr ""
"У наступному прикладі натискання кнопки вперше друкує ``Greetings!``. "
"``OneShot`` відключає сигнал, тому повторне натискання кнопки нічого не "
"робить."

msgid "Disconnecting automatically when the receiver is freed"
msgstr "Автоматичне відключення, коли приймач звільняється"

msgid ""
"Normally, when any ``GodotObject`` is freed (such as any ``Node``), Godot "
"automatically disconnects all connections associated with that object. This "
"happens for both signal emitters and signal receivers."
msgstr ""
"Зазвичай, коли будь-який ``GodotObject`` звільняється (наприклад, будь-який "
"``Node``), Godot автоматично роз’єднує всі з’єднання, пов’язані з цим "
"об’єктом. Це відбувається як для випромінювачів, так і для приймачів "
"сигналів."

msgid ""
"For example, a node with this code will print \"Hello!\" when the button is "
"pressed, then free itself. Freeing the node disconnects the signal, so "
"pressing the button again doesn't do anything:"
msgstr ""
"Наприклад, вузол із таким кодом надрукує \"Hello!\" при натисканні кнопки "
"звільняється. Звільнення вузла відключає сигнал, тому повторне натискання "
"кнопки нічого не робить:"

msgid ""
"When a signal receiver is freed while the signal emitter is still alive, in "
"some cases automatic disconnection won't happen:"
msgstr ""
"Коли приймач сигналу звільняється, а випромінювач сигналу ще живий, у деяких "
"випадках автоматичне відключення не відбудеться:"

msgid ""
"The signal is connected to a lambda expression that captures a variable."
msgstr "Сигнал пов’язаний з лямбда-виразом, який фіксує змінну."

msgid "The signal is a custom signal."
msgstr "Сигнал є індивідуальним."

msgid ""
"The following sections explain these cases in more detail and include "
"suggestions for how to disconnect manually."
msgstr ""
"У наступних розділах ці випадки пояснюються більш детально та містяться "
"пропозиції щодо від’єднання вручну."

msgid ""
"Automatic disconnection is totally reliable if a signal emitter is freed "
"before any of its receivers are freed. With a project style that prefers "
"this pattern, the above limits may not be a concern."
msgstr ""
"Автоматичне відключення є цілком надійним, якщо випромінювач сигналу "
"звільняється до того, як звільняється будь-який із його приймачів. Зі стилем "
"проекту, який віддає перевагу цьому шаблону, наведені вище обмеження можуть "
"не викликати занепокоєння."

msgid ""
"No automatic disconnection: a lambda expression that captures a variable"
msgstr "Без автоматичного відключення: лямбда-вираз, який фіксує змінну"

msgid ""
"If you connect to a lambda expression that captures variables, Godot can't "
"tell that the lambda is associated with the instance that created it. This "
"causes this example to have potentially unexpected behavior:"
msgstr ""
"Якщо ви підключитесь до лямбда-виразу, який фіксує змінні, Годо не зможе "
"сказати, що лямбда пов’язана з примірником, який його створив. Через це цей "
"приклад має потенційно неочікувану поведінку:"

msgid ""
"On tick 4, the lambda expression tries to access the ``Name`` property of "
"the node, but the node has already been freed. This causes the exception."
msgstr ""
"На відмітці 4 лямбда-вираз намагається отримати доступ до властивості "
"``Name`` вузла, але вузол уже звільнено. Це викликає виключення."

msgid ""
"To disconnect, keep a reference to the delegate created by the lambda "
"expression and pass that to ``-=``. For example, this node connects and "
"disconnects using the ``_EnterTree`` and ``_ExitTree`` lifecycle methods:"
msgstr ""
"Щоб від’єднатися, збережіть посилання на делегат, створений лямбда-виразом, "
"і передайте його в ``-=``. Наприклад, цей вузол підключається та "
"від’єднується за допомогою методів життєвого циклу ``_EnterTree`` і "
"``_ExitTree``:"

msgid ""
"In this example, ``Free`` causes the node to leave the tree, which calls "
"``_ExitTree``. ``_ExitTree`` disconnects the signal, so ``_tick`` is never "
"called again."
msgstr ""
"У цьому прикладі ``Free`` змушує вузол залишати дерево, яке викликає "
"``_ExitTree``. ``_ExitTree`` від’єднує сигнал, тому ``_tick`` більше ніколи "
"не викликається."

msgid ""
"The lifecycle methods to use depend on what the node does. Another option is "
"to connect to signals in ``_Ready`` and disconnect in ``Dispose``."
msgstr ""
"Використовувані методи життєвого циклу залежать від того, що робить вузол. "
"Іншим варіантом є підключення до сигналів у ``_Ready`` і від’єднання в "
"``Dispose``."

msgid ""
"Godot uses `Delegate.Target <https://learn.microsoft.com/en-us/dotnet/api/"
"system.delegate.target>`_ to determine what instance a delegate is "
"associated with. When a lambda expression doesn't capture a variable, the "
"generated delegate's ``Target`` is the instance that created the delegate. "
"When a variable is captured, the ``Target`` instead points at a generated "
"type that stores the captured variable. This is what breaks the association. "
"If you want to see if a delegate will be automatically cleaned up, try "
"checking its ``Target``."
msgstr ""
"Godot використовує `Delegate.Target <https://learn.microsoft.com/en-us/"
"dotnet/api/system.delegate.target>`_, щоб визначити, з яким екземпляром "
"пов’язаний делегат. Якщо лямбда-вираз не фіксує змінну, ``Target`` "
"згенерованого делегату є примірником, який створив делегат. Коли змінна "
"захоплена, ``Target`` замість цього вказує на згенерований тип, який "
"зберігає захоплену змінну. Це те, що розриває асоціацію. Якщо ви хочете "
"побачити, чи делегат буде автоматично очищено, спробуйте перевірити його "
"``Target``."

msgid ""
"``Callable.From`` doesn't affect the ``Delegate.Target``, so connecting a "
"lambda that captures variables using ``Connect`` doesn't work any better "
"than ``+=``."
msgstr ""
"``Callable.From`` не впливає на ``Delegate.Target``, тому підключення лямбда-"
"виразки, яка фіксує змінні за допомогою ``Connect``, працює не краще, ніж "
"``+=``."

msgid "No automatic disconnection: a custom signal"
msgstr "Без автоматичного відключення: спеціальний сигнал"

msgid ""
"Connecting to a custom signal using ``+=`` doesn't disconnect automatically "
"when the receiving node is freed."
msgstr ""
"Підключення до спеціального сигналу за допомогою ``+=`` не розривається "
"автоматично, коли приймальний вузол звільняється."

msgid "To disconnect, use ``-=`` at an appropriate time. For example:"
msgstr ""
"Щоб від’єднатися, використовуйте ``-=`` у відповідний момент. Наприклад:"

msgid ""
"Another solution is to use ``Connect``, which does disconnect automatically "
"with custom signals:"
msgstr ""
"Іншим рішенням є використання ``Connect``, який автоматично роз’єднується за "
"допомогою спеціальних сигналів:"
