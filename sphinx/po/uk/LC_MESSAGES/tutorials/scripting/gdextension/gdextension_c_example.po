#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDExtension C example"
msgstr "Приклад GDExtension C"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"This is a simple example on how to work with GDExtension directly with C "
"code. Note that the API is not meant to be used directly, so this will "
"definitely be quite verbose and require a lot of steps even for a small "
"example. However, it serves as a reference for creating bindings for a "
"different language. It is still possible to use the API directly if you "
"prefer, which might be convenient when only binding a third-party library."
msgstr ""
"Це простий приклад того, як працювати з GDExtension безпосередньо з кодом C. "
"Зауважте, що API не призначений для безпосереднього використання, тому це, "
"безперечно, буде досить багатослівним і вимагатиме багато кроків навіть для "
"невеликого прикладу. Однак він служить посиланням для створення прив’язок "
"для іншої мови. Ви все ще можете використовувати API напряму, якщо хочете, "
"що може бути зручним, коли лише прив’язуєте сторонню бібліотеку."

msgid ""
"In this example we will create a custom node that moves a sprite on the "
"screen based on the user's parameters. While very simple, it serves to show "
"how to do some of the things with GDExtension, like registering custom "
"classes with methods, properties, and signals. It gives an insight on the "
"GDExtension API."
msgstr ""
"У цьому прикладі ми створимо спеціальний вузол, який переміщує спрайт на "
"екрані на основі параметрів користувача. Хоча він дуже простий, він служить "
"для того, щоб показати, як робити деякі речі з GDExtension, наприклад, "
"реєструвати спеціальні класи з методами, властивостями та сигналами. Він дає "
"уявлення про API GDExtension."

msgid "Setting up the project"
msgstr "Налаштування проекту"

msgid "There are a few prerequisites you'll need:"
msgstr "Вам знадобиться кілька передумов:"

msgid "a Godot 4.2 (or later) executable,"
msgstr "виконуваний файл Godot 4.2 (або новішої версії).,"

msgid "a C compiler,"
msgstr "компілятор C,"

msgid "SCons as a build tool."
msgstr "SCons як інструмент побудови."

msgid ""
"Since this is using the API directly, there's no need to use the `godot-cpp "
"repository <https://github.com/godotengine/godot-cpp>`__."
msgstr ""
"Оскільки тут використовується безпосередньо API, немає потреби "
"використовувати `репозиторій godot-cpp <https://github.com/godotengine/godot-"
"cpp>`__."

msgid "File structure"
msgstr "Структура файлу"

msgid "To organize our files, we're gonna split into mainly two folders:"
msgstr "Щоб упорядкувати наші файли, ми розділимо їх на дві папки:"

msgid ""
"We also need a copy of the ``gdextension_interface.h`` header from the Godot "
"source code, which can be obtained directly from the Godot executable by "
"running the following command:"
msgstr ""
"Нам також потрібна копія заголовка ``gdextension_interface.h`` з вихідного "
"коду Godot, яку можна отримати безпосередньо з виконуваного файлу Godot, "
"виконавши таку команду:"

msgid ""
"This creates the header in the current folder, so you can just copy it to "
"the ``src`` folder in the example project."
msgstr ""
"Це створює заголовок у поточній папці, тож ви можете просто скопіювати його "
"до папки ``src`` у прикладі проекту."

msgid ""
"Lastly, there's another source of information we need to refer to, which is "
"the JSON file with the Godot API reference. This file won't be used by the "
"code directly, we will only use it to extract some information manually."
msgstr ""
"Нарешті, є ще одне джерело інформації, на яке нам потрібно звернутися, це "
"файл JSON із посиланням на Godot API. Цей файл не використовуватиметься "
"кодом безпосередньо, ми використовуватимемо його лише для отримання деякої "
"інформації вручну."

msgid "To get this JSON file, just call the Godot executable:"
msgstr "Щоб отримати цей файл JSON, просто викличте виконуваний файл Godot:"

msgid ""
"The resulting ``extension_api.json`` file will be created in the current "
"folder. You can copy this file to the example folder to have it handy."
msgstr ""
"Отриманий файл ``extension_api.json`` буде створено в поточній папці. Ви "
"можете скопіювати цей файл до папки прикладу, щоб мати його під рукою."

msgid ""
"This extension is targeting Godot 4.2, but it should work on later versions "
"as well. If you want to target a different minimal version, make sure to get "
"the header and the JSON from the version Godot version you are targeting."
msgstr ""
"Це розширення націлено на Godot 4.2, але воно має працювати й на пізніших "
"версіях. Якщо ви хочете націлити іншу мінімальну версію, переконайтеся, що "
"ви отримали заголовок і JSON із версії Godot, на яку ви націлюєте."

msgid "Buildsystem"
msgstr "Buildsystem"

msgid ""
"Using a buildsystem makes our life a lot easier when dealing with C code. "
"For the sake of convenience, we'll use SCons since it's the same as what "
"Godot itself uses."
msgstr ""
"Використання buildsystem значно полегшує наше життя під час роботи з кодом "
"C. Для зручності ми будемо використовувати SCons, оскільки це те саме, що "
"використовує сам Godot."

msgid ""
"The following ``SConstruct`` file is a simple one that will build your "
"extension to the current platform that you are using, be it Linux, macOS, or "
"Windows. This will be a non-optimized build for debugging purposes. It also "
"assumes a 64-bit build, which is relevant for some parts of the example "
"code. Making other build types and cross-compilation is out of the scope of "
"this tutorial. Save this file to the root folder."
msgstr ""
"Наступний файл ``SConstruct`` є простим файлом, який створить ваше "
"розширення для поточної платформи, яку ви використовуєте, будь то Linux, "
"macOS або Windows. Це буде неоптимізована збірка для цілей налагодження. Він "
"також передбачає 64-розрядну збірку, яка актуальна для деяких частин "
"прикладу коду. Створення інших типів збірок і крос-компіляція виходять за "
"рамки цього посібника. Збережіть цей файл у кореневій папці."

msgid ""
"This will include all C files in the ``src`` folder, so we don't need to "
"change this file when adding new source files."
msgstr ""
"Це включатиме всі файли C у папці ``src``, тому нам не потрібно змінювати "
"цей файл під час додавання нових вихідних файлів."

msgid "Initializing the extension"
msgstr "Ініціалізація розширення"

msgid ""
"The first bit of code will be responsible for initializing the extension. "
"This is what makes Godot aware of what our GDExtension provides, such as "
"classes and plugins."
msgstr ""
"Перший біт коду відповідатиме за ініціалізацію розширення. Саме завдяки "
"цьому Godot дізнається про те, що надає наше GDExtension, як-от класи та "
"плагіни."

msgid ""
"Create the file ``init.h`` in the ``src`` folder, with the following "
"contents:"
msgstr "Створіть файл ``init.h`` у папці ``src`` з таким вмістом:"

msgid ""
"The functions declared here have the signatures expected by the GDExtension "
"API."
msgstr "Оголошені тут функції мають сигнатури, очікувані API GDExtension."

msgid ""
"Note the inclusion of the ``defs.h`` file. This is one of our helpers to "
"simplify writing the extension code. For now it will only contain the "
"definition of ``GDE_EXPORT``, a macro that makes the function public in the "
"shared library so Godot can properly call it. This macro helps abstracting "
"what each compiler expects."
msgstr ""
"Зверніть увагу на включення файлу ``defs.h``. Це один із наших помічників "
"для спрощення написання коду розширення. Наразі він міститиме лише "
"визначення ``GDE_EXPORT``, макросу, який робить функцію загальнодоступною у "
"спільній бібліотеці, щоб Godot міг правильно її викликати. Цей макрос "
"допомагає абстрагувати те, що очікує кожен компілятор."

msgid ""
"Create the ``defs.h`` file in the ``src`` folder with the following contents:"
msgstr "Створіть файл ``defs.h`` у папці ``src`` із таким вмістом:"

msgid ""
"We also include some standard headers to make things easier. Now we only "
"have to include ``defs.h`` and those will come as a bonus."
msgstr ""
"Ми також включаємо деякі стандартні заголовки, щоб полегшити роботу. Тепер "
"нам залишається лише включити ``defs.h``, і це буде бонусом."

msgid ""
"Now, let's implement the functions we just declared. Create a file called "
"``init.c`` in the ``src`` folder and add this code:"
msgstr ""
"Тепер давайте реалізуємо функції, які ми щойно оголосили. Створіть файл під "
"назвою ``init.c`` у папці ``src`` і додайте цей код:"

msgid ""
"What this does is set up the initialization data that Godot expects. The "
"functions to initialize and deinitialize are set so Godot will call then "
"when needed. It also sets the initialization level which varies per "
"extension. Since we plan to add a custom node, the ``SCENE`` level is enough."
msgstr ""
"Це встановлює дані ініціалізації, які очікує Godot. Функції для "
"ініціалізації та деініціалізації налаштовано таким чином, щоб Godot викликав "
"тоді, коли це необхідно. Він також встановлює рівень ініціалізації, який "
"залежить від розширення. Оскільки ми плануємо додати спеціальний вузол, "
"достатньо рівня ``SCENE``."

msgid ""
"We will fill the ``initialize_gdexample_module()`` function later to "
"register our custom class."
msgstr ""
"Ми заповнимо функцію ``initialize_gdexample_module()`` пізніше, щоб "
"зареєструвати наш власний клас."

msgid "A basic class"
msgstr "Базовий клас"

msgid ""
"In order to make an actual node, first we'll create a C struct to hold data "
"and functions that will act as methods. The plan is to make this a custom "
"node that inherits from :ref:`Sprite2D <class_Sprite2D>`."
msgstr ""
"Щоб створити фактичний вузол, спочатку ми створимо структуру C для "
"зберігання даних і функцій, які діятимуть як методи. План полягає в тому, "
"щоб зробити це спеціальним вузлом, який успадковує від :ref:`Sprite2D "
"<class_Sprite2D>`."

msgid ""
"Create a file called ``gdexample.h`` in the ``src`` folder with the "
"following contents:"
msgstr ""
"Створіть файл під назвою ``gdexample.h`` у папці ``src`` з таким вмістом:"

msgid ""
"Noteworthy here is the ``object`` field, which holds a pointer to the Godot "
"object, and the ``gdexample_class_bind_methods()`` function, which will "
"register the metadata of our custom class (properties, methods, and "
"signals). The latter is not entirely necessary, as we can do it when "
"registering the class, but it makes clearer to separate the concerns and let "
"our class register its own metadata."
msgstr ""
"Тут варто звернути увагу на поле ``object``, яке містить покажчик на об’єкт "
"Godot, і ``gdexample_class_bind_methods()`` функцію, яка реєструватиме "
"метадані нашого спеціального класу (властивості, методи та сигнали). Останнє "
"не є абсолютно необхідним, оскільки ми можемо це зробити під час реєстрації "
"класу, але це дає змогу чіткіше розділити проблеми та дозволити нашому класу "
"зареєструвати власні метадані."

msgid ""
"The ``object`` field is necessary because our class will inherit a Godot "
"class. Since we can't inherit it directly, as we are not interacting with "
"the source code (and C doesn't even have classes), we instead tell Godot to "
"create an object of a type it knows and attach our extension to it. We will "
"need the reference to such objects when calling methods on the parent class, "
"for instance."
msgstr ""
"Поле ``object`` є необхідним, оскільки наш клас успадкує клас Godot. "
"Оскільки ми не можемо успадкувати його безпосередньо, оскільки ми не "
"взаємодіємо з вихідним кодом (а C навіть не має класів), ми натомість кажемо "
"Godot створити об’єкт того типу, який йому відомий, і приєднати до нього "
"наше розширення. Нам знадобиться посилання на такі об’єкти, наприклад, під "
"час виклику методів батьківського класу."

msgid ""
"Let's create the source counterpart of this header. Create the file "
"``gdexample.c`` in the ``src`` folder and add the following code to it:"
msgstr ""
"Давайте створимо вихідний аналог цього заголовка. Створіть файл "
"``gdexample.c`` у папці ``src`` і додайте до нього такий код:"

msgid ""
"As we don't have anything to do with those functions yet, they'll stay empty "
"for a while."
msgstr ""
"Оскільки ми ще не маємо нічого спільного з цими функціями, вони деякий час "
"залишатимуться порожніми."

msgid ""
"The next step is registering our class. However, in order to do so we need "
"to create a :ref:`StringName <class_StringName>` and for that we have to get "
"a function from the GDExtension API. Since we'll need this a few times and "
"we'll also need other things, let's create a wrapper API to facilitate this "
"kind of chore."
msgstr ""
"Наступний крок - реєстрація нашого класу. Однак для цього нам потрібно "
"створити :ref:`StringName <class_StringName>`, а для цього нам потрібно "
"отримати функцію з GDExtension API. Оскільки це нам знадобиться кілька "
"разів, і нам також знадобляться інші речі, давайте створимо API-оболонку, "
"щоб полегшити цю роботу."

msgid "A wrapper API"
msgstr "API оболонки"

msgid "We'll start by creating an ``api.h`` file in the ``src`` folder:"
msgstr "Ми почнемо зі створення файлу ``api.h`` у папці ``src``:"

msgid ""
"This file will include many other helpers as we fill our extension with "
"something useful. For now it only has a pointer to a function that creates a "
"StringName from a C string (in Latin-1 encoding) and another to destruct a "
"StringName, which we'll need to use to avoid leaking memory, as well as the "
"function to register a class, which is our initial goal."
msgstr ""
"Цей файл міститиме багато інших помічників, коли ми наповнюємо наше "
"розширення чимось корисним. Наразі він має лише вказівник на функцію, яка "
"створює StringName із рядка C (у кодуванні Latin-1), і інший для знищення "
"StringName, який нам потрібно буде використовувати, щоб уникнути витоку "
"пам’яті, а також функцію для реєстрації класу, що є нашою початковою метою."

msgid ""
"We also keep a reference to the ``class_library`` here. This is something "
"that Godot provides to us when initializing the extension and we'll need to "
"use it when registering the things we create so Godot can tell which "
"extension is making the call."
msgstr ""
"Ми також зберігаємо тут посилання на ``class_library``. Це те, що Godot "
"надає нам під час ініціалізації розширення, і нам потрібно буде "
"використовувати це під час реєстрації речей, які ми створюємо, щоб Godot міг "
"визначити, яке розширення здійснює виклик."

msgid ""
"There's also a function to load those function pointers from the GDExtension "
"API."
msgstr ""
"Існує також функція для завантаження цих покажчиків на функції з API "
"GDExtension."

msgid ""
"Let's work on the source counterpart of this header. Create the ``api.c`` "
"file in the ``src`` folder, adding the following code:"
msgstr ""
"Давайте попрацюємо над вихідним аналогом цього заголовка. Створіть файл "
"``api.c`` у папці ``src``, додавши такий код:"

msgid ""
"The first important thing here is ``p_get_proc_address``. This a function "
"from the GDExtension API that is passed during initialization. You can use "
"this function to request specific functions from the API by their name. Here "
"we are caching the results so we don't have to keep a reference for "
"``p_get_proc_address`` everywhere and use our wrapper instead."
msgstr ""
"Перша важлива річ тут – це ``p_get_proc_address``. Це функція з API "
"GDExtension, яка передається під час ініціалізації. Ви можете "
"використовувати цю функцію, щоб запитувати певні функції в API за їх іменем. "
"Тут ми кешуємо результати, тому нам не потрібно скрізь зберігати посилання "
"на ``p_get_proc_address`` і використовувати натомість нашу оболонку."

msgid ""
"At the start we request the ``variant_get_ptr_destructor()`` function. This "
"is not going to be used outside of this function, so we don't add to our "
"wrapper and only cache it locally. The cast is necessary to silence compiler "
"warnings."
msgstr ""
"На початку ми запитуємо функцію ``variant_get_ptr_destructor()``. Це не буде "
"використовуватися поза цією функцією, тому ми не додаємо до нашої оболонки, "
"а лише кешуємо її локально. Приведення необхідне, щоб заглушити попередження "
"компілятора."

msgid ""
"Then we get the function that creates a StringName from a C string, exactly "
"what we mentioned before as a needed function. We store that in our "
"``constructors`` struct."
msgstr ""
"Тоді ми отримуємо функцію, яка створює StringName із рядка C, саме те, що ми "
"згадували раніше як необхідну функцію. Ми зберігаємо це в нашій структурі "
"``constructors``."

msgid ""
"Next, we use the ``variant_get_ptr_destructor()`` function we just got to "
"query for the destructor for StringName, using the enum value from "
"``gdextension_interface.h`` API as a parameter. We could get destructors for "
"other types in a similar manner, but we'll limit ourselves to what is needed "
"for the example."
msgstr ""
"Далі ми використовуємо функцію ``variant_get_ptr_destructor()``, яку ми "
"щойно отримали, щоб запитати деструктор для StringName, використовуючи "
"значення enum з API ``gdextension_interface.h`` як параметр. Ми могли б "
"отримати деструктори для інших типів подібним чином, але ми обмежимося тим, "
"що потрібно для прикладу."

msgid ""
"Lastly, we get the ``classdb_register_extension_class2()`` function, which "
"we'll need in order to register our custom class."
msgstr ""
"Нарешті, ми отримуємо функцію ``classdb_register_extension_class2()``, яка "
"нам знадобиться для реєстрації нашого спеціального класу."

msgid ""
"You may wonder why the ``2`` is there in the function name. This means it's "
"the second version of this function. The old version is kept to ensure "
"backwards compatibility with older extensions, but since we have the second "
"version available, it's best to use the new one, because we don't intend to "
"support older Godot versions in this example."
msgstr ""
"Ви можете здивуватися, чому ``2`` є в назві функції. Це означає, що це друга "
"версія цієї функції. Стара версія зберігається для забезпечення зворотної "
"сумісності зі старими розширеннями, але оскільки у нас є друга версія, "
"найкраще використовувати нову, оскільки ми не маємо наміру підтримувати "
"старіші версії Godot у цьому прикладі."

msgid ""
"The ``gdextension_interface.h`` header documents in which Godot version each "
"function was introduced."
msgstr ""
"Заголовок ``gdextension_interface.h`` документує, у якій версії Godot було "
"представлено кожну функцію."

msgid ""
"We also define the ``class_library`` variable here, which will be set during "
"initialization."
msgstr ""
"Ми також визначаємо тут змінну ``class_library``, яка буде встановлена під "
"час ініціалізації."

msgid ""
"Speaking of initialization, now we have to change the ``init.c`` file in "
"order to fill the things we just added:"
msgstr ""
"Говорячи про ініціалізацію, тепер нам потрібно змінити файл ``init.c``, щоб "
"заповнити те, що ми щойно додали:"

msgid ""
"Here we set the ``class_library`` as needed and call our new ``load_api()`` "
"function. Don't forget to also include the new headers at the top of this "
"file:"
msgstr ""
"Тут ми за потреби встановлюємо ``class_library`` і викликаємо нашу нову "
"функцію ``load_api()``. Не забудьте також включити нові заголовки у верхній "
"частині цього файлу:"

msgid ""
"Since we are here, we can register our new custom class. Let's fill the "
"``initialize_gdexample_module()`` function:"
msgstr ""
"Оскільки ми тут, ми можемо зареєструвати наш новий спеціальний клас. Давайте "
"заповнимо функцію ``initialize_gdexample_module()``:"

msgid ""
"The struct with the class information is the biggest thing here. None of its "
"fields are required with the exception of ``create_instance_func`` and "
"``free_instance_func``. We haven't made those functions yet, so we'll have "
"to work on them soon. Note that we skip the initialization if it isn't at "
"the ``SCENE`` level. This function may be called multiple times, once for "
"each level, but we only want to register our class once."
msgstr ""
"Структура з інформацією про клас — це найбільше тут. Жодне з його полів не є "
"обов’язковим, за винятком ``create_instance_func`` і ``free_instance_func``. "
"Ми ще не створили ці функції, тому незабаром нам доведеться над ними "
"працювати. Зауважте, що ми пропускаємо ініціалізацію, якщо вона не на рівні "
"``SCENE``. Цю функцію можна викликати кілька разів, один раз для кожного "
"рівня, але ми хочемо зареєструвати наш клас лише один раз."

msgid ""
"The other undefined thing here is ``StringName``. This will be an opaque "
"struct meant to hold the data of a Godot StringName in our extension. We'll "
"define it in the appropriately named ``defs.h`` file:"
msgstr ""
"Інша невизначена річ тут – ``StringName``. Це буде непрозора структура, "
"призначена для зберігання даних Godot StringName у нашому розширенні. Ми "
"визначимо його у файлі ``defs.h`` з відповідною назвою:"

msgid ""
"As mentioned in the comment, the sizes can be found in the "
"``extension_api.json`` file that we generated earlier, under the "
"``builtin_class_sizes`` property. The ``BUILD_32`` is never defined, as we "
"assume we are working with a 64-bits build of Godot here, but if you need it "
"you can add ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` to your ``SConstruct`` "
"file."
msgstr ""
"Як зазначено в коментарі, розміри можна знайти у файлі "
"``extension_api.json``, який ми згенерували раніше, у властивості "
"``builtin_class_sizes``. ``BUILD_32`` ніколи не визначається, оскільки ми "
"припускаємо, що тут ми працюємо з 64-розрядною збіркою Godot, але якщо вам "
"це потрібно, ви можете додати ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` до "
"вашого файлу ``SConstruct``."

msgid ""
"The ``// Types.`` comment foreshadows that we'll be adding more types to "
"this file. Let's leave that for later."
msgstr ""
"Коментар ``// Types.`` передвіщає, що ми додамо більше типів до цього файлу. "
"Залишимо це на потім."

msgid ""
"The ``StringName`` struct here is just to hold Godot data, so we don't "
"really care what is inside of it. Though, in this case, it is just a pointer "
"to the data in the heap. We'll use this struct when we need to allocate data "
"for a StringName ourselves, like we are doing when registering our class."
msgstr ""
"Структура ``StringName`` призначена лише для зберігання даних Godot, тому "
"нам не дуже важливо, що всередині неї. Хоча в даному випадку це лише "
"вказівник на дані в купі. Ми будемо використовувати цю структуру, коли нам "
"потрібно буде самостійно виділити дані для StringName, як ми це робимо під "
"час реєстрації нашого класу."

msgid ""
"Back to registering, we need to work on our create and free functions. Let's "
"include them in ``gdexample.h`` since they're specific to the custom class:"
msgstr ""
"Повертаючись до реєстрації, нам потрібно попрацювати над нашими функціями "
"створення та безкоштовного доступу. Давайте включимо їх у ``gdexample.h``, "
"оскільки вони специфічні для спеціального класу:"

msgid ""
"Before we can implement those function, we'll need a few more things in our "
"API. We need a way to allocate and free memory. While we could do this with "
"good ol' ``malloc()``, we can instead make use of Godot's memory management "
"functions. We'll also need a way to create a Godot object and set it with "
"our custom instance."
msgstr ""
"Перш ніж ми зможемо реалізувати ці функції, нам знадобиться ще кілька речей "
"у нашому API. Нам потрібен спосіб розподілу та звільнення пам’яті. Хоча ми "
"могли б зробити це за допомогою старого доброго ``malloc()``, натомість ми "
"можемо використати функції керування пам’яттю Godot. Нам також знадобиться "
"спосіб створити об’єкт Godot і встановити його за допомогою нашого "
"спеціального екземпляра."

msgid "So let's change the ``api.h`` to include these new functions:"
msgstr "Отже, давайте змінимо ``api.h``, щоб включити ці нові функції:"

msgid ""
"Then we change the ``load_api()`` function in ``api.c`` to grab these new "
"functions:"
msgstr ""
"Потім ми змінюємо функцію ``load_api()`` в ``api.c``, щоб отримати ці нові "
"функції:"

msgid ""
"Now we can go back to ``gdexample.c`` and define the new functions, without "
"forgetting to include the ``api.h`` header:"
msgstr ""
"Тепер ми можемо повернутися до ``gdexample.c`` і визначити нові функції, не "
"забувши включити ``api.h`` заголовок:"

msgid ""
"When instantiating an object, first we create a new Sprite2D object, since "
"that's the parent of our class. Then we allocate memory for our custom "
"struct and call its constructor. We save the pointer to the Godot object in "
"the struct as well like we mentioned earlier."
msgstr ""
"Під час створення екземпляра об’єкта ми спочатку створюємо новий об’єкт "
"Sprite2D, оскільки це батьківський об’єкт нашого класу. Потім ми виділяємо "
"пам’ять для нашої спеціальної структури та викликаємо її конструктор. Ми "
"також зберігаємо покажчик на об’єкт Godot у структурі, як ми згадували "
"раніше."

msgid ""
"Then we set our custom struct as the instance data. This will make Godot "
"know that the object is an instance of our custom class and properly call "
"our custom methods for instance, as well as passing this data back."
msgstr ""
"Потім ми встановлюємо нашу спеціальну структуру як дані екземпляра. Це дасть "
"Godot знати, що об’єкт є екземпляром нашого спеціального класу, і, "
"наприклад, правильно викликати наші власні методи, а також передати ці дані "
"назад."

msgid "Note that we return the Godot object we created, not our custom struct."
msgstr ""
"Зауважте, що ми повертаємо створений нами об’єкт Godot, а не нашу спеціальну "
"структуру."

msgid ""
"For the ``gdextension_free_instance()`` function, we only call the "
"destructor and free the memory we allocated for the custom data. It is not "
"necessary to destruct the Godot object since that will be taken care of by "
"the engine itself."
msgstr ""
"Для функції ``gdextension_free_instance()`` ми викликаємо лише деструктор і "
"звільняємо пам’ять, яку ми виділили для спеціальних даних. Не обов'язково "
"руйнувати об'єкт Godot, оскільки про це подбає сам двигун."

msgid "A demo project"
msgstr "Демонстраційний проект"

msgid ""
"Now that we can create and free our custom object, we should be able to try "
"it out in an actual project. For this, you need to open Godot and create a "
"new project on the ``demo`` folder. The project manager may warn you the "
"folder isn't empty if you have compiled the extension before, you can safely "
"ignore this warning this time."
msgstr ""
"Тепер, коли ми можемо створити та звільнити наш власний об’єкт, ми маємо "
"можливість випробувати його в реальному проекті. Для цього вам потрібно "
"відкрити Godot і створити новий проект у папці ``demo``. Керівник проекту "
"може попередити вас, що папка не порожня, якщо ви скомпілювали розширення "
"раніше, цього разу ви можете спокійно проігнорувати це попередження."

msgid ""
"If you didn't compile the extension yet, it is the time to do it now. To do "
"that, open a terminal or command prompt, navigate to the root folder of the "
"extension and run ``scons``. It should compile quickly since the extension "
"is very simple."
msgstr ""
"Якщо ви ще не скомпілювали розширення, настав час зробити це зараз. Для "
"цього відкрийте термінал або командний рядок, перейдіть до кореневої папки "
"розширення та запустіть ``scons``. Він має швидко компілюватися, оскільки "
"розширення дуже просте."

msgid ""
"Then, create a file called ``gdexample.gdextension`` inside the ``demo`` "
"folder. This is a Godot resource that describes the extension, allowing the "
"engine to properly load it. Put the following content in this file:"
msgstr ""
"Потім створіть файл під назвою ``gdexample.gdextension`` у папці ``demo``. "
"Це ресурс Godot, який описує розширення, що дозволяє механізму правильно "
"його завантажувати. Розмістіть у цьому файлі такий вміст:"

msgid ""
"As you can see, ``gdexample_library_init()`` is the same name of the "
"function we defined in our ``init.c`` file. It is important that the names "
"match because it is how Godot calls the entry point of the extension."
msgstr ""
"Як бачите, ``gdexample_library_init()`` — це та сама назва функції, яку ми "
"визначили у нашому файлі ``init.c``. Важливо, щоб імена збігалися, оскільки "
"саме так Godot називає точку входу розширення."

msgid ""
"We also set the compatibility minimum to 4.2, since we are targeting this "
"version. It should still work on later versions. If you are using a later "
"Godot version and rely on the new features, you need to increase this value "
"to a version number that has everything you use. "
"See :ref:`doc_what_is_gdextension_version_compatibility` for more "
"information."
msgstr ""
"Ми також встановили мінімальну сумісність 4.2, оскільки ми орієнтуємося на "
"цю версію. Він все одно має працювати на пізніших версіях. Якщо ви "
"використовуєте пізнішу версію Godot і покладаєтеся на нові функції, вам "
"потрібно збільшити це значення до номера версії, який містить усе, що ви "
"використовуєте. "
"Перегляньте :ref:`doc_what_is_gdextension_version_compatibility` для "
"отримання додаткової інформації."

msgid ""
"In the ``[libraries]`` section we set up the paths to the shared library on "
"different platforms. Here there's only the debug versions since that's what "
"we are working on for the example. Using :ref:`feature tags "
"<doc_feature_tags>` you can fine tune this to also provide release versions, "
"add more target operating systems, as well as providing 32-bit and 64-bit "
"binaries."
msgstr ""
"У розділі ``[libraries]`` ми встановлюємо шляхи до спільної бібліотеки на "
"різних платформах. Тут є лише версії для налагодження, оскільки це те, над "
"чим ми працюємо для прикладу. Використовуючи :ref:`feature tags "
"<doc_feature_tags>`, ви можете точно налаштувати це, щоб також надавати "
"версії випусків, додавати більше цільових операційних систем, а також "
"надавати 32-розрядні та 64-розрядні двійкові файли."

msgid ""
"You can also add library dependencies and custom icons for your classes in "
"this file, but this is out of the scope for this tutorial."
msgstr ""
"Ви також можете додати до цього файлу залежності бібліотеки та спеціальні "
"піктограми для ваших класів, але це виходить за рамки цього посібника."

msgid ""
"After saving the file, go back to the editor. Godot should automatically "
"load the extension. Nothing will be seen because our extension only "
"registers a new class. To use this class add a ``Node2D`` as a root of the "
"scene. Move it to the middle of viewport for better visibility. Then add a "
"new child node to the root and in the **Create New Node** dialog search for "
"\"GDExample\", the name of our class, as it should be listed there. If it "
"isn't, it means that Godot didn't load the extension properly, so try "
"restarting the editor and retrace the steps to see if anything went missing."
msgstr ""
"Після збереження файлу поверніться до редактора. Godot має автоматично "
"завантажити розширення. Нічого не буде видно, оскільки наше розширення "
"реєструє лише новий клас. Щоб використовувати цей клас, додайте ``Node2D`` "
"як корінь сцени. Перемістіть його в середину вікна перегляду для кращої "
"видимості. Потім додайте новий дочірній вузол до кореня та в діалоговому "
"вікні **Створити новий вузол** знайдіть «GDExample», ім’я нашого класу, яке "
"там має бути зазначено. Якщо ні, це означає, що Godot не завантажив "
"розширення належним чином, тому спробуйте перезапустити редактор і повторити "
"кроки, щоб побачити, чи щось не пропало."

msgid ""
"Our custom class is derived from ``Sprite2D``, so it has a **Texture** "
"property in the Inspector. Set this to the ``icon.svg`` file that Godot "
"handily created for us when making the project. Save this scene as "
"``main.tscn`` and run it. You may want to set it as the main scene for "
"convenience."
msgstr ""
"Наш спеціальний клас походить від ``Sprite2D``, тому він має властивість "
"**Texture** в інспекторі. Установіть для цього файл ``icon.svg``, який Godot "
"зручно створив для нас під час створення проекту. Збережіть цю сцену як "
"``main.tscn`` і запустіть її. Ви можете встановити його як основну сцену для "
"зручності."

msgid ""
"Voilà! We have a custom node running in Godot. However, it does not do "
"anything and has nothing different than a regular ``Sprite2D`` node. We will "
"fix that next by adding custom methods and properties."
msgstr ""
"Вуаля! У нас є спеціальний вузол, який працює в Godot. Однак він нічого не "
"робить і нічим не відрізняється від звичайного вузла ``Sprite2D``. Далі ми "
"виправимо це, додавши спеціальні методи та властивості."

msgid "Custom methods"
msgstr "Спеціальні методи"

msgid ""
"A common thing in extensions is creating methods for the custom classes and "
"exposing those to the Godot API. We are going to create a couple of getters "
"and setters which are need for binding the properties afterwards."
msgstr ""
"Звичайна річ у розширеннях – це створення методів для користувальницьких "
"класів і надання їх API Godot. Ми збираємося створити пару геттерів і "
"сеттерів, які будуть потрібні для подальшого зв’язування властивостей."

msgid ""
"First, let's add the new fields in our struct to hold the values for "
"``amplitude`` and ``speed``, which we will use later on when creating the "
"behavior for the node. Add them to the ``gdexample.h`` file, changing the "
"``GDExample`` struct:"
msgstr ""
"По-перше, давайте додамо нові поля в нашу структуру для зберігання значень "
"для ``amplitude`` і ``speed``, які ми будемо використовувати пізніше під час "
"створення поведінки для вузла. Додайте їх до файлу ``gdexample.h``, змінивши "
"структуру ``GDExample``:"

msgid ""
"In the same file, add the declaration for the getters and setters, right "
"after the destructor."
msgstr ""
"У цьому ж файлі додайте оголошення для геттерів і сеттерів одразу після "
"деструктора."

msgid ""
"In the ``gdexample.c`` file, we will initialize these values in the "
"constructor and add the implementations for those new functions, which are "
"quite trivial:"
msgstr ""
"У файлі ``gdexample.c`` ми ініціалізуємо ці значення в конструкторі та "
"додамо реалізації для цих нових функцій, які є досить тривіальними:"

msgid ""
"To make those simple functions work when called by Godot, we will need some "
"wrappers to help us properly convert the data to and from the engine."
msgstr ""
"Щоб ці прості функції працювали, коли їх викликає Godot, нам знадобляться "
"деякі оболонки, які допоможуть нам належним чином конвертувати дані в "
"механізм і з нього."

msgid ""
"First, we will create wrappers for ``ptrcall``. This is what Godot uses when "
"the types of the values are known to be exact, which avoids using Variant. "
"We're gonna need two of those: one for the functions that take no arguments "
"and return a ``double`` (for the getters) and another for the functions that "
"take a single ``double`` argument and return nothing (for the setters)."
msgstr ""
"Спочатку ми створимо оболонки для ``ptrcall``. Це те, що Godot використовує, "
"коли відомо, що типи значень точні, що дозволяє уникнути використання "
"Variant. Нам знадобляться дві з них: одна для функцій, які не приймають "
"аргументів і повертають ``double`` (для геттерів), а інша для функцій, які "
"приймають один ``double`` аргумент і не повертають нічого (для сеттерів)."

msgid "Add the declarations to the ``api.h`` file:"
msgstr "Додайте оголошення до файлу ``api.h``:"

msgid ""
"Those two functions follow the ``GDExtensionClassMethodPtrCall`` type, as "
"defined in the ``gdextension_interface.h``. We use ``float`` as a name here "
"because in Godot the ``float`` type has double precision, so we keep this "
"convention."
msgstr ""
"Ці дві функції відповідають типу ``GDExtensionClassMethodPtrCall``, як "
"визначено в ``gdextension_interface.h``. Ми використовуємо ``float`` як "
"назву тут, оскільки в Godot тип ``float`` має подвійну точність, тому ми "
"дотримуємося цієї угоди."

msgid "Then we implement those functions in the ``api.c`` file:"
msgstr "Потім ми реалізуємо ці функції у файлі ``api.c``:"

msgid ""
"The ``method_userdata`` argument is a custom value that we give to Godot, in "
"this case we will set as the function pointer for the one we want to call. "
"So first we convert it to the function type, then we just call it by passing "
"the arguments when needed, or setting the return value."
msgstr ""
"Аргумент ``method_userdata`` — це користувацьке значення, яке ми надаємо "
"Godot. У цьому випадку ми встановимо вказівник на функцію для тієї, яку ми "
"хочемо викликати. Тож спочатку ми перетворюємо її на тип функції, а потім "
"просто викликаємо її, передаючи аргументи, коли потрібно, або встановлюючи "
"значення, що повертається."

msgid ""
"The ``p_instance`` argument contains the custom instance of our class, which "
"we gave with ``object_set_instance()`` when creating the object."
msgstr ""
"Аргумент ``p_instance`` містить спеціальний екземпляр нашого класу, який ми "
"передали за допомогою ``object_set_instance()`` під час створення об’єкта."

msgid ""
"``p_args`` is an array of arguments. Note this contains **pointers** to the "
"values. That's why we dereference it when passing to our functions. The "
"number of arguments will be declared when binding the function (which we "
"will do soon) and it will always include default ones if those exist."
msgstr ""
"``p_args`` - це масив аргументів. Зауважте, що це містить **вказівники** на "
"значення. Ось чому ми розіменовуємо його при переході до наших функцій. "
"Кількість аргументів буде оголошено під час зв’язування функції (що ми "
"зробимо незабаром), і вона завжди включатиме параметри за замовчуванням, "
"якщо вони існують."

msgid ""
"Finally, the ``r_ret`` is a pointer to the variable where the return value "
"needs to be set. Like the arguments, it will be the correct type as "
"declared. For the function that does not return, we have to avoid setting it."
msgstr ""
"Нарешті, ``r_ret`` є покажчиком на змінну, для якої потрібно встановити "
"значення, що повертається. Як і аргументи, це буде правильний тип, як "
"оголошено. Для функції, яка не повертає, ми повинні уникати її встановлення."

msgid ""
"Note how the type and argument counts are exact, so if we needed different "
"types, for example, we would have to create more wrappers. This could be "
"automated using some code generation, but this is out of the scope for this "
"tutorial."
msgstr ""
"Зверніть увагу, що підрахунок типів і аргументів точний, тому, наприклад, "
"якщо нам потрібні різні типи, нам доведеться створити більше обгорток. Це "
"можна автоматизувати за допомогою генерації коду, але це виходить за рамки "
"цього посібника."

msgid ""
"While the ``ptrcall`` functions are used when types are exact, sometimes "
"Godot cannot know if that's the case (when the call comes from a dynamically "
"typed language, such as GDScript). In those situations it uses regular "
"``call`` functions, so we need to provide those as well when binding."
msgstr ""
"Хоча функції ``ptrcall`` використовуються, коли типи є точними, іноді Godot "
"не може знати, чи це так (коли виклик надходить з мови з динамічним типом, "
"наприклад GDScript). У таких ситуаціях він використовує звичайні функції "
"``виклику``, тому нам також потрібно надати їх під час зв’язування."

msgid "Let's create two new wrappers in the ``api.h`` file:"
msgstr "Давайте створимо дві нові оболонки у файлі ``api.h``:"

msgid ""
"These follow the ``GDExtensionClassMethodCall`` type, which is a bit "
"different. First, you receive pointers to Variants instead of exact types. "
"There's also the amount of arguments and an error struct that you can set if "
"something goes wrong."
msgstr ""
"Вони йдуть за типом ``GDExtensionClassMethodCall``, який дещо відрізняється. "
"По-перше, ви отримуєте вказівники на варіанти замість точних типів. Існує "
"також кількість аргументів і структура помилок, які ви можете встановити, "
"якщо щось піде не так."

msgid ""
"In order to check the type and also extract interact with Variant, we will "
"need a few more functions from the GDExtension API. So let's expand our "
"wrapper structs:"
msgstr ""
"Щоб перевірити тип, а також витягнути взаємодію з Variant, нам знадобиться "
"ще кілька функцій з API GDExtension. Отже, давайте розширимо наші структури "
"оболонки:"

msgid ""
"The names say all about what those do. We have a couple of constructors to "
"create and extract a floating point value to and from a Variant. We also "
"have a couple of helpers to actually get those constructors, as well as a "
"function to find out the type of a Variant."
msgstr ""
"Назви говорять усе про те, чим вони займаються. У нас є кілька конструкторів "
"для створення та вилучення значення з плаваючою комою до та з Variant. У нас "
"також є кілька помічників, щоб фактично отримати ці конструктори, а також "
"функція, щоб дізнатися тип Variant."

msgid ""
"Let's get those from the API, like we did before, by changing the "
"``load_api()`` function in the ``api.c`` file:"
msgstr ""
"Давайте отримаємо їх з API, як ми робили раніше, змінивши функцію "
"``load_api()`` у файлі ``api.c``:"

msgid ""
"Now that we have these set, we can implement our call wrappers in the same "
"file:"
msgstr ""
"Тепер, коли ми маємо ці набори, ми можемо реалізувати наші оболонки викликів "
"у тому самому файлі:"

msgid ""
"These functions are a bit longer but easy to follow. First they check if the "
"argument count is as expected and if not they set the error struct and "
"return. For the one that has one parameter, it also checks if the argument "
"type is correct. This is important because mismatched types when extracting "
"from Variant can cause crashes."
msgstr ""
"Ці функції трохи довші, але їх легко використовувати. Спочатку вони "
"перевіряють, чи кількість аргументів відповідає очікуванням, а якщо ні, вони "
"встановлюють структуру помилки та повертають. Для того, що має один "
"параметр, він також перевіряє правильність типу аргументу. Це важливо, "
"оскільки невідповідні типи під час вилучення з Variant можуть спричинити "
"збої."

msgid ""
"Then it proceeds to extract the argument using the constructor we setup "
"before. The one with no arguments instead sets the return value after "
"calling the function. Note how they use a pointer to a ``double`` variable, "
"since this is what those constructors expect."
msgstr ""
"Потім він переходить до вилучення аргументу за допомогою конструктора, який "
"ми встановили раніше. Натомість без аргументів встановлюється значення, що "
"повертається після виклику функції. Зверніть увагу, як вони використовують "
"вказівник на змінну ``double``, оскільки це те, що ці конструктори очікують."

msgid ""
"Before we can actually bind our methods, we need a way to create "
"``GDExtensionPropertyInfo`` instances. While we could do them inside the "
"binding functions that we'll implement afterwards, it's easier to have a "
"helper for it since we'll need it multiple times, including for when we bind "
"properties."
msgstr ""
"Перш ніж ми зможемо прив’язати наші методи, нам потрібен спосіб створити "
"екземпляри ``GDExtensionPropertyInfo``. Хоча ми могли б виконати їх у "
"функціях зв’язування, які ми реалізуємо пізніше, простіше мати для цього "
"помічника, оскільки він нам знадобиться кілька разів, зокрема, коли ми "
"зв’язуємо властивості."

msgid "Let's create these two functions in the ``api.h`` file:"
msgstr "Давайте створимо ці дві функції у файлі ``api.h``:"

msgid ""
"The first one is a simplified version of the second since we usually don't "
"need all the arguments for the property and are okay with the defaults. Then "
"we also have a function to destruct the PropertyInfo since we need to create "
"Strings and StringNames that need to be properly disposed of."
msgstr ""
"Перший є спрощеною версією другого, оскільки зазвичай нам не потрібні всі "
"аргументи для властивості, і ми згодні з типовими значеннями. Крім того, у "
"нас є функція для знищення PropertyInfo, оскільки нам потрібно створити "
"рядки та імена рядків, від яких потрібно правильно позбутися."

msgid ""
"Speaking of which, we also need a way to create and destruct Strings, so "
"we'll make an addition to existing structs in this same file. We'll also get "
"a new API function for actually binding our custom method."
msgstr ""
"Говорячи про це, нам також потрібен спосіб створення та знищення рядків, "
"тому ми додамо доповнення до існуючих структур у цьому самому файлі. Ми "
"також отримаємо нову функцію API для фактичного зв’язування нашого "
"спеціального методу."

msgid ""
"Before implementing those, let's do a quick stop in the ``defs.h`` file and "
"include the size of the ``String`` type and a couple of enums:"
msgstr ""
"Перш ніж реалізувати їх, давайте коротко зупинимося у файлі ``defs.h`` і "
"додамо розмір типу ``String`` і кілька переліків:"

msgid ""
"While it's the same size as ``StringName``, it is more clear to use a "
"different name for it."
msgstr ""
"Хоча він має той самий розмір, що й ``StringName``, зрозуміліше "
"використовувати іншу назву для нього."

msgid ""
"The enums here are just helpers to give names to the numbers they represent. "
"The information about them is present in the ``extension_api.json`` file. "
"Here we just set up the ones we need for the tutorial, to keep it more "
"concise."
msgstr ""
"Переліки тут є лише помічниками, щоб дати назви числам, які вони "
"представляють. Інформація про них міститься у файлі ``extension_api.json``. "
"Тут ми просто встановили ті, які нам потрібні для підручника, щоб зробити "
"його більш лаконічним."

msgid ""
"Going now to the ``api.c``, we need to load the pointers to the new "
"functions we added to the API."
msgstr ""
"Переходячи до ``api.c``, нам потрібно завантажити покажчики на нові функції, "
"які ми додали до API."

msgid ""
"Then we can also implement the functions to create the ``PropertyInfo`` "
"struct."
msgstr ""
"Тоді ми також можемо реалізувати функції для створення структури "
"``PropertyInfo``."

msgid ""
"The simple version of ``make_property()`` just calls the more complete one "
"with a some default arguments. What those values mean exactly is out of the "
"scope of this tutorial, check the page about the :ref:`Object class "
"<doc_object_class>` for more details about binding methods and properties."
msgstr ""
"Проста версія ``make_property()`` просто викликає повнішу версію з деякими "
"аргументами за замовчуванням. Те, що саме означають ці значення, виходить за "
"рамки цього підручника. Перегляньте сторінку про :ref:`Object class "
"<doc_object_class>`, щоб дізнатися більше про методи зв’язування та "
"властивості."

msgid ""
"The complete version is more involved. First, it creates ``String``'s and "
"``StringName``'s for the needed fields, by allocating memory and calling "
"their constructors. Then it creates a ``GDExtensionPropertyInfo`` struct and "
"sets all the fields with the arguments provided. Finally it returns this "
"created struct."
msgstr ""
"Повна версія більш складна. По-перше, він створює ``String`` і "
"``StringName`` для необхідних полів шляхом виділення пам'яті та виклику "
"їхніх конструкторів. Потім він створює структуру ``GDExtensionPropertyInfo`` "
"і встановлює всі поля з наданими аргументами. Нарешті він повертає створену "
"структуру."

msgid ""
"The ``destruct_property()`` function is straightforward, it simply calls the "
"destructors for the created objects and frees their allocated memory."
msgstr ""
"Функція ``destruct_property()`` проста, вона просто викликає деструктори для "
"створених об’єктів і звільняє виділену для них пам’ять."

msgid ""
"Let's go back again to the header ``api.h`` to create the functions that "
"will actually bind the methods:"
msgstr ""
"Давайте знову повернемося до заголовка ``api.h``, щоб створити функції, які "
"фактично прив’язуватимуть методи:"

msgid "Then switch back to the ``api.c`` file to implement these:"
msgstr "Потім поверніться до файлу ``api.c``, щоб реалізувати ці:"

msgid ""
"Both functions are very similar. First, they create a ``StringName`` with "
"the method name. This is created in the stack since we don't need to keep it "
"after the function ends. Then they create local variables to hold the "
"``call_func`` and ``ptrcall_func``, pointing to the helper functions we "
"defined earlier."
msgstr ""
"Обидві функції дуже схожі. Спочатку вони створюють ``StringName`` з назвою "
"методу. Це створюється в стеку, оскільки нам не потрібно зберігати його "
"після завершення функції. Потім вони створюють локальні змінні для "
"зберігання ``call_func`` і ``ptrcall_func``, вказуючи на допоміжні функції, "
"які ми визначили раніше."

msgid ""
"In the next step they diverge a bit. The first one creates a property for "
"the return value, which has an empty name since it's not needed. The other "
"creates an array of properties for the arguments, which in this case has a "
"single element. This one also has an array of metadata, which can be used if "
"there's something special about the argument (e.g. if an ``int`` value is 32 "
"bits long instead of the default of 64 bits)."
msgstr ""
"На наступному етапі вони трохи розходяться. Перший створює властивість для "
"значення, що повертається, яке має порожнє ім’я, оскільки воно не потрібно. "
"Інший створює масив властивостей для аргументів, який у цьому випадку має "
"один елемент. Цей також має масив метаданих, які можна використовувати, якщо "
"в аргументі є щось особливе (наприклад, якщо значення ``int`` має 32 біти "
"замість 64 бітів за замовчуванням)."

msgid ""
"Afterwards, they create the ``GDExtensionClassMethodInfo`` with the required "
"fields for each case. Then they make a ``StringName`` for the class name, in "
"order to associate the method with the class. Next, they call the API "
"function to actually bind this method to the class. Finally, we destruct the "
"objects we created since they aren't needed anymore."
msgstr ""
"Після цього вони створюють ``GDExtensionClassMethodInfo`` з обов’язковими "
"полями для кожного випадку. Потім вони створюють ``StringName`` для імені "
"класу, щоб асоціювати метод із класом. Потім вони викликають функцію API, "
"щоб фактично прив’язати цей метод до класу. Нарешті, ми знищуємо створені "
"об’єкти, оскільки вони більше не потрібні."

msgid ""
"The bind helpers here use the call helpers we created earlier, so do note "
"that those call helpers only accept the Godot ``FLOAT`` type (which is "
"equivalent to ``double`` in C). If you intend to use this for other types, "
"you would need to check the type of the arguments and return type and select "
"an appropriate function callback. This is avoided here only to keep the "
"example from becoming even longer."
msgstr ""
"Помічники зв’язування тут використовують помічники викликів, які ми створили "
"раніше, тому зауважте, що ці помічники викликів приймають лише тип Godot "
"``FLOAT`` (який еквівалентний ``double`` у C). Якщо ви збираєтеся "
"використовувати це для інших типів, вам потрібно буде перевірити тип "
"аргументів і тип повернення та вибрати відповідний зворотний виклик функції. "
"Тут цього уникають лише для того, щоб приклад не став ще довшим."

msgid ""
"Now that we have the means to bind methods, we can actually do so in our "
"custom class. Go to the ``gdexample.c`` file and fill up the "
"``gdexample_class_bind_methods()`` function:"
msgstr ""
"Тепер, коли у нас є засоби зв’язування методів, ми можемо зробити це в "
"нашому спеціальному класі. Перейдіть до файлу ``gdexample.c`` і заповніть "
"функцію ``gdexample_class_bind_methods()``:"

msgid ""
"Since this function is already being called by the initialization process, "
"we can stop here. This function is much more straightforward after we "
"created all the infrastructure to make this work. You can see that "
"implementing the binding functions inline here would take some space and "
"also be quite repetitive. This also makes it easier to add another method in "
"the future."
msgstr ""
"Оскільки ця функція вже викликається процесом ініціалізації, ми можемо "
"зупинитися на цьому. Ця функція стала набагато простішою після того, як ми "
"створили всю інфраструктуру для її роботи. Ви бачите, що реалізація "
"вбудованих функцій зв’язування тут займе трохи місця, а також буде досить "
"повторюваною. Це також спрощує додавання іншого методу в майбутньому."

msgid ""
"If you compile the code and reopen the demo project, nothing will be "
"different at first, since we only added two new methods. To ensure those are "
"registered properly, you can search for ``GDExample`` in the editor help and "
"verify they are present in the documentation page."
msgstr ""
"Якщо ви скомпілюєте код і знову відкриєте демонстраційний проект, спочатку "
"нічого не зміниться, оскільки ми додали лише два нові методи. Щоб "
"переконатися, що вони зареєстровані належним чином, ви можете знайти "
"``GDExample`` у довідці редактора та перевірити їх присутність на сторінці "
"документації."

msgid "Custom properties"
msgstr "Спеціальні властивості"

msgid ""
"Since we now have the getter and setter for our properties already bound, we "
"can move forward to create actual properties that will be displayed in the "
"Godot editor inspector."
msgstr ""
"Оскільки ми вже зв’язали геттер і сеттер для наших властивостей, ми можемо "
"перейти до створення фактичних властивостей, які відображатимуться в "
"інспекторі редактора Godot."

msgid ""
"Given our extensive setup in the previous section, there are only a few "
"things needed to enable us to bind properties. First, let's get a new API "
"function in the ``api.h`` file:"
msgstr ""
"Враховуючи наше обширне налаштування в попередньому розділі, є лише кілька "
"речей, необхідних для того, щоб ми могли прив’язувати властивості. По-перше, "
"давайте отримаємо нову функцію API у файлі ``api.h``:"

msgid "Let's also declare a function here to bind properties:"
msgstr "Давайте також оголосимо тут функцію для зв’язування властивостей:"

msgid "In the ``api.c`` file, we can load the new API function:"
msgstr "У файлі ``api.c`` ми можемо завантажити нову функцію API:"

msgid "Then we can implement our new helper function in this same file:"
msgstr ""
"Тоді ми можемо реалізувати нашу нову допоміжну функцію в тому самому файлі:"

msgid ""
"This function is similar to the one for binding methods. The main difference "
"is that we don't need an extra struct since we can simply use the "
"``GDExtensionPropertyInfo`` that is created by our helper function, so it's "
"more straightforward. It only creates the ``StringName`` values from the C "
"strings, creates a property info struct using our helper, calls the API "
"function to register the property in the class and then destructs all the "
"objects we created."
msgstr ""
"Ця функція подібна до функції для методів прив’язки. Основна відмінність "
"полягає в тому, що нам не потрібна додаткова структура, оскільки ми можемо "
"просто використати ``GDExtensionPropertyInfo``, створений нашою допоміжною "
"функцією, тому це більш просто. Він лише створює значення ``StringName`` із "
"рядків C, створює структуру інформації про властивості за допомогою нашого "
"помічника, викликає функцію API для реєстрації властивості в класі, а потім "
"знищує всі створені нами об’єкти."

msgid ""
"With this done, we can extend the ``gdexample_class_bind_methods()`` "
"function in the ``gdexample.c`` file:"
msgstr ""
"Зробивши це, ми можемо розширити функцію ``gdexample_class_bind_methods()`` "
"у файлі ``gdexample.c``:"

msgid ""
"If you build the extension with ``scons``, you'll see in the Godot editor "
"the new property shown not only on the documentation page for the custom "
"class but also in the Inspector dock when the ``GDExample`` node is selected."
msgstr ""
"Якщо ви створюєте розширення за допомогою ``scons``, ви побачите в редакторі "
"Godot нову властивість, показану не лише на сторінці документації для "
"спеціального класу, а й у доці Inspector, коли вибрано вузол ``GDExample``."

msgid "Binding virtual methods"
msgstr "Прив'язка віртуальних методів"

msgid ""
"Our custom node now has properties to influence how it operates, but it "
"still doesn't do anything. In this section, we will bind the virtual "
"method :ref:`_process() <class_Node_private_method__process>` and make our "
"custom sprite move a little bit."
msgstr ""
"Наш спеціальний вузол тепер має властивості впливати на його роботу, але він "
"все ще нічого не робить. У цьому розділі ми прив’яжемо віртуальний "
"метод :ref:`_process() <class_Node_private_method__process>` і змусимо наш "
"власний спрайт трохи рухатися."

msgid ""
"In the ``gdexample.h`` file, let's add a function that represents the custom "
"``_process()`` method:"
msgstr ""
"У файл ``gdexample.h`` давайте додамо функцію, яка представляє спеціальний "
"метод ``_process()``:"

msgid ""
"We'll also add a \"private\" field to keep track of the time passed in our "
"custom struct. This is \"private\" only in the sense that it won't be bound "
"to the Godot API, even though it is public in the C side, given the language "
"lacks access modifiers."
msgstr ""
"Ми також додамо поле «приватне» для відстеження часу, витраченого в нашій "
"користувацькій структурі. Це «приватне» лише в тому сенсі, що воно не буде "
"прив’язане до Godot API, навіть якщо воно загальнодоступне на стороні C, "
"враховуючи, що мова не має модифікаторів доступу."

msgid ""
"On the counterpart source file ``gdexample.c`` we need to initialize the new "
"field in the constructor:"
msgstr ""
"У відповідному вихідному файлі ``gdexample.c`` нам потрібно ініціалізувати "
"нове поле в конструкторі:"

msgid ""
"Then we can create the simplest implementation for the ``_process`` method:"
msgstr ""
"Тоді ми можемо створити найпростішу реалізацію для методу ``_process``:"

msgid ""
"For now it will do nothing but update the private field we created. We'll "
"come back to this after the method is properly bound."
msgstr ""
"Наразі він не робитиме нічого, крім оновлення приватного поля, яке ми "
"створили. Ми повернемося до цього після належного зв’язування методу."

msgid ""
"Virtual methods are a bit different from the regular bindings. Instead of "
"explicitly registering the method itself, we'll register a special function "
"that Godot will call to ask if a particular virtual method is implemented in "
"our extension. The engine will pass a ``StringName`` as an argument so, "
"following the spirit of this tutorial, we'll create a helper function to "
"check if it is equal to a C string."
msgstr ""
"Віртуальні методи дещо відрізняються від звичайних прив’язок. Замість того, "
"щоб явно реєструвати сам метод, ми зареєструємо спеціальну функцію, яку "
"Godot викличе, щоб запитати, чи реалізовано конкретний віртуальний метод у "
"нашому розширенні. Механізм передаватиме ``StringName`` як аргумент, тому, "
"дотримуючись духу цього підручника, ми створимо допоміжну функцію, щоб "
"перевірити, чи дорівнює він рядку C."

msgid "Let's add the declaration to the ``api.h`` file:"
msgstr "Давайте додамо оголошення до файлу ``api.h``:"

msgid ""
"We'll also add a new struct to this file, to hold function pointers for "
"custom operators:"
msgstr ""
"Ми також додамо нову структуру до цього файлу, щоб утримувати покажчики "
"функцій для спеціальних операторів:"

msgid ""
"Then in the ``api.c`` file we'll load the function pointer from the API:"
msgstr "Потім у файл ``api.c`` ми завантажимо вказівник на функцію з API:"

msgid ""
"As you can see we need a new local helper here in order to grab the function "
"pointer for the operator."
msgstr ""
"Як бачите, нам потрібен новий локальний помічник, щоб отримати покажчик "
"функції для оператора."

msgid ""
"With this handy, we can easily create our comparison function in the same "
"file:"
msgstr ""
"Завдяки цьому ми можемо легко створити нашу функцію порівняння в тому самому "
"файлі:"

msgid ""
"This function creates a ``StringName`` from the argument, compares with the "
"other one using the operator function pointer, and returns the result. Note "
"that the return value for the operator is passed as an out reference, this "
"is a common thing in the API."
msgstr ""
"Ця функція створює ``StringName`` з аргументу, порівнює з іншим за допомогою "
"покажчика операторної функції та повертає результат. Зверніть увагу, що "
"значення, що повертається для оператора, передається як вихідне посилання, "
"це звичайна річ в API."

msgid ""
"Let's go back to the ``gdexample.h`` file and add a couple of functions that "
"will be used as the callbacks for the Godot API:"
msgstr ""
"Давайте повернемося до файлу ``gdexample.h`` і додамо кілька функцій, які "
"використовуватимуться як зворотні виклики для Godot API:"

msgid ""
"There are actually two ways of registering virtual methods. Only one has the "
"``get`` part, in which you give Godot a properly crafted function pointer "
"which will be called. For this we would need to create another helper for "
"each virtual method, something that is not very convenient. Instead, we use "
"the second method which allows us to return any data, and then Godot will "
"call a second callback and give us back this data along with the call "
"information. We can simply give our own function pointer as custom data and "
"then have a single callback for all virtual methods. Although in this "
"example we will only use it for one method, this way is simpler to expand."
msgstr ""
"Фактично існує два способи реєстрації віртуальних методів. Лише один має "
"частину ``get``, у якій ви надаєте Godot правильно створений покажчик на "
"функцію, яка буде викликана. Для цього нам потрібно було б створити ще "
"одного помічника для кожного віртуального методу, що не дуже зручно. Замість "
"цього ми використовуємо другий метод, який дозволяє повертати будь-які дані, "
"а потім Godot викличе другий зворотний виклик і поверне нам ці дані разом з "
"інформацією про виклик. Ми можемо просто надати наш власний покажчик на "
"функцію як власні дані, а потім мати єдиний зворотний виклик для всіх "
"віртуальних методів. Хоча в цьому прикладі ми будемо використовувати його "
"лише для одного методу, цей спосіб простіше розширити."

msgid "So let's implement those two functions in the ``gdexample.c`` file:"
msgstr "Отже, давайте реалізуємо ці дві функції у файлі ``gdexample.c``:"

msgid ""
"Those functions are also quite straightforward after making all the helpers "
"previously."
msgstr ""
"Ці функції також досить прості після попереднього створення всіх помічників."

msgid ""
"For the first one, we simply check if the function name requested is "
"``_process`` and if it is we return a function pointer to our implementation "
"of it. Otherwise we return ``NULL``, signaling that the method is not being "
"overridden. We don't use the ``p_class_userdata`` here since this function "
"is meant only for one class and we don't have any data associated with it."
msgstr ""
"Для першого ми просто перевіряємо, чи ім’я запитуваної функції є "
"``_process``, і якщо це так, ми повертаємо вказівник функції на нашу її "
"реалізацію. В іншому випадку ми повертаємо ``NULL``, сигналізуючи, що метод "
"не перевизначено. Ми не використовуємо тут ``p_class_userdata``, оскільки ця "
"функція призначена лише для одного класу, і ми не маємо жодних даних, "
"пов’язаних з ним."

msgid ""
"The second one is similar. If it is the ``_process()`` method, it uses the "
"given function pointer to call the ``ptrcall`` helper, passing the call "
"arguments forward. Otherwise it simply does nothing, since we don't have any "
"other virtual methods being implemented."
msgstr ""
"Другий схожий. Якщо це метод ``_process()``, він використовує заданий "
"покажчик на функцію для виклику помічника ``ptrcall``, передаючи аргументи "
"виклику вперед. Інакше він просто нічого не робить, оскільки у нас немає "
"інших реалізованих віртуальних методів."

msgid ""
"The only thing missing is using those callbacks when the class is "
"registered. Go to the ``init.c`` file and change the ``class_info`` "
"initialization to include those, replacing the ``NULL`` value used "
"previously:"
msgstr ""
"Єдине, чого не вистачає, це використання цих зворотних викликів під час "
"реєстрації класу. Перейдіть до файлу ``init.c`` і змініть ініціалізацію "
"``class_info``, щоб включити їх, замінивши значення ``NULL``, яке "
"використовувалося раніше:"

msgid ""
"This is enough to bind the virtual method. If you build the extension and "
"run the demo project again, the ``_process()`` function will be called. You "
"just won't be able to tell since the function itself does nothing visible. "
"We will solve this now by making the custom node move following a pattern."
msgstr ""
"Цього достатньо для прив'язки віртуального методу. Якщо ви створите "
"розширення та знову запустите демонстраційний проект, буде викликана функція "
"``_process()``. Ви просто не зможете сказати, оскільки сама функція не "
"робить нічого видимого. Зараз ми вирішимо цю проблему, змусивши настроюваний "
"вузол рухатися за зразком."

msgid ""
"In order to make our node do stuff, we'll need to call Godot methods. Not "
"only the GDExtension API functions as we've being doing so far, but actual "
"engine methods, as we would do with scripting. This naturally requires some "
"extra setup."
msgstr ""
"Щоб змусити наш вузол щось робити, нам потрібно буде викликати методи Godot. "
"Функціонує не лише API GDExtension, як ми це робили досі, а й фактичні "
"методи двигуна, як ми робили б із сценаріями. Для цього, звичайно, потрібні "
"додаткові налаштування."

msgid ""
"First, let's add :ref:`class_Vector2` to our ``defs.h`` file, so we can use "
"it in our method:"
msgstr ""
"По-перше, давайте додамо :ref:`class_Vector2` до нашого файлу ``defs.h``, "
"щоб ми могли використовувати його в нашому методі:"

msgid ""
"The ``REAL_T_IS_DOUBLE`` define is only needed if your Godot version was "
"built with double precision support, which is not the default."
msgstr ""
"Визначення ``REAL_T_IS_DOUBLE`` потрібне, лише якщо ваша версія Godot була "
"створена з підтримкою подвійної точності, яка не є типовою."

msgid ""
"Now, in the ``api.h`` file, we'll add few things to the API structs, "
"including a new one for holding engine methods to call."
msgstr ""
"Тепер у файлі ``api.h`` ми додамо кілька речей до структур API, включно з "
"новою для утримання методів двигуна для виклику."

msgid ""
"Then in the ``api.c`` file we can grab the function pointers from Godot:"
msgstr ""
"Потім у файлі ``api.c`` ми можемо отримати вказівники на функції з Godot:"

msgid ""
"The only noteworthy part here is the ``Vector2`` constructor, for which we "
"request the index ``3``. Since there are multiple constructors with "
"different kinds of arguments, we need to specify which one we want. In this "
"case we're getting the one that takes two float numbers as the ``x`` and "
"``y`` coordinates, hence the name. This index can be retrieved from the "
"``extension_api.json`` file. Note we also need a new local helper to get it."
msgstr ""
"Єдиною вартою уваги тут є конструктор ``Vector2``, для якого ми запитуємо "
"індекс ``3``. Оскільки існує кілька конструкторів з різними типами "
"аргументів, нам потрібно вказати, який з них нам потрібен. У цьому випадку "
"ми отримуємо той, який приймає два числа з плаваючою точкою як координати "
"``x`` і ``y``, звідки і назва. Цей індекс можна отримати з файлу "
"``extension_api.json``. Зверніть увагу, що нам також потрібен новий місцевий "
"помічник, щоб отримати його."

msgid ""
"Be aware that we don't get anything for the methods struct here. This is "
"because this function is called too early in the initialization process, so "
"classes won't be properly registered yet."
msgstr ""
"Майте на увазі, що тут ми нічого не отримуємо для структури методів. Це "
"тому, що ця функція викликається занадто рано в процесі ініціалізації, тому "
"класи ще не будуть належним чином зареєстровані."

msgid ""
"Instead, we're gonna use the initialization level callback to grab those "
"when we are registering our custom class. Add this to the ``init.c`` file:"
msgstr ""
"Замість цього ми будемо використовувати зворотний виклик рівня "
"ініціалізації, щоб отримати їх під час реєстрації нашого спеціального класу. "
"Додайте це до файлу ``init.c``:"

msgid ""
"Here we create ``StringName``'s for the class and method we want to get, "
"then use the GDExtension API to retrieve their ``MethodBind``, which is an "
"object that represents the bound method. We get the ``set_position`` method "
"from ``Node2D`` since this is where it was registered, even though we're "
"going to use it in a ``Sprite2D``, a derived class."
msgstr ""
"Тут ми створюємо ``StringName`` для класу та методу, які ми хочемо отримати, "
"а потім використовуємо API GDExtension, щоб отримати їх ``MethodBind``, який "
"є об’єктом, який представляє зв’язаний метод. Ми отримуємо метод "
"``set_position`` від ``Node2D``, оскільки саме тут він був зареєстрований, "
"навіть якщо ми збираємося використовувати його в ``Sprite2D``, похідному "
"класі."

msgid ""
"The seemingly random number for getting the bind is actually a hash of the "
"method signature. This allows Godot to match the method you're requesting "
"even if in a future Godot version this signature changes, by providing a "
"compatibility method that matches what you're asking for. This is one of the "
"systems that allow the engine to load extensions made for previous versions. "
"You can get the value of this hash from the ``extension_api.json`` file."
msgstr ""
"Здавалося б, випадкове число для отримання прив'язки насправді є хешем "
"сигнатури методу. Це дозволяє Godot відповідати методу, який ви запитуєте, "
"навіть якщо в майбутній версії Godot цей підпис зміниться, надаючи метод "
"сумісності, який відповідає тому, що ви просите. Це одна із систем, яка "
"дозволяє двигуну завантажувати розширення, створені для попередніх версій. "
"Ви можете отримати значення цього хешу з файлу ``extension_api.json``."

msgid ""
"With all that, we can finally implement our custom ``_process()`` method in "
"the ``gdexample.c`` file:"
msgstr ""
"З усім цим ми нарешті можемо реалізувати наш спеціальний метод "
"``_process()`` у файлі ``gdexample.c``:"

msgid ""
"After updating the time passed scaled by the ``speed`` property, it creates "
"``x`` and ``y`` values based on that, also modulated by the ``amplitude`` "
"property. This is what will give the pattern effect. The ``math.h`` header "
"is needed for the ``sin()`` and ``cos()`` functions used here."
msgstr ""
"Після оновлення витраченого часу, масштабованого властивістю ``speed``, він "
"створює на основі цього значення ``x`` і ``y``, також модульовані "
"властивістю ``amplitude``. Саме це дасть ефект візерунка. Заголовок "
"``math.h`` потрібен для функцій ``sin()`` і ``cos()``, які тут "
"використовуються."

msgid ""
"Then it sets up an array of arguments to construct a ``Vector2``, followed "
"by calling the constructor. It sets up another array of arguments and use it "
"to call the ``set_position()`` method via the bind we acquired previously."
msgstr ""
"Потім він встановлює масив аргументів для побудови ``Vector2``, після чого "
"викликається конструктор. Він встановлює інший масив аргументів і "
"використовує його для виклику методу ``set_position()`` через прив’язку, яку "
"ми отримали раніше."

msgid "Since nothing here allocates any memory, there's not a need to cleanup."
msgstr "Оскільки тут ніщо не виділяє пам’ять, немає необхідності очищати."

msgid ""
"Now we can build the extension again and reopen Godot. Even in the editor "
"you'll see the custom sprite moving."
msgstr ""
"Тепер ми можемо знову побудувати розширення та знову відкрити Godot. Навіть "
"у редакторі ви побачите рух спеціального спрайту."

msgid ""
"Try changing the **Speed** and **Amplitude** properties and see how the "
"sprite react."
msgstr ""
"Спробуйте змінити властивості **Speed** і **Amplitude** і подивіться, як "
"відреагує спрайт."

msgid "Registering and emitting a signal"
msgstr "Реєстрація та випромінювання сигналу"

msgid ""
"To complete this tutorial, let's see how you can register a custom signal "
"and emit it when appropriate. As you might have guessed, we'll need a few "
"more function pointers from the API and more helper functions."
msgstr ""
"Щоб завершити цей підручник, давайте подивимося, як можна зареєструвати "
"спеціальний сигнал і випромінювати його, коли це необхідно. Як ви могли "
"здогадатися, нам знадобиться ще кілька покажчиків на функції з API та більше "
"допоміжних функцій."

msgid ""
"In the ``api.h`` file we're adding two things. One is an API function to "
"register a signal, the other is a helper function to wrap the signal binding."
msgstr ""
"У файлі ``api.h`` ми додаємо дві речі. Одна — це функція API для реєстрації "
"сигналу, інша — допоміжна функція для обгортання зв'язування сигналу."

msgid ""
"In this case we only have a version for one argument, since it's what we're "
"going to use."
msgstr ""
"У цьому випадку ми маємо версію лише для одного аргументу, оскільки це те, "
"що ми збираємося використовувати."

msgid ""
"Moving to the ``api.c`` file, we can load this new function pointer and "
"implement the helper:"
msgstr ""
"Переходячи до файлу ``api.c``, ми можемо завантажити цей новий покажчик на "
"функцію та реалізувати помічник:"

msgid ""
"This one is very similar to the function to bind methods. The main "
"difference is that we don't need to fill another struct, we just pass the "
"needed names and the array of arguments. The ``1`` at the end means the "
"amount of arguments the signal provides."
msgstr ""
"Ця функція дуже схожа на функцію зв’язування методів. Основна відмінність "
"полягає в тому, що нам не потрібно заповнювати іншу структуру, ми просто "
"передаємо необхідні імена та масив аргументів. ``1`` в кінці означає "
"кількість аргументів, які надає сигнал."

msgid "With this we can bind the signal in ``gdexample.c``:"
msgstr "За допомогою цього ми можемо зв’язати сигнал у ``gdexample.c``:"

msgid ""
"In order to emit a signal, we need to call the :ref:`emit_signal() "
"<class_Object_method_emit_signal>` method on our custom node. Since this is "
"a ``vararg`` function (meaning it takes any amount of arguments), we cannot "
"use ``ptrcall``. To do a regular call, we have to create Variants, which "
"require a few more steps of plumbing to get done."
msgstr ""
"Щоб подати сигнал, нам потрібно викликати метод :ref:`emit_signal() "
"<class_Object_method_emit_signal>` на нашому спеціальному вузлі. Оскільки це "
"функція ``vararg`` (це означає, що вона приймає будь-яку кількість "
"аргументів), ми не можемо використовувати ``ptrcall``. Щоб здійснити "
"звичайний дзвінок, ми маємо створити варіанти, для виконання яких потрібно "
"виконати ще кілька кроків."

msgid "First, in the ``defs.h`` file we create a definition for Variant:"
msgstr "Спочатку у файлі ``defs.h`` ми створюємо визначення для Variant:"

msgid ""
"We first set the size of Variant together with the size of Vector2 that we "
"added before. Then we use it to create an opaque struct that is enough to "
"hold the Variant data. Again, we set the size for double precision builds as "
"a fallback, since by the official Godot builds use single precision."
msgstr ""
"Спочатку ми встановили розмір Variant разом із розміром Vector2, який ми "
"додали раніше. Потім ми використовуємо його для створення непрозорої "
"структури, достатньої для зберігання даних Variant. Знову ж таки, ми "
"встановлюємо розмір для збірок подвійної точності як запасний варіант, "
"оскільки офіційні збірки Godot використовують одинарну точність."

msgid ""
"The ``emit_signal()`` function will be called with two arguments. The first "
"is the name of the signal to be emitted and the second is the argument we're "
"passing to the signal connections, which is a Vector2 as we declared when "
"binding it. So we're gonna create a helper function that can call a "
"MethodBind with these types. Even though it does return something (an error "
"code), we don't need to deal with it, so for now we're just going to ignore "
"it."
msgstr ""
"Функція ``emit_signal()`` буде викликана з двома аргументами. Перший — це "
"ім’я сигналу, який буде передано, а другий — це аргумент, який ми передаємо "
"сигнальним з’єднанням, який є Vector2, як ми оголосили під час його "
"зв’язування. Отже, ми створимо допоміжну функцію, яка може викликати "
"MethodBind із цими типами. Незважаючи на те, що він повертає щось (код "
"помилки), нам не потрібно мати справу з цим, тому поки що ми просто "
"збираємося його ігнорувати."

msgid ""
"In the ``api.h``, we're adding a few things to the existing structs, plus a "
"new helper function for the call:"
msgstr ""
"У ``api.h`` ми додаємо кілька речей до існуючих структур, а також нову "
"допоміжну функцію для виклику:"

msgid ""
"Now let's switch to the ``api.c`` file to load these new function pointers "
"and implement the helper function."
msgstr ""
"Тепер давайте перейдемо до файлу ``api.c``, щоб завантажити ці нові "
"покажчики на функції та реалізувати допоміжну функцію."

msgid ""
"This helper function has some boilerplate code but is quite straightforward. "
"It sets up the two arguments inside stack allocated Variants, then creates "
"an array with pointers to those. It also sets up another Variant to keep the "
"return value, which we don't need to construct since the call expects it to "
"be uninitialized."
msgstr ""
"Ця допоміжна функція має шаблонний код, але є досить простою. Він встановлює "
"два аргументи всередині виділених стеком варіантів, а потім створює масив із "
"покажчиками на них. Він також встановлює інший Variant для збереження "
"повертаного значення, яке нам не потрібно створювати, оскільки виклик "
"очікує, що воно буде неініціалізованим."

msgid ""
"Then it actually calls the MethodBind using the instance we provided and the "
"arguments. The ``NULL`` at the end would be a pointer to a "
"``GDExtensionCallError`` struct. This can be used to treat potential errors "
"when calling the functions (such as wrong arguments). For the sake of "
"simplicity we're not gonna handle that here."
msgstr ""
"Потім він фактично викликає MethodBind, використовуючи наданий нами "
"екземпляр і аргументи. ``NULL`` у кінці буде вказівником на структуру "
"``GDExtensionCallError``. Це можна використовувати для лікування потенційних "
"помилок під час виклику функцій (наприклад, неправильні аргументи). Заради "
"простоти ми не будемо розглядати це тут."

msgid ""
"At the end we need to destruct the Variants we created. While technically "
"the Vector2 one does not require destructing, it is clearer to cleanup "
"everything."
msgstr ""
"Наприкінці нам потрібно знищити Варіанти, які ми створили. Хоча технічно "
"Vector2 не потребує знищення, зрозуміліше очистити все."

msgid ""
"We also need to load the MethodBind, which we'll do in the ``init.c`` file, "
"right after loading the one for the ``set_position`` method we did before:"
msgstr ""
"Нам також потрібно завантажити MethodBind, що ми зробимо у файлі ``init.c`` "
"одразу після завантаження методу ``set_position``, який ми робили раніше:"

msgid ""
"Note that we reuse the ``native_class_name`` and ``method_name`` variables "
"here, so we don't need to declare new ones."
msgstr ""
"Зверніть увагу, що тут ми повторно використовуємо змінні "
"``native_class_name`` і ``method_name``, тому нам не потрібно оголошувати "
"нові."

msgid ""
"Now go to the ``gdexample.h`` file where we're going to add a couple of "
"fields:"
msgstr ""
"Тепер перейдіть до файлу ``gdexample.h``, де ми збираємося додати кілька "
"полів:"

msgid ""
"The first one will store the time passed since the last signal was emitted, "
"since we'll be doing so at regular intervals. The other is just to cache the "
"signal name so we don't need to create a new StringName every time."
msgstr ""
"Перший зберігає час, що минув з моменту надходження останнього сигналу, "
"оскільки ми будемо робити це через регулярні проміжки часу. Інший — просто "
"кешувати назву сигналу, щоб нам не потрібно було щоразу створювати нове "
"StringName."

msgid ""
"In the source ``gdexample.c`` file we can change the constructor and "
"destructor to deal with the new fields:"
msgstr ""
"У вихідному файлі ``gdexample.c`` ми можемо змінити конструктор і деструктор "
"для роботи з новими полями:"

msgid "It is important to destruct the StringName to avoid memory leaks."
msgstr "Важливо знищити StringName, щоб уникнути витоків пам’яті."

msgid ""
"Now we can add to the ``gdexample_class_process()`` function to actually "
"emit the signal:"
msgstr ""
"Тепер ми можемо додати до функції ``gdexample_class_process()``, щоб "
"фактично видавати сигнал:"

msgid ""
"This updates the time passed for the signal emission and, if it is over one "
"second it calls the ``emit_signal()`` function on the current instance, "
"passing the name of the signal and the new position as arguments."
msgstr ""
"Це оновлює час, витрачений на випромінювання сигналу, і, якщо він перевищує "
"одну секунду, викликає функцію ``emit_signal()`` для поточного екземпляра, "
"передаючи назву сигналу та нову позицію як аргументи."

msgid ""
"Now we're done with our C GDExtension. Build it once more and reopen the "
"demo project in the editor."
msgstr ""
"Тепер ми закінчили з нашим C GDExtension. Знову створіть його та знову "
"відкрийте демонстраційний проект у редакторі."

msgid ""
"In the documentation page for ``GDExample`` you can see the new signal we "
"bound:"
msgstr ""
"На сторінці документації для ``GDExample`` ви можете побачити новий "
"зв’язаний сигнал:"

msgid ""
"To check it's working, let's add a small script to the root node, parent of "
"our custom one, that prints the position to the output every time it "
"receives the signal:"
msgstr ""
"Щоб перевірити, чи він працює, давайте додамо невеликий сценарій до "
"кореневого вузла, батьківського для нашого спеціального вузла, який друкує "
"позицію на виході кожного разу, коли отримує сигнал:"

msgid ""
"Run the project and you can observe the values being printed in the Output "
"dock in the editor:"
msgstr ""
"Запустіть проект, і ви зможете спостерігати за значеннями, які друкуються в "
"док-станції «Вивід» у редакторі:"

msgid "Conclusion"
msgstr "Висновки"

msgid ""
"This tutorial shows a basic extension with custom methods, properties, and "
"signals. While it does require a good amount of boilerplate, it can scale "
"well by creating helper functions to handle the tedious tasks."
msgstr ""
"У цьому підручнику показано базове розширення з власними методами, "
"властивостями та сигналами. Хоча для цього потрібна достатня кількість "
"шаблонів, його можна добре масштабувати, створюючи допоміжні функції для "
"вирішення нудних завдань."

msgid ""
"This should serve as a good basis to understand the GDExtension API and as a "
"starting point to create custom binding generators. In fact, it would be "
"possible to create bindings for C using such type of generator, making the "
"actual coding look more like the ``gdexample.c`` file in this example, which "
"is quite straightforward and not very verbose."
msgstr ""
"Це повинно послужити гарною основою для розуміння API GDExtension і "
"відправною точкою для створення спеціальних генераторів зв’язування. "
"Насправді можна було б створити зв’язки для C за допомогою такого типу "
"генератора, завдяки чому фактичне кодування виглядатиме більше як файл "
"``gdexample.c`` у цьому прикладі, який є досить простим і не дуже "
"багатослівним."

msgid ""
"If you want to create actual extensions, it is preferred to use the C++ "
"bindings instead, as it takes away all of the boilerplate from your code. "
"Check the :ref:`godot-cpp documentation <doc_godot_cpp>` to see how you can "
"do this."
msgstr ""
"Якщо ви хочете створювати фактичні розширення, краще використовувати "
"прив'язки C++, оскільки це позбавляє ваш код усіх шаблонів. Перегляньте "
"документацію :ref:`godot-cpp documentation <doc_godot_cpp>`, щоб дізнатися, "
"як це зробити."
