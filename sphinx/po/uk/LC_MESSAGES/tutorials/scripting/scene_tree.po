#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "Використання Дерева сцени"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"У попередніх уроках все оберталося навколо концепції вузлів. Сцени - це "
"колекції вузлів. Вони стають активними, як тільки входять у *дерево сцен*."

msgid "MainLoop"
msgstr "MainLoop (Головний цикл)"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Внутрішня робота Godot полягає в наступному. Існує клас :ref:`OS "
"<class_OS>`, який є єдиним екземпляром, який запускається на початку. Після "
"цього завантажуються всі драйвери, сервери, скриптові мови, система сцен "
"тощо."

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"Коли ініціалізація завершена, :ref:`OS <class_OS>` потрібно для "
"запуску :ref:`MainLoop <class_MainLoop>`. До цього моменту все це внутрішня "
"обробка (ви можете перевірити файл main/main.cpp у вихідному коді, якщо вам "
"стане колись цікаво побачити, як це працює всередині)."

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"Програма користувача, або гра, запускається в MainLoop. У цьому класі є "
"кілька методів для ініціалізації, простою (зворотний синхронізований кадр), "
"фіксації (фізичний синхронізований зворотний виклик) та введення. Однак це "
"низький рівень, і при розробці ігор в Godot, рідко має сенс писати власний "
"MainLoop."

msgid "SceneTree"
msgstr "Дерево Сцен"

msgid ""
"One of the ways to explain how Godot works is that it's a high-level game "
"engine over a low-level middleware."
msgstr ""
"Один із способів пояснити, як працює Godot, полягає в тому, що це "
"високорівневий ігровий движок над низькорівневим проміжним програмним "
"забезпеченням."

msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low-level API."
msgstr ""
"Система сцени — це ігровий механізм, тоді як :ref:`OS <class_OS>` і сервери "
"— низькорівневий API."

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"Система сцен забезпечує власний головний цикл для ОС, :ref:`SceneTree "
"<class_SceneTree>`. Він автоматично встановлюється і налаштовується під час "
"запуску сцени, не потрібно робити зайвих робіт."

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr ""
"Важливо знати, про наявність цього класу, оскільки він має кілька важливих "
"застосувань:"

msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"Він містить кореневий :ref:`Viewport <class_Viewport>`, до якого додається "
"сцена в якості нащадка, при першому відкритті, щоб стати частиною *Дерева "
"сцен* (докладніше про це далі)."

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr ""
"Він містить інформацію про групи і має засоби для виклику всіх вузлів групи, "
"або отримання їх списку."

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr ""
"Він містить деяку функціональність глобального стану, наприклад встановлення "
"режиму паузи, або вихід."

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by "
"calling :ref:`Node.get_tree() <class_Node_method_get_tree>`."
msgstr ""
"Коли вузол є частиною дерева сцен, сиглтон (одиночний "
"екземпляр) :ref:`SceneTree <class_SceneTree>` можна отримати, "
"викликавши :ref:`Node.get_tree() <class_Node_method_get_tree>`."

msgid "Root viewport"
msgstr "Кореневе вікно перегляду"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"Кореневе :ref:`Viewport (Вікно перегляду)<class_Viewport>` завжди "
"знаходиться у верхній частині сцени. З вузла його можна отримати двома "
"різними способами:"

msgid ""
"This node contains the main viewport. Anything that is a child of "
"a :ref:`Viewport <class_Viewport>` is drawn inside of it by default, so it "
"makes sense that the top of all nodes is always a node of this type "
"otherwise nothing would be seen."
msgstr ""
"Цей вузол містить головне вікно перегляду. Всі нащадки :ref:`Viewport "
"<class_Viewport>`, малюються всередині нього за замовчуванням, тому є сенс в "
"тому, щоб коренем всіх вузлів завжди був вузол такого типу, інакше нічого не "
"буде видно."

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"Хоча в сцені можуть створюватися інші вікна перегляду (для ефектів "
"розділеного екрана і подібних речей), це єдине, яке ніколи не створюється "
"користувачем. Воно створюється автоматично всередині SceneTree (дерева сцен)."

msgid "Scene tree"
msgstr "Дерево сцени"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr ""
"Коли вузол підключений безпосередньо, або опосередковано, до кореневого "
"вікна перегляду, він стає частиною *дерева сцен*."

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"Це означає, що, як пояснювалося в попередніх посібниках, він отримає "
"зворотні виклики ``_enter_tree()`` і ``_ready()`` (а також ``_exit_tree()``)."

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"Коли вузли входять у *дерево сцен*, вони стають активними. Вони отримують "
"доступ до всього необхідного для обробки, отримують введення, демонструють "
"2D та 3D-візуальні зображення, отримують та надсилають сповіщення, "
"відтворюють звуки тощо. Коли їх видаляють із дерева сцен , вони втрачають ці "
"здібності."

msgid "Tree order"
msgstr "Послідовність в дереві"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""
"Більшість операцій із вузлами в Godot, таких як малювання 2D, обробка чи "
"отримання сповіщень, виконуються в *деревоподібному порядку* або зверху "
"вниз, як це видно в редакторі (також відомий як обхід попереднього "
"замовлення):"

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""
"Наприклад, для верхнього вузла сцени спочатку викликається функція "
"``_process()``, потім для вузла під ним викликається функція ``_process()``, "
"потім вузол під ним і так далі."

msgid ""
"An important exception is the ``_ready()`` function: each parent node has "
"its ``_ready()`` function called only after all its child nodes have their "
"``_ready()`` functions called, so that the parent knows its children are "
"completely ready to be accessed. This is also known as post-order traversal. "
"In the above image, ``NameLabel`` would be notified first (but only after "
"its children, if it had any!), followed by ``Name``, etc., and ``Panel`` "
"would be notified last."
msgstr ""
"Важливим винятком є функція ``_ready()``: кожен батьківський вузол має свою "
"функцію ``_ready()``, що викликається лише після того, як усі його дочірні "
"вузли викликають свої функції ``_ready()``, так що батьківський вузол знає, "
"що його діти повністю готові до доступу. Це також відомо як обхід після "
"замовлення. На наведеному вище зображенні ``NameLabel`` сповіщатиметься "
"першим (але лише після своїх дочірніх елементів, якщо вони були!), потім "
"``Name`` тощо, а ``Panel`` буде сповіщено останнім."

msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""
"Порядок операцій також можна змінити за допомогою властивості вузла "
"``process_priority``. Вузли з меншим номером викликаються першими. "
"Наприклад, вузли з пріоритетами \"0, 1, 2, 3\" будуть викликані в такому "
"порядку зліва направо."

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "\"Становлення активним\" при вході в *дерево сцен*"

msgid "A scene is loaded from disk or created by scripting."
msgstr "Сцена завантажується з диска, або створюється скриптом."

msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any of its "
"descendants."
msgstr ""
"Кореневий вузол цієї сцени (лише один корінь, пам’ятаєте?) додається або як "
"дочірній елемент «кореневого» вікна перегляду (з SceneTree), або до будь-"
"якого з його нащадків."

msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"Кожен вузол щойно доданої сцени отримає сповіщення \"enter_tree\" "
"( зворотний виклик ``_enter_tree()`` у GDScript) у порядку зверху вниз "
"(обхід попереднього замовлення)."

msgid ""
"Every node will receive the \"ready\" notification ( ``_ready()`` callback "
"in GDScript) for convenience, once all its children have received the "
"\"ready\" notification (post-order traversal)."
msgstr ""
"Кожен вузол отримає сповіщення «готовий» ( зворотний виклик ``_ready()`` у "
"GDScript) для зручності, щойно всі його дочірні вузли отримають сповіщення "
"«готовий» (обхід після замовлення)."

msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"Коли сцену (або її частину) видалено, вони отримують сповіщення про \"вихід "
"зі сцени\" (зворотний виклик ``_exit_tree()`` у GDScript) у порядку знизу-"
"вгору (зворотному порядку зверху-вниз)."

msgid "Changing current scene"
msgstr "Зміна поточної сцени"

msgid ""
"After a scene is loaded, you may want to change this scene for another one. "
"One way to do this is to use the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` function:"
msgstr ""
"Після завантаження сцени ви можете змінити цю сцену на іншу. Один із "
"способів зробити це — використати "
"функцію :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>`:"

msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent "
"function :ref:`SceneTree.change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"
msgstr ""
"Замість використання шляхів до файлів можна також використовувати готові "
"ресурси :ref:`PackedScene <class_PackedScene>` за допомогою еквівалентної "
"функції :ref:`SceneTree.change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"

msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in the development of your game, it may be preferable to create proper "
"loading screens with progress bar, animated indicators or threaded "
"(background) loading. This must be done manually "
"using :ref:`doc_singletons_autoload` and :ref:`doc_background_loading`."
msgstr ""
"Це швидкі та корисні способи перемикання сцен, але мають недолік, що гра "
"зупинятиметься, доки нова сцена не буде завантажена та запущена. На певному "
"етапі розробки вашої гри може бути краще створити відповідні екрани "
"завантаження з індикатором прогресу, анімованими індикаторами або потоковим "
"(фоновим) завантаженням. Це потрібно зробити вручну за "
"допомогою :ref:`doc_singletons_autoload` і :ref:`doc_background_loading`."
