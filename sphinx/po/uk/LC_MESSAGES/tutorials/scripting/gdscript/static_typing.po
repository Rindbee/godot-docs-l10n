#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Static typing in GDScript"
msgstr "Статична типізація в GDScript"

msgid "In this guide, you will learn:"
msgstr "У цьому посібнику ви дізнаєтесь:"

msgid "how to use static typing in GDScript;"
msgstr "як використовувати статичну типізацію в GDScript;"

msgid "that static types can help you avoid bugs;"
msgstr "що статичні типи можуть допомогти вам уникнути помилок;"

msgid "that static typing improves your experience with the editor."
msgstr "що статичне введення тексту покращує роботу з редактором."

msgid ""
"Where and how you use this language feature is entirely up to you: you can "
"use it only in some sensitive GDScript files, use it everywhere, or don't "
"use it at all."
msgstr ""
"Де і як ви будете використовувати цю мовну функцію, залежить тільки від вас: "
"ви можете використовувати її тільки в деяких чутливих файлах GDScript, "
"використовувати її скрізь або не використовувати взагалі."

msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr ""
"Статичні типи можна використовувати для змінних, констант, функцій, "
"параметрів та типів повернення."

msgid "A brief look at static typing"
msgstr "Короткий огляд статичної типізації"

msgid ""
"With static typing, GDScript can detect more errors without even running the "
"code. Also type hints give you and your teammates more information as you're "
"working, as the arguments' types show up when you call a method. Static "
"typing improves editor autocompletion and :ref:`documentation "
"<doc_gdscript_documentation_comments>` of your scripts."
msgstr ""
"За допомогою статичної типізації GDScript може виявити більше помилок без "
"запуску кода. Підказки типів також надають вам і вашим товаришам по команді "
"більше інформації під час роботи, оскільки типи аргументів з’являються під "
"час виклику методу. Статичні типи покращують підказки редактора "
"та :ref:`documentation <doc_gdscript_documentation_comments>` ваших скриптів."

msgid ""
"Imagine you're programming an inventory system. You code an ``Item`` class, "
"then an ``Inventory``. To add items to the inventory, the people who work "
"with your code should always pass an ``Item`` to the ``Inventory.add()`` "
"method. With types, you can enforce this:"
msgstr ""
"Уявіть, що ви програмуєте систему управління інвентаризацією. Ви створюєте "
"клас ``Item``, а потім ``Inventory``. Щоб додати елементи до інвентаризації, "
"люди, які працюють з вашим кодом, повинні завжди передавати ``Item`` методу "
"``Inventory.add()``. За допомогою типів ви можете забезпечити це:"

msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options."
msgstr ""
"Статичні типи також дають вам кращі варіанти завершення коду. Нижче ви "
"можете побачити різницю між динамічним і статичним варіантами завершення."

msgid ""
"You've probably encountered a lack of autocomplete suggestions after a dot:"
msgstr ""
"Можливо, ви стикалися з відсутністю пропозицій автозаповнення після крапки:"

msgid "Completion options for dynamic typed code."
msgstr "Параметри завершення для динамічного введеного коду."

msgid ""
"This is due to dynamic code. Godot cannot know what value type you're "
"passing to the function. If you write the type explicitly however, you will "
"get all methods, properties, constants, etc. from the value:"
msgstr ""
"Це пов'язано з динамічним кодом. Godot не може знати, який тип значення ви "
"передаєте функції. Однак якщо ви напишете тип явно, ви отримаєте всі методи, "
"властивості, константи тощо зі значення:"

msgid "Completion options for static typed code."
msgstr "Параметри завершення для статичного коду."

msgid ""
"If you prefer static typing, we recommend enabling the **Text Editor > "
"Completion > Add Type Hints** editor setting. Also consider enabling `some "
"warnings <Warning system_>`_ that are disabled by default."
msgstr ""
"Якщо ви віддаєте перевагу статичному введенню, рекомендуємо ввімкнути "
"параметр редактора **Текстовий редактор > Завершення > Додати підказки "
"типу**. Також варто ввімкнути `деякі попередження <Warning system_>`_ які "
"вимкнено за замовчуванням."

msgid ""
"Also, typed GDScript improves performance by using optimized opcodes when "
"operand/argument types are known at compile time. More GDScript "
"optimizations are planned in the future, such as JIT/AOT compilation."
msgstr ""
"Крім того, типізований GDScript покращує продуктивність, використовуючи "
"оптимізовані коди операцій, коли типи операндів/аргументів відомі під час "
"компіляції. У майбутньому планується більше оптимізацій GDScript, наприклад "
"компіляція JIT/AOT."

msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you're working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people's code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"Загалом, типізоване програмування дає вам більш структурований досвід. Воно "
"допомагає запобігти помилкам і покращує само-документування аспектів ваших "
"скриптів. Це особливо корисно, коли ви працюєте в команді, або над "
"довготривалим проєктом: дослідження показали, що розробники проводять більшу "
"частину свого часу за читанням кодів інших людей, або скриптів, які вони "
"писали раніше і про які вже забули. Чим чіткіший і структурований код, тим "
"легше його зрозуміти, і тим швидше ви зможете рухатися далі."

msgid "How to use static typing"
msgstr "Як використовувати статичну типізацію"

msgid ""
"To define the type of a variable, parameter, or constant, write a colon "
"after the name, followed by its type. E.g. ``var health: int``. This forces "
"the variable's type to always stay the same:"
msgstr ""
"Щоб визначити тип змінної, параметра або константи, напишіть двокрапку після "
"назви, а потім її тип. Наприклад, ``var health: int``. Це змушує тип змінної "
"завжди залишатися незмінним:"

msgid ""
"Godot will try to infer types if you write a colon, but you omit the type:"
msgstr ""
"Godot спробує визначити типи, якщо ви поставите двокрапку, але пропустите "
"тип:"

msgid "There is no difference between ``=`` and ``:=`` for constants."
msgstr "Немає різниці між ``=`` і ``:=`` для констант."

msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer. Also, this is useful for typed arrays (like "
"``const A: Array[int] = [1, 2, 3]``), since untyped arrays are used by "
"default."
msgstr ""
"Вам не потрібно писати підказки типу для констант, оскільки Godot "
"автоматично встановлює їх із призначеного значення. Але ви можете зробити "
"це, щоб зробити зміст вашого коду зрозумілішим. Крім того, це корисно для "
"типізованих масивів (наприклад, ``const A: Array[int] = [1, 2, 3]``), "
"оскільки нетипізовані масиви використовуються за замовчуванням."

msgid "What can be a type hint"
msgstr "Що може бути підказкою типу"

msgid "Here is a complete list of what can be used as a type hint:"
msgstr "Ось повний список того, що можна використовувати як підказку типу:"

msgid ""
"``Variant``. Any type. In most cases this is not much different from an "
"untyped declaration, but increases readability. As a return type, forces the "
"function to explicitly return some value."
msgstr ""
"``Варіант``. Будь-який тип. У більшості випадків це мало чим відрізняється "
"від нетипової декларації, але покращує читабельність. Як тип повернення, "
"змушує функцію явно повертати певне значення."

msgid ""
"*(Only return type)* ``void``. Indicates that the function does not return "
"any value."
msgstr ""
"*(Тільки тип повернення)* ``void``. Вказує, що функція не повертає жодного "
"значення."

msgid ":ref:`Built-in types <doc_gdscript_builtin_types>`."
msgstr ":ref:`Built-in types <doc_gdscript_builtin_types>`."

msgid "Native classes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)."
msgstr "Нативні класи (``Object``, ``Node``, ``Area2D``, ``Camera2D`` тощо)."

msgid ":ref:`Global classes <doc_gdscript_basics_class_name>`."
msgstr ":ref:`Global classes <doc_gdscript_basics_class_name>`."

msgid ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."
msgstr ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."

msgid ""
"Global, native and custom named enums. Note that an enum type is just an "
"``int``, there is no guarantee that the value belongs to the set of enum "
"values."
msgstr ""
"Глобальні, нативні та власні іменовані переліки. Зауважте, що тип переліку – "
"це лише ``int``, немає гарантії, що значення належить до набору значень "
"переліку."

msgid ""
"Constants (including local ones) if they contain a preloaded class or enum."
msgstr ""
"Константи (включаючи локальні), якщо вони містять попередньо завантажений "
"клас або перелік."

msgid ""
"You can use any class, including your custom classes, as types. There are "
"two ways to use them in scripts. The first method is to preload the script "
"you want to use as a type in a constant:"
msgstr ""
"Ви можете використовувати будь-який клас, включаючи ваші власні класи, як "
"типи. Існує два способи їх використання в скриптах. Перший метод полягає в "
"попередньому завантаженні скрипта, який ви хочете використовувати як тип, у "
"константу:"

msgid ""
"The second method is to use the ``class_name`` keyword when you create. For "
"the example above, your ``rifle.gd`` would look like this:"
msgstr ""
"Другий метод полягає у використанні ключового слова ``class_name`` під час "
"створення. Для наведеного вище прикладу ваш ``rifle.gd`` виглядатиме так:"

msgid ""
"If you use ``class_name``, Godot registers the ``Rifle`` type globally in "
"the editor, and you can use it anywhere, without having to preload it into a "
"constant:"
msgstr ""
"Якщо ви використовуєте ``class_name``, Godot реєструє тип ``Rifle`` "
"глобально в редакторі, і ви можете використовувати його будь-де, без "
"необхідності попереднього завантаження його в константу:"

msgid "Specify the return type of a function with the arrow ``->``"
msgstr "Вкажіть тип повернення функції за допомогою стрілки ``->``"

msgid ""
"To define the return type of a function, write a dash and a right angle "
"bracket ``->`` after its declaration, followed by the return type:"
msgstr ""
"Щоб визначити тип повернення функції, напишіть тире та праву кутову дужку ``-"
">`` після її оголошення, а потім тип повернення:"

msgid ""
"The type ``void`` means the function does not return anything. You can use "
"any type, as with variables:"
msgstr ""
"Тип ``void`` означає, що функція нічого не повертає. Ви можете "
"використовувати будь-який тип, як і у випадку зі змінними:"

msgid "You can also use your own classes as return types:"
msgstr "Ви також можете використовувати власні класи як типи повернення:"

msgid "Covariance and contravariance"
msgstr "Коваріація та контраваріація"

msgid ""
"When inheriting base class methods, you should follow the `Liskov "
"substitution principle <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__."
msgstr ""
"Успадковуючи методи базового класу, слід дотримуватися `принципу підстановки "
"Ліскова <https://en.wikipedia.org/wiki/Liskov_substitution_principle>`__."

msgid ""
"**Covariance:** When you inherit a method, you can specify a return type "
"that is more specific (**subtype**) than the parent method."
msgstr ""
"**Коваріація:** Коли ви успадковуєте метод, ви можете вказати тип "
"повернення, який є більш конкретним (**підтип**), ніж батьківський метод."

msgid ""
"**Contravariance:** When you inherit a method, you can specify a parameter "
"type that is less specific (**supertype**) than the parent method."
msgstr ""
"**Контраваріантність:** Коли ви успадковуєте метод, ви можете вказати тип "
"параметра, який є менш конкретним (**супертип**), ніж батьківський метод."

msgid "Example:"
msgstr "Приклад:"

msgid "Specify the element type of an ``Array``"
msgstr "Укажіть тип елемента ``Array``"

msgid "To define the type of an ``Array``, enclose the type name in ``[]``."
msgstr "Щоб визначити тип «масиву», укладіть назву типу в «[]»."

msgid ""
"An array's type applies to ``for`` loop variables, as well as some operators "
"like ``[]``, ``[...] =`` (assignment), and ``+``. Array methods (such as "
"``push_back``) and other operators (such as ``==``) are still untyped. Built-"
"in types, native and custom classes, and enums may be used as element types. "
"Nested array types (like ``Array[Array[int]]``) are not supported."
msgstr ""
"Тип масиву застосовується до змінних циклу ``for``, а також до деяких "
"операторів, таких як ``[]``, ``[...] =`` (присвоювання) та ``+``. Методи "
"масиву (такі як ``push_back``) та інші оператори (такі як ``==``) все ще не "
"мають типів. Вбудовані типи, нативні та користувацькі класи, а також "
"переліки можуть використовуватися як типи елементів. Вкладені типи масивів "
"(такі як ``Array[Array[int]]``) не підтримуються."

msgid ""
"Since Godot 4.2, you can also specify a type for the loop variable in a "
"``for`` loop. For instance, you can write:"
msgstr ""
"Починаючи з Godot 4.2, ви також можете вказати тип для змінної циклу в циклі "
"``for``. Наприклад, ви можете написати:"

msgid ""
"The array will remain untyped, but the ``name`` variable within the ``for`` "
"loop will always be of ``String`` type."
msgstr ""
"Масив залишатиметься без типів, але змінна ``name`` у циклі ``for`` завжди "
"буде типу ``String``."

msgid "Specify the element type of a ``Dictionary``"
msgstr "Вкажіть тип елемента a ``Dictionary``"

msgid ""
"To define the type of a ``Dictionary``'s keys and values, enclose the type "
"name in ``[]`` and separate the key and value type with a comma."
msgstr ""
"Щоб визначити тип ключів та значень ``Dictionary``, укладіть назву типу в "
"``[]`` та розділіть тип ключа та значення комою."

msgid ""
"A dictionary's value type applies to ``for`` loop variables, as well as some "
"operators like ``[]`` and ``[...] =`` (assignment). Dictionary methods that "
"return values and other operators (such as ``==``) are still untyped. Built-"
"in types, native and custom classes, and enums may be used as element types. "
"Nested typed collections (like ``Dictionary[String, Dictionary[String, "
"int]]``) are not supported."
msgstr ""
"Тип значення словника застосовується до змінних циклу ``for``, а також до "
"деяких операторів, таких як ``[]`` і ``[...] =`` (присвоювання). Методи "
"словника, що повертають значення, та інші оператори (такі як ``==``) "
"залишаються нетипізованими. Вбудовані типи, нативні та користувацькі класи, "
"а також переліки можуть використовуватися як типи елементів. Вкладені "
"типізовані колекції (такі як ``Dictionary[String, Dictionary[String, "
"int]]``) не підтримуються."

msgid "Type casting"
msgstr "Лиття типу"

msgid ""
"Type casting is an important concept in typed languages. Casting is the "
"conversion of a value from one type to another."
msgstr ""
"Приведення типів є важливою концепцією в типізованих мовах. Приведення — це "
"перетворення значення з одного типу в інший."

msgid ""
"Imagine an ``Enemy`` in your game, that ``extends Area2D``. You want it to "
"collide with the ``Player``, a ``CharacterBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``body_entered`` signal to "
"detect the collision. With typed code, the body you detect is going to be a "
"generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"Уявіть ``Ворога`` у вашій грі, який ``розширює Area2D``. Ви хочете, щоб він "
"зіткнувся з ``Player``, ``CharacterBody2D`` із прикріпленим до нього "
"сценарієм під назвою ``PlayerController``. Ви використовуєте сигнал "
"``body_entered`` для виявлення зіткнення. За допомогою введеного коду тіло, "
"яке ви виявляєте, буде загальним ``PhysicsBody2D``, а не вашим "
"``PlayerController`` у зворотному виклику ``_on_body_entered``."

msgid ""
"You can check if this ``PhysicsBody2D`` is your ``Player`` with the ``as`` "
"keyword, and using the colon ``:`` again to force the variable to use this "
"type. This forces the variable to stick to the ``PlayerController`` type:"
msgstr ""
"Ви можете перевірити, чи є цей ``PhysicsBody2D`` вашим ``Player``, за "
"допомогою ключового слова ``as`` та повторного використання двокрапки ``:``, "
"щоб змусити змінну використовувати цей тип. Це змушує змінну дотримуватися "
"типу ``PlayerController``:"

msgid ""
"As we're dealing with a custom type, if the ``body`` doesn't extend "
"``PlayerController``, the ``player`` variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"Оскільки ми маємо справу з користувацьким типом, якщо ``body`` не розширює "
"``PlayerController``, змінна ``player`` буде встановлена на ``null``. Ми "
"можемо використовувати це, щоб перевірити, чи є тіло гравцем чи ні. Ми також "
"отримаємо повне автозавершення для змінної гравця завдяки цьому касту."

msgid ""
"The ``as`` keyword silently casts the variable to ``null`` in case of a type "
"mismatch at runtime, without an error/warning. While this may be convenient "
"in some cases, it can also lead to bugs. Use the ``as`` keyword only if this "
"behavior is intended. A safer alternative is to use the ``is`` keyword:"
msgstr ""
"Ключове слово ``as`` непомітно перетворює змінну на ``null`` у разі "
"невідповідності типів під час виконання, без помилки/попередження. Хоча це "
"може бути зручно в деяких випадках, це також може призвести до помилок. "
"Використовуйте ключове слово ``as``, лише якщо це передбачено. Безпечнішою "
"альтернативою є використання ключового слова ``is``:"

msgid "You can also simplify the code by using the ``is not`` operator:"
msgstr "Ви також можете спростити код, використовуючи оператор ``is not``:"

msgid "Alternatively, you can use the ``assert()`` statement:"
msgstr "Або ж ви можете скористатися оператором ``assert()``:"

msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr ""
"Якщо ви спробуєте привести за допомогою вбудованого типу, але це не "
"вдасться, Godot видасть помилку."

msgid "Safe lines"
msgstr "Безпечні рядки"

msgid ""
"You can also use casting to ensure safe lines. Safe lines are a tool to tell "
"you when ambiguous lines of code are type-safe. As you can mix and match "
"typed and dynamic code, at times, Godot doesn't have enough information to "
"know if an instruction will trigger an error or not at runtime."
msgstr ""
"Ви також можете використовувати лиття для забезпечення безпечних ліній. "
"Безпечні рядки — це інструмент, який повідомляє вам, коли неоднозначні рядки "
"коду безпечні для типів. Оскільки ви можете поєднувати введений і динамічний "
"код, інколи Godot не має достатньо інформації, щоб знати, чи інструкція "
"викличе помилку чи ні під час виконання."

msgid ""
"This happens when you get a child node. Let's take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don't care about the "
"node's type as long as it has the methods you need to call."
msgstr ""
"Це відбувається, коли ви отримуєте дочірній вузол. Візьмемо для прикладу "
"таймер: за допомогою динамічного коду ви можете отримати вузол з "
"допомогою``$Timer``. GDScript підтримує `качину типізацію <https://"
"stackoverflow.com/a/4205163/8125343>`__, тому навіть якщо ваш таймер типу "
"``Timer``, він також є ``Node`` і ``Object``, два класи він розширює. За "
"допомогою динамічного GDScript ви також не піклуєтесь про тип вузла, якщо "
"він має методи, необхідні для виклику."

msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as CharacterBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"Ви можете використовувати кастинг, щоб повідомити Godot тип, який ви "
"очікуєте, коли отримаєте вузол: ``($Timer як Timer)``, ``($Player як "
"CharacterBody2D)`` тощо. Godot переконається, що тип працює, і якщо так, "
"номер рядка стане зеленим ліворуч від редактора сценаріїв."

msgid "Unsafe vs Safe Line"
msgstr "Небезпечна проти безпечної лінії"

msgid "Unsafe line (line 7) vs Safe Lines (line 6 and 8)"
msgstr "Небезпечний рядок (рядок 7) проти безпечних рядків (рядки 6 та 8)"

msgid ""
"Safe lines do not always mean better or more reliable code. See the note "
"above about the ``as`` keyword. For example:"
msgstr ""
"Безпечні рядки не завжди означають кращий або надійніший код. Дивіться "
"примітку вище щодо ключового слова ``as``. Наприклад:"

msgid ""
"Even though ``node_2`` declaration is marked as an unsafe line, it is more "
"reliable than ``node_1`` declaration. Because if you change the node type in "
"the scene and accidentally forget to change it in the script, the error will "
"be detected immediately when the scene is loaded. Unlike ``node_1``, which "
"will be silently cast to ``null`` and the error will be detected later."
msgstr ""
"Незважаючи на те, що декларація ``node_2`` позначена як небезпечний рядок, "
"вона надійніша, ніж декларація ``node_1``. Тому що якщо ви зміните тип вузла "
"в сцені і випадково забудете змінити його в сценарії, помилка буде виявлена "
"відразу після завантаження сцени. На відміну від `` node_1 ``, який буде "
"мовчки приведений до `` null``, і помилка буде виявлена пізніше."

msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr ""
"Ви можете вимкнути безпечні рядки, або змінити їх колір у налаштуваннях "
"редактора."

msgid "Typed or dynamic: stick to one style"
msgstr "Типізований, або динамічний: дотримуйтеся одного стилю"

msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But "
"it's recommended to stick to either style for consistency in your codebase, "
"and for your peers. It's easier for everyone to work together if you follow "
"the same guidelines, and faster to read and understand other people's code."
msgstr ""
"Типізований GDScript і динамічний GDScript можуть співіснувати в одному "
"проекті. Але радимо дотримуватися будь-якого стилю для узгодженості вашої "
"кодової бази та для ваших аналогів. Усім легше працювати разом, якщо ви "
"дотримуєтеся однакових інструкцій, і швидше читати та розуміти код інших "
"людей."

msgid ""
"Typed code takes a little more writing, but you get the benefits we "
"discussed above. Here's an example of the same, empty script, in a dynamic "
"style:"
msgstr ""
"Типізований код потребує трохи більше написання, але ви отримуєте переваги, "
"які ми обговорювали вище. Ось приклад того ж, порожнього скрипта, в "
"динамічному стилі:"

msgid "And with static typing:"
msgstr "А зі статичною типізацією:"

msgid ""
"As you can see, you can also use types with the engine's virtual methods. "
"Signal callbacks, like any methods, can also use types. Here's a "
"``body_entered`` signal in a dynamic style:"
msgstr ""
"Як бачите, ви також можете використовувати типи з віртуальними методами "
"движка. Зворотні виклики сигналів, як і будь-які методи, також можуть "
"використовувати типи. Ось сигнал ``body_entered`` у динамічному стилі:"

msgid "And the same callback, with type hints:"
msgstr "І той самий зворотний виклик, з підказками типу:"

msgid "::"
msgstr "::"

msgid "func _on_area_2d_body_entered(body: PhysicsBody2D) -> void:"
msgstr "func _on_area_2d_body_entered(body: PhysicsBody2D) -> void:"

msgid "pass"
msgstr "pass"

msgid "Warning system"
msgstr "Система попередження"

msgid ""
"Detailed documentation about the GDScript warning system has been moved "
"to :ref:`doc_gdscript_warning_system`."
msgstr ""
"Детальну документацію про систему попереджень GDScript переміщено "
"до :ref:`doc_gdscript_warning_system`."

msgid ""
"Godot gives you warnings about your code as you write it. The engine "
"identifies sections of your code that may lead to issues at runtime, but "
"lets you decide whether or not you want to leave the code as it is."
msgstr ""
"Godot дає вам попередження про ваш код, коли ви його пишете. Механізм "
"визначає розділи вашого коду, які можуть призвести до проблем під час "
"виконання, але дозволяє вам вирішити, чи бажаєте ви залишити код таким, як "
"він є."

msgid ""
"We have a number of warnings aimed specifically at users of typed GDScript. "
"By default, these warnings are disabled, you can enable them in Project "
"Settings (**Debug > GDScript**, make sure **Advanced Settings** is enabled)."
msgstr ""
"У нас є низка попереджень, спрямованих саме на користувачів введеного "
"GDScript. За замовчуванням ці попередження вимкнено. Ви можете ввімкнути їх "
"у налаштуваннях проекту (**Debug > GDScript**, переконайтеся, що **Advanced "
"Settings** увімкнено)."

msgid ""
"You can enable the ``UNTYPED_DECLARATION`` warning if you want to always use "
"static types. Additionally, you can enable the ``INFERRED_DECLARATION`` "
"warning if you prefer a more readable and reliable, but more verbose syntax."
msgstr ""
"Ви можете ввімкнути попередження ``UNTYPED_DECLARATION``, якщо хочете завжди "
"використовувати статичні типи. Крім того, ви можете ввімкнути попередження "
"``INFERRED_DECLARATION``, якщо ви віддаєте перевагу більш читабельному та "
"надійному, але більш докладному синтаксису."

msgid ""
"``UNSAFE_*`` warnings make unsafe operations more noticeable, than unsafe "
"lines. Currently, ``UNSAFE_*`` warnings do not cover all cases that unsafe "
"lines cover."
msgstr ""
"Попередження ``UNSAFE_*`` роблять небезпечні операції більш помітними, ніж "
"небезпечні рядки. Наразі попередження ``UNSAFE_*`` не охоплюють усі випадки, "
"які охоплюють небезпечні лінії."

msgid "Common unsafe operations and their safe counterparts"
msgstr "Поширені небезпечні операції та їхні безпечні аналоги"

msgid "``UNSAFE_PROPERTY_ACCESS`` and ``UNSAFE_METHOD_ACCESS`` warnings"
msgstr "Попередження ``UNSAFE_PROPERTY_ACCESS`` і ``UNSAFE_METHOD_ACCESS``"

msgid ""
"In this example, we aim to set a property and call a method on an object "
"that has a script attached with ``class_name MyScript`` and that ``extends "
"Node2D``. If we have a reference to the object as a ``Node2D`` (for "
"instance, as it was passed to us by the physics system), we can first check "
"if the property and method exist and then set and call them if they do:"
msgstr ""
"У цьому прикладі ми маємо на меті встановити властивість та викликати метод "
"для об'єкта, до якого приєднаний скрипт з назвою ``class_name MyScript``, і "
"який ``розширює Node2D``. Якщо у нас є посилання на об'єкт як ``Node2D`` "
"(наприклад, оскільки його передала нам фізична система), ми можемо спочатку "
"перевірити, чи існують властивість і метод, а потім встановити та викликати "
"їх, якщо вони існують:"

msgid ""
"However, this code will produce ``UNSAFE_PROPERTY_ACCESS`` and "
"``UNSAFE_METHOD_ACCESS`` warnings as the property and method are not present "
"in the referenced type - in this case a ``Node2D``. To make these operations "
"safe, you can first check if the object is of type ``MyScript`` using the "
"``is`` keyword and then declare a variable with the type ``MyScript`` on "
"which you can set its properties and call its methods:"
msgstr ""
"Однак, цей код видасть попередження ``UNSAFE_PROPERTY_ACCESS`` та "
"``UNSAFE_METHOD_ACCESS``, оскільки властивість та метод відсутні у вказаному "
"типі – у цьому випадку ``Node2D``. Щоб зробити ці операції безпечними, ви "
"можете спочатку перевірити, чи об'єкт належить до типу ``MyScript``, "
"використовуючи ключове слово ``is``, а потім оголосити змінну з типом "
"``MyScript``, для якої ви можете встановити її властивості та викликати її "
"методи:"

msgid ""
"Alternatively, you can declare a variable and use the ``as`` operator to try "
"to cast the object. You'll then want to check whether the cast was "
"successful by confirming that the variable was assigned:"
msgstr ""
"Або ж ви можете оголосити змінну та використати оператор ``as``, щоб "
"спробувати привести тип об'єкта. Потім вам потрібно буде перевірити, чи було "
"приведення успішним, підтвердивши, що змінній було присвоєно тип:"

msgid "``UNSAFE_CAST`` warning"
msgstr "Попередження ``UNSAFE_CAST``"

msgid ""
"In this example, we would like the label connected to an object entering our "
"collision area to show the area's name. Once the object enters the collision "
"area, the physics system sends a signal with a ``Node2D`` object, and the "
"most straightforward (but not statically typed) solution to do what we want "
"could be achieved like this:"
msgstr ""
"У цьому прикладі ми хочемо, щоб мітка, пов'язана з об'єктом, що входить у "
"нашу область зіткнення, відображала назву цієї області. Щойно об'єкт "
"потрапляє в область зіткнення, фізична система надсилає сигнал з об'єктом "
"``Node2D``, і найпростіше (але не статично типізоване) рішення для "
"досягнення бажаного результату можна отримати таким чином:"

msgid ""
"This piece of code produces an ``UNSAFE_PROPERTY_ACCESS`` warning because "
"``label`` is not defined in ``Node2D``. To solve this, we could first check "
"if the ``label`` property exist and cast it to type ``Label`` before "
"settings its text property like so:"
msgstr ""
"Цей фрагмент коду видає попередження ``UNSAFE_PROPERTY_ACCESS``, оскільки "
"властивість ``label`` не визначена в ``Node2D``. Щоб вирішити цю проблему, "
"ми можемо спочатку перевірити, чи існує властивість ``label``, і привести її "
"до типу ``Label``, перш ніж встановлювати її властивість text ось так:"

msgid ""
"However, this produces an ``UNSAFE_CAST`` warning because ``body.label`` is "
"of a ``Variant`` type. To safely get the property in the type you want, you "
"can use the ``Object.get()`` method which returns the object as a "
"``Variant`` value or returns ``null`` if the property doesn't exist. You can "
"then determine whether the property contains an object of the right type "
"using the ``is`` keyword, and finally declare a statically typed variable "
"with the object:"
msgstr ""
"Однак, це призводить до появи попередження ``UNSAFE_CAST``, оскільки "
"``body.label`` має тип ``Variant``. Щоб безпечно отримати властивість "
"потрібного типу, можна скористатися методом ``Object.get()``, який повертає "
"об'єкт як значення ``Variant`` або повертає ``null``, якщо властивість не "
"існує. Потім можна визначити, чи містить властивість об'єкт потрібного типу, "
"використовуючи ключове слово ``is``, і, нарешті, оголосити статично "
"типізовану змінну з об'єктом:"

msgid "Cases where you can't specify types"
msgstr "Випадки, коли ви не можете вказати типи"

msgid ""
"To wrap up this introduction, let's mention cases where you can't use type "
"hints. This will trigger a **syntax error**."
msgstr ""
"Підсумовуючи цей вступ, давайте згадаємо випадки, коли ви не можете "
"використовувати підказки типу. Це викличе **синтаксичну помилку**."

msgid ""
"You can't specify the type of individual elements in an array or a "
"dictionary:"
msgstr "Ви не можете вказати тип окремих елементів у масиві або словнику:"

msgid "Nested types are not currently supported:"
msgstr "Вкладені типи наразі не підтримуються:"

msgid "Summary"
msgstr "Підсумок"

msgid ""
"Typed GDScript is a powerful tool. It helps you write more structured code, "
"avoid common errors, and create scalable and reliable systems. Static types "
"improve GDScript performance and more optimizations are planned for the "
"future."
msgstr ""
"Типізований GDScript є потужним інструментом. Це допомагає вам писати більш "
"структурований код, уникати поширених помилок і створювати масштабовані та "
"надійні системи. Статичні типи покращують продуктивність GDScript, і на "
"майбутнє планується більше оптимізацій."
