#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDScript reference"
msgstr "Посилання на GDScript"

msgid ""
":ref:`GDScript<doc_gdscript>` is a high-level, `object-oriented <https://"
"en.wikipedia.org/wiki/Object-oriented_programming>`_, `imperative <https://"
"en.wikipedia.org/wiki/Imperative_programming>`_, and `gradually typed "
"<https://en.wikipedia.org/wiki/Gradual_typing>`_ programming language built "
"for Godot. It uses an indentation-based syntax similar to languages like "
"`Python <https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_. "
"Its goal is to be optimized for and tightly integrated with Godot Engine, "
"allowing great flexibility for content creation and integration."
msgstr ""
":ref:`GDScript<doc_gdscript>` є високорівневим, `об’єктно-орієнтованим "
"<https://en.wikipedia.org/wiki/Object-oriented_programming>`_, `імперативним "
"<https://en.wikipedia.org/wiki/Imperative_programming>`_ і `поступово "
"введена <https://en.wikipedia.org/wiki/Gradual_typing>`_ мова програмування, "
"створена для Godot. Він використовує синтаксис на основі відступів, схожий "
"на такі мови, як `Python <https://en.wikipedia.org/wiki/"
"Python_%28programming_language%29>`_. Його метою є оптимізація та тісна "
"інтеграція з Godot Engine, що забезпечує велику гнучкість для створення та "
"інтеграції вмісту."

msgid "GDScript is entirely independent from Python and is not based on it."
msgstr "GDScript повністю не залежить від Python і не базується на ньому."

msgid "History"
msgstr "Історія"

msgid ""
"Documentation about GDScript's history has been moved to "
"the :ref:`Frequently Asked Questions <doc_faq_what_is_gdscript>`."
msgstr ""
"Документація про історію GDScript була переміщена до :ref:`FAQ "
"<doc_faq_what_is_gdscript>`."

msgid "Example of GDScript"
msgstr "Зразок GDScript"

msgid ""
"Some people can learn better by taking a look at the syntax, so here's an "
"example of how GDScript looks."
msgstr ""
"Деякі люди можуть навчитися краще, поглянувши на синтаксис, тому ось приклад "
"того, як виглядає GDScript."

msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"Якщо у вас є досвід роботи зі статично типізованими мовами, такими як C, C+"
"+, або C#, але раніше ви ніколи не використовували динамічно типізовані, "
"радимо прочитати цей урок: :ref:`doc_gdscript_more_efficiently`."

msgid "Identifiers"
msgstr "Ідентифікатори"

msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"Будь-який рядок, що обмежується алфавітними символами ( від ``a`` до ``z`` і "
"від ``A`` до ``Z``), цифрами (від ``0`` до ``9``) і ``_`` кваліфікується як "
"ідентифікатор. Крім того, ідентифікатори не повинні починатися з цифри. "
"Ідентифікатори залежать від регістру (``foo`` відрізняється від ``FOO``)."

msgid ""
"Identifiers may also contain most Unicode characters part of `UAX#31 "
"<https://www.unicode.org/reports/tr31/>`__. This allows you to use "
"identifier names written in languages other than English. Unicode characters "
"that are considered \"confusable\" for ASCII characters and emoji are not "
"allowed in identifiers."
msgstr ""
"Ідентифікатори також можуть містити більшість символів Unicode, що є "
"частиною `UAX#31 <https://www.unicode.org/reports/tr31/>`__. Це дозволяє "
"використовувати імена ідентифікаторів, написані не англійською мовою. "
"Символи Юнікоду, які вважаються \"сплутаними\" з символами ASCII та емодзі, "
"не допускаються в ідентифікаторах."

msgid "Keywords"
msgstr "Ключові слова"

msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"Далі наведено список ключових слів, які підтримуються мовою. Оскільки "
"ключові слова є зарезервованими словами (лексемами), їх не можна "
"використовувати як ідентифікатори. Оператори (такі як ``in``, ``not``, "
"``and``, або ``or``) і імена вбудованих типів, перерахованих в наступних "
"розділах, також зарезервовані."

msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"Ключові слова визначаються в `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_, "
"якщо ви хочете зазирнути під капот."

msgid "Keyword"
msgstr "Ключове слово"

msgid "Description"
msgstr "Опис"

msgid "if"
msgstr "if"

msgid "See `if/else/elif`_."
msgstr "Дивіться `if/else/elif`_."

msgid "elif"
msgstr "elif"

msgid "else"
msgstr "else"

msgid "for"
msgstr "for"

msgid "See for_."
msgstr "Дивіться for_."

msgid "while"
msgstr "while"

msgid "See while_."
msgstr "Дивіться while_."

msgid "match"
msgstr "match"

msgid "See match_."
msgstr "Дивіться match_."

msgid "when"
msgstr "when"

msgid "Used by `pattern guards <Pattern guards_>`_ in ``match`` statements."
msgstr ""
"Використовується охоронцями шаблонів <Pattern guards_>`_ в операторах "
"``match``."

msgid "break"
msgstr "перерва"

msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "Перериває виконання поточного циклу ``for``, або ``while``."

msgid "continue"
msgstr "продовжити"

msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "Негайний перехід до наступної ітерації циклу ``for``, або ``while``."

msgid "pass"
msgstr "pass"

msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr ""
"Використовується там, де, за правилами синтаксису, обов'язкова наявність "
"інструкції (коду), але виконання коду небажане, наприклад, у порожніх "
"функціях."

msgid "return"
msgstr "return"

msgid "Returns a value from a function."
msgstr "Повертає значення з функції."

msgid "class"
msgstr "class"

msgid "Defines an inner class. See `Inner classes`_."
msgstr "Визначає внутрішній клас. Див. `Внутрішні класи`_."

msgid "class_name"
msgstr "class_name"

msgid ""
"Defines the script as a globally accessible class with the specified name. "
"See `Registering named classes`_."
msgstr ""
"Визначає сценарій як глобально доступний клас із вказаною назвою. Див. "
"`Реєстрація іменованих класів`_."

msgid "extends"
msgstr "extends"

msgid "Defines what class to extend with the current class."
msgstr "Визначає який клас розширити поточним класом."

msgid "is"
msgstr "is"

msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr ""
"Тестує, чи змінна поширюється на заданий клас, чи на даний вбудований тип."

msgid "in"
msgstr "in"

msgid ""
"Tests whether a value is within a string, array, range, dictionary, or node. "
"When used with ``for``, it iterates through them instead of testing."
msgstr ""
"Перевіряє, чи знаходиться значення в рядку, масиві, діапазоні, словнику чи "
"вузлі. Якщо використовується з ``for``, він виконує їх ітерацію замість "
"тестування."

msgid "as"
msgstr "as"

msgid "Cast the value to a given type if possible."
msgstr "Якщо можливо, то переводить значення в заданий тип."

msgid "self"
msgstr "self"

msgid "Refers to current class instance. See `self`_."
msgstr "Посилається на поточний екземпляр класу. Дивіться `self`_."

msgid "super"
msgstr "super"

msgid "Resolves the scope of the parent method. See `Inheritance`_."
msgstr "Вирішує область батьківського методу. Див. `Наслідування`_."

msgid "signal"
msgstr "signal"

msgid "Defines a signal. See `Signals`_."
msgstr "Визначає сигнал. Дивіться `Сигнали`_."

msgid "func"
msgstr "func"

msgid "Defines a function.  See `Functions`_."
msgstr "Визначає функцію.  Див. `Функції`_."

msgid "static"
msgstr "static"

msgid "Defines a static function or a static member variable."
msgstr "Визначає статичну функцію або статичну змінну-член."

msgid "const"
msgstr "const"

msgid "Defines a constant. See `Constants`_."
msgstr "Визначає константу. Див. `Константи`_."

msgid "enum"
msgstr "enum"

msgid "Defines an enum. See `Enums`_."
msgstr "Визначає перелік. Перегляньте `Enums`_."

msgid "var"
msgstr "var"

msgid "Defines a variable. See `Variables`_."
msgstr "Визначає змінну. Див. `Змінні`_."

msgid "breakpoint"
msgstr "breakpoint"

msgid ""
"Editor helper for debugger breakpoints. Unlike breakpoints created by "
"clicking in the gutter, ``breakpoint`` is stored in the script itself. This "
"makes it persistent across different machines when using version control."
msgstr ""
"Помічник редактора для точок зупину налагоджувача. На відміну від точок "
"зупину, створених клацанням у канаві, ``точка зупину`` зберігається в самому "
"сценарії. Це робить його постійним на різних машинах під час використання "
"контролю версій."

msgid "preload"
msgstr "preload"

msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr ""
"Попередньо завантажує клас, чи змінну. Дивіться `Classes as resources`_."

msgid "await"
msgstr "await"

msgid ""
"Waits for a signal or a coroutine to finish. See `Awaiting signals or "
"coroutines`_."
msgstr ""
"Очікує на завершення сигналу або співпрограми. Див. `Сигнали очікування або "
"співпрограми`_."

msgid "yield"
msgstr "yield"

msgid "Previously used for coroutines. Kept as keyword for transition."
msgstr ""
"Раніше використовувався для співпрограм. Зберігається як ключове слово для "
"переходу."

msgid "assert"
msgstr "assert"

msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"Затверджує умову, реєструє помилку під час збою. Ігнорується в не-"
"налагоджених збірках. Дивіться `Assert keyword`_."

msgid "void"
msgstr "Void"

msgid "Used to represent that a function does not return any value."
msgstr ""
"Використовується для позначення того, що функція не повертає жодного "
"значення."

msgid "PI"
msgstr "PI"

msgid "PI constant."
msgstr "Константа Пі (π)."

msgid "TAU"
msgstr "TAU"

msgid "TAU constant."
msgstr "Константа Тау (τ)."

msgid "INF"
msgstr "INF"

msgid "Infinity constant. Used for comparisons and as result of calculations."
msgstr ""
"Стала нескінченності. Використовується для порівнянь і як результат "
"розрахунків."

msgid "NAN"
msgstr "NAN"

msgid ""
"NAN (not a number) constant. Used as impossible result from calculations."
msgstr ""
"Константа NAN (не число). Використовується як неможливий результат "
"розрахунків."

msgid "Operators"
msgstr "Оператори"

msgid ""
"The following is the list of supported operators and their precedence. All "
"binary operators are `left-associative <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_, including the ``**`` operator. This means that "
"``2 ** 2 ** 3`` is equal to ``(2 ** 2) ** 3``. Use parentheses to explicitly "
"specify precedence you need, for example ``2 ** (2 ** 3)``. The ternary ``if/"
"else`` operator is right-associative."
msgstr ""
"Нижче наведено список підтримуваних операторів і їх пріоритет. Усі бінарні "
"оператори є `лівоасоціативними <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_, включаючи оператор ``**``. Це означає, що ``2 ** "
"2 ** 3`` дорівнює ``(2 ** 2) ** 3``. Використовуйте круглі дужки, щоб явно "
"вказати пріоритет, який вам потрібен, наприклад ``2 ** (2 ** 3)``. Тернарний "
"оператор if/else є правоасоціативним."

msgid "**Operator**"
msgstr "**Оператор**"

msgid "**Description**"
msgstr "**Опис**"

msgid "``(`` ``)``"
msgstr "``(`` ``)``"

msgid "Grouping (highest priority)"
msgstr "Групування (найвищий пріоритет)"

msgid ""
"Parentheses are not really an operator, but allow you to explicitly specify "
"the precedence of an operation."
msgstr ""
"Дужки насправді не є оператором, але дозволяють явно вказати пріоритет "
"операції."

msgid "``x[index]``"
msgstr "``x[index]``"

msgid "Subscription"
msgstr "Підписка"

msgid "``x.attribute``"
msgstr "``x.attribute``"

msgid "Attribute reference"
msgstr "Посилання на атрибут"

msgid "``foo()``"
msgstr "``foo()``"

msgid "Function call"
msgstr "Виклик функції"

msgid "``await x``"
msgstr "``await x``"

msgid "`Awaiting signals or coroutines`_"
msgstr "`Сигнали очікування або співпрограми`_"

msgid "``x is Node``"
msgstr "``x is Node``"

msgid "``x is not Node``"
msgstr "``x is not Node``"

msgid "Type checking"
msgstr "Перевірка типу"

msgid ""
"See also :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` "
"function."
msgstr ""
"Дивіться також функцію :ref:`is_instance_of() "
"<class_@GDScript_method_is_instance_of>`."

msgid "``x ** y``"
msgstr "``x ** y``"

msgid "Power"
msgstr "потужність"

msgid ""
"Multiplies ``x`` by itself ``y`` times, similar to calling :ref:`pow() "
"<class_@GlobalScope_method_pow>` function."
msgstr ""
"Помножує ``x`` на себе ``y`` разів, подібно до виклику функції :ref:`pow() "
"<class_@GlobalScope_method_pow>`."

msgid "``~x``"
msgstr "``~x``"

msgid "Bitwise NOT"
msgstr "Побітове NOT (НЕ)"

msgid "``+x``"
msgstr "``+x``"

msgid "``-x``"
msgstr "``-x``"

msgid "Identity / Negation"
msgstr "Тотожність / Заперечення"

msgid "``x * y``"
msgstr "``x * y``"

msgid "``x / y``"
msgstr "``x / y``"

msgid "``x % y``"
msgstr "``x % y``"

msgid "Multiplication / Division / Remainder"
msgstr "Множення/Ділення/Залишок ділення"

msgid ""
"The ``%`` operator is additionally used for :ref:`format strings "
"<doc_gdscript_printf>`."
msgstr ""
"Оператор ``%`` додатково використовується для :ref:`format strings "
"<doc_gdscript_printf>`."

msgid ""
"**Note:** These operators have the same behavior as C++, which may be "
"unexpected for users coming from Python, JavaScript, etc. See a detailed "
"note after the table."
msgstr ""
"**Примітка.** Ці оператори мають таку саму поведінку, що й C++, що може бути "
"неочікуваним для користувачів, які використовують Python, JavaScript тощо. "
"Див. детальну примітку після таблиці."

msgid "``x + y``"
msgstr "``x + y``"

msgid "``x - y``"
msgstr "``x - y``"

msgid "Addition (or Concatenation) / Subtraction"
msgstr "Додавання (або об'єднання) / віднімання"

msgid "``x << y``"
msgstr "``x << y``"

msgid "``x >> y``"
msgstr "``x >> y``"

msgid "Bit shifting"
msgstr "Побітовий зсув (зміщення)"

msgid "``x & y``"
msgstr "``x & y``"

msgid "Bitwise AND"
msgstr "Побітове AND (І)"

msgid "``x ^ y``"
msgstr "``x ^ y``"

msgid "Bitwise XOR"
msgstr "Побітове XOR (Виключене АБО)"

msgid "``x | y``"
msgstr "``x | y``"

msgid "Bitwise OR"
msgstr "Побітове OR (АБО)"

msgid "``x == y``"
msgstr "``x == y``"

msgid "``x != y``"
msgstr "``x != y``"

msgid "``x < y``"
msgstr "``x < y``"

msgid "``x > y``"
msgstr "``x > y``"

msgid "``x <= y``"
msgstr "``x <= y``"

msgid "``x >= y``"
msgstr "``x >= y``"

msgid "Comparison"
msgstr "Порівняння"

msgid "See a detailed note after the table."
msgstr "Дивіться детальну примітку після таблиці."

msgid "``x in y``"
msgstr "``x in y``"

msgid "``x not in y``"
msgstr "``x not in y``"

msgid "Inclusion checking"
msgstr "Перевірка включення"

msgid "``in`` is also used with the for_ keyword as part of the syntax."
msgstr ""
"``in`` також використовується з ключовим словом for_ як частина синтаксису."

msgid "``not x``"
msgstr "``not x``"

msgid "``!x``"
msgstr "``!x``"

msgid "Boolean NOT and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "Логічне значення NOT і його :ref:`unrecommended <boolean_operators>`"

msgid "``x and y``"
msgstr "``x and y``"

msgid "``x && y``"
msgstr "``x && y``"

msgid "Boolean AND and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "Логічне І та його :ref:`unrecommended <boolean_operators>`"

msgid "``x or y``"
msgstr "``x or y``"

msgid "``x || y``"
msgstr "``x || y``"

msgid "Boolean OR and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "Логічне АБО та його :ref:`unrecommended <boolean_operators>`"

msgid "``true_expr if cond else false_expr``"
msgstr "``true_expr if cond else false_expr``"

msgid "Ternary if/else"
msgstr "Потрійне if/else (якщо/інакше)"

msgid "``x as Node``"
msgstr "``x as Node``"

msgid "`Type casting <casting_>`_"
msgstr "`Type casting <casting_>`_"

msgid "``x = y``"
msgstr "``x = y``"

msgid "``x += y``"
msgstr "``x += y``"

msgid "``x -= y``"
msgstr "``x -= y``"

msgid "``x *= y``"
msgstr "``x *= y``"

msgid "``x /= y``"
msgstr "``x /= y``"

msgid "``x **= y``"
msgstr "``x **= y``"

msgid "``x %= y``"
msgstr "``x %= y``"

msgid "``x &= y``"
msgstr "``x &= y``"

msgid "``x |= y``"
msgstr "``x |= y``"

msgid "``x ^= y``"
msgstr "``x ^= y``"

msgid "``x <<= y``"
msgstr "``x <<= y``"

msgid "``x >>= y``"
msgstr "``x >>= y``"

msgid "Assignment (lowest priority)"
msgstr "Присвоювання значення, найнижчий пріоритет"

msgid "You cannot use an assignment operator inside an expression."
msgstr "Ви не можете використовувати оператор присвоювання всередині виразу."

msgid "The behavior of some operators may differ from what you expect:"
msgstr "Поведінка деяких операторів може відрізнятися від очікуваної:"

msgid ""
"If both operands of the ``/`` operator are :ref:`int <class_int>`, then "
"integer division is performed instead of fractional. For example ``5 / 2 == "
"2``, not ``2.5``. If this is not desired, use at least one :ref:`float "
"<class_float>` literal (``x / 2.0``), cast (``float(x) / y``), or multiply "
"by ``1.0`` (``x * 1.0 / y``)."
msgstr ""
"Якщо обидва операнди оператора ``/`` є :ref:`int <class_int>`, тоді "
"виконується цілочисельне ділення замість дробового. Наприклад, ``5 / 2 == "
"2``, а не ``2,5``. Якщо це небажано, використовуйте принаймні один "
"літерал :ref:`float <class_float>` (``x / 2.0``), приведення (``float(x) / "
"y``) або помножте на ``1.0 `` (``x * 1,0 / y``)."

msgid ""
"The ``%`` operator is only available for ints, for floats use "
"the :ref:`fmod() <class_@GlobalScope_method_fmod>` function."
msgstr ""
"Оператор ``%`` доступний лише для int, для float використовуйте "
"функцію :ref:`fmod() <class_@GlobalScope_method_fmod>`."

msgid ""
"For negative values, the ``%`` operator and ``fmod()`` use `truncation "
"<https://en.wikipedia.org/wiki/Truncation>`_ instead of rounding towards "
"negative infinity. This means that the remainder has a sign. If you need the "
"remainder in a mathematical sense, use the :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` and :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` functions instead."
msgstr ""
"Для від’ємних значень оператор ``%`` і ``fmod()`` використовують `усічення "
"<https://en.wikipedia.org/wiki/Truncation>`_ замість округлення до від’ємної "
"нескінченності. Це означає, що остача має знак. Якщо вам потрібен залишок у "
"математичному сенсі, замість цього використовуйте функції :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` і :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>`."

msgid ""
"The ``==`` and ``!=`` operators sometimes allow you to compare values of "
"different types (for example, ``1 == 1.0`` is true), but in other cases it "
"can cause a runtime error. If you're not sure about the types of the "
"operands, you can safely use the :ref:`is_same() "
"<class_@GlobalScope_method_is_same>` function (but note that it is more "
"strict about types and references). To compare floats, use "
"the :ref:`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` "
"and :ref:`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` "
"functions instead."
msgstr ""
"Оператори ``==`` і ``!=`` іноді дозволяють порівнювати значення різних типів "
"(наприклад, ``1 == 1.0`` є істинним), але в інших випадках це може викликати "
"помилку виконання. Якщо ви не впевнені щодо типів операндів, ви можете "
"сміливо використовувати функцію :ref:`is_same() "
"<class_@GlobalScope_method_is_same>` (але зауважте, що вона більш сувора "
"щодо типів і посилань). Для порівняння плаваючих значень замість цього "
"використовуйте функції :ref:`is_equal_approx() "
"<class_@GlobalScope_method_is_equal_approx>` і :ref:`is_zero_approx() "
"<class_@GlobalScope_method_is_zero_approx>`."

msgid "Literals"
msgstr "Літерали"

msgid "**Example(s)**"
msgstr "**Приклад(и)**"

msgid "``null``"
msgstr "``null``"

msgid "Null value"
msgstr "Нульове значення"

msgid "``false``, ``true``"
msgstr "``false``, ``true``"

msgid "Boolean values"
msgstr "Логічні значення"

msgid "``45``"
msgstr "``45``"

msgid "Base 10 integer"
msgstr "Ціле число за десятковою системою числення"

msgid "``0x8f51``"
msgstr "``0x8f51``"

msgid "Base 16 (hexadecimal) integer"
msgstr "Ціле число на основі шістнадцяткової системи числення"

msgid "``0b101010``"
msgstr "``0b101010``"

msgid "Base 2 (binary) integer"
msgstr "Ціле число в двійковій (бінарній) системі числення"

msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14``, ``58.1e-10``"

msgid "Floating-point number (real)"
msgstr "Число з рухомою комою (дійсне)"

msgid "``\"Hello\"``, ``'Hi'``"
msgstr "``\"Hello\"``, ``'Hi'``"

msgid "Regular strings"
msgstr "Звичайні рядки"

msgid "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"
msgstr "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"

msgid "Triple-quoted regular strings"
msgstr "Звичайні рядки в потрійних лапках"

msgid "``r\"Hello\"``, ``r'Hi'``"
msgstr "``r\"Hello\"``, ``r'Hi'``"

msgid "Raw strings"
msgstr "Необроблені рядки"

msgid "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"
msgstr "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"

msgid "Triple-quoted raw strings"
msgstr "Необроблені рядки в потрійних лапках"

msgid "``&\"name\"``"
msgstr "``&\"name\"``"

msgid ":ref:`StringName <class_StringName>`"
msgstr ":ref:`StringName <class_StringName>`"

msgid "``^\"Node/Label\"``"
msgstr "``^\"Node/Label\"``"

msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

msgid ""
"There are also two constructs that look like literals, but actually are not:"
msgstr ""
"Є також дві конструкції, які виглядають як літерали, але насправді такими не "
"є:"

msgid "**Example**"
msgstr "**Приклад**"

msgid "``$NodePath``"
msgstr "``$NodePath``"

msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "Скорочення для ``get_node(\"NodePath\")``"

msgid "``%UniqueNode``"
msgstr "``%UniqueNode``"

msgid "Shorthand for ``get_node(\"%UniqueNode\")``"
msgstr "Скорочення для ``get_node(\"%UniqueNode\")``"

msgid ""
"Integers and floats can have their numbers separated with ``_`` to make them "
"more readable. The following ways to write numbers are all valid:"
msgstr ""
"Цілі числа та числа з плаваючою комою можуть бути розділені символом ``_`` "
"для кращої читабельності. Підходять такі способи запису чисел:"

msgid "**Regular string literals** can contain the following escape sequences:"
msgstr ""
"**Звичайні рядкові літерали** можуть містити такі керуючі послідовності:"

msgid "**Escape sequence**"
msgstr "**Escape послідовності**"

msgid "**Expands to**"
msgstr "**Розширюються**"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Newline (line feed)"
msgstr "Новий рядок (перенесення рядка)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "Horizontal tab character"
msgstr "Горизонтальний символ табуляції"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage return"
msgstr "Повернення каретки"

msgid "``\\a``"
msgstr "``\\a``"

msgid "Alert (beep/bell)"
msgstr "Попередження (звуковий сигнал/дзвінок)"

msgid "``\\b``"
msgstr "``\\b``"

msgid "Backspace"
msgstr "Стерти"

msgid "``\\f``"
msgstr "``\\f``"

msgid "Formfeed page break"
msgstr "Розрив сторінки форми"

msgid "``\\v``"
msgstr "``\\v``"

msgid "Vertical tab character"
msgstr "Вертикальний символ табуляції"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote"
msgstr "Подвійні лапки"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote"
msgstr "Одинарні лапки"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash"
msgstr "Зворотний слеш"

msgid "``\\uXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-16 Unicode codepoint ``XXXX`` (hexadecimal, case-insensitive)"
msgstr ""
"UTF-16 кодова точка Unicode ``XXXX`` (шістнадцяткове число, регістр не "
"залежить)"

msgid "``\\UXXXXXX``"
msgstr "``\\UXXXXXX``"

msgid "UTF-32 Unicode codepoint ``XXXXXX`` (hexadecimal, case-insensitive)"
msgstr ""
"UTF-32 Кодова точка Юнікоду ``XXXXXX`` (шістнадцяткове число, регістр не "
"залежить)"

msgid ""
"There are two ways to represent an escaped Unicode character above "
"``0xFFFF``:"
msgstr "Є два способи представити екранований символ Unicode над ``0xFFFF``:"

msgid ""
"as a `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."
msgstr ""
"як `сурогатна пара UTF-16 <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."

msgid "as a single UTF-32 codepoint ``\\UXXXXXX``."
msgstr "як один код UTF-32 ``\\UXXXXXX``."

msgid ""
"Also, using ``\\`` followed by a newline inside a string will allow you to "
"continue it in the next line, without inserting a newline character in the "
"string itself."
msgstr ""
"Крім того, використання ``\\`` з наступним символом нового рядка всередині "
"рядка дозволить вам продовжити його в наступному рядку, не вставляючи символ "
"нового рядка в самому рядку."

msgid ""
"A string enclosed in quotes of one type (for example ``\"``) can contain "
"quotes of another type (for example ``'``) without escaping. Triple-quoted "
"strings allow you to avoid escaping up to two consecutive quotes of the same "
"type (unless they are adjacent to the string edges)."
msgstr ""
"Рядок, укладений у лапки одного типу (наприклад ``\"``), може містити лапки "
"іншого типу (наприклад `````) без екранування. Рядки з потрійними лапками "
"дозволяють уникнути екранування двох послідовних лапок одного типу (якщо "
"вони не примикають до країв рядка)."

msgid ""
"**Raw string literals** always encode the string as it appears in the source "
"code. This is especially useful for regular expressions. A raw string "
"literal doesn't process escape sequences, however it does recognize ``\\\\`` "
"and ``\\\"`` (``\\'``) and replaces them with themselves. Thus, a string can "
"have a quote that matches the opening one, but only if it's preceded by a "
"backslash."
msgstr ""
"**Необроблені рядкові літерали** завжди кодують рядок так, як він "
"відображається у вихідному коді. Це особливо корисно для регулярних виразів. "
"Літерал необробленого рядка не обробляє escape-послідовності, однак він "
"розпізнає ``\\\\`` і ``\\\"`` (``\\'``) і замінює їх собою. Таким чином, "
"рядок може містити лапки який збігається з початковим, але лише якщо йому "
"передує зворотна скісна риска."

msgid ""
"Some strings cannot be represented using raw string literals: you cannot "
"have an odd number of backslashes at the end of a string or have an "
"unescaped opening quote inside the string. However, in practice this doesn't "
"matter since you can use a different quote type or use concatenation with a "
"regular string literal."
msgstr ""
"Деякі рядки не можна представити за допомогою необроблених рядкових "
"літералів: ви не можете мати непарну кількість зворотних похилих рисок у "
"кінці рядка або мати неекрановані початкові лапки всередині рядка. Однак на "
"практиці це не має значення, оскільки ви можете використовувати інший тип "
"лапок або використовувати конкатенацію зі звичайним рядковим літералом."

msgid "GDScript also supports :ref:`format strings <doc_gdscript_printf>`."
msgstr "GDScript також підтримує :ref:`format strings <doc_gdscript_printf>`."

msgid "Annotations"
msgstr "Анотації"

msgid ""
"Annotations are special tokens in GDScript that act as modifiers to a script "
"or its code and may affect how the script is treated by the Godot engine or "
"editor."
msgstr ""
"Анотації — це спеціальні маркери в GDScript, які діють як модифікатори "
"сценарію або його коду та можуть впливати на те, як сценарій обробляється "
"механізмом або редактором Godot."

msgid ""
"Every annotation starts with the ``@`` character and is specified by a name. "
"A detailed description and example for each annotation can be found inside "
"the :ref:`GDScript class reference <class_@GDScript>`."
msgstr ""
"Кожна анотація починається із символу ``@`` і вказується назвою. Детальний "
"опис і приклад для кожної анотації можна знайти в :ref:`посиланні на клас "
"GDScript <class_@GDScript>`."

msgid "For instance, you can use it to export a value to the editor:"
msgstr ""
"Наприклад, ви можете використовувати його для експорту значення до редактора:"

msgid ""
"For more information about exporting properties, read the :ref:`GDScript "
"exports <doc_gdscript_exports>` article."
msgstr ""
"Щоб дізнатися більше про експорт властивостей, прочитайте "
"статтю :ref:`GDScript exports <doc_gdscript_exports>`."

msgid ""
"Any constant expression compatible with the required argument type can be "
"passed as an annotation argument value:"
msgstr ""
"Будь-який константний вираз, сумісний з необхідним типом аргументу, можна "
"передати як значення аргументу анотації:"

msgid ""
"Annotations can be specified one per line or all in the same line. They "
"affect the next statement that isn't an annotation. Annotations can have "
"arguments sent between parentheses and separated by commas."
msgstr ""
"Анотації можна вказувати по одній на рядок або всі в одному рядку. Вони "
"впливають на наступне твердження, яке не є анотацією. Анотації можуть "
"містити аргументи, надіслані в круглих дужках і розділені комами."

msgid "Both of these are the same:"
msgstr "Обидва ці речі однакові:"

msgid "``@onready`` annotation"
msgstr "анотація ``@onready``"

msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to ``Node._ready()`` is made."
msgstr ""
"При використанні вузлів бажання зберігати посилання на частини сцени в "
"змінній цілком нормальне. Оскільки сцени можуть бути налаштовані лише під "
"час входу в дерево активних сцен, під-вузли можна отримати лише тоді, коли "
"здійснюється виклик ``Node._ready()``."

msgid ""
"This can get a little cumbersome, especially when nodes and external "
"references pile up. For this, GDScript has the ``@onready`` annotation, that "
"defers initialization of a member variable until ``_ready()`` is called. It "
"can replace the above code with a single line:"
msgstr ""
"Це може бути трохи громіздким, особливо коли вузли та зовнішні посилання "
"накопичуються. Для цього GDScript має анотацію ``@onready``, яка відкладає "
"ініціалізацію змінної-члена до виклику ``_ready()``. Вона може замінити "
"наведений вище код одним рядком:"

msgid ""
"Applying ``@onready`` and any ``@export`` annotation to the same variable "
"doesn't work as you might expect. The ``@onready`` annotation will cause the "
"default value to be set after the ``@export`` takes effect and will override "
"it:"
msgstr ""
"Застосування анотації ``@onready`` та будь-якої анотації ``@export`` до тієї "
"ж змінної не працює належним чином. Анотація ``@onready`` призведе до "
"встановлення значення за замовчуванням після набрання чинності ``@export`` "
"та замінить його:"

msgid ""
"Therefore, the ``ONREADY_WITH_EXPORT`` warning is generated, which is "
"treated as an error by default. We do not recommend disabling or ignoring it."
msgstr ""
"Тому створюється попередження ``ONREADY_WITH_EXPORT``, яке за замовчуванням "
"розглядається як помилка. Ми не рекомендуємо вимикати або ігнорувати його."

msgid "Comments"
msgstr "Коментарі"

msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr ""
"Все що знаходиться після символа ``#``, і до кінця рядка, ігнорується і "
"вважається коментарем."

msgid ""
"In the Godot script editor, special keywords are highlighted within comments "
"to bring the user's attention to specific comments:"
msgstr ""
"У редакторі скриптів Godot спеціальні ключові слова виділено в коментарях, "
"щоб привернути увагу користувача до конкретних коментарів:"

msgid ""
"**Critical** *(appears in red)*: ``ALERT``, ``ATTENTION``, ``CAUTION``, "
"``CRITICAL``, ``DANGER``, ``SECURITY``"
msgstr ""
"**Критично** *(відображається червоним кольором)*: ``ALERT``, ``ATTENTION``, "
"``CAUTION``, ``CRITICAL``, ``DANGER``, ``SECURITY``"

msgid ""
"**Warning** *(appears in yellow)*: ``BUG``, ``DEPRECATED``, ``FIXME``, "
"``HACK``, ``TASK``, ``TBD``, ``TODO``, ``WARNING``"
msgstr ""
"**Попередження** *(відображається жовтим кольором)*: ``BUG``, "
"``DEPRECATED``, ``FIXME``, ``HACK``, ``TASK``, ``TBD``, ` `ЗАВДАННЯ``, "
"``УВАГА``"

msgid ""
"**Notice** *(appears in green)*: ``INFO``, ``NOTE``, ``NOTICE``, ``TEST``, "
"``TESTING``"
msgstr ""
"**Примітка** *(з’являється зеленим кольором)*: ``INFO``, ``NOTE``, "
"``NOTICE``, ``TEST``, ``TESTING``"

msgid ""
"These keywords are case-sensitive, so they must be written in uppercase for "
"them to be recognized:"
msgstr ""
"Ці ключові слова чутливі до регістру, тому їх потрібно писати у верхньому "
"регістрі, щоб їх розпізнати:"

msgid ""
"The list of highlighted keywords and their colors can be changed in the "
"**Text Editor > Theme > Comment Markers** section of the Editor Settings."
msgstr ""
"Список виділених ключових слів та їхні кольори можна змінити в розділі "
"**Текстовий редактор > Тема > Маркери коментарів** у налаштуваннях редактора."

msgid ""
"Use two hash symbols (``##``) instead of one (``#``) to add a *documentation "
"comment*, which will appear in the script documentation and in the inspector "
"description of an exported variable. Documentation comments must be placed "
"directly *above* a documentable item (such as a member variable), or at the "
"top of a file. Dedicated formatting options are also available. "
"See :ref:`doc_gdscript_documentation_comments` for details."
msgstr ""
"Використовуйте два хеш-символи (``##``) замість одного (``#``), щоб додати "
"*коментар до документації*, який з’являтиметься в документації сценарію та в "
"описі інспектора експортованої змінної. Коментарі до документації мають бути "
"розміщені безпосередньо *над* документованим елементом (наприклад, змінною-"
"членом) або у верхній частині файлу. Також доступні спеціальні параметри "
"форматування. Перегляньте :ref:`doc_gdscript_documentation_comments` для "
"деталей."

msgid "Code regions"
msgstr "Кодові регіони"

msgid ""
"Code regions are special types of comments that the script editor "
"understands as *foldable regions*. This means that after writing code region "
"comments, you can collapse and expand the region by clicking the arrow that "
"appears at the left of the comment. This arrow appears within a purple "
"square to be distinguishable from standard code folding."
msgstr ""
"Області коду — це спеціальні типи коментарів, які редактор сценаріїв розуміє "
"як *згортані області*. Це означає, що після написання коментарів регіону "
"коду ви можете згортати та розгортати регіон, натиснувши стрілку, яка "
"з’являється ліворуч від коментаря. Ця стрілка відображається в фіолетовому "
"квадраті, щоб її можна було відрізнити від стандартного згортання коду."

msgid "The syntax is as follows:"
msgstr "Синтаксис такий:"

msgid ""
"To create a code region quickly, select several lines in the script editor, "
"right-click the selection then choose **Create Code Region**. The region "
"description will be selected automatically for editing."
msgstr ""
"Щоб швидко створити область коду, виберіть кілька рядків у редакторі "
"сценаріїв, клацніть виділення правою кнопкою миші та виберіть **Створити "
"область коду**. Опис регіону буде автоматично вибрано для редагування."

msgid "It is possible to nest code regions within other code regions."
msgstr "Області коду можна вкладати в інші області коду."

msgid "Here's a concrete usage example of code regions:"
msgstr "Ось конкретний приклад використання регіонів коду:"

msgid ""
"This can be useful to organize large chunks of code into easier to "
"understand sections. However, remember that external editors generally don't "
"support this feature, so make sure your code is easy to follow even when not "
"relying on folding code regions."
msgstr ""
"Це може бути корисним для організації великих фрагментів коду в легших для "
"розуміння розділах. Однак пам’ятайте, що зовнішні редактори, як правило, не "
"підтримують цю функцію, тому переконайтеся, що ваш код простий у дотриманні, "
"навіть якщо не покладатися на області згортання коду."

msgid ""
"Individual functions and indented sections (such as ``if`` and ``for``) can "
"*always* be collapsed in the script editor. This means you should avoid "
"using a code region to contain a single function or indented section, as it "
"won't bring much of a benefit. Code regions work best when they're used to "
"group multiple elements together."
msgstr ""
"Окремі функції та розділи з відступами (такі як ``if`` і ``for``) можна "
"*завжди* згорнути в редакторі сценаріїв. Це означає, що вам слід уникати "
"використання області коду для однієї функції або розділу з відступом, "
"оскільки це не принесе великої користі. Області коду працюють найкраще, коли "
"вони використовуються для групування кількох елементів разом."

msgid "Line continuation"
msgstr "Продовження лінії"

msgid ""
"A line of code in GDScript can be continued on the next line by using a "
"backslash (``\\``). Add one at the end of a line and the code on the next "
"line will act like it's where the backslash is. Here is an example:"
msgstr ""
"Рядок коду в GDScript можна продовжити в наступному рядку за допомогою "
"зворотної косої риски (``\\``). Додайте один у кінці рядка, і код у "
"наступному рядку діятиме так, ніби там знаходиться зворотна коса риска. Ось "
"приклад:"

msgid "A line can be continued multiple times like this:"
msgstr "Рядок можна продовжувати кілька разів так:"

msgid "Built-in types"
msgstr "Вбудовані типи"

msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The exceptions are ``Object``, ``Array``, ``Dictionary``, and "
"packed arrays (such as ``PackedByteArray``), which are passed by reference "
"so they are shared. All arrays, ``Dictionary``, and some objects (``Node``, "
"``Resource``) have a ``duplicate()`` method that allows you to make a copy."
msgstr ""
"Вбудовані типи розміщуються в стеку. Вони передаються як значення. Це "
"означає, що копія створюється при кожному присвоюванні або при передачі їх "
"як аргументів у функції. Виняток становлять ``Object``, ``Array``, "
"``Dictionary`` та упаковані масиви (такі як ``PackedByteArray``), які "
"передаються за посиланням, тому вони є спільними. Всі масиви, ``Dictionary`` "
"і деякі об'єкти (``Node``, ``Resource``) мають метод ``duplicate()``, який "
"дозволяє зробити копію."

msgid "Basic built-in types"
msgstr "Базові вбудовані типи"

msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "Змінна в GDScript може бути призначена декільком вбудованим типам."

msgid "null"
msgstr "нуль"

msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr ""
"``null`` це порожній тип даних, який не містить інформації та не може "
"приймати інші значення."

msgid ""
"Only types that inherit from Object can have a ``null`` value (Object is "
"therefore called a \"nullable\" type). :ref:`Variant types "
"<doc_variant_class>` must have a valid value at all times, and therefore "
"cannot have a ``null`` value."
msgstr ""
"Лише типи, які успадковуються від Object, можуть мати значення ``null`` "
"(тому Object називають типом, що допускає нульові значення). :ref:`Variant "
"types <doc_variant_class>` повинні завжди мати дійсне значення, тому не "
"можуть мати значення ``null``."

msgid ":ref:`bool <class_bool>`"
msgstr ":ref:`bool <class_bool>` (логічні)"

msgid "Short for \"boolean\", it can only contain ``true`` or ``false``."
msgstr "Скорочене для \"boolean\", може містити лише ``true``, або ``false``."

msgid ":ref:`int <class_int>`"
msgstr ":ref:`int <class_int>`"

msgid ""
"Short for \"integer\", it stores whole numbers (positive and negative). It "
"is stored as a 64-bit value, equivalent to ``int64_t`` in C++."
msgstr ""
"Скорочено від \"ціле число\", він зберігає цілі числа (додатні та від’ємні). "
"Воно зберігається як 64-розрядне значення, еквівалентне ``int64_t`` у C++."

msgid ":ref:`float <class_float>`"
msgstr ":ref:`float <class_float>`"

msgid ""
"Stores real numbers, including decimals, using floating-point values. It is "
"stored as a 64-bit value, equivalent to ``double`` in C++. Note: Currently, "
"data structures such as ``Vector2``, ``Vector3``, and ``PackedFloat32Array`` "
"store 32-bit single-precision ``float`` values."
msgstr ""
"Зберігає дійсні числа, включаючи десяткові дроби, використовуючи значення з "
"плаваючою комою. Воно зберігається як 64-розрядне значення, еквівалентне "
"``double`` у C++. Примітка: наразі такі структури даних, як ``Vector2``, "
"``Vector3`` і ``PackedFloat32Array`` зберігають 32-розрядні значення "
"``float`` одинарної точності."

msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

msgid ""
"A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/"
"Unicode>`_."
msgstr ""
"Послідовність символів у форматі `Unicode <https://en.wikipedia.org/wiki/"
"Unicode>`_."

msgid ""
"An immutable string that allows only one instance of each name. They are "
"slower to create and may result in waiting for locks when multithreading. In "
"exchange, they're very fast to compare, which makes them good candidates for "
"dictionary keys."
msgstr ""
"Незмінний рядок, який допускає лише один екземпляр кожного імені. Вони "
"повільніше створюються і можуть призвести до очікування блокувань під час "
"багатопоточності. Натомість вони дуже швидкі для порівняння, що робить їх "
"хорошими кандидатами на ключі словника."

msgid ""
"A pre-parsed path to a node or a node property.  It can be easily assigned "
"to, and from, a String. They are useful to interact with the tree to get a "
"node, or affecting properties like with :ref:`Tweens <class_Tween>`."
msgstr ""
"Попередньо проаналізований шлях до вузла або властивості вузла. Його можна "
"легко призначити рядку та з нього. Вони корисні для взаємодії з деревом, щоб "
"отримати вузол, або для впливу на властивості, як-от :ref:`Tweens "
"<class_Tween>`."

msgid "Vector built-in types"
msgstr "Векторні вбудовані типи"

msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as an "
"array."
msgstr ""
"2D векторний тип містить поля ``x`` і ``y``. Також можна отримати доступ до "
"масиву."

msgid ":ref:`Vector2i <class_Vector2i>`"
msgstr ":ref:`Vector2i <class_Vector2i>`"

msgid ""
"Same as a Vector2 but the components are integers. Useful for representing "
"items in a 2D grid."
msgstr ""
"Те саме, що Vector2, але компоненти є цілими числами. Корисно для "
"представлення елементів у двовимірній сітці."

msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Also contains an ``end`` field which is ``position + size``."
msgstr ""
"Тип Прямокутник 2D, містить два векторних поля: ``position`` і ``size``. "
"Також містить поле ``end``, яке є ``.position + size``."

msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr ""
"Тип 3D вектора, містить поля ``x``, ``y`` і ``z``. Його також можна отримати "
"як масив."

msgid ":ref:`Vector3i <class_Vector3i>`"
msgstr ":ref:`Vector3i <class_Vector3i>`"

msgid ""
"Same as Vector3 but the components are integers. Can be use for indexing "
"items in a 3D grid."
msgstr ""
"Те саме, що Vector3, але компоненти є цілими числами. Можна використовувати "
"для індексування елементів у тривимірній сітці."

msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

msgid "3×2 matrix used for 2D transforms."
msgstr "3 × 2 матриця, що використовується для 2D перетворень."

msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr ""
"Тип 3D площини в нормалізованому вигляді, містить векторне поле ``normal`` і "
"скалярну відстань ``d``."

msgid ":ref:`Quaternion <class_Quaternion>`"
msgstr ":ref:`Quaternion <class_Quaternion>`"

msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr ""
"Quaternion - це тип даних, який використовується для представлення "
"тривимірного обертання. Корисний для інтерполяції обертів."

msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Also contains an ``end`` field which is "
"``position + size``."
msgstr ""
"Вісь вирівняна обмежувальною коробкою (або 3D коробкою) містить 2 векторних "
"поля: ``position`` і ``size``. Також містить поле ``end``, яке є ``position "
"+ size``."

msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"Матриця 3x3, використовується для 3D обертання та масштабування. Вона "
"містить 3 векторних полів (``x``, ``y`` і ``z``) , а також може бути "
"доступна в вигляді масиву 3D векторів."

msgid ":ref:`Transform3D <class_Transform3D>`"
msgstr ":ref:`Transform3D <class_Transform3D>`"

msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr ""
"3D перетворення містить поле Basis (Основа) ``basis``та поле Vector3 "
"``origin``."

msgid "Engine built-in types"
msgstr "Вбудовані типи движка"

msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"Color (Колір) тип даних містить поля ``r``, ``g``, ``b`` і ``a``. Також "
"можуть бути доступні ``h``, ``s`` і ``v`` для hue(відтінок)/ "
"saturation(насиченість) / value(значення)."

msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr ""
"Ідентифікатор ресурсу (RID). Сервери використовують загальні RID для "
"посилання непрозорих даних."

msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

msgid "Base class for anything that is not a built-in type."
msgstr "Базовий клас для всього, що не є вбудованим типом."

msgid "Container built-in types"
msgstr "Вбудовані типи контейнерів"

msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Negative indices count from the end."
msgstr ""
"Масиви - це послідовність об'єктів довільних типів, включаючи інші масиви, "
"чи словники (дивіться нижче). Масив може динамічно змінювати розмір. Масиви "
"індексуються, починаючи з індексу ``0``. Негативні показники рахуються з "
"кінця."

msgid "Typed arrays"
msgstr "Типізовані масиви"

msgid ""
"Godot 4.0 added support for typed arrays. On write operations, Godot checks "
"that element values match the specified type, so the array cannot contain "
"invalid values. The GDScript static analyzer takes typed arrays into "
"account, however array methods like ``front()`` and ``back()`` still have "
"the ``Variant`` return type."
msgstr ""
"Godot 4.0 додав підтримку типізованих масивів. Під час запису Godot "
"перевіряє, чи значення елементів відповідають указаному типу, тому масив не "
"може містити недійсні значення. Статичний аналізатор GDScript враховує "
"введені масиви, однак такі методи масиву, як ``front()`` і ``back()``, все "
"ще мають тип повернення ``Variant``."

msgid ""
"Typed arrays have the syntax ``Array[Type]``, where ``Type`` can be any "
"``Variant`` type, native or user class, or enum. Nested array types (like "
"``Array[Array[int]]``) are not supported."
msgstr ""
"Типова масиви мають синтаксис ``Array[Type]``, де ``Type`` може бути будь-"
"яким типом ``Variant``, власним або користувацьким класом, або переліком. "
"Типи вкладених масивів (наприклад, ``Array[Array[int]]`` не підтримуються."

msgid "``Array`` and ``Array[Variant]`` are the same thing."
msgstr "``Array`` і ``Array[Variant]`` — це те саме."

msgid ""
"Arrays are passed by reference, so the array element type is also an "
"attribute of the in-memory structure referenced by a variable in runtime. "
"The static type of a variable restricts the structures that it can reference "
"to. Therefore, you **cannot** assign an array with a different element type, "
"even if the type is a subtype of the required type."
msgstr ""
"Масиви передаються за посиланням, тому тип елемента масиву також є атрибутом "
"структури в пам’яті, на яку посилається змінна під час виконання. Статичний "
"тип змінної обмежує структури, на які вона може посилатися. Таким чином, ви "
"**не можете** призначити масиву інший тип елемента, навіть якщо тип є "
"підтипом потрібного типу."

msgid ""
"If you want to *convert* a typed array, you can create a new array and use "
"the :ref:`Array.assign() <class_Array_method_assign>` method:"
msgstr ""
"Якщо ви хочете *конвертувати* типізований масив, ви можете створити новий "
"масив і використати метод :ref:`Array.assign() <class_Array_method_assign>`:"

msgid ""
"The only exception was made for the ``Array`` (``Array[Variant]``) type, for "
"user convenience and compatibility with old code. However, operations on "
"untyped arrays are considered unsafe."
msgstr ""
"Єдиний виняток зроблено для типу ``Масив`` (``Array[Variant]``) для "
"зручності користувача та сумісності зі старим кодом. Однак операції з "
"нетиповими масивами вважаються небезпечними."

msgid "Packed arrays"
msgstr "Упаковані масиви"

msgid ""
"PackedArrays are generally faster to iterate on and modify compared to a "
"typed Array of the same type (e.g. PackedInt64Array versus Array[int]) and "
"consume less memory. In the worst case, they are expected to be as fast as "
"an untyped Array. Conversely, non-Packed Arrays (typed or not) have extra "
"convenience methods such as :ref:`Array.map <class_Array_method_map>` that "
"PackedArrays lack. Consult the :ref:`class reference "
"<class_PackedFloat32Array>` for details on the methods available. Typed "
"Arrays are generally faster to iterate on and modify than untyped Arrays."
msgstr ""
"Упаковані масиви, як правило, швидші для ітерації та модифікації порівняно з "
"введеним масивом того самого типу (наприклад, PackedInt64Array проти "
"Array[int]) і споживають менше пам’яті. У гіршому випадку очікується, що "
"вони будуть такими ж швидкими, як і нетипізований масив. Навпаки, "
"неупаковані масиви (типові чи ні) мають додаткові зручні методи, такі "
"як :ref:`Array.map <class_Array_method_map>`, яких у PackedArrays немає. "
"Зверніться до :ref:`class reference <class_PackedFloat32Array>`, щоб "
"дізнатися більше про доступні методи. Типізовані масиви, як правило, швидше "
"обробляти та змінювати, ніж нетипізовані масиви."

msgid ""
"While all Arrays can cause memory fragmentation when they become large "
"enough, if memory usage and performance (iteration and modification speed) "
"is a concern and the type of data you're storing is compatible with one of "
"the ``Packed`` Array types, then using those may yield improvements. "
"However, if you do not have such concerns (e.g. the size of your array does "
"not reach the tens of thousands of elements) it is likely more helpful to "
"use regular or typed Arrays, as they provide convenience methods that can "
"make your code easier to write and maintain (and potentially faster if your "
"data requires such operations a lot). If the data you will store is of a "
"known type (including your own defined classes), prefer to use a typed Array "
"as it may yield better performance in iteration and modification compared to "
"an untyped Array."
msgstr ""
"Хоча всі масиви можуть спричинити фрагментацію пам’яті, коли вони стають "
"достатньо великими, якщо використання пам’яті та продуктивність (швидкість "
"ітерації та модифікації) викликають занепокоєння, а тип даних, які ви "
"зберігаєте, сумісний з одним із типів ``пакованих`` масивів, їх використання "
"може призвести до покращень. Однак, якщо у вас немає таких проблем "
"(наприклад, розмір вашого масиву не досягає десятків тисяч елементів), "
"швидше за все, буде корисніше використовувати звичайні або типізовані "
"масиви, оскільки вони забезпечують зручні методи, які можуть полегшити "
"написання та підтримку вашого коду (і потенційно швидше, якщо ваші дані "
"вимагають таких операцій багато). Якщо дані, які ви зберігатимете, належать "
"до відомого типу (включно з вашими власними визначеними класами), віддайте "
"перевагу використанню типізованого масиву, оскільки він може забезпечити "
"кращу продуктивність під час ітерації та модифікації порівняно з "
"нетипізованим масивом."

msgid ""
":ref:`PackedByteArray <class_PackedByteArray>`: An array of bytes (integers "
"from 0 to 255)."
msgstr ""
":ref:`PackedByteArray <class_PackedByteArray>`: масив байтів (цілі числа від "
"0 до 255)."

msgid ""
":ref:`PackedInt32Array <class_PackedInt32Array>`: An array of 32-bit "
"integers."
msgstr ""
":ref:`PackedInt32Array <class_PackedInt32Array>`: масив 32-розрядних цілих "
"чисел."

msgid ""
":ref:`PackedInt64Array <class_PackedInt64Array>`: An array of 64-bit "
"integers."
msgstr ""
":ref:`PackedInt64Array <class_PackedInt64Array>`: масив 64-розрядних цілих "
"чисел."

msgid ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: An array of 32-bit "
"floats."
msgstr ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: масив 32-розрядних "
"чисел з плаваючою точкою."

msgid ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`: An array of 64-bit "
"floats."
msgstr ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`: масив 64-розрядних "
"чисел з плаваючою точкою."

msgid ""
":ref:`PackedStringArray <class_PackedStringArray>`: An array of strings."
msgstr ":ref:`PackedStringArray <class_PackedStringArray>`: масив рядків."

msgid ""
":ref:`PackedVector2Array <class_PackedVector2Array>`: An array "
"of :ref:`Vector2 <class_Vector2>` values."
msgstr ""
":ref:`PackedVector2Array <class_PackedVector2Array>`: масив "
"значень :ref:`Vector2 <class_Vector2>`."

msgid ""
":ref:`PackedVector3Array <class_PackedVector3Array>`: An array "
"of :ref:`Vector3 <class_Vector3>` values."
msgstr ""
":ref:`PackedVector3Array <class_PackedVector3Array>`: масив "
"значень :ref:`Vector3 <class_Vector3>`."

msgid ""
":ref:`PackedVector4Array <class_PackedVector4Array>`: An array "
"of :ref:`Vector4 <class_Vector4>` values."
msgstr ""
":ref:`PackedVector4Array <class_PackedVector4Array>`: Масив "
"значень :ref:`Vector4 <class_Vector4>`."

msgid ""
":ref:`PackedColorArray <class_PackedColorArray>`: An array of :ref:`Color "
"<class_Color>` values."
msgstr ""
":ref:`PackedColorArray <class_PackedColorArray>`: масив значень :ref:`Color "
"<class_Color>`."

msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

msgid "Associative container which contains values referenced by unique keys."
msgstr ""
"Асоціативний контейнер, який містить значення, на які посилаються унікальні "
"ключі."

msgid ""
"Lua-style table syntax is also supported. Lua-style uses ``=`` instead of "
"``:`` and doesn't use quotes to mark string keys (making for slightly less "
"to write). However, keys written in this form can't start with a digit (like "
"any GDScript identifier), and must be string literals."
msgstr ""
"Також підтримується синтаксис таблиць у стилі Lua. У стилі Lua "
"використовується ``=`` замість ``:`` і не використовуються лапки для "
"позначення ключів рядків (що робить трохи менше для запису). Однак ключі, "
"написані в цій формі, не можуть починатися з цифри (як і будь-який "
"ідентифікатор GDScript), а повинні бути рядковими літералами."

msgid ""
"To add a key to an existing dictionary, access it like an existing key and "
"assign to it:"
msgstr ""
"Щоб додати ключ до існуючого словника, зверніться до нього як до існуючого "
"ключа та призначте йому:"

msgid ""
"The bracket syntax can be used to access properties of "
"any :ref:`class_Object`, not just Dictionaries. Keep in mind it will cause a "
"script error when attempting to index a non-existing property. To avoid "
"this, use the :ref:`Object.get() <class_Object_method_get>` "
"and :ref:`Object.set() <class_Object_method_set>` methods instead."
msgstr ""
"Синтаксис дужок може використовуватися для доступу до властивостей будь-"
"якого :ref:`class_Object`, а не лише до словників. Майте на увазі, що спроба "
"індексувати неіснуючу властивість спричинить помилку скрипту . Щоб цього "
"уникнути, використовуйте методи :ref:`Object.get() "
"<class_Object_method_get>` та :ref:`Object.set() <class_Object_method_set>`."

msgid "Typed dictionaries"
msgstr "Типізовані словники"

msgid ""
"Godot 4.4 added support for typed dictionaries. On write operations, Godot "
"checks that element keys and values match the specified type, so the "
"dictionary cannot contain invalid keys or values. The GDScript static "
"analyzer takes typed dictionaries into account. However, dictionary methods "
"that return values still have the ``Variant`` return type."
msgstr ""
"У Godot 4.4 додано підтримку типізованих словників. Під час операцій запису "
"Godot перевіряє, чи відповідають ключі та значення елементів заданому типу, "
"тому словник не може містити недійсні ключі або значення. Статичний "
"аналізатор GDScript враховує типізовані словники. Однак методи словника, які "
"повертають значення, все ще мають тип повернення ``Variant``."

msgid ""
"Typed dictionaries have the syntax ``Dictionary[KeyType, ValueType]``, where "
"``KeyType`` and ``ValueType`` can be any ``Variant`` type, native or user "
"class, or enum. Both the key and value type **must** be specified, but you "
"can use ``Variant`` to make either of them untyped. Nested typed collections "
"(like ``Dictionary[String, Dictionary[String, int]]``) are not supported."
msgstr ""
"Типізовані словники мають синтаксис ``Dictionary[KeyType, ValueType]``, де "
"``KeyType`` та ``ValueType`` можуть бути будь-яким типом ``Variant``, рідним "
"або користувацьким класом, або переліком. Як ключ, так і тип значення "
"**обов'язково** мають бути вказані, але ви можете використовувати "
"``Variant``, щоб зробити будь-який з них нетипованим. Вкладені типізовані "
"колекції (наприклад, ``Dictionary[String, Dictionary[String, int]]``) не "
"підтримуються."

msgid "``Dictionary`` and ``Dictionary[Variant, Variant]`` are the same thing."
msgstr "``Dictionary`` і ``Dictionary[Variant, Variant]`` є одним і тим самим."

msgid ":ref:`Signal <class_Signal>`"
msgstr ":ref:`Signal <class_Signal>`"

msgid ""
"A signal is a message that can be emitted by an object to those who want to "
"listen to it. The Signal type can be used for passing the emitter around."
msgstr ""
"Сигнал - це повідомлення, яке може передати об'єкт тим, хто хоче його "
"прослухати. Тип сигналу можна використовувати для передачі випромінювача."

msgid ""
"Signals are better used by getting them from actual objects, e.g. "
"``$Button.button_up``."
msgstr ""
"Сигнали краще використовувати, отримуючи їх від реальних об’єктів, напр. "
"``$Button.button_up``."

msgid ":ref:`Callable <class_Callable>`"
msgstr ":ref:`Callable <class_Callable>`"

msgid ""
"Contains an object and a function, which is useful for passing functions as "
"values (e.g. when connecting to signals)."
msgstr ""
"Містить об’єкт і функцію, які корисні для передачі функцій як значень "
"(наприклад, під час підключення до сигналів)."

msgid ""
"Getting a method as a member returns a callable. ``var x = "
"$Sprite2D.rotate`` will set the value of ``x`` to a callable with "
"``$Sprite2D`` as the object and ``rotate`` as the method."
msgstr ""
"Отримання методу як члена повертає виклик. ``var x = $Sprite2D.rotate`` "
"встановить значення ``x`` для виклику з ``$Sprite2D`` як об’єкт і ``rotate`` "
"як метод."

msgid "You can call it using the ``call`` method: ``x.call(PI)``."
msgstr "Ви можете викликати його за допомогою методу ``call``: ``x.call(PI)``."

msgid "Variables"
msgstr "Змінні"

msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"Змінні можуть існувати як члени класу, або як локальні для функцій. Вони "
"створюються за допомогою ключового слова ``var`` і, за бажання, їм можна "
"присвоювати значення після ініціалізації."

msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"Змінні, не обов'язково, але можуть мати специфікацію типу. Коли тип "
"вказаний, змінна буде змушена завжди мати один і той самий тип, а спроба "
"призначити несумісне значення призведе до помилки."

msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr ""
"Типи задаються при створенні змінної з використанням символа ``:`` "
"(двокрапка) після імені змінної, за яким вказується тип."

msgid ""
"If the variable is initialized within the declaration, the type can be "
"inferred, so it's possible to omit the type name:"
msgstr ""
"Якщо змінна ініціалізована в оголошенні, тип можна визначити, тому можна "
"пропустити назву типу:"

msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr ""
"Таке визначення типу можливе лише в тому випадку, якщо призначене значення "
"має визначений тип, інакше виникне помилка."

msgid "Valid types are:"
msgstr "Підтримувані типи:"

msgid "Built-in types (Array, Vector2, int, String, etc.)."
msgstr "Вбудовані типи (Array, Vector2, int, String, тощо)."

msgid "Engine classes (Node, Resource, RefCounted, etc.)."
msgstr "Класи механізмів (Node, Resource, RefCounted тощо)."

msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"Імена констант, якщо вони містять ресурс скрипту (``MyScript`` якщо ви "
"визначили ``const MyScript = preload(\"res://my_script.gd\")``)."

msgid ""
"Other classes in the same script, respecting scope "
"(``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the "
"``class InnerClass`` in the same scope)."
msgstr ""
"Інші класи в тому ж скрипті, з дотриманням меж застосування "
"(``InnerClass.NestedClass`` якщо ви визначили ``class NestedClass`` "
"всередині ``class InnerClass`` в тих самих межах)."

msgid "Script classes declared with the ``class_name`` keyword."
msgstr "Класи скриптів, оголошені за допомогою ключового слова ``class_name``."

msgid "Autoloads registered as singletons."
msgstr "Автозавантаження, зареєстровані як синглтони."

msgid ""
"While ``Variant`` is a valid type specification, it's not an actual type. It "
"only means there's no set type and is equivalent to not having a static type "
"at all. Therefore, inference is not allowed by default for ``Variant``, "
"since it's likely a mistake."
msgstr ""
"Хоча ``Variant`` є дійсною специфікацією типу, це не справжній тип. Це лише "
"означає, що немає встановленого типу, і еквівалентно відсутності статичного "
"типу взагалі. Тому висновок не дозволений за замовчуванням для ``Variant``, "
"оскільки це, ймовірно, помилка."

msgid ""
"You can turn off this check, or make it only a warning, by changing it in "
"the project settings. See :ref:`doc_gdscript_warning_system` for details."
msgstr ""
"Ви можете вимкнути цю перевірку або зробити її лише попередженням, змінивши "
"її в налаштуваннях проекту. Перегляньте :ref:`doc_gdscript_warning_system` "
"для деталей."

msgid "Initialization order"
msgstr "Приклад ініціалізації"

msgid "Member variables are initialized in the following order:"
msgstr "Змінні-члени ініціалізуються в такому порядку:"

msgid ""
"Depending on the variable's static type, the variable is either ``null`` "
"(untyped variables and objects) or has a default value of the type (``0`` "
"for ``int``, ``false`` for ``bool``, etc.)."
msgstr ""
"Залежно від статичного типу змінної, змінна або ``null`` (нетипові змінні та "
"об’єкти), або має значення типу за замовчуванням (``0`` для ``int``, "
"``false`` для ` `bool`` тощо)."

msgid ""
"The specified values are assigned in the order of the variables in the "
"script, from top to bottom."
msgstr ""
"Зазначені значення присвоюються в порядку змінних у сценарії, зверху вниз."

msgid ""
"(Only for ``Node``-derived classes) If the ``@onready`` annotation is "
"applied to a variable, its initialization is deferred to step 5."
msgstr ""
"(Лише для класів, похідних від ``Node``.) Якщо до змінної застосовано "
"анотацію ``@onready``, її ініціалізація відкладається до кроку 5."

msgid "If defined, the ``_init()`` method is called."
msgstr "Якщо визначено, викликається метод ``_init()``."

msgid ""
"When instantiating scenes and resources, the exported values are assigned."
msgstr ""
"Під час створення екземплярів сцен і ресурсів призначаються експортовані "
"значення."

msgid ""
"(Only for ``Node``-derived classes) ``@onready`` variables are initialized."
msgstr ""
"(Тільки для класів, похідних від ``Node``) Змінні ``@onready`` "
"ініціалізуються."

msgid ""
"(Only for ``Node``-derived classes) If defined, the ``_ready()`` method is "
"called."
msgstr ""
"(Тільки для класів, похідних від ``Node``.) Якщо визначено, викликається "
"метод ``_ready()``."

msgid ""
"You can specify a complex expression as a variable initializer, including "
"function calls. Make sure the variables are initialized in the correct "
"order, otherwise your values may be overwritten. For example:"
msgstr ""
"Ви можете вказати складний вираз як ініціалізатор змінних, включаючи виклики "
"функцій. Переконайтеся, що змінні ініціалізовано в правильному порядку, "
"інакше ваші значення можуть бути перезаписані. Наприклад:"

msgid "Will print:"
msgstr "Надрукую:"

msgid ""
"To fix this, move the ``_data`` variable definition above the ``a`` "
"definition or remove the empty dictionary assignment (``= {}``)."
msgstr ""
"Щоб виправити це, перемістіть визначення змінної ``_data`` над визначенням "
"``a`` або видаліть порожнє призначення словника (``= {}``)."

msgid "Static variables"
msgstr "Статичні змінні"

msgid "A class member variable can be declared static:"
msgstr "Змінну-член класу можна оголосити статичною:"

msgid ""
"Static variables belong to the class, not instances. This means that static "
"variables share values between multiple instances, unlike regular member "
"variables."
msgstr ""
"Статичні змінні належать до класу, а не до екземплярів. Це означає, що "
"статичні змінні мають спільні значення для кількох екземплярів, на відміну "
"від звичайних змінних-членів."

msgid ""
"From inside a class, you can access static variables from any function, both "
"static and non-static. From outside the class, you can access static "
"variables using the class or an instance (the second is not recommended as "
"it is less readable)."
msgstr ""
"Зсередини класу ви можете отримати доступ до статичних змінних із будь-якої "
"функції, як статичної, так і нестатичної. Ззовні класу ви можете отримати "
"доступ до статичних змінних за допомогою класу або екземпляра (другий не "
"рекомендується, оскільки він менш читабельний)."

msgid ""
"The ``@export`` and ``@onready`` annotations cannot be applied to a static "
"variable. Local variables cannot be static."
msgstr ""
"Анотації ``@export`` і ``@onready`` не можна застосувати до статичної "
"змінної. Локальні змінні не можуть бути статичними."

msgid ""
"The following example defines a ``Person`` class with a static variable "
"named ``max_id``. We increment the ``max_id`` in the ``_init()`` function. "
"This makes it easy to keep track of the number of ``Person`` instances in "
"our game."
msgstr ""
"У наступному прикладі визначено клас ``Person`` зі статичною змінною з "
"назвою ``max_id``. Ми збільшуємо ``max_id`` у функції ``_init()``. Це "
"полегшує відстеження кількості екземплярів ``Person`` у нашій грі."

msgid ""
"In this code, we create two instances of our ``Person`` class and check that "
"the class and every instance have the same ``max_id`` value, because the "
"variable is static and accessible to every instance."
msgstr ""
"У цьому коді ми створюємо два екземпляри нашого класу ``Person`` і "
"перевіряємо, що клас і кожен екземпляр мають однакове значення ``max_id``, "
"оскільки змінна є статичною та доступною для кожного примірника."

msgid "Static variables can have type hints, setters and getters:"
msgstr "Статичні змінні можуть мати підказки типів, сеттери та геттери:"

msgid "A base class static variable can also be accessed via a child class:"
msgstr ""
"До статичної змінної базового класу також можна отримати доступ через "
"дочірній клас:"

msgid ""
"When referencing a static variable from a tool script, the other script "
"containing the static variable **must** also be a tool script. "
"See :ref:`Running code in the editor "
"<doc_running_code_in_the_editor_important_information>` for details."
msgstr ""
"Під час посилання на статичну змінну зі скрипта інструменту, інший скрипт, "
"що містить статичну змінну, також **повинен** бути скриптом інструменту. "
"Див. :ref:`Running code in the editor "
"<doc_running_code_in_the_editor_important_information>` для отримання "
"детальної інформації."

msgid "``@static_unload`` annotation"
msgstr "Анотація ``@static_unload``"

msgid ""
"Since GDScript classes are resources, having static variables in a script "
"prevents it from being unloaded even if there are no more instances of that "
"class and no other references left. This can be important if static "
"variables store large amounts of data or hold references to other project "
"resources, such as scenes. You should clean up this data manually, or use "
"the :ref:`@static_unload <class_@GDScript_annotation_@static_unload>` "
"annotation if static variables don't store important data and can be reset."
msgstr ""
"Оскільки класи GDScript є ресурсами, наявність статичних змінних у сценарії "
"запобігає його вивантаженню, навіть якщо більше немає екземплярів цього "
"класу та інших посилань. Це може бути важливо, якщо статичні змінні "
"зберігають великі обсяги даних або містять посилання на інші ресурси "
"проекту, наприклад сцени. Ви повинні очистити ці дані вручну або "
"скористатися анотацією :ref:`@static_unload "
"<class_@GDScript_annotation_@static_unload>`, якщо статичні змінні не "
"зберігають важливі дані та можуть бути скинуті."

msgid ""
"Currently, due to a bug, scripts are never freed, even if ``@static_unload`` "
"annotation is used."
msgstr ""
"Наразі через помилку сценарії ніколи не звільняються, навіть якщо "
"використовується анотація ``@static_unload``."

msgid ""
"Note that ``@static_unload`` applies to the entire script (including inner "
"classes) and must be placed at the top of the script, before ``class_name`` "
"and ``extends``:"
msgstr ""
"Зверніть увагу, що ``@static_unload`` застосовується до всього скрипта "
"(включно з внутрішніми класами) і має бути розміщений на початку скрипта, "
"перед ``class_name`` та ``extends``:"

msgid "See also `Static functions`_ and `Static constructor`_."
msgstr "Дивіться також `Статичні функції`_ і `Статичний конструктор`_."

msgid "Casting"
msgstr "Кастинг"

msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"Значення, присвоєні типізованим змінним, повинні мати сумісний тип. Якщо "
"потрібно примусити значення бути певного типу, зокрема для типів об'єктів, "
"ви можете використовувати оператор ``as``."

msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"Оператор спрацює вірно, якщо тип присвоєного об'єкта збігається з типом "
"змінної, або є підтипом її типу."

msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr ""
"Якщо значення не є підтипом, ця операція призведе до значення ``null``."

msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr ""
"Вбудовані типи будуть примусово перетворені, якщо це можливо, в противному "
"випадку движок видасть помилку."

msgid ""
"Casting is also useful to have better type-safe variables when interacting "
"with the scene tree:"
msgstr ""
"Приведення типів також корисне для кращої типобезпечності змінних під час "
"взаємодії з деревом сцени:"

msgid "Constants"
msgstr "Константи"

msgid ""
"Constants are values you cannot change when the game is running. Their value "
"must be known at compile-time. Using the ``const`` keyword allows you to "
"give a constant value a name. Trying to assign a value to a constant after "
"it's declared will give you an error."
msgstr ""
"Константи - це значення, які ви не можете змінити під час роботи гри. Їх "
"значення має бути відоме під час компіляції. Використання ключового слова "
"``const`` дозволяє надати значенню константи назву. Спроба присвоїти "
"значення константі після її оголошення буде давати вам помилку."

msgid "We recommend using constants whenever a value is not meant to change."
msgstr ""
"Ми рекомендуємо використовувати константи для значень які не призначені для "
"зміни."

msgid ""
"Although the type of constants is inferred from the assigned value, it's "
"also possible to add explicit type specification:"
msgstr ""
"Хоча тип констант визначається з присвоєного значення, також можливо додати "
"явну специфікацію типу:"

msgid "Assigning a value of an incompatible type will raise an error."
msgstr "Призначення значення несумісного типу призведе до помилки."

msgid ""
"You can also create constants inside a function, which is useful to name "
"local magic values."
msgstr ""
"Ви також можете створити константи всередині функції, що корисно для "
"іменування локальних магічних значень."

msgid "Enums"
msgstr "Переліки"

msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr ""
"Переліки - це, в основному, скорочення для констант, і вони дуже корисні, "
"якщо ви хочете призначити послідовні цілі числа якимось константам."

msgid ""
"If you pass a name to the enum, it will put all the keys inside a "
"constant :ref:`Dictionary <class_Dictionary>` of that name. This means all "
"constant methods of a dictionary can also be used with a named enum."
msgstr ""
"Якщо ви передасте ім’я переліку, він помістить усі ключі в "
"константу :ref:`Dictionary <class_Dictionary>` з цим ім’ям. Це означає, що "
"всі константні методи словника також можна використовувати з іменованим "
"переліком."

msgid ""
"Keys in a named enum are not registered as global constants. They should be "
"accessed prefixed by the enum's name (``Name.KEY``)."
msgstr ""
"Ключі в іменованому переліку не реєструються як глобальні константи. Доступ "
"до них має здійснюватися з префіксом імені переліку (``Name.KEY``)."

msgid ""
"If not assigning a value to a key of an enum it will be assigned the "
"previous value plus one, or ``0`` if it is the first entry in the enum. "
"Multiple keys with the same value are allowed."
msgstr ""
"Якщо не присвоїти значення ключу переліку, йому буде присвоєно попереднє "
"значення плюс один або ``0``, якщо це перший запис у переліку. Допускається "
"кілька ключів з однаковим значенням."

msgid "Functions"
msgstr "Функції"

msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members "
"(see `self`_), but is not always required (and should *not* be sent as the "
"function's first argument, unlike Python)."
msgstr ""
"Функції завжди належать до `class <Classes_>`_. Пріоритет області для пошуку "
"змінних: локальний → член класу → глобальний. Змінна ``self`` завжди "
"доступна та надається як опція для доступу до членів класу (див. `self`_), "
"але не завжди потрібна (і *не* повинна надсилатися як перший аргумент "
"функції, на відміну від Python)."

msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr ""
"Функція може повертати значення (``return``) в будь-якій точці. За "
"замовчуванням повертається - ``null``."

msgid ""
"If a function contains only one line of code, it can be written on one line:"
msgstr ""
"Якщо функція містить лише один рядок коду, її можна записати в одному рядку:"

msgid ""
"Functions can also have type specification for the arguments and for the "
"return value. Types for arguments can be added in a similar way to variables:"
msgstr ""
"Функції також можуть мати специфікацію типу для аргументів та для "
"повертаного значення. Типи для аргументів можна додавати подібно до змінних:"

msgid ""
"If a function argument has a default value, it's possible to infer the type:"
msgstr ""
"Якщо аргумент функції має значення за замовчуванням, можна визначити його "
"тип:"

msgid ""
"The return type of the function can be specified after the arguments list "
"using the arrow token (``->``):"
msgstr ""
"Тип повернення функції можна вказати після списку аргументів за допомогою "
"токена стрілки (``->``):"

msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"Функції, що мають тип повернення, **повинні** повертати значення "
"відповідного типу. Тип ``void`` означає, що функція нічого не повертає. "
"Функції можуть використовувати ключове слово ``return``, але вони не можуть "
"повертати ніякого значення."

msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"Функції, які повертають інший тип, **завжди** повинні повертати якесь "
"значення, тому якщо у вашому коді є операції розгалуження (наприклад "
"конструкцію ``if``/``else``), усі можливі шляхи повинні мати повернення. "
"Наприклад, якщо у вас ``return`` всередині блоку ``if``, але не після нього, "
"редактор викличе помилку, оскільки якщо умова блоку не буде виконана, "
"функція не матиме значення для повернення."

msgid "Referencing functions"
msgstr "Посилання на функції"

msgid ""
"Functions are first-class values in terms of the :ref:`Callable "
"<class_Callable>` object. Referencing a function by name without calling it "
"will automatically generate the proper callable. This can be used to pass "
"functions as arguments."
msgstr ""
"Функції є значеннями першого класу з точки зору об’єкта :ref:`Callable "
"<class_Callable>`. Посилання на функцію за іменем без її виклику автоматично "
"генерує правильний виклик. Це можна використовувати для передачі функцій як "
"аргументів."

msgid ""
"Callables **must** be called with the :ref:`call() "
"<class_Callable_method_call>` method. You cannot use the ``()`` operator "
"directly. This behavior is implemented to avoid performance issues on direct "
"function calls."
msgstr ""
"Об’єкти, що викликаються, **повинні** викликатися методом :ref:`call() "
"<class_Callable_method_call>`. Ви не можете безпосередньо використовувати "
"оператор ``()``. Ця поведінка реалізована, щоб уникнути проблем із "
"продуктивністю під час прямих викликів функцій."

msgid "Lambda functions"
msgstr "Лямбда-функції"

msgid ""
"Lambda functions allow you to declare functions that do not belong to a "
"class. Instead, a :ref:`Callable <class_Callable>` object is created and "
"assigned to a variable directly. This can be useful to create callables to "
"pass around without polluting the class scope."
msgstr ""
"Лямбда-функції дозволяють оголошувати функції, які не належать до класу. "
"Замість цього створюється об’єкт :ref:`Callable <class_Callable>`, який "
"безпосередньо призначається змінній. Це може бути корисним для створення "
"викликів для передачі без забруднення області класу."

msgid ""
"To call the created lambda you can use the :ref:`call() "
"<class_Callable_method_call>` method:"
msgstr ""
"Щоб викликати створену лямбда-вираз, можна скористатися методом :ref:`call() "
"<class_Callable_method_call>`:"

msgid ""
"Lambda functions can be named for debugging purposes (the name is displayed "
"in the Debugger):"
msgstr ""
"Лямбда-функції можна іменувати для цілей налагодження (назва відображається "
"в налагоджувачі):"

msgid ""
"You can specify type hints for lambda functions in the same way as for "
"regular ones:"
msgstr ""
"Ви можете вказати підказки типів для лямбда-функцій так само, як і для "
"звичайних:"

msgid ""
"Note that if you want to return a value from a lambda function, an explicit "
"``return`` is required (you can't omit ``return``):"
msgstr ""
"Зверніть увагу, що якщо ви хочете повернути значення з лямбда-функції, "
"потрібне явне вказівка ``return`` (не можна пропускати ``return``):"

msgid "Lambda functions capture the local environment:"
msgstr "Лямбда-функції фіксують локальне середовище:"

msgid ""
"Local variables are captured by value once, when the lambda is created. So "
"they won't be updated in the lambda if reassigned in the outer function:"
msgstr ""
"Локальні змінні захоплюються за значенням один раз, під час створення лямбда-"
"виразу. Тому вони не будуть оновлені в лямбда-виразі, якщо їх перепризначити "
"в зовнішній функції:"

msgid ""
"Also, a lambda cannot reassign an outer local variable. After exiting the "
"lambda, the variable will be unchanged, because the lambda capture "
"implicitly shadows it:"
msgstr ""
"Також лямбда-вираз не може перепризначити зовнішню локальну змінну. Після "
"виходу з лямбда-виразу змінна залишиться незмінною, оскільки захоплення "
"лямбда-виразу неявно затінює її:"

msgid ""
"However, if you use pass-by-reference data types (arrays, dictionaries, and "
"objects), then the content changes are shared until you reassign the "
"variable:"
msgstr ""
"Однак, якщо ви використовуєте типи даних з передачею за посиланням (масиви, "
"словники та об'єкти), то зміни вмісту будуть спільними, доки ви не "
"перепризначите змінну:"

msgid "Static functions"
msgstr "Статичні функції"

msgid ""
"A function can be declared static. When a function is static, it has no "
"access to the instance member variables or ``self``. A static function has "
"access to static variables. Also static functions are useful to make "
"libraries of helper functions:"
msgstr ""
"Функцію можна оголосити статичною. Коли функція є статичною, вона не має "
"доступу до змінних-членів екземпляра або ``self``. Статична функція має "
"доступ до статичних змінних. Також статичні функції корисні для створення "
"бібліотек допоміжних функцій:"

msgid "Lambda functions cannot be declared static."
msgstr "Лямбда-функції не можна оголосити статичними."

msgid "See also `Static variables`_ and `Static constructor`_."
msgstr "Дивіться також `Статичні змінні`_ і `Статичний конструктор`_."

msgid "Variadic functions"
msgstr "Варіадичні функції"

msgid ""
"A variadic function is a function that can take a variable number of "
"arguments. Since Godot 4.5, GDScript supports variadic functions. To declare "
"a variadic function, you need to use the *rest parameter*, which collects "
"all the excess arguments into an array."
msgstr ""
"Варіативна функція — це функція, яка може приймати змінну кількість "
"аргументів. Починаючи з Godot 4.5, GDScript підтримує варіативні функції. "
"Щоб оголосити варіативну функцію, потрібно використовувати параметр *rest*, "
"який збирає всі зайві аргументи в масив."

msgid ""
"A function can have at most one rest parameter, which must be the last one "
"in the parameter list. The rest parameter cannot have a default value. "
"Static and lambda functions can also be variadic."
msgstr ""
"Функція може мати щонайбільше один параметр-залишок, який має бути останнім "
"у списку параметрів. Параметр-залишок не може мати значення за "
"замовчуванням. Статичні та лямбда-функції також можуть бути змінними."

msgid ""
"Static typing works for variadic functions too. However, typed arrays are "
"currently not supported as a static type of the rest parameter:"
msgstr ""
"Статична типізація також працює для змінних функцій. Однак типізовані масиви "
"наразі не підтримуються як статичний тип параметра rest:"

msgid ""
"Although you can declare functions as variadic using the rest parameter, "
"unpacking parameters when calling a function using *spread syntax* that "
"exists in some languages ​​(JavaScript, PHP) is currently not supported in "
"GDScript. However, you can use ``callv()`` to call a function with an array "
"of arguments:"
msgstr ""
"Хоча ви можете оголошувати функції як змінні за допомогою параметра rest, "
"розпакування параметрів під час виклику функції з використанням *синтаксису "
"розгортання*, який існує в деяких мовах програмування (JavaScript, PHP), "
"наразі не підтримується в GDScript. Однак ви можете використовувати "
"``callv()`` для виклику функції з масивом аргументів:"

msgid "Abstract functions"
msgstr "Абстрактні функції"

msgid "See `Abstract classes and methods`_."
msgstr "Див. `Абстрактні класи та методи`_."

msgid "Statements and control flow"
msgstr "Оператори і управління потоком"

msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"Оператори є стандартними і можуть бути призначеннями, викликами функцій, "
"структурами контрольного потоку тощо (дивіться нижче). Роздільник ``;`` "
"абсолютно необов'язковий."

msgid "Expressions"
msgstr "Вирази"

msgid ""
"Expressions are sequences of operators and their operands in orderly "
"fashion. An expression by itself can be a statement too, though only calls "
"are reasonable to use as statements since other expressions don't have side "
"effects."
msgstr ""
"Вирази — це послідовності операторів та їхніх операндів у впорядкованому "
"порядку. Вираз сам по собі також може бути оператором, хоча лише виклики "
"розумно використовувати як оператори, оскільки інші вирази не мають побічних "
"ефектів."

msgid ""
"Expressions return values that can be assigned to valid targets. Operands to "
"some operator can be another expression. An assignment is not an expression "
"and thus does not return any value."
msgstr ""
"Вирази повертають значення, які можна призначити дійсним цілям. Операндами "
"для деяких операторів можуть бути інші вирази. Присвоєння не є виразом і "
"тому не повертає жодного значення."

msgid "Here are some examples of expressions:"
msgstr "Ось кілька прикладів виразів:"

msgid ""
"Identifiers, attributes, and subscripts are valid assignment targets. Other "
"expressions cannot be on the left side of an assignment."
msgstr ""
"Ідентифікатори, атрибути та індекси є дійсними цілями призначення. Інші "
"вирази не можуть бути в лівій частині завдання."

msgid ""
"``self`` can be used to refer to the current instance and is often "
"equivalent to directly referring to symbols available in the current script. "
"However, ``self`` also allows you to access properties, methods, and other "
"names that are defined dynamically (i.e. are expected to exist in subtypes "
"of the current class, or are provided using :ref:`_set() "
"<class_Object_private_method__set>` and/or :ref:`_get() "
"<class_Object_private_method__get>`)."
msgstr ""
"``self`` можна використовувати для посилання на поточний екземпляр і часто "
"еквівалентно прямому посиланню на символи, доступні в поточному сценарії. "
"Проте ``self`` також дозволяє вам отримати доступ до властивостей, методів "
"та інших імен, які визначені динамічно (тобто, як очікується, існуватимуть у "
"підтипах поточного класу або надаються за допомогою :ref:`_set() "
"<class_Object_private_method__set>` та/або :ref:`_get() "
"<class_Object_private_method__get>`)."

msgid ""
"Beware that accessing members of child classes in the base class is often "
"considered a bad practice, because this blurs the area of responsibility of "
"any given piece of code, making the overall relationship between parts of "
"your game harder to reason about. Besides that, one can simply forget that "
"the parent class had some expectations about it's descendants."
msgstr ""
"Майте на увазі, що доступ до членів дочірніх класів у базовому класі часто "
"вважається поганою практикою, оскільки це розмиває зону відповідальності "
"будь-якої даної частини коду, ускладнюючи загальний зв’язок між частинами "
"вашої гри. Крім того, можна просто забути, що батьківський клас мав певні "
"очікування щодо своїх нащадків."

msgid "if/else/elif"
msgstr "якщо/інакше/якщо-інакше (ельіф)"

msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"Прості умови створюються за допомогою синтаксису ``if``/``else``/``elif``. "
"Дужки навколо умов дозволені, але не обов'язкові. Враховуючи характер "
"відступів на основі табуляції, ``elif`` можна використовувати замість "
"``else``/``if`` для підтримки рівня відступу."

msgid "Short statements can be written on the same line as the condition:"
msgstr "Короткі оператори можна записати в тому ж рядку, що й умову:"

msgid ""
"Sometimes, you might want to assign a different initial value based on a "
"boolean expression. In this case, ternary-if expressions come in handy:"
msgstr ""
"Іноді вам може знадобитися призначити інше початкове значення на основі "
"булевого виразу. У цьому випадку стануть у пригоді тернарні вирази if:"

msgid ""
"Ternary-if expressions can be nested to handle more than 2 cases. When "
"nesting ternary-if expressions, it is recommended to wrap the complete "
"expression over multiple lines to preserve readability:"
msgstr ""
"Тернарні вирази типу \"if\" можуть бути вкладеними для обробки більше ніж 2 "
"випадків. Під час вкладення тернарних виразів типу \"if\" рекомендується "
"розміщувати весь вираз на кількох рядках для збереження читабельності:"

msgid ""
"You may also wish to check if a value is contained within something. You can "
"use an ``if`` statement combined with the ``in`` operator to accomplish this:"
msgstr ""
"Ви також можете перевірити, чи міститься значення всередині чогось. Для "
"цього можна використовувати оператор ``if`` у поєднанні з оператором ``in``:"

msgid ""
"Simple loops are created by using ``while`` syntax. Loops can be broken "
"using ``break`` or continued using ``continue`` (which skips to the next "
"iteration of the loop without executing any further code in the current "
"iteration):"
msgstr ""
"Прості цикли створюються за допомогою синтаксису ``while``. Цикли можна "
"розірвати за допомогою ``break`` або продовжити за допомогою ``continue`` "
"(що пропускає до наступної ітерації циклу без виконання подальшого коду в "
"поточній ітерації):"

msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *key* is stored in the "
"loop variable."
msgstr ""
"Для повторення (ітерації) діапазону, наприклад масиву, або таблиці, "
"використовується цикл *for*. Під час ітерації над масивом поточний елемент "
"масиву зберігається у змінній циклу. Під час ітерації над словником у "
"змінній циклу зберігається індекс."

msgid ""
"If you want to assign values on an array as it is being iterated through, it "
"is best to use ``for i in array.size()``."
msgstr ""
"Якщо ви хочете призначити значення масиву під час його проходження, найкраще "
"використовувати ``for i в array.size()``."

msgid ""
"The loop variable is local to the for-loop and assigning to it will not "
"change the value on the array. Objects passed by reference (such as nodes) "
"can still be manipulated by calling methods on the loop variable."
msgstr ""
"Змінна циклу є локальною для циклу for, і її призначення не змінить значення "
"в масиві. Об’єктами, переданими за посиланням (наприклад, вузлами), можна "
"маніпулювати, викликаючи методи змінної циклу."

msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"Оператор використовується для гілкування. Це еквівалент оператора "
"``switch``, який можна знайти в багатьох інших мовах, але``match`` пропонує "
"деякі додаткові функції."

msgid ""
"``match`` is more type strict than the ``==`` operator. For example ``1`` "
"will **not** match ``1.0``. The only exception is ``String`` vs "
"``StringName`` matching: for example, the String ``\"hello\"`` is considered "
"equal to the StringName ``&\"hello\"``."
msgstr ""
"``match`` є більш суворим за типом, ніж оператор ``==``. Наприклад, ``1`` "
"**не** відповідатиме ``1.0``. Єдиним винятком є збіг ``String`` проти "
"``StringName``: наприклад, рядок ``\"hello\"`` вважається рівним StringName "
"``&\"hello\"``."

msgid "Basic syntax"
msgstr "Основний синтаксис"

msgid "Crash-course for people who are familiar with switch statements"
msgstr "Експрес-курс для тих, хто знайомий з операторами перемикання"

msgid "Replace ``switch`` with ``match``."
msgstr "Замініть ``switch`` на ``match``."

msgid "Remove ``case``."
msgstr "Видаліть ``case``."

msgid "Remove any ``break``\\ s."
msgstr "Видаліть усі ``розриви``\\ s."

msgid "Change ``default`` to a single underscore."
msgstr "Змініть ``default`` на одне підкреслення."

msgid "Control flow"
msgstr "Контрольний потік"

msgid ""
"The patterns are matched from top to bottom. If a pattern matches, the first "
"corresponding block will be executed. After that, the execution continues "
"below the ``match`` statement."
msgstr ""
"Викрійки з’єднуються зверху вниз. Якщо шаблон збігається, буде виконано "
"перший відповідний блок. Після цього виконання продовжується під оператором "
"``match``."

msgid ""
"The special ``continue`` behavior in ``match`` supported in 3.x was removed "
"in Godot 4.0."
msgstr ""
"Спеціальну поведінку ``continue`` у ``match``, підтримувану в 3.x, було "
"видалено в Godot 4.0."

msgid "The following pattern types are available:"
msgstr "Доступні наступні типи візерунків:"

msgid "Literal pattern"
msgstr "Літеральний візерунок"

msgid "Matches a `literal <Literals_>`_:"
msgstr "Збігається з `literal <Literals_>`_:"

msgid "Expression pattern"
msgstr "Шаблон виразу"

msgid ""
"Matches a constant expression, an identifier, or an attribute access "
"(``A.B``):"
msgstr ""
"Збігається з константним виразом, ідентифікатором або доступом до атрибута "
"(``A.B``):"

msgid "Wildcard pattern"
msgstr "Шаблон Wildcard"

msgid "This pattern matches everything. It's written as a single underscore."
msgstr "Цей шаблон відповідає усьому. Він прописаний як окреме підкреслення."

msgid ""
"It can be used as the equivalent of the ``default`` in a ``switch`` "
"statement in other languages:"
msgstr ""
"Його можна використовувати як еквівалент ``default`` в операторі ``switch`` "
"іншими мовами:"

msgid "Binding pattern"
msgstr "Зв'язувальний шаблон"

msgid ""
"A binding pattern introduces a new variable. Like the wildcard pattern, it "
"matches everything - and also gives that value a name. It's especially "
"useful in array and dictionary patterns:"
msgstr ""
"Шаблон зв'язування вводить нову змінну. Як і шаблон підстановки, він "
"відповідає всьому, а також надає цьому значенню назву. Він особливо корисний "
"у шаблонах масивів та словників:"

msgid "Array pattern"
msgstr "Шаблон масиву"

msgid ""
"Matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr ""
"Відповідає масиву. Кожен окремий елемент шаблону масиву сам по собі є "
"шаблоном, тому їх можна вкладати."

msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr ""
"Спочатку тестується довжина масиву, він повинен бути того ж розміру, що і "
"шаблон, інакше шаблон не збігатиметься."

msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``."
msgstr ""
"**Масив відкритого типу**: Масив може стати більшим за шаблон, під час "
"виконання останнього під-шаблону ``..``."

msgid "Every subpattern has to be comma-separated."
msgstr "Кожен під-шаблон повинен бути розділений комою."

msgid "Dictionary pattern"
msgstr "Словниковий шаблон"

msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr ""
"Працює так само, як і шаблон масиву. Кожен ключ повинен бути постійним "
"шаблоном."

msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr ""
"Спочатку тестується розмір словника, він повинен бути того ж розміру, що і "
"шаблон, інакше шаблон не співладе."

msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``."
msgstr ""
"**Відкритий словник**: Словник може стати більшим за шаблон при виконанні "
"останнього підшаблону ``..``."

msgid "Every subpattern has to be comma separated."
msgstr "Кожен під-шаблон повинен бути відокремлений комою."

msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "Якщо значення не вказано, перевіряється лише наявність ключа."

msgid "A value pattern is separated from the key pattern with a ``:``."
msgstr "Шаблон значення відокремлений від основного шаблону ``:``."

msgid "Multiple patterns"
msgstr "Кілька шаблонів"

msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them."
msgstr ""
"Ви також можете вказати кілька шаблонів, розділених комою. Ці шаблони не "
"можуть мати ніяких прив'язок у них."

msgid "Pattern guards"
msgstr "Охоронці шаблону"

msgid ""
"A *pattern guard* is an optional condition that follows the pattern list and "
"allows you to make additional checks before choosing a ``match`` branch. "
"Unlike a pattern, a pattern guard can be an arbitrary expression."
msgstr ""
"*Захист шаблону* є необов’язковою умовою, яка слідує за списком шаблонів і "
"дозволяє вам робити додаткові перевірки перед вибором гілки "
"``відповідності``. На відміну від шаблону, шаблон guard може бути довільним "
"виразом."

msgid ""
"Only one branch can be executed per ``match``. Once a branch is chosen, the "
"rest are not checked. If you want to use the same pattern for multiple "
"branches or to prevent choosing a branch with too general pattern, you can "
"specify a pattern guard after the list of patterns with the ``when`` keyword:"
msgstr ""
"Тільки одна гілка може бути виконана за одне ``match``. Після вибору гілки "
"решта не перевіряються. Якщо ви хочете використовувати той самий шаблон для "
"кількох гілок або запобігти вибору гілки з надто загальним шаблоном, ви "
"можете вказати захист шаблону після списку шаблонів за допомогою ключового "
"слова ``when``:"

msgid ""
"If there is no matching pattern for the current branch, the pattern guard is "
"**not** evaluated and the patterns of the next branch are checked."
msgstr ""
"Якщо для поточної гілки немає відповідного шаблону, захист шаблонів **не** "
"оцінюється, а шаблони наступної гілки перевіряються."

msgid "If a matching pattern is found, the pattern guard is evaluated."
msgstr "Якщо знайдено відповідний шаблон, оцінюється захист шаблону."

msgid ""
"If it's true, then the body of the branch is executed and ``match`` ends."
msgstr "Якщо це істина, тоді тіло гілки виконується, а ``збіг`` завершується."

msgid "If it's false, then the patterns of the next branch are checked."
msgstr "Якщо воно невірне, то перевіряються шаблони наступної гілки."

msgid "Classes"
msgstr "Класи"

msgid ""
"By default, all script files are unnamed classes. In this case, you can only "
"reference them using the file's path, using either a relative or an absolute "
"path. For example, if you name a script file ``character.gd``:"
msgstr ""
"За замовчуванням усі файли скриптів є безіменними класами. У цьому випадку "
"ви можете посилатися на них лише за допомогою шляху до файлу, використовуючи "
"або відносний, або абсолютний шлях. Наприклад, якщо ви назвете файл скрипта "
"``character.gd``:"

msgid "Registering named classes"
msgstr "Реєстрація іменованих класів"

msgid ""
"You can give your class a name to register it as a new type in Godot's "
"editor. For that, you use the ``class_name`` keyword. You can optionally use "
"the ``@icon`` annotation with a path to an image, to use it as an icon. Your "
"class will then appear with its new icon in the editor:"
msgstr ""
"Ви можете дати своєму класу ім'я, щоб зареєструвати його як новий тип у "
"редакторі Godot. Для цього використовується ключове слово ``class_name``. За "
"потреби можна використовувати анотацію ``@icon`` зі шляхом до зображення, "
"щоб використовувати його як піктограму. Після цього ваш клас з'явиться в "
"редакторі з новою піктограмою:"

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor "
"Theme** :ref:`import options <doc_importing_images_editor_import_options>` "
"enabled. This allows icons to follow the editor's scale and theming settings "
"if the icons are designed with the same color palette as Godot's own icons."
msgstr ""
"SVG-зображення, які використовуються як спеціальні піктограми вузлів, "
"повинні мати **Редактор > Масштабувати за допомогою масштабу редактора** та "
"**Редактор > Перетворити значки за допомогою теми редактора** :ref:`import "
"options <doc_importing_images_editor_import_options>`. Це дозволяє "
"піктограмам відповідати параметрам масштабу та тематики редактора, якщо "
"піктограми розроблено з тією ж палітрою кольорів, що й власні піктограми "
"Godot."

msgid "Here's a class file example:"
msgstr "Ось зразок файла класу:"

msgid "If you want to use ``extends`` too, you can keep both on the same line:"
msgstr ""
"Якщо ви також хочете використовувати ``extends``, ви можете залишити обидва "
"в одному рядку:"

msgid ""
"Named classes are globally registered, which means they become available to "
"use in other scripts without the need to ``load`` or ``preload`` them:"
msgstr ""
"Іменовані класи реєструються глобально, що означає, що вони стають "
"доступними для використання в інших скриптах без необхідності ``load`` або "
"``preload`` їх:"

msgid ""
"Godot initializes non-static variables every time you create an instance, "
"and this includes arrays and dictionaries. This is in the spirit of thread "
"safety, since scripts can be initialized in separate threads without the "
"user knowing."
msgstr ""
"Godot ініціалізує нестатичні змінні кожного разу, коли ви створюєте "
"екземпляр, і це включає масиви та словники. Це в дусі потокової безпеки, "
"оскільки сценарії можна ініціалізувати в окремих потоках без відома "
"користувача."

msgid ""
"The Godot editor will hide these custom classes with names that begin with "
"the prefix \"Editor\" in the 'Create New Node' or 'Create New Scene' dialog "
"windows. The classes are available for instantiation at runtime via their "
"class names, but are automatically hidden by the editor windows along with "
"the built-in editor nodes used by the Godot editor."
msgstr ""
"Редактор Godot приховає ці спеціальні класи з іменами, які починаються з "
"префікса «Редактор» у діалогових вікнах «Створити новий вузол» або «Створити "
"нову сцену». Класи доступні для створення екземплярів під час виконання "
"через їхні імена класів, але автоматично приховані вікнами редактора разом "
"із вбудованими вузлами редактора, які використовуються редактором Godot."

msgid "Abstract classes and methods"
msgstr "Абстрактні класи та методи"

msgid ""
"Since Godot 4.5, you can define abstract classes and methods using the "
"``@abstract`` annotation."
msgstr ""
"Починаючи з Godot 4.5, ви можете визначати абстрактні класи та методи за "
"допомогою анотації ``@abstract``."

msgid ""
"An abstract class is a class that cannot be instantiated directly. Instead, "
"it is meant to be inherited by other classes. Attempting to instantiate an "
"abstract class will result in an error."
msgstr ""
"Абстрактний клас — це клас, екземпляр якого не можна створити безпосередньо. "
"Натомість він призначений для успадкування іншими класами. Спроба створити "
"екземпляр абстрактного класу призведе до помилки."

msgid ""
"An abstract method is a method that has no implementation. Therefore, a "
"newline or a semicolon is expected after the function header. This defines a "
"contract that inheriting classes must conform to, because the method "
"signature must be compatible when overriding."
msgstr ""
"Абстрактний метод — це метод, який не має реалізації. Тому після заголовка "
"функції очікується новий рядок або крапка з комою. Це визначає контракт, "
"якому повинні відповідати успадковувані класи, оскільки сигнатура методу має "
"бути сумісною під час перевизначення."

msgid ""
"Inheriting classes must either provide implementations for all abstract "
"methods, or the inheriting class must be marked as abstract. If a class has "
"at least one abstract method (either its own or an unimplemented inherited "
"one), then it must also be marked as abstract. However, the reverse is not "
"true: an abstract class is allowed to have no abstract methods."
msgstr ""
"Класи-успадковувачі повинні або забезпечувати реалізації для всіх "
"абстрактних методів, або клас-успадковувач має бути позначений як "
"абстрактний. Якщо клас має хоча б один абстрактний метод (або свій власний, "
"або нереалізований успадкований), то він також має бути позначений як "
"абстрактний. Однак зворотне не вірно: абстрактному класу дозволено не мати "
"абстрактних методів."

msgid ""
"If you want to declare a method as optional to be overridden, you should use "
"a non-abstract method and provide a default implementation."
msgstr ""
"Якщо ви хочете оголосити метод як необов'язковий для перевизначення, вам "
"слід використовувати неабстрактний метод та надати реалізацію за "
"замовчуванням."

msgid ""
"For example, you could have an abstract class called ``Shape`` that defines "
"an abstract method called ``draw()``. You can then create subclasses like "
"``Circle`` and ``Square`` that implement the ``draw()`` method in their own "
"way. This allows you to define a common *interface* for all shapes without "
"having to implement all the details in the abstract class itself:"
msgstr ""
"Наприклад, ви можете мати абстрактний клас під назвою ``Shape``, який "
"визначає абстрактний метод під назвою ``draw()``. Потім ви можете створити "
"підкласи, такі як ``Circle`` та ``Square``, які реалізують метод ``draw()`` "
"по-своєму. Це дозволяє вам визначити спільний *інтерфейс* для всіх фігур без "
"необхідності реалізовувати всі деталі в самому абстрактному класі:"

msgid ""
"Both inner classes and classes created using ``class_name`` can be abstract. "
"This example creates two abstract classes, one of which is a subclass of "
"another abstract class:"
msgstr ""
"Як внутрішні класи, так і класи, створені за допомогою ``class_name``, "
"можуть бути абстрактними. У цьому прикладі створюється два абстрактних "
"класи, один з яких є підкласом іншого абстрактного класу:"

msgid ""
"Since an abstract class cannot be instantiated, it is not possible to attach "
"an abstract class to a node. If you attempt to do so, the engine will print "
"an error when running the scene:"
msgstr ""
"Оскільки абстрактний клас не може бути створений, його неможливо приєднати "
"до вузла. Якщо ви спробуєте це зробити, рушій виведе помилку під час запуску "
"сцени:"

msgid ""
"Unnamed classes can also be defined as abstract, the ``@abstract`` "
"annotation must precede ``extends``:"
msgstr ""
"Безіменовані класи також можна визначити як абстрактні, анотація "
"``@abstract`` повинна передувати ``extends``:"

msgid "Inheritance"
msgstr "Успадкування"

msgid "A class (stored as a file) can inherit from:"
msgstr "Клас (зберігається як файл) може успадковувати від:"

msgid "A global class."
msgstr "Глобального класу."

msgid "Another class file."
msgstr "Іншого класу."

msgid "An inner class inside another class file."
msgstr "Внутрішнього класу всередині іншого файла класу."

msgid "Multiple inheritance is not allowed."
msgstr "Багаторазове успадкування неможливе."

msgid "Inheritance uses the ``extends`` keyword:"
msgstr "Успадкування використовує ключове слово ``extends``:"

msgid ""
"If inheritance is not explicitly defined, the class will default to "
"inheriting :ref:`class_RefCounted`."
msgstr ""
"Якщо успадкування не визначено явно, клас за умовчанням "
"успадковуватиме :ref:`class_RefCounted`."

msgid ""
"To check if a given instance inherits from a given class, the ``is`` keyword "
"can be used:"
msgstr ""
"Щоб перевірити, чи успадковується даний екземпляр від даного класу, можна "
"використовувати ключове слово ``is``:"

msgid ""
"To call a function in a *super class* (i.e. one ``extend``-ed in your "
"current class), use the ``super`` keyword:"
msgstr ""
"Щоб викликати функцію в *суперкласі* (тобто в одному ``extend``-(у вашому "
"поточному класі), використовуйте ``super`` ключове слово:"

msgid ""
"This is especially useful because functions in extending classes replace "
"functions with the same name in their super classes. If you still want to "
"call them, you can use ``super``:"
msgstr ""
"Це особливо корисно, оскільки функції в розширюючих класах замінюють функції "
"з тим самим ім'ям у їхніх суперкласах. Якщо ви все ще хочете їх викликати, "
"ви можете використовувати ``super``:"

msgid ""
"If you need to call a different function from the super class, you can "
"specify the function name with the attribute operator:"
msgstr ""
"Якщо вам потрібно викликати іншу функцію з суперкласу, ви можете вказати "
"назву функції за допомогою оператора атрибута:"

msgid ""
"One of the common misconceptions is trying to override *non-virtual* engine "
"methods such as ``get_class()``, ``queue_free()``, etc. This is not "
"supported for technical reasons."
msgstr ""
"Одним із поширених помилкових уявлень є спроба перевизначити *невіртуальні* "
"методи двигуна, такі як ``get_class()``, ``queue_free()`` тощо. Це не "
"підтримується з технічних причин."

msgid ""
"In Godot 3, you can *shadow* engine methods in GDScript, and it will work if "
"you call this method in GDScript. However, the engine will **not** execute "
"your code if the method is called inside the engine on some event."
msgstr ""
"У Godot 3 ви можете *затіняти* методи двигуна в GDScript, і це працюватиме, "
"якщо викликати цей метод у GDScript. Однак механізм **не** виконає ваш код, "
"якщо метод викликається всередині механізму під час певної події."

msgid ""
"In Godot 4, even shadowing may not always work, as GDScript optimizes native "
"method calls. Therefore, we added the ``NATIVE_METHOD_OVERRIDE`` warning, "
"which is treated as an error by default. We strongly advise against "
"disabling or ignoring the warning."
msgstr ""
"У Godot 4 навіть затінення може не завжди працювати, оскільки GDScript "
"оптимізує виклики рідних методів. Тому ми додали попередження "
"``NATIVE_METHOD_OVERRIDE``, яке за умовчанням розглядається як помилка. Ми "
"настійно рекомендуємо не вимикати або ігнорувати попередження."

msgid ""
"Note that this does not apply to virtual methods such as ``_ready()``, "
"``_process()`` and others (marked with the ``virtual`` qualifier in the "
"documentation and the names start with an underscore). These methods are "
"specifically for customizing engine behavior and can be overridden in "
"GDScript. Signals and notifications can also be useful for these purposes."
msgstr ""
"Зауважте, що це не стосується віртуальних методів, таких як ``_ready()``, "
"``_process()`` та інших (позначених кваліфікатором ``virtual`` у "
"документації та назви починаються з підкреслення). Ці методи призначені "
"спеціально для налаштування поведінки двигуна та можуть бути замінені в "
"GDScript. Для цих цілей також можуть бути корисні сигнали та повідомлення."

msgid "Class constructor"
msgstr "Конструктор класу"

msgid ""
"The class constructor, called on class instantiation, is named ``_init``. If "
"you want to call the base class constructor, you can also use the ``super`` "
"syntax. Note that every class has an implicit constructor that is always "
"called (defining the default values of class variables). ``super`` is used "
"to call the explicit constructor:"
msgstr ""
"Конструктор класу, який викликається під час створення екземпляра класу, "
"називається ``_init``. Якщо ви хочете викликати конструктор базового класу, "
"ви також можете використовувати синтаксис ``super``. Зверніть увагу, що "
"кожен клас має неявний конструктор, який завжди викликається (визначає "
"значення змінних класу за замовчуванням). ``super`` використовується для "
"виклику явного конструктора:"

msgid "This is better explained through examples. Consider this scenario:"
msgstr "Це краще пояснити на прикладах. Розглянемо такий сценарій:"

msgid "There are a few things to keep in mind here:"
msgstr "Тут слід зазначити таке:"

msgid ""
"If the inherited class (``state.gd``) defines an ``_init`` constructor that "
"takes arguments (``e`` in this case), then the inheriting class "
"(``idle.gd``) *must* define ``_init`` as well and pass appropriate "
"parameters to ``_init`` from ``state.gd``."
msgstr ""
"Якщо успадкований клас (``state.gd``) визначає конструктор ``_init``, який "
"приймає аргументи (``e`` у цьому випадку), тоді успадкований клас "
"(``idle.gd``) *повинен* також визначити ``_init`` та передати відповідні "
"параметри до ``_init`` з ``state.gd``."

msgid ""
"``idle.gd`` can have a different number of arguments than the base class "
"``state.gd``."
msgstr ""
"``idle.gd`` може мати іншу кількість аргументів, ніж базовий клас "
"``state.gd``."

msgid ""
"In the example above, ``e`` passed to the ``state.gd`` constructor is the "
"same ``e`` passed in to ``idle.gd``."
msgstr ""
"У наведеному вище прикладі ``e``, переданий конструктору ``state.gd``, є тим "
"самим ``e``, переданим ``idle.gd``."

msgid ""
"If ``idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to "
"pass some value to the ``state.gd`` base class, even if it does nothing. "
"This brings us to the fact that you can pass expressions to the base "
"constructor as well, not just variables, e.g.:"
msgstr ""
"Якщо конструктор ``_init`` класу ``idle.gd`` не приймає жодних аргументів, "
"йому все одно потрібно передавати якесь значення базовому класу "
"``state.gd``, навіть якщо він нічого не робить. Це підводить нас до того "
"факту, що базовому конструктору можна передавати не лише змінні, а й вирази, "
"наприклад:"

msgid "func _init():"
msgstr "func _init():"

msgid "super(5)"
msgstr "super(5)"

msgid "Static constructor"
msgstr "Статичний конструктор"

msgid ""
"A static constructor is a static function ``_static_init`` that is called "
"automatically when the class is loaded, after the static variables have been "
"initialized:"
msgstr ""
"Статичний конструктор — це статична функція ``_static_init``, яка "
"викликається автоматично під час завантаження класу, після ініціалізації "
"статичних змінних:"

msgid ""
"A static constructor cannot take arguments and must not return any value."
msgstr ""
"Статичний конструктор не може приймати аргументи та не повинен повертати "
"значення."

msgid "Inner classes"
msgstr "Внутрішні класи"

msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"Файл класу може містити внутрішні класи. Внутрішні класи визначаються за "
"допомогою ключового слова ``class``. Вони встановлені за допомогою функції "
"``ClassName.new()``."

msgid "Classes as resources"
msgstr "Класи як ресурси"

msgid ""
"Classes stored as files are treated as :ref:`GDScripts <class_GDScript>`. "
"They must be loaded from disk to access them in other classes. This is done "
"using either the ``load`` or ``preload`` functions (see below). Instancing "
"of a loaded class resource is done by calling the ``new`` function on the "
"class object:"
msgstr ""
"Класи, що зберігаються у вигляді файлів, обробляються як :ref:`GDScripts "
"<class_GDScript>`. Для доступу до них в інших класах їх необхідно "
"завантажити з диска. Це робиться за допомогою функцій ``load`` або "
"``preload`` (див. нижче). Створення екземпляра завантаженого ресурсу класу "
"здійснюється викликом функції ``new`` на об'єкті класу:"

msgid "Exports"
msgstr "Експорт"

msgid ""
"Documentation about exports has been moved to :ref:`doc_gdscript_exports`."
msgstr "Документація про експорт переміщена до :ref:`doc_gdscript_exports`."

msgid "Properties (setters and getters)"
msgstr "Властивості (сеттери та геттери)"

msgid ""
"Sometimes, you want a class' member variable to do more than just hold data "
"and actually perform some validation or computation whenever its value "
"changes. It may also be desired to encapsulate its access in some way."
msgstr ""
"Іноді ви хочете, щоб змінна-член класу робила більше, ніж просто зберігала "
"дані, і фактично виконувала перевірку або обчислення кожного разу, коли її "
"значення змінюється. Також може знадобитися певним чином інкапсулювати його "
"доступ."

msgid ""
"For this, GDScript provides a special syntax to define properties using the "
"``set`` and ``get`` keywords after a variable declaration. Then you can "
"define a code block that will be executed when the variable is accessed or "
"assigned."
msgstr ""
"Для цього GDScript надає спеціальний синтаксис для визначення властивостей "
"за допомогою ключових слів ``set`` і ``get`` після оголошення змінної. Потім "
"ви можете визначити блок коду, який буде виконуватися, коли змінна отримує "
"доступ або призначається."

msgid "Example:"
msgstr "Приклад:"

msgid ""
"Unlike ``setget`` in previous Godot versions, ``set`` and ``get`` methods "
"are **always** called (except as noted below), even when accessed inside the "
"same class (with or without prefixing with ``self.``). This makes the "
"behavior consistent. If you need direct access to the value, use another "
"variable for direct access and make the property code use that name."
msgstr ""
"На відміну від ``setget`` у попередніх версіях Godot, ``set`` і ``get`` "
"методи **завжди** викликаються (окрім випадків, зазначених нижче), навіть "
"коли до них звертаються всередині одного класу (з префіксом або без нього "
"``само.``). Це робить поведінку послідовною. Якщо вам потрібен прямий доступ "
"до значення, використовуйте іншу змінну для прямого доступу та зробіть так, "
"щоб код властивості використовував це ім’я."

msgid "Alternative syntax"
msgstr "Альтернативний синтаксис"

msgid ""
"Also there is another notation to use existing class functions if you want "
"to split the code from the variable declaration or you need to reuse the "
"code across multiple properties (but you can't distinguish which property "
"the setter/getter is being called for):"
msgstr ""
"Також існує ще одна нотація для використання існуючих функцій класу, якщо ви "
"хочете розділити код з оголошення змінної або вам потрібно повторно "
"використовувати код для кількох властивостей (але ви не можете розрізнити, "
"для якої властивості викликається сеттер/геттер):"

msgid "This can also be done in the same line:"
msgstr "Це також можна зробити в тому ж рядку:"

msgid ""
"The setter and getter must use the same notation, mixing styles for the same "
"variable is not allowed."
msgstr ""
"Сетер і геттер повинні використовувати однакову нотацію, змішування стилів "
"для однієї змінної не допускається."

msgid ""
"You cannot specify type hints for *inline* setters and getters. This is done "
"on purpose to reduce the boilerplate. If the variable is typed, then the "
"setter's argument is automatically of the same type, and the getter's return "
"value must match it. Separated setter/getter functions can have type hints, "
"and the type must match the variable's type or be a wider type."
msgstr ""
"Ви не можете вказати підказки типу для *вбудованих* сеттерів і гетерів. Це "
"зроблено навмисно, щоб зменшити шаблон. Якщо змінна введена, то аргумент "
"сеттера автоматично має той самий тип, і значення, що повертається геттером, "
"має відповідати йому. Окремі функції встановлення/отримання можуть мати "
"підказки щодо типу, і тип має відповідати типу змінної або бути ширшим типом."

msgid "When setter/getter is not called"
msgstr "Коли сетер/гетер не викликається"

msgid ""
"When a variable is initialized, the value of the initializer will be written "
"directly to the variable. Including if the ``@onready`` annotation is "
"applied to the variable."
msgstr ""
"Коли змінна ініціалізована, значення ініціалізатора буде записане "
"безпосередньо в змінну. У тому числі, якщо до змінної застосовано анотацію "
"``@onready``."

msgid ""
"Using the variable's name to set it inside its own setter or to get it "
"inside its own getter will directly access the underlying member, so it "
"won't generate infinite recursion and saves you from explicitly declaring "
"another variable:"
msgstr ""
"Використання імені змінної для її встановлення всередині власного сеттера "
"або для отримання її всередині власного геттера призведе до безпосереднього "
"доступу до базового члена, тому це не генеруватиме нескінченну рекурсію та "
"позбавить вас необхідності явно оголошувати іншу змінну:"

msgid "This also applies to the alternative syntax:"
msgstr "Це також стосується альтернативного синтаксису:"

msgid ""
"The exception does **not** propagate to other functions called in the setter/"
"getter. For example, the following code **will** cause an infinite recursion:"
msgstr ""
"Виняток **не** поширюється на інші функції, що викликаються в сеттері/"
"геттері. Наприклад, наступний код **викличе** нескінченну рекурсію:"

msgid "Tool mode"
msgstr "Режим інструмента"

msgid ""
"By default, scripts don't run inside the editor and only the exported "
"properties can be changed. In some cases, it is desired that they do run "
"inside the editor (as long as they don't execute game code or manually avoid "
"doing so). For this, the ``@tool`` annotation exists and must be placed at "
"the top of the file:"
msgstr ""
"За замовчуванням скрипти не виконуються всередині редактора, і можна "
"змінювати лише експортовані властивості. У деяких випадках бажано, щоб вони "
"виконувалися всередині редактора (якщо вони не виконують ігровий код або "
"вручну уникають цього). Для цього існує анотація ``@tool``, яку потрібно "
"розмістити на початку файлу:"

msgid "See :ref:`doc_running_code_in_the_editor` for more information."
msgstr "Додаткову інформацію дивіться в :ref:`doc_running_code_in_the_editor`."

msgid ""
"Be cautious when freeing nodes with ``queue_free()`` or ``free()`` in a tool "
"script (especially the script's owner itself). As tool scripts run their "
"code in the editor, misusing them may lead to crashing the editor."
msgstr ""
"Будьте обережні, звільняючи вузли за допомогою ``queue_free()``, або "
"``free()``, в скрипті інструмента (особливо самого власника скрипту). "
"Оскільки скрипти інструментів виконують свій код у редакторі, неправильне "
"використання може призвести до збою редактора."

msgid "Memory management"
msgstr "Управління пам'яттю"

msgid ""
"Godot implements reference counting to free certain instances that are no "
"longer used, instead of a garbage collector, or requiring purely manual "
"management. Any instance of the :ref:`class_RefCounted` class (or any class "
"that inherits it, such as :ref:`class_Resource`) will be freed automatically "
"when no longer in use. For an instance of any class that is not "
"a :ref:`class_RefCounted` (such as :ref:`class_Node` or the "
"base :ref:`class_Object` type), it will remain in memory until it is deleted "
"with ``free()`` (or ``queue_free()`` for Nodes)."
msgstr ""
"Godot реалізує підрахунок посилань, щоб звільнити певні екземпляри, які "
"більше не використовуються, замість збирача сміття або потребують суто "
"ручного керування. Будь-який екземпляр класу :ref:`class_RefCounted` (або "
"будь-який клас, який його успадковує, наприклад :ref:`class_Resource`) буде "
"автоматично звільнено, коли він більше не використовується. Примірник будь-"
"якого класу, який не є :ref:`class_RefCounted` (наприклад, :ref:`class_Node` "
"або базовий тип :ref:`class_Object`), він залишатиметься в пам’яті, доки "
"його не буде видалено з ``free ()`` (або ``queue_free()`` для вузлів)."

msgid ""
"If a :ref:`class_Node` is deleted via ``free()`` or ``queue_free()``, all of "
"its children will also recursively be deleted."
msgstr ""
"Якщо :ref:`class_Node` видалено за допомогою ``free()`` або "
"``queue_free()``, усі його дочірні елементи також будуть рекурсивно видалені."

msgid ""
"To avoid reference cycles that can't be freed, a :ref:`class_WeakRef` "
"function is provided for creating weak references, which allow access to the "
"object without preventing a :ref:`class_RefCounted` from freeing. Here is an "
"example:"
msgstr ""
"Щоб уникнути посилальних циклів, які не можна звільнити, надається "
"функція :ref:`class_WeakRef` для створення слабких посилань, які дозволяють "
"отримати доступ до об’єкта, не перешкоджаючи "
"звільненню :ref:`class_RefCounted`. Ось приклад:"

msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"Крім того, коли не використовуються посилання, "
"``is_instance_valid(instance)`` можуть бути використані для перевірки, чи "
"об'єкт звільнений."

msgid "Signals"
msgstr "Сигнали"

msgid ""
"Signals are a tool to emit messages from an object that other objects can "
"react to. To create custom signals for a class, use the ``signal`` keyword."
msgstr ""
"Сигнали - це інструмент для передачі повідомлень від об'єкта, на який можуть "
"реагувати інші об'єкти. Щоб створити спеціальні сигнали для класу, "
"використовуйте ключове слово ``signal``."

msgid ""
"Signals are a `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ mechanism. They also fill the role of "
"Observers, a common programming pattern. For more information, read the "
"`Observer tutorial <https://gameprogrammingpatterns.com/observer.html>`_ in "
"the Game Programming Patterns ebook."
msgstr ""
"Сигнали - це механізм `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ . Вони також виконують роль "
"спостерігачів, загальна схема програмування. Для отримання додаткової "
"інформації читайте `Observer tutorial <https://gameprogrammingpatterns.com/"
"observer.html>`_ у книзі \"Шаблони програмування ігор\"."

msgid ""
"You can connect these signals to methods the same way you connect built-in "
"signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody3D`."
msgstr ""
"Ви можете підключити ці сигнали до методів так само, як підключаєте "
"вбудовані сигнали вузлів, наприклад :ref:`class_Button` "
"або :ref:`class_RigidBody3D`."

msgid ""
"In the example below, we connect the ``health_depleted`` signal from a "
"``Character`` node to a ``Game`` node. When the ``Character`` node emits the "
"signal, the game node's ``_on_character_health_depleted`` is called:"
msgstr ""
"У наведеному нижче прикладі ми підключаємо сигнал ``health_depleted`` від "
"вузла ``Character`` до вузла ``Game``. Коли вузол ``Character`` випромінює "
"сигнал, викликається сигнал ``_on_character_health_depleted`` ігрового вузла:"

msgid "You can emit as many arguments as you want along with a signal."
msgstr "Ви можете передати скільки завгодно аргументів разом із сигналом."

msgid ""
"Here is an example where this is useful. Let's say we want a life bar on "
"screen to react to health changes with an animation, but we want to keep the "
"user interface separate from the player in our scene tree."
msgstr ""
"Ось приклад, коли це корисно. Скажімо, ми хочемо, щоб панель життя на екрані "
"реагувала на зміни здоров'я за допомогою анімації, але ми хочемо, щоб "
"інтерфейс користувача був окремим від гравця в нашому дереві сцен."

msgid ""
"In our ``character.gd`` script, we define a ``health_changed`` signal and "
"emit it with :ref:`Signal.emit() <class_Signal_method_emit>`, and from a "
"``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` "
"using the :ref:`Signal.connect() <class_Signal_method_connect>` method:"
msgstr ""
"У нашому скрипті ``character.gd`` ми визначаємо сигнал ``health_changed`` та "
"випромінюємо його за допомогою :ref:`Signal.emit() "
"<class_Signal_method_emit>`, а з вузла ``Game``, розташованого вище в нашому "
"дереві сцен, ми підключаємо його до ``Lifebar`` за допомогою "
"методу :ref:`Signal.connect() <class_Signal_method_connect>`:"

msgid ""
"In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, "
"then connect the character, that emits the signal, to the receiver, the "
"``Lifebar`` node in this case."
msgstr ""
"У вузлі ``Game`` ми отримуємо вузли ``Character`` і ``Lifebar``, і "
"підключаємо вузол, який випромінює сигнал, до приймача, у цьому випадку "
"вузол ``Lifebar``."

msgid ""
"This allows the ``Lifebar`` to react to health changes without coupling it "
"to the ``Character`` node."
msgstr ""
"Це дозволяє ``Lifebar`` реагувати на зміни стану здоров’я, без з'єднання з "
"вузлом ``Character``."

msgid ""
"You can write optional argument names in parentheses after the signal's "
"definition:"
msgstr ""
"Ви можете написати назви необов'язкових аргументів у дужках після визначення "
"сигналу:"

msgid ""
"These arguments show up in the editor's node dock, and Godot can use them to "
"generate callback functions for you. However, you can still emit any number "
"of arguments when you emit signals; it's up to you to emit the correct "
"values."
msgstr ""
"Ці аргументи відображаються на панелі вузла редактора, і Godot може "
"використовувати їх для створення функцій зворотного виклику для вас. Однак "
"ви можете випромінювати будь-яку кількість аргументів, коли ви випромінюєте "
"сигнали; Ви повинні випромінювати правильні значення."

msgid ""
"You can also create copies of GDScript Callable objects which accept "
"additional arguments using :ref:`Callable.bind() "
"<class_Callable_method_bind>`. This allows you to add extra information to "
"the connection if the emitted signal itself doesn't give you access to all "
"the data that you need."
msgstr ""
"Ви також можете створювати копії об'єктів GDScript Callable, які приймають "
"додаткові аргументи, використовуючи :ref:`Callable.bind() "
"<class_Callable_method_bind>`. Це дозволяє додавати додаткову інформацію до "
"з'єднання, якщо сам випромінюваний сигнал не надає вам доступу до всіх "
"необхідних даних."

msgid ""
"When the signal is emitted, the callback method receives the bound values, "
"in addition to those provided by the signal."
msgstr ""
"Коли сигнал випромінюється, метод зворотного виклику отримує зв'язані "
"значення, окрім тих, що надаються сигналом."

msgid ""
"Building on the example above, let's say we want to display a log of the "
"damage taken by each character on the screen, like ``Player1 took 22 "
"damage.``. The ``health_changed`` signal doesn't give us the name of the "
"character that took damage. So when we connect the signal to the in-game "
"console, we can add the character's name using the bind method:"
msgstr ""
"Спираючись на наведений вище приклад, припустимо, що ми хочемо відобразити "
"на екрані журнал пошкоджень, отриманих кожним персонажем, наприклад, "
"``Player1 отримав 22 пошкодження``. Сигнал ``health_changed`` не дає нам "
"імені персонажа, який отримав пошкодження. Тому, коли ми підключаємо сигнал "
"до ігрової консолі, ми можемо додати ім'я персонажа за допомогою методу bind:"

msgid ""
"Our ``BattleLog`` node receives each bound element as an extra argument:"
msgstr ""
"Наш вузол ``BattleLog`` отримує кожен зв'язаний елемент як додатковий "
"аргумент:"

msgid "Awaiting signals or coroutines"
msgstr "Сигнали очікування або співпрограми"

msgid ""
"The ``await`` keyword can be used to create `coroutines <https://"
"en.wikipedia.org/wiki/Coroutine>`_ which wait until a signal is emitted "
"before continuing execution. Using the ``await`` keyword with a signal or a "
"call to a function that is also a coroutine will immediately return the "
"control to the caller. When the signal is emitted (or the called coroutine "
"finishes), it will resume execution from the point on where it stopped."
msgstr ""
"Ключове слово ``await`` можна використовувати для створення `співпрограм "
"<https://en.wikipedia.org/wiki/Coroutine>`_, які чекають, доки не буде "
"видано сигнал, перш ніж продовжити виконання. Використання ключового слова "
"``await`` із сигналом або викликом функції, яка також є співпрограмою, "
"негайно поверне керування абоненту. Коли сигнал надходить (або викликана "
"співпрограма закінчується), вона продовжить виконання з точки, де вона була "
"зупинена."

msgid ""
"For example, to stop execution until the user presses a button, you can do "
"something like this:"
msgstr ""
"Наприклад, щоб зупинити виконання, доки користувач не натисне кнопку, можна "
"зробити щось подібне:"

msgid ""
"In this case, the ``wait_confirmation`` becomes a coroutine, which means "
"that the caller also needs to await it:"
msgstr ""
"У цьому випадку ``wait_confirmation`` стає корутиною, що означає, що "
"викликаюча сторона також повинна її очікувати:"

msgid ""
"Note that requesting a coroutine's return value without ``await`` will "
"trigger an error:"
msgstr ""
"Зверніть увагу, що запит значення, що повертається корутиною, без ``await`` "
"призведе до помилки:"

msgid ""
"However, if you don't depend on the result, you can just call it "
"asynchronously, which won't stop execution and won't make the current "
"function a coroutine:"
msgstr ""
"Однак, якщо ви не залежите від результату, ви можете просто викликати його "
"асинхронно, що не зупинить виконання та не зробить поточну функцію корутиною:"

msgid ""
"If you use await with an expression that isn't a signal nor a coroutine, the "
"value will be returned immediately and the function won't give the control "
"back to the caller:"
msgstr ""
"Якщо ви використовуєте await з виразом, який не є ні сигналом, ні корутиною, "
"значення буде повернуто негайно, і функція не передасть керування тому, хто "
"викликає:"

msgid ""
"This also means that returning a signal from a function that isn't a "
"coroutine will make the caller await that signal:"
msgstr ""
"Це також означає, що повернення сигналу з функції, яка не є корутиною, "
"змусить викликаючу функцію очікувати цей сигнал:"

msgid ""
"Unlike ``yield`` in previous Godot versions, you cannot obtain the function "
"state object. This is done to ensure type safety. With this type safety in "
"place, a function cannot say that it returns an ``int`` while it actually "
"returns a function state object during runtime."
msgstr ""
"На відміну від ``yield`` у попередніх версіях Godot, ви не можете отримати "
"об’єкт стану функції. Це зроблено для забезпечення безпеки типу. З цією "
"безпекою типу функція не може сказати, що вона повертає ``int``, тоді як "
"вона фактично повертає об’єкт стану функції під час виконання."

msgid "Assert keyword"
msgstr "Ключове слово Assert"

msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds. This means that the "
"expression passed as argument won't be evaluated in a project exported in "
"release mode. Due to this, assertions must **not** contain expressions that "
"have side effects. Otherwise, the behavior of the script would vary "
"depending on whether the project is run in a debug build."
msgstr ""
"Ключове слово ``assert`` може бути використано для перевірки умов в "
"налагоджувальних збірках. Ці твердження ігноруються у не налагоджуваних "
"збірках. Це означає, що вираз, переданий як аргумент, не буде оцінено в "
"проєкті, експортованому в режимі випуску. Через це твердження повинні **не** "
"містити виразів, які мають побічні ефекти. В іншому випадку поведінка "
"скрипту може змінюватись залежно від того в якій збірці запускається проєкт."

msgid ""
"When running a project from the editor, the project will be paused if an "
"assertion error occurs."
msgstr ""
"Під час запуску проєкту з редактора проєкт буде призупинено, якщо станеться "
"помилка твердження."

msgid ""
"You can optionally pass a custom error message to be shown if the assertion "
"fails:"
msgstr ""
"За бажанням, ви можете передати власне повідомлення про помилку, яке буде "
"відображатися, якщо твердження не виконується:"
