#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "Мультиплеєр високого рівня"

msgid "High-level vs low-level API"
msgstr "API високого та низького рівня"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"Нижче пояснюються відмінності мереж високого та низького рівня у Godot, а "
"також деякі основи. Якщо ви хочете одразу перейти до справи і додати мережу "
"до своїх перших вузлів, перейдіть до `Ініціалізація мережі`_ нижче. Але "
"пізніше обов’язково прочитайте решту!"

msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot завжди підтримував стандартну мережу низького рівня через :abbr:`UDP "
"(протокол дейтаграм користувача)`, :abbr:`TCP (протокол керування "
"передачею)` та деякі протоколи вищого рівня, такі як :abbr:`HTTP (протокол "
"передачі гіпертексту) ` і :abbr:`SSL (Secure Sockets Layer)`. Ці протоколи є "
"гнучкими і їх можна використовувати майже для будь-чого. Однак використання "
"їх для синхронізації стану гри вручну може скласти велику роботу. Іноді "
"такої роботи неможливо уникнути або вона того варта, наприклад, під час "
"роботи з власною реалізацією сервера на сервері. Але в більшості випадків "
"варто розглянути мережевий API високого рівня Godot, який жертвує частиною "
"тонкого контролю низькорівневої мережі заради більшої простоти використання."

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "Це пов'язано з обмеженнями притаманними протоколам низького рівня:"

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP гарантує, що пакети завжди надходитимуть надійно та в правильному "
"порядку, але затримка, як правило, вища через виправлення помилок. Це також "
"досить складний протокол, оскільки він розуміє, що таке \"з'єднання\", і "
"оптимізується для цілей, які часто не підходять для таких застосунків, як "
"багатокористувацькі ігри. Пакети буферизуються для надсилання більшими "
"пачками, що призводить до менших затрат на пакет, але більшої затримки. Це "
"може бути корисно для таких речей, як HTTP, але, зазвичай, не для ігор. Дещо "
"з цього можна налаштувати та вимкнути (наприклад, відключивши «алгоритм "
"Нейгла» для TCP-з'єднання)."

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP є простішим протоколом, який надсилає лише пакети (і не має поняття "
"\"з’єднання\"). Відсутність виправлення помилок робить його досить швидким "
"(затримка низька), але пакети можуть бути втрачені при передачі, або "
"отримані в неправильному порядку. Крім того, MTU (максимальний розмір "
"пакету) для UDP, як правило, малий (всього кілька сотень байтів), тому "
"передача більших пакетів означає їх розділення, реорганізацію та повторну "
"спробу, якщо частина дає збій."

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"Загалом, TCP можна вважати надійним, впорядкованим і повільним; UDP — "
"ненадійним, неупорядкованим, але швидким. Через велику різницю в "
"продуктивності часто є сенс перебудувати частини TCP, необхідні для ігор "
"(додаткова надійність і порядок пакетів), уникаючи небажаних частин (функції "
"контролю завантаженості/трафіку, алгоритм Нейгла тощо). Завдяки цьому "
"більшість ігрових рушіїв мають таку реалізацію, і Godot не виняток."

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"Отже, ви можете використовувати API мережі низького рівня для максимального "
"контролю та впроваджувати все поверх відкритих протоколів мережі, або "
"використовувати API високого рівня на основі :ref:`Дерева Сцени "
"<class_SceneTree>`, яке, загалом оптимізовано, виконує більшість важких "
"завдань за лаштунками."

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Більшість платформ, які підтримує Godot, пропонують всі або більшість "
"згаданих мережевих функцій високого та низького рівнів. Оскільки робота в "
"мережі завжди значною мірою залежить від апаратного забезпечення та "
"операційної системи, деякі функції можуть змінюватися або бути недоступними "
"на деяких цільових платформах. Зокрема, платформа HTML5 наразі пропонує "
"підтримку WebSockets і WebRTC, але не має деяких високорівневих функцій, а "
"також необробленого доступу до низькорівневих протоколів, таких як TCP і UDP."

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"Більше про TCP/IP, UDP та мережу: https://gafferongames.com/post/udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"У Gaffer On Games є багато корисних статей про мережу в іграх (`тут <https://"
"gafferongames.com/categories/game-networking/>`__), включаючи вичерпуюче "
"`введення в мережеві моделі в іграх <https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"Додавання мережі до вашої гри вимагає певної відповідальності. Це може "
"зробити вашу програму вразливою, якщо її зробити неправильно, і може "
"призвести до чітів або експлойтів. Це навіть може дозволити зловмиснику "
"скомпрометувати комп’ютери, на яких працює ваша програма, і використовувати "
"ваші сервери для надсилання спаму, нападу на інших або викрадення даних "
"ваших користувачів, якщо вони грають у вашу гру."

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"Таке завжди відбувається, коли задіяна мережа і це не має ніякого відношення "
"до Godot. Ви, звичайно, можете експериментувати, але завжди, коли ви "
"випускаєте мережеву програму, подбайте про всі можливі заходи безпеки."

msgid "Mid-level abstraction"
msgstr "Абстракція середнього рівня"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"Перш ніж перейти до того, як ми можемо синхронізувати гру в мережі, може "
"бути корисно зрозуміти, як виконує синхронізацію базовий мережевий API."

msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot використовує об’єкт середнього рівня :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. Цей об’єкт не призначений для безпосереднього "
"створення, але розроблений таким чином, щоб кілька реалізацій C++ могли його "
"надати."

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"Цей об’єкт поширюється від :ref:`PacketPeer <class_PacketPeer>`, тому він "
"успадковує всі корисні методи для серіалізації, надсилання та отримання "
"даних. Крім того, він додає методи встановлення однорангового вузла, режиму "
"передачі тощо. Він також включає сигнали, які повідомлять вам, коли "
"однорангові вузли підключаються, чи відключаються."

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet (:"
"ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on WebRTC "
"(:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one based "
"on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this could be "
"used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/"
"console-specific networking APIs."
msgstr ""
"Цей інтерфейс класу може абстрагувати більшість типів мережевих рівнів, "
"топологій і бібліотек. За замовчуванням Godot надає реалізацію на основі "
"ENet (:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), одну на "
"основі WebRTC (:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`) і "
"одну на основі WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), але "
"це можна використовувати для реалізації мобільних API (для ad hoc WiFi, "
"Bluetooth) або користувацьких мережевих API для пристрою/консолі."

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"У більшості поширених випадків використання цього об’єкта напряму не "
"рекомендується, оскільки Godot надає мережеві можливості ще вищого рівня. "
"Цей об’єкт все ще доступний, якщо гра потребує API нижчого рівня."

msgid "Hosting considerations"
msgstr "Розгляд хостингу"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form ``192.168."
"*.*``. This internal IP address is **not** reachable by non-LAN/Internet "
"clients."
msgstr ""
"Під час розміщення сервера клієнти вашої :abbr:`LAN (локальної мережі)` "
"можуть підключатися за допомогою внутрішньої IP-адреси, яка зазвичай має "
"форму ``192.168.*.*``. Ця внутрішня IP-адреса **не** доступна клієнтам, які "
"не є локальною мережею/інтернетом."

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""
"У Windows ви можете знайти свою внутрішню IP-адресу, відкривши командний "
"рядок і ввівши ``ipconfig``. У macOS відкрийте термінал і введіть "
"``ifconfig``. У Linux відкрийте термінал і введіть ``ip addr``."

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""
"Якщо ви розміщуєте сервер на своїй власній машині та хочете, щоб до нього "
"підключалися клієнти, що не належать до локальної мережі, вам, імовірно, "
"доведеться *перенаправити* порт сервера на маршрутизаторі. Це потрібно, щоб "
"зробити ваш сервер доступним з Інтернету, оскільки більшість домашніх "
"з’єднань використовують `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Багатокористувацький API високого рівня "
"Godot використовує лише UDP, тому ви повинні перенаправляти порт у UDP, а не "
"лише в TCP."

msgid ""
"After forwarding a UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""
"Перенаправивши UDP-порт і переконавшись, що ваш сервер використовує цей "
"порт, ви можете використовувати `цей веб-сайт <https://icanhazip.com/>`__, "
"щоб знайти свою публічну IP-адресу. Потім надайте цю загальнодоступну IP-"
"адресу всім клієнтам Інтернету, які бажають підключитися до вашого сервера."

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr ""
"Високорівневий API Godot для багатокористувацької гри використовує "
"модифіковану версію ENet, яка забезпечує повну підтримку IPv6."

msgid "Initializing the network"
msgstr "Ініціалізація мережі"

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""
"Кожен вузол має властивість ``multiplayer``, яка є посиланням на екземпляр "
"``MultiplayerAPI``, налаштований для нього деревом сцени. Спочатку кожен "
"вузол налаштовано з тим самим об’єктом ``MultiplayerAPI``."

msgid ""
"It is possible to create a new ``MultiplayerAPI`` object and assign it to a "
"``NodePath`` in the the scene tree, which will override ``multiplayer`` for "
"the node at that path and all of its descendants. This allows sibling nodes "
"to be configured with different peers, which makes it possible to run a "
"server and a client simultaneously in one instance of Godot."
msgstr ""
"Можна створити новий об’єкт ``MultiplayerAPI`` і призначити його "
"``NodePath`` у дереві сцени, який замінить ``multiplayer`` для вузла на "
"цьому шляху та всіх його нащадків. Це дозволяє конфігурувати вузли-сестри з "
"різними одноранговими вузлами, що дає змогу запускати сервер і клієнт "
"одночасно в одному екземплярі Godot."

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""
"Для ініціалізації мережі необхідно створити об’єкт ``MultiplayerPeer``, "
"ініціалізувати його як сервер або клієнт і передати ``MultiplayerAPI``."

msgid "To terminate networking:"
msgstr "Щоб припинити роботу в мережі:"

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"Під час експорту в Android обов’язково ввімкніть дозвіл ``INTERNET`` у "
"попередньо налаштованих експортах Android, перш ніж експортувати проект, або "
"використовувати розгортання одним клацанням мишки. Інакше Android заблокує "
"будь-який мережевий зв’язок."

msgid "Managing connections"
msgstr "Управління з'єднаннями"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""
"Кожному вузлу присвоюється унікальний ідентифікатор. Ідентифікатор сервера "
"завжди дорівнює 1, а клієнтам призначається випадкове позитивне ціле число."

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr ""
"Відповідь на підключення або відключення можлива шляхом підключення до "
"сигналів ``MultiplayerAPI``:"

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""
"``peer_connected(id: int)`` Цей сигнал випромінюється з ідентифікатором "
"нещодавно підключеного вузла на кожному іншому вузлі та на новому вузлі "
"кілька разів, один раз з ідентифікатором іншого вузла."

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""
"``peer_disconnected(id: int)`` Цей сигнал надсилається кожному решті "
"однорангового вузла, коли один з них від’єднується."

msgid "The rest are only emitted on clients:"
msgstr "Решта випускаються тільки на клієнтах:"

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr "Щоб отримати унікальний ідентифікатор пов’язаного вузла:"

msgid "To check whether the peer is server or client:"
msgstr "Щоб перевірити, чи є партнер сервером чи клієнтом:"

msgid "Remote procedure calls"
msgstr "Віддалені виклики процедур"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""
"Віддалені виклики процедур, або RPC, — це функції, які можна викликати на "
"інших однорангових вузлах. Щоб створити його, використовуйте анотацію "
"``@rpc`` перед визначенням функції. Щоб викликати RPC, використовуйте метод "
"``Callable`` ``rpc()`` для виклику кожного вузла або ``rpc_id()`` для "
"виклику конкретного вузла."

msgid "RPCs will not serialize objects or callables."
msgstr "RPC не серіалізують об’єкти чи виклики."

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""
"Щоб віддалений виклик був успішним, вузол-відправник і вузол-одержувач "
"повинні мати однаковий ``NodePath``, що означає, що вони повинні мати "
"однакове ім’я. У разі використання ``add_child()`` для вузлів, які, як "
"очікується, будуть використовувати RPC, встановіть аргумент "
"``force_readable_name`` на ``true``."

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""
"Якщо функція анотована ``@rpc`` у клієнтському сценарії (відповідно "
"серверному сценарії), то ця функція також повинна бути оголошена в "
"серверному сценарії (відповідно клієнтському сценарії). Обидва RPC повинні "
"мати однаковий підпис, який оцінюється за допомогою контрольної суми **усіх "
"RPC**. Усі RPC у сценарії перевіряються одночасно, і всі RPC мають бути "
"оголошені як у сценаріях клієнта, так і в сценаріях сервера, **навіть у "
"функціях, які зараз не використовуються**."

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""
"Якщо ці умови не виконуються (якщо всі RPC не проходять перевірку підпису), "
"сценарій може надрукувати помилку або викликати небажану поведінку. "
"Повідомлення про помилку може бути не пов’язане з функцією RPC, яку ви зараз "
"створюєте та тестуєте."

msgid ""
"See further explanation and troubleshooting on `this post <https://github."
"com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""
"Дивіться додаткові пояснення та способи усунення несправностей у `цій "
"публікації <https://github.com/godotengine/godot/"
"issues/57869#issuecomment-1034215138>`__."

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr ""
"Анотація може приймати ряд аргументів, які мають значення за замовчуванням. "
"``@rpc`` еквівалентний:"

msgid "The parameters and their functions are as follows:"
msgstr "Параметри та їхні функції такі:"

msgid "``mode``:"
msgstr "``Режим``:"

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr ""
"``\"any_peer\"``: клієнтам дозволено дзвонити віддалено. Корисно для "
"передачі даних користувача."

msgid "``sync``:"
msgstr "``синхронізація``:"

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "``\"call_remote\"``: функція не буде викликана на локальному вузлі."

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""
"``\"call_local\"``: Функцію можна викликати на локальному одноранговому "
"пристрої. Корисно, коли сервер також є гравцем."

msgid "``transfer_mode``:"
msgstr "``режим_передачі``:"

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr ""
"``\"ненадійний\"`` Пакети не підтверджуються, можуть бути втрачені та можуть "
"надходити в будь-якому порядку."

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""
"``\"unreliable_ordered\"`` Пакети надходять у тому порядку, в якому вони "
"були надіслані. Це досягається шляхом ігнорування пакетів, які надходять "
"пізніше, якщо інші, надіслані після них, уже отримані. При неправильному "
"використанні може спричинити втрату пакетів."

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""
"``\"надійний\"`` Повторні спроби надсилаються, доки пакети не будуть "
"підтверджені, а їх порядок збережено. Має значне зниження продуктивності."

msgid "``transfer_channel`` is the channel index."
msgstr "``transfer_channel`` - це індекс каналу."

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr ""
"Перші 3 можна передавати в будь-якому порядку, але ``transfer_channel`` "
"завжди має бути останнім."

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""
"Функцію ``multiplayer.get_remote_sender_id()`` можна використовувати для "
"отримання унікального ідентифікатора відправника rpc, коли вона "
"використовується у функції, що викликається rpc."

msgid "Channels"
msgstr "Канали"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""
"Сучасні мережеві протоколи підтримують канали, які є окремими з’єднаннями "
"всередині з’єднання. Це дозволяє створювати кілька потоків пакетів, які не "
"заважають один одному."

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""
"Наприклад, повідомлення, пов’язані з ігровим чатом, і деякі з основних "
"повідомлень ігрового процесу мають надсилатися надійно, але ігрове "
"повідомлення не повинно чекати підтвердження повідомлення чату. Цього можна "
"досягти, використовуючи різні канали."

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""
"Канали також корисні при використанні з ненадійним упорядкованим режимом "
"передачі. Надсилання пакетів різного розміру за допомогою цього режиму "
"передачі може спричинити втрату пакетів, оскільки пакети, які надходять "
"повільніше, ігноруються. Розділення їх на кілька потоків однорідних пакетів "
"за допомогою каналів забезпечує впорядковану передачу з невеликою втратою "
"пакетів і без штрафу за затримку, викликаного надійним режимом."

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr ""
"Канал за замовчуванням з індексом 0 насправді складається з трьох різних "
"каналів - по одному для кожного режиму передачі."

msgid "Example lobby implementation"
msgstr "Приклад реалізації лобі"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""
"Це приклад лобі, який може керувати приєднанням і виходом однолітків, "
"повідомляти сцени інтерфейсу користувача за допомогою сигналів і запускати "
"гру після того, як усі клієнти завантажать сцену гри."

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr ""
"Кореневий вузол ігрової сцени повинен мати назву Game. У доданому до нього "
"сценарії:"

msgid "Exporting for dedicated servers"
msgstr "Експорт для виділених серверів"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. See :ref:"
"`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"Після створення багатокористувацької гри ви можете експортувати її для "
"запуску на виділеному сервері без доступного графічного процесора. Дивіться :"
"ref:`doc_exporting_for_dedicated_servers` для додаткової інформації."

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"Зразки коду на цій сторінці не призначені для роботи на виділеному сервері. "
"Вам доведеться змінити їх, щоб сервер не вважався гравцем. Вам також "
"доведеться змінити механізм початку гри, щоб перший гравець, який "
"приєднається, міг почати гру."
