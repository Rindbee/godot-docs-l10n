#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using NavigationServer"
msgstr "Використання NavigationServer"

msgid ""
"2D and 3D version of the NavigationServer are available as :ref:"
"`NavigationServer2D<class_NavigationServer2D>` and :ref:"
"`NavigationServer3D<class_NavigationServer3D>` respectively."
msgstr ""
"2D і 3D версії NavigationServer доступні як :ref:"
"`NavigationServer2D<class_NavigationServer2D>` і :ref:"
"`NavigationServer3D<class_NavigationServer3D>` відповідно."

msgid ""
"Both 2D and 3D use the same NavigationServer with NavigationServer3D being "
"the primary server. The NavigationServer2D is a frontend that converts 2D "
"positions into 3D positions and back. Hence it is entirely possible (if not "
"a little cumbersome) to exclusively use the NavigationServer3D API for 2D "
"navigation."
msgstr ""
"І 2D, і 3D використовують той самий NavigationServer, при цьому "
"NavigationServer3D є основним сервером. NavigationServer2D — це інтерфейс, "
"який перетворює 2D-позиції в 3D-позиції та назад. Таким чином, цілком "
"можливо (якщо не трохи громіздко) використовувати виключно "
"NavigationServer3D API для двовимірної навігації."

msgid "Communicating with the NavigationServer"
msgstr "Зв'язок із навігаційним сервером"

msgid ""
"To work with the NavigationServer means to prepare parameters for a "
"**query** that can be sent to the NavigationServer for updates or requesting "
"data."
msgstr ""
"Працювати з NavigationServer означає підготувати параметри для **запиту**, "
"який можна надіслати на NavigationServer для оновлення або запиту даних."

msgid ""
"To reference the internal NavigationServer objects like maps, regions and "
"agents RIDs are used as identification numbers. Every navigation related "
"node in the scene tree has a function that returns the RID for this node."
msgstr ""
"Для посилань на внутрішні об’єкти NavigationServer, такі як карти, регіони "
"та агенти, RID використовуються як ідентифікаційні номери. Кожен пов’язаний "
"з навігацією вузол у дереві сцени має функцію, яка повертає RID для цього "
"вузла."

msgid "Threading and Synchronization"
msgstr "Потоковість і синхронізація"

msgid ""
"The NavigationServer does not update every change immediately but waits "
"until the end of the **physics frame** to synchronize all the changes "
"together."
msgstr ""
"NavigationServer не оновлює кожну зміну негайно, а чекає до кінця "
"**фізичного кадру**, щоб синхронізувати всі зміни разом."

msgid ""
"Waiting for synchronization is required to apply changes to all maps, "
"regions and agents. Synchronization is done because some updates like a "
"recalculation of the entire navigation map are very expensive and require "
"updated data from all other objects. Also the NavigationServer uses a "
"**threadpool** by default for some functionality like avoidance calculation "
"between agents."
msgstr ""
"Очікування синхронізації потрібне для застосування змін до всіх карт, "
"регіонів і агентів. Синхронізація виконується, оскільки деякі оновлення, як-"
"от перерахунок усієї навігаційної карти, є дуже дорогими та вимагають "
"оновлення даних з усіх інших об’єктів. Крім того, NavigationServer "
"використовує **threadpool** за замовчуванням для деяких функцій, як-от "
"розрахунок уникнення між агентами."

msgid ""
"Waiting is not required for most ``get()`` functions that only request data "
"from the NavigationServer without making changes. Note that not all data "
"will account for changes made in the same frame. E.g. if an avoidance agent "
"changed the navigation map this frame the ``agent_get_map()`` function will "
"still return the old map before the synchronization. The exception to this "
"are nodes that store their values internally before sending the update to "
"the NavigationServer. When a getter on a node is used for a value that was "
"updated in the same frame it will return the already updated value stored on "
"the node."
msgstr ""
"Очікування не потрібне для більшості функцій ``get()``, які лише запитують "
"дані від NavigationServer без внесення змін. Зауважте, що не всі дані "
"враховуватимуть зміни, внесені в одному фреймі. наприклад якщо агент "
"уникнення змінив навігаційну карту в цьому кадрі, функція "
"``agent_get_map()`` все одно повертатиме стару карту до синхронізації. "
"Винятком є вузли, які зберігають свої значення всередині перед надсиланням "
"оновлення на NavigationServer. Коли геттер на вузлі використовується для "
"значення, яке було оновлено в тому самому кадрі, він поверне вже оновлене "
"значення, що зберігається на вузлі."

msgid ""
"The NavigationServer is **thread-safe** as it places all API calls that want "
"to make changes in a queue to be executed in the synchronization phase. "
"Synchronization for the NavigationServer happens in the middle of the "
"physics frame after scene input from scripts and nodes are all done."
msgstr ""
"NavigationServer **потоково-безпечний**, оскільки розміщує всі виклики API, "
"які хочуть внести зміни, у чергу для виконання на етапі синхронізації. "
"Синхронізація для NavigationServer відбувається в середині кадру фізики "
"після завершення введення сцени зі сценаріїв і вузлів."

msgid ""
"The important takeaway is that most NavigationServer changes take effect "
"after the next physics frame and not immediately. This includes all changes "
"made by navigation related nodes in the scene tree or through scripts."
msgstr ""
"Важливим висновком є те, що більшість змін NavigationServer набувають "
"чинності після наступного кадру фізики, а не відразу. Це включає всі зміни, "
"внесені пов’язаними з навігацією вузлами в дереві сцени або за допомогою "
"сценаріїв."

msgid "All setters and delete functions require synchronization."
msgstr "Усі функції встановлення та видалення потребують синхронізації."

msgid "2D and 3D NavigationServer differences"
msgstr "Відмінності 2D і 3D NavigationServer"

msgid ""
"NavigationServer2D and NavigationServer3D are equivalent in functionality "
"for their dimension and both use the same NavigationServer behind the scene."
msgstr ""
"NavigationServer2D і NavigationServer3D еквівалентні за функціональністю за "
"своїм виміром і обидва використовують один і той самий NavigationServer."

msgid ""
"Strictly technical a NavigationServer2D is a myth. The NavigationServer2D is "
"a frontend to facilitate conversions of ``Vector2(x, y)`` to ``Vector3(x, "
"0.0, z)`` and back for the NavigationServer3D API. 2D uses a flat 3D mesh "
"pathfinding and the NavigationServer2D facilitates the conversions. When a "
"guide uses just NavigationServer without the 2D or 3D suffix it usually "
"works for both servers by exchange ``Vector2(x, y)`` with ``Vector3(x, 0.0, "
"z)`` or reverse."
msgstr ""
"Строго технічно NavigationServer2D є міфом. NavigationServer2D — це "
"інтерфейс для полегшення перетворення ``Vector2(x, y)`` у ``Vector3(x, 0.0, "
"z)`` і назад для API NavigationServer3D. 2D використовує плоску 3D-сітку для "
"пошуку шляху, а NavigationServer2D полегшує перетворення. Коли посібник "
"використовує лише NavigationServer без суфікса 2D або 3D, він зазвичай "
"працює для обох серверів шляхом обміну ``Vector2(x, y)`` на ``Vector3(x, "
"0.0, z)`` або навпаки."

msgid ""
"Technically it is possible to use the tools for creating navigation meshes "
"in one dimension for the other dimension, e.g. baking a 2D navigation mesh "
"with the 3D NavigationMesh when using flat 3D source geometry or creating 3D "
"flat navigation meshes with the polygon outline draw tools of "
"NavigationRegion2D and NavigationPolygons."
msgstr ""
"Технічно можливо використовувати інструменти для створення навігаційних "
"сіток в одному вимірі для іншого виміру, напр. запікання 2D навігаційної "
"сітки за допомогою 3D NavigationMesh при використанні плоскої 3D вихідної "
"геометрії або створення 3D плоских навігаційних сіток за допомогою "
"інструментів малювання контуру багатокутника NavigationRegion2D і "
"NavigationPolygons."

msgid ""
"Any RID created with the NavigationServer2D API works on the "
"NavigationServer3D API as well and both 2D and 3D avoidance agents can exist "
"on the same map."
msgstr ""
"Будь-який RID, створений за допомогою NavigationServer2D API, також працює з "
"NavigationServer3D API, і як 2D, так і 3D агенти уникнення можуть існувати "
"на одній карті."

msgid ""
"Regions created in 2D and 3D will merge their navigation meshes when placed "
"on the same map and merge conditions apply. The NavigationServer does not "
"discriminate between NavigationRegion2D and NavigationRegion3D nodes as both "
"are regions on the server. By default those nodes register on different "
"navigation maps so this merge can only happen when maps are changed manually "
"e.g. with scripts."
msgstr ""
"Регіони, створені в 2D і 3D, об’єднають свої навігаційні сітки, якщо їх "
"розмістити на одній карті, і застосовуються умови злиття. NavigationServer "
"не розрізняє вузли NavigationRegion2D і NavigationRegion3D, оскільки обидва "
"є регіонами на сервері. За замовчуванням ці вузли реєструються на різних "
"навігаційних картах, тому це злиття може відбутися лише тоді, коли карти "
"змінено вручну, наприклад. зі скриптами."

msgid ""
"Actors with avoidance enabled will avoid both 2D and 3D avoidance agents "
"when placed on the same map."
msgstr ""
"Актори з увімкненим уникненням уникатимуть як 2D, так і 3D агентів "
"уникнення, якщо їх розмістити на одній карті."

msgid ""
"It is not possible to use NavigationServer2D while disabling 3D on a Godot "
"custom build."
msgstr ""
"Неможливо використовувати NavigationServer2D з вимкненим 3D у користувацькій "
"збірці Godot."

msgid "Waiting for synchronization"
msgstr "Очікування синхронізації"

msgid ""
"At the start of the game, a new scene or procedural navigation changes any "
"path query to a NavigationServer will return empty or wrong."
msgstr ""
"На початку гри нова сцена або процедурна навігація змінює будь-який запит "
"шляху до NavigationServer, повертаючи пустий або неправильний."

msgid ""
"The navigation map is still empty or not updated at this point. All nodes "
"from the scene tree need to first upload their navigation related data to "
"the NavigationServer. Each added or changed map, region or agent need to be "
"registered with the NavigationServer. Afterward the NavigationServer "
"requires a **physics frame** for synchronization to update the maps, regions "
"and agents."
msgstr ""
"На даний момент навігаційна карта все ще порожня або не оновлена. Усі вузли "
"з дерева сцени повинні спочатку завантажити свої навігаційні дані на "
"NavigationServer. Кожну додану або змінену карту, регіон або агента "
"необхідно зареєструвати на NavigationServer. Після цього навігаційному "
"серверу потрібен **фізичний фрейм** для синхронізації для оновлення карт, "
"регіонів і агентів."

msgid ""
"One workaround is to make a deferred call to a custom setup function (so all "
"nodes are ready). The setup function makes all the navigation changes, e.g. "
"adding procedural stuff. Afterwards the function waits for the next physics "
"frame before continuing with path queries."
msgstr ""
"Один обхідний шлях полягає в тому, щоб зробити відкладений виклик "
"спеціальної функції налаштування (щоб усі вузли були готові). Функція "
"налаштування вносить усі зміни навігації, напр. додавання процедурних речей. "
"Після цього функція чекає наступного фізичного кадру, перш ніж продовжити "
"запити шляху."

msgid "Server Avoidance Callbacks"
msgstr "Зворотні виклики для уникнення сервера"

msgid ""
"If RVO avoidance agents are registered for avoidance callbacks the "
"NavigationServer dispatches their ``velocity_computed`` signals just before "
"the PhysicsServer synchronization."
msgstr ""
"Якщо агенти уникнення RVO зареєстровані для зворотних викликів уникнення, "
"NavigationServer надсилає їхні сигнали ``velocity_computed`` безпосередньо "
"перед синхронізацією PhysicsServer."

msgid ""
"To learn more about NavigationAgents see :ref:"
"`doc_navigation_using_navigationagents`."
msgstr ""
"Щоб дізнатися більше про NavigationAgents, перегляньте :ref:"
"`doc_navigation_using_navigationagents`."

msgid ""
"The simplified order of execution for NavigationAgents that use avoidance:"
msgstr ""
"Спрощений порядок виконання для NavigationAgents, які використовують "
"уникнення:"

msgid "physics frame starts."
msgstr "Починається фізичний кадр."

msgid "``_physics_process(delta)``."
msgstr "``_фізичні_процеси(delta)``."

msgid "``velocity`` property is set on NavigationAgent Node."
msgstr "Властивість ``velocity`` встановлено на вузлі NavigationAgent."

msgid "Agent sends velocity and position to NavigationServer."
msgstr "Агент надсилає швидкість і положення до NavigationServer."

msgid "NavigationServer waits for synchronization."
msgstr "NavigationServer очікує на синхронізацію."

msgid ""
"NavigationServer synchronizes and computes avoidance velocities for all "
"registered avoidance agents."
msgstr ""
"NavigationServer синхронізує та обчислює швидкість уникнення для всіх "
"зареєстрованих агентів уникнення."

msgid ""
"NavigationServer sends safe velocity vector with signals for each registered "
"avoidance agents."
msgstr ""
"NavigationServer надсилає вектор безпечної швидкості з сигналами для кожного "
"зареєстрованого агента уникнення."

msgid ""
"Agents receive the signal and move their parent e.g. with ``move_and_slide`` "
"or ``linear_velocity``."
msgstr ""
"Агенти отримують сигнал і переміщують свого батька, напр. з "
"``move_and_slide`` або ``linear_velocity``."

msgid "PhysicsServer synchronizes."
msgstr "PhysicsServer синхронізується."

msgid "physics frame ends."
msgstr "закінчення фізики."

msgid ""
"Therefore moving a physicsbody actor in the callback function with the safe "
"velocity is perfectly thread- and physics-safe as all happens inside the "
"same physics frame before the PhysicsServer commits to changes and does its "
"own calculations."
msgstr ""
"Тому переміщення актора фізичного тіла у функції зворотного виклику з "
"безпечною швидкістю є абсолютно безпечним для потоків і фізики, оскільки все "
"відбувається в одному фізичному кадрі до того, як PhysicsServer внесе зміни "
"та зробить власні обчислення."
