#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "Оптимізація продуктивності навігації"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr ""
"Поширені проблеми продуктивності навігації можна розділити на такі теми:"

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr ""
"Проблеми з продуктивністю розбору вузлів дерева сцени для запікання сітки "
"навігації."

msgid "Performance problems with baking the actual navigation mesh."
msgstr "Проблеми з продуктивністю під час запікання фактичної сітки навігації."

msgid "Performance problems with NavigationAgent path queries."
msgstr "Проблеми з продуктивністю запитів шляхів NavigationAgent."

msgid "Performance problems with the actual path search."
msgstr "Проблеми з продуктивністю фактичного пошуку шляху."

msgid "Performance problems with synchronizing the navigation map."
msgstr "Проблеми з продуктивністю синхронізації навігаційної карти."

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"У наступних розділах можна знайти інформацію про те, як визначити та "
"виправити або принаймні пом’якшити їхній вплив на частоту кадрів."

msgid "Performance problems with parsing scene tree nodes"
msgstr "Проблеми з продуктивністю розбору вузлів дерева сцени"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"Надавайте перевагу використанню простих форм із якомога меншою кількістю "
"країв, напр. нічого округлого, як коло, сфера або тор."

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"Надавайте перевагу використанню фізичних форм зіткнень над складними "
"візуальними сітками як вихідною геометрією, оскільки сітки потрібно "
"копіювати з графічного процесора, і вони зазвичай набагато детальніші, ніж "
"потрібно."

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"Загалом уникайте використання дуже складної геометрії як вихідної геометрії "
"для запікання навігаційних сіток. наприклад ніколи не використовуйте дуже "
"деталізовану візуальну сітку, оскільки розбір її форми до масивів даних і її "
"вокселізація для запікання навігаційної сітки займе багато часу, оскільки "
"остаточна навігаційна сітка не покращить якість. Замість цього "
"використовуйте дуже спрощену версію фігури рівня деталізації. Ще краще "
"використовувати дуже примітивні форми, такі як коробки та прямокутники, які "
"лише приблизно покривають ту саму геометрію, але все одно дають запечений "
"результат, достатньо хороший для пошуку шляху."

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"Надавайте перевагу використанню простих фізичних форм зіткнення замість "
"візуальних сіток як вихідної геометрії для запікання навігаційних сіток. "
"Фізичні форми за замовчуванням є дуже обмеженими та оптимізованими фігурами, "
"які легко та швидко аналізувати. З іншого боку, візуальна сітка може "
"варіюватися від простої до складної. Крім того, щоб отримати доступ до даних "
"візуальної сіті, синтаксичний аналізатор має запитувати масиви даних сіті "
"від RenderingServer, оскільки дані візуальної сіті зберігаються "
"безпосередньо на GPU, а не кешуються на CPU. Це вимагає блокування потоку "
"RenderingServer і може серйозно вплинути на частоту кадрів під час "
"виконання, коли візуалізація виконується багатопоточною. Якщо візуалізація "
"виконується однопотоково, вплив на частоту кадрів може бути ще гіршим, а "
"аналіз сітки може заморозити всю гру на кілька секунд на складних сітках."

msgid "Performance problems with navigation mesh baking"
msgstr "Проблеми з продуктивністю під час запікання сітки навігації"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr ""
"Під час виконання завжди віддавайте перевагу використанню фонового потоку "
"для запікання навігаційних сіток."

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"Збільште ``cell_size`` і ``cell_height`` NavigationMesh, щоб створити менше "
"вокселів."

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr ""
"Змініть ``SamplePartitionType`` з вододілу на монотонний або шари, щоб "
"підвищити ефективність випічки."

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"НІКОЛИ не масштабуйте вихідну геометрію за допомогою вузлів, щоб уникнути "
"помилок точності. Більшість масштабів застосовуються лише візуально, а "
"фігури, які є дуже великими в базовому масштабі, потребують значної "
"додаткової обробки навіть у зменшеному масштабі."

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"Запікання навігаційних сіток під час виконання завжди має виконуватися у "
"фоновому потоці, якщо це можливо. Навіть невеликі навігаційні сітки можуть "
"займати набагато більше часу, ніж те, що можна втиснути в один кадр, "
"принаймні, якщо частота кадрів повинна залишатися на прийнятному рівні."

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake "
"(e.g. because they require no distance field pass)."
msgstr ""
"Складність вихідних геометричних даних, аналізованих із вузлів дерева сцени, "
"має великий вплив на продуктивність випікання, оскільки все потрібно "
"відображати в сітці/вокселях. Для продуктивності запікання під час виконання "
"розмір комірки NavigationMesh і висота комірки мають бути якомога вищими, "
"щоб це не спричиняло проблеми з якістю навігаційної сітки для гри. Якщо "
"розмір комірки або висота комірки встановлено занадто мало, процес запікання "
"змушений створити надмірну кількість вокселів для обробки вихідної "
"геометрії. Якщо вихідна геометрія охоплює дуже великий ігровий світ, можливо "
"навіть, що процес запікання закінчиться з пам’яті в середині та призведе до "
"збою гри. Тип розділу також можна зменшити залежно від того, наскільки "
"складною є геометрія джерела ігор, щоб збільшити продуктивність. наприклад "
"ігри з переважно плоскими поверхнями з блоковою геометрією можуть обійтися "
"монотонним режимом або режимом шарів, які набагато швидше запікаються "
"(наприклад, тому що вони не вимагають проходження поля на відстані)."

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"Ніколи не масштабуйте вихідну геометрію за допомогою вузлів. Це не тільки "
"може призвести до багатьох помилок точності з неправильно підібраними "
"вершинами та ребрами, але також певне масштабування існує лише як візуальні "
"елементи, а не у фактичних проаналізованих даних. наприклад якщо сітку "
"візуально зменшено в редакторі, наприклад. масштаб встановлений на 0,001 на "
"MeshInstance, сітка все ще потребує гігантської та дуже складної воксельної "
"сітки для обробки для запікання."

msgid "Performance problems with NavigationAgent path queries"
msgstr "Проблеми з продуктивністю запитів шляхів NavigationAgent"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr ""
"Уникайте непотрібного скидання шляху та запитів кожного кадру в сценаріях "
"NavigationAgent."

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr "Уникайте оновлення всіх шляхів NavigationAgent в одному кадрі."

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"Логічні помилки та марнотратні операції в користувацьких сценаріях "
"NavigationAgent є дуже поширеними причинами проблем із продуктивністю, напр. "
"стежити за скиданням шляху кожного кадру. За замовчуванням NavigationAgent "
"оптимізовано лише для запиту нових шляхів, коли змінюється цільове "
"положення, змінюється навігаційна карта або вони змушені надто далеко від "
"бажаної відстані шляху."

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"наприклад коли штучний інтелект має рухатися до гравця, цільова позиція не "
"повинна встановлюватися на позицію гравця в кожному кадрі, оскільки це "
"запитує новий шлях у кожному кадрі. Натомість слід порівняти відстань від "
"поточної цільової позиції до позиції гравця, і тільки коли гравець відійшов "
"занадто далеко, слід встановити нову цільову позицію."

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"Не перевіряйте заздалегідь, чи доступна цільова позиція кожного кадру. Те, "
"що виглядає як невинна перевірка, є еквівалентом дорогого запиту шляху за "
"сценою. Якщо план передбачає запит на новий шлях у будь-якому випадку, якщо "
"позиція буде доступною, шлях слід запитувати безпосередньо. Дивлячись на "
"останню позицію повернутого шляху та якщо ця позиція знаходиться на "
"«досяжній» відстані до позначеної позиції, він відповідає на запитання «чи "
"ця позиція доступна?» запитання. Це дозволяє уникнути виконання еквівалента "
"двох повних запитів шляху в кожному кадрі для того самого NavigationAgent."

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"Розділіть загальну кількість NavigationAgent на групи оновлення або "
"використовуйте випадкові таймери, щоб усі вони не запитували нові шляхи в "
"одному кадрі."

msgid "Performance problems with the actual path search"
msgstr "Проблеми з продуктивністю фактичного пошуку шляху"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr ""
"Оптимізуйте наддеталізовані навігаційні сітки, зменшивши кількість "
"багатокутників і країв."

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"Вартість фактичного пошуку шляху прямо корелює з кількістю багатокутників і "
"країв навігаційної сітки, а не з реальним розміром ігрового світу. Якщо "
"гігантський ігровий світ використовує дуже оптимізовану навігаційну сітку з "
"кількома полігонами, які охоплюють великі території, продуктивність має бути "
"прийнятною. Якщо ігровий світ розбитий на дуже маленькі навігаційні сітки, "
"кожна з яких має крихітні багатокутники (як у TileMaps), продуктивність "
"пошуку шляху буде знижена."

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"Поширеною проблемою є раптове зниження продуктивності, коли цільова позиція "
"недоступна в запиті шляху. Це падіння продуктивності є «нормальним» і є "
"результатом занадто великої, занадто неоптимізованої навігаційної сітки з "
"великою кількістю полігонів і країв для пошуку. У звичайному пошуку шляху, "
"коли цільова позиція може бути досягнута швидко, пошук шляху виконає ранній "
"вихід, щойно позиція буде досягнута, що може на деякий час приховати цю "
"відсутність оптимізації. Якщо цільова позиція не може бути досягнута, пошук "
"шляху має виконати значно довший пошук серед доступних полігонів, щоб "
"підтвердити, що позиція абсолютно недоступна."

msgid "Performance problems with navigation map synchronization"
msgstr "Проблеми з продуктивністю синхронізації навігаційної карти"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr ""
"Навігаційна сітка злиття розміщує полігони за вершинами, а не за з’єднанням "
"ребер, де це можливо."

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"Коли вносяться зміни, напр. навігаційних сіток або навігаційних областей, "
"NavigationServer повинен синхронізувати навігаційну карту. Залежно від "
"складності навігаційних сіток це може зайняти значну кількість часу, що може "
"вплинути на частоту кадрів."

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"NavigationServer об’єднує навігаційні сіті або за вершиною, або за "
"з’єднанням по краях. Об’єднання за вершиною відбувається, коли дві вершини "
"двох різних ребер потрапляють в одну клітинку сітки карти. Це досить швидка "
"і недорога операція. Об’єднання країв відбувається за другий прохід для всіх "
"необ’єднаних країв. Всі вільні краї перевіряються на можливі крайові "
"з'єднання як за відстанню, так і за кутом, що досить дорого."

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"Таким чином, окрім загального правила мати якомога менше ребер "
"багатокутника, якомога більше ребер має бути об’єднано вершиною вперед, щоб "
"залишити лише кілька ребер для дорожчого обчислення з’єднання ребер. Debug "
"Navigation PerformanceMonitor можна використовувати для отримання "
"статистичних даних про те, скільки полігонів і ребер доступно, а також "
"скільки з них не об’єднано або не об’єднано за вершиною. Якщо співвідношення "
"між об’єднаними вершинами та ребровими з’єднаннями є незначним (вершина має "
"бути значно вищою), навігаційні сітки створені належним чином або розміщені "
"дуже неефективно."
