#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Background loading"
msgstr "Тло завантаження"

msgid ""
"Commonly, games need to load resources asynchronously. When switching the "
"main scene of your game (e.g. going to a new level), you might want to show "
"a loading screen with some indication that progress is being made, or you "
"may want to load additional resources during gameplay."
msgstr ""
"Зазвичай ігри потребують асинхронного завантаження ресурсів. Перемикаючи "
"основну сцену вашої гри (наприклад, переходячи на новий рівень), можливо, ви "
"захочете показати екран завантаження з певною ознакою прогресу, або ви "
"можете завантажити додаткові ресурси під час гри."

msgid ""
"The standard load method (:ref:`ResourceLoader.load "
"<class_ResourceLoader_method_load>` or GDScript's simpler :ref:`load "
"<class_@GDScript_method_load>`) blocks your thread, making your game appear "
"unresponsive while the resource is being loaded."
msgstr ""
"Стандартний метод завантаження (:ref:`ResourceLoader.load "
"<class_ResourceLoader_method_load>` або простіший метод GDScript :ref:`load "
"<class_@GDScript_method_load>`) блокує ваш потік, через що ваша гра не "
"відповідає на запити під час завантаження ресурсу."

msgid ""
"One way around this is using ``ResourceLoader`` to load resources "
"asynchronously in background threads."
msgstr ""
"Одним із способів обійти це є використання ``ResourceLoader`` для "
"асинхронного завантаження ресурсів у фонових потоках."

msgid "Using ResourceLoader"
msgstr "Використання ResourceLoader"

msgid ""
"Generally, you queue requests to load resources for a path "
"using :ref:`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>`, which will then be "
"loaded in threads in the background."
msgstr ""
"Зазвичай ви ставите в чергу запити на завантаження ресурсів для шляху за "
"допомогою :ref:`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>`, який потім "
"завантажуватиметься в потоки у фоновому режимі."

msgid ""
"You can check the status with :ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>`. Progress can be "
"obtained by passing an array variable via progress which will return a one "
"element array containing the percentage."
msgstr ""
"Ви можете перевірити статус за "
"допомогою :ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>`. Прогрес можна "
"отримати, передавши змінну масиву через progress, яка поверне одноелементний "
"масив, що містить відсоток."

msgid ""
"Finally, you retrieve loaded resources by "
"calling :ref:`ResourceLoader.load_threaded_get "
"<class_ResourceLoader_method_load_threaded_get>`."
msgstr ""
"Нарешті, ви отримуєте завантажені ресурси, "
"викликаючи :ref:`ResourceLoader.load_threaded_get "
"<class_ResourceLoader_method_load_threaded_get>`."

msgid ""
"Once you call ``load_threaded_get()``, either the resource finished loading "
"in the background and will be returned instantly or the load will block at "
"this point like ``load()`` would. If you want to guarantee this does not "
"block, you either need to ensure there is enough time between requesting the "
"load and retrieving the resource or you need to check the status manually."
msgstr ""
"Після виклику ``load_threaded_get()`` або ресурс завершить завантаження у "
"фоновому режимі та буде миттєво повернено, або завантаження буде заблоковано "
"на цьому етапі, як ``load()``. Якщо ви хочете гарантувати, що це не "
"блокується, вам потрібно переконатися, що між запитом завантаження та "
"отриманням ресурсу пройшло достатньо часу, або вам потрібно перевірити "
"статус вручну."

msgid "Example"
msgstr "Приклад"

msgid ""
"This example demonstrates how to load a scene in the background. We will "
"have a button spawn an enemy when pressed. The enemy will be ``Enemy.tscn`` "
"which we will load on ``_ready`` and instantiate when pressed. The path will "
"be ``\"Enemy.tscn\"`` which is located at ``res://Enemy.tscn``."
msgstr ""
"Цей приклад демонструє, як завантажити сцену у фоновому режимі. Ми матимемо "
"кнопку, яка породжує ворога при натисканні. Ворогом буде ``Enemy.tscn``, "
"який ми будемо завантажувати на ``_ready`` і створювати екземпляр при "
"натисканні. Шляхом буде ``\"Enemy.tscn\"``, який знаходиться за адресою "
"``res://Enemy.tscn``."

msgid ""
"First, we will start a request to load the resource and connect the button:"
msgstr "Спочатку запустимо запит на завантаження ресурсу і підключимо кнопку:"

msgid ""
"Now ``_on_button_pressed`` will be called when the button is pressed. This "
"method will be used to spawn an enemy."
msgstr ""
"Тепер ``_on_button_pressed`` буде викликатися при натисканні кнопки. Цей "
"метод буде використовуватися для породження ворога."
