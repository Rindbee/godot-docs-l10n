#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "Збереження ігор"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"Збереження гри може бути складним. Наприклад, може бути бажано зберігати "
"інформацію з декількох об'єктів на декількох рівнях. Розширені системи "
"збереження ігор повинні містити додаткову інформацію про довільну кількість "
"об'єктів. Це дозволить функції збереження масштабуватися, оскільки гра стає "
"все складнішою."

msgid ""
"If you're looking to save user configuration, you can use "
"the :ref:`class_ConfigFile` class for this purpose."
msgstr ""
"Якщо ви хочете зберегти конфігурацію користувача, ви можете використовувати "
"клас :ref:`class_ConfigFile` для цієї мети."

msgid ""
"You can see how saving and loading works in action using the `Saving and "
"Loading (Serialization) demo project <https://github.com/godotengine/godot-"
"demo-projects/blob/master/loading/serialization>`__."
msgstr ""
"Ви можете побачити, як збереження та завантаження працює в дії, "
"використовуючи демонстраційний проект «Збереження та завантаження "
"(серіалізація) <https://github.com/godotengine/godot-demo-projects/blob/"
"master/loading/serialization>`__."

msgid "Identify persistent objects"
msgstr "Визначення постійних об'єктів"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"Спершу, ми повинні визначити, які об'єкти ми хочемо зберігати між ігровими "
"сесіями та яку інформацію від цих об'єктів ми хочемо зберегти. Для цього "
"підручника ми будемо використовувати групи для позначення та обробки "
"об'єктів, які потрібно зберегти, але, безумовно, можливі інші методи."

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"Почнемо з додавання об'єктів, які ми хочемо зберегти, до групи \"Persist\". "
"Ми можемо зробити це за допомогою графічного інтерфейсу, або скрипту. Додамо "
"відповідні вузли за допомогою графічного інтерфейсу:"

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"Як тільки це буде зроблено, при потребі зберегти гру, ми зможемо отримати "
"всі об'єкти, які необхідно зберегти, і зберегти їх за допомогою цього "
"скрипту:"

msgid "Serializing"
msgstr "Серіалізація"

msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has the helper "
"class :ref:`JSON<class_json>` to convert between dictionary and string. Our "
"node needs to contain a save function that returns this data. The save "
"function will look like this:"
msgstr ""
"Наступним кроком є серіалізація даних. Це значно полегшує читання та "
"збереження на диску. У цьому випадку ми припускаємо, що кожен член групи "
"Persist є примірником вузла і, отже, має шлях. GDScript має допоміжний "
"клас :ref:`JSON<class_json>` для перетворення між словником і рядком. Наш "
"вузол повинен містити функцію збереження, яка повертає ці дані. Функція "
"збереження буде виглядати так:"

msgid ""
"This gives us a dictionary with the style "
"``{ \"variable_name\":value_of_variable }``, which will be useful when "
"loading."
msgstr ""
"Це дає нам словник в стилі ``{ \"назва_змінної\":значення_змінної }``, який "
"буде корисний при завантаженні."

msgid "Saving and reading data"
msgstr "Збереження та читання даних"

msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use the "
"class :ref:`JSON<class_json>` to convert it into an easily stored string and "
"store them in a file. Doing it this way ensures that each line is its own "
"object, so we have an easy way to pull the data out of the file as well."
msgstr ""
"Як описано в підручнику :ref:`doc_filesystem`, нам потрібно буде відкрити "
"файл, щоб ми могли писати в нього або читати з нього. Тепер, коли ми маємо "
"спосіб викликати наші групи та отримати відповідні дані, давайте "
"використаємо клас :ref:`JSON<class_json>`, щоб перетворити його на рядок, "
"який легко зберігати, і зберегти їх у файлі. Це гарантує, що кожен рядок є "
"окремим об’єктом, тож ми також маємо простий спосіб отримати дані з файлу."

msgid ""
"Game saved! Now, to load, we'll read each line. Use "
"the :ref:`parse<class_JSON_method_parse>` method to read the JSON string "
"back to a dictionary, and then iterate over the dict to read our values. But "
"we'll need to first create the object and we can use the filename and parent "
"values to achieve that. Here is our load function:"
msgstr ""
"Гра збережена! Тепер, щоб завантажити, ми прочитаємо кожен рядок. "
"Використовуйте метод :ref:`parse<class_JSON_method_parse>`, щоб прочитати "
"рядок JSON назад у словник, а потім повторіть dict, щоб прочитати наші "
"значення. Але нам потрібно спочатку створити об’єкт, і ми можемо "
"використовувати ім’я файлу та батьківські значення для досягнення цього. Ось "
"наша функція завантаження:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"Тепер ми можемо зберегти і завантажити довільну кількість об'єктів практично "
"в будь-якому місці по всьому дереву сцени! Кожен об'єкт може зберігати різні "
"дані в залежності від того, що йому потрібно зберегти."

msgid "Some notes"
msgstr "Деякі примітки"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"Ми приховали налаштування стану гри для завантаження. Зрештою, це залежить "
"від творця проекту, де піде більша частина цієї логіки. Це часто "
"ускладнюється і потрібно буде багато попрацювати, виходячи з потреб окремого "
"проекту."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"Крім того, наша реалізація передбачає, що жодні об'єкти Persist не є "
"дочірніми елементами інших об'єктів Persist. В іншому випадку будуть "
"створені неприпустимі шляхи. Щоб розмістити вкладені об'єкти Persist, "
"спробуйте зберегти об'єкти поетапно. Спочатку завантажте батьківські "
"об'єкти, щоб вони були доступні для виклику :ref:`add_child() "
"<class_node_method_add_child>` під час завантаження дочірніх об'єктів. Вам "
"також знадобиться спосіб зв'язати дітей з батьками, оскільки :ref:`NodePath "
"<class_nodepath>` *(Шлях вузла)*, ймовірно, буде недійсним."

msgid "JSON vs binary serialization"
msgstr "JSON проти бінарної серіалізації"

msgid ""
"For simple game state, JSON may work and it generates human-readable files "
"that are easy to debug."
msgstr ""
"Для простого ігрового стану JSON може працювати, і він генерує файли, "
"зрозумілі людині, які легко налагодити."

msgid ""
"But JSON has many limitations. If you need to store more complex game state "
"or a lot of it, :ref:`binary serialization<doc_binary_serialization_api>` "
"may be a better approach."
msgstr ""
"Але JSON має багато обмежень. Якщо вам потрібно зберігати складніший стан "
"гри або багато його, :ref:`binary "
"serialization<doc_binary_serialization_api>` може бути кращим підходом."

msgid "JSON limitations"
msgstr "Обмеження JSON"

msgid "Here are some important gotchas to know about when using JSON."
msgstr ""
"Ось деякі важливі моменти, про які слід знати під час використання JSON."

msgid ""
"**Filesize:** JSON stores data in text format, which is much larger than "
"binary formats."
msgstr ""
"**Розмір файлу:** JSON зберігає дані в текстовому форматі, який набагато "
"більший за двійкові формати."

msgid ""
"**Data types:** JSON only offers a limited set of data types. If you have "
"data types that JSON doesn't have, you will need to translate your data to "
"and from types that JSON can handle. For example, some important types that "
"JSON can't parse are: ``Vector2``, ``Vector3``, ``Color``, ``Rect2``, and "
"``Quaternion``."
msgstr ""
"**Типи даних:** JSON пропонує лише обмежений набір типів даних. Якщо у вас є "
"типи даних, яких немає в JSON, вам потрібно буде перевести дані в типи, які "
"JSON може обробляти, і з них. Наприклад, деякі важливі типи, які JSON не "
"може проаналізувати: ``Vector2``, ``Vector3``, ``Color``, ``Rect2`` і "
"``Quaternion``."

msgid ""
"**Custom logic needed for encoding/decoding:** If you have any custom "
"classes that you want to store with JSON, you will need to write your own "
"logic for encoding and decoding those classes."
msgstr ""
"**Власна логіка, необхідна для кодування/декодування:** Якщо у вас є "
"спеціальні класи, які ви хочете зберігати в JSON, вам потрібно буде написати "
"власну логіку для кодування та декодування цих класів."

msgid "Binary serialization"
msgstr "Бінарна серіалізація"

msgid ""
":ref:`Binary serialization<doc_binary_serialization_api>` is an alternative "
"approach for storing game state, and you can use it with the functions "
"``get_var`` and ``store_var`` of :ref:`class_FileAccess`."
msgstr ""
":ref:`Binary serialization<doc_binary_serialization_api>` — це "
"альтернативний підхід для збереження стану гри, і ви можете використовувати "
"його з функціями ``get_var`` і ``store_var`` :ref:`class_FileAccess`."

msgid "Binary serialization should produce smaller files than JSON."
msgstr "Двійкова серіалізація повинна створювати менші файли, ніж JSON."

msgid "Binary serialization can handle most common data types."
msgstr "Двійкова серіалізація може обробляти більшість поширених типів даних."

msgid ""
"Binary serialization requires less custom logic for encoding and decoding "
"custom classes."
msgstr ""
"Двійкова серіалізація вимагає менше спеціальної логіки для кодування та "
"декодування спеціальних класів."

msgid ""
"Note that not all properties are included. Only properties that are "
"configured with "
"the :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"flag set will be serialized. You can add a new usage flag to a property by "
"overriding "
"the :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"method in your class. You can also check how property usage is configured by "
"calling ``Object._get_property_list``. "
"See :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` for the "
"possible usage flags."
msgstr ""
"Зауважте, що включено не всі властивості. Буде серіалізовано лише "
"властивості, налаштовані за допомогою "
"прапорця :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>`. "
"Ви можете додати новий прапор використання до властивості, перевизначивши "
"метод :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"у вашому класі. Ви також можете перевірити, як налаштовано використання "
"властивості, викликавши ``Object._get_property_list``. "
"Перегляньте :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` "
"для можливих позначок використання."
