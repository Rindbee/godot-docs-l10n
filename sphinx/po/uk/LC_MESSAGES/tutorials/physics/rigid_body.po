#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using RigidBody"
msgstr "Використання RigidBody"

msgid "What is a rigid body?"
msgstr "Що таке тверде тіло?"

msgid ""
"A rigid body is one that is directly controlled by the physics engine in "
"order to simulate the behavior of physical objects. In order to define the "
"shape of the body, it must have one or more :ref:`Shape3D <class_Shape3D>` "
"objects assigned. Note that setting the position of these shapes will affect "
"the body's center of mass."
msgstr ""
"Тверде тіло – це тіло, яким безпосередньо керує фізичний механізм, щоб "
"імітувати поведінку фізичних об’єктів. Щоб визначити форму тіла, воно "
"повинно мати один або кілька призначених об’єктів :ref:`Shape3D "
"<class_Shape3D>`. Зауважте, що встановлення положення цих форм впливатиме на "
"центр мас тіла."

msgid "How to control a rigid body"
msgstr "Як керувати rigid body"

msgid ""
"A rigid body's behavior can be altered by setting its properties, such as "
"mass and weight. A physics material needs to be added to the rigid body to "
"adjust its friction and bounce, and set if it's absorbent and/or rough. "
"These properties can be set in the Inspector or via code. See :ref:"
"`RigidBody3D <class_RigidBody3D>` and :ref:`PhysicsMaterial "
"<class_PhysicsMaterial>` for the full list of properties and their effects."
msgstr ""
"Поведінка твердого тіла може бути змінена шляхом встановлення його "
"властивостей, таких як маса та вага. Фізичний матеріал потрібно додати до "
"твердого тіла, щоб відрегулювати його тертя та відскок, і встановити, чи "
"воно абсорбуюче та/або грубе. Ці властивості можна встановити в інспекторі "
"або за допомогою коду. Перегляньте :ref:`RigidBody3D <class_RigidBody3D>` і :"
"ref:`PhysicsMaterial <class_PhysicsMaterial>` для повного переліку "
"властивостей та їхніх ефектів."

msgid ""
"There are several ways to control a rigid body's movement, depending on your "
"desired application."
msgstr ""
"Існує кілька способів керування рухом твердого тіла залежно від бажаного "
"застосування."

msgid ""
"If you only need to place a rigid body once, for example to set its initial "
"location, you can use the methods provided by the :ref:`Node3D "
"<class_Node3D>` node, such as ``set_global_transform()`` or ``look_at()``. "
"However, these methods cannot be called every frame or the physics engine "
"will not be able to correctly simulate the body's state. As an example, "
"consider a rigid body that you want to rotate so that it points towards "
"another object. A common mistake when implementing this kind of behavior is "
"to use ``look_at()`` every frame, which breaks the physics simulation. "
"Below, we'll demonstrate how to implement this correctly."
msgstr ""
"Якщо вам потрібно розмістити тверде тіло лише один раз, наприклад, щоб "
"встановити його початкове розташування, ви можете скористатися методами, "
"наданими вузлом :ref:`Node3D <class_Node3D>`, такими як "
"``set_global_transform()`` або `` look_at()``. Однак ці методи не можна "
"викликати кожен кадр, інакше фізичний движок не зможе правильно змоделювати "
"стан тіла. Як приклад розглянемо тверде тіло, яке потрібно повернути так, "
"щоб воно вказувало на інший об’єкт. Поширеною помилкою під час реалізації "
"такого типу поведінки є використання ``look_at()`` кожного кадру, що порушує "
"фізичне моделювання. Нижче ми покажемо, як це правильно реалізувати."

msgid ""
"The fact that you can't use ``set_global_transform()`` or ``look_at()`` "
"methods doesn't mean that you can't have full control of a rigid body. "
"Instead, you can control it by using the ``_integrate_forces()`` callback. "
"In this method, you can add *forces*, apply *impulses*, or set the "
"*velocity* in order to achieve any movement you desire."
msgstr ""
"Той факт, що ви не можете використовувати методи ``set_global_transform()`` "
"або ``look_at()``, не означає, що ви не можете мати повний контроль над "
"твердим тілом. Натомість ви можете контролювати це за допомогою зворотного "
"виклику ``_integrate_forces()``. У цьому методі ви можете додати *сили*, "
"застосувати *імпульси* або встановити *швидкість*, щоб досягти будь-якого "
"руху, який ви бажаєте."

msgid "The \"look at\" method"
msgstr "Метод «подивитися»"

msgid ""
"As described above, using the Node3D's ``look_at()`` method can't be used "
"each frame to follow a target. Here is a custom ``look_at()`` method called "
"``look_follow()`` that will work with rigid bodies:"
msgstr ""
"Як описано вище, за допомогою методу Node3D ``look_at()`` не можна "
"використовувати кожен кадр для дотримання мети. Ось спеціальний метод "
"look_at() під назвою look_follow() який працюватиме з твердими тілами:"

msgid ""
"This method uses the rigid body's ``angular_velocity`` property to rotate "
"the body. The axis to rotate around is given by the cross product between "
"the current forward direction and the direction one wants to look in. The "
"``clamp`` is a simple method used to prevent the amount of rotation from "
"going past the direction which is wanted to be looked in, as the total "
"amount of rotation needed is given by the arccosine of the dot product. This "
"method can be used with ``axis_lock_angular_*`` as well. If more precise "
"control is needed, solutions such as ones relying on :ref:`class_Quaternion` "
"may be required, as discussed in :ref:`doc_using_transforms`."
msgstr ""
"Цей метод використовує властивість ``angular_velocity`` твердого тіла для "
"обертання тіла. Вісь, навколо якої потрібно обертатися, визначається "
"перехресним добутком між поточним напрямком вперед і напрямком, у якому "
"потрібно дивитися. ``Затискач`` — це простий метод, який використовується "
"для запобігання виходу обертання за межі потрібного напрямку слід "
"розглядати, оскільки загальна величина необхідного обертання визначається "
"аркосинусом скалярного добутку. Цей метод також можна використовувати з "
"``axis_lock_angular_*``. Якщо потрібен більш точний контроль, можуть "
"знадобитися такі рішення, як ті, що покладаються на :ref:`class_Quaternion`, "
"як описано в :ref:`doc_using_transforms`."
