#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Jolt Physics"
msgstr "Використання Jolt Physics"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"The Jolt physics engine was added as an alternative to the existing Godot "
"Physics physics engine in 4.4. Jolt is developed by Jorrit Rouwe with a "
"focus on games and VR applications. Previously it was available as an "
"extension but is now built into Godot."
msgstr ""
"Фізичний двигун Jolt було додано як альтернативу існуючому фізичному двигуну "
"Godot Physics у версії 4.4. Jolt розроблено Jorrit Rouwe з акцентом на ігри "
"та VR-додатки. Раніше він був доступний як розширення, але тепер вбудований "
"у Godot."

msgid ""
"It is important to note that the built-in Jolt Physics module is considered "
"**not finished**, **experimental**, and **lacks feature parity** with both "
"Godot Physics and the Godot Jolt extension. Behavior may change as it is "
"developed further. Please keep that in mind when choosing what to use for "
"your project."
msgstr ""
"Важливо зазначити, що вбудований модуль Jolt Physics вважається "
"**незавершеним**, **експериментальним** та **не має паритету функцій** як з "
"Godot Physics, так і з розширенням Godot Jolt. Поведінка може змінюватися в "
"міру його подальшого розвитку. Будь ласка, пам’ятайте про це, вибираючи, що "
"використовувати для свого проєкту."

msgid ""
"The existing extension is now considered in maintenance mode. That means bug "
"fixes will be merged, and it will be kept compatible with new versions of "
"Godot until the built-in module has feature parity with the extension. The "
"extension can be found `here on GitHub <https://github.com/godot-jolt/godot-"
"jolt>`_ and in Godot's asset library."
msgstr ""
"Існуюче розширення зараз розглядається як таке, що перебуває в режимі "
"обслуговування. Це означає, що виправлення помилок будуть об'єднані, і воно "
"буде сумісним з новими версіями Godot, доки вбудований модуль не матиме "
"паритету функціональності з розширенням. Розширення можна знайти `тут на "
"GitHub <https://github.com/godot-jolt/godot-jolt>`_ та в бібліотеці ресурсів "
"Godot."

msgid ""
"To change the 3D physics engine to be Jolt Physics, set :ref:`Project "
"Settings > Physics > 3D > Physics "
"Engine<class_ProjectSettings_property_physics/3D/Physics_Engine>` to ``Jolt "
"Physics``. Once you've done that, click the **Save & Restart** button. When "
"the editor opens again, 3D scenes should now be using Jolt for physics."
msgstr ""
"Щоб змінити 3D-фізичний рушій на Jolt Physics, встановіть :ref:`Project "
"Settings > Physics > 3D > Physics "
"Engine<class_ProjectSettings_property_physics/3D/Physics_Engine>` на ``Jolt "
"Physics``. Після цього натисніть кнопку **Зберегти та перезапустити**. Коли "
"редактор знову відкриється, 3D-сцени тепер повинні використовувати Jolt для "
"фізики."

msgid "Notable differences to Godot Physics"
msgstr "Помітні відмінності від Godot Physics"

msgid ""
"There are many differences between the existing Godot Physics engine and "
"Jolt."
msgstr ""
"Між існуючим фізичним двигуном Godot та Jolt існує багато відмінностей."

msgid "Joint properties"
msgstr "Спільні властивості"

msgid ""
"The current interfaces for the 3D joint nodes don't quite line up with the "
"interface of Jolt's own joints. As such, there are a number of joint "
"properties that are not supported, mainly ones related to configuring the "
"joint's soft limits."
msgstr ""
"Поточні інтерфейси для вузлів 3D-суглобів не зовсім відповідають інтерфейсу "
"власних суглобів Jolt. Таким чином, існує ряд властивостей суглобів, які не "
"підтримуються, головним чином пов'язані з налаштуванням м'яких меж суглоба."

msgid "The unsupported properties are:"
msgstr "Непідтримувані властивості:"

msgid "PinJoint3D: ``bias``, ``damping``, ``impulse_clamp``"
msgstr "PinJoint3D: ``bias``, ``damping``, ``impulse_clamp``"

msgid "HingeJoint3D: ``bias``, ``softness``, ``relaxation``"
msgstr "HingeJoint3D: ``bias``, ``softness``, ``relaxation``"

msgid ""
"SliderJoint3D: ``angular_\\*``, ``\\*_limit/softness``, ``\\*_limit/"
"restitution``, ``\\*_limit/damping``"
msgstr ""
"SliderJoint3D: ``angular_\\*``, ``\\*_limit/softness``, ``\\*_limit/"
"restitution``, ``\\*_limit/damping``"

msgid "ConeTwistJoint3D: ``bias``, ``relaxation``, ``softness``"
msgstr "ConeTwistJoint3D: ``bias``, ``relaxation``, ``softness``"

msgid ""
"Generic6DOFJoint3D: ``*_limit_*/softness``, ``*_limit_*/restitution``, "
"``*_limit_*/damping``, ``*_limit_*/erp``"
msgstr ""
"Generic6DOFJoint3D: ``*_limit_*/softness``, ``*_limit_*/restitution``, "
"``*_limit_*/damping``, ``*_limit_*/erp``"

msgid ""
"Currently a warning is emitted if you set these properties to anything but "
"their default values."
msgstr ""
"Наразі з'являється попередження, якщо ви встановите для цих властивостей "
"значення, відмінні від значень за замовчуванням."

msgid "Single-body joints"
msgstr "Монотільні суглоби"

msgid ""
"You can, in Godot, omit one of the joint bodies for a two-body joint and "
"effectively have \"the world\" be the other body. However, the node path "
"that you assign your body to (:ref:`node_a<class_Joint3D_property_node_a>` "
"vs :ref:`node_b<class_Joint3D_property_node_b>`) is ignored. Godot Physics "
"will always behave as if you assigned it to ``node_a``, and since ``node_a`` "
"is also what defines the frame of reference for the joint limits, you end up "
"with inverted limits and a potentially strange limit shape, especially if "
"your limits allow both linear and angular degrees of freedom."
msgstr ""
"У методі Godot ви можете пропустити одне зі спільних тіл для двотілового "
"суглоба та фактично зробити так, щоб \"світ\" був іншим тілом. Однак, шлях "
"вузла, якому ви призначаєте своє тіло "
"(:ref:`node_a<class_Joint3D_property_node_a>` "
"проти :ref:`node_b<class_Joint3D_property_node_b>`), ігнорується. Фізика "
"Godot завжди поводитиметься так, ніби ви призначили його ``node_a``, і "
"оскільки ``node_a`` також визначає систему відліку для спільних меж, ви "
"отримаєте інвертовані межі та потенційно дивну форму межі, особливо якщо "
"ваші межі дозволяють як лінійні, так і кутові ступені свободи."

msgid ""
"Jolt will behave as if you assigned the body to ``node_b`` instead, with "
"``node_a`` representing \"the world\". There is a project setting "
"called :ref:`Physics > Jolt Physics 3D > Joints > World "
"Node<class_ProjectSettings_property_physics/jolt_physics_3d/joints/"
"world_node>` that lets you toggle this behavior, if you need compatibility "
"for an existing project."
msgstr ""
"Jolt поводитиметься так, ніби ви призначили тіло вузлу ``node_b``, де "
"``node_a`` представлятиме \"світ\". Існує налаштування проекту під "
"назвою :ref:`Physics > Jolt Physics 3D > Joints > World "
"Node<class_ProjectSettings_property_physics/jolt_physics_3d/joints/"
"world_node>`, яке дозволяє перемикати цю поведінку, якщо вам потрібна "
"сумісність для існуючого проекту."

msgid "Collision margins"
msgstr "Межі зіткнень"

msgid ""
"Jolt (and other similar physics engines) uses something that Jolt refers to "
"as \"convex radius\" to help improve the performance and behavior of the "
"types of collision detection that Jolt relies on for convex shapes. Other "
"physics engines (Godot included) might refer to these as \"collision "
"margins\" instead. Godot exposes these as the ``margin`` property on every "
"Shape3D-derived class, but Godot Physics itself does not use them for "
"anything."
msgstr ""
"Jolt (та інші подібні фізичні двигуни) використовує те, що Jolt називає "
"\"опуклим радіусом\", щоб покращити продуктивність та поведінку типів "
"виявлення зіткнень, на які Jolt покладається для опуклих фігур. Інші фізичні "
"двигуни (включно з Godot) можуть називати їх \"полями зіткнень\". Godot "
"надає їх як властивість ``margin`` для кожного класу, похідного від Shape3D, "
"але сама фізика Godot не використовує їх ні для чого."

msgid ""
"What these collision margins sometimes do in other engines (as described in "
"Godot's documentation) is effectively add a \"shell\" around the shape, "
"slightly increasing its size while also rounding off any edges/corners. In "
"Jolt however, these margins are first used to shrink the shape, and then the "
"\"shell\" is applied, resulting in edges/corners being similarly rounded "
"off, but without increasing the size of the shape."
msgstr ""
"Ці поля колізій іноді роблять в інших рушіях (як описано в документації "
"Godot), фактично додаючи \"оболонку\" навколо фігури, трохи збільшуючи її "
"розмір, а також заокруглюючи будь-які краї/кути. Однак у Jolt ці поля "
"спочатку використовуються для стиснення фігури, а потім застосовується "
"\"оболонка\", в результаті чого краї/кути аналогічно заокруглюються, але без "
"збільшення розміру фігури."

msgid ""
"To prevent having to tweak this margin property manually, since its default "
"value can be problematic for smaller shapes, the Jolt module exposes a "
"project setting called :ref:`Physics > Jolt Physics 3D > Collisions > "
"Collision Margin Fraction<class_ProjectSettings_property_physics/"
"jolt_physics_3d/collisions/collision_margin_fraction>` which is multiplied "
"with the smallest axis of the shape's AABB to calculate the actual margin. "
"The margin property of the shape is then instead used as an upper bound."
msgstr ""
"Щоб уникнути необхідності налаштування цієї властивості поля вручну, "
"оскільки її значення за замовчуванням може бути проблематичним для менших "
"фігур, модуль Jolt надає налаштування проекту під назвою :ref:`Physics > "
"Jolt Physics 3D > Collisions > Collision Margin "
"Fraction<class_ProjectSettings_property_physics/jolt_physics_3d/collisions/"
"collision_margin_fraction>`, яке множиться на найменшу вісь AABB фігури для "
"обчислення фактичного поля. Властивість margin фігури потім використовується "
"як верхня межа."

msgid ""
"These margins should, for most use-cases, be more or less transparent, but "
"can sometimes result in odd collision normals when performing shape queries. "
"You can lower the above mentioned project setting to mitigate some of this, "
"including setting it to ``0.0``, but too small of a margin can also cause "
"odd collision results, so is generally not recommended."
msgstr ""
"Ці поля, для більшості випадків використання, повинні бути більш-менш "
"прозорими, але іноді можуть призводити до дивних колізійних нормалей під час "
"виконання запитів фігури. Ви можете зменшити вищезгадане налаштування "
"проекту, щоб зменшити це, зокрема встановити його на ``0.0``, але занадто "
"мале поле також може призвести до дивних колізійних результатів, тому "
"зазвичай не рекомендується."

msgid "Baumgarte stabilization"
msgstr "Стабілізація Баумгарта"

msgid ""
"Baumgarte stabilization is a method to resolve penetrating bodies and push "
"them to a state where they are just touching. In Godot Physics this works "
"like a spring. This means that bodies can accelerate and may cause the "
"bodies to overshoot and separate completely. With Jolt, the stabilization is "
"only applied to the position and not to the velocity of the body. This means "
"it cannot overshoot but it may take longer to resolve the penetration."
msgstr ""
"Стабілізація Баумгарта — це метод вирішення проблеми проникнення тіл та "
"приведення їх до стану, коли вони лише торкаються одне одного. У фізиці "
"Godot це працює як пружина. Це означає, що тіла можуть прискорюватися, що "
"може призвести до їх перестрибування та повного роз'єднання. За допомогою "
"поштовху стабілізація застосовується лише до положення, а не до швидкості "
"тіла. Це означає, що перестрибування неможливе, але для вирішення проблеми "
"проникнення може знадобитися більше часу."

msgid ""
"The strength of this stabilization can be tweaked using the project "
"setting :ref:`Physics > Jolt Physics 3D > Simulation > Baumgarte "
"Stabilization Factor<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/baumgarte_stabilization_factor>`. Setting this project setting to "
"``0.0`` will turn Baumgarte stabilization off. Setting it to ``1.0`` will "
"resolve penetration in 1 simulation step. This is fast but often also "
"unstable."
msgstr ""
"Силу цієї стабілізації можна налаштувати за допомогою налаштувань "
"проекту :ref:`Physics > Jolt Physics 3D > Simulation > Baumgarte "
"Stabilization Factor<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/baumgarte_stabilization_factor>`. Встановлення цього налаштування "
"проекту на ``0.0`` вимкне стабілізацію Баумгарта. Встановлення на ``1.0`` "
"вирішить проблему проникнення за 1 крок симуляції. Це швидко, але часто "
"також нестабільно."

msgid "Ghost collisions"
msgstr "Зіткнення привидів"

msgid ""
"Jolt employs two techniques to mitigate ghost collisions, meaning collisions "
"with internal edges of shapes/bodies that result in collision normals that "
"oppose the direction of movement."
msgstr ""
"Jolt використовує два методи для зменшення зіткнень типу \"привид\", тобто "
"зіткнень з внутрішніми краями фігур/тіл, що призводять до утворення нормалей "
"зіткнень, що протистоять напрямку руху."

msgid ""
"The first technique, called \"active edge detection\", marks edges of "
"triangles in :ref:`class_ConcavePolygonShape3D` "
"or :ref:`class_HeightMapShape3D` as either \"active\" or \"inactive\", based "
"on the angle to the neighboring triangle. When a collision happens with an "
"inactive edge the collision normal will be replaced with the triangle's "
"normal instead, to lessen the effect of ghost collisions."
msgstr ""
"Перший метод, який називається «активне виявлення ребер», позначає ребра "
"трикутників у :ref:`class_ConcavePolygonShape3D` "
"або :ref:`class_HeightMapShape3D` як «активні» або «неактивні» на основі "
"кута до сусіднього трикутника. Коли відбувається зіткнення з неактивним "
"ребром, нормаль зіткнення буде замінена нормаллю трикутника, щоб зменшити "
"ефект фантомних зіткнень."

msgid ""
"The angle threshold for this active edge detection is configurable through "
"the project setting :ref:`Physics >Jolt Physics 3D > Collisions > Active "
"Edge Threshold<class_ProjectSettings_property_physics/jolt_physics_3d/"
"collisions/active_edge_threshold>`."
msgstr ""
"Поріг кута для цього активного виявлення країв налаштовується через "
"налаштування проекту :ref:`Physics >Jolt Physics 3D > Collisions > Active "
"Edge Threshold<class_ProjectSettings_property_physics/jolt_physics_3d/"
"collisions/active_edge_threshold>`."

msgid ""
"The second technique, called \"enhanced internal edge removal\", instead "
"adds runtime checks to detect whether an edge is active or inactive, based "
"on the contact points of the two bodies. This has the benefit of applying "
"not only to collisions with :ref:`class_ConcavePolygonShape3D` "
"and :ref:`class_HeightMapShape3D`, but also edges between any shapes within "
"the same body."
msgstr ""
"Другий метод, який називається «покращене внутрішнє видалення ребер», "
"натомість додає перевірки під час виконання для визначення активності ребра "
"на основі точок контакту двох тіл. Це має перевагу в тому, що застосовується "
"не лише до зіткнень з :ref:`class_ConcavePolygonShape3D` "
"та :ref:`class_HeightMapShape3D`, але й до ребер між будь-якими фігурами в "
"межах одного тіла."

msgid ""
"Enhanced internal edge removal can be toggled on and off for the various "
"contexts to which it's applied, using the :ref:`Physics >Jolt Physics 3D > "
"Simulation > Use Enhanced Internal Edge "
"Removal<class_ProjectSettings_property_physics/jolt_physics_3d/simulation/"
"use_enhanced_internal_edge_removal>`, project setting, and the similar "
"settings for :ref:`queries<class_ProjectSettings_property_physics/"
"jolt_physics_3d/queries/use_enhanced_internal_edge_removal>` "
"and :ref:`motion queries<class_ProjectSettings_property_physics/"
"jolt_physics_3d/motion_queries/use_enhanced_internal_edge_removal>`."
msgstr ""
"Покращене видалення внутрішніх країв можна вмикати та вимикати для різних "
"контекстів, до яких воно застосовується, використовуючи :ref:`Physics >Jolt "
"Physics 3D > Simulation > Use Enhanced Internal Edge "
"Removal<class_ProjectSettings_property_physics/jolt_physics_3d/simulation/"
"use_enhanced_internal_edge_removal>`, налаштування проекту та аналогічні "
"налаштування для :ref:`queries<class_ProjectSettings_property_physics/"
"jolt_physics_3d/queries/use_enhanced_internal_edge_removal>` та :ref:`motion "
"queries<class_ProjectSettings_property_physics/jolt_physics_3d/"
"motion_queries/use_enhanced_internal_edge_removal>`."

msgid ""
"Note that neither the active edge detection nor enhanced internal edge "
"removal apply when dealing with ghost collisions between two different "
"bodies."
msgstr ""
"Зверніть увагу, що ні активне виявлення країв, ні покращене видалення "
"внутрішніх країв не застосовуються під час роботи з колізіями-привидами між "
"двома різними тілами."

msgid "Memory usage"
msgstr "Використання пам'яті"

msgid ""
"Jolt uses a stack allocator for temporary allocations within its simulation "
"step. This stack allocator requires allocating a set amount of memory up "
"front, which can be configured using the :ref:`Physics > Jolt Physics 3D > "
"Limits > Temporary Memory Buffer Size<class_ProjectSettings_property_physics/"
"jolt_physics_3d/limits/temporary_memory_buffer_size>` project setting."
msgstr ""
"Jolt використовує розподільник стеку для тимчасових розподілів пам'яті на "
"етапі моделювання. Цей розподільник стеку вимагає виділення певного обсягу "
"пам'яті заздалегідь, який можна налаштувати за допомогою параметрів "
"проекту :ref:`Physics > Jolt Physics 3D > Limits > Temporary Memory Buffer "
"Size<class_ProjectSettings_property_physics/jolt_physics_3d/limits/"
"temporary_memory_buffer_size>`."

msgid "Ray-cast face index"
msgstr "Індекс грані, відбитий променем"

msgid ""
"The ``face_index`` property returned in the results "
"of :ref:`intersect_ray()<class_PhysicsDirectSpaceState3D_method_intersect_ray>` "
"and RayCast3D will by default always be ``-1`` with Jolt. The project "
"setting :ref:`Physics > Jolt Physics 3D > Queries > Enable Ray Cast Face "
"Index<class_ProjectSettings_property_physics/jolt_physics_3d/queries/"
"enable_ray_cast_face_index>` will enable them."
msgstr ""
"Властивість ``face_index``, що повертається в "
"результатах :ref:`intersect_ray()<class_PhysicsDirectSpaceState3D_method_intersect_ray>` "
"та RayCast3D, за замовчуванням завжди матиме значення ``-1`` з Jolt. "
"Налаштування проекту :ref:`Physics > Jolt Physics 3D > Queries > Enable Ray "
"Cast Face Index<class_ProjectSettings_property_physics/jolt_physics_3d/"
"queries/enable_ray_cast_face_index>` увімкне їх."

msgid ""
"Note that enabling this setting will increase the memory requirement "
"of :ref:`class_ConcavePolygonShape3D` with about 25%."
msgstr ""
"Зверніть увагу, що ввімкнення цього параметра збільшить вимоги до пам'яті "
"для :ref:`class_ConcavePolygonShape3D` приблизно на 25%."

msgid "Kinematic RigidBody3D contacts"
msgstr "Кінематичні контакти RigidBody3D"

msgid ""
"When using Jolt, a :ref:`class_RigidBody3D` frozen "
"with :ref:`FREEZE_MODE_KINEMATIC<class_RigidBody3D_constant_FREEZE_MODE_KINEMATIC>` "
"will by default not report contacts from collisions with other static/"
"kinematic bodies, for performance reasons, even when setting a non-"
"zero :ref:`max_contacts_reported<class_RigidBody3D_property_max_contacts_reported>`. "
"If you have many/large kinematic bodies overlapping with complex static "
"geometry, such as :ref:`class_ConcavePolygonShape3D` "
"or :ref:`class_HeightMapShape3D`, you can end up wasting a significant "
"amount of CPU performance and memory without realizing it."
msgstr ""
"Під час використання Jolt, :ref:`class_RigidBody3D`, заморожений за "
"допомогою :ref:`FREEZE_MODE_KINEMATIC<class_RigidBody3D_constant_FREEZE_MODE_KINEMATIC>`, "
"за замовчуванням не повідомлятиме про контакти від зіткнень з іншими "
"статичними/кінематичними тілами з міркувань продуктивності, навіть якщо "
"встановлено ненульове "
"значення :ref:`max_contacts_reported<class_RigidBody3D_property_max_contacts_reported>`. "
"Якщо у вас є багато/великі кінематичні тіла, що перекриваються зі складною "
"статичною геометрією, такою як :ref:`class_ConcavePolygonShape3D` "
"або :ref:`class_HeightMapShape3D`, ви можете зрештою витрачати значну "
"кількість продуктивності процесора та пам'яті, не усвідомлюючи цього."

msgid ""
"For this reason this behavior is opt-in through the project "
"setting :ref:`Physics > Jolt Physics 3D > Simulation > Generate All "
"Kinematic Contacts<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/generate_all_kinematic_contacts>`."
msgstr ""
"З цієї причини ця поведінка вмикається через налаштування "
"проекту :ref:`Physics > Jolt Physics 3D > Simulation > Generate All "
"Kinematic Contacts<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/generate_all_kinematic_contacts>`."

msgid "Contact impulses"
msgstr "Контактні імпульси"

msgid ""
"Due to limitations internal to Jolt, the contact impulses provided "
"by :ref:`PhysicsDirectBodyState3D.get_contact_impulse()<class_physicsdirectbodystate3d_method_get_contact_impulse>` "
"are estimated ahead of time based on things like the contact manifold and "
"velocities of the colliding bodies. This means that the reported impulses "
"will only be accurate in cases where the two bodies in question are not "
"colliding with any other bodies."
msgstr ""
"Через внутрішні обмеження Jolt, контактні імпульси, що "
"надаються :ref:`PhysicsDirectBodyState3D.get_contact_impulse()<class_physicsdirectbodystate3d_method_get_contact_impulse>`, "
"оцінюються заздалегідь на основі таких речей, як контактний різноманіття та "
"швидкості тіл, що стикаються. Це означає, що повідомлені імпульси будуть "
"точними лише у випадках, коли два тіла, що розглядаються, не стикаються з "
"жодними іншими тілами."

msgid "Area3D and SoftBody3D"
msgstr "Area3D та SoftBody3D"

msgid ""
"Jolt does not currently support any interactions "
"between :ref:`class_SoftBody3D` and :ref:`class_Area3D`, such as overlap "
"events, or the wind properties found on :ref:`class_Area3D`."
msgstr ""
"Jolt наразі не підтримує жодної взаємодії між :ref:`class_SoftBody3D` "
"та :ref:`class_Area3D`, такої як події перекриття або властивості вітру, "
"знайдені на :ref:`class_Area3D`."

msgid "WorldBoundaryShape3D"
msgstr "WorldBoundaryShape3D"

msgid ""
":ref:`class_WorldBoundaryShape3D`, which is meant to represent an infinite "
"plane, is implemented a bit differently in Jolt compared to Godot Physics. "
"Both engines have an upper limit for how big the effective size of this "
"plane can be, but this size is much smaller when using Jolt, in order to "
"avoid precision issues."
msgstr ""
":ref:`class_WorldBoundaryShape3D`, який призначений для представлення "
"нескінченної площини, реалізовано в Jolt дещо інакше порівняно з Godot "
"Physics. Обидва рушії мають верхню межу ефективного розміру цієї площини, "
"але цей розмір набагато менший при використанні Jolt, щоб уникнути проблем з "
"точністю."

msgid ""
"You can configure this size using the :ref:`Physics > Jolt Physics 3D > "
"Limits > World Boundary Shape Size<class_ProjectSettings_Property_physics/"
"jolt_physics_3d/limits/world_boundary_shape_size>` project setting."
msgstr ""
"Ви можете налаштувати цей розмір за допомогою параметрів "
"проєкту :ref:`Physics > Jolt Physics 3D > Limits > World Boundary Shape "
"Size<class_ProjectSettings_Property_physics/jolt_physics_3d/limits/"
"world_boundary_shape_size>`."

msgid "Notable differences to the Godot Jolt extension"
msgstr "Помітні відмінності від розширення Godot Jolt"

msgid ""
"While the built-in Jolt module is largely a straight port of the Godot Jolt "
"extension, there are a few things that are different."
msgstr ""
"Хоча вбудований модуль Jolt значною мірою є прямим портом розширення Godot "
"Jolt, є кілька відмінностей."

msgid "Project settings"
msgstr "Параметри проекту"

msgid ""
"All project settings have been moved from the ``physics/jolt_3d`` category "
"to ``physics/jolt_physics_3d``."
msgstr ""
"Усі налаштування проєкту перенесено з категорії ``physics/jolt_3d`` до "
"``physics/jolt_physics_3d``."

msgid ""
"On top of that, there's been some renaming and refactoring of the individual "
"project settings as well. These include:"
msgstr ""
"Крім того, було також здійснено деякі перейменування та рефакторинг окремих "
"налаштувань проекту. До них належать:"

msgid "``sleep/enabled`` is now ``simulation/allow_sleep.``"
msgstr "``sleep/enabled`` зараз ``simulation/allow_sleep.``"

msgid ""
"``sleep/velocity_threshold`` is now ``simulation/sleep_velocity_threshold.``"
msgstr ""
"``sleep/velocity_threshold`` зараз ``simulation/sleep_velocity_threshold.``"

msgid "``sleep/time_threshold`` is now ``simulation/sleep_time_threshold.``"
msgstr "``sleep/time_threshold`` зараз ``simulation/sleep_time_threshold.``"

msgid ""
"``collisions/use_shape_margins`` is now ``collisions/"
"collision_margin_fraction``, where a value of 0 is equivalent to disabling "
"it."
msgstr ""
"``collisions/use_shape_margins`` зараз ``collisions/"
"collision_margin_fraction``, де значення 0 еквівалентне його вимкненню."

msgid ""
"``collisions/use_enhanced_internal_edge_removal`` is now ``simulation/"
"use_enhanced_internal_edge_removal.``"
msgstr ""
"``collisions/use_enhanced_internal_edge_removal`` зараз ``simulation/"
"use_enhanced_internal_edge_removal.``"

msgid ""
"``collisions/areas_detect_static_bodies`` is now ``simulation/"
"areas_detect_static_bodies.``"
msgstr ""
"``collisions/areas_detect_static_bodies`` зараз ``simulation/"
"areas_detect_static_bodies.``"

msgid ""
"``collisions/report_all_kinematic_contacts`` is now ``simulation/"
"generate_all_kinematic_contacts.``"
msgstr ""
"``collisions/report_all_kinematic_contacts`` зараз ``simulation/"
"generate_all_kinematic_contacts.``"

msgid ""
"``collisions/soft_body_point_margin`` is now ``simulation/"
"soft_body_point_radius.``"
msgstr ""
"``collisions/soft_body_point_margin`` зараз ``simulation/"
"soft_body_point_radius.``"

msgid ""
"``collisions/body_pair_cache_enabled is now simulation/"
"body_pair_contact_cache_enabled.``"
msgstr ""
"``collisions/body_pair_cache_enabled is now simulation/"
"body_pair_contact_cache_enabled.``"

msgid ""
"``collisions/body_pair_cache_distance_threshold`` is ``now simulation/"
"body_pair_contact_cache_distance_threshold.``"
msgstr ""
"``collisions/body_pair_cache_distance_threshold`` є ``now simulation/"
"body_pair_contact_cache_distance_threshold.``"

msgid ""
"``collisions/body_pair_cache_angle_threshold is now simulation/"
"body_pair_contact_cache_angle_threshold.``"
msgstr ""
"``collisions/body_pair_cache_angle_threshold is now simulation/"
"body_pair_contact_cache_angle_threshold.``"

msgid ""
"``continuous_cd/movement_threshold`` is now ``simulation/"
"continuous_cd_movement_threshold``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``continuous_cd/movement_threshold`` зараз ``simulation/"
"continuous_cd_movement_threshold``, але виражений у вигляді дробу, а не "
"відсотків."

msgid ""
"``continuous_cd/max_penetration`` is now ``simulation/"
"continuous_cd_max_penetration``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``continuous_cd/max_penetration`` зараз ``simulation/"
"continuous_cd_max_penetration``, але виражений у вигляді дробу, а не "
"відсотків."

msgid ""
"``kinematics/use_enhanced_internal_edge_removal`` is now ``motion_queries/"
"use_enhanced_internal_edge_removal.``"
msgstr ""
"``kinematics/use_enhanced_internal_edge_removal`` зараз ``motion_queries/"
"use_enhanced_internal_edge_removal.``"

msgid ""
"``kinematics/recovery_iterations`` is now ``motion_queries/"
"recovery_iterations``, but expressed as a fraction instead of a percentage."
msgstr ""
"``kinematics/recovery_iterations`` зараз ``motion_queries/"
"recovery_iterations``, але виражений у вигляді дробу, а не відсотків."

msgid ""
"``kinematics/recovery_amount`` is now ``motion_queries/recovery_amount.``"
msgstr ""
"``kinematics/recovery_amount`` зараз ``motion_queries/recovery_amount.``"

msgid "``queries/use_legacy_ray_casting`` has been removed."
msgstr "``queries/use_legacy_ray_casting`` було видалено."

msgid "``solver/position_iterations`` is now ``simulation/position_steps.``"
msgstr "``solver/position_iterations`` зараз ``simulation/position_steps.``"

msgid "``solver/velocity_iterations`` is now ``simulation/velocity_steps.``"
msgstr "``solver/velocity_iterations`` зараз ``simulation/velocity_steps.``"

msgid ""
"``solver/position_correction`` is now ``simulation/"
"baumgarte_stabilization_factor``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``solver/position_correction`` зараз ``simulation/"
"baumgarte_stabilization_factor``, але виражений у вигляді дробу, а не "
"відсотків."

msgid ""
"``solver/active_edge_threshold`` is now ``collisions/active_edge_threshold.``"
msgstr ""
"``solver/active_edge_threshold`` зараз ``collisions/active_edge_threshold.``"

msgid ""
"``solver/bounce_velocity_threshold`` is now ``simulation/"
"bounce_velocity_threshold.``"
msgstr ""
"``solver/bounce_velocity_threshold`` зараз ``simulation/"
"bounce_velocity_threshold.``"

msgid ""
"``solver/contact_speculative_distance`` is now ``simulation/"
"speculative_contact_distance.``"
msgstr ""
"``solver/contact_speculative_distance`` зараз ``simulation/"
"speculative_contact_distance.``"

msgid ""
"``solver/contact_allowed_penetration`` is now ``simulation/"
"penetration_slop.``"
msgstr ""
"``solver/contact_allowed_penetration`` зараз ``simulation/penetration_slop.``"

msgid "``limits/max_angular_velocity`` is now stored as radians instead."
msgstr "``limits/max_angular_velocity`` тепер зберігається у вигляді радіанів."

msgid ""
"``limits/max_temporary_memory`` is now ``limits/"
"temporary_memory_buffer_size.``"
msgstr ""
"``limits/max_temporary_memory`` зараз ``limits/"
"temporary_memory_buffer_size.``"

msgid "Joint nodes"
msgstr "Суглобові вузли"

msgid ""
"The joint nodes that are exposed in the Godot Jolt extension "
"(JoltPinJoint3D, JoltHingeJoint3D, JoltSliderJoint3D, JoltConeTwistJoint3D, "
"and JoltGeneric6DOFJoint) have not been included in the Jolt module."
msgstr ""
"Вузли з'єднань, що відображаються в розширенні Godot Jolt (JoltPinJoint3D, "
"JoltHingeJoint3D, JoltSliderJoint3D, JoltConeTwistJoint3D та "
"JoltGeneric6DOFJoint), не були включені до модуля Jolt."

msgid "Thread safety"
msgstr "Безпека потоків"

msgid ""
"Unlike the Godot Jolt extension, the Jolt module does have thread-safety, "
"including support for the :ref:`Physics > 3D > Run On Separate "
"Thread<class_ProjectSettings_Property_physics/3d/run_on_separate_thread>` "
"project setting. However this has not been tested very thoroughly, so it "
"should be considered experimental."
msgstr ""
"На відміну від розширення Godot Jolt, модуль Jolt має потокобезпечність, "
"зокрема підтримку налаштування проекту :ref:`Physics > 3D > Run On Separate "
"Thread<class_ProjectSettings_Property_physics/3d/run_on_separate_thread>`. "
"Однак це не було ретельно протестовано, тому його слід вважати "
"експериментальним."
