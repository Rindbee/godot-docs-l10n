#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using CharacterBody2D/3D"
msgstr "Використання CharacterBody2D/3D"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot offers several collision objects to provide both collision detection "
"and response. Trying to decide which one to use for your project can be "
"confusing. You can avoid problems and simplify development if you understand "
"how each of them works and what their pros and cons are. In this tutorial, "
"we'll look at the :ref:`CharacterBody2D <class_CharacterBody2D>` node and "
"show some examples of how to use it."
msgstr ""
"Godot пропонує кілька об’єктів зіткнення, щоб забезпечити як виявлення "
"зіткнення, так і відповідь. Спроба вирішити, який з них використовувати для "
"вашого проекту, може заплутати. Ви зможете уникнути проблем і спростити "
"розробку, якщо зрозумієте, як кожен з них працює і в чому його плюси і "
"мінуси. У цьому посібнику ми розглянемо вузол :ref:`CharacterBody2D "
"<class_CharacterBody2D>` і покажемо кілька прикладів його використання."

msgid ""
"While this document uses ``CharacterBody2D`` in its examples, the same "
"concepts apply in 3D as well."
msgstr ""
"У той час як у цьому документі використовується ``CharacterBody2D`` у своїх "
"прикладах, ті самі поняття також застосовуються в 3D."

msgid "What is a character body?"
msgstr "Що таке тіло персонажа?"

msgid ""
"``CharacterBody2D`` is for implementing bodies that are controlled via code. "
"Character bodies detect collisions with other bodies when moving, but are "
"not affected by engine physics properties, like gravity or friction. While "
"this means that you have to write some code to create their behavior, it "
"also means you have more precise control over how they move and react."
msgstr ""
"``CharacterBody2D`` призначений для реалізації тіл, які керуються через код. "
"Тіла персонажів виявляють зіткнення з іншими тілами під час руху, але на них "
"не впливають фізичні властивості двигуна, як-от сила тяжіння чи тертя. Хоча "
"це означає, що вам потрібно написати певний код, щоб створити їх поведінку, "
"це також означає, що ви маєте більш точний контроль над тим, як вони "
"рухаються та реагують."

msgid ""
"This document assumes you're familiar with Godot's various physics bodies. "
"Please read :ref:`doc_physics_introduction` first, for an overview of the "
"physics options."
msgstr ""
"Цей документ передбачає, що ви знайомі з різними фізичними тілами Godot. "
"Будь ласка, спочатку прочитайте :ref:`doc_physics_introduction` для огляду "
"варіантів фізики."

msgid ""
"A `CharacterBody2D` can be affected by gravity and other forces, but you "
"must calculate the movement in code. The physics engine will not move a "
"`CharacterBody2D`."
msgstr ""
"На `CharacterBody2D` може впливати сила тяжіння та інші сили, але ви повинні "
"обчислити рух у коді. Фізичний механізм не переміщуватиме `CharacterBody2D`."

msgid "Movement and collision"
msgstr "Рух і зіткнення"

msgid ""
"When moving a ``CharacterBody2D``, you should not set its ``position`` "
"property directly. Instead, you use the ``move_and_collide()`` or "
"``move_and_slide()`` methods. These methods move the body along a given "
"vector and detect collisions."
msgstr ""
"Переміщуючи ``CharacterBody2D``, ви не повинні встановлювати його "
"властивість ``position`` безпосередньо. Замість цього ви використовуєте "
"методи ``move_and_collide()`` або ``move_and_slide()``. Ці методи "
"переміщують тіло по заданому вектору та виявляють зіткнення."

msgid ""
"You should handle physics body movement in the ``_physics_process()`` "
"callback."
msgstr ""
"Ви повинні обробляти фізичний рух тіла у зворотному виклику "
"``_physics_process()``."

msgid ""
"The two movement methods serve different purposes, and later in this "
"tutorial, you'll see examples of how they work."
msgstr ""
"Два методи руху служать різним цілям, і далі в цьому посібнику ви побачите "
"приклади їх роботи."

msgid "move_and_collide"
msgstr "move_and_collide"

msgid ""
"This method takes one required parameter: a :ref:`Vector2 <class_Vector2>` "
"indicating the body's relative movement. Typically, this is your velocity "
"vector multiplied by the frame timestep (``delta``). If the engine detects a "
"collision anywhere along this vector, the body will immediately stop moving. "
"If this happens, the method will return a :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` object."
msgstr ""
"Цей метод приймає один обов’язковий параметр: a :ref:`Vector2 "
"<class_Vector2>`, що вказує на відносний рух тіла. Як правило, це ваш вектор "
"швидкості, помножений на часовий крок кадру (``дельта``). Якщо двигун "
"виявить зіткнення в будь-якому місці цього вектора, тіло негайно припинить "
"рух. Якщо це станеться, метод поверне об’єкт :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>`."

msgid ""
"``KinematicCollision2D`` is an object containing data about the collision "
"and the colliding object. Using this data, you can calculate your collision "
"response."
msgstr ""
"``KinematicCollision2D`` — це об’єкт, що містить дані про зіткнення та "
"об’єкт зіткнення. Використовуючи ці дані, ви можете розрахувати реакцію на "
"зіткнення."

msgid ""
"``move_and_collide`` is most useful when you just want to move the body and "
"detect collision, but don't need any automatic collision response. For "
"example, if you need a bullet that ricochets off a wall, you can directly "
"change the angle of the velocity when you detect a collision. See below for "
"an example."
msgstr ""
"``move_and_collide`` найбільш корисний, коли ви просто хочете перемістити "
"тіло та виявити зіткнення, але не потребуєте автоматичної реакції на "
"зіткнення. Наприклад, якщо вам потрібна куля, яка рикошетить від стіни, ви "
"можете безпосередньо змінити кут швидкості, коли виявите зіткнення. Дивіться "
"приклад нижче."

msgid "move_and_slide"
msgstr "move_and_slide"

msgid ""
"The ``move_and_slide()`` method is intended to simplify the collision "
"response in the common case where you want one body to slide along the "
"other. It is especially useful in platformers or top-down games, for example."
msgstr ""
"Метод ``move_and_slide()`` призначений для спрощення реакції на зіткнення у "
"типовому випадку, коли ви хочете, щоб одне тіло ковзало вздовж іншого. Це "
"особливо корисно, наприклад, у платформерах або іграх з видом зверху."

msgid ""
"When calling ``move_and_slide()``, the function uses a number of node "
"properties to calculate its slide behavior. These properties can be found in "
"the Inspector, or set in code."
msgstr ""
"Під час виклику ``move_and_slide()`` функція використовує низку властивостей "
"вузла для обчислення його поведінки ковзання. Ці властивості можна знайти в "
"інспекторі або встановити в коді."

msgid "``velocity`` - *default value:* ``Vector2( 0, 0 )``"
msgstr "``velocity`` - *значення за замовчуванням:* ``Vector2( 0, 0 )``"

msgid ""
"This property represents the body's velocity vector in pixels per second. "
"``move_and_slide()`` will modify this value automatically when colliding."
msgstr ""
"Ця властивість представляє вектор швидкості тіла в пікселях на секунду. "
"``move_and_slide()`` автоматично змінить це значення під час зіткнення."

msgid "``motion_mode`` - *default value:* ``MOTION_MODE_GROUNDED``"
msgstr ""
"``motion_mode`` - *значення за замовчуванням:* ``MOTION_MODE_GROUNDED``"

msgid ""
"This property is typically used to distinguish between side-scrolling and "
"top-down movement. When using the default value, you can use the "
"``is_on_floor()``, ``is_on_wall()``, and ``is_on_ceiling()`` methods to "
"detect what type of surface the body is in contact with, and the body will "
"interact with slopes. When using ``MOTION_MODE_FLOATING``, all collisions "
"will be considered \"walls\"."
msgstr ""
"Ця властивість зазвичай використовується, щоб розрізнити бічне прокручування "
"та рух зверху вниз. Використовуючи значення за замовчуванням, ви можете "
"використовувати методи ``is_on_floor()``, ``is_on_wall()`` і "
"``is_on_ceiling()``, щоб визначити, з яким типом поверхні контактує тіло, і "
"тіло буде взаємодіяти зі схилами. При використанні ``MOTION_MODE_FLOATING`` "
"усі зіткнення вважатимуться \"стінами\"."

msgid "``up_direction`` - *default value:* ``Vector2( 0, -1 )``"
msgstr "``up_direction`` - *значення за замовчуванням:* ``Вектор2( 0, -1 )``"

msgid ""
"This property allows you to define what surfaces the engine should consider "
"being the floor. Its value lets you use the ``is_on_floor()``, "
"``is_on_wall()``, and ``is_on_ceiling()`` methods to detect what type of "
"surface the body is in contact with. The default value means that the top "
"side of horizontal surfaces will be considered \"ground\"."
msgstr ""
"Ця властивість дозволяє визначити, які поверхні двигун повинен вважати "
"підлогою. Його значення дозволяє використовувати методи ``is_on_floor()``, "
"``is_on_wall()`` і ``is_on_ceiling()``, щоб визначити, з яким типом поверхні "
"контактує тіло. Значення за замовчуванням означає, що верхня сторона "
"горизонтальних поверхонь вважатиметься «грунтом»."

msgid "``floor_stop_on_slope`` - *default value:* ``true``"
msgstr "``floor_stop_on_slope`` - *значення за замовчуванням:* ``true``"

msgid ""
"This parameter prevents a body from sliding down slopes when standing still."
msgstr "Цей параметр запобігає ковзанню тіла вниз по схилах під час стояння."

msgid ""
"``wall_min_slide_angle`` - *default value:* ``0.261799`` (in radians, "
"equivalent to ``15`` degrees)"
msgstr ""
"``wall_min_slide_angle`` - *значення за замовчуванням:* ``0,261799`` (у "
"радіанах, еквівалентно ``15`` градусам)"

msgid ""
"This is the minimum angle where the body is allowed to slide when it hits a "
"slope."
msgstr "Це мінімальний кут, під яким тіло може ковзати при наїзді на схил."

msgid ""
"``floor_max_angle`` - *default value:* ``0.785398`` (in radians, equivalent "
"to ``45`` degrees)"
msgstr ""
"``floor_max_angle`` - *значення за замовчуванням:* ``0,785398`` (у радіанах, "
"еквівалентно ``45`` градусам)"

msgid ""
"This parameter is the maximum angle before a surface is no longer considered "
"a \"floor.\""
msgstr ""
"Цей параметр є максимальним кутом перед тим, як поверхня більше не "
"вважатиметься «підлогою»"

msgid ""
"There are many other properties that can be used to modify the body's "
"behavior under specific circumstances. See the :ref:`CharacterBody2D "
"<class_CharacterBody2D>` docs for full details."
msgstr ""
"Є багато інших властивостей, які можна використовувати для зміни поведінки "
"організму за певних обставин. Перегляньте документацію :ref:`CharacterBody2D "
"<class_CharacterBody2D>` для повної інформації."

msgid "Detecting collisions"
msgstr "Виявлення зіткнень"

msgid ""
"When using ``move_and_collide()`` the function returns a "
"``KinematicCollision2D`` directly, and you can use this in your code."
msgstr ""
"При використанні ``move_and_collide()`` функція повертає "
"``KinematicCollision2D`` безпосередньо, і ви можете використовувати це у "
"своєму коді."

msgid ""
"When using ``move_and_slide()`` it's possible to have multiple collisions "
"occur, as the slide response is calculated. To process these collisions, use "
"``get_slide_collision_count()`` and ``get_slide_collision()``:"
msgstr ""
"Під час використання ``move_and_slide()`` можливе виникнення кількох "
"зіткнень, оскільки обчислюється відповідь на слайд. Щоб обробити ці "
"зіткнення, використовуйте ``get_slide_collision_count()`` і "
"``get_slide_collision()``:"

msgid ""
"`get_slide_collision_count()` only counts times the body has collided and "
"changed direction."
msgstr ""
"`get_slide_collision_count()` підраховує лише рази, коли тіло зіткнулося та "
"змінило напрямок."

msgid ""
"See :ref:`KinematicCollision2D <class_KinematicCollision2D>` for details on "
"what collision data is returned."
msgstr ""
"Перегляньте :ref:`KinematicCollision2D <class_KinematicCollision2D>`, щоб "
"дізнатися, які дані про зіткнення повертаються."

msgid "Which movement method to use?"
msgstr "Який метод руху використовувати?"

msgid ""
"A common question from new Godot users is: \"How do you decide which "
"movement function to use?\" Often, the response is to use "
"``move_and_slide()`` because it seems simpler, but this is not necessarily "
"the case. One way to think of it is that ``move_and_slide()`` is a special "
"case, and ``move_and_collide()`` is more general. For example, the following "
"two code snippets result in the same collision response:"
msgstr ""
"Поширене запитання нових користувачів Godot: \"Як ви вирішуєте, яку функцію "
"руху використовувати?\" Часто у відповідь використовують "
"``move_and_slide()``, оскільки це здається простішим, але це не обов’язково "
"так. Один із способів подумати про це так: ``move_and_slide()`` є окремим "
"випадком, а ``move_and_collide()`` є більш загальним. Наприклад, наступні "
"два фрагменти коду призводять до однакової відповіді на конфлікт:"

msgid ""
"Anything you do with ``move_and_slide()`` can also be done with "
"``move_and_collide()``, but it might take a little more code. However, as "
"we'll see in the examples below, there are cases where ``move_and_slide()`` "
"doesn't provide the response you want."
msgstr ""
"Усе, що ви робите за допомогою ``move_and_slide()``, також можна зробити за "
"допомогою ``move_and_collide()``, але для цього може знадобитися трохи "
"більше коду. Однак, як ми побачимо в наведених нижче прикладах, є випадки, "
"коли ``move_and_slide()`` не надає потрібної відповіді."

msgid ""
"In the example above, ``move_and_slide()`` automatically alters the "
"``velocity`` variable. This is because when the character collides with the "
"environment, the function recalculates the speed internally to reflect the "
"slowdown."
msgstr ""
"У наведеному вище прикладі ``move_and_slide()`` автоматично змінює змінну "
"``velocity``. Це пояснюється тим, що коли персонаж стикається з навколишнім "
"середовищем, функція внутрішньо перераховує швидкість, щоб відобразити "
"уповільнення."

msgid ""
"For example, if your character fell on the floor, you don't want it to "
"accumulate vertical speed due to the effect of gravity. Instead, you want "
"its vertical speed to reset to zero."
msgstr ""
"Наприклад, якщо ваш персонаж впав на підлогу, ви не хочете, щоб він "
"накопичував вертикальну швидкість через дію сили тяжіння. Натомість ви "
"хочете скинути його вертикальну швидкість до нуля."

msgid ""
"``move_and_slide()`` may also recalculate the kinematic body's velocity "
"several times in a loop as, to produce a smooth motion, it moves the "
"character and collides up to five times by default. At the end of the "
"process, the character's new velocity is available for use on the next frame."
msgstr ""
"``move_and_slide()`` також може перераховувати кінематичну швидкість тіла "
"кілька разів у циклі, оскільки для створення плавного руху воно переміщує "
"персонажа та стикається до п’яти разів за замовчуванням. Наприкінці процесу "
"нова швидкість персонажа доступна для використання в наступному кадрі."

msgid "Examples"
msgstr "Приклади"

msgid ""
"To see these examples in action, download the sample project: "
"`character_body_2d_starter.zip <https://github.com/godotengine/godot-docs-"
"project-starters/releases/download/latest-4.x/"
"character_body_2d_starter.zip>`_"
msgstr ""
"Щоб побачити ці приклади в дії, завантажте приклад проекту: "
"`character_body_2d_starter.zip <https://github.com/godotengine/godot-docs-"
"project-starters/releases/download/latest-4.x/"
"character_body_2d_starter.zip>`_"

msgid "Movement and walls"
msgstr "Рух і стіни"

msgid ""
"If you've downloaded the sample project, this example is in "
"\"basic_movement.tscn\"."
msgstr ""
"Якщо ви завантажили зразок проекту, цей приклад знаходиться в "
"\"basic_movement.tscn\"."

msgid ""
"For this example, add a ``CharacterBody2D`` with two children: a "
"``Sprite2D`` and a ``CollisionShape2D``. Use the Godot \"icon.svg\" as the "
"Sprite2D's texture (drag it from the Filesystem dock to the *Texture* "
"property of the ``Sprite2D``). In the ``CollisionShape2D``'s *Shape* "
"property, select \"New RectangleShape2D\" and size the rectangle to fit over "
"the sprite image."
msgstr ""
"Для цього прикладу додайте ``CharacterBody2D`` з двома дочірніми елементами: "
"``Sprite2D`` і ``CollisionShape2D``. Використовуйте Godot \"icon.svg\" як "
"текстуру Sprite2D (перетягніть його з док-станції Filesystem до властивості "
"*Texture* ``Sprite2D``). У властивості *Shape* ``CollisionShape2D`` виберіть "
"«New RectangleShape2D» і задайте розмір прямокутника так, щоб він поміщався "
"над зображенням спрайту."

msgid ""
"See :ref:`doc_2d_movement` for examples of implementing 2D movement schemes."
msgstr ""
"Дивіться :ref:`doc_2d_movement` для прикладів реалізації двовимірних схем "
"руху."

msgid "Attach a script to the CharacterBody2D and add the following code:"
msgstr "Додайте сценарій до CharacterBody2D і додайте такий код:"

msgid ""
"Run this scene and you'll see that ``move_and_collide()`` works as expected, "
"moving the body along the velocity vector. Now let's see what happens when "
"you add some obstacles. Add a :ref:`StaticBody2D <class_StaticBody2D>` with "
"a rectangular collision shape. For visibility, you can use a Sprite2D, a "
"Polygon2D, or turn on \"Visible Collision Shapes\" from the \"Debug\" menu."
msgstr ""
"Запустіть цю сцену, і ви побачите, що ``move_and_collide()`` працює належним "
"чином, переміщуючи тіло вздовж вектора швидкості. Тепер давайте подивимося, "
"що станеться, якщо ви додасте кілька перешкод. Додайте :ref:`StaticBody2D "
"<class_StaticBody2D>` з прямокутною формою зіткнення. Для видимості можна "
"використовувати Sprite2D, Polygon2D або ввімкнути «Видимі форми зіткнень» у "
"меню «Налагодження»."

msgid ""
"Run the scene again and try moving into the obstacle. You'll see that the "
"``CharacterBody2D`` can't penetrate the obstacle. However, try moving into "
"the obstacle at an angle and you'll find that the obstacle acts like glue - "
"it feels like the body gets stuck."
msgstr ""
"Запустіть сцену ще раз і спробуйте натрапити на перешкоду. Ви побачите, що "
"``CharacterBody2D`` не може подолати перешкоду. Однак спробуйте наблизитися "
"до перешкоди під кутом, і ви побачите, що перешкода діє як клей – таке "
"відчуття, ніби тіло застрягло."

msgid ""
"This happens because there is no *collision response*. "
"``move_and_collide()`` stops the body's movement when a collision occurs. We "
"need to code whatever response we want from the collision."
msgstr ""
"Це відбувається тому, що немає *відповіді на зіткнення*. "
"``move_and_collide()`` зупиняє рух тіла, коли відбувається зіткнення. Нам "
"потрібно закодувати будь-яку відповідь від зіткнення, яку ми хочемо."

msgid "Try changing the function to ``move_and_slide()`` and running again."
msgstr "Спробуйте змінити функцію на ``move_and_slide()`` і запустіть знову."

msgid ""
"``move_and_slide()`` provides a default collision response of sliding the "
"body along the collision object. This is useful for a great many game types, "
"and may be all you need to get the behavior you want."
msgstr ""
"``move_and_slide()`` забезпечує реакцію на зіткнення за замовчуванням "
"ковзанням тіла вздовж об’єкта зіткнення. Це корисно для багатьох типів ігор "
"і може бути всім, що вам потрібно, щоб отримати бажану поведінку."

msgid "Bouncing/reflecting"
msgstr "Підстрибуючи/відображаючи"

msgid ""
"What if you don't want a sliding collision response? For this example "
"(\"bounce_and_collide.tscn\" in the sample project), we have a character "
"shooting bullets and we want the bullets to bounce off the walls."
msgstr ""
"Що робити, якщо вам не потрібна ковзаюча реакція на зіткнення? У цьому "
"прикладі (\"bounce_and_collide.tscn\" у прикладі проекту) у нас є персонаж, "
"який стріляє кулями, і ми хочемо, щоб кулі відскакували від стін."

msgid ""
"This example uses three scenes. The main scene contains the Player and "
"Walls. The Bullet and Wall are separate scenes so that they can be instanced."
msgstr ""
"У цьому прикладі використовуються три сцени. Основна сцена містить гравця та "
"стіни. Куля та Стіна є окремими сценами, тому їх можна інстансувати."

msgid ""
"The Player is controlled by the ``w`` and ``s`` keys for forward and back. "
"Aiming uses the mouse pointer. Here is the code for the Player, using "
"``move_and_slide()``:"
msgstr ""
"Гравець керується клавішами ``w`` і ``s`` для руху вперед і назад. Для "
"прицілювання використовується вказівник миші. Ось код для програвача, який "
"використовує ``move_and_slide()``:"

msgid "And the code for the Bullet:"
msgstr "І код для Bullet:"

msgid ""
"The action happens in ``_physics_process()``. After using "
"``move_and_collide()``, if a collision occurs, a ``KinematicCollision2D`` "
"object is returned (otherwise, the return is ``null``)."
msgstr ""
"Дія відбувається в ``_physics_process()``. Після використання "
"``move_and_collide()``, якщо відбувається зіткнення, повертається об’єкт "
"``KinematicCollision2D`` (в іншому випадку повертається ``null``)."

msgid ""
"If there is a returned collision, we use the ``normal`` of the collision to "
"reflect the bullet's ``velocity`` with the ``Vector2.bounce()`` method."
msgstr ""
"Якщо є зворотне зіткнення, ми використовуємо ``нормаль`` зіткнення, щоб "
"відобразити ``швидкість`` кулі за допомогою методу ``Vector2.bounce()``."

msgid ""
"If the colliding object (``collider``) has a ``hit`` method, we also call "
"it. In the example project, we've added a flashing color effect to the Wall "
"to demonstrate this."
msgstr ""
"Якщо об’єкт зіткнення (``collider``) має метод ``hit``, ми також викликаємо "
"його. У прикладі проекту ми додали ефект миготливого кольору до стіни, щоб "
"продемонструвати це."

msgid "Platformer movement"
msgstr "Рух платформер"

msgid ""
"Let's try one more popular example: the 2D platformer. ``move_and_slide()`` "
"is ideal for quickly getting a functional character controller up and "
"running. If you've downloaded the sample project, you can find this in "
"\"platformer.tscn\"."
msgstr ""
"Давайте спробуємо ще один популярний приклад: 2D-платформер. "
"``move_and_slide()`` ідеально підходить для швидкого запуску та запуску "
"функціонального контролера символів. Якщо ви завантажили зразок проекту, ви "
"можете знайти його в \"platformer.tscn\"."

msgid ""
"For this example, we'll assume you have a level made of one or more "
"``StaticBody2D`` objects. They can be any shape and size. In the sample "
"project, we're using :ref:`Polygon2D <class_Polygon2D>` to create the "
"platform shapes."
msgstr ""
"Для цього прикладу ми припустимо, що у вас є рівень, який складається з "
"одного або кількох об’єктів ``StaticBody2D``. Вони можуть бути будь-якої "
"форми і розміру. У прикладі проекту ми використовуємо :ref:`Polygon2D "
"<class_Polygon2D>` для створення форм платформи."

msgid "Here's the code for the player body:"
msgstr "Ось код для тіла гравця:"

msgid ""
"In this code we're using ``move_and_slide()`` as described above - to move "
"the body along its velocity vector, sliding along any collision surfaces "
"such as the ground or a platform. We're also using ``is_on_floor()`` to "
"check if a jump should be allowed. Without this, you'd be able to \"jump\" "
"in midair; great if you're making Flappy Bird, but not for a platformer game."
msgstr ""
"У цьому коді ми використовуємо ``move_and_slide()``, як описано вище - для "
"переміщення тіла вздовж його вектора швидкості, ковзаючи вздовж будь-яких "
"поверхонь зіткнення, таких як земля або платформа. Ми також використовуємо "
"``is_on_floor()``, щоб перевірити, чи можна дозволити стрибок. Без цього ви "
"могли б «стрибнути» в повітрі; чудово, якщо ви створюєте Flappy Bird, але не "
"для платформерної гри."

msgid ""
"There is a lot more that goes into a complete platformer character: "
"acceleration, double-jumps, coyote-time, and many more. The code above is "
"just a starting point. You can use it as a base to expand into whatever "
"movement behavior you need for your own projects."
msgstr ""
"Існує багато іншого, що входить у повний персонаж платформера: прискорення, "
"подвійні стрибки, час койота та багато іншого. Наведений вище код є лише "
"відправною точкою. Ви можете використовувати його як основу для розширення "
"будь-якої поведінки руху, яка вам потрібна для ваших власних проектів."
