#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced physics interpolation"
msgstr "Розширена фізична інтерполяція"

msgid ""
"Although the previous instructions will give satisfactory results in a lot "
"of games, in some cases you will want to go a stage further to get the best "
"possible results and the smoothest possible experience."
msgstr ""
"Незважаючи на те, що попередні інструкції дадуть задовільні результати в "
"багатьох іграх, у деяких випадках ви захочете піти на крок далі, щоб "
"отримати найкращі можливі результати та якнайкращу роботу."

msgid "Exceptions to automatic physics interpolation"
msgstr "Винятки для автоматичної фізичної інтерполяції"

msgid ""
"Even with physics interpolation active, there may be some local situations "
"where you would benefit from disabling automatic interpolation for "
"a :ref:`Node<class_Node>` (or branch of "
"the :ref:`SceneTree<class_SceneTree>`), and have the finer control of "
"performing interpolation manually."
msgstr ""
"Навіть якщо фізична інтерполяція активна, можуть виникнути локальні "
"ситуації, коли вам буде корисно вимкнути автоматичну інтерполяцію "
"для :ref:`Node<class_Node>` (або гілки :ref:`SceneTree<class_SceneTree>`) і "
"мати більш точний контроль над виконанням інтерполяції вручну."

msgid ""
"This is possible using "
"the :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"property which is present in all Nodes. If you for example, turn off "
"interpolation for a Node, the children will recursively also be affected (as "
"they default to inheriting the parent setting). This means you can easily "
"disable interpolation for an entire subscene."
msgstr ""
"Це можливо за допомогою "
"властивості :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`, "
"яка присутня у всіх вузлах. Якщо ви, наприклад, вимкнете інтерполяцію для "
"вузла, рекурсивно це також вплине на дочірні елементи (оскільки вони за "
"умовчанням успадковують батьківські налаштування). Це означає, що ви можете "
"легко вимкнути інтерполяцію для всієї підсцени."

msgid ""
"The most common situation where you may want to perform your own "
"interpolation is Cameras."
msgstr ""
"Найпоширенішою ситуацією, коли ви можете виконати власну інтерполяцію, є "
"камери."

msgid "Cameras"
msgstr "Фотоапарати"

msgid ""
"In many cases, a :ref:`Camera3D<class_Camera3D>` can use automatic "
"interpolation just like any other node. However, for best results, "
"especially at low physics tick rates, it is recommended that you take a "
"manual approach to camera interpolation."
msgstr ""
"У багатьох випадках :ref:`Camera3D<class_Camera3D>` може використовувати "
"автоматичну інтерполяцію, як і будь-який інший вузол. Однак для досягнення "
"найкращих результатів, особливо при низьких фізичних тиках, рекомендується "
"використовувати ручний підхід до інтерполяції камери."

msgid ""
"This is because viewers are very sensitive to camera movement. For instance, "
"a Camera3D that realigns slightly every 1/10th of a second (at 10tps tick "
"rate) will often be noticeable. You can get a much smoother result by moving "
"the camera each frame in ``_process``, and following an interpolated target "
"manually."
msgstr ""
"Це тому, що глядачі дуже чутливі до руху камери. Наприклад, Camera3D, яка "
"дещо перебудовується кожні 1/10 секунди (зі швидкістю 10 tps), часто буде "
"помітною. Ви можете отримати набагато плавніший результат, переміщуючи "
"камеру в кожному кадрі в ``_process`` і дотримуючись інтерпольованої цілі "
"вручну."

msgid "Manual camera interpolation"
msgstr "Ручна інтерполяція камери"

msgid "Ensure the camera is using global coordinate space"
msgstr "Переконайтеся, що камера використовує глобальний простір координат"

msgid ""
"The very first step when performing manual camera interpolation is to make "
"sure the Camera3D transform is specified in *global space* rather than "
"inheriting the transform of a moving parent. This is because feedback can "
"occur between the movement of a parent node of a Camera3D and the movement "
"of the camera Node itself, which can mess up the interpolation."
msgstr ""
"Найпершим кроком під час виконання інтерполяції камери вручну є "
"переконатися, що перетворення Camera3D указано в *глобальному просторі*, а "
"не успадковувати перетворення рухомого батька. Це пояснюється тим, що може "
"виникнути зворотний зв’язок між рухом батьківського вузла Camera3D і рухом "
"самого вузла камери, що може зіпсувати інтерполяцію."

msgid "There are two ways of doing this:"
msgstr "Є два способи зробити це:"

msgid ""
"Move the Camera3D so it is independent on its own branch, rather than being "
"a child of a moving object."
msgstr ""
"Перемістіть Camera3D так, щоб він був незалежним від власної гілки, а не був "
"дочірнім елементом рухомого об’єкта."

msgid ""
"Call :ref:`Node3D.top_level<class_Node3D_property_top_level>` and set this "
"to ``true``, which will make the Camera ignore the transform of its parent."
msgstr ""
"Викличте :ref:`Node3D.top_level<class_Node3D_property_top_level>` і "
"встановіть значення ``true``, що змусить камеру ігнорувати перетворення "
"свого батька."

msgid "Typical example"
msgstr "Типовий приклад"

msgid ""
"A typical example of a custom approach is to use the ``look_at`` function in "
"the Camera3D every frame in ``_process()`` to look at a target node (such as "
"the player)."
msgstr ""
"Типовим прикладом спеціального підходу є використання ``look_at`` у Camera3D "
"кожен кадр у ``_process()``, щоб дивитися на цільовий вузол (наприклад, "
"програвач)."

msgid ""
"But there is a problem. If we use the traditional ``get_global_transform()`` "
"on a Camera3D \"target\" node, this transform will only focus the Camera3D "
"on the target *at the current physics tick*. This is *not* what we want, as "
"the camera will jump about on each physics tick as the target moves. Even "
"though the camera may be updated each frame, this does not help give smooth "
"motion if the *target* is only changing each physics tick."
msgstr ""
"Але є проблема. Якщо ми використовуємо традиційний "
"``get_global_transform()`` на «цільовому» вузлі Camera3D, це перетворення "
"фокусуватиме Camera3D лише на цілі *на поточному фізичному тику*. Це *не* "
"те, чого ми хочемо, оскільки камера буде стрибати на кожному фізичному "
"кліку, коли ціль рухається. Незважаючи на те, що камера може оновлюватися "
"кожного кадру, це не допомагає забезпечити плавний рух, якщо *ціль* змінює "
"лише кожен фізичний тик."

msgid "get_global_transform_interpolated()"
msgstr "get_global_transform_interpolated()"

msgid ""
"What we really want to focus the camera on, is not the position of the "
"target on the physics tick, but the *interpolated* position, i.e. the "
"position at which the target will be rendered."
msgstr ""
"Те, на чому ми дійсно хочемо сфокусувати камеру, це не положення цілі на "
"фізиці, а *інтерпольоване* положення, тобто положення, в якому ціль "
"відображатиметься."

msgid ""
"We can do this using "
"the :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"function. This acts exactly like "
"getting :ref:`Node3D.global_transform<class_Node3D_property_global_transform>` "
"but it gives you the *interpolated* transform (during a ``_process()`` call)."
msgstr ""
"Ми можемо зробити це за допомогою "
"функції :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`. "
"Це діє так само, як "
"отримання :ref:`Node3D.global_transform<class_Node3D_property_global_transform>`, "
"але це дає вам *інтерпольоване* перетворення (під час виклику "
"``_process()``)."

msgid ""
"``get_global_transform_interpolated()`` should only be used once or twice "
"for special cases such as cameras. It should **not** be used all over the "
"place in your code (both for performance reasons, and to give correct "
"gameplay)."
msgstr ""
"``get_global_transform_interpolated()`` слід використовувати лише один або "
"два рази для особливих випадків, таких як камери. Його **не** можна "
"використовувати скрізь у вашому коді (як з міркувань продуктивності, так і "
"для забезпечення правильного ігрового процесу)."

msgid ""
"Aside from exceptions like the camera, in most cases, your game logic should "
"be in ``_physics_process()``. In game logic you should be calling "
"``get_global_transform()`` or ``get_transform()``, which will give the "
"current physics transform (in global or local space respectively), which is "
"usually what you will want for gameplay code."
msgstr ""
"Окрім винятків, таких як камера, у більшості випадків ваша ігрова логіка має "
"бути в ``_physics_process()``. У логіці гри ви повинні викликати "
"``get_global_transform()`` або ``get_transform()``, які дадуть поточне "
"фізичне перетворення (у глобальному або локальному просторі відповідно), що "
"зазвичай є тим, що вам потрібно для коду ігрового процесу."

msgid "Example manual camera script"
msgstr "Приклад ручного сценарію камери"

msgid ""
"Here is an example of a simple fixed camera which follows an interpolated "
"target:"
msgstr ""
"Ось приклад простої фіксованої камери, яка слідує за інтерпольованою ціллю:"

msgid "Mouse look"
msgstr "Мишачий погляд"

msgid ""
"Mouse look is a very common way of controlling cameras. But there is a "
"problem. Unlike keyboard input which can be sampled periodically on the "
"physics tick, mouse move events can come in continuously. The camera will be "
"expected to react and follow these mouse movements on the next frame, rather "
"than waiting until the next physics tick."
msgstr ""
"Погляд миші - дуже поширений спосіб керування камерами. Але є проблема. На "
"відміну від введення з клавіатури, який можна періодично перевіряти під час "
"фізики, події переміщення миші можуть надходити постійно. Очікується, що "
"камера реагує та слідкує за цими рухами миші на наступному кадрі, а не чекає "
"до наступного тика фізики."

msgid ""
"In this situation, it can be better to disable physics interpolation for the "
"camera node "
"(using :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"and directly apply the mouse input to the camera rotation, rather than apply "
"it in ``_physics_process``."
msgstr ""
"У цій ситуації може бути краще вимкнути фізичну інтерполяцію для вузла "
"камери (за "
"допомогою :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"і безпосередньо застосувати введення миші до обертання камери, а не "
"застосовувати його в ``_physics_process``."

msgid ""
"Sometimes, especially with cameras, you will want to use a combination of "
"interpolation and non-interpolation:"
msgstr ""
"Іноді, особливо з камерами, ви захочете використовувати комбінацію "
"інтерполяції та неінтерполяції:"

msgid ""
"A first person camera may position the camera at a player location (perhaps "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"but control the Camera rotation from mouse look *without* interpolation."
msgstr ""
"Камера від першої особи може розташувати камеру в місці розташування гравця "
"(можливо, "
"використовуючи :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"але керувати обертанням камери з погляду миші *без* інтерполяції."

msgid ""
"A third person camera may similarly determine the look at (target location) "
"of the camera "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"but position the camera using mouse look *without* interpolation."
msgstr ""
"Камера третьої особи може подібним чином визначати погляд (цільове "
"розташування) камери за "
"допомогою :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"але позиціонувати камеру за допомогою погляду миші *без* інтерполяції."

msgid ""
"There are many permutations and variations of camera types, but it should be "
"clear that in many cases, disabling automatic physics interpolation and "
"handling this yourself can give a better result."
msgstr ""
"Існує багато перестановок і варіацій типів камер, але має бути зрозуміло, що "
"в багатьох випадках вимкнення автоматичної фізичної інтерполяції та власна "
"робота з нею може дати кращий результат."

msgid "Disabling interpolation on other nodes"
msgstr "Вимкнення інтерполяції на інших вузлах"

msgid ""
"Although cameras are the most common example, there are a number of cases "
"when you may wish other nodes to control their own interpolation, or be non-"
"interpolated. Consider for example, a player in a top view game whose "
"rotation is controlled by mouse look. Disabling physics rotation allows the "
"player rotation to match the mouse in real-time."
msgstr ""
"Хоча камери є найпоширенішим прикладом, існує ряд випадків, коли ви можете "
"побажати, щоб інші вузли контролювали свою власну інтерполяцію або не "
"інтерполювалися. Розглянемо, наприклад, гравця в грі з видом зверху, "
"обертання якого контролюється поглядом миші. Вимкнення обертання фізики "
"дозволяє обертанню гравця відповідати миші в реальному часі."

msgid "MultiMeshes"
msgstr "Мульти Meshes"

msgid ""
"Although most visual Nodes follow the single Node single visual instance "
"paradigm, MultiMeshes can control several instances from the same Node. "
"Therefore, they have some extra functions for controlling interpolation "
"functionality on a *per-instance* basis. You should explore these functions "
"if you are using interpolated MultiMeshes."
msgstr ""
"Хоча більшість візуальних вузлів дотримуються парадигми єдиного візуального "
"екземпляра Node, MultiMeshes може керувати декількома екземплярами з одного "
"вузла. Таким чином, вони мають деякі додаткові функції для контролю "
"функціональності інтерполяції на *кожній* основі. Вам слід вивчити ці "
"функції, якщо ви використовуєте інтерпольовані MultiMeshes."

msgid ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"
msgstr ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"

msgid ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"
msgstr ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"

msgid ""
"Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation."
msgstr ""
"Повна інформація міститься в документації :ref:`MultiMesh<class_MultiMesh>`."
