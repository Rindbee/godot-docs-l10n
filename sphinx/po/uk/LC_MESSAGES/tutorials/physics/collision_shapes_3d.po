#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (3D)"
msgstr "Форми зіткнення (3D)"

msgid "This guide explains:"
msgstr "Цей посібник пояснює:"

msgid "The types of collision shapes available in 3D in Godot."
msgstr "Типи фігур зіткнення, доступні в 3D у Godot."

msgid "Using a convex or a concave mesh as a collision shape."
msgstr "Використання опуклої або увігнутої сітки як форми зіткнення."

msgid "Performance considerations regarding 3D collisions."
msgstr "Зауваження продуктивності щодо тривимірних зіткнень."

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr ""
"Godot надає багато видів колізійних форм із різною продуктивністю та "
"точністю."

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody3D` by adding one or "
"more :ref:`CollisionShape3Ds <class_CollisionShape3D>` as *direct* child "
"nodes. Indirect child nodes (i.e. children of child nodes) will be ignored "
"and won't be used as collision shapes. Also, note that you must add "
"a :ref:`class_Shape3D` *resource* to collision shape nodes in the Inspector "
"dock."
msgstr ""
"Ви можете визначити форму :ref:`class_PhysicsBody3D`, додавши один або "
"кілька :ref:`CollisionShape3Ds <class_CollisionShape3D>` як *прямі* дочірні "
"вузли. Непрямі дочірні вузли (тобто діти дочірніх вузлів) ігноруватимуться "
"та не використовуватимуться як форми зіткнень. Також зауважте, що ви повинні "
"додати :ref:`class_Shape3D` *ресурс* до вузлів форми зіткнення в доці "
"Inspector."

msgid ""
"When you add multiple collision shapes to a single PhysicsBody, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"Коли ви додаєте кілька форм зіткнення до одного PhysicsBody, вам не потрібно "
"турбуватися про те, що вони накладаються. Вони не будуть «зіткнутися» один з "
"одним."

msgid "Primitive collision shapes"
msgstr "Примітивні форми зіткнення"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godot надає наступні типи примітивних форм зіткнення:"

msgid ":ref:`class_BoxShape3D`"
msgstr ":ref:`class_BoxShape3D`"

msgid ":ref:`class_SphereShape3D`"
msgstr ":ref:`class_SphereShape3D`"

msgid ":ref:`class_CapsuleShape3D`"
msgstr ":ref:`class_CapsuleShape3D`"

msgid ":ref:`class_CylinderShape3D`"
msgstr ":ref:`class_CylinderShape3D`"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"Ви можете представити зіткнення більшості менших об’єктів за допомогою "
"однієї або кількох простих форм. Однак для більш складних об'єктів, таких як "
"великий корабель або цілий рівень, вам можуть знадобитися опуклі або "
"увігнуті форми. Детальніше про це нижче."

msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"Ми рекомендуємо віддавати перевагу примітивним формам для динамічних "
"об’єктів, таких як RigidBodies і CharacterBodies, оскільки їх поведінка є "
"найбільш надійною. Вони також часто забезпечують кращу продуктивність."

msgid "Convex collision shapes"
msgstr "Опуклі форми зіткнення"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape3D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
":ref:`Convex collision shapes <class_ConvexPolygonShape3D>` є компромісом "
"між примітивними формами зіткнення та увігнутими формами зіткнення. Вони "
"можуть представляти фігури будь-якої складності, але з важливим "
"застереженням. Як випливає з назви, окрема фігура може представляти лише "
"*опуклу* форму. Наприклад, піраміда *опукла*, а порожниста коробка "
"*увігнута*. Щоб визначити увігнутий об’єкт з єдиною формою зіткнення, "
"потрібно використовувати увігнуту форму зіткнення."

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"Залежно від складності об’єкта, ви можете отримати кращу продуктивність, "
"використовуючи кілька опуклих форм замість увігнутої форми зіткнення. Godot "
"дозволяє використовувати *опукле розкладання* для створення опуклих форм, "
"які приблизно відповідають порожнистому об’єкту. Зауважте, що ця перевага "
"продуктивності більше не застосовується після певної кількості опуклих форм. "
"Для великих і складних об’єктів, таких як цілий рівень, ми рекомендуємо "
"замість цього використовувати увігнуті форми."

msgid ""
"You can generate one or several convex collision shapes from the editor by "
"selecting a MeshInstance3D and using the **Mesh** menu at the top of the 3D "
"viewport. The editor exposes two generation modes:"
msgstr ""
"Ви можете створити одну або кілька опуклих форм зіткнення з редактора, "
"вибравши MeshInstance3D і скориставшись меню **Mesh** у верхній частині "
"вікна тривимірного перегляду. Редактор пропонує два режими генерації:"

msgid ""
"**Create Single Convex Collision Sibling** uses the Quickhull algorithm. It "
"creates one CollisionShape node with an automatically generated convex "
"collision shape. Since it only generates a single shape, it provides good "
"performance and is ideal for small objects."
msgstr ""
"**Створення єдиного опуклого зіткнення-брата** використовує алгоритм "
"Quickhull. Він створює один вузол CollisionShape із автоматично згенерованою "
"опуклою формою зіткнення. Оскільки він створює лише одну форму, він "
"забезпечує хорошу продуктивність і ідеально підходить для невеликих об’єктів."

msgid ""
"**Create Multiple Convex Collision Siblings** uses the V-HACD algorithm. It "
"creates several CollisionShape nodes, each with a convex shape. Since it "
"generates multiple shapes, it is more accurate for concave objects at the "
"cost of performance. For objects with medium complexity, it will likely be "
"faster than using a single concave collision shape."
msgstr ""
"**Створити кілька опуклих братів і сестер** використовує алгоритм V-HACD. "
"Він створює кілька вузлів CollisionShape, кожен з яких має опуклу форму. "
"Оскільки він генерує кілька форм, він більш точний для увігнутих об’єктів за "
"рахунок продуктивності. Для об’єктів середньої складності це, швидше за все, "
"буде швидше, ніж використання однієї увігнутої форми зіткнення."

msgid "Concave or trimesh collision shapes"
msgstr "Увігнуті або трійчасті форми зіткнення"

msgid ""
":ref:`Concave collision shapes <class_ConcavePolygonShape3D>`, also called "
"trimesh collision shapes, can take any form, from a few triangles to "
"thousands of triangles. Concave shapes are the slowest option but are also "
"the most accurate in Godot. **You can only use concave shapes within "
"StaticBodies.** They will not work with CharacterBodies or RigidBodies "
"unless the RigidBody's mode is Static."
msgstr ""
":ref:`Concave collision shapes <class_ConcavePolygonShape3D>`, які також "
"називають трисітковими фігурами зіткнень, можуть мати будь-яку форму, від "
"кількох трикутників до тисяч трикутників. Увігнуті форми є найповільнішим "
"варіантом, але також найточнішим у Godot. **Ви можете використовувати лише "
"увігнуті фігури в StaticBodies.** Вони не працюватимуть із CharacterBodies "
"або RigidBodies, якщо для RigidBody не встановлено режим Static."

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr ""
"Незважаючи на те, що увігнуті форми забезпечують найточнішу *колізію*, звіти "
"про контакти можуть бути менш точними, ніж примітивні форми."

msgid ""
"When not using GridMaps for level design, concave shapes are the best "
"approach for a level's collision. That said, if your level has small "
"details, you may want to exclude those from collision for performance and "
"game feel. To do so, you can build a simplified collision mesh in a 3D "
"modeler and have Godot generate a collision shape for it automatically. More "
"on that below"
msgstr ""
"Якщо не використовувати GridMaps для проектування рівнів, увігнуті форми є "
"найкращим підходом для зіткнення рівнів. Тим не менш, якщо ваш рівень має "
"дрібні деталі, ви можете виключити їх із зіткнення для продуктивності та "
"відчуття гри. Для цього ви можете побудувати спрощену сітку зіткнень у "
"програмі 3D-моделювання, а Godot згенерувати для неї форму зіткнень "
"автоматично. Детальніше про це нижче"

msgid ""
"Note that unlike primitive and convex shapes, a concave collision shape "
"doesn't have an actual \"volume\". You can place objects both *outside* of "
"the shape as well as *inside*."
msgstr ""
"Зауважте, що на відміну від примітивних і опуклих форм, увігнута форма "
"зіткнення не має фактичного «об’єму». Ви можете розміщувати об’єкти як "
"*зовні* фігури, так і *всередині*."

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"MeshInstance3D and using the **Mesh** menu at the top of the 3D viewport. "
"The editor exposes two options:"
msgstr ""
"Ви можете створити увігнуту форму зіткнення з редактора, вибравши "
"MeshInstance3D і скориставшись меню **Mesh** у верхній частині тривимірного "
"вікна перегляду. Редактор пропонує два варіанти:"

msgid ""
"**Create Trimesh Static Body** is a convenient option. It creates a "
"StaticBody containing a concave shape matching the mesh's geometry."
msgstr ""
"**Створити статичне тіло Trimesh** є зручним варіантом. Він створює "
"StaticBody, що містить увігнуту форму, що відповідає геометрії сітки."

msgid ""
"**Create Trimesh Collision Sibling** creates a CollisionShape node with a "
"concave shape matching the mesh's geometry."
msgstr ""
"**Create Trimesh Collision Sibling** створює вузол CollisionShape із "
"увігнутою формою, яка відповідає геометрії сітки."

msgid ""
"See :ref:`doc_importing_3d_scenes` for information on how to export models "
"for Godot and automatically generate collision shapes on import."
msgstr ""
"Перегляньте :ref:`doc_importing_3d_scenes` інформацію про те, як "
"експортувати моделі для Godot і автоматично генерувати форми зіткнень під "
"час імпорту."

msgid "Performance caveats"
msgstr "Застереження щодо продуктивності"

msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"Ви не обмежені однією формою зіткнення на PhysicsBody. Тим не менш, ми "
"рекомендуємо зберігати якомога меншу кількість форм, щоб покращити "
"продуктивність, особливо для динамічних об’єктів, таких як RigidBodies і "
"CharacterBodies. Крім того, уникайте перекладу, обертання або масштабування "
"CollisionShapes, щоб скористатися перевагами внутрішньої оптимізації "
"фізичного механізму."

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"У разі використання однієї нетрансформованої форми зіткнення в StaticBody "
"алгоритм *широкої фази* двигуна може відкидати неактивні PhysicsBodies. Тоді "
"*вузька фаза* повинна буде враховувати лише форми активних тіл. Якщо "
"StaticBody має багато форм зіткнення, широка фаза не вдасться. Вузька фаза, "
"яка є повільнішою, повинна виконати перевірку на зіткнення з кожною формою."

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"Якщо у вас виникли проблеми з продуктивністю, вам, можливо, доведеться піти "
"на компроміси щодо точності. Більшість ігор не мають 100% точного зіткнення. "
"Вони знаходять творчі способи приховати це або іншим чином зробити "
"непомітним під час звичайної гри."
