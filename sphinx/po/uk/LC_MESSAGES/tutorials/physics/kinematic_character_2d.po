#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "Кінематичний персонаж (2D)"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"Так, назва звучить дивно. «Кінематичний характер». Що це? Причина такої "
"назви полягає в тому, що коли з’явилися фізичні двигуни, їх називали "
"двигунами «Динамічні» (оскільки вони стосувалися в основному реакції на "
"зіткнення). Було зроблено багато спроб створити контролер персонажа за "
"допомогою динамічних двигунів, але це було не так просто, як здавалося. "
"Godot має одну з найкращих реалізацій динамічного контролера персонажів, яку "
"тільки можна знайти (як це можна побачити в демонстрації 2d/платформера), "
"але його використання вимагає значного рівня навичок і розуміння фізичних "
"движків (або багато терпіння під час випробувань). і помилка)."

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"Деякі фізичні движки, такі як Havok, здається, вважають найкращим варіантом "
"динамічні контролери символів, тоді як інші (PhysX) радше просувають "
"кінематичні."

msgid "So, what is the difference?:"
msgstr "Отже, в чому різниця?:"

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**Динамічний контролер символів** використовує тверде тіло з нескінченним "
"тензором інерції. Це тверде тіло, яке не може обертатися. Фізичні механізми "
"завжди дозволяють об’єктам рухатися та стикатися, а потім разом вирішують їх "
"зіткнення. Це дозволяє динамічним контролерам персонажів безперебійно "
"взаємодіяти з іншими фізичними об’єктами, як видно з демонстрації "
"платформера. Однак ці взаємодії не завжди передбачувані. Для розв’язання "
"зіткнень може знадобитися більше одного кадру, тому може здатися, що кілька "
"зіткнень дещо зміщуються. Ці проблеми можна вирішити, але вимагають певних "
"навичок."

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"Передбачається, що **контролер кінематичних символів** завжди починається в "
"стані без зіткнень і завжди переходитиме до стану без зіткнень. Якщо він "
"починає зіткнутися, він намагатиметься звільнитися, як це роблять тверді "
"тіла, але це виняток, а не правило. Це робить їхній контроль і рух набагато "
"більш передбачуваним і легшим для програмування. Однак недоліком є те, що "
"вони не можуть безпосередньо взаємодіяти з іншими фізичними об’єктами, якщо "
"тільки це не зроблено вручну в коді."

msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"Цей короткий підручник зосереджений на контролері кінематичних символів. Він "
"використовує старий спосіб обробки зіткнень, який не обов’язково простіший "
"під капотом, але добре прихований і представлений як API."

msgid "Physics process"
msgstr "Фізика процесу"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"Щоб керувати логікою кінематичного тіла або персонажа, завжди рекомендується "
"використовувати фізичний процес, оскільки він викликається перед фізичним "
"кроком і його виконання синхронізовано з фізичним сервером, також він завжди "
"викликається однаково часто на секунду. Завдяки цьому обчислення фізики та "
"руху працюють більш передбачувано, ніж використання звичайного процесу, який "
"може мати стрибки або втрачати точність, якщо частота кадрів надто висока чи "
"занизька."

msgid "Scene setup"
msgstr "Налаштування сцени"

msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"Щоб було що перевірити, ось сцена (з підручника з мапи плиток): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. Ми створимо нову сцену для персонажа. "
"Використовуйте спрайт робота та створіть таку сцену:"

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"Ви помітите, що біля нашого вузла CollisionShape2D є значок попередження; це "
"тому, що ми не визначили для нього форму. Створіть новий CircleShape2D у "
"властивості форми CollisionShape2D. Клацніть на <CircleShape2D>, щоб перейти "
"до його параметрів, і встановіть радіус 30:"

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**Примітка: як згадувалося раніше в підручнику з фізики, фізичний механізм "
"не може обробляти масштаб більшості типів фігур (працюють лише багатокутники "
"зіткнення, площини та сегменти), тому натомість завжди змінюйте параметри "
"(такі як радіус) фігури його масштабування. Те саме стосується самих "
"кінематичних/твердих/статичних тіл, оскільки їхній масштаб впливає на "
"масштаб форми.**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr ""
"Тепер створіть сценарій для персонажа, той, що використовується як приклад "
"вище, повинен працювати як основа."

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"Нарешті, створіть екземпляр цієї сцени персонажа на карті плиток і зробіть "
"сцену карти основною, щоб вона запускалася під час натискання кнопки "
"відтворення."

msgid "Moving the kinematic character"
msgstr "Переміщення кінематичного характеру"

msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes a :ref:"
"`Vector2 <class_Vector2>` as an argument, and tries to apply that motion to "
"the kinematic body. If a collision happens, it stops right at the moment of "
"the collision."
msgstr ""
"Поверніться до сцени персонажа та відкрийте сценарій, магія починається "
"зараз! Кінематичне тіло нічого не робитиме за замовчуванням, але воно має "
"корисну функцію під назвою ``CharacterBody2D.move_and_collide()``. Ця "
"функція приймає :ref:`Vector2 <class_Vector2>` як аргумент і намагається "
"застосувати цей рух до кінематичного тіла. Якщо відбувається зіткнення, він "
"зупиняється в момент зіткнення."

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr ""
"Отже, давайте перемістимо наш спрайт вниз, поки він не впаде на підлогу:"

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr ""
"У результаті персонаж рухатиметься, але зупинятиметься одразу після удару об "
"підлогу. Дуже круто, га?"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr ""
"Наступним кроком буде додавання тяжіння суміші, таким чином вона поводиться "
"трохи більше, як звичайний ігровий персонаж:"

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"Тепер персонаж плавно падає. Давайте змусимо його ходити в сторони, ліворуч "
"і праворуч, торкаючись клавіш направлення. Пам’ятайте, що використовуються "
"значення (принаймні для швидкості) – це пікселі на секунду."

msgid "This adds basic support for walking when pressing left and right:"
msgstr ""
"Це додає базову підтримку для ходьби при натисканні ліворуч і праворуч:"

msgid "And give it a try."
msgstr "І спробуйте."

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://github."
"com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character."
msgstr ""
"Це хороша відправна точка для платформера. Більш повну демонстрацію можна "
"знайти в демо-архіві zip, що розповсюджується разом із механізмом, або на "
"https://github.com/godotengine/godot-demo-projects/tree/master/2d/"
"kinematic_character."
