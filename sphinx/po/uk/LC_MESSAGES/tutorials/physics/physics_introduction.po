#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "Вступ до курсу фізики"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"При розробці ігор часто потрібно знати, коли два об'єкти в грі перетинаються "
"або контактують. Це називається **виявленням зіткнень**. Коли виявлено "
"зіткнення, ви зазвичай хочете, щоб щось сталося. Це називається **реакція на "
"зіткнення**."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot пропонує низку об'єктів зіткнень у 2D та 3D, щоб забезпечити як "
"виявлення зіткнень, так і реакцію на них. Спроба вирішити, який з них "
"використовувати для вашого проекту, може бути заплутаною. Ви можете уникнути "
"проблем і спростити розробку, якщо зрозумієте, як працює кожен з них і які "
"їхні переваги та недоліки."

msgid "In this guide, you will learn:"
msgstr "У цьому посібнику ви дізнаєтесь:"

msgid "Godot's four collision object types"
msgstr "Чотири типи об'єктів зіткнення Godot"

msgid "How each collision object works"
msgstr "Як працює кожен об'єкт колізії"

msgid "When and why to choose one type over another"
msgstr "Коли і чому варто обирати один тип замість іншого"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"У прикладах цього документу використовуються 2D-об'єкти. Кожен 2D-фізичний "
"об'єкт і форма зіткнення має прямий еквівалент у 3D, і в більшості випадків "
"вони працюють майже так само."

msgid "Collision objects"
msgstr "Об'єкти зіткнення"

msgid ""
"Godot offers four kinds of collision objects which all "
"extend :ref:`CollisionObject2D <class_CollisionObject2D>`. The last three "
"listed below are physics bodies and additionally extend :ref:`PhysicsBody2D "
"<class_PhysicsBody2D>`."
msgstr ""
"Godot пропонує чотири типи об'єктів зіткнення, які "
"розширюють :ref:`CollisionObject2D <class_CollisionObject2D>`. Останні три, "
"перелічені нижче, є фізичними тілами і додатково "
"розширюють :ref:`PhysicsBody2D <class_PhysicsBody2D>`."

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"Вузли ``Area2D`` забезпечують **виявлення** та **вплив**. Вони можуть "
"виявляти, коли об'єкти накладаються один на одного, і можуть випромінювати "
"сигнали, коли тіла входять або виходять. Вузол ``Area2D`` також можна "
"використовувати для перевизначення фізичних властивостей, таких як "
"гравітація або демпфування, у визначеній області."

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ":ref:`StaticBody2D <class_StaticBody2D>`"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"Статичне тіло – це тіло, яке не переміщується фізичним двигуном. Він бере "
"участь у виявленні зіткнення, але не рухається у відповідь на зіткнення. "
"Найчастіше вони використовуються для об’єктів, які є частиною середовища або "
"яким не потрібна динамічна поведінка."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>`"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting "
"movement. :ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"Це вузол, який реалізує змодельовану 2D фізику. Ви не керуєте "
"``RigidBody2D`` напряму, натомість ви застосовуєте до нього сили "
"(гравітація, імпульси тощо), і фізичний механізм обчислює результуючий "
"рух. :ref:`Read more about using rigid bodies. <doc_rigid_body>`"

msgid ":ref:`CharacterBody2D <class_CharacterBody2D>`"
msgstr ":ref:`CharacterBody2D <class_CharacterBody2D>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"Тіло, яке забезпечує виявлення зіткнень, але не має фізики. Усі реакції на "
"рух і зіткнення мають бути реалізовані в коді."

msgid "Physics material"
msgstr "Матеріал з фізики"

msgid ""
"Static bodies and rigid bodies can be configured to use "
"a :ref:`PhysicsMaterial <class_PhysicsMaterial>`. This allows adjusting the "
"friction and bounce of an object, and set if it's absorbent and/or rough."
msgstr ""
"Статичні тіла та тверді тіла можна налаштувати на "
"використання :ref:`PhysicsMaterial <class_PhysicsMaterial>`. Це дозволяє "
"регулювати тертя та відскок об’єкта, а також встановлювати, чи він "
"абсорбуючий та/або грубий."

msgid "Collision shapes"
msgstr "Форми зіткнень"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"Фізичне тіло може містити будь-яку кількість об’єктів :ref:`Shape2D "
"<class_Shape2D>` як дітей. Ці форми використовуються для визначення меж "
"зіткнення об’єкта та виявлення контакту з іншими об’єктами."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr ""
"Щоб виявити зіткнення, принаймні один ``Shape2D`` має бути призначений "
"об’єкту."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"Найпоширенішим способом призначення форми є додавання :ref:`CollisionShape2D "
"<class_CollisionShape2D>` або :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` як дочірнього об’єкта. Ці вузли дозволяють "
"малювати фігуру безпосередньо в робочій області редактора."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"Будьте обережні, щоб ніколи не масштабувати форми зіткнень у редакторі. "
"Властивість «Масштаб» в інспекторі має залишатися ``(1, 1)``. Змінюючи "
"розмір форми зіткнення, ви завжди повинні використовувати маркери розміру, "
"**не** маркери масштабу ``Node2D``. Масштабування фігури може призвести до "
"неочікуваної поведінки зіткнення."

msgid "Physics process callback"
msgstr "Зворотний виклик фізичного процесу"

msgid ""
"The physics engine runs at a fixed rate (a default of 60 iterations per "
"second). This rate is typically different from the frame rate which "
"fluctuates based on what is rendered and available resources."
msgstr ""
"Фізична система працює з фіксованою частотою (за замовчуванням 60 ітерацій "
"на секунду). Ця частота зазвичай відрізняється від частоти кадрів, яка "
"коливається залежно від того, що відтворюється, і доступних ресурсів."

msgid ""
"It is important that all physics related code runs at this fixed rate. "
"Therefore Godot differentiates :ref:`between physics and idle processing "
"<doc_idle_and_physics_processing>`. Code that runs each frame is called idle "
"processing and code that runs on each physics tick is called physics "
"processing. Godot provides two different callbacks, one for each of those "
"processing rates."
msgstr ""
"Важливо, щоб увесь код, пов'язаний з фізикою, виконувався з цією фіксованою "
"швидкістю. Тому Godot розрізняє :ref:`between physics and idle processing "
"<doc_idle_and_physics_processing>`. Код, який виконується кожен кадр, "
"називається холостою обробкою, а код, який виконується на кожному фізичному "
"тику, називається фізичною обробкою. Godot надає два різних способи "
"зворотного виклику, по одному для кожної з цих швидкостей обробки."

msgid ""
"The physics callback, :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`, is called before each physics "
"step. Any code that needs to access a body's properties should be run in "
"here. This method will be passed a ``delta`` parameter, which is a floating-"
"point number equal to the time passed in *seconds* since the last step. When "
"using the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"Зворотний виклик :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>` викликається перед кожним "
"кроком фізики. Тут слід запускати будь-який код, який потребує доступу до "
"властивостей тіла. Цьому методу буде передано параметр ``delta``, який є "
"числом з плаваючою комою, що дорівнює часу, який минув у *секундах* з "
"моменту останнього кроку. Якщо використовується стандартна частота оновлення "
"фізики 60 Гц, вона зазвичай дорівнюватиме ``0,01666...`` (але не завжди, "
"див. нижче)."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"Рекомендується завжди використовувати параметр ``дельта``, коли це необхідно "
"для ваших фізичних розрахунків, щоб гра поводилася правильно, якщо ви "
"змінюєте швидкість оновлення фізики або якщо пристрій гравця не може "
"встигати."

msgid "Collision layers and masks"
msgstr "Шари та маски зіткнення"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 32 different physics layers it "
"can interact with."
msgstr ""
"Однією з найпотужніших, але часто неправильно зрозумілих функцій зіткнень є "
"система рівня зіткнень. Ця система дозволяє будувати складні взаємодії між "
"різноманітними об’єктами. Ключовими поняттями є **шари** та **маски**. Кожен "
"``CollisionObject2D`` має 32 різні фізичні рівні, з якими він може "
"взаємодіяти."

msgid "Let's look at each of the properties in turn:"
msgstr "Давайте по черзі розглянемо кожну з властивостей:"

msgid "collision_layer"
msgstr "Collision_layer"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"Це описує шари, **в** яких з’являється об’єкт. За замовчуванням усі тіла "
"знаходяться на шарі ``1``."

msgid "collision_mask"
msgstr "Collision_mask"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"Це описує, які шари тіло буде **сканувати** на предмет зіткнень. Якщо "
"об’єкта немає в одному з шарів маски, тіло його проігнорує. За замовчуванням "
"усі тіла сканують шар ``1``."

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr ""
"Ці властивості можна налаштувати за допомогою коду або редагуючи їх в "
"інспекторі."

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in **Project Settings > Layer Names > 2D Physics**."
msgstr ""
"Відстежувати, для чого ви використовуєте кожен шар, може бути важко, тому "
"вам може бути корисно призначити імена шарам, які ви використовуєте. Назви "
"можна призначити в меню **Налаштування проекту > Назви шарів > 2D Physics**."

msgid "GUI example"
msgstr "Приклад GUI"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"У вашій грі є чотири типи вузлів: стіни, гравець, ворог і монета. І гравець, "
"і ворог повинні стикатися зі стінами. Вузол Player повинен виявляти "
"зіткнення як з Enemy, так і з Coin, але Enemy і Coin повинні ігнорувати один "
"одного."

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"Почніть із назви шарів 1–4 «стіни», «гравець», «вороги» та «монети» та "
"розмістіть кожен тип вузла у відповідному шарі за допомогою властивості "
"«Шар». Потім установіть для кожного вузла властивість «Маска», вибравши "
"шари, з якими він має взаємодіяти. Наприклад, параметри програвача "
"виглядатимуть так:"

msgid "Code example"
msgstr "Приклад коду"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0xffffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"У викликах функцій шари вказуються як бітова маска. Якщо функція вмикає всі "
"шари за замовчуванням, маску шару буде задано як ``0xffffffff``. Ваш код "
"може використовувати двійкову, шістнадцяткову чи десяткову систему запису "
"для масок шарів, залежно від ваших уподобань."

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows:"
msgstr ""
"Кодовий еквівалент наведеного вище прикладу, де були ввімкнені шари 1, 3 та "
"4, буде таким:"

msgid ""
"You can also set bits independently by calling "
"``set_collision_layer_value(layer_number, value)`` or "
"``set_collision_mask_value(layer_number, value)`` on any "
"given :ref:`CollisionObject2D <class_CollisionObject2D>` as follows:"
msgstr ""
"Ви також можете встановлювати біти незалежно, викликаючи "
"``set_collision_layer_value(layer_number, value)`` або "
"``set_collision_mask_value(layer_number, value)`` для будь-якого "
"заданого :ref:`CollisionObject2D <class_CollisionObject2D>` наступним чином:"

msgid ""
"Export annotations can be used to export bitmasks in the editor with a user-"
"friendly GUI:"
msgstr ""
"Експорт анотацій можна використовувати для експорту бітових масок у "
"редакторі за допомогою зручного графічного інтерфейсу:"

msgid ""
"Additional export annotations are available for render and navigation "
"layers, in both 2D and 3D. "
"See :ref:`doc_gdscript_exports_exporting_bit_flags`."
msgstr ""
"Додаткові експортні анотації доступні для шарів візуалізації та навігації як "
"у 2D, так і в 3D. "
"Перегляньте :ref:`doc_gdscript_exports_exporting_bit_flags`."

msgid "Area2D"
msgstr "Площа2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Вузли області забезпечують **виявлення** та **вплив**. Вони можуть виявляти, "
"коли об’єкти перекриваються, і видавати сигнали, коли тіла входять або "
"виходять. Області також можна використовувати для перевизначення фізичних "
"властивостей, таких як сила тяжіння або демпфування, у визначеній області."

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr "Є три основні способи використання :ref:`Area2D <class_Area2D>`:"

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr ""
"Перевизначення фізичних параметрів (наприклад, сили тяжіння) у певному "
"регіоні."

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr ""
"Виявлення того, коли інші тіла входять або виходять з регіону або які тіла "
"зараз знаходяться в регіоні."

msgid "Checking other areas for overlap."
msgstr "Перевірка інших областей на перекриття."

msgid "By default, areas also receive mouse and touchscreen input."
msgstr ""
"За замовчуванням області також отримують введення за допомогою миші та "
"сенсорного екрана."

msgid "StaticBody2D"
msgstr "Static Body2D"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"Статичне тіло – це тіло, яке не переміщується фізичним двигуном. Він бере "
"участь у виявленні зіткнення, але не рухається у відповідь на зіткнення. "
"Однак він може передавати рух або обертання тілу, що стикається, **так "
"ніби** воно рухається, використовуючи властивості "
"``constant_linear_velocity`` і ``constant_angular_velocity``."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"Вузли ``StaticBody2D`` найчастіше використовуються для об’єктів, які є "
"частиною середовища або яким не потрібна динамічна поведінка."

msgid "Example uses for ``StaticBody2D``:"
msgstr "Приклад використання для ``StaticBody2D``:"

msgid "Platforms (including moving platforms)"
msgstr "Платформи (включаючи рухомі платформи)"

msgid "Conveyor belts"
msgstr "Конвеєрні стрічки"

msgid "Walls and other obstacles"
msgstr "Стіни та інші перешкоди"

msgid "RigidBody2D"
msgstr "Rigid Body2D"

msgid ""
"This is the node that implements simulated 2D physics. You do not control "
"a :ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces "
"to it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"Це вузол, який реалізує змодельовану 2D фізику. Ви не "
"керуєте :ref:`RigidBody2D <class_RigidBody2D>` безпосередньо. Натомість ви "
"прикладаєте до нього силу, і фізичний механізм обчислює результуючий рух, "
"включаючи зіткнення з іншими тілами та реакції на зіткнення, такі як "
"підстрибування, обертання тощо."

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"Ви можете змінити поведінку твердого тіла за допомогою таких властивостей, "
"як «Маса», «Тертя» або «Відскок», які можна встановити в інспекторі."

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"**Project Settings > Physics**, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"На поведінку тіла також впливають властивості світу, встановлені в "
"**Налаштування проекту > Фізика** або введення :ref:`Area2D <class_Area2D>`, "
"яке перекриває глобальні фізичні властивості."

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"Коли тверде тіло знаходиться в стані спокою і деякий час не рухається, воно "
"засинає. Спляче тіло діє як статичне тіло, і його сили не розраховуються "
"фізичним механізмом. Тіло прокинеться під час застосування сил через "
"зіткнення або через код."

msgid "Using RigidBody2D"
msgstr "Використання RigidBody2D"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"Однією з переваг використання твердого тіла є те, що багато поведінки можна "
"отримати «безкоштовно» без написання коду. Наприклад, якщо ви робите гру в "
"стилі «Angry Birds» з падаючими блоками, вам потрібно буде лише створити "
"RigidBody2D і налаштувати їхні властивості. Укладання, падіння та "
"підстрибування автоматично обчислюватимуться фізичним механізмом."

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use "
"the :ref:`_integrate_forces() "
"<class_RigidBody2D_private_method__integrate_forces>` callback instead of "
"``_physics_process()``. In this callback, you have access to the "
"body's :ref:`PhysicsDirectBodyState2D <class_PhysicsDirectBodyState2D>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"Однак, якщо ви хочете мати певний контроль над тілом, вам слід бути "
"обережними: зміна ``position``, ``linear_velocity`` або інших фізичних "
"властивостей твердого тіла може призвести до неочікуваної поведінки. Якщо "
"вам потрібно змінити будь-яку властивість, пов’язану з фізикою, вам слід "
"використовувати зворотний виклик :ref:`_integrate_forces() "
"<class_RigidBody2D_private_method__integrate_forces>` замість "
"``_physics_process()``. У цьому зворотному виклику ви маєте доступ "
"до :ref:`PhysicsDirectBodyState2D <class_PhysicsDirectBodyState2D>` тіла, що "
"дозволяє безпечно змінювати властивості та синхронізувати їх із фізичною "
"системою."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "Наприклад, ось код космічного корабля в стилі \"Астероїди\":"

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"Зауважте, що ми не встановлюємо властивості linear_velocity або "
"``angular_velocity`` безпосередньо, а застосовуємо сили (``поштовх`` і "
"``крутний момент``) до тіла та дозволяємо фізичній системі обчислювати "
"результуючий рух."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling "
"the :ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be "
"aware that this can have a negative effect on performance."
msgstr ""
"Коли тверде тіло переходить у сплячий стан, функція ``_integrate_forces()`` "
"не викликається. Щоб перевизначити цю поведінку, вам потрібно буде "
"підтримувати тіло в стані неспання, створюючи зіткнення, застосовуючи до "
"нього силу або вимикаючи властивість :ref:`can_sleep "
"<class_RigidBody2D_property_can_sleep>`. Майте на увазі, що це може "
"негативно вплинути на продуктивність."

msgid "Contact reporting"
msgstr "Контактна звітність"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained "
"via :ref:`PhysicsDirectBodyState2D.get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` and related "
"functions."
msgstr ""
"За замовчуванням тверді тіла не відстежують контакти, оскільки для цього "
"може знадобитися величезний обсяг пам’яті, якщо в сцені багато тіл. Щоб "
"увімкнути звітування про контакти, установіть для "
"властивості :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` ненульове значення. "
"Потім контакти можна отримати за "
"допомогою :ref:`PhysicsDirectBodyState2D.get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` і пов’язаних "
"функцій."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. "
"See :ref:`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"Моніторинг контактів за допомогою сигналів можна ввімкнути за допомогою "
"властивості :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>`. Перегляньте :ref:`RigidBody2D "
"<class_RigidBody2D>` список доступних сигналів."

msgid "CharacterBody2D"
msgstr "CharacterBody2D"

msgid ""
":ref:`CharacterBody2D <class_CharacterBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a character body."
msgstr ""
":ref:`CharacterBody2D <class_CharacterBody2D>` тіла виявляють зіткнення з "
"іншими тілами, але на них не впливають такі фізичні властивості, як сила "
"тяжіння чи тертя. Натомість користувач має керувати ними за допомогою коду. "
"Фізичний механізм не рухатиме тіло персонажа."

msgid ""
"When moving a character body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"Під час переміщення тіла персонажа не слід безпосередньо встановлювати його "
"``положення``. Замість цього ви використовуєте методи ``move_and_collide()`` "
"або ``move_and_slide()``. Ці методи переміщують тіло по заданому вектору, і "
"воно миттєво зупиняється, якщо буде виявлено зіткнення з іншим тілом. Після "
"зіткнення тіла будь-яка реакція на зіткнення повинна бути закодована вручну."

msgid "Character collision response"
msgstr "Реакція на зіткнення символів"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"CharacterBody2D."
msgstr ""
"Після зіткнення ви можете захотіти, щоб тіло відскочило, ковзало вздовж "
"стіни або змінило властивості об’єкта, якого воно вдарило. Спосіб обробки "
"реакції на зіткнення залежить від методу, який ви використали для "
"переміщення CharacterBody2D."

msgid ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"
msgstr ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"

msgid ""
"When using ``move_and_collide()``, the function returns "
"a :ref:`KinematicCollision2D <class_KinematicCollision2D>` object, which "
"contains information about the collision and the colliding body. You can use "
"this information to determine the response."
msgstr ""
"Під час використання ``move_and_collide()`` функція повертає "
"об’єкт :ref:`KinematicCollision2D <class_KinematicCollision2D>`, який "
"містить інформацію про зіткнення та тіло, що стикається. Ви можете "
"використовувати цю інформацію для визначення відповіді."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr ""
"Наприклад, якщо ви хочете знайти точку в просторі, де відбулося зіткнення:"

msgid "Or to bounce off of the colliding object:"
msgstr "Або відскочити від предмета, що стикається:"

msgid ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"Ковзання є загальною реакцією на зіткнення; Уявіть собі гравця, який "
"рухається вздовж стін у грі «згори вниз» або бігає вгору та вниз по схилах у "
"платформері. Хоча цю відповідь можна закодувати самостійно після "
"використання ``move_and_collide()``, ``move_and_slide()`` надає зручний "
"спосіб реалізувати рух ковзання без написання коду."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``. This does "
"**not** apply to ``gravity`` as it is an acceleration and is time dependent, "
"and needs to be scaled by ``delta``."
msgstr ""
"``move_and_slide()`` автоматично включає часовий крок у свій розрахунок, "
"тому вам **не** слід множити вектор швидкості на ``дельту``. Це **не** "
"стосується ``гравітації``, оскільки це прискорення, залежить від часу та "
"потребує масштабування ``дельта``."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"Наприклад, використовуйте наступний код, щоб створити персонажа, який може "
"ходити по землі (включаючи схили) і стрибати, стоячи на землі:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"Перегляньте :ref:`doc_kinematic_character_2d` для отримання додаткової "
"інформації про використання ``move_and_slide()``, включаючи демонстраційний "
"проект із детальним кодом."
