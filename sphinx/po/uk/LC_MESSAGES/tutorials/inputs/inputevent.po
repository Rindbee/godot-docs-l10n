#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "Використання inputEvent"

msgid "What is it?"
msgstr "Що це таке?"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"Управління входом, як правило, складне, незалежно від ОС, або платформи. Щоб "
"трохи полегшити це, передбачений спеціальний вбудований тип Вхідних Подій :"
"ref:`InputEvent <class_InputEvent>`. Цей тип даних можна настроїти так, щоб "
"він містив кілька типів вхідних подій. Вхідні події проходять через рушій і "
"можуть бути отримані в декількох місцях, в залежності від мети."

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "Ось короткий приклад, закривання гри при натисканні клавіші Esc:"

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"Однак чистіше і зручніше використовувати надану функцію Карти Введення :ref:"
"`InputMap <class_InputMap>`, яка дозволяє визначати дії введення і "
"призначати їм різні клавіші. Таким чином, ви можете визначити кілька клавіш "
"для однієї дії (наприклад, клавішу виходу з клавіатури та кнопку пуску на "
"геймпаді). Потім ви зможете легше змінити ці призначення в параметрах "
"проекту, не оновлюючи код, і навіть створити функцію перепризначення клавіш, "
"щоб дозволити гравцям призначати зручні для них клавіші!"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"Карту вводу можна настроїти в розділі **Проект > Параметри проекту > Input "
"Map**, а потім використати ці дії, наприклад, так:"

msgid "How does it work?"
msgstr "Як усе це працює?"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"Кожна подія введення походить від користувача/гравця (хоча можна згенерувати "
"InputEvent і передати їх назад механізму, що корисно для жестів). "
"DisplayServer для кожної платформи читатиме події з операційної системи, а "
"потім передасть їх до кореня :ref:`Window <class_Window>`."

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
":ref:`Viewport <class_Viewport>` вікна робить досить багато речей з "
"отриманим введенням, у порядку:"

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"Якщо вікно перегляду вбудовує Windows, вікно перегляду намагається "
"інтерпретувати подію в якості диспетчера вікон (наприклад, для зміни розміру "
"або переміщення вікон)."

msgid ""
"Next if an embedded Window is focused, the event is sent to that Window and "
"processed in the Windows Viewport and afterwards treated as handled. If no "
"embedded Window is focused, the event is sent to the nodes of the current "
"viewport in the following order."
msgstr ""
"Далі, якщо у фокусі вбудоване вікно, подія надсилається до цього вікна та "
"обробляється у вікні перегляду Windows, а потім розглядається як оброблена. "
"Якщо жодне вбудоване вікно не знаходиться в фокусі, подія надсилається до "
"вузлів поточного вікна перегляду в такому порядку."

msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing with :ref:`Node."
"set_process_input() <class_Node_method_set_process_input>`). If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"По-перше, стандартна функція :ref:`Node._input() "
"<class_Node_private_method__input>` буде викликана в будь-якому вузлі, який "
"замінює її (і не вимкнув обробку вхідних даних за допомогою :ref:`Node."
"set_process_input() <class_Node_method_set_process_input>`). Якщо будь-яка "
"функція споживає подію, вона може викликати :ref:`Viewport."
"set_input_as_handled() <class_Viewport_method_set_input_as_handled>`, і "
"подія більше не поширюватиметься. Це гарантує, що ви можете фільтрувати всі "
"події, які вас цікавлять, навіть до графічного інтерфейсу користувача. Для "
"ігрового процесу :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` зазвичай краще підходить, "
"оскільки дозволяє графічному інтерфейсу користувача перехоплювати події."

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will call :ref:"
"`Control.accept_event() <class_Control_method_accept_event>` and the event "
"will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether a :ref:"
"`Control <class_Control>` is notified of mouse events via :ref:`Control."
"_gui_input() <class_Control_private_method__gui_input>` callback, and "
"whether these events are propagated further."
msgstr ""
"По-друге, він намагатиметься надіслати вхідні дані до графічного інтерфейсу "
"користувача та перевірити, чи може якийсь елемент керування отримати їх. "
"Якщо так, :ref:`Control <class_Control>` буде викликано через віртуальну "
"функцію :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` і буде видано сигнал «gui_input» "
"(цю функцію можна повторно реалізувати за допомогою сценарій шляхом "
"успадкування від нього). Якщо елемент керування хоче «спожити» подію, він "
"викличе :ref:`Control.accept_event() <class_Control_method_accept_event>`, і "
"подія більше не поширюватиметься. Використовуйте властивість :ref:`Control."
"mouse_filter <class_Control_property_mouse_filter>`, щоб контролювати, чи "
"сповіщати :ref:`Control <class_Control>` про події миші через :ref:`Control."
"_gui_input() <class_Control_private_method__gui_input>` зворотний виклик і "
"чи ці події поширюються далі."

msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only for :ref:"
"`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"Якщо досі ніхто не використовував подію, зворотній виклик :ref:`Node."
"_shortcut_input() <class_Node_private_method__shortcut_input>` буде "
"викликано, якщо перевизначено (і не вимкнено за допомогою :ref:`Node."
"set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). Це відбувається лише для :"
"ref:`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` і :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. Якщо будь-яка функція споживає подію, вона "
"може викликати :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, і подія більше не "
"поширюватиметься. Зворотний виклик швидкого введення ідеально підходить для "
"обробки подій, призначених як ярлики."

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is an :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"Якщо досі ніхто не використовував подію, зворотній виклик :ref:`Node."
"_unhandled_key_input() <class_Node_private_method__unhandled_key_input>` "
"буде викликано, якщо перевизначено (і не вимкнено за допомогою :ref:`Node."
"set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). Це відбувається, лише "
"якщо подією є :ref:`InputEventKey <class_InputEventKey>`. Якщо будь-яка "
"функція споживає подію, вона може викликати :ref:`Viewport."
"set_input_as_handled() <class_Viewport_method_set_input_as_handled>`, і "
"подія більше не поширюватиметься. Зворотний виклик необробленого введення "
"клавіш ідеально підходить для ключових подій."

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"Якщо досі ніхто не використовував подію, зворотній виклик :ref:`Node."
"_unhandled_input() <class_Node_private_method__unhandled_input>` буде "
"викликано, якщо перевизначено (і не вимкнено за допомогою :ref:`Node."
"set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). Якщо будь-яка функція "
"споживає подію, вона може викликати :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, і подія більше не "
"поширюватиметься. Необроблений зворотний виклик ідеально підходить для "
"повноекранних ігрових подій, тому вони не приймаються, коли графічний "
"інтерфейс активний."

msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled in :"
"ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"Якщо поки що ніхто не хотів події, а :ref:`Вибір об’єкта "
"<class_viewport_property_physics_object_picking>` увімкнено, подія "
"використовується для вибору об’єкта. Для кореневого вікна перегляду це також "
"можна ввімкнути в :ref:`Налаштуваннях проекту "
"<class_ProjectSettings_property_physics/common/enable_object_picking>`. У "
"випадку 3D-сцени, якщо :ref:`Camera3D <class_Camera3D>` призначено вікну "
"перегляду, буде спрямовано промінь у світ фізики (у напрямку променя від "
"клацання). Якщо цей промінь потрапляє на об’єкт, він викличе функцію :ref:"
"`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` у відповідному "
"фізичному об’єкті. У випадку 2D-сцени концептуально те саме відбувається з :"
"ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"При надсиланні подій до своїх дочірніх та нащадкових вузлів, видошукач буде "
"робити це, як показано на наступному рисунку, у зворотному порядку від "
"глибини до початку, починаючи з вузла у нижній частині дерева сцени, і "
"закінчуючи кореневим вузлом. З цього процесу виключаються вікна та підвікна."

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"Оскільки Viewports не надсилають події до інших :ref:`SubViewports "
"<class_SubViewport>`, потрібно використати один із наведених нижче методів:"

msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
"Використовуйте :ref:`SubViewportContainer <class_SubViewportContainer>`, "
"який автоматично надсилає події своєму дочірньому :ref:`SubViewports "
"<class_SubViewport>` після :ref:`Node._input() "
"<class_Node_private_method__input>` або :ref:`Control._gui_input () "
"<class_Control_private_method__gui_input>`."

msgid "Implement event propagation based on the individual requirements."
msgstr "Реалізація розповсюдження подій на основі індивідуальних вимог."

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"Відповідно до архітектури Godot, яка заснована на вузлах, це дозволяє "
"спеціалізованим дочірнім вузлам обробляти і споживати певні події, в той час "
"як їх предки, і в кінцевому підсумку корінь сцени, можуть забезпечити більш "
"узагальнену поведінку, якщо це необхідно."

msgid "Anatomy of an InputEvent"
msgstr "Анатомія InputEvent"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` - це просто базовий вбудований тип "
"вхідної події, він нічого не представляє і містить лише деяку основну "
"інформацію, таку як ідентифікатор події (який збільшується для кожної "
"події), індекс пристрою, тощо."

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr ""
"Існує кілька спеціалізованих типів InputEvent, описаних в таблиці нижче:"

msgid "Event"
msgstr "Подія"

msgid "Description"
msgstr "Опис"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "Порожня вхідна подія."

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "Містить код ключа та значення Unicode, а також модифікатори."

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr ""
"Містить інформацію про кліки мишкою, таку як клавіша, модифікатори тощо."

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr ""
"Містить інформацію про рух, наприклад відносне й абсолютне положення та "
"швидкість."

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "Містить інформацію про аналогову вісь Джойстика/Джойпада."

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "Містить інформацію про джойстик/джойпад."

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr ""
"Містить інформацію про натискання/відтискання кількох дотиків. (доступно "
"тільки на мобільних пристроях)"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr ""
"Містить відомості про переміщення кількох дотиків. (доступно тільки на "
"мобільних пристроях)"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "Містить позицію, фактор, а також модифікатори."

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr "Містить позицію, дельту, а також модифікатори."

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr ":ref:`InputEventMIDI <class_InputEventMIDI>`"

msgid "Contains MIDI-related information."
msgstr "Містить інформацію, пов'язану з MIDI."

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr ":ref:`InputEventShortcut <class_InputEventShortcut>`"

msgid "Contains a shortcut."
msgstr "Містить ярлик."

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr ""
"Містить загальну дію. Ці події часто генеруються програмістом як зворотний "
"зв'язок. (Докладніше про це нижче)"

msgid "This allows for:"
msgstr "Це дозволяє:"

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"Один і той же код для роботи на різних пристроях з різними входами "
"(наприклад, клавіатура на ПК, Joypad на консолі)."

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr ""
"Дії можна створити в меню «Налаштування проекту» на вкладці **Карта вхідних "
"даних** і призначити вхідні події."

msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent "
"<class_InputEvent>`."
msgstr ""
"Будь-яка подія має методи :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` та :ref:`InputEvent "
"<class_InputEvent>`."

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"Крім того, може знадобитися надати грі дію з коду гри (хорошим прикладом "
"цього є виявлення жестів). Синглтон Input має для цього метод: :ref:`Input."
"parse_input_event() <class_input_method_parse_input_event>`. Зазвичай ви "
"використовуєте його так:"

msgid "InputMap"
msgstr "InputMap (карта введення)"
