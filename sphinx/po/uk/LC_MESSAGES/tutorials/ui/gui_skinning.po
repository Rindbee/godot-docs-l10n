#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to GUI skinning"
msgstr "Вступ до графічного інтерфейсу користувача"

msgid ""
"It is essential for a game to provide clear, informative, and yet visually "
"pleasing user interface to its players. While :ref:`Control <class_Control>` "
"nodes come with a decently functional look out of the box, there is always "
"room for uniqueness and case-specific tuning. For this purpose Godot engine "
"includes a system for GUI skinning (or theming), which allows you to "
"customize the look of every control in your user interface, including your "
"custom controls."
msgstr ""
"Важливо, щоб гра надавала гравцям зрозумілий, інформативний, але візуально "
"приємний інтерфейс користувача. Хоча вузли :ref:`Control <class_Control>` "
"мають пристойно функціональний вигляд із коробки, завжди є місце для "
"унікальності та індивідуального налаштування. Для цього движок Godot містить "
"систему для оформлення графічного інтерфейсу (або створення тем), яка "
"дозволяє вам налаштувати вигляд кожного елемента керування у вашому "
"інтерфейсі користувача, включно з вашими власними елементами керування."

msgid ""
"Here is an example of this system in action — a game with the GUI that is "
"radically different from the default UI theme of the engine:"
msgstr ""
"Ось приклад цієї системи в дії — гра з графічним інтерфейсом користувача, "
"який радикально відрізняється від стандартної теми інтерфейсу користувача "
"движка:"

msgid "A \"Gear Up!\" screen in Tank Kings, courtesy of Winterpixel Games"
msgstr "A \"Gear Up!\" екран у Tank Kings, люб’язно наданий Winterpixel Games"

msgid ""
"Beyond achieving a unique look for your game, this system also enables "
"developers to provide customization options to the end users, including "
"accessibility settings. UI themes are applied in a cascading manner (i.e. "
"they propagate from parent controls to their children), which means that "
"font settings or adjustments for colorblind users can be applied in a single "
"place and affect the entire UI tree. Of course this system can also be used "
"for gameplay purposes: your hero-based game can change its style for the "
"selected player character, or you can give different flavors to the sides in "
"your team-based project."
msgstr ""
"Окрім досягнення унікального вигляду вашої гри, ця система також дозволяє "
"розробникам надавати параметри налаштування для кінцевих користувачів, "
"зокрема налаштування доступності. Теми інтерфейсу користувача застосовуються "
"каскадним способом (тобто вони поширюються від батьківських елементів "
"керування до дочірніх), що означає, що параметри шрифту або налаштування для "
"користувачів із дальтоніком можна застосувати в одному місці та вплинути на "
"все дерево інтерфейсу користувача. Звичайно, цю систему також можна "
"використовувати для геймплея: ваша гра, заснована на героях, може змінити "
"свій стиль для вибраного персонажа гравця, або ви можете надати сторонам "
"різні відтінки у своєму командному проекті."

msgid "Basics of themes"
msgstr "Основи тем"

msgid ""
"The skinning system is driven by the :ref:`Theme <class_Theme>` resource. "
"Every Godot project has an inherent default theme that contains the settings "
"used by the built-in control nodes. This is what gives the controls their "
"distinct look out of the box. A theme only describes the configuration, "
"however, and it is still the job of each individual control to use that "
"configuration in the way it requires to display itself. This is important to "
"remember when implementing :ref:`your own custom controls "
"<doc_custom_gui_controls>`."
msgstr ""
"Система створення скінів керується ресурсом :ref:`Theme <class_Theme>`. "
"Кожен проект Godot має власну тему за замовчуванням, яка містить "
"налаштування, що використовуються вбудованими вузлами керування. Це те, що "
"надає елементам керування виразний вигляд із коробки. Однак тема лише описує "
"конфігурацію, і завданням кожного окремого елемента керування є використання "
"цієї конфігурації так, як вона вимагає для відображення. Це важливо "
"пам’ятати під час впровадження :ref:`ваших власних елементів керування "
"<doc_custom_gui_controls>`."

msgid ""
"Even the Godot editor itself relies on the default theme. But it doesn't "
"look the same as a Godot project, because it applies its own heavily "
"customized theme on top of the default one. In principle, this works exactly "
"like it would in your game as explained :ref:`below "
"<doc_gui_theme_in_project>`."
msgstr ""
"Навіть сам редактор Godot покладається на тему за замовчуванням. Але він "
"виглядає не так, як проект Godot, оскільки він застосовує власну сильно "
"налаштовану тему поверх стандартної. В принципі, це працює так само, як і у "
"вашій грі, як описано :ref:`нижче <doc_gui_theme_in_project>`."

msgid "Theme items"
msgstr "Тематичні предмети"

msgid ""
"The configuration that is stored in a theme consists of theme items. Each "
"item has a unique name and must be one of the following data types:"
msgstr ""
"Конфігурація, яка зберігається в темі, складається з елементів теми. Кожен "
"елемент має унікальне ім’я та має бути одного з таких типів даних:"

msgid "**Color**"
msgstr "**Color**"

msgid ""
"A :ref:`color <class_Color>` value, which is often used for fonts and "
"backgrounds. Colors can also be used for modulation of controls and icons."
msgstr ""
"Значення :ref:`color <class_Color>`, яке часто використовується для шрифтів "
"і фону. Кольори також можна використовувати для модуляції елементів "
"керування та значків."

msgid "**Constant**"
msgstr "**constant**"

msgid ""
"An integer value, which can be used either for numeric properties of "
"controls (such as the item separation in a :ref:`BoxContainer "
"<class_BoxContainer>`), or for boolean flags (such as the drawing of "
"relationship lines in a :ref:`Tree <class_Tree>`)."
msgstr ""
"Ціле значення, яке можна використовувати або для числових властивостей "
"елементів керування (наприклад, розділення елементів у :ref:`BoxContainer "
"<class_BoxContainer>`), або для логічних прапорів (таких як малювання ліній "
"зв’язку в :ref:`Tree <class_Tree>`)."

msgid "**Font**"
msgstr "**Шрифт**"

msgid ""
"A :ref:`font <class_Font>` resource, which is used by controls that display "
"text. Fonts contain most text rendering settings, except for its size and "
"color. On top of that, alignment and text direction are controlled by "
"individual controls."
msgstr ""
"Ресурс :ref:`font <class_Font>`, який використовується елементами керування, "
"які відображають текст. Шрифти містять більшість параметрів відтворення "
"тексту, за винятком його розміру та кольору. Крім того, вирівнювання та "
"напрямок тексту контролюються окремими елементами керування."

msgid "**Font size**"
msgstr "**font size**"

msgid ""
"An integer value, which is used alongside a font to determine the size at "
"which the text should be displayed."
msgstr ""
"Ціле число, яке використовується разом із шрифтом для визначення розміру "
"тексту, який має відображатися."

msgid "**Icon**"
msgstr "**Icon**"

msgid ""
"A :ref:`texture <class_Texture2D>` resource, which is normally used to "
"display an icon (on a :ref:`Button <class_Button>`, for example)."
msgstr ""
"Ресурс :ref:`texture <class_Texture2D>`, який зазвичай використовується для "
"відображення значка (наприклад, на :ref:`Button <class_Button>`)."

msgid "**StyleBox**"
msgstr "**styleBox**"

msgid ""
"A :ref:`StyleBox <class_StyleBox>` resource, a collection of configuration "
"options which define the way a UI panel should be displayed. This is not "
"limited to the :ref:`Panel <class_Panel>` control, as styleboxes are used by "
"many controls for their backgrounds and overlays."
msgstr ""
"Ресурс :ref:`StyleBox <class_StyleBox>`, набір параметрів конфігурації, які "
"визначають спосіб відображення панелі інтерфейсу. Це не обмежується "
"елементом керування :ref:`Panel <class_Panel>`, оскільки поля стилів "
"використовуються багатьма елементами керування для фону та накладень."

msgid "Theme types"
msgstr "Типи тем"

msgid ""
"To help with the organization of its items each theme is separated into "
"types, and each item must belong to a single type. In other words, each "
"theme item is defined by its name, its data type and its theme type. This "
"combination must be unique within the theme. For example, there cannot be "
"two color items named ``font_color`` in a type called ``Label``, but there "
"can be another ``font_color`` item in a type ``LineEdit``."
msgstr ""
"Щоб допомогти з організацією елементів, кожну тему розділено на типи, і "
"кожен елемент має належати до одного типу. Іншими словами, кожен елемент "
"теми визначається своїм іменем, типом даних і типом теми. Ця комбінація має "
"бути унікальною в межах теми. Наприклад, не може бути двох елементів кольору "
"з назвою ``font_color`` у типі під назвою ``Label``, але може бути інший "
"``font_color`` елемент у типі ``LineEdit``."

msgid ""
"The default Godot theme comes with multiple theme types already defined, one "
"for every built-in control node that uses UI skinning. The example above "
"contains actual theme items present in the default theme. You can refer to "
"the **Theme Properties** section in the class reference for each control to "
"see which items are available to it and its child classes."
msgstr ""
"Тема Godot за замовчуванням постачається з декількома вже визначеними типами "
"тем, по одному для кожного вбудованого вузла керування, який використовує "
"оболонку інтерфейсу користувача. Наведений вище приклад містить фактичні "
"елементи теми, присутні в темі за замовчуванням. Ви можете звернутися до "
"розділу **Властивості теми** в довідці про клас для кожного елемента "
"керування, щоб побачити, які елементи доступні для нього та його дочірніх "
"класів."

msgid ""
"Child classes can use theme items defined for their parent class (``Button`` "
"and its derivatives being a good example of that). In fact, every control "
"can use every theme item of any theme type, if it needs to (but for the "
"clarity and predictability we try to avoid that in the engine)."
msgstr ""
"Дочірні класи можуть використовувати елементи теми, визначені для їх "
"батьківського класу (``Button`` та його похідні є гарним прикладом цього). "
"Фактично, кожен елемент керування може використовувати кожен елемент теми "
"будь-якого типу теми, якщо це необхідно (але для ясності та передбачуваності "
"ми намагаємося уникати цього в движку)."

msgid ""
"It is important to remember that for child classes that process is "
"automated. Whenever a built-in control requests a theme item from the theme "
"it can omit the theme type, and its class name will be used instead. On top "
"of that, the class names of its parent classes will also be used in turn. "
"This allows changes to the parent class, such as ``Button``, to affect all "
"derived classes without the need to customize every one of them."
msgstr ""
"Важливо пам'ятати, що для дитячих класів цей процес автоматизований. Кожного "
"разу, коли вбудований елемент керування запитує елемент теми з теми, він "
"може пропустити тип теми, а замість цього буде використано назву її класу. "
"Крім того, імена класів батьківських класів також будуть використовуватися "
"по черзі. Це дозволяє змінам батьківського класу, наприклад ``Button``, "
"впливати на всі похідні класи без необхідності налаштовувати кожен з них."

msgid ""
"You can also define your own theme types, and additionally customize both "
"built-in controls and your own controls. Because built-in controls have no "
"knowledge of your custom theme types, you must utilize scripts to access "
"those items. All control nodes have several methods that allow to fetch "
"theme items from the theme that is applied to them. Those methods accept the "
"theme type as one of the arguments."
msgstr ""
"Ви також можете визначити власні типи тем і додатково налаштувати як "
"вбудовані, так і власні елементи керування. Оскільки вбудовані елементи "
"керування не знають про ваші користувацькі типи тем, ви повинні "
"використовувати сценарії для доступу до цих елементів. Усі контрольні вузли "
"мають кілька методів, які дозволяють отримати елементи теми з теми, яка до "
"них застосована. Ці методи приймають тип теми як один із аргументів."

msgid ""
"To give more customization opportunities types can also be linked together "
"as type variations. This is another use-case for custom theme types. For "
"example, a theme can contain a type ``Header`` which can be marked as a "
"variation of the base ``Label`` type. An individual ``Label`` control can "
"then be set to use the ``Header`` variation for its type, and every time a "
"theme item is requested from a theme this variation will be used before any "
"other type. This allows to store various presets of theme items for the same "
"class of the control node in the single ``Theme`` resource."
msgstr ""
"Щоб надати більше можливостей для налаштування, типи також можна пов’язувати "
"разом як варіанти типу. Це ще один варіант використання користувацьких типів "
"тем. Наприклад, тема може містити тип ``Заголовок``, який можна позначити як "
"варіацію базового типу ``Мітка``. Окремий елемент керування ``Label`` можна "
"налаштувати на використання варіанту ``Header`` для свого типу, і кожного "
"разу, коли елемент теми запитується з теми, цей варіант "
"використовуватиметься перед будь-яким іншим типом. Це дозволяє зберігати "
"різні попередні налаштування елементів теми для одного класу вузла керування "
"в одному ресурсі ``Тема``."

msgid ""
"Only variations available from the default theme or defined in the custom "
"project theme are shown in the Inspector dock as options. You can still "
"input manually the name of a variation that is defined outside of those two "
"places, but it is recommended to keep all variations to the project theme."
msgstr ""
"Лише варіації, доступні в темі за замовчуванням або визначені в "
"користувальницькій темі проекту, відображаються на панелі «Інспектор» як "
"параметри. Ви все ще можете вручну ввести назву варіанту, який визначено "
"поза цими двома місцями, але рекомендується зберегти всі варіанти в темі "
"проекту."

msgid ""
"You can learn more about creating and using theme type variations in a :ref:"
"`dedicated article <doc_gui_theme_type_variations>`."
msgstr ""
"Ви можете дізнатися більше про створення та використання варіантів типу теми "
"в :ref:`спеціальній статті <doc_gui_theme_type_variations>`."

msgid "Customizing a control"
msgstr "Налаштування елемента керування"

msgid ""
"Each control node can be customized directly without the use of themes. This "
"is called local overrides. Every theme property from the control's class "
"reference can be overridden directly on the control itself, using either the "
"Inspector dock, or scripts. This allows to make granular changes to a "
"particular part of the UI, while not affecting anything else in the project, "
"including this control's children."
msgstr ""
"Кожен вузол керування можна налаштувати безпосередньо без використання тем. "
"Це називається локальними перевизначеннями. Кожну властивість теми з "
"посилання на клас елемента керування можна перевизначити безпосередньо в "
"самому елементі керування за допомогою док-станції Inspector або сценаріїв. "
"Це дозволяє вносити детальні зміни до певної частини інтерфейсу користувача, "
"не впливаючи ні на що інше в проекті, включно з дочірніми елементами цього "
"елемента керування."

msgid ""
"Local overrides are less useful for the visual flair of your user interface, "
"especially if you aim for consistency. However, for layout nodes these are "
"essential. Nodes such as :ref:`BoxContainer <class_BoxContainer>` and :ref:"
"`GridContainer <class_GridContainer>` use theme constants for defining "
"separation between their children, and :ref:`MarginContainer "
"<class_MarginContainer>` stores its customizable margins in its theme items."
msgstr ""
"Локальні перевизначення менш корисні для візуального вигляду вашого "
"інтерфейсу користувача, особливо якщо ви прагнете узгодженості. Однак для "
"вузлів макета вони важливі. Такі вузли, як :ref:`BoxContainer "
"<class_BoxContainer>` і :ref:`GridContainer <class_GridContainer>` "
"використовують константи теми для визначення поділу між їхніми дочірніми "
"елементами, а :ref:`MarginContainer <class_MarginContainer>` зберігає "
"настроювані поля в своїх елементах теми ."

msgid ""
"Whenever a control has a local theme item override, this is the value that "
"it uses. Values provided by the theme are ignored."
msgstr ""
"Щоразу, коли елемент керування має заміну елемента локальної теми, це "
"значення, яке він використовує. Значення, надані темою, ігноруються."

msgid "Customizing a project"
msgstr "Налаштування проекту"

msgid ""
"Out of the box each project adopts the default project theme provided by "
"Godot. The default theme itself is constant and cannot be changed, but its "
"items can be overridden with a custom theme. Custom themes can be applied in "
"two ways: as a project setting, and as a node property throughout the tree "
"of control nodes."
msgstr ""
"З коробки кожен проект приймає тему проекту за замовчуванням, надану Godot. "
"Сама тема за замовчуванням є постійною та не може бути змінена, але її "
"елементи можна замінити спеціальною темою. Спеціальні теми можна "
"застосовувати двома способами: як налаштування проекту та як властивість "
"вузла в усьому дереві вузлів керування."

msgid ""
"This allows you to configure the default look of every Godot control with a "
"single theme resource, but you can go more granular than that. Every control "
"node also has a :ref:`theme <class_Control_property_theme>` property, which "
"allows you to set a custom theme for the branch of nodes starting with that "
"control. This means that the control and all of its children, and their "
"children in turn, would first check that custom theme resource before "
"falling back on the project and the default themes."
msgstr ""
"Це дозволяє налаштувати вигляд за замовчуванням кожного елемента керування "
"Godot за допомогою єдиного тематичного ресурсу, але ви можете зробити це "
"більш детально. Кожний вузол керування також має властивість :ref:`theme "
"<class_Control_property_theme>`, яка дозволяє встановити спеціальну тему для "
"гілки вузлів, починаючи з цього елемента керування. Це означає, що елемент "
"керування та всі його дочірні елементи, а також їхні дочірні елементи, у "
"свою чергу, спочатку перевірять цей власний ресурс теми, перш ніж "
"повернутися до проекту та тем за замовчуванням."

msgid ""
"Instead of changing the project setting you can set the custom theme "
"resource to the root-most control node of your entire UI branch to almost "
"the same effect. While in the running project it will behave as expected, "
"individual scenes will still display using the default theme when previewing "
"or running them directly. To fix that you can set the same theme resource to "
"the root control of each individual scene."
msgstr ""
"Замість того, щоб змінювати параметри проекту, ви можете встановити ресурс "
"спеціальної теми для самого кореневого вузла керування всієї вашої гілки "
"інтерфейсу користувача з майже таким самим ефектом. Хоча у запущеному "
"проекті він поводитиметься належним чином, окремі сцени все одно "
"відображатимуться з використанням теми за замовчуванням під час попереднього "
"перегляду або безпосереднього запуску. Щоб виправити це, ви можете "
"встановити той самий ресурс теми для кореневого керування кожної окремої "
"сцени."

msgid ""
"For example, you can have a certain style for buttons in your project theme, "
"but want a different look for buttons inside of a popup dialog. You can set "
"a custom theme resource to the root control of your popup and define a "
"different style for buttons within that resource. As long as the chain of "
"control nodes between the root of the popup and the buttons is "
"uninterrupted, those buttons will use the styles defined in the theme "
"resource that is closest to them. All other controls will still be styled "
"using the project-wide theme and the default theme styles."
msgstr ""
"Наприклад, ви можете мати певний стиль для кнопок у темі проекту, але "
"бажаєте інший вигляд кнопок у спливаючому діалоговому вікні. Ви можете "
"встановити спеціальний ресурс теми для кореневого елемента керування вашого "
"спливаючого вікна та визначити інший стиль для кнопок у цьому ресурсі. Поки "
"ланцюжок вузлів керування між коренем спливаючого вікна та кнопками не "
"переривається, ці кнопки використовуватимуть стилі, визначені в ресурсі "
"теми, який є найближчим до них. Усі інші елементи керування все одно будуть "
"оформлені за допомогою теми для всього проекту та стилів теми за "
"замовчуванням."

msgid ""
"To sum it up, for an arbitrary control its theme item lookup would look "
"something like this:"
msgstr ""
"Підводячи підсумок, для довільного елемента управління пошук елементів його "
"теми виглядатиме приблизно так:"

msgid "Check for local overrides of the same data type and name."
msgstr "Перевірте локальні перевизначення того самого типу даних і імені."

msgid "Using control's type variation, class name and parent class names:"
msgstr ""
"Використання варіанту типу елемента керування, імені класу та назв "
"батьківського класу:"

msgid ""
"Check every control starting from itself and see if it has a theme property "
"set;"
msgstr ""
"Перевірте кожен елемент керування, починаючи з самого себе, і подивіться, чи "
"встановлено для нього властивість теми;"

msgid ""
"If it does, check that theme for the matching item of the same name, data "
"and theme type;"
msgstr ""
"Якщо так, перевірте цю тему для відповідного елемента з такою ж назвою, "
"даними та типом теми;"

msgid ""
"If there is no custom theme or it doesn't have the item, move to the parent "
"control;"
msgstr ""
"Якщо спеціальної теми немає або в ній відсутній елемент, перейдіть до "
"батьківського контролю;"

msgid ""
"Repeat steps a-c. until the root of the tree is reached, or a non-control "
"node is reached."
msgstr ""
"Повторіть кроки a-c. поки не буде досягнуто кореня дерева або не буде "
"досягнуто неконтрольний вузол."

msgid ""
"Using control's type variation, class name and parent class names check the "
"project-wide theme, if it's present."
msgstr ""
"Використовуючи варіант типу елемента керування, назву класу та імена "
"батьківського класу, перевірте тему для всього проекту, якщо вона присутня."

msgid ""
"Using control's type variation, class name and parent class names check the "
"default theme."
msgstr ""
"Використовуючи зміну типу елемента керування, назву класу та імена "
"батьківських класів, перевірте тему за замовчуванням."

msgid ""
"Even if the item doesn't exist in any theme, a corresponding default value "
"for that data type will be returned."
msgstr ""
"Навіть якщо елемент не існує в жодній темі, буде повернено відповідне "
"значення за замовчуванням для цього типу даних."

msgid "Beyond controls"
msgstr "Поза контролем"

msgid ""
"Naturally, themes are an ideal type of resource for storing configuration "
"for something visual. While the support for theming is built into control "
"nodes, other nodes can use them as well, just like any other resource."
msgstr ""
"Звичайно, теми є ідеальним типом ресурсу для зберігання конфігурації чогось "
"візуального. Хоча підтримка тематизації вбудована в контрольні вузли, інші "
"вузли також можуть використовувати їх, як і будь-який інший ресурс."

msgid ""
"An example of using themes for something beyond controls can be a modulation "
"of sprites for the same units on different teams in a strategy game. A theme "
"resource can define a collection of colors, and sprites (with a help from "
"scripts) can use those colors to draw the texture. The main benefit being "
"that you could make different themes using the same theme items for red, "
"blue, and green teams, and swap them with a single resource change."
msgstr ""
"Прикладом використання тем для чогось поза контролем може бути модуляція "
"спрайтів для тих самих підрозділів у різних командах у стратегічній грі. "
"Ресурс теми може визначати набір кольорів, а спрайти (за допомогою "
"сценаріїв) можуть використовувати ці кольори для малювання текстури. Основна "
"перевага полягає в тому, що ви можете створювати різні теми, використовуючи "
"однакові елементи теми для червоних, синіх і зелених команд, і міняти їх "
"місцями за допомогою однієї зміни ресурсу."
