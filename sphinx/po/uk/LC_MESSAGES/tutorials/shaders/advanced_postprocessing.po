#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "Розширена постобробка"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"Цей підручник описує розширений метод постобробки в Godot. Зокрема, буде "
"пояснено, як написати шейдер постобробки, який використовує буфер глибини. "
"Ви вже повинні бути знайомі з постобробкою загалом і, зокрема, з методами, "
"викладеними в :ref:`підручнику з постобробки <doc_custom_postprocessing>`."

msgid "Full screen quad"
msgstr "Повноекранний квадроцикл"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"Один із способів створення користувацьких ефектів постобробки — використання "
"вікна перегляду. Однак є два основні недоліки використання Viewport:"

msgid "The depth buffer cannot be accessed"
msgstr "Немає доступу до буфера глибини"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "Ефект шейдера постобробки не видно в редакторі"

msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"Щоб обійти обмеження на використання буфера глибини, використовуйте :ref:"
"`MeshInstance3D <class_MeshInstance3D>` з примітивом :ref:`QuadMesh "
"<class_QuadMesh>`. Це дозволяє нам використовувати шейдер і отримати доступ "
"до текстури глибини сцени. Потім скористайтеся вершинним шейдером, щоб "
"квадроцикл постійно покривав екран, щоб ефект постобробки застосовувався "
"постійно, включно з редактором."

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"Спочатку створіть новий MeshInstance3D і встановіть його сітку на QuadMesh. "
"Це створює чотирикутник із центром у позиції ``(0, 0, 0)`` із шириною та "
"висотою ``1``. Встановіть ширину та висоту на ``2`` і ввімкніть **Flip "
"Faces**. Прямо зараз квадроцикл займає позицію у світовому просторі на "
"початку координат. Однак ми хочемо, щоб він рухався разом з камерою, щоб він "
"завжди покривав весь екран. Щоб зробити це, ми обійдемо перетворення "
"координат, які переміщують позиції вершин через простори різницевих "
"координат і оброблятимемо вершини так, ніби вони вже знаходяться в просторі "
"відсікання."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position in clip space directly."
msgstr ""
"Вершиний шейдер очікує виводу координат у просторі відсікання, які є "
"координатами в діапазоні від ``-1`` у лівій і нижній частині екрана до ``1`` "
"у верхній і правій частині екрана. Ось чому QuadMesh має мати висоту та "
"ширину ``2``. Ґодо виконує перетворення від моделі до простору огляду до "
"простору кліпу за кадром, тому нам потрібно звести нанівець ефект "
"перетворень Годо. Ми робимо це, встановлюючи вбудований ``POSITION`` у "
"бажане положення. ``POSITION`` обходить вбудовані перетворення та встановлює "
"позицію вершини в просторі кліпу безпосередньо."

msgid ""
"In versions of Godot earlier than 4.3, this code recommended using "
"``POSITION = vec4(VERTEX, 1.0);`` which implicitly assumed the clip-space "
"near plane was at ``0.0``. That code is now incorrect and will not work in "
"versions 4.3+ as we use a \"reversed-z\" depth buffer now where the near "
"plane is at ``1.0``."
msgstr ""
"У версіях Godot, раніших за 4.3, цей код рекомендував використовувати "
"``POSITION = vec4(VERTEX, 1.0);``, який неявно припускав, що простір кліпу "
"біля площини був ``0.0``. Тепер цей код неправильний і не працюватиме у "
"версіях 4.3+, оскільки тепер ми використовуємо буфер глибини \"reversed-z\", "
"де ближня площина знаходиться на ``1.0``."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"Навіть із цим вершинним шейдером квадроцикл продовжує зникати. Це пов’язано "
"з вибракуванням усеченої точки, яке виконується на ЦП. Frustum cutling "
"використовує матрицю камери та AABB сіток, щоб визначити, чи буде сітка "
"видимою *перед* передачею її до графічного процесора. ЦП не знає, що ми "
"робимо з вершинами, тому він припускає, що вказані координати стосуються "
"світових позицій, а не позицій у просторі відсіку, що призводить до того, що "
"Годо відбирає квадроцикл, коли ми повертаємося від центру сцени. Щоб "
"уберегти квадроцикл від вибракування, є кілька варіантів:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"Додайте QuadMesh до камери як дочірнього елемента, щоб камера завжди була "
"спрямована на нього"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"Встановіть властивість Geometry ``extra_cull_margin`` якомога більше в "
"QuadMesh"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"Другий варіант гарантує, що квадроцикл буде видно в редакторі, тоді як "
"перший варіант гарантує, що він все одно буде видимим, навіть якщо камера "
"переміститься за межі відбракування. Ви також можете використовувати обидва "
"варіанти."

msgid "Depth texture"
msgstr "Глибина текстури"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"Щоб прочитати текстуру глибини, нам спочатку потрібно створити однорідну "
"текстуру, налаштовану на буфер глибини за допомогою ``hint_depth_texture``."

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr ""
"Після визначення текстуру глибини можна прочитати за допомогою функції "
"``texture()``."

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"Подібно до доступу до текстури екрана, доступ до текстури глибини можливий "
"лише під час читання з поточного вікна перегляду. До текстури глибини "
"неможливо отримати доступ з іншого вікна перегляду, яке ви відтворили."

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"По-перше, візьміть координати екранного простору та перетворіть їх у "
"нормалізовані координати пристрою (NDC). NDC виконується від ``-1.0`` до "
"``1.0`` у напрямках ``x`` і ``y`` та від ``0.0`` до ``1.0`` у напрямку ``z`` "
"під час використання бекенд Vulkan. Реконструюйте NDC, використовуючи "
"``SCREEN_UV`` для осей ``x`` і ``y``, а також значення глибини ``z``."

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"Перетворіть NDC на оглядовий простір, помноживши NDC на "
"``INV_PROJECTION_MATRIX``. Пам’ятайте, що простір перегляду визначає "
"положення відносно камери, тому значення ``z`` дасть нам відстань до точки."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"Оскільки камера спрямована в негативному напрямку ``z``, позиція матиме "
"від’ємне значення ``z``. Щоб отримати придатне значення глибини, ми маємо "
"заперечити ``view.z``."

msgid "An optimization"
msgstr "Оптимізація"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"Ви можете отримати вигоду від використання одного великого трикутника, а не "
"використання повноекранного чотирикутника. Причину цього пояснюється `тут "
"<https://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-"
"passes>`_. Однак переваги досить невеликі й корисні лише під час запуску "
"особливо складних фрагментних шейдерів."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Встановіть Mesh у MeshInstance3D на :ref:`ArrayMesh <class_ArrayMesh>`. "
"ArrayMesh — це інструмент, який дозволяє легко побудувати сітку з масивів "
"для вершин, нормалей, кольорів тощо."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr "Тепер додайте сценарій до MeshInstance3D і використовуйте такий код:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"Трикутник задається в нормалізованих координатах пристрою. Нагадаємо, NDC "
"працює від ``-1.0`` до ``1.0`` в обох напрямках ``x`` і ``y``. Це робить "
"екран ``2`` одиниці шириною та ``2`` одиниці висотою. Щоб покрити весь екран "
"одним трикутником, використовуйте трикутник шириною ``4`` одиниць і ``4`` "
"одиниць заввишки, подвоївши його висоту та ширину."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"Призначте той самий вершинний шейдер зверху, і все повинно виглядати точно "
"так само."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"Єдиним недоліком використання ArrayMesh порівняно з QuadMesh є те, що "
"ArrayMesh не видно в редакторі, оскільки трикутник не будується, доки не "
"буде запущено сцену. Щоб уникнути цього, побудуйте одну трикутну сітку в "
"програмі моделювання та використовуйте її в MeshInstance3D."
