#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "Використання обчислювальних шейдерів"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"Цей підручник проведе вас через процес створення мінімального "
"обчислювального шейдера. Але спочатку трохи фону про обчислювальні шейдери "
"та про те, як вони працюють із Godot."

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"Цей посібник передбачає, що ви загалом знайомі з шейдерами. Якщо ви новачок "
"у шейдерах, будь ласка, прочитайте :ref:`doc_introduction_to_shaders` "
"і :ref:`ваш перший шейдер <toc-your-first-shader>` перед тим, як продовжити "
"цей посібник."

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"Обчислювальний шейдер — це особливий тип шейдерної програми, яка орієнтована "
"на програмування загального призначення. Іншими словами, вони більш гнучкі, "
"ніж вершинні шейдери та фрагментні шейдери, оскільки вони не мають "
"фіксованої мети (тобто трансформації вершин або запису кольорів у "
"зображення). На відміну від фрагментних і вершинних шейдерів, у "
"обчислювальних шейдерах дуже мало відбувається за лаштунками. Код, який ви "
"пишете, — це те, що виконує GPU, і зовсім небагато іншого. Це може зробити "
"їх дуже корисним інструментом для перевантаження важких обчислень на GPU."

msgid "Now let's get started by creating a short compute shader."
msgstr "Тепер давайте почнемо зі створення короткого обчислювального шейдера."

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"Спочатку у **зовнішньому** текстовому редакторі за вашим вибором створіть "
"новий файл під назвою ``compute_example.glsl`` у папці вашого проекту. Коли "
"ви пишете обчислювальні шейдери в Godot, ви пишете їх безпосередньо в GLSL. "
"Мова шейдерів Godot базується на GLSL. Якщо ви знайомі зі звичайними "
"шейдерами в Godot, наведений нижче синтаксис здасться вам дещо знайомим."

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"Обчислювальні шейдери можна використовувати лише з рендерів на основі "
"RenderingDevice (Forward+ або Mobile renderer). Щоб дотримуватися цього "
"підручника, переконайтеся, що ви використовуєте Forward+ або Mobile "
"рендерер. Налаштування для якого розташовано у верхньому правому куті "
"редактора."

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"Зауважте, що підтримка обчислювальних шейдерів зазвичай погана на мобільних "
"пристроях (через помилки драйверів), навіть якщо вони технічно підтримуються."

msgid "Let's take a look at this compute shader code:"
msgstr "Погляньмо на цей код обчислювального шейдера:"

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"Цей код приймає масив чисел з плаваючою точкою, множить кожен елемент на 2 і "
"зберігає результати назад у буферному масиві. Тепер давайте розглянемо це "
"рядок за рядком."

msgid "These two lines communicate two things:"
msgstr "Ці два рядки повідомляють про дві речі:"

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"Наступний код є обчислювальним шейдером. Це підказка щодо Godot, яка "
"потрібна редактору для правильного імпорту файлу шейдера."

msgid "The code is using GLSL version 450."
msgstr "Код використовує GLSL версії 450."

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr ""
"Вам ніколи не доведеться змінювати ці два рядки для ваших власних "
"обчислювальних шейдерів."

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"Далі ми повідомляємо кількість викликів, які будуть використовуватися в "
"кожній робочій групі. Виклики — це екземпляри шейдера, які виконуються в "
"одній робочій групі. Коли ми запускаємо обчислювальний шейдер із ЦП, ми "
"повідомляємо йому, скільки робочих груп потрібно запустити. Робочі групи "
"працюють паралельно одна одній. Під час роботи однієї робочої групи ви не "
"можете отримати доступ до інформації в іншій робочій групі. Однак виклики в "
"одній робочій групі можуть мати обмежений доступ до інших викликів."

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr ""
"Подумайте про робочі групи та виклики як про гігантський вкладений цикл "
"``for``."

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"Робочі групи та виклики — це розширена тема. Наразі пам’ятайте, що ми будемо "
"виконувати два виклики для кожної робочої групи."

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"Тут ми надаємо інформацію про пам’ять, до якої матиме доступ обчислювальний "
"шейдер. Властивість ``layout`` дозволяє нам вказати шейдеру, де шукати "
"буфер, пізніше нам потрібно буде зіставити ці позиції ``set`` і ``binding`` "
"з боку ЦП."

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"Ключове слово ``restrict`` повідомляє шейдеру, що доступ до цього буфера "
"буде доступний лише з одного місця цього шейдера. Іншими словами, ми не "
"будемо прив’язувати цей буфер до іншого індексу ``set`` або ``binding``. Це "
"важливо, оскільки дозволяє компілятору шейдерів оптимізувати код шейдера. "
"Завжди використовуйте ``restrict``, коли це можливо."

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"Це *нерозмірний* буфер, що означає, що він може бути будь-якого розміру. "
"Тому нам потрібно бути обережними, щоб не читати з індексу, який перевищує "
"розмір буфера."

msgid ""
"Finally, we write the ``main`` function which is where all the logic "
"happens. We access a position in the storage buffer using the "
"``gl_GlobalInvocationID`` built-in variables. ``gl_GlobalInvocationID`` "
"gives you the global unique ID for the current invocation."
msgstr ""
"Нарешті, ми пишемо функцію ``main``, у якій і відбувається вся логіка. Ми "
"отримуємо доступ до позиції в буфері зберігання за допомогою вбудованих "
"змінних ``gl_GlobalInvocationID``. ``gl_GlobalInvocationID`` дає глобальний "
"унікальний ідентифікатор для поточного виклику."

msgid ""
"To continue, write the code above into your newly created "
"``compute_example.glsl`` file."
msgstr ""
"Щоб продовжити, запишіть наведений вище код у щойно створений файл "
"``compute_example.glsl``."

msgid "Create a local RenderingDevice"
msgstr "Створіть локальний RenderingDevice"

msgid ""
"To interact with and execute a compute shader, we need a script. Create a "
"new script in the language of your choice and attach it to any Node in your "
"scene."
msgstr ""
"Щоб взаємодіяти з обчислювальним шейдером і виконувати його, нам потрібен "
"сценарій. Створіть новий сценарій вибраною вами мовою та прикріпіть його до "
"будь-якого вузла вашої сцени."

msgid ""
"Now to execute our shader we need a local :ref:`class_RenderingDevice` which "
"can be created using the :ref:`class_RenderingServer`:"
msgstr ""
"Тепер для виконання нашого шейдера нам потрібен "
"локальний :ref:`class_RenderingDevice`, який можна створити за "
"допомогою :ref:`class_RenderingServer`:"

msgid ""
"After that, we can load the newly created shader file "
"``compute_example.glsl`` and create a precompiled version of it using this:"
msgstr ""
"Після цього ми можемо завантажити щойно створений файл шейдера "
"``compute_example.glsl`` і створити його попередньо скомпільовану версію за "
"допомогою цього:"

msgid ""
"Local RenderingDevices cannot be debugged using tools such as `RenderDoc "
"<https://renderdoc.org/>`__."
msgstr ""
"Локальні RenderingDevices не можна налагодити за допомогою таких "
"інструментів, як `RenderDoc <https://renderdoc.org/>`__."

msgid "Provide input data"
msgstr "Надайте вхідні дані"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"Як ви пам’ятаєте, ми хочемо передати вхідний масив у наш шейдер, помножити "
"кожен елемент на 2 і отримати результати."

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"Нам потрібно створити буфер для передачі значень у обчислювальний шейдер. Ми "
"маємо справу з масивом float, тому для цього прикладу будемо використовувати "
"буфер зберігання. Буфер зберігання займає масив байтів і дозволяє "
"центральному процесору передавати дані в і з графічного процесора."

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr ""
"Тож давайте ініціалізуємо масив із плаваючими числами та створимо буфер "
"зберігання:"

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"З буфером на місці нам потрібно сказати пристрою рендерингу використовувати "
"цей буфер. Для цього нам потрібно буде створити уніформу (як у звичайних "
"шейдерах) і призначити її набору уніформ, який ми можемо передати нашому "
"шейдеру пізніше."

msgid "Defining a compute pipeline"
msgstr "Визначення обчислювального конвеєра"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr ""
"Наступним кроком є створення набору інструкцій, які може виконувати наш "
"графічний процесор. Для цього нам потрібен конвеєр і список обчислень."

msgid "The steps we need to do to compute our result are:"
msgstr "Щоб обчислити результат, нам потрібно виконати такі кроки:"

msgid "Create a new pipeline."
msgstr "Створіть новий конвеєр."

msgid "Begin a list of instructions for our GPU to execute."
msgstr "Почніть список інструкцій, які має виконати наш графічний процесор."

msgid "Bind our compute list to our pipeline"
msgstr "Прив’яжіть наш список обчислень до нашого конвеєра"

msgid "Bind our buffer uniform to our pipeline"
msgstr "Прив’яжіть нашу буферну форму до нашого трубопроводу"

msgid "Specify how many workgroups to use"
msgstr "Укажіть, скільки робочих груп використовувати"

msgid "End the list of instructions"
msgstr "Завершіть список інструкцій"

msgid ""
"Note that we are dispatching the compute shader with 5 work groups in the X "
"axis, and one in the others. Since we have 2 local invocations in the X axis "
"(specified in our shader), 10 compute shader invocations will be launched in "
"total. If you read or write to indices outside of the range of your buffer, "
"you may access memory outside of your shaders control or parts of other "
"variables which may cause issues on some hardware."
msgstr ""
"Зауважте, що ми відправляємо обчислювальний шейдер із 5 робочими групами на "
"осі X і по одній на інших. Оскільки у нас є 2 локальні виклики на осі X "
"(зазначені в нашому шейдері), загалом буде запущено 10 викликів "
"обчислювального шейдера. Якщо ви читаєте або записуєте індекси за межами "
"діапазону вашого буфера, ви можете отримати доступ до пам’яті поза контролем "
"ваших шейдерів або до частин інших змінних, що може спричинити проблеми з "
"деяким обладнанням."

msgid "Execute a compute shader"
msgstr "Виконайте обчислювальний шейдер"

msgid ""
"After all of this we are almost done, but we still need to execute our "
"pipeline. So far we have only recorded what we would like the GPU to do; we "
"have not actually run the shader program."
msgstr ""
"Після всього цього ми майже закінчили, але нам ще потрібно виконати наш "
"конвеєр. Поки що ми записали лише те, що ми хотіли б, щоб GPU зробив; ми "
"фактично не запускали шейдерну програму."

msgid ""
"To execute our compute shader we need to submit the pipeline to the GPU and "
"wait for the execution to finish:"
msgstr ""
"Щоб виконати наш обчислювальний шейдер, нам потрібно передати конвеєр до GPU "
"та дочекатися завершення виконання:"

msgid ""
"Ideally, you would not call ``sync()`` to synchronize the RenderingDevice "
"right away as it will cause the CPU to wait for the GPU to finish working. "
"In our example, we synchronize right away because we want our data available "
"for reading right away. In general, you will want to wait *at least* 2 or 3 "
"frames before synchronizing so that the GPU is able to run in parallel with "
"the CPU."
msgstr ""
"В ідеалі ви б не викликали ``sync()`` для синхронізації RenderingDevice "
"одразу, оскільки це змусить центральний процесор чекати завершення роботи "
"графічного процесора. У нашому прикладі ми синхронізуємо відразу, тому що ми "
"хочемо, щоб наші дані були доступні для читання відразу. Загалом, вам "
"потрібно зачекати *принаймні* 2-3 кадри перед синхронізацією, щоб графічний "
"процесор міг працювати паралельно з центральним процесором."

msgid ""
"Long computations can cause Windows graphics drivers to \"crash\" due "
"to :abbr:`TDR (Timeout Detection and Recovery)` being triggered by Windows. "
"This is a mechanism that reinitializes the graphics driver after a certain "
"amount of time has passed without any activity from the graphics driver "
"(usually 5 to 10 seconds)."
msgstr ""
"Довгі обчислення можуть призвести до «збою» графічних драйверів Windows "
"через :abbr:`TDR (Timeout Detection and Recovery)`, який запускає Windows. "
"Це механізм, який повторно ініціалізує графічний драйвер після того, як мине "
"певний проміжок часу без жодної активності графічного драйвера (зазвичай від "
"5 до 10 секунд)."

msgid ""
"Depending on the duration your compute shader takes to execute, you may need "
"to split it into multiple dispatches to reduce the time each dispatch takes "
"and reduce the chances of triggering a TDR. Given TDR is time-dependent, "
"slower GPUs may be more prone to TDRs when running a given compute shader "
"compared to a faster GPU."
msgstr ""
"Залежно від тривалості виконання обчислювального шейдера, вам може "
"знадобитися розділити його на кілька відправлень, щоб скоротити час, який "
"займає кожне відправлення, і зменшити ймовірність запуску TDR. Враховуючи, "
"що TDR залежить від часу, повільніші графічні процесори можуть бути більш "
"схильні до TDR під час роботи певного обчислювального шейдера порівняно зі "
"швидшим графічним процесором."

msgid "Retrieving results"
msgstr "Отримання результатів"

msgid ""
"You may have noticed that, in the example shader, we modified the contents "
"of the storage buffer. In other words, the shader read from our array and "
"stored the data in the same array again so our results are already there. "
"Let's retrieve the data and print the results to our console."
msgstr ""
"Можливо, ви помітили, що у прикладі шейдера ми змінили вміст буфера "
"зберігання. Іншими словами, шейдер прочитав наш масив і знову зберіг дані в "
"тому ж масиві, тому наші результати вже є. Давайте отримаємо дані та "
"надрукуємо результати на нашу консоль."

msgid ""
"With that, you have everything you need to get started working with compute "
"shaders."
msgstr ""
"Таким чином, у вас є все необхідне, щоб розпочати роботу з обчислювальними "
"шейдерами."

msgid ""
"The demo projects repository contains a `Compute Shader Heightmap demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ This project performs heightmap image "
"generation on the CPU and GPU separately, which lets you compare how a "
"similar algorithm can be implemented in two different ways (with the GPU "
"implementation being faster in most cases)."
msgstr ""
"Репозиторій демонстраційних проектів містить `демонстрацію Compute Shader "
"Heightmap <https://github.com/godotengine/godot-demo-projects/tree/master/"
"misc/compute_shader_heightmap>`__ Цей проект створює зображення карти висот "
"окремо на CPU та GPU , який дає змогу порівняти, як подібний алгоритм можна "
"реалізувати двома різними способами (причому реалізація GPU у більшості "
"випадків швидша)."
