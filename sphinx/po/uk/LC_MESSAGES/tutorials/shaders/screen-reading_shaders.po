#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "Шейдери для читання з екрана"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"Часто хочеться створити шейдер, який читає з того самого екрана, на який він "
"записує. 3D API, такі як OpenGL або DirectX, дуже ускладнюють це через "
"внутрішні апаратні обмеження. Графічні процесори надзвичайно паралельні, "
"тому читання та запис спричиняє різноманітні проблеми з кеш-пам’яттю та "
"когерентністю. Як наслідок, навіть найсучасніше обладнання не підтримує це "
"належним чином."

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"Обхідним шляхом є створення копії екрана або частини екрана у зворотному "
"буфері, а потім читання з нього під час малювання. Godot надає кілька "
"інструментів, які полегшують цей процес."

msgid "Screen texture"
msgstr "Текстура екрану"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_language` має спеціальну текстуру для доступу до вже "
"відрендереного вмісту екрана. Він використовується шляхом визначення "
"підказки під час оголошення уніформи ``sampler2D``: ``hint_screen_texture``. "
"Спеціальний вбудований змінний ``SCREEN_UV`` можна використовувати для "
"отримання UV відносно екрана для поточного фрагмента. У результаті цей "
"фрагментний шейдер canvas_item створює невидимий об’єкт, оскільки він "
"показує лише те, що лежить позаду:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"Тут використовується ``textureLod``, оскільки ми хочемо читати лише з "
"нижньої mipmap. Якщо замість цього ви хочете читати з розмитої версії "
"текстури, ви можете збільшити третій аргумент до ``textureLod`` і змінити "
"підказку ``filter_nearest`` на ``filter_nearest_mipmap`` (або будь-який "
"інший фільтр з увімкненими mipmaps). Якщо використовується фільтр з mip-"
"картами, Godot автоматично обчислить розмиту текстуру для вас."

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with an LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""
"Якщо режим фільтра не змінено на режим фільтра, який містить ``mipmap`` у "
"своїй назві, ``textureLod`` з параметром LOD, більшим за ``0.0``, матиме "
"такий самий вигляд, як і ``0.0`` ` Параметр LOD."

msgid "Screen texture example"
msgstr "Приклад текстури екрана"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"Текстуру екрана можна використовувати для багатьох речей. Існує спеціальна "
"демонстрація для *Screen Space Shaders*, яку ви можете завантажити, щоб "
"переглянути та навчитися. Одним із прикладів є простий шейдер для "
"регулювання яскравості, контрастності та насиченості:"

msgid "Behind the scenes"
msgstr "За кадром"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"Хоча це здається чарівним, це не так. У 2D, коли ``hint_screen_texture`` "
"вперше знайдено у вузлі, який збирається намалювати, Godot робить "
"повноекранну копію до заднього буфера. На наступних вузлах, які "
"використовують його в шейдерах, екран не буде скопійовано для них, оскільки "
"це в кінцевому підсумку буде неефективним. У 3D екран копіюється після "
"проходу непрозорої геометрії, але перед проходом прозорої геометрії, тому "
"прозорі об’єкти не будуть зафіксовані в текстурі екрана."

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"Як результат, у 2D, якщо шейдери, які використовують "
"``hint_screen_texture``, перекриваються, другий не використовуватиме "
"результат першого, що призведе до неочікуваних візуальних ефектів:"

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"На наведеному вище зображенні друга сфера (вгорі праворуч) використовує те "
"саме джерело текстури екрана, що й перша нижче, тому перша «зникає» або її "
"не видно."

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"У 2D це можна виправити за допомогою вузла :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, який можна створити між обома сферами. "
"BackBufferCopy може працювати, вказуючи область екрана або весь екран:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr ""
"З правильним копіюванням у зворотний буфер дві сфери правильно поєднуються:"

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""
"У 3D матеріали, які використовують ``hint_screen_texture``, самі по собі "
"вважаються прозорими і не відображатимуться в отриманій текстурі екрана "
"інших матеріалів. Якщо ви плануєте створити екземпляр сцени, яка "
"використовує матеріал із ``hint_screen_texture``, вам потрібно буде "
"використовувати вузол BackBufferCopy."

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"У 3D існує менша гнучкість для вирішення цієї конкретної проблеми, оскільки "
"текстура екрана фіксується лише один раз. Будьте обережні, використовуючи "
"текстуру екрана в 3D, оскільки вона не захопить прозорі об’єкти та може "
"захопити деякі непрозорі об’єкти, які знаходяться перед об’єктом за "
"допомогою текстури екрана."

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"Ви можете відтворити логіку зворотного буфера в 3D, створивши :ref:`Viewport "
"<class_Viewport>` з камерою в тій самій позиції, що й ваш об’єкт, а потім "
"використати текстуру :ref:`Viewport <class_Viewport>` замість текстура "
"екрану."

msgid "Back-buffer logic"
msgstr "Логіка зворотного буфера"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"Отже, щоб було зрозуміліше, ось як працює логіка копіювання зворотного "
"буфера в 2D у Godot:"

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"Якщо вузол використовує ``hint_screen_texture``, весь екран копіюється до "
"заднього буфера перед малюванням цього вузла. Це відбувається тільки вперше; "
"наступні вузли не запускають це."

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"Якщо вузол BackBufferCopy було оброблено до ситуації, описаної вище (навіть "
"якщо ``hint_screen_texture`` не використовувався), поведінка, описана в "
"пункті вище, не відбувається. Іншими словами, автоматичне копіювання всього "
"екрана відбувається, лише якщо ``hint_screen_texture`` використовується у "
"вузлі вперше, і жоден вузол BackBufferCopy (не вимкнений) не був знайдений "
"раніше в порядку дерева."

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy може копіювати весь екран або його область. Якщо встановлено "
"лише область (а не весь екран), а ваш шейдер використовує пікселі не в "
"скопійованій області, результат цього читання буде невизначеним (швидше за "
"все, сміття з попередніх кадрів). Іншими словами, можна використовувати "
"BackBufferCopy, щоб скопіювати назад область екрана, а потім зчитати "
"текстуру екрана з іншої області. Уникайте такої поведінки!"

msgid "Depth texture"
msgstr "Глибина текстури"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"Для 3D-шейдерів також можна отримати доступ до буфера глибини екрана. Для "
"цього використовується підказка ``hint_depth_texture``. Ця текстура не є "
"лінійною; її необхідно перетворити за допомогою матриці зворотної проекції."

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "Наступний код отримує 3D-позицію під малюваним пікселем:"

msgid "Normal-roughness texture"
msgstr "Звичайна шорстка текстура"

msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr ""
"Текстури з нормальною шорсткістю підтримуються лише у методі рендерингу "
"Forward+, але не в мобільному або сумісності."

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"Подібним чином текстуру нормальної шорсткості можна використовувати для "
"читання нормалей і шорсткості об’єктів, відтворених у попередньому проході "
"глибини. Нормаль зберігається в каналах ``.xyz`` (відображається в діапазоні "
"0-1), тоді як шорсткість зберігається в каналі ``.w``."

msgid "Redefining screen textures"
msgstr "Перевизначення текстур екрану"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"Підказки текстури екрана (``hint_screen_texture``, ``hint_depth_texture`` і "
"``hint_normal_roughness_texture``) можна використовувати з кількома "
"уніформами. Наприклад, ви можете зчитувати з текстури кілька разів з іншим "
"прапором повторення або прапором фільтра."

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"У наведеному нижче прикладі показано шейдер, який зчитує нормальний простір "
"екрана за допомогою лінійної фільтрації, але зчитує шорсткість простору "
"екрана за допомогою фільтрації найближчих сусідів."
