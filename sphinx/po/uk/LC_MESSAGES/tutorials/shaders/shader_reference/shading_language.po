#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shading language"
msgstr "Штрихування мови"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godot використовує мову затінення, подібну до GLSL ES 3.0. Більшість типів "
"даних і функцій підтримуються, а ті, що залишилися, ймовірно, будуть додані "
"з часом."

msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""
"Якщо ви вже знайомі з GLSL, :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` — це ресурс, який допоможе вам "
"перейти від звичайної GLSL до мови затінення Godot."

msgid "Data types"
msgstr "Типи даних"

msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "Підтримуються більшість типів даних GLSL ES 3.0:"

msgid "Type"
msgstr "Тип"

msgid "Description"
msgstr "Опис"

msgid "**void**"
msgstr "**порожнеча**"

msgid "Void datatype, useful only for functions that return nothing."
msgstr "Тип даних Void, корисний лише для функцій, які нічого не повертають."

msgid "**bool**"
msgstr "**bool**"

msgid "Boolean datatype, can only contain ``true`` or ``false``."
msgstr "Логічний тип даних, може містити лише ``true`` або ``false``."

msgid "**bvec2**"
msgstr "**б-вектор2**"

msgid "Two-component vector of booleans."
msgstr "Двокомпонентний вектор логічних значень."

msgid "**bvec3**"
msgstr "**б-вектор3**"

msgid "Three-component vector of booleans."
msgstr "Трикомпонентний вектор булевих значень."

msgid "**bvec4**"
msgstr "**б-вектор4**"

msgid "Four-component vector of booleans."
msgstr "Чотирикомпонентний вектор логічних значень."

msgid "**int**"
msgstr "**int**"

msgid "**ivec2**"
msgstr "**ай-вектор2**"

msgid "Two-component vector of signed integers."
msgstr "Двокомпонентний вектор цілих чисел зі знаком."

msgid "**ivec3**"
msgstr "**ай-вектор3**"

msgid "Three-component vector of signed integers."
msgstr "Трикомпонентний вектор цілих чисел зі знаком."

msgid "**ivec4**"
msgstr "**ай-вектор4**"

msgid "Four-component vector of signed integers."
msgstr "Чотирикомпонентний вектор цілих чисел зі знаком."

msgid "**uint**"
msgstr "**юінт**"

msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr "Беззнакове скалярне ціле число; не може містити від’ємних чисел."

msgid "**uvec2**"
msgstr "**ю-вектор2**"

msgid "Two-component vector of unsigned integers."
msgstr "Двокомпонентний вектор беззнакових цілих чисел."

msgid "**uvec3**"
msgstr "**ю-вектор3**"

msgid "Three-component vector of unsigned integers."
msgstr "Трикомпонентний вектор беззнакових цілих чисел."

msgid "**uvec4**"
msgstr "**ю-вектор4**"

msgid "Four-component vector of unsigned integers."
msgstr "Чотирикомпонентний вектор беззнакових цілих чисел."

msgid "**float**"
msgstr "**float**"

msgid "**vec2**"
msgstr "**вектор2**"

msgid "Two-component vector of floating-point values."
msgstr "Двокомпонентний вектор значень з плаваючою комою."

msgid "**vec3**"
msgstr "**вектор3**"

msgid "Three-component vector of floating-point values."
msgstr "Трикомпонентний вектор значень з плаваючою комою."

msgid "**vec4**"
msgstr "**вектор4**"

msgid "Four-component vector of floating-point values."
msgstr "Чотирикомпонентний вектор значень з плаваючою комою."

msgid "**mat2**"
msgstr "**мат2**"

msgid "2x2 matrix, in column major order."
msgstr "Матриця 2x2, у порядку основних стовпців."

msgid "**mat3**"
msgstr "**мат3**"

msgid "3x3 matrix, in column major order."
msgstr "Матриця 3x3, у порядку основних стовпців."

msgid "**mat4**"
msgstr "**мат4**"

msgid "4x4 matrix, in column major order."
msgstr "Матриця 4x4, у порядку основних стовпців."

msgid "**sampler2D**"
msgstr "**семплер2D**"

msgid "Sampler type for binding 2D textures, which are read as float."
msgstr "Тип семплера для прив’язки 2D-текстур, які зчитуються як плаваючі."

msgid "**isampler2D**"
msgstr "**ай-семплер2D**"

msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr ""
"Тип семплера для прив’язки 2D текстур, які читаються як ціле число зі знаком."

msgid "**usampler2D**"
msgstr "**ю-семплер2D**"

msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr ""
"Тип семплера для прив’язки 2D-текстур, які читаються як ціле число без знаку."

msgid "**sampler2DArray**"
msgstr "**Sampler2DArray**"

msgid "Sampler type for binding 2D texture arrays, which are read as float."
msgstr ""
"Тип семплера для зв’язування масивів двовимірних текстур, які зчитуються як "
"float."

msgid "**isampler2DArray**"
msgstr "**Isampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as signed integer."
msgstr ""
"Тип семплера для зв’язування 2D-масивів текстур, які читаються як ціле число "
"зі знаком."

msgid "**usampler2DArray**"
msgstr "**Usampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as unsigned "
"integer."
msgstr ""
"Тип семплера для зв’язування 2D масивів текстур, які зчитуються як ціле "
"число без знаку."

msgid "**sampler3D**"
msgstr "**Sampler3D**"

msgid "Sampler type for binding 3D textures, which are read as float."
msgstr "Тип семплера для зв'язування 3D-текстур, які читаються як плаваючі."

msgid "**isampler3D**"
msgstr "**Isampler3D**"

msgid "Sampler type for binding 3D textures, which are read as signed integer."
msgstr ""
"Тип семплера для зв'язування 3D-текстур, які читаються як ціле число зі "
"знаком."

msgid "**usampler3D**"
msgstr "**Usampler3D**"

msgid ""
"Sampler type for binding 3D textures, which are read as unsigned integer."
msgstr ""
"Тип семплера для зв'язування 3D-текстур, які читаються як ціле число без "
"знаку."

msgid "**samplerCube**"
msgstr "**семплерКуб**"

msgid "Sampler type for binding Cubemaps, which are read as float."
msgstr "Тип семплера для прив’язки Cubemaps, які читаються як float."

msgid "**samplerCubeArray**"
msgstr "**samplerCubeArray**"

msgid "Comments"
msgstr "Коментарі"

msgid ""
"The shading language supports the same comment syntax as used in C# and C++:"
msgstr ""
"Мова затінення підтримує той самий синтаксис коментарів, який "
"використовується в C# і C++:"

msgid ""
"Additionally, you can use documentation comments that are displayed in the "
"inspector when hovering a shader parameter. Documentation comments are "
"currently only supported when placed immediately above a ``uniform`` "
"declaration. These documentation comments only support the **multiline** "
"comment syntax and must use **two** leading asterisks (``/**``) instead of "
"just one (``/*``):"
msgstr ""
"Крім того, ви можете використовувати коментарі до документації, які "
"відображаються в інспекторі під час наведення курсора на параметр шейдера. "
"Коментарі до документації наразі підтримуються лише тоді, коли вони "
"розміщені безпосередньо над декларацією ``uniform``. Ці коментарі "
"документації підтримують лише синтаксис **багаторядкових** коментарів і "
"мають використовувати **дві** зірочки на початку (``/**``) замість однієї "
"(``/*``):"

msgid ""
"The asterisks on the follow-up lines are not required, but are recommended "
"as per the :ref:`doc_shaders_style_guide`. These asterisks are automatically "
"stripped by the inspector, so they won't appear in the tooltip."
msgstr ""
"Зірочки в наступних рядках не є обов’язковими, але рекомендовані відповідно "
"до :ref:`doc_shaders_style_guide`. Ці зірочки автоматично видаляються "
"інспектором, тому вони не відображатимуться у спливаючій підказці."

msgid "Casting"
msgstr "Кастинг"

msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""
"Як і в GLSL ES 3.0, неявне приведення між скалярами та векторами однакового "
"розміру, але різного типу, не допускається. Також не допускається лиття "
"типів різного розміру. Перетворення має виконуватися явно за допомогою "
"конструкторів."

msgid "Example:"
msgstr "Приклад:"

msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr ""
"Цілочисельні константи за замовчуванням мають знак, тому для перетворення в "
"беззнакові завжди потрібне приведення:"

msgid "Members"
msgstr "Члени"

msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""
"Окремі скалярні члени векторних типів доступні через елементи «x», «y», «z» "
"і «w». Крім того, використання «r», «g», «b» і «a» також працює та є "
"еквівалентним. Використовуйте те, що найкраще відповідає вашим потребам."

msgid "Constructing"
msgstr "Конструювання"

msgid "Construction of vector types must always pass:"
msgstr "Конструкція векторних типів завжди має проходити:"

msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules:"
msgstr ""
"Матриці також можуть бути побудовані з матриці іншого виміру. Є два правила:"

msgid ""
"1. If a larger matrix is constructed from a smaller matrix, the additional "
"rows and columns are set to the values they would have in an identity "
"matrix. 2. If a smaller matrix is constructed from a larger matrix, the top, "
"left submatrix of the larger matrix is used."
msgstr ""
"1. Якщо більша матриця будується з меншої матриці, додаткові рядки та "
"стовпці встановлюються на значення, які вони мали б в одиничній матриці. 2. "
"Якщо менша матриця будується з більшої матриці, використовується верхня, "
"ліва підматриця більшої матриці."

msgid "Swizzling"
msgstr "розпивання"

msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""
"Можна отримати будь-яку комбінацію компонентів у будь-якому порядку, якщо "
"результатом буде інший векторний тип (або скаляр). Це легше показати, ніж "
"пояснити:"

msgid "Precision"
msgstr "Точність"

msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr ""
"До типів даних можна додати модифікатори точності; використовуйте їх для "
"уніформ, змінних, аргументів і варіацій:"

msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""
"Використання нижчої точності для деяких операцій може пришвидшити обчислення "
"(ціною меншої точності). Це рідко потрібно у функції вершинного процесора "
"(де повна точність потрібна більшу частину часу), але часто корисно у "
"процесорі фрагментів."

msgid ""
"Some architectures (mainly mobile) can benefit significantly from this, but "
"there are downsides such as the additional overhead of conversion between "
"precisions. Refer to the documentation of the target architecture for "
"further information. In many cases, mobile drivers cause inconsistent or "
"unexpected behavior and it is best to avoid specifying precision unless "
"necessary."
msgstr ""
"Деякі архітектури (головним чином мобільні) можуть отримати значну користь "
"від цього, але є недоліки, такі як додаткові накладні витрати на "
"перетворення між точністю. Для отримання додаткової інформації зверніться до "
"документації цільової архітектури. У багатьох випадках мобільні драйвери "
"спричиняють неузгоджену або неочікувану поведінку, тому краще уникати "
"вказівки точності, якщо це не необхідно."

msgid "Arrays"
msgstr "Масиви"

msgid "Arrays are containers for multiple variables of a similar type."
msgstr "Масиви — це контейнери для кількох змінних подібного типу."

msgid "Local arrays"
msgstr "Локальні масиви"

msgid ""
"Local arrays are declared in functions. They can use all of the allowed "
"datatypes, except samplers. The array declaration follows a C-style syntax: "
"``[const] + [precision] + typename + identifier + [array size]``."
msgstr ""
"Локальні масиви оголошуються у функціях. Вони можуть використовувати всі "
"дозволені типи даних, крім семплерів. Оголошення масиву відповідає "
"синтаксису стилю C: ``[const] + [precision] + typename + identifier + [array "
"size]``."

msgid "They can be initialized at the beginning like:"
msgstr "Їх можна ініціалізувати на початку так:"

msgid ""
"You can declare multiple arrays (even with different sizes) in one "
"expression:"
msgstr ""
"Ви можете оголосити кілька масивів (навіть із різними розмірами) в одному "
"виразі:"

msgid "To access an array element, use the indexing syntax:"
msgstr ""
"Щоб отримати доступ до елемента масиву, використовуйте синтаксис "
"індексування:"

msgid ""
"Arrays also have a built-in function ``.length()`` (not to be confused with "
"the built-in ``length()`` function). It doesn't accept any parameters and "
"will return the array's size."
msgstr ""
"Масиви також мають вбудовану функцію ``.length()`` (не плутати з вбудованою "
"функцією ``length()``). Він не приймає жодних параметрів і повертає розмір "
"масиву."

msgid ""
"If you use an index either below 0 or greater than array size - the shader "
"will crash and break rendering. To prevent this, use ``length()``, ``if``, "
"or ``clamp()`` functions to ensure the index is between 0 and the array's "
"length. Always carefully test and check your code. If you pass a constant "
"expression or a number, the editor will check its bounds to prevent this "
"crash."
msgstr ""
"Якщо ви використовуєте індекс, менший за 0 або більший за розмір масиву, "
"шейдер вийде з ладу та порушить рендеринг. Щоб запобігти цьому, "
"використовуйте функції ``length()``, ``if`` або ``clamp()``, щоб "
"переконатися, що індекс знаходиться між 0 і довжиною масиву. Завжди ретельно "
"перевіряйте свій код. Якщо ви передаєте постійний вираз або число, редактор "
"перевірить його межі, щоб запобігти цьому збою."

msgid "Global arrays"
msgstr "Глобальні масиви"

msgid "You can declare arrays at global space like:"
msgstr "Ви можете оголошувати масиви в глобальному просторі так:"

msgid ""
"Global arrays have to be declared as global constants, otherwise they can be "
"declared the same as local arrays."
msgstr ""
"Глобальні масиви мають бути оголошені як глобальні константи, інакше вони "
"можуть бути оголошені так само, як локальні масиви."

msgid "Constants"
msgstr "Константи"

msgid ""
"Use the ``const`` keyword before the variable declaration to make that "
"variable immutable, which means that it cannot be modified. All basic types, "
"except samplers can be declared as constants. Accessing and using a constant "
"value is slightly faster than using a uniform. Constants must be initialized "
"at their declaration."
msgstr ""
"Використовуйте ключове слово ``const`` перед оголошенням змінної, щоб "
"зробити цю змінну незмінною, що означає, що її неможливо змінити. Усі "
"основні типи, крім семплерів, можуть бути оголошені як константи. Доступ і "
"використання постійного значення відбувається трохи швидше, ніж використання "
"уніформи. Константи повинні бути ініціалізовані при їх оголошенні."

msgid ""
"Constants cannot be modified and additionally cannot have hints, but "
"multiple of them (if they have the same type) can be declared in a single "
"expression e.g"
msgstr ""
"Константи не можна змінювати та додатково не можуть мати підказки, але "
"декілька з них (якщо вони мають той самий тип) можуть бути оголошені в "
"одному виразі, наприклад"

msgid "Similar to variables, arrays can also be declared with ``const``."
msgstr ""
"Подібно до змінних, масиви також можна оголошувати за допомогою ``const``."

msgid ""
"Constants can be declared both globally (outside of any function) or locally "
"(inside a function). Global constants are useful when you want to have "
"access to a value throughout your shader that does not need to be modified. "
"Like uniforms, global constants are shared between all shader stages, but "
"they are not accessible outside of the shader."
msgstr ""
"Константи можна оголошувати як глобально (поза будь-якою функцією), так і "
"локально (всередині функції). Глобальні константи корисні, коли ви хочете "
"мати доступ до значення в шейдері, яке не потрібно змінювати. Як і уніформи, "
"глобальні константи є спільними для всіх етапів шейдера, але вони недоступні "
"поза шейдером."

msgid ""
"Constants of the ``float`` type must be initialized using ``.`` notation "
"after the decimal part or by using the scientific notation. The optional "
"``f`` post-suffix is also supported."
msgstr ""
"Константи типу ``float`` необхідно ініціалізувати за допомогою нотації ``.`` "
"після десяткової частини або за допомогою наукової нотації. Також "
"підтримується додатковий пост-суфікс ``f``."

msgid ""
"Constants of the ``uint`` (unsigned int) type must have a ``u`` suffix to "
"differentiate them from signed integers. Alternatively, this can be done by "
"using the ``uint(x)`` built-in conversion function."
msgstr ""
"Константи типу ``uint`` (unsigned int) повинні мати суфікс ``u``, щоб "
"відрізнити їх від цілих чисел зі знаком. Крім того, це можна зробити за "
"допомогою вбудованої функції перетворення ``uint(x)``."

msgid "Structs"
msgstr "Структури"

msgid ""
"Structs are compound types which can be used for better abstraction of "
"shader code. You can declare them at the global scope like:"
msgstr ""
"Структури — це складені типи, які можна використовувати для кращої "
"абстракції шейдерного коду. Ви можете оголосити їх у глобальній області "
"видимості, наприклад:"

msgid "After declaration, you can instantiate and initialize them like:"
msgstr ""
"Після оголошення ви можете створювати екземпляри та ініціалізувати їх так:"

msgid "Or use struct constructor for same purpose:"
msgstr "Або використовуйте конструктор структур для тієї ж мети:"

msgid ""
"Structs may contain other struct or array, you can also instance them as "
"global constant:"
msgstr ""
"Структури можуть містити інші структури або масиви, ви також можете створити "
"їх як глобальну константу:"

msgid "You can also pass them to functions:"
msgstr "Ви також можете передати їх функціям:"

msgid "Operators"
msgstr "Оператори"

msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""
"Мова затінення Godot підтримує той самий набір операторів, що й GLSL ES 3.0. "
"Нижче наведено їх список у порядку пріоритету:"

msgid "Precedence"
msgstr "Пріоритет"

msgid "Class"
msgstr "Клас"

msgid "Operator"
msgstr "Оператор"

msgid "1 (highest)"
msgstr "1 (найвищий)"

msgid "parenthetical grouping"
msgstr "групування за допомогою дужок"

msgid "**()**"
msgstr "**()**"

msgid "2"
msgstr "2"

msgid "unary"
msgstr "унарні"

msgid "**+, -, !, ~**"
msgstr "**+, -, !, ~**"

msgid "3"
msgstr "3"

msgid "multiplicative"
msgstr "мультиплікативні"

msgid "**/, \\*, %**"
msgstr "**/, \\*, %**"

msgid "4"
msgstr "4"

msgid "additive"
msgstr "адитивні"

msgid "**+, -**"
msgstr "**+, -**"

msgid "5"
msgstr "5"

msgid "bit-wise shift"
msgstr "зсув за бітами"

msgid "**<<, >>**"
msgstr "**<<, >>**"

msgid "6"
msgstr "6"

msgid "relational"
msgstr "реляційні"

msgid "**<, >, <=, >=**"
msgstr "**<, >, <=, >=**"

msgid "7"
msgstr "7"

msgid "equality"
msgstr "рівність"

msgid "**==, !=**"
msgstr "**==, !=**"

msgid "8"
msgstr "8"

msgid "bit-wise AND"
msgstr "побітове І"

msgid "**&**"
msgstr "**&**"

msgid "9"
msgstr "9"

msgid "bit-wise exclusive OR"
msgstr "побітове виключаюче АБО"

msgid "**^**"
msgstr "**^**"

msgid "10"
msgstr "10"

msgid "bit-wise inclusive OR"
msgstr "побітове включне АБО"

msgid "**|**"
msgstr "**|**"

msgid "11"
msgstr "11"

msgid "logical AND"
msgstr "логічне І"

msgid "**&&**"
msgstr "**&&**"

msgid "12 (lowest)"
msgstr "12 (найнижчий)"

msgid "logical inclusive OR"
msgstr "логічне включне АБО"

msgid "**||**"
msgstr "**||**"

msgid "Flow control"
msgstr "Контроль потоку"

msgid "Godot Shading language supports the most common types of flow control:"
msgstr "Мова затінення Godot підтримує найпоширеніші типи керування потоком:"

msgid ""
"Keep in mind that in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""
"Майте на увазі, що в сучасних графічних процесорах може існувати "
"нескінченний цикл, який може заморозити вашу програму (включаючи редактор). "
"Годо не може захистити вас від цього, тому будьте обережні, щоб не зробити "
"цю помилку!"

msgid ""
"Also, when comparing floating-point values against a number, make sure to "
"compare them against a *range* instead of an exact number."
msgstr ""
"Крім того, порівнюючи значення з плаваючою комою з числом, переконайтеся, що "
"порівнюєте їх із *діапазоном* замість точного числа."

msgid ""
"A comparison like ``if (value == 0.3)`` may not evaluate to ``true``. "
"Floating-point math is often approximate and can defy expectations. It can "
"also behave differently depending on the hardware."
msgstr ""
"Порівняння на кшталт «if (value == 0.3)» може не мати значення «true». "
"Математика з плаваючою комою часто є приблизною і може не відповідати "
"очікуванням. Він також може поводитися по-різному залежно від апаратного "
"забезпечення."

msgid "**Don't** do this."
msgstr "**Не** роби цього."

msgid ""
"Instead, always perform a range comparison with an epsilon value. The larger "
"the floating-point number (and the less precise the floating-point number), "
"the larger the epsilon value should be."
msgstr ""
"Замість цього завжди виконуйте порівняння діапазону зі значенням епсилон. "
"Чим більше число з плаваючою комою (і чим менш точне число з плаваючою "
"комою), тим більшим має бути значення епсилон."

msgid ""
"See `floating-point-gui.de <https://floating-point-gui.de/>`__ for more "
"information."
msgstr ""
"Перегляньте `floating-point-gui.de <https://floating-point-gui.de/>`__ для "
"отримання додаткової інформації."

msgid "Discarding"
msgstr "Відкидання"

msgid ""
"Fragment and light functions can use the ``discard`` keyword. If used, the "
"fragment is discarded and nothing is written."
msgstr ""
"Функції фрагментів і легких можуть використовувати ключове слово "
"``discard``. Якщо використовується, фрагмент відкидається, і нічого не "
"записується."

msgid ""
"Beware that ``discard`` has a performance cost when used, as it will prevent "
"the depth prepass from being effective on any surfaces using the shader. "
"Also, a discarded pixel still needs to be rendered in the vertex shader, "
"which means a shader that uses ``discard`` on all of its pixels is still "
"more expensive to render compared to not rendering any object in the first "
"place."
msgstr ""
"Майте на увазі, що ``відкинути`` має витрати на продуктивність у разі "
"використання, оскільки це запобігає ефективності попереднього проходу "
"глибини на будь-яких поверхнях, де використовується шейдер. Крім того, "
"відкинутий піксель все ще потребує візуалізації у вершинному шейдері, що "
"означає, що шейдер, який використовує ``discard`` для всіх своїх пікселів, "
"все ще дорожчий для візуалізації порівняно з тим, що спочатку не візуалізує "
"жодного об’єкта."

msgid "Functions"
msgstr "Функції"

msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr ""
"У шейдері Годо можна визначати функції. Вони використовують такий синтаксис:"

msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them. Redefining a function "
"that has already been defined above (or is a built-in function name) will "
"cause an error."
msgstr ""
"Ви можете використовувати лише ті функцією, які були визначені вище (вищі в "
"редакторі) функцію, з якої ви їх викликає. Перевизначення функції, яка вже "
"була визначена вище (або ім’я вбудованої функція), спричинить помилку."

msgid "Function arguments can have special qualifiers:"
msgstr "Аргументи функції можуть мати спеціальні кваліфікатори:"

msgid "**in**: Means the argument is only for reading (default)."
msgstr "**in**: означає, що аргумент лише для читання (за замовчуванням)."

msgid "**out**: Means the argument is only for writing."
msgstr "**out**: означає, що аргумент призначений лише для запису."

msgid "**inout**: Means the argument is fully passed via reference."
msgstr "**введення**: означає, що аргумент повністю передається за посиланням."

msgid ""
"**const**: Means the argument is a constant and cannot be changed, may be "
"combined with **in** qualifier."
msgstr ""
"**const**: означає, що аргумент є константою і не може бути змінений, може "
"поєднуватися з кваліфікатором **in**."

msgid "Example below:"
msgstr "Приклад нижче:"

msgid ""
"Unlike GLSL, Godot's shader language does **not** support function "
"overloading. This means that a function cannot be defined several times with "
"different argument types or numbers of arguments. As a workaround, use "
"different names for functions that accept a different number of arguments or "
"arguments of different types."
msgstr ""
"На відміну від GLSL, мова шейдерів Godot **не** підтримує перевантаження "
"функцій. Це означає, що функція не може бути визначена кілька разів з "
"різними типами аргументів або кількістю аргументів. Як обхідний шлях "
"використовуйте різні імена для функцій, які приймають різну кількість "
"аргументів або аргументи різних типів."

msgid "Varyings"
msgstr "варіювання"

msgid ""
"To send data from the vertex to the fragment (or light) processor function, "
"*varyings* are used. They are set for every primitive vertex in the *vertex "
"processor*, and the value is interpolated for every pixel in the *fragment "
"processor*."
msgstr ""
"Щоб відправити дані з вершини до функції процесора фрагмента (або світла), "
"використовуються *variyings*. Вони встановлюються для кожної примітивної "
"вершини в *процесорі вершин*, а значення інтерполюється для кожного пікселя "
"в *процесорі фрагментів*."

msgid "Varying can also be an array:"
msgstr "Варіант також може бути масивом:"

msgid ""
"It's also possible to send data from *fragment* to *light* processors using "
"*varying* keyword. To do so you can assign it in the *fragment* and later "
"use it in the *light* function."
msgstr ""
"Також можна надсилати дані від *fragment* до *light* процесорів за допомогою "
"ключового слова *varying*. Для цього ви можете призначити його у *фрагменті* "
"і пізніше використати у функції *light*."

msgid ""
"Note that varying may not be assigned in custom functions or a *light "
"processor* function like:"
msgstr ""
"Зауважте, що варіювання не може бути призначено в спеціальних функціях або "
"функції *легкого процесора*, наприклад:"

msgid ""
"This limitation was introduced to prevent incorrect usage before "
"initialization."
msgstr ""
"Це обмеження було введено, щоб запобігти неправильному використанню до "
"ініціалізації."

msgid "Interpolation qualifiers"
msgstr "Класифікатори інтерполяції"

msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr ""
"Певні значення інтерполюються під час конвеєра затінення. Ви можете змінити "
"спосіб виконання цих інтерполяцій за допомогою *кваліфікаторів інтерполяції*."

msgid "There are two possible interpolation qualifiers:"
msgstr "Є два можливі кваліфікатори інтерполяції:"

msgid "Qualifier"
msgstr "Кваліфікатор"

msgid "**flat**"
msgstr "Нейтральний"

msgid "The value is not interpolated."
msgstr "Значення не інтерполюється."

msgid "**smooth**"
msgstr "Згладжування"

msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr ""
"Значення інтерполюється у правильному для перспективи режимі. Це значення за "
"умовчанням."

msgid "Uniforms"
msgstr "Уніформа"

msgid ""
"Passing values to shaders is possible. These are global to the whole shader "
"and are called *uniforms*. When a shader is later assigned to a material, "
"the uniforms will appear as editable parameters in it. Uniforms can't be "
"written from within the shader."
msgstr ""
"Можлива передача значень шейдерам. Вони є глобальними для всього шейдера і "
"називаються *уніформами*. Коли шейдер пізніше буде призначено для матеріалу, "
"уніформа з’явиться в ньому як редаговані параметри. Уніформу не можна "
"написати з шейдера."

msgid ""
"You can set uniforms in the editor in the material. Or you can set them "
"through GDScript:"
msgstr ""
"Ви можете встановити форму в редакторі в матеріалі. Або ви можете встановити "
"їх через GDScript:"

msgid ""
"The first argument to ``set_shader_parameter`` is the name of the uniform in "
"the shader. It must match *exactly* to the name of the uniform in the shader "
"or else it will not be recognized."
msgstr ""
"Першим аргументом ``set_shader_parameter`` є назва уніформи в шейдері. Воно "
"має *точно* збігатися з назвою уніформи в шейдері, інакше його не буде "
"розпізнано."

msgid ""
"Any GLSL type except for *void* can be a uniform. Additionally, Godot "
"provides optional shader hints to make the compiler understand for what the "
"uniform is used, and how the editor should allow users to modify it."
msgstr ""
"Будь-який тип GLSL, крім *void*, може бути єдиним. Крім того, Godot надає "
"додаткові підказки щодо шейдерів, щоб компілятор міг зрозуміти, для чого "
"використовується уніформа та як редактор має дозволяти користувачам її "
"змінювати."

msgid ""
"It's important to understand that textures *that are supplied as color* "
"require hints for proper sRGB -> linear conversion (i.e. ``source_color``), "
"as Godot's 3D engine renders in linear color space. If this is not done, the "
"texture will appear washed out."
msgstr ""
"Важливо розуміти, що текстури, *які постачаються як колір*, вимагають "
"підказок для належного sRGB -> лінійного перетворення (тобто "
"``source_color``), оскільки 3D-механізм Godot відображає в лінійному "
"просторі кольорів. Якщо цього не зробити, текстура буде виглядати розмитою."

msgid ""
"The 2D renderer also renders in linear color space if the **Rendering > "
"Viewport > HDR 2D** project setting is enabled, so ``source_color`` must "
"also be used in ``canvas_item`` shaders. If 2D HDR is disabled, "
"``source_color`` will keep working correctly in ``canvas_item`` shaders, so "
"it's recommend to use it either way."
msgstr ""
"Засіб 2D візуалізації також виконує візуалізацію в лінійному колірному "
"просторі, якщо ввімкнено параметр проекту **Rendering > Viewport > HDR 2D**, "
"тому ``source_color`` також має використовуватися в шейдерах "
"``canvas_item``. Якщо 2D HDR вимкнено, ``source_color`` працюватиме належним "
"чином у шейдерах ``canvas_item``, тому рекомендується використовувати його в "
"будь-якому випадку."

msgid "Full list of hints below:"
msgstr "Повний список підказок нижче:"

msgid "Hint"
msgstr "Підказка"

msgid "**vec3, vec4**"
msgstr "**Vec3, vec4**"

msgid "source_color"
msgstr "source_color"

msgid "Used as color."
msgstr "Використовується як колір."

msgid "**int, float**"
msgstr "**int, float**"

msgid "hint_range(min, max[, step])"
msgstr "Hint_range(min, max[, step])"

msgid "Restricted to values in a range (with min/max/step)."
msgstr "Обмежується значеннями в діапазоні (з min/max/кроком)."

msgid "Used as albedo color."
msgstr "Використовується як колір альбедо."

msgid "hint_normal"
msgstr "Hint_normal"

msgid "Used as normalmap."
msgstr "Використовується як normalmap."

msgid "hint_default_white"
msgstr "Hint_default_white"

msgid "As value or albedo color, default to opaque white."
msgstr "Як значення або колір альбедо, за замовчуванням непрозорий білий."

msgid "hint_default_black"
msgstr "Hint_default_black"

msgid "As value or albedo color, default to opaque black."
msgstr "Як значення або колір альбедо за замовчуванням непрозорий чорний."

msgid "hint_default_transparent"
msgstr "Hint_default_transparent"

msgid "As value or albedo color, default to transparent black."
msgstr "Як значення або колір альбедо, за замовчуванням прозорий чорний."

msgid "hint_anisotropy"
msgstr "Hint_anisotropy"

msgid "As flowmap, default to right."
msgstr "Як схема потоку, за замовчуванням праворуч."

msgid "hint_roughness[_r, _g, _b, _a, _normal, _gray]"
msgstr "Hint_roughness[_r, _g, _b, _a, _normal, _gray]"

msgid ""
"Used for roughness limiter on import (attempts reducing specular aliasing). "
"``_normal`` is a normal map that guides the roughness limiter, with "
"roughness increasing in areas that have high-frequency detail."
msgstr ""
"Використовується для обмежувача шорсткості під час імпорту (спроби зменшити "
"дзеркальне згладжування). ``_normal`` — це карта нормалей, яка керує "
"обмежувачем шорсткості, із збільшенням шорсткості в областях із "
"високочастотними деталями."

msgid "filter[_nearest, _linear][_mipmap][_anisotropic]"
msgstr "Filter[_nearest, _linear][_mipmap][_anisotropic]"

msgid "Enabled specified texture filtering."
msgstr "Увімкнено фільтрацію заданої текстури."

msgid "repeat[_enable, _disable]"
msgstr "repeat[_enable, _disable]"

msgid "Enabled texture repeating."
msgstr "Увімкнено повторення текстури."

msgid "hint_screen_texture"
msgstr "hint_screen_texture"

msgid "Texture is the screen texture."
msgstr "Текстура — це текстура екрана."

msgid "hint_depth_texture"
msgstr "hint_depth_texture"

msgid "Texture is the depth texture."
msgstr "Текстура — це текстура глибини."

msgid "hint_normal_roughness_texture"
msgstr "hint_normal_roughness_texture"

msgid "Texture is the normal roughness texture (only supported in Forward+)."
msgstr ""
"Текстура — це звичайна текстура шорсткості (підтримується лише у Forward+)."

msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""
"GDScript використовує інші типи змінних, ніж GLSL, тому, коли передаються "
"змінні з GDScript у шейдери, Godot автоматично перетворює тип. Нижче "
"наведено таблицю відповідних типів:"

msgid "GLSL type"
msgstr "Тип GLSL"

msgid "GDScript type"
msgstr "Тип GDScript"

msgid "Notes"
msgstr "Нотатки"

msgid "Bitwise packed int where bit 0 (LSB) corresponds to x."
msgstr "Побітово упаковане int, де біт 0 (LSB) відповідає x."

msgid "For example, a bvec2 of (bx, by) could be created in the following way:"
msgstr "Наприклад, bvec2 з (bx, by) можна створити таким чином:"

msgid "**Vector2i**"
msgstr "**Vector2i**"

msgid "**Vector3i**"
msgstr "**Vector3i**"

msgid "**Vector4i**"
msgstr "**Vector4i**"

msgid "**Vector2**"
msgstr "**Vector2**"

msgid "**Vector3**, **Color**"
msgstr "**Vector3**, **Color**"

msgid "When Color is used, it will be interpreted as (r, g, b)."
msgstr "Коли використовується Колір, він інтерпретуватиметься як (r, g, b)."

msgid "**Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"
msgstr "**vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"

msgid "When Color is used, it will be interpreted as (r, g, b, a)."
msgstr "Коли використовується Колір, він інтерпретуватиметься як (r, g, b, a)."

msgid ""
"When Rect2 is used, it will be interpreted as (position.x, position.y, size."
"x, size.y)."
msgstr ""
"Коли використовується Rect2, він інтерпретуватиметься як (position.x, "
"position.y, size.x, size.y)."

msgid ""
"When Plane is used it will be interpreted as (normal.x, normal.y, normal.z, "
"d)."
msgstr ""
"Коли використовується площина, це буде інтерпретовано як (normal.x, normal."
"y, normal.z, d)."

msgid "**Transform2D**"
msgstr "**transform2D**"

msgid "**Basis**"
msgstr "**Основа**"

msgid "**Projection**, **Transform3D**"
msgstr "**projection**, **Transform3D**"

msgid "When a Transform3D is used, the w Vector is set to the identity."
msgstr ""
"Коли використовується Transform3D, вектор w встановлюється на ідентичність."

msgid "**Texture2D**"
msgstr "**texture2D**"

msgid "**Texture2DArray**"
msgstr "**texture2DArray**"

msgid "**Texture3D**"
msgstr "**texture3D**"

msgid "**Cubemap**"
msgstr "**cubemap**"

msgid "**CubemapArray**"
msgstr "**Cubemap Array**"

msgid ""
"Be careful when setting shader uniforms from GDScript, no error will be "
"thrown if the type does not match. Your shader will just exhibit undefined "
"behavior."
msgstr ""
"Будьте обережні, встановлюючи форму шейдера з GDScript, помилка не буде "
"видана, якщо тип не збігається. Ваш шейдер просто демонструватиме "
"невизначену поведінку."

msgid "Uniforms can also be assigned default values:"
msgstr "Уніформі також можна призначити значення за замовчуванням:"

msgid ""
"Note that when adding a default value and a hint, the default value goes "
"after the hint."
msgstr ""
"Зауважте, що при додаванні значення за замовчуванням і підказки значення за "
"замовчуванням йде після підказки."

msgid ""
"If you need to make multiple uniforms to be grouped in the specific category "
"of an inspector, you can use a `group_uniform` keyword like:"
msgstr ""
"Якщо вам потрібно створити кілька уніформ, які будуть згруповані в конкретну "
"категорію інспектора, ви можете використати ключове слово `group_uniform`, "
"наприклад:"

msgid "You can close the group by using:"
msgstr "Закрити групу можна за допомогою:"

msgid ""
"The syntax also supports subgroups (it's not mandatory to declare the base "
"group before this):"
msgstr ""
"Синтаксис також підтримує підгрупи (необов’язково оголошувати базову групу "
"перед цим):"

msgid "Global uniforms"
msgstr "Глобальна уніформа"

msgid ""
"Sometimes, you want to modify a parameter in many different shaders at once. "
"With a regular uniform, this takes a lot of work as all these shaders need "
"to be tracked and the uniform needs to be set for each of them. Global "
"uniforms allow you to create and update uniforms that will be available in "
"all shaders, in every shader type (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` and ``fog``)."
msgstr ""
"Іноді потрібно змінити параметр у багатьох різних шейдерах одночасно. Зі "
"звичайною уніформою це потребує багато роботи, оскільки всі ці шейдери "
"потрібно відстежувати та налаштовувати уніформу для кожного з них. Глобальні "
"уніформи дозволяють створювати та оновлювати уніформи, які будуть доступні в "
"усіх шейдерах, у кожному типі шейдерів (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` і ``fog``)."

msgid ""
"Global uniforms are especially useful for environmental effects that affect "
"many objects in a scene, like having foliage bend when the player is nearby, "
"or having objects move with the wind."
msgstr ""
"Глобальна уніформа особливо корисна для наслідків навколишнього середовища, "
"які впливають на багато об’єктів у сцені, як-от згинання листя, коли гравець "
"знаходиться поруч, або рух об’єктів з вітром."

msgid ""
"To create a global uniform, open the **Project Settings** then go to the "
"**Shader Globals** tab. Specify a name for the uniform (case-sensitive) and "
"a type, then click **Add** in the top-right corner of the dialog. You can "
"then edit the value assigned to the uniform by clicking the value in the "
"list of uniforms:"
msgstr ""
"Щоб створити глобальну уніформу, відкрийте **Налаштування проекту**, а потім "
"перейдіть на вкладку **Глобальні шейдери**. Укажіть назву для форми (з "
"урахуванням регістру) і тип, а потім натисніть **Додати** у верхньому "
"правому куті діалогового вікна. Потім ви можете змінити значення, призначене "
"уніформі, клацнувши значення у списку уніформи:"

msgid ""
"Adding a global uniform in the Shader Globals tab of the Project Settings"
msgstr ""
"Додавання глобальної уніформи на вкладці Shader Globals у налаштуваннях "
"проекту"

msgid "After creating a global uniform, you can use it in a shader as follows:"
msgstr ""
"Після створення глобальної форми ви можете використовувати її в шейдері "
"таким чином:"

msgid ""
"Note that the global uniform *must* exist in the Project Settings at the "
"time the shader is saved, or compilation will fail. While you can assign a "
"default value using ``global uniform vec4 my_color = ...`` in the shader "
"code, it will be ignored as the global uniform must always be defined in the "
"Project Settings anyway."
msgstr ""
"Зауважте, що глобальна уніформа *повинна* існувати в налаштуваннях проекту "
"на момент збереження шейдера, інакше компіляція не вдасться. Хоча ви можете "
"призначити значення за замовчуванням за допомогою ``global uniform vec4 "
"my_color = ...`` у коді шейдера, воно буде проігноровано, оскільки глобальна "
"уніформа все одно має бути визначена в налаштуваннях проекту."

msgid ""
"To change the value of a global uniform at run-time, use the :ref:"
"`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` method in a "
"script:"
msgstr ""
"Щоб змінити значення глобальної форми під час виконання, використовуйте "
"метод :ref:`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` у сценарії:"

msgid ""
"Assigning global uniform values can be done as many times as desired without "
"impacting performance, as setting data doesn't require synchronization "
"between the CPU and GPU."
msgstr ""
"Призначення глобальних уніфікованих значень можна виконувати скільки "
"завгодно разів без впливу на продуктивність, оскільки дані налаштувань не "
"вимагають синхронізації між ЦП і ГП."

msgid "You can also add or remove global uniforms at run-time:"
msgstr ""
"Ви також можете додавати або видаляти глобальні уніформи під час виконання:"

msgid ""
"Adding or removing global uniforms at run-time has a performance cost, "
"although it's not as pronounced compared to getting global uniform values "
"from a script (see the warning below)."
msgstr ""
"Додавання або видалення глобальних уніфікованих значень під час виконання "
"має втрату продуктивності, хоча вона не така виражена порівняно з отриманням "
"глобальних уніфікованих значень зі сценарію (див. попередження нижче)."

msgid ""
"While you *can* query the value of a global uniform at run-time in a script "
"using ``RenderingServer.global_shader_parameter_get(\"uniform_name\")``, "
"this has a large performance penalty as the rendering thread needs to "
"synchronize with the calling thread."
msgstr ""
"Хоча ви *можете* запитувати значення глобальної уніформи під час виконання в "
"сценарії за допомогою ``RenderingServer."
"global_shader_parameter_get(\"uniform_name\")``, це має значне зниження "
"продуктивності, оскільки потік рендерингу повинен синхронізуватися з потоком "
"виклику ."

msgid ""
"Therefore, it's not recommended to read global shader uniform values "
"continuously in a script. If you need to read values in a script after "
"setting them, consider creating an :ref:`autoload <doc_singletons_autoload>` "
"where you store the values you need to query at the same time you're setting "
"them as global uniforms."
msgstr ""
"Тому не рекомендується безперервно зчитувати стандартні значення глобального "
"шейдера в сценарії. Якщо вам потрібно прочитати значення в сценарії після їх "
"встановлення, розгляньте можливість створення :ref:`autoload "
"<doc_singletons_autoload>`, де ви зберігаєте значення, які вам потрібно "
"запитати, одночасно встановлюючи їх як глобальні уніфіковані."

msgid "Per-instance uniforms"
msgstr "Поінстанційний уніформа"

msgid "Per-instance uniforms are only available in ``spatial`` (3D) shaders."
msgstr ""
"Уніформи для екземплярів доступні лише в ``просторових`` (3D) шейдерах."

msgid ""
"Per-instance uniforms are not supported when using the Compatibility "
"renderer."
msgstr ""
"Уніформи для кожного екземпляра не підтримуються під час використання засобу "
"відтворення сумісності."

msgid ""
"Sometimes, you want to modify a parameter on each node using the material. "
"As an example, in a forest full of trees, when you want each tree to have a "
"slightly different color that is editable by hand. Without per-instance "
"uniforms, this requires creating a unique material for each tree (each with "
"a slightly different hue). This makes material management more complex, and "
"also has a performance overhead due to the scene requiring more unique "
"material instances. Vertex colors could also be used here, but they'd "
"require creating unique copies of the mesh for each different color, which "
"also has a performance overhead."
msgstr ""
"Іноді потрібно змінити параметр на кожному вузлі за допомогою матеріалу. Як "
"приклад, у лісі, повному дерев, коли ви хочете, щоб кожне дерево мало дещо "
"інший колір, який можна редагувати вручну. Без уніформи для кожного "
"екземпляра це вимагає створення унікального матеріалу для кожного дерева "
"(кожне з дещо іншим відтінком). Це робить керування матеріалами більш "
"складним, а також має накладні витрати на продуктивність через сцену, яка "
"вимагає більше унікальних екземплярів матеріалу. Тут також можна "
"використовувати кольори вершин, але вони потребуватимуть створення "
"унікальних копій сітки для кожного окремого кольору, що також має накладні "
"витрати на продуктивність."

msgid ""
"Per-instance uniforms are set on each GeometryInstance3D, rather than on "
"each Material instance. Take this into account when working with meshes that "
"have multiple materials assigned to them, or MultiMesh setups."
msgstr ""
"Уніформи для кожного екземпляра встановлюються для кожного "
"GeometryInstance3D, а не для кожного екземпляра Material. Візьміть це до "
"уваги під час роботи з сітками, яким призначено кілька матеріалів, або "
"налаштуваннями MultiMesh."

msgid ""
"After saving the shader, you can change the per-instance uniform's value "
"using the inspector:"
msgstr ""
"Після збереження шейдера ви можете змінити значення уніформи для кожного "
"екземпляра за допомогою інспектора:"

msgid ""
"Setting a per-instance uniform's value in the GeometryInstance3D section of "
"the inspector"
msgstr ""
"Встановлення значення уніформи для кожного екземпляра в розділі "
"GeometryInstance3D інспектора"

msgid ""
"Per-instance uniform values can also be set at run-time using :ref:"
"`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` method on a "
"node that inherits from :ref:`class_GeometryInstance3D`:"
msgstr ""
"Уніфіковані значення для кожного екземпляра також можна встановити під час "
"виконання за допомогою методу :ref:`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` на вузлі, "
"який успадковує від :ref:`class_GeometryInstance3D`:"

msgid ""
"When using per-instance uniforms, there are some restrictions you should be "
"aware of:"
msgstr ""
"Під час використання уніформи для окремих інстанцій є деякі обмеження, про "
"які вам слід знати:"

msgid ""
"**Per-instance uniforms do not support textures**, only regular scalar and "
"vector types. As a workaround, you can pass a texture array as a regular "
"uniform, then pass the index of the texture to be drawn using a per-instance "
"uniform."
msgstr ""
"**Уніформи для кожного екземпляра не підтримують текстури**, лише звичайні "
"скалярні та векторні типи. Як обхідний шлях, ви можете передати масив "
"текстур як звичайну уніформу, а потім передати індекс текстури, яку потрібно "
"намалювати, використовуючи уніформу для кожного екземпляра."

msgid "There is a practical maximum limit of 16 instance uniforms per shader."
msgstr ""
"Практичний максимальний ліміт становить 16 екземплярів уніформи на шейдер."

msgid ""
"If your mesh uses multiple materials, the parameters for the first mesh "
"material found will \"win\" over the subsequent ones, unless they have the "
"same name, index *and* type. In this case, all parameters are affected "
"correctly."
msgstr ""
"Якщо ваша сітка використовує кілька матеріалів, параметри для першого "
"знайденого матеріалу сітки «переможуть» над наступними, якщо вони не мають "
"однакові ім’я, індекс *і* тип. У цьому випадку всі параметри впливають "
"правильно."

msgid ""
"If you run into the above situation, you can avoid clashes by manually "
"specifying the index (0-15) of the instance uniform by using the "
"``instance_index`` hint:"
msgstr ""
"Якщо ви зіткнетеся з наведеною вище ситуацією, ви можете уникнути "
"конфліктів, вказавши вручну індекс (0-15) екземпляра uniform за допомогою "
"підказки ``instance_index``:"

msgid "Built-in variables"
msgstr "Вбудовані змінні"

msgid ""
"A large number of built-in variables are available, like ``UV``, ``COLOR`` "
"and ``VERTEX``. What variables are available depends on the type of shader "
"(``spatial``, ``canvas_item`` or ``particle``) and the function used "
"(``vertex``, ``fragment`` or ``light``). For a list of the built-in "
"variables that are available, please see the corresponding pages:"
msgstr ""
"Доступна велика кількість вбудованих змінних, таких як ``UV``, ``COLOR`` і "
"``VERTEX``. Доступні змінні залежать від типу шейдера (``spatial``, "
"``canvas_item`` або ``particle``) і використовувану функцію (``вершина``, "
"``фрагмент`` або ``світло``). Перелік доступних вбудованих змінних див. на "
"відповідних сторінках:"

msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr ":ref:`Spatial shaders <doc_spatial_shader>`"

msgid ":ref:`Canvas item shaders <doc_canvas_item_shader>`"
msgstr ":ref:`Canvas item shaders <doc_canvas_item_shader>`"

msgid ":ref:`Particle shaders <doc_particle_shader>`"
msgstr ":ref:`Particle shaders <doc_particle_shader>`"

msgid ":ref:`Sky shaders <doc_sky_shader>`"
msgstr ":ref:`Sky shaders <doc_sky_shader>`"

msgid ":ref:`Fog shaders <doc_fog_shader>`"
msgstr ":ref:`Fog shaders <doc_fog_shader>`"

msgid "Built-in functions"
msgstr "Вбудовані функції"

msgid ""
"A large number of built-in functions are supported, conforming to GLSL ES "
"3.0. When vec_type (float), vec_int_type, vec_uint_type, vec_bool_type "
"nomenclature is used, it can be scalar or vector."
msgstr ""
"Підтримується велика кількість вбудованих функцій, що відповідають GLSL ES "
"3.0. Якщо використовується номенклатура vec_type (float), vec_int_type, "
"vec_uint_type, vec_bool_type, вона може бути скалярною або векторною."

msgid "Function"
msgstr "Функція"

msgid "Description / Return value"
msgstr "Опис/Повернене значення"

msgid "vec_type **radians** (vec_type degrees)"
msgstr "vec_type **радіани** (vec_type градуси)"

msgid "Convert degrees to radians."
msgstr "Перетворіть градуси в радіани."

msgid "vec_type **degrees** (vec_type radians)"
msgstr "Vec_type **degrees** (vec_type radians)"

msgid "Convert radians to degrees."
msgstr "Перетворіть радіани в градуси."

msgid "vec_type **sin** (vec_type x)"
msgstr "Vec_type **sin** (vec_type x)"

msgid "Sine."
msgstr "Синус."

msgid "vec_type **cos** (vec_type x)"
msgstr "Vec_type **cos** (vec_type x)"

msgid "Cosine."
msgstr "Косинус."

msgid "vec_type **tan** (vec_type x)"
msgstr "Vec_type **tan** (vec_type x)"

msgid "Tangent."
msgstr "По дотичній."

msgid "vec_type **asin** (vec_type x)"
msgstr "Vec_type **asin** (vec_type x)"

msgid "Arcsine."
msgstr "Арксин."

msgid "vec_type **acos** (vec_type x)"
msgstr "Vec_type **acos** (vec_type x)"

msgid "Arccosine."
msgstr "Аркозин."

msgid "vec_type **atan** (vec_type y_over_x)"
msgstr "Vec_type **atan** (vec_type y_over_x)"

msgid "Arctangent."
msgstr "Арктангенс."

msgid "vec_type **atan** (vec_type y, vec_type x)"
msgstr "Vec_type **atan** (vec_type y, vec_type x)"

msgid "vec_type **sinh** (vec_type x)"
msgstr "Vec_type **sinh** (vec_type x)"

msgid "Hyperbolic sine."
msgstr "Гіперболічний синус."

msgid "vec_type **cosh** (vec_type x)"
msgstr "Vec_type **cosh** (vec_type x)"

msgid "Hyperbolic cosine."
msgstr "Гіперболічний косинус."

msgid "vec_type **tanh** (vec_type x)"
msgstr "Vec_type **tanh** (vec_type x)"

msgid "Hyperbolic tangent."
msgstr "Гіперболічний тангенс."

msgid "vec_type **asinh** (vec_type x)"
msgstr "Vec_type **asinh** (vec_type x)"

msgid "Inverse hyperbolic sine."
msgstr "Обернений гіперболічний синус."

msgid "vec_type **acosh** (vec_type x)"
msgstr "Vec_type **acosh** (vec_type x)"

msgid "Inverse hyperbolic cosine."
msgstr "Обернений гіперболічний косинус."

msgid "vec_type **atanh** (vec_type x)"
msgstr "Vec_type **atanh** (vec_type x)"

msgid "Inverse hyperbolic tangent."
msgstr "Обернена гіперболічна дотична."

msgid "vec_type **pow** (vec_type x, vec_type y)"
msgstr "Vec_type **pow** (vec_type x, vec_type y)"

msgid "Power (undefined if ``x`` < 0 or if ``x`` == 0 and ``y`` <= 0)."
msgstr "Потужність (undefined if ``x`` < 0 or if ``x`` == 0 and ``y`` <= 0)."

msgid "vec_type **exp** (vec_type x)"
msgstr "Vec_type **exp** (vec_type x)"

msgid "Base-e exponential."
msgstr "База-е експонента."

msgid "vec_type **exp2** (vec_type x)"
msgstr "Vec_type **exp2** (vec_type x)"

msgid "Base-2 exponential."
msgstr "Основа-2 експоненціальна."

msgid "vec_type **log** (vec_type x)"
msgstr "Vec_type **log** (vec_type x)"

msgid "Natural logarithm."
msgstr "Натуральний логарифм."

msgid "vec_type **log2** (vec_type x)"
msgstr "Vec_type **log2** (vec_type x)"

msgid "Base-2 logarithm."
msgstr "Логарифм з основою 2."

msgid "vec_type **sqrt** (vec_type x)"
msgstr "Vec_type **sqrt** (vec_type x)"

msgid "Square root."
msgstr "Квадратний корінь."

msgid "vec_type **inversesqrt** (vec_type x)"
msgstr "Vec_type **inversesqrt** (vec_type x)"

msgid "Inverse square root."
msgstr "Обернений квадратний корінь."

msgid "vec_type **abs** (vec_type x)"
msgstr "Vec_type **abs** (vec_type x)"

msgid "ivec_type **abs** (ivec_type x)"
msgstr "Ivec_type **abs** (ivec_type x)"

msgid "Absolute value (returns positive value if negative)."
msgstr "Абсолютне значення (повертає додатне значення, якщо від’ємне)."

msgid "vec_type **sign** (vec_type x)"
msgstr "Vec_type **sign** (vec_type x)"

msgid "ivec_type **sign** (ivec_type x)"
msgstr "Ivec_type **sign** (ivec_type x)"

msgid ""
"Sign (returns ``1.0`` if positive, ``-1.0`` if negative, ``0.0`` if zero)."
msgstr ""
"Знак (повертає ``1.0``, якщо позитивний, ``-1.0``, якщо негативний, ``0.0``, "
"якщо нуль)."

msgid "vec_type **floor** (vec_type x)"
msgstr "Vec_type **floor** (vec_type x)"

msgid "Round to the integer below."
msgstr "Округліть до цілого числа нижче."

msgid "vec_type **round** (vec_type x)"
msgstr "Vec_type **round** (vec_type x)"

msgid "Round to the nearest integer."
msgstr "Округлити до найближчого цілого числа."

msgid "vec_type **roundEven** (vec_type x)"
msgstr "Vec_type **roundEven** (vec_type x)"

msgid "Round to the nearest even integer."
msgstr "Округліть до найближчого парного цілого числа."

msgid "vec_type **trunc** (vec_type x)"
msgstr "Vec_type **trunc** (vec_type x)"

msgid "Truncation."
msgstr "Усічення."

msgid "vec_type **ceil** (vec_type x)"
msgstr "Vec_type **ceil** (vec_type x)"

msgid "Round to the integer above."
msgstr "Округлити до цілого числа вище."

msgid "vec_type **fract** (vec_type x)"
msgstr "Vec_type **fract** (vec_type x)"

msgid "Fractional (returns ``x - floor(x)``)."
msgstr "Дробовий (повертає ``x - floor(x)``)."

msgid "vec_type **mod** (vec_type x, vec_type y)"
msgstr "Vec_type **mod** (vec_type x, vec_type y)"

msgid "vec_type **mod** (vec_type x, float y)"
msgstr "Vec_type **mod** (vec_type x, float y)"

msgid "Modulo (division remainder)."
msgstr "По модулю (залишок від ділення)."

msgid "vec_type **modf** (vec_type x, out vec_type i)"
msgstr "Vec_type **modf** (vec_type x, out vec_type i)"

msgid "Fractional of ``x``, with ``i`` as integer part."
msgstr "Дробове значення x, де i є цілою частиною."

msgid "vec_type  **min** (vec_type a, vec_type b)"
msgstr "Vec_type**min** (vec_type a, vec_type b)"

msgid "Lowest value between ``a`` and ``b``."
msgstr "Найменше значення між \"a\" і \"b\"."

msgid "vec_type  **max** (vec_type a, vec_type b)"
msgstr "Vec_type**max** (vec_type a, vec_type b)"

msgid "Highest value between ``a`` and ``b``."
msgstr "Найвище значення між ``a`` і ``b``."

msgid "vec_type **clamp** (vec_type x, vec_type min, vec_type max)"
msgstr "Vec_type **clamp** (vec_type x, vec_type min, vec_type max)"

msgid "Clamp ``x`` between ``min`` and ``max`` (inclusive)."
msgstr "Затисніть ``x`` між ``min`` і ``max`` (включно)."

msgid "float **mix** (float a, float b, float c)"
msgstr "Float **mix** (float a, float b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, float c)"
msgstr "Vec_type **mix** (vec_type a, vec_type b, float c)"

msgid "vec_type **mix** (vec_type a, vec_type b, bvec_type c)"
msgstr "Vec_type **mix** (vec_type a, vec_type b, bvec_type c)"

msgid "Linear interpolate between ``a`` and ``b`` by ``c``."
msgstr "Лінійна інтерполяція між ``a`` і ``b`` на ``c``."

msgid "vec_type **fma** (vec_type a, vec_type b, vec_type c)"
msgstr "Vec_type **fma** (vec_type a, vec_type b, vec_type c)"

msgid ""
"Performs a fused multiply-add operation: ``(a * b + c)`` (faster than doing "
"it manually)."
msgstr ""
"Виконує операцію злитого множення-додавання: ``(a * b + c)`` (швидше, ніж "
"робити це вручну)."

msgid "vec_type **step** (vec_type a, vec_type b)"
msgstr "Vec_type **step** (vec_type a, vec_type b)"

msgid "``b[i] < a[i] ? 0.0 : 1.0``."
msgstr "``b[i] < a[i] ? 0.0 : 1.0``."

msgid "vec_type **step** (float a, vec_type b)"
msgstr "Vec_type **step** (float a, vec_type b)"

msgid "``b[i] < a ? 0.0 : 1.0``."
msgstr "``b[i] < a ? 0.0 : 1.0``."

msgid "vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"
msgstr "Vec_type **smoothstep** (vec_type a, vec_type b, vec_type c)"

msgid "vec_type **smoothstep** (float a, float b, vec_type c)"
msgstr "Vec_type **smoothstep** (float a, float b, vec_type c)"

msgid "Hermite interpolate between ``a`` and ``b`` by ``c``."
msgstr "Ерміт інтерполює між ``a`` і ``b`` на ``c``."

msgid "bvec_type **isnan** (vec_type x)"
msgstr "Bvec_type **isnan** (vec_type x)"

msgid "Returns ``true`` if scalar or vector component is ``NaN``."
msgstr "Повертає ``true``, якщо скалярний або векторний компонент є ``NaN``."

msgid "bvec_type **isinf** (vec_type x)"
msgstr "Bvec_type **isinf** (vec_type x)"

msgid "Returns ``true`` if scalar or vector component is ``INF``."
msgstr "Повертає ``true``, якщо скалярний або векторний компонент є ``INF``."

msgid "ivec_type **floatBitsToInt** (vec_type x)"
msgstr "Ivec_type **floatBitsToInt** (vec_type x)"

msgid "Float->Int bit copying, no conversion."
msgstr "Копіювання бітів Float->Int, без перетворення."

msgid "uvec_type **floatBitsToUint** (vec_type x)"
msgstr "Uvec_type **floatBitsToUint** (vec_type x)"

msgid "Float->UInt bit copying, no conversion."
msgstr "Копіювання бітів Float->UInt, без перетворення."

msgid "vec_type **intBitsToFloat** (ivec_type x)"
msgstr "Vec_type **intBitsToFloat** (ivec_type x)"

msgid "Int->Float bit copying, no conversion."
msgstr "Копіювання бітів Int->Float, без перетворення."

msgid "vec_type **uintBitsToFloat** (uvec_type x)"
msgstr "Vec_type **uintBitsToFloat** (uvec_type x)"

msgid "UInt->Float bit copying, no conversion."
msgstr "Копіювання бітів UInt->Float, без перетворення."

msgid "float **length** (vec_type x)"
msgstr "Float **length** (vec_type x)"

msgid "Vector length."
msgstr "Довжина вектора."

msgid "float **distance** (vec_type a, vec_type b)"
msgstr "Float **distance** (vec_type a, vec_type b)"

msgid "Distance between vectors i.e ``length(a - b)``."
msgstr "Відстань між векторами, тобто ``довжина (a - b)``."

msgid "float **dot** (vec_type a, vec_type b)"
msgstr "Float **dot** (vec_type a, vec_type b)"

msgid "Dot product."
msgstr "Точковий продукт."

msgid "vec3 **cross** (vec3 a, vec3 b)"
msgstr "Vec3 **cross** (vec3 a, vec3 b)"

msgid "Cross product."
msgstr "Перехресний продукт."

msgid "vec_type **normalize** (vec_type x)"
msgstr "Vec_type **normalize** (vec_type x)"

msgid "Normalize to unit length."
msgstr "Нормалізувати до одиниці довжини."

msgid "vec3 **reflect** (vec3 I, vec3 N)"
msgstr "Vec3 **reflect** (vec3 I, vec3 N)"

msgid "Reflect."
msgstr "Подумай."

msgid "vec3 **refract** (vec3 I, vec3 N, float eta)"
msgstr "Vec3 **refract** (vec3 I, vec3 N, float eta)"

msgid "Refract."
msgstr "Заломлення."

msgid "vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)"
msgstr "Vec_type **faceforward** (vec_type N, vec_type I, vec_type Nref)"

msgid "If ``dot(Nref, I)`` < 0, return ``N``, otherwise ``-N``."
msgstr "Якщо ``точка(Nref, I)`` < 0, повертається ``N``, інакше ``-N``."

msgid "mat_type **matrixCompMult** (mat_type x, mat_type y)"
msgstr "Mat_type **matrixCompMult** (mat_type x, mat_type y)"

msgid "Matrix component multiplication."
msgstr "Множення компонент матриці."

msgid "mat_type **outerProduct** (vec_type column, vec_type row)"
msgstr "Mat_type **outerProduct** (vec_type column, vec_type row)"

msgid "Matrix outer product."
msgstr "Зовнішній продукт матриці."

msgid "mat_type **transpose** (mat_type m)"
msgstr "Mat_type **transpose** (mat_type m)"

msgid "Transpose matrix."
msgstr "Транспонуємо матрицю."

msgid "float **determinant** (mat_type m)"
msgstr "Float **determinant** (mat_type m)"

msgid "Matrix determinant."
msgstr "Матричний визначник."

msgid "mat_type **inverse** (mat_type m)"
msgstr "Mat_type **inverse** (mat_type m)"

msgid "Inverse matrix."
msgstr "Обернена матриця."

msgid "bvec_type **lessThan** (vec_type x, vec_type y)"
msgstr "Bvec_type **lessThan** (vec_type x, vec_type y)"

msgid "Bool vector comparison on < int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах < int/uint/float."

msgid "bvec_type **greaterThan** (vec_type x, vec_type y)"
msgstr "Bvec_type **greaterThan** (vec_type x, vec_type y)"

msgid "Bool vector comparison on > int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах > int/uint/float."

msgid "bvec_type **lessThanEqual** (vec_type x, vec_type y)"
msgstr "Bvec_type **lessThanEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on <= int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах <= int/uint/float."

msgid "bvec_type **greaterThanEqual** (vec_type x, vec_type y)"
msgstr "Bvec_type **greaterThanEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on >= int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах >= int/uint/float."

msgid "bvec_type **equal** (vec_type x, vec_type y)"
msgstr "Bvec_type **equal** (vec_type x, vec_type y)"

msgid "Bool vector comparison on == int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах == int/uint/float."

msgid "bvec_type **notEqual** (vec_type x, vec_type y)"
msgstr "Bvec_type **notEqual** (vec_type x, vec_type y)"

msgid "Bool vector comparison on != int/uint/float vectors."
msgstr "Порівняння векторів Bool на векторах != int/uint/float."

msgid "bool **any** (bvec_type x)"
msgstr "Bool **any** (bvec_type x)"

msgid "``true`` if any component is ``true``, ``false`` otherwise."
msgstr ""
"``true``, якщо будь-який компонент має значення ``true``, ``false`` інакше."

msgid "bool **all** (bvec_type x)"
msgstr "Bool **all** (bvec_type x)"

msgid "``true`` if all components are ``true``, ``false`` otherwise."
msgstr "``true``, якщо всі компоненти ``true``, ``false`` інакше."

msgid "bvec_type **not** (bvec_type x)"
msgstr "Bvec_type **not** (bvec_type x)"

msgid "Invert boolean vector."
msgstr "Інвертувати булевий вектор."

msgid "ivec2 **textureSize** (gsampler2D s, int lod)"
msgstr "ivec2 **textureSize** (gsampler2D s, int lod)"

msgid "ivec3 **textureSize** (gsampler2DArray s, int lod)"
msgstr "ivec3 **textureSize** (gsampler2DArray s, int lod)"

msgid "ivec3 **textureSize** (gsampler3D s, int lod)"
msgstr "ivec3 **textureSize** (gsampler3D s, int lod)"

msgid "ivec2 **textureSize** (samplerCube s, int lod)"
msgstr "Ivec2 **textureSize** (samplerCube s, int lod)"

msgid "ivec2 **textureSize** (samplerCubeArray s, int lod)"
msgstr "Ivec2 **textureSize** (samplerCubeArray s, int lod)"

msgid "Get the size of a texture."
msgstr "Отримайте розмір текстури."

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0`` will use "
"the full resolution texture."
msgstr ""
"LOD визначає, який рівень mipmap використовується. Значення LOD ``0`` "
"використовуватиме текстуру повної роздільної здатності."

msgid "vec2 **textureQueryLod** (gsampler2D s, vec2 p)"
msgstr "Vec2 **textureQueryLod** (gsampler2D s, vec2 p)"

msgid "vec3 **textureQueryLod** (gsampler2DArray s, vec2 p)"
msgstr "Vec3 **textureQueryLod** (gsampler2DArray s, vec2 p)"

msgid "vec2 **textureQueryLod** (gsampler3D s, vec3 p)"
msgstr "Vec2 **textureQueryLod** (gsampler3D s, vec3 p)"

msgid "vec2 **textureQueryLod** (samplerCube s, vec3 p)"
msgstr "Vec2 **textureQueryLod** (samplerCube s, vec3 p)"

msgid ""
"Compute the level-of-detail that would be used to sample from a texture. The "
"``x`` component of the resulted value is the mipmap array that would be "
"accessed. The ``y`` component is computed level-of-detail relative to the "
"base level (regardless of the mipmap levels of the texture)."
msgstr ""
"Обчисліть рівень деталізації, який використовуватиметься для вибірки "
"текстури. Компонент ``x`` отриманого значення є масивом mipmap, до якого "
"буде доступ. Компонент ``y`` є обчисленим рівнем деталізації відносно "
"базового рівня (незалежно від рівнів MIP-карти текстури)."

msgid "int **textureQueryLevels** (gsampler2D s)"
msgstr "Int **textureQueryLevels** (gsampler2D s)"

msgid "int **textureQueryLevels** (gsampler2DArray s)"
msgstr "Int **textureQueryLevels** (gsampler2DArray s)"

msgid "int **textureQueryLevels** (gsampler3D s)"
msgstr "Int **textureQueryLevels** (gsampler3D s)"

msgid "int **textureQueryLevels** (samplerCube s)"
msgstr "Int **textureQueryLevels** (samplerCube s)"

msgid "Get the number of accessible mipmap levels of a texture."
msgstr "Отримайте кількість доступних рівнів mipmap текстури."

msgid ""
"If the texture is unassigned to a sampler, ``1`` is returned (Godot always "
"internally assigns a texture even to an empty sampler)."
msgstr ""
"Якщо текстура не призначена для семплера, повертається ``1`` (Godot завжди "
"внутрішньо призначає текстуру навіть порожньому семплеру)."

msgid "gvec4_type **texture** (gsampler2D s, vec2 p [, float bias])"
msgstr "Gvec4_type **texture** (gsampler2D s, vec2 p [, float bias])"

msgid "gvec4_type **texture** (gsampler2DArray s, vec3 p [, float bias])"
msgstr "Gvec4_type **texture** (gsampler2DArray s, vec3 p [, float bias])"

msgid "gvec4_type **texture** (gsampler3D s, vec3 p [, float bias])"
msgstr "Gvec4_type **texture** (gsampler3D s, vec3 p [, float bias])"

msgid "vec4 **texture** (samplerCube s, vec3 p [, float bias])"
msgstr "Vec4 **texture** (samplerCube s, vec3 p [, float bias])"

msgid "vec4 **texture** (samplerCubeArray s, vec4 p [, float bias])"
msgstr "Vec4 **texture** (samplerCubeArray s, vec4 p [, float bias])"

msgid "Perform a texture read."
msgstr "Виконайте зчитування текстури."

msgid "gvec4_type **textureProj** (gsampler2D s, vec3 p [, float bias])"
msgstr "Gvec4_type **textureProj** (gsampler2D s, vec3 p [, float bias])"

msgid "gvec4_type **textureProj** (gsampler2D s, vec4 p [, float bias])"
msgstr "Gvec4_type **textureProj** (gsampler2D s, vec4 p [, float bias])"

msgid "gvec4_type **textureProj** (gsampler3D s, vec4 p [, float bias])"
msgstr "Gec4_type **textureProj** (gsampler3D s, vec4 p [, float bias])"

msgid "Perform a texture read with projection."
msgstr "Виконайте зчитування текстури за допомогою проекції."

msgid "gvec4_type **textureLod** (gsampler2D s, vec2 p, float lod)"
msgstr "Gvec4_type **textureLod** (gsampler2D s, vec2 p, float lod)"

msgid "gvec4_type **textureLod** (gsampler2DArray s, vec3 p, float lod)"
msgstr "Gvec4_type **textureLod** (gsampler2DArray s, vec3 p, float lod)"

msgid "gvec4_type **textureLod** (gsampler3D s, vec3 p, float lod)"
msgstr "Gvec4_type **textureLod** (gsampler3D s, vec3 p, float lod)"

msgid "vec4 **textureLod** (samplerCube s, vec3 p, float lod)"
msgstr "Vec4 **textureLod** (samplerCube s, vec3 p, float lod)"

msgid "vec4 **textureLod** (samplerCubeArray s, vec4 p, float lod)"
msgstr "Vec4 **textureLod** (samplerCubeArray s, vec4 p, float lod)"

msgid "Perform a texture read at custom mipmap."
msgstr "Виконайте зчитування текстури на власному mipmap."

msgid ""
"The LOD defines which mipmap level is used. An LOD value of ``0.0`` will use "
"the full resolution texture. If the texture lacks mipmaps, all LOD values "
"will act like ``0.0``."
msgstr ""
"LOD визначає, який рівень mipmap використовується. Значення LOD ``0.0`` "
"використовуватиме текстуру повної роздільної здатності. Якщо в текстурі "
"відсутні MIP-карти, усі значення LOD діятимуть як ``0.0``."

msgid "gvec4_type **textureProjLod** (gsampler2D s, vec3 p, float lod)"
msgstr "Gvec4_type **textureProjLod** (gsampler2D s, vec3 p, float lod)"

msgid "gvec4_type **textureProjLod** (gsampler2D s, vec4 p, float lod)"
msgstr "Gvec4_type **textureProjLod** (gsampler2D s, vec4 p, float lod)"

msgid "gvec4_type **textureProjLod** (gsampler3D s, vec4 p, float lod)"
msgstr "Gvec4_type **textureProjLod** (gsampler3D s, vec4 p, float lod)"

msgid "Performs a texture read with projection/LOD."
msgstr "Виконує зчитування текстури за допомогою проекції/LOD."

msgid "gvec4_type **textureGrad** (gsampler2D s, vec2 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"Gvec4_type **textureGrad** (gsampler2D s, vec2 p, vec2 dPdx, vec2 dPdy)"

msgid ""
"gvec4_type **textureGrad** (gsampler2DArray s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"Gvec4_type **textureGrad** (gsampler2DArray s, vec3 p, vec2 dPdx, vec2 dPdy)"

msgid "gvec4_type **textureGrad** (gsampler3D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"Gvec4_type **textureGrad** (gsampler3D s, vec3 p, vec2 dPdx, vec2 dPdy)"

msgid "vec4 **textureGrad** (samplerCube s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr "Vec4 **textureGrad** (samplerCube s, vec3 p, vec3 dPdx, vec3 dPdy)"

msgid "vec4 **textureGrad** (samplerCubeArray s, vec3 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"Vec4 **textureGrad** (samplerCubeArray s, vec3 p, vec3 dPdx, vec3 dPdy)"

msgid "Performs a texture read with explicit gradients."
msgstr "Виконує зчитування текстури з явними градієнтами."

msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec3 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"Gvec4_type **textureProjGrad** (gsampler2D s, vec3 p, vec2 dPdx, vec2 dPdy)"

msgid ""
"gvec4_type **textureProjGrad** (gsampler2D s, vec4 p, vec2 dPdx, vec2 dPdy)"
msgstr ""
"Gvec4_type **textureProjGrad** (gsampler2D s, vec4 p, vec2 dPdx, vec2 dPdy)"

msgid ""
"gvec4_type **textureProjGrad** (gsampler3D s, vec4 p, vec3 dPdx, vec3 dPdy)"
msgstr ""
"Gvec4_type **textureProjGrad** (gsampler3D s, vec4 p, vec3 dPdx, vec3 dPdy)"

msgid ""
"Performs a texture read with projection/LOD and with explicit gradients."
msgstr ""
"Виконує зчитування текстури за допомогою проекції/LOD і з явними градієнтами."

msgid "gvec4_type **texelFetch** (gsampler2D s, ivec2 p, int lod)"
msgstr "Gvec4_type **texelFetch** (gsampler2D s, ivec2 p, int lod)"

msgid "gvec4_type **texelFetch** (gsampler2DArray s, ivec3 p, int lod)"
msgstr "Gvec4_type **texelFetch** (gsampler2DArray s, ivec3 p, int lod)"

msgid "gvec4_type **texelFetch** (gsampler3D s, ivec3 p, int lod)"
msgstr "Gvec4_type **texelFetch** (gsampler3D s, ivec3 p, int lod)"

msgid "Fetches a single texel using integer coordinates."
msgstr "Отримує один тексель за допомогою цілих координат."

msgid "gvec4_type **textureGather** (gsampler2D s, vec2 p [, int comps])"
msgstr "Gvec4_type **textureGather** (gsampler2D s, vec2 p [, int comps])"

msgid "gvec4_type **textureGather** (gsampler2DArray s, vec3 p [, int comps])"
msgstr "Gvec4_type **textureGather** (gsampler2DArray s, vec3 p [, int comps])"

msgid "vec4 **textureGather** (samplerCube s, vec3 p [, int comps])"
msgstr "Vec4 **textureGather** (samplerCube s, vec3 p [, int comps])"

msgid ""
"Gathers four texels from a texture. Use ``comps`` within range of 0..3 to "
"define which component (x, y, z, w) is returned. If ``comps`` is not "
"provided: 0 (or x-component) is used."
msgstr ""
"Збирає чотири текселі з текстури. Використовуйте ``comps`` у діапазоні 0..3, "
"щоб визначити, який компонент (x, y, z, w) повертається. Якщо ``comps`` не "
"надано: використовується 0 (або x-компонент)."

msgid "vec_type **dFdx** (vec_type p)"
msgstr "Vec_type **dFdx** (vec_type p)"

msgid ""
"Derivative in ``x`` using local differencing. Internally, can use either "
"``dFdxCoarse`` or ``dFdxFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""
"Похідна в ``x`` з використанням локальної різниці. Внутрішньо можна "
"використовувати або ``dFdxCoarse``, або ``dFdxFine``, але рішення про "
"використання приймається драйвером GPU."

msgid "vec_type **dFdxCoarse** (vec_type p)"
msgstr "Vec_type **dFdxCoarse** (vec_type p)"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""
"Обчислює похідну відносно віконної координати ``x`` за допомогою локальної "
"різниці на основі значення ``p`` для поточного сусіда(ів) фрагмента та, "
"можливо, але не обов’язково, включатиме значення для поточного фрагмента. Ця "
"функція недоступна в профілі ``gl_compatibility``."

msgid "vec_type **dFdxFine** (vec_type p)"
msgstr "Vec_type **dFdxFine** (vec_type p)"

msgid ""
"Calculates derivative with respect to ``x`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""
"Обчислює похідну відносно віконної координати ``x`` за допомогою локальної "
"різниці на основі значення ``p`` для поточного фрагмента та його найближчих "
"сусідів. Ця функція недоступна в профілі ``gl_compatibility``."

msgid "vec_type **dFdy** (vec_type p)"
msgstr "Vec_type **dFdy** (vec_type p)"

msgid ""
"Derivative in ``y`` using local differencing. Internally, can use either "
"``dFdyCoarse`` or ``dFdyFine``, but the decision for which to use is made by "
"the GPU driver."
msgstr ""
"Похідна в ``y`` з використанням локальної різниці. Внутрішньо можна "
"використовувати або ``dFdyCoarse``, або ``dFdyFine``, але рішення про "
"використання приймається драйвером GPU."

msgid "vec_type **dFdyCoarse** (vec_type p)"
msgstr "Vec_type **dFdyCoarse** (vec_type p)"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment "
"neighbour(s), and will possibly, but not necessarily, include the value for "
"the current fragment. This function is not available on ``gl_compatibility`` "
"profile."
msgstr ""
"Обчислює похідну відносно віконної координати ``y`` за допомогою локальної "
"різниці на основі значення ``p`` для поточного сусіда(ів) фрагмента та, "
"можливо, але не обов’язково, включатиме значення для поточного фрагмента. Ця "
"функція недоступна в профілі ``gl_compatibility``."

msgid "vec_type **dFdyFine** (vec_type p)"
msgstr "Vec_type **dFdyFine** (vec_type p)"

msgid ""
"Calculates derivative with respect to ``y`` window coordinate using local "
"differencing based on the value of ``p`` for the current fragment and its "
"immediate neighbour(s). This function is not available on "
"``gl_compatibility`` profile."
msgstr ""
"Обчислює похідну відносно віконної координати ``y`` за допомогою локальної "
"різниці на основі значення ``p`` для поточного фрагмента та його найближчих "
"сусідів. Ця функція недоступна в профілі ``gl_compatibility``."

msgid "vec_type **fwidth** (vec_type p)"
msgstr "Vec_type **fwidth** (vec_type p)"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdx(p)) + abs(dFdy(p))``."
msgstr ""
"Сума абсолютної похідної в ``x`` і ``y``. Це еквівалент використання "
"``abs(dFdx(p)) + abs(dFdy(p))``."

msgid "vec_type **fwidthCoarse** (vec_type p)"
msgstr "Vec_type **fwidthCoarse** (vec_type p)"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""
"Сума абсолютної похідної в ``x`` і ``y``. Це еквівалент використання "
"``abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))``. Ця функція недоступна в профілі "
"``gl_compatibility``."

msgid "vec_type **fwidthFine** (vec_type p)"
msgstr "Vec_type **fwidthFine** (vec_type p)"

msgid ""
"Sum of absolute derivative in ``x`` and ``y``. This is the equivalent of "
"using ``abs(dFdxFine(p)) + abs(dFdyFine(p))``. This function is not "
"available on ``gl_compatibility`` profile."
msgstr ""
"Сума абсолютної похідної в ``x`` і ``y``. Це еквівалент використання "
"``abs(dFdxFine(p)) + abs(dFdyFine(p))``. Ця функція недоступна в профілі "
"``gl_compatibility``."

msgid "uint **packHalf2x16** (vec2 v)"
msgstr "uint **packHalf2x16** (vec2 v)"

msgid "vec2 **unpackHalf2x16** (uint v)"
msgstr "vec2 **unpackHalf2x16** (uint v)"

msgid ""
"Convert two 32-bit floating-point numbers into 16-bit and pack them into a "
"32-bit unsigned integer and vice-versa."
msgstr ""
"Перетворіть два 32-розрядні числа з плаваючою комою на 16-розрядні та "
"запакуйте їх у 32-розрядне ціле число без знаку і навпаки."

msgid "uint **packUnorm2x16** (vec2 v)"
msgstr "uint **packUnorm2x16** (vec2 v)"

msgid "vec2 **unpackUnorm2x16** (uint v)"
msgstr "vec2 **unpackUnorm2x16** (uint v)"

msgid ""
"Convert two 32-bit floating-point numbers (clamped within 0..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""
"Перетворіть два 32-розрядні числа з плаваючою комою (закріплені в межах 0..1 "
"діапазону) у 16-розрядні та запакуйте їх у 32-розрядне ціле число без знаку "
"і навпаки."

msgid "uint **packSnorm2x16** (vec2 v)"
msgstr "uint **packSnorm2x16** (vec2 v)"

msgid "vec2 **unpackSnorm2x16** (uint v)"
msgstr "vec2 **unpackSnorm2x16** (uint v)"

msgid ""
"Convert two 32-bit floating-point numbers (clamped within -1..1 range) into "
"16-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""
"Перетворіть два 32-розрядні числа з плаваючою комою (закріплені в діапазоні "
"-1..1) у 16-розрядні та запакуйте їх у 32-розрядне ціле число без знаку і "
"навпаки."

msgid "uint **packUnorm4x8** (vec4 v)"
msgstr "uint **packUnorm4x8** (vec4 v)"

msgid "vec4 **unpackUnorm4x8** (uint v)"
msgstr "vec4 **unpackUnorm4x8** (uint v)"

msgid ""
"Convert four 32-bit floating-point numbers (clamped within 0..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""
"Перетворіть чотири 32-розрядні числа з плаваючою комою (затиснуті в "
"діапазоні 0..1) у 8-розрядні та запакуйте їх у 32-розрядне ціле число без "
"знаку, і навпаки."

msgid "uint **packSnorm4x8** (vec4 v)"
msgstr "uint **packSnorm4x8** (vec4 v)"

msgid "vec4 **unpackSnorm4x8** (uint v)"
msgstr "vec4 **unpackSnorm4x8** (uint v)"

msgid ""
"Convert four 32-bit floating-point numbers (clamped within -1..1 range) into "
"8-bit and pack them into a 32-bit unsigned integer and vice-versa."
msgstr ""
"Перетворіть чотири 32-розрядні числа з плаваючою комою (затиснуті в "
"діапазоні -1..1) у 8-розрядні та запакуйте їх у 32-розрядне ціле число без "
"знаку і навпаки."

msgid "ivec_type **bitfieldExtract** (ivec_type value, int offset, int bits)"
msgstr "ivec_type **bitfieldExtract** (ivec_type value, int offset, int bits)"

msgid "uvec_type **bitfieldExtract** (uvec_type value, int offset, int bits)"
msgstr "uvec_type **bitfieldExtract** (uvec_type value, int offset, int bits)"

msgid "Extracts a range of bits from an integer."
msgstr "Виділяє діапазон бітів із цілого числа."

msgid ""
"ivec_type **bitfieldInsert** (ivec_type base, ivec_type insert, int offset, "
"int bits)"
msgstr ""
"ivec_type **bitfieldInsert** (ivec_type base, ivec_type insert, int offset, "
"int bits)"

msgid ""
"uvec_type **bitfieldInsert** (uvec_type base, uvec_type insert, int offset, "
"int bits)"
msgstr ""
"uvec_type **bitfieldInsert** (uvec_type base, uvec_type insert, int offset, "
"int bits)"

msgid "Insert a range of bits into an integer."
msgstr "Вставте діапазон бітів у ціле число."

msgid "ivec_type **bitfieldReverse** (ivec_type value)"
msgstr "ivec_type **bitfieldReverse** (ivec_type value)"

msgid "uvec_type **bitfieldReverse** (uvec_type value)"
msgstr "uvec_type **bitfieldReverse** (uvec_type value)"

msgid "Reverse the order of bits in an integer."
msgstr "Змінити порядок бітів у цілому числі."

msgid "ivec_type **bitCount** (ivec_type value)"
msgstr "ivec_type **bitCount** (ivec_type value)"

msgid "uvec_type **bitCount** (uvec_type value)"
msgstr "uvec_type **bitCount** (uvec_type value)"

msgid "Counts the number of 1 bits in an integer."
msgstr "Підраховує кількість 1 біта в цілому числі."

msgid "ivec_type **findLSB** (ivec_type value)"
msgstr "ivec_type **findLSB** (ivec_type value)"

msgid "uvec_type **findLSB** (uvec_type value)"
msgstr "uvec_type **findLSB** (uvec_type value)"

msgid "Find the index of the least significant bit set to 1 in an integer."
msgstr "Знайдіть індекс молодшого біта, який дорівнює 1, у цілому числі."

msgid "ivec_type **findMSB** (ivec_type value)"
msgstr "ivec_type **findMSB** (ivec_type value)"

msgid "uvec_type **findMSB** (uvec_type value)"
msgstr "uvec_type **findMSB** (uvec_type value)"

msgid "Find the index of the most significant bit set to 1 in an integer."
msgstr "Знайдіть індекс старшого біта, який дорівнює 1, у цілому числі."

msgid ""
"void **imulExtended** (ivec_type x, ivec_type y, out ivec_type msb, out "
"ivec_type lsb)"
msgstr ""
"void **imulExtended** (ivec_type x, ivec_type y, out ivec_type msb, out "
"ivec_type lsb)"

msgid ""
"void **umulExtended** (uvec_type x, uvec_type y, out uvec_type msb, out "
"uvec_type lsb)"
msgstr ""
"void **umulExtended** (uvec_type x, uvec_type y, out uvec_type msb, out "
"uvec_type lsb)"

msgid ""
"Multiplies two 32-bit numbers and produce a 64-bit result. ``x`` - the first "
"number. ``y`` - the second number. ``msb`` - will contain the most "
"significant bits. ``lsb`` - will contain the least significant bits."
msgstr ""
"Перемножує два 32-розрядні числа та отримує 64-розрядний результат. ``x`` - "
"перше число. ``y`` - друге число. ``msb`` - міститиме старші біти. ``lsb`` - "
"міститиме молодші біти."

msgid "uvec_type **uaddCarry** (uvec_type x, uvec_type y, out uvec_type carry)"
msgstr ""
"uvec_type **uaddCarry** (uvec_type x, uvec_type y, out uvec_type carry)"

msgid "Adds two unsigned integers and generates carry."
msgstr "Додає два цілі числа без знаку та генерує перенесення."

msgid ""
"uvec_type **usubBorrow** (uvec_type x, uvec_type y, out uvec_type borrow)"
msgstr ""
"uvec_type **usubBorrow** (uvec_type x, uvec_type y, out uvec_type borrow)"

msgid "Subtracts two unsigned integers and generates borrow."
msgstr "Віднімає два цілі числа без знаку та генерує позику."

msgid "vec_type **ldexp** (vec_type x, out ivec_type exp)"
msgstr "vec_type **ldexp** (vec_type x, out ivec_type exp)"

msgid "Assemble a floating-point number from a value and exponent."
msgstr "Складіть число з плаваючою комою зі значення та експоненти."

msgid ""
"If this product is too large to be represented in the floating-point type "
"the result is undefined."
msgstr ""
"Якщо цей добуток завеликий для представлення в типі з плаваючою комою, "
"результат буде невизначеним."

msgid "vec_type **frexp** (vec_type x, out ivec_type exp)"
msgstr "vec_type **frexp** (vec_type x, out ivec_type exp)"

msgid ""
"Splits a floating-point number(``x``) into significand (in the range of "
"[0.5, 1.0]) and an integral exponent."
msgstr ""
"Розділяє число з плаваючою комою (``x``) на значуще (в діапазоні [0,5, 1,0]) "
"і інтегральний показник."

msgid ""
"For ``x`` equals zero the significand and exponent are both zero. For ``x`` "
"of infinity or NaN, the results are undefined."
msgstr ""
"Якщо ``x`` дорівнює нулю, і значуще, і показник степеня дорівнюють нулю. Для "
"``x`` нескінченності або NaN результати не визначені."
