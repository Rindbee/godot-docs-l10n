#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shader preprocessor"
msgstr "Препроцесор шейдерів"

msgid "Why use a shader preprocessor?"
msgstr "Навіщо використовувати препроцесор шейдерів?"

msgid ""
"In programming languages, a *preprocessor* allows changing the code before "
"the compiler reads it. Unlike the compiler, the preprocessor does not care "
"about whether the syntax of the preprocessed code is valid. The preprocessor "
"always performs what the *directives* tell it to do. A directive is a "
"statement starting with a hash symbol (``#``). It is not a *keyword* of the "
"shader language (such as ``if`` or ``for``), but a special kind of token "
"within the language."
msgstr ""
"У мовах програмування *препроцесор* дозволяє змінювати код до того, як його "
"прочитає компілятор. На відміну від компілятора, препроцесор не піклується "
"про те, чи дійсний синтаксис попередньо обробленого коду. Препроцесор завжди "
"виконує те, що вказують *директиви*. Директива — це оператор, що починається "
"символом решетки (``#``). Це не *ключове слово* мови шейдерів (наприклад, "
"``if`` або ``for``), а особливий вид токена в мові."

msgid ""
"From Godot 4.0 onwards, you can use a shader preprocessor within text-based "
"shaders. The syntax is similar to what most GLSL shader compilers support "
"(which in turn is similar to the C/C++ preprocessor)."
msgstr ""
"Починаючи з Godot 4.0 і далі, ви можете використовувати препроцесор шейдерів "
"у текстових шейдерах. Синтаксис схожий на той, який підтримує більшість "
"компіляторів шейдерів GLSL (який, у свою чергу, подібний до препроцесора C/C+"
"+)."

msgid ""
"The shader preprocessor is not available in :ref:`visual shaders "
"<doc_visual_shaders>`. If you need to introduce preprocessor statements to a "
"visual shader, you can convert it to a text-based shader using the **Convert "
"to Shader** option in the VisualShader inspector resource dropdown. This "
"conversion is a one-way operation; text shaders cannot be converted back to "
"visual shaders."
msgstr ""
"Препроцесор шейдерів недоступний у :ref:`visual shaders "
"<doc_visual_shaders>`. Якщо вам потрібно додати оператори препроцесора до "
"візуального шейдера, ви можете перетворити його на текстовий шейдер за "
"допомогою параметра **Перетворити на шейдер** у спадному списку ресурсів "
"інспектора VisualShader. Це перетворення є односторонньою операцією; "
"текстові шейдери не можна перетворити назад на візуальні шейдери."

msgid "Directives"
msgstr "Директиви"

msgid "General syntax"
msgstr "Загальний синтаксис"

msgid ""
"Preprocessor directives do not use brackets (``{}``), but can use "
"parentheses."
msgstr ""
"Директиви препроцесора не використовують дужки (``{}``), але можуть "
"використовувати круглі дужки."

msgid ""
"Preprocessor directives **never** end with semicolons (with the exception of "
"``#define``, where this is allowed but potentially dangerous)."
msgstr ""
"Директиви препроцесора **ніколи** не закінчуються крапкою з комою (за "
"винятком ``#define``, де це дозволено, але потенційно небезпечно)."

msgid ""
"Preprocessor directives can span several lines by ending each line with a "
"backslash (``\\``). The first line break *not* featuring a backslash will "
"end the preprocessor statement."
msgstr ""
"Директиви препроцесора можуть охоплювати кілька рядків, закінчуючи кожен "
"рядок зворотною скісною рискою (``\\``). Перший розрив рядка *без* зі "
"зворотною скісною рискою завершує оператор препроцесора."

msgid "#define"
msgstr "#визначити"

msgid "**Syntax:** ``#define <identifier> [replacement_code]``."
msgstr "**Синтаксис:** ``#define <ідентифікатор> [код_заміни]``."

msgid ""
"Defines the identifier after that directive as a macro, and replaces all "
"successive occurrences of it with the replacement code given in the shader. "
"Replacement is performed on a \"whole words\" basis, which means no "
"replacement is performed if the string is part of another string (without "
"any spaces or operators separating it)."
msgstr ""
"Визначає ідентифікатор після цієї директиви як макрос і замінює всі його "
"послідовні входження кодом заміни, наданим у шейдері. Заміна виконується на "
"основі «цілих слів», що означає, що заміна не виконується, якщо рядок є "
"частиною іншого рядка (без пробілів або операторів, що розділяють його)."

msgid ""
"Defines with replacements may also have one or more *arguments*, which can "
"then be passed when referencing the define (similar to a function call)."
msgstr ""
"Визначення із замінами також можуть мати один або більше *аргументів*, які "
"потім можна передати під час посилання на визначення (подібно до виклику "
"функції)."

msgid ""
"If the replacement code is not defined, the identifier may only be used with "
"``#ifdef`` or ``#ifndef`` directives."
msgstr ""
"Якщо код заміни не визначено, ідентифікатор можна використовувати лише з "
"директивами ``#ifdef`` або ``#ifndef``."

msgid ""
"If the *concatenation* symbol (``##``) is present in the replacement code "
"then it will be removed upon macro insertion, together with any space "
"surrounding it, and join the surrounding words and arguments into a new "
"token."
msgstr ""
"Якщо символ *конкатенації* (``##``) присутній у коді заміни, тоді він буде "
"видалений після вставки макросу разом із будь-яким пробілом навколо нього та "
"об’єднає навколишні слова та аргументи в новий маркер."

msgid ""
"Compared to constants (``const CONSTANT = value;``), ``#define`` can be used "
"anywhere within the shader (including in uniform hints). ``#define`` can "
"also be used to insert arbitrary shader code at any location, while "
"constants can't do that."
msgstr ""
"Порівняно з константами (``const CONSTANT = value;``), ``#define`` можна "
"використовувати будь-де в шейдері (зокрема, у однорідних підказках). "
"``#define`` також можна використовувати для вставки довільного коду шейдера "
"в будь-яке місце, тоді як константи не можуть цього зробити."

msgid ""
"Defining a ``#define`` for an identifier that is already defined results in "
"an error. To prevent this, use ``#undef <identifier>``."
msgstr ""
"Визначення ``#define`` для ідентифікатора, який уже визначено, призводить до "
"помилки. Щоб запобігти цьому, використовуйте ``#undef <ідентифікатор>``."

msgid "#undef"
msgstr "#undef"

msgid "**Syntax:** ``#undef identifier``"
msgstr "**Синтаксис:** ``#undef ідентифікатор``"

msgid ""
"The ``#undef`` directive may be used to cancel a previously defined "
"``#define`` directive:"
msgstr ""
"Директиву ``#undef`` можна використовувати для скасування попередньо "
"визначеної директиви ``#define``:"

msgid ""
"Without ``#undef`` in the above example, there would be a macro redefinition "
"error."
msgstr ""
"Без ``#undef`` у наведеному вище прикладі виникла б помилка перевизначення "
"макросу."

msgid "#if"
msgstr "#if"

msgid "**Syntax:** ``#if <condition>``"
msgstr "**Синтаксис:** ``#if <умова>``"

msgid ""
"The ``#if`` directive checks whether the ``condition`` passed. If it "
"evaluates to a non-zero value, the code block is included, otherwise it is "
"skipped."
msgstr ""
"Директива ``#if`` перевіряє, чи виконано ``умову``. Якщо він має ненульове "
"значення, блок коду включається, інакше він пропускається."

msgid ""
"To evaluate correctly, the condition must be an expression giving a simple "
"floating-point, integer or boolean result. There may be multiple condition "
"blocks connected by ``&&`` (AND) or ``||`` (OR) operators. It may be "
"continued by a ``#else`` block, but **must** be ended with the ``#endif`` "
"directive."
msgstr ""
"Для правильного обчислення умова має бути виразом, що дає простий результат "
"із плаваючою комою, ціле чи логічний результат. Може бути кілька блоків "
"умов, з’єднаних операторами ``&&`` (І) або ``||`` (АБО). Він може "
"продовжуватися блоком ``#else``, але **має** закінчуватися директивою "
"``#endif``."

msgid ""
"Using the ``defined()`` *preprocessor function*, you can check whether the "
"passed identifier is defined a by ``#define`` placed above that directive. "
"This is useful for creating multiple shader versions in the same file. It "
"may be continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"Використовуючи *defined()` *функцію препроцесора*, ви можете перевірити, чи "
"переданий ідентифікатор визначений ``#define``, розміщеним над цією "
"директивою. Це корисно для створення кількох версій шейдерів в одному файлі. "
"Він може продовжуватися блоком ``#else``, але повинен завершуватися "
"директивою ``#endif``."

msgid ""
"The ``defined()`` function's result can be negated by using the ``!`` "
"(boolean NOT) symbol in front of it. This can be used to check whether a "
"define is *not* set."
msgstr ""
"Результат функції ``defined()`` можна звести нанівець за допомогою символу "
"``!`` (логічне НІ) перед ним. Це можна використати, щоб перевірити, чи "
"визначення *не* встановлено."

msgid ""
"Be careful, as ``defined()`` must only wrap a single identifier within "
"parentheses, never more:"
msgstr ""
"Будьте обережні, оскільки ``defined()`` має заключати лише один "
"ідентифікатор у круглі дужки, ніколи більше:"

msgid ""
"In the shader editor, preprocessor branches that evaluate to ``false`` (and "
"are therefore excluded from the final compiled shader) will appear grayed "
"out. This does not apply to runtime ``if`` statements."
msgstr ""
"У редакторі шейдерів гілки препроцесора, які мають значення ``false`` (і "
"тому виключені з остаточно скомпільованого шейдера), відображатимуться сірим "
"кольором. Це не стосується операторів ``if`` під час виконання."

msgid "**#if preprocessor versus if statement: Performance caveats**"
msgstr ""
"**#попередній процесор if проти оператора if: застереження щодо "
"продуктивності**"

msgid ""
"The :ref:`shading language <doc_shading_language>` supports runtime ``if`` "
"statements:"
msgstr ""
":ref:`shading language <doc_shading_language>` підтримує оператори ``if`` "
"під час виконання:"

msgid ""
"If the uniform is never changed, this behaves identical to the following "
"usage of the ``#if`` preprocessor statement:"
msgstr ""
"Якщо уніформа ніколи не змінюється, це поводиться так само, як наступне "
"використання оператора препроцесора ``#if``:"

msgid ""
"However, the ``#if`` variant can be faster in certain scenarios. This is "
"because all runtime branches in a shader are still compiled and variables "
"within those branches may still take up register space, even if they are "
"never run in practice."
msgstr ""
"Однак варіант ``#if`` може бути швидшим у певних сценаріях. Це пов’язано з "
"тим, що всі гілки часу виконання в шейдері все ще скомпільовані, і змінні в "
"цих гілках все ще можуть займати місце в реєстрі, навіть якщо вони ніколи не "
"запускаються на практиці."

msgid ""
"Modern GPUs are `quite effective <https://medium.com/@jasonbooth_86226/"
"branching-on-a-gpu-18bfc83694f2>`__ at performing \"static\" branching. "
"\"Static\" branching refers to ``if`` statements where *all* pixels/vertices "
"evaluate to the same result in a given shader invocation. However, high "
"amounts of :abbr:`VGPRs (Vector General-Purpose Register)` (which can be "
"caused by having too many branches) can still slow down shader execution "
"significantly."
msgstr ""
"Сучасні графічні процесори є «досить ефективними <https://medium.com/"
"@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2>`__ у виконанні "
"«статичного» розгалуження. «Статичне» розгалуження відноситься до операторів "
"«if», де *всі* пікселі/вершини обчислюють той самий результат у заданому "
"виклику шейдера. Однак велика кількість :abbr:`VGPR (Векторний регістр "
"загального призначення)` (яка може бути спричинена надто великою кількістю "
"розгалужень) може значно сповільнити виконання шейдера."

msgid "#elif"
msgstr "#elif"

msgid ""
"The ``#elif`` directive stands for \"else if\" and checks the condition "
"passed if the above ``#if`` evaluated to ``false``. ``#elif`` can only be "
"used within an ``#if`` block. It is possible to use several ``#elif`` "
"statements after an ``#if`` statement."
msgstr ""
"Директива ``#elif`` розшифровується як «else if» і перевіряє передану умову, "
"якщо вищезгаданий ``#if`` оцінено як ``false``. ``#elif`` можна "
"використовувати тільки в ``#if`` блоці. Можна використовувати декілька "
"операторів ``#elif`` після оператора ``#if``."

msgid "Like with ``#if``, the ``defined()`` preprocessor function can be used:"
msgstr ""
"Як і у випадку з ``#if``, можна використовувати функцію препроцесора "
"``defined()``:"

msgid "#ifdef"
msgstr "#ifdef"

msgid "**Syntax:** ``#ifdef <identifier>``"
msgstr "**Синтаксис:** ``#ifdef <ідентифікатор>``"

msgid ""
"This is a shorthand for ``#if defined(...)``. Checks whether the passed "
"identifier is defined by ``#define`` placed above that directive. This is "
"useful for creating multiple shader versions in the same file. It may be "
"continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"Це скорочення для ``#if defined(...)``. Перевіряє, чи переданий "
"ідентифікатор визначено ``#define``, розміщеним над цією директивою. Це "
"корисно для створення кількох версій шейдерів в одному файлі. Він може "
"продовжуватися блоком ``#else``, але повинен завершуватися директивою "
"``#endif``."

msgid ""
"The processor does *not* support ``#elifdef`` as a shortcut for ``#elif "
"defined(...)``. Instead, use the following series of ``#ifdef`` and "
"``#else`` when you need more than two branches:"
msgstr ""
"Процесор *не* підтримує ``#elifdef`` як ярлик для ``#elif defined(...)``. "
"Замість цього використовуйте такі ряди ``#ifdef`` і ``#else``, якщо вам "
"потрібно більше ніж дві гілки:"

msgid "#ifndef"
msgstr "#ifndef"

msgid "**Syntax:** ``#ifndef <identifier>``"
msgstr "**Синтаксис:** ``#ifndef <ідентифікатор>``"

msgid ""
"This is a shorthand for ``#if !defined(...)``. Similar to ``#ifdef``, but "
"checks whether the passed identifier is **not** defined by ``#define`` "
"before that directive."
msgstr ""
"Це скорочення для ``#if !defined(...)``. Подібно до ``#ifdef``, але "
"перевіряє, чи переданий ідентифікатор **не** визначений ``#define`` перед "
"цією директивою."

msgid ""
"This is the exact opposite of ``#ifdef``; it will always match in situations "
"where ``#ifdef`` would never match, and vice versa."
msgstr ""
"Це повна протилежність ``#ifdef``; він завжди збігатиметься в ситуаціях, "
"коли ``#ifdef`` ніколи не збігатиметься, і навпаки."

msgid "#else"
msgstr "#else"

msgid "**Syntax:** ``#else``"
msgstr "**Синтаксис:** ``#else``"

msgid ""
"Defines the optional block which is included when the previously defined "
"``#if``, ``#elif``, ``#ifdef`` or ``#ifndef`` directive evaluates to false."
msgstr ""
"Визначає необов’язковий блок, який включається, коли попередньо визначена "
"директива ``#if``, ``#elif``, ``#ifdef`` або ``#ifndef`` має значення false."

msgid "#endif"
msgstr "#endif"

msgid "**Syntax:** ``#endif``"
msgstr "**Синтаксис:** ``#endif``"

msgid ""
"Used as terminator for the ``#if``, ``#ifdef``, ``#ifndef`` or subsequent "
"``#else`` directives."
msgstr ""
"Використовується як термінатор для директив ``#if``, ``#ifdef``, ``#ifndef`` "
"або наступних директив ``#else``."

msgid "#error"
msgstr "#помилка"

msgid "**Syntax:** ``#error <message>``"
msgstr "**Синтаксис:** ``#помилка <повідомлення>``"

msgid ""
"The ``#error`` directive forces the preprocessor to emit an error with "
"optional message. For example, it's useful when used within ``#if`` block to "
"provide a strict limitation of the defined value."
msgstr ""
"Директива ``#error`` змушує препроцесор видавати помилку з додатковим "
"повідомленням. Наприклад, це корисно при використанні в блоці ``#if``, щоб "
"забезпечити суворе обмеження визначеного значення."

msgid "#include"
msgstr "#include"

msgid "**Syntax:** ``#include \"path\"``"
msgstr "**Синтаксис:** ``#include \"path\"``"

msgid ""
"The ``#include`` directive includes the *entire* content of a shader include "
"file in a shader. ``\"path\"`` can be an absolute ``res://`` path or "
"relative to the current shader file. Relative paths are only allowed in "
"shaders that are saved to ``.gdshader`` or ``.gdshaderinc`` files, while "
"absolute paths can be used in shaders that are built into a scene/resource "
"file."
msgstr ""
"Директива ``#include`` включає *весь* вміст файлу включення шейдера в "
"шейдері. ``\"path\"`` може бути абсолютним ``res://`` шляхом або відносно "
"поточного файлу шейдера. Відносні шляхи дозволені лише в шейдерах, "
"збережених у файлах ``.gdshader`` або ``.gdshaderinc``, тоді як абсолютні "
"шляхи можна використовувати в шейдерах, вбудованих у файл сцени/ресурсу."

msgid ""
"You can create new shader includes by using the **File > Create Shader "
"Include** menu option of the shader editor, or by creating a "
"new :ref:`ShaderInclude<class_ShaderInclude>` resource in the FileSystem "
"dock."
msgstr ""
"Ви можете створити нові включення шейдерів, скориставшись пунктом меню "
"**Файл > Створити шейдерне включення** редактора шейдерів або створивши "
"новий ресурс :ref:`ShaderInclude<class_ShaderInclude>` у доку FileSystem."

msgid ""
"Shader includes can be included from within any shader, or other shader "
"include, at any point in the file."
msgstr ""
"Включення шейдерів можна включити з будь-якого шейдера або іншого включення "
"шейдера в будь-яку точку файлу."

msgid ""
"When including shader includes in the global scope of a shader, it is "
"recommended to do this after the initial ``shader_type`` statement."
msgstr ""
"У разі включення шейдера до глобальної області шейдера рекомендується робити "
"це після початкового оператора ``shader_type``."

msgid ""
"You can also include shader includes from within the body a function. Please "
"note that the shader editor is likely going to report errors for your shader "
"include's code, as it may not be valid outside of the context that it was "
"written for. You can either choose to ignore these errors (the shader will "
"still compile fine), or you can wrap the include in an ``#ifdef`` block that "
"checks for a define from your shader."
msgstr ""
"Ви також можете включити функцію шейдера, що включає всередину тіла. Будь "
"ласка, зверніть увагу, що редактор шейдерів, імовірно, повідомлятиме про "
"помилки для коду вашого шейдера, оскільки він може бути недійсним поза "
"контекстом, для якого він був написаний. Ви можете або ігнорувати ці помилки "
"(шейдер все одно компілюватиметься нормально), або ви можете загорнути "
"включення в блок ``#ifdef``, який перевіряє визначення з вашого шейдера."

msgid ""
"``#include`` is useful for creating libraries of helper functions (or "
"macros) and reducing code duplication. When using ``#include``, be careful "
"about naming collisions, as redefining functions or macros is not allowed."
msgstr ""
"``#include`` корисний для створення бібліотек допоміжних функцій (або "
"макросів) і зменшення дублювання коду. Використовуючи ``#include``, будьте "
"обережні щодо колізій імен, оскільки перевизначення функцій або макросів "
"заборонено."

msgid "``#include`` is subject to several restrictions:"
msgstr "``#include`` підпадає під кілька обмежень:"

msgid ""
"Only shader include resources (ending with ``.gdshaderinc``) can be "
"included. ``.gdshader`` files cannot be included by another shader, but a "
"``.gdshaderinc`` file can include other ``.gdshaderinc`` files."
msgstr ""
"Можна включити лише ресурси включення шейдерів (закінчуються на "
"``.gdshaderinc``). Файли ``.gdshader`` не можуть бути включені іншим "
"шейдером, але файл ``.gdshaderinc`` може містити інші файли ``.gdshaderinc``."

msgid "Cyclic dependencies are **not** allowed and will result in an error."
msgstr "Циклічні залежності **не** дозволені та призведуть до помилки."

msgid "To avoid infinite recursion, include depth is limited to 25 steps."
msgstr ""
"Щоб уникнути нескінченної рекурсії, глибина включення обмежена 25 кроками."

msgid "Example shader include file:"
msgstr "Приклад включеного файлу шейдера:"

msgid "Example base shader (using the include file we created above):"
msgstr ""
"Приклад базового шейдера (з використанням включеного файлу, який ми створили "
"вище):"

msgid "#pragma"
msgstr "#pragma"

msgid "**Syntax:** ``#pragma value``"
msgstr "**Синтаксис:** ``#прагма значення``"

msgid ""
"The ``#pragma`` directive provides additional information to the "
"preprocessor or compiler."
msgstr ""
"Директива ``#pragma`` надає додаткову інформацію препроцесору або "
"компілятору."

msgid ""
"Currently, it may have only one value: ``disable_preprocessor``. If you "
"don't need the preprocessor, use that directive to speed up shader "
"compilation by excluding the preprocessor step."
msgstr ""
"Наразі він може мати лише одне значення: ``disable_preprocessor``. Якщо вам "
"не потрібен препроцесор, використовуйте цю директиву, щоб прискорити "
"компіляцію шейдера, виключивши крок препроцесора."

msgid "Built-in defines"
msgstr "Вбудований визначає"

msgid "Current renderer"
msgstr "Поточний рендерер"

msgid ""
"Since Godot 4.4, you can check which renderer is currently used with the "
"built-in defines ``CURRENT_RENDERER``, ``RENDERER_COMPATIBILITY``, "
"``RENDERER_MOBILE``, and ``RENDERER_FORWARD_PLUS``:"
msgstr ""
"Починаючи з Godot 4.4, ви можете перевірити, який рендерер зараз "
"використовується за допомогою вбудованих визначень ``CURRENT_RENDERER``, "
"``RENDERER_COMPATIBILITY``, ``RENDERER_MOBILE`` і ``RENDERER_FORWARD_PLUS``:"

msgid ""
"``CURRENT_RENDERER`` is set to either ``0``, ``1``, or ``2`` depending on "
"the current renderer."
msgstr ""
"``CURRENT_RENDERER`` має значення ``0``, ``1`` або ``2`` залежно від "
"поточного засобу відтворення."

msgid "``RENDERER_COMPATIBILITY`` is always ``0``."
msgstr "``RENDERER_COMPATIBILITY`` завжди ``0``."

msgid "``RENDERER_MOBILE`` is always ``1``."
msgstr "``RENDERER_MOBILE`` є завжди ``1``."

msgid "``RENDERER_FORWARD_PLUS`` is always ``2``."
msgstr "``RENDERER_FORWARD_PLUS`` є завжди ``2``."

msgid ""
"As an example, this shader sets ``ALBEDO`` to a different color in each "
"renderer:"
msgstr ""
"Як приклад, цей шейдер встановлює для ``ALBEDO`` інший колір у кожному "
"рендерері:"
