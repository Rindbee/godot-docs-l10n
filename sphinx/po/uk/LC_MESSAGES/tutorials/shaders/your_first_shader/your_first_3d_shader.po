#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "Ваш перший 3D-шейдер"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"Ви вирішили почати писати свій власний просторовий шейдер. Можливо, ви "
"побачили в Інтернеті класний трюк із шейдерами, або виявили, що :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>` не зовсім відповідає вашим "
"потребам. У будь-якому випадку, ви вирішили написати власний і тепер вам "
"потрібно зрозуміти, з чого почати."

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"Цей підручник пояснює, як написати просторовий шейдер, і охоплює більше тем, "
"ніж підручник :ref:`CanvasItem <doc_your_first_canvasitem_shader>`."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Просторові шейдери мають більше вбудованих функцій, ніж шейдери CanvasItem. "
"Очікування просторових шейдерів полягає в тому, що Godot вже надав "
"функціональні можливості для звичайних випадків використання, і все, що "
"користувачеві потрібно зробити в шейдері, це встановити правильні параметри. "
"Це особливо актуально для робочого процесу PBR (фізично орієнтоване "
"відтворення)."

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In the :ref:"
"`second part <doc_your_second_spatial_shader>` we will take the concepts "
"from this tutorial and set up custom materials in a fragment shader by "
"writing an ocean water shader."
msgstr ""
"Це підручник із двох частин. У цій першій частині ми створимо рельєф, "
"використовуючи зміщення вершин із карти висот у функції вершин. У :ref:"
"`другій частині <doc_your_second_spatial_shader>` ми візьмемо концепції з "
"цього підручника та налаштуємо спеціальні матеріали у фрагментному шейдері, "
"написавши шейдер океанської води."

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"Цей підручник передбачає деякі базові знання шейдерів, наприклад типи "
"(``vec2``, ``float``, ``sampler2D``) і функції. Якщо ви відчуваєте "
"дискомфорт із цими концепціями, найкраще ознайомитися з `Книгою шейдерів "
"<https://thebookofshaders.com>`_ перед тим, як завершити цей посібник."

msgid "Where to assign my material"
msgstr "Куди призначити мій матеріал"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a few :ref:"
"`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic geometry "
"to a scene without importing Meshes."
msgstr ""
"У 3D об’єкти малюються за допомогою :ref:`Meshes <class_Mesh>`. Сітки — це "
"тип ресурсу, який зберігає геометрію (форму вашого об’єкта) і матеріали "
"(колір і те, як об’єкт реагує на світло) в одиницях, які називаються "
"«поверхнями». Сітка може мати кілька поверхонь або лише одну. Як правило, ви "
"імпортуєте меш з іншої програми (наприклад, Blender). Але Godot також має "
"кілька :ref:`PrimitiveMeshes <class_primitivemesh>`, які дозволяють вам "
"додавати базову геометрію до сцени без імпорту Meshes."

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also use :ref:"
"`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"Існує кілька типів вузлів, які можна використовувати для малювання сітки. "
"Основний з них :ref:`MeshInstance3D <class_MeshInstance3D>`, але ви також "
"можете використовувати :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:"
"`MultiMeshes <class_MultiMesh>` (з :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), або інші."

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"Як правило, матеріал пов’язується з певною поверхнею в сітці, але деякі "
"вузли, як-от MeshInstance3D, дозволяють замінити матеріал для певної "
"поверхні або для всіх поверхонь."

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"Якщо ви встановлюєте матеріал на саму поверхню або сітку, то всі "
"MeshInstance3D, які спільно використовують цю сітку, матимуть спільний "
"доступ до цього матеріалу. Однак, якщо ви хочете повторно використовувати ту "
"саму сітку в кількох екземплярах сітки, але мати різні матеріали для кожного "
"екземпляра, вам слід встановити матеріал у MeshInstance3D."

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"У цьому підручнику ми встановимо наш матеріал на самій сітці, а не "
"скористаємося можливістю MeshInstance3D перевизначати матеріали."

msgid "Setting up"
msgstr "Налаштування"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr ""
"Додайте новий вузол :ref:`MeshInstance3D <class_MeshInstance3D>` до вашої "
"сцени."

msgid ""
"In the inspector tab beside \"Mesh\" click \"[empty]\" and select \"New "
"PlaneMesh\". Then click on the image of a plane that appears."
msgstr ""
"На вкладці інспектора поруч із «Mesh» натисніть «[порожній]» і виберіть «New "
"PlaneMesh». Потім натисніть на зображення літака, яке з'явиться."

msgid "This adds a :ref:`PlaneMesh <class_planemesh>` to our scene."
msgstr "Це додає :ref:`PlaneMesh <class_planemesh>` до нашої сцени."

msgid ""
"Then, in the viewport, click in the upper left corner on the button that "
"says \"Perspective\". A menu will appear. In the middle of the menu are "
"options for how to display the scene. Select 'Display Wireframe'."
msgstr ""
"Потім у вікні перегляду клацніть у верхньому лівому куті кнопку з написом "
"«Перспектива». З'явиться меню. Посередині меню є параметри, як відобразити "
"сцену. Виберіть «Показати каркас»."

msgid "This will allow you to see the triangles making up the plane."
msgstr "Це дозволить вам побачити трикутники, що утворюють площину."

msgid ""
"Now set ``Subdivide Width`` and ``Subdivide Depth`` of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"Тепер встановіть ``Subdivide Width`` і ``Subdivide Depth`` :ref:`PlaneMesh "
"<class_planemesh>` на ``32``."

msgid ""
"You can see that there are now many more triangles in the :ref:"
"`MeshInstance3D<class_MeshInstance3D>`. This will give us more vertices to "
"work with and thus allow us to add more detail."
msgstr ""
"Ви бачите, що тепер у :ref:`MeshInstance3D<class_MeshInstance3D>` набагато "
"більше трикутників. Це дасть нам більше вершин для роботи і, таким чином, "
"дозволить додати більше деталей."

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Click beside "
"\"Material\" where it says \"[empty]\" and select \"New ShaderMaterial\". "
"Then click the sphere that appears."
msgstr ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, як і PlaneMesh, мають лише "
"одну поверхню, тому замість масиву матеріалів є лише одна. Клацніть поруч із "
"«Матеріалом», де написано «[порожній]», і виберіть «Новий матеріал шейдера». "
"Потім натисніть сферу, що з’явиться."

msgid ""
"Now click beside \"Shader\" where it says \"[empty]\" and select \"New "
"Shader\"."
msgstr ""
"Тепер клацніть поруч із «Шейдером», де написано «[порожній]», і виберіть "
"«Новий шейдер»."

msgid ""
"The shader editor should now pop up and you are ready to begin writing your "
"first Spatial shader!"
msgstr ""
"Тепер має з’явитися редактор шейдерів, і ви готові почати писати свій перший "
"просторовий шейдер!"

msgid "Shader magic"
msgstr "Магія шейдерів"

msgid ""
"The new shader is already generated with a ``shader_type`` variable and the "
"``fragment()`` function. The first thing Godot shaders need is a declaration "
"of what type of shader they are. In this case the ``shader_type`` is set to "
"``spatial`` because this is a spatial shader."
msgstr ""
"Новий шейдер уже створено за допомогою змінної ``shader_type`` і функції "
"``fragment()``. Перше, що потрібно шейдерам Godot, це декларація типу "
"шейдера. У цьому випадку для ``shader_type`` встановлено ``spatial``, тому "
"що це просторовий шейдер."

msgid ""
"For now ignore the ``fragment()`` function and define the ``vertex()`` "
"function. The ``vertex()`` function determines where the vertices of your :"
"ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. We "
"will be using it to offset the height of each vertex and make our flat plane "
"appear like a little terrain."
msgstr ""
"Наразі ігноруйте функцію ``fragment()`` і визначте функцію ``vertex()``. "
"Функція ``vertex()`` визначає, де з’являться вершини вашого :ref:"
"`MeshInstance3D<class_MeshInstance3D>` у фінальній сцені. Ми будемо "
"використовувати його, щоб змістити висоту кожної вершини, щоб наша плоска "
"площина виглядала як маленька місцевість."

msgid "We define the vertex shader like so:"
msgstr "Ми розуміємо вершинний шейдер так:"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""
"Не маючи нічого у функції ``vertex()``, Godot використовуватиме свій типовий "
"вершинний шейдер. Ми можемо легко почати вносити зміни, додавши один рядок:"

msgid "Adding this line, you should get an image like the one below."
msgstr ""
"Додавши цей рядок, ви повинні отримати зображення, схоже на наведене нижче."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""
"Гаразд, давайте розпакуємо це. Значення ``y`` ``VERTEX`` збільшується. І ми "
"передаємо компоненти ``x`` і ``z`` ``VERTEX`` як аргументи ``cos`` і "
"``sin``; що дає нам хвилеподібний вигляд по осях ``x`` і ``z``."

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""
"Ми хочемо отримати вигляд невеликих пагорбів; адже. ``cos`` і ``sin`` вже "
"схожі на пагорби. Ми робимо це, масштабуючи вхідні дані для функцій ``cos`` "
"і ``sin``."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr ""
"Це виглядає краще, але воно все ще занадто гостре та повторюване, давайте "
"зробимо це трохи цікавішим."

msgid "Noise heightmap"
msgstr "Карта висоти шуму"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"Шум є дуже популярним інструментом для підробки вигляду місцевості. "
"Подумайте про це як про функцію косинуса, де у вас є пагорби, що "
"повторюються, за винятком того, що з шумом кожен пагорб має різну висоту."

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot надає ресурс :ref:`NoiseTexture2D <class_noisetexture2D>` для "
"створення шумової текстури, до якої можна отримати доступ із шейдера."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"Щоб отримати доступ до текстури в шейдері, додайте наступний код у верхній "
"частині шейдера поза функцією ``vertex()``."

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called \"Shader "
"Params\". If you open it up, you'll see a section called \"noise\"."
msgstr ""
"Це дозволить вам надіслати текстуру шуму в шейдер. Тепер подивіться в "
"інспекторі під ваш матеріал. Ви повинні побачити розділ під назвою "
"«Параметри шейдера». Якщо ви відкриєте його, ви побачите розділ під назвою "
"«шум»."

msgid ""
"Click beside it where it says \"[empty]\" and select \"New NoiseTexture2D\". "
"Then in your :ref:`NoiseTexture2D <class_noisetexture2D>` click beside where "
"it says \"Noise\" and select \"New FastNoiseLite\"."
msgstr ""
"Клацніть біля нього там, де написано «[порожній]» і виберіть «Нова "
"NoiseTexture2D». Потім у вашому :ref:`NoiseTexture2D <class_noisetexture2D>` "
"клацніть поруч із написом «Шум» і виберіть «Новий FastNoiseLite»."

msgid ""
":ref:`FastNoiseLite <class_fastnoiselite>` is used by the NoiseTexture2D to "
"generate a heightmap."
msgstr ""
":ref:`FastNoiseLite <class_fastnoiselite>` використовується NoiseTexture2D "
"для створення карти висот."

msgid "Once you set it up and should look like this."
msgstr "Після того, як ви налаштуєте його, він повинен виглядати так."

msgid ""
"Now, access the noise texture using the ``texture()`` function. "
"``texture()`` takes a texture as the first argument and a ``vec2`` for the "
"position on the texture as the second argument. We use the ``x`` and ``z`` "
"channels of ``VERTEX`` to determine where on the texture to look up. Note "
"that the PlaneMesh coordinates are within the [-1,1] range (for a size of "
"2), while the texture coordinates are within [0,1], so to normalize we "
"divide by the size of the PlaneMesh by 2.0 and add 0.5. ``texture()`` "
"returns a ``vec4`` of the ``r, g, b, a`` channels at the position. Since the "
"noise texture is grayscale, all of the values are the same, so we can use "
"any one of the channels as the height. In this case we'll use the ``r``, or "
"``x`` channel."
msgstr ""
"Тепер отримайте доступ до текстури шуму за допомогою функції ``texture()``. "
"``texture()`` приймає текстуру як перший аргумент і ``vec2`` для позиції на "
"текстурі як другий аргумент. Ми використовуємо канали ``x`` і ``z`` "
"``VERTEX``, щоб визначити, де на текстурі шукати. Зверніть увагу, що "
"координати PlaneMesh знаходяться в діапазоні [-1,1] (для розміру 2), тоді як "
"координати текстури знаходяться в межах [0,1], тому для нормалізації ми "
"ділимо розмір PlaneMesh на 2,0 і додаємо 0,5. ``texture()`` повертає "
"``vec4`` каналів ``r, g, b, a`` у позиції. Оскільки текстура шуму є "
"відтінками сірого, усі значення однакові, тому ми можемо використовувати "
"будь-який із каналів як висоту. У цьому випадку ми будемо використовувати "
"канал ``r`` або ``x`` канал."

msgid ""
"Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture()."
"x`` above, we could use ``texture().r``. See the `OpenGL documentation "
"<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more "
"details."
msgstr ""
"Примітка: ``xyzw`` те саме, що ``rgba`` в GLSL, тому замість ``texture().x`` "
"вище, ми можемо використовувати ``texture().r``. Додаткову інформацію див. у "
"`документації OpenGL <https://www.khronos.org/opengl/wiki/"
"Data_Type_(GLSL)#Vectors>`_."

msgid "Using this code you can see the texture creates random looking hills."
msgstr ""
"Використовуючи цей код, ви можете побачити, як текстура створює випадкові "
"пагорби."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"Зараз він занадто гострий, ми хочемо трохи пом’якшити пагорби. Для цього ми "
"будемо використовувати форму. Ви вже використовували уніформу вище, щоб "
"передати текстуру шуму, тепер давайте дізнаємося, як вони працюють."

msgid "Uniforms"
msgstr "Уніформа"

msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"are very useful for controlling shader effects. Uniforms can be almost any "
"datatype that can be used in the shader. To use a uniform, you declare it in "
"your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""
"Uniform змінні дозволяють передавати дані з гри в шейдер. Вони дуже корисні "
"для керування ефектами шейдерів. Уніформи можуть мати майже будь-який тип "
"даних, який можна використовувати в шейдері. Щоб використовувати уніформу, "
"ви оголосите її у своєму :ref:`Shader<class_Shader>` за допомогою ключового "
"слова ``uniform``."

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "Зробимо форму, яка змінює висоту місцевості."

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the function "
"``set_shader_parameter()`` on the material corresponding to the shader. The "
"value passed from GDScript takes precedence over the value used to "
"initialize it in the shader."
msgstr ""
"Godot дозволяє ініціалізувати уніформу значенням; тут ``height_scale`` "
"встановлено на ``0,5``. Ви можете встановити уніформи з GDScript, викликавши "
"функцію ``set_shader_parameter()`` для матеріалу, що відповідає шейдеру. "
"Значення, передане з GDScript, має пріоритет над значенням, яке "
"використовується для його ініціалізації в шейдері."

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"Зміна уніформ у просторових вузлах відрізняється від вузлів на основі "
"CanvasItem. Тут ми встановлюємо матеріал всередині ресурсу PlaneMesh. В "
"інших мережевих ресурсах вам може знадобитися спочатку отримати доступ до "
"матеріалу, викликавши ``surface_get_material()``. У MeshInstance3D ви "
"отримаєте доступ до матеріалу за допомогою ``get_surface_material()`` або "
"``material_override``."

msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the :ref:`Shader<class_Shader>`. You can "
"use the uniform variable anywhere inside your :ref:`Shader<class_Shader>`. "
"Here, we will use it to set the height value instead of arbitrarily "
"multiplying by ``0.5``."
msgstr ""
"Пам’ятайте, що рядок, переданий у ``set_shader_parameter()``, має збігатися "
"з назвою уніфікованої змінної в :ref:`Shader<class_Shader>`. Ви можете "
"використовувати змінну uniform будь-де всередині вашого :ref:"
"`Shader<class_Shader>`. Тут ми будемо використовувати його для встановлення "
"значення висоти замість довільного множення на ``0,5``."

msgid "Now it looks much better."
msgstr "Тепер це виглядає набагато краще."

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"Використовуючи форму, ми навіть можемо змінювати значення кожного кадру, щоб "
"анімувати висоту місцевості. У поєднанні з :ref:`Tweens <class_Tween>` це "
"може бути особливо корисним для анімації."

msgid "Interacting with light"
msgstr "Взаємодія зі світлом"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"Зверніть увагу, як колір сітки стає рівним. Це пояснюється тим, що "
"освітлення на ньому рівне. Додамо світла!"

msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene."
msgstr "Спочатку ми додамо :ref:`OmniLight3D<class_OmniLight3D>` до сцени."

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"Ви можете побачити, як світло впливає на місцевість, але це виглядає дивно. "
"Проблема в тому, що світло впливає на рельєф так, ніби це плоска площина. Це "
"тому, що світлотіньовий шейдер використовує нормалі з :ref:`Mesh "
"<class_mesh>` для обчислення світла."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"Нормалі зберігаються в Mesh, але ми змінюємо форму Mesh у шейдері, тому "
"нормалі більше не правильні. Щоб виправити це, ми можемо перерахувати "
"нормалі в шейдері або використати нормальну текстуру, яка відповідає нашому "
"шуму. Ґодо полегшує нам і те, і інше."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"Ви можете обчислити нову нормаль вручну у функції вершини, а потім просто "
"встановити ``NORMAL``. З установкою ``NORMAL`` Годо виконає всі складні "
"розрахунки освітлення за нас. Ми розглянемо цей метод у наступній частині "
"цього уроку, а поки ми будемо читати нормалі з текстури."

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"Замість цього ми знову покладатимемося на NoiseTexture для розрахунку "
"нормалей. Ми робимо це, передаючи другу текстуру шуму."

msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normalmap**."
msgstr ""
"Встановіть цю другу однорідну текстуру на іншу :ref:`NoiseTexture2D "
"<class_noisetexture2D>` з іншою :ref:`FastNoiseLite <class_fastnoiselite>`. "
"Але цього разу позначте **Як Normalmap**."

msgid ""
"Now, because this is a normalmap and not a per-vertex normal, we are going "
"to assign it in the ``fragment()`` function. The ``fragment()`` function "
"will be explained in more detail in the next part of this tutorial."
msgstr ""
"Тепер, оскільки це нормаль, а не вершинна нормаль, ми збираємося призначити "
"її у функції ``fragment()``. Функцію ``fragment()`` буде пояснено більш "
"детально в наступній частині цього посібника."

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP``. This way Godot will handle the wrapping of texture around "
"the mesh automatically."
msgstr ""
"Якщо у нас є нормалі, які відповідають певній вершині, ми встановлюємо "
"``NORMAL``, але якщо у вас є нормаль, яка походить від текстури, "
"встановлюйте нормаль за допомогою ``NORMAL_MAP``. Таким чином Godot "
"автоматично оброблятиме обгортання текстури навколо сітки."

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the ``VERTEX."
"xz`` position from the ``vertex()`` function to the ``fragment()`` function. "
"We do that with varyings."
msgstr ""
"Насамкінець, щоб переконатися, що ми читаємо з тих самих місць текстури шуму "
"та текстури карти нормалей, ми передамо позицію ``VERTEX.xz`` з функції "
"``vertex()`` до ` функція `fragment()``. Ми робимо це з варіаціями."

msgid ""
"Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside "
"the ``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``."
msgstr ""
"Над ``vertex()`` визначте ``vec2`` під назвою ``tex_position`` І всередині "
"функції ``vertex()`` призначте ``VERTEX.xz`` до ``tex_position``."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr ""
"І тепер ми можемо отримати доступ до ``tex_position`` з функції "
"``fragment()``."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr ""
"З установленими нормалями світло тепер динамічно реагує на висоту сітки."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr ""
"Ми навіть можемо перетягувати світло, і освітлення оновлюватиметься "
"автоматично."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"Ось повний код для цього підручника. Ви бачите, що це не дуже довго, "
"оскільки Годо впорається з більшістю складних речей за вас."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"Це все для цієї частини. Сподіваємось, тепер ви розумієте основи вершинних "
"шейдерів у Godot. У наступній частині цього посібника ми напишемо функцію "
"фрагмента, яка супроводжуватиме цю вершинну функцію, і розглянемо більш "
"просунуту техніку, щоб перетворити цю місцевість на океан рухомих хвиль."
