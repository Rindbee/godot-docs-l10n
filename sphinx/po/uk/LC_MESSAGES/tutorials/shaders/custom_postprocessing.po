#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "Індивідуальна постобробка"

msgid "Introduction"
msgstr "Вступ"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described "
"in :ref:`doc_environment_and_post_processing`. However, advanced use cases "
"may require custom effects. This article explains how to write your own "
"custom effects."
msgstr ""
"Godot надає багато ефектів постобробки з коробки, включаючи Bloom, DOF і "
"SSAO, які описані в :ref:`doc_environment_and_post_processing`. Однак для "
"розширених випадків використання можуть знадобитися спеціальні ефекти. У цій "
"статті пояснюється, як написати власні ефекти."

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"Найпростіший спосіб реалізувати власний шейдер постобробки - використати "
"вбудовану у Godot можливість зчитування текстури з екрана. Якщо ви не "
"знайомі з цією можливістю, вам слід спершу прочитати :ref:`Screen Reading "
"Shaders Tutorial <doc_screen-reading_shaders>`."

msgid "Single pass post-processing"
msgstr "Однопрохідна постобробка"

msgid "Your scene tree will look something like this:"
msgstr "Ваше дерево сцен буде виглядати приблизно так:"

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"Інший більш ефективний метод полягає у використанні :ref:`BackBufferCopy "
"<class_BackBufferCopy>`, щоб скопіювати область екрана в буфер і отримати "
"доступ до неї в шейдерному сценарії через ``sampler2D`` за допомогою "
"``hint_screen_texture``."

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"На момент написання Godot не підтримує відтворення в кількох буферах "
"одночасно. Ваш шейдер після обробки не матиме доступу до інших проходів "
"візуалізації та буферів, які не показує Godot (таких як глибина або норма/"
"шорсткість). Ви маєте доступ лише до візуалізованого кадру та буферів, "
"наданих Godot як вибірки."

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr ""
"Для цієї демонстрації ми використаємо цей :ref:`Sprite <class_Sprite2D>` із "
"зображенням вівці."

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built-in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"Призначте новий :ref:`Shader <class_Shader>` до ``ShaderMaterial`` "
"``ColorRect``. Ви можете отримати доступ до текстури кадру та UV за "
"допомогою ``sampler2D`` за допомогою ``hint_screen_texture`` і вбудованої "
"форми ``SCREEN_UV``."

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"Скопіюйте наступний код у свій шейдер. Наведений нижче код є шейдером "
"шістнадцяткової пікселізації від `arlez80 <https://bitbucket.org/arlez80/hex-"
"mosaic/src/master/>`_,"

msgid "The sheep will look something like this:"
msgstr "Вівця буде виглядати приблизно так:"

msgid "Multi-pass post-processing"
msgstr "Багатопрохідна постобробка"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"Деякі ефекти постобробки, такі як розмиття, потребують ресурсів. Ви можете "
"змусити їх працювати набагато швидше, якщо розбити їх за кілька проходів. У "
"багатопрохідному матеріалі кожен прохід приймає результат попереднього "
"проходу як вхідні дані та обробляє його."

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"Щоб створити багатопрохідний шейдер постобробки, ви складають вузли "
"``CanvasLayer`` і ``ColorRect``. У наведеному вище прикладі ви "
"використовуєте об’єкт ``CanvasLayer`` для відтворення шейдера за допомогою "
"рамки на шарі нижче. Окрім структури вузлів, кроки такі самі, як і для "
"однопрохідного шейдера постобробки."

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"Як приклад, ви можете написати повноекранний ефект розмиття за Гауссом, "
"прикріпивши наступні фрагменти коду до кожного з вузлів ``ColorRect``. "
"Порядок, у якому ви застосовуєте шейдери, залежить від позиції "
"``CanvasLayer`` у дереві сцени, вище означає раніше. Для цього шейдера "
"розмиття порядок не має значення."

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr ""
"Використовуючи наведений вище код, ви повинні отримати ефект розмиття на "
"весь екран, як показано нижче."
