#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using multiple threads"
msgstr "Використання кількох потоків"

msgid "Threads"
msgstr "Потоки"

msgid ""
"Threads allow simultaneous execution of code. It allows off-loading work "
"from the main thread."
msgstr ""
"Потоки дозволяють одночасне виконання коду. Це дозволяє знімати навантаження "
"з основного потоку."

msgid "Godot supports threads and provides many handy functions to use them."
msgstr ""
"Godot підтримує потоки та надає багато зручних функцій для їх використання."

msgid ""
"If using other languages (C#, C++), it may be easier to use the threading "
"classes they support."
msgstr ""
"Якщо ви використовуєте інші мови (C#, C++), можливо, буде легше "
"використовувати класи потоків, які вони підтримують."

msgid ""
"Before using a built-in class in a thread, read :ref:`doc_thread_safe_apis` "
"first to check whether it can be safely used in a thread."
msgstr ""
"Перш ніж використовувати вбудований клас у потоці, спочатку "
"прочитайте :ref:`doc_thread_safe_apis`, щоб перевірити, чи можна безпечно "
"використовувати його в потоці."

msgid "Creating a Thread"
msgstr "Створення потоку"

msgid "To create a thread, use the following code:"
msgstr "Щоб створити потік, використовуйте наступний код:"

msgid ""
"Your function will, then, run in a separate thread until it returns. Even if "
"the function has returned already, the thread must collect it, so "
"call :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, "
"which will wait until the thread is done (if not done yet), then properly "
"dispose of it."
msgstr ""
"Тоді ваша функція виконуватиметься в окремому потоці, доки не повернеться. "
"Навіть якщо функція вже повернулася, потік має її зібрати, тому "
"викличте :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, "
"яка чекатиме, поки потік завершиться (якщо ще не завершено), а потім "
"належним чином утилізує його."

msgid ""
"Creating threads is a slow operation, especially on Windows. To avoid "
"unnecessary performance overhead, make sure to create threads before heavy "
"processing is needed instead of creating threads just-in-time."
msgstr ""
"Створення потоків є повільною операцією, особливо в Windows. Щоб уникнути "
"непотрібних витрат на продуктивність, створюйте потоки до того, як "
"знадобиться важка обробка, замість того, щоб створювати потоки вчасно."

msgid ""
"For example, if you need multiple threads during gameplay, you can create "
"threads while the level is loading and only actually start processing with "
"them later on."
msgstr ""
"Наприклад, якщо вам потрібно кілька потоків під час гри, ви можете створити "
"потоки під час завантаження рівня й фактично розпочати їх обробку пізніше."

msgid ""
"Additionally, locking and unlocking of mutexes can also be an expensive "
"operation. Locking should be done carefully; avoid locking too often (or for "
"too long)."
msgstr ""
"Крім того, блокування та розблокування м'ютексів також може бути дорогою "
"операцією. Замикання слід проводити акуратно; уникайте занадто частого (або "
"надто тривалого) блокування."

msgid "Mutexes"
msgstr "Мьютекси"

msgid ""
"Accessing objects or data from multiple threads is not always supported (if "
"you do it, it will cause unexpected behaviors or crashes). Read "
"the :ref:`doc_thread_safe_apis` documentation to understand which engine "
"APIs support multiple thread access."
msgstr ""
"Доступ до об’єктів або даних із кількох потоків не завжди підтримується "
"(якщо ви це зробите, це призведе до неочікуваної поведінки або збоїв). "
"Прочитайте документацію :ref:`doc_thread_safe_apis`, щоб зрозуміти, які API "
"механізму підтримують багатопотоковий доступ."

msgid ""
"When processing your own data or calling your own functions, as a rule, try "
"to avoid accessing the same data directly from different threads. You may "
"run into synchronization problems, as the data is not always updated between "
"CPU cores when modified. Always use a :ref:`Mutex<class_Mutex>` when "
"accessing a piece of data from different threads."
msgstr ""
"Під час обробки власних даних або виклику власних функцій, як правило, "
"намагайтеся уникати доступу до тих самих даних безпосередньо з різних "
"потоків. Ви можете зіткнутися з проблемами синхронізації, оскільки дані не "
"завжди оновлюються між ядрами ЦП у разі їх зміни. Завжди "
"використовуйте :ref:`Mutex<class_Mutex>` під час доступу до частини даних з "
"різних потоків."

msgid ""
"When calling :ref:`Mutex.lock()<class_Mutex_method_lock>`, a thread ensures "
"that all other threads will be blocked (put on suspended state) if they try "
"to *lock* the same mutex. When the mutex is unlocked by "
"calling :ref:`Mutex.unlock()<class_Mutex_method_unlock>`, the other threads "
"will be allowed to proceed with the lock (but only one at a time)."
msgstr ""
"Під час виклику :ref:`Mutex.lock()<class_Mutex_method_lock>` потік гарантує, "
"що всі інші потоки будуть заблоковані (переведені в стан призупинення), якщо "
"вони спробують *заблокувати* той самий м’ютекс. Коли м’ютекс розблоковано "
"викликом :ref:`Mutex.unlock()<class_Mutex_method_unlock>`, іншим потокам "
"буде дозволено продовжити блокування (але лише по одному)."

msgid "Here is an example of using a Mutex:"
msgstr "Ось приклад використання Mutex:"

msgid "Semaphores"
msgstr "Семафори"

msgid ""
"Sometimes you want your thread to work *\"on demand\"*. In other words, tell "
"it when to work and let it suspend when it isn't doing anything. For "
"this, :ref:`Semaphores<class_Semaphore>` are used. The "
"function :ref:`Semaphore.wait()<class_Semaphore_method_wait>` is used in the "
"thread to suspend it until some data arrives."
msgstr ""
"Іноді ви хочете, щоб ваш потік працював *\"на вимогу\"*. Іншими словами, "
"скажіть йому, коли працювати, і дозвольте йому призупинити, коли він нічого "
"не робить. Для цього використовуються :ref:`Semaphores<class_Semaphore>`. "
"Функція :ref:`Semaphore.wait()<class_Semaphore_method_wait>` "
"використовується в потоці, щоб призупинити його до отримання певних даних."

msgid ""
"The main thread, instead, "
"uses :ref:`Semaphore.post()<class_Semaphore_method_post>` to signal that "
"data is ready to be processed:"
msgstr ""
"Натомість основний потік "
"використовує :ref:`Semaphore.post()<class_Semaphore_method_post>`, щоб "
"повідомити, що дані готові до обробки:"
