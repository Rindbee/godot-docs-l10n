#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "оптимізація"

msgid "Optimizing 3D performance"
msgstr "Оптимізація продуктивності 3D"

msgid "Culling"
msgstr "Вибракування"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot автоматично виконає відсікання кута перегляду, щоб запобігти "
"візуалізації об’єктів, які знаходяться за межами вікна перегляду. Це добре "
"працює для ігор, які відбуваються на невеликій території, проте все може "
"швидко стати проблематичним на великих рівнях."

msgid "Occlusion culling"
msgstr "Вибракування оклюзії"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"Наприклад, гуляючи містом, ви можете побачити лише кілька будівель на "
"вулиці, де ви перебуваєте, а також небо та кілька птахів, що літають над "
"головою. Що стосується наївного рендерера, ви все одно можете побачити все "
"місто. Він не просто візуалізує будівлі перед вами, він відобразить вулицю "
"позаду, з людьми на цій вулиці, будівлями позаду. Ви швидко потрапляєте в "
"ситуації, коли намагаєтесь відобразити на 10 або 100 разів більше, ніж "
"видиме."

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"Усе не так погано, як здається, оскільки Z-буфер зазвичай дозволяє "
"графічному процесору повністю затінювати лише ті об’єкти, які знаходяться "
"спереду. Це називається *depth prepass* і ввімкнено за замовчуванням у Godot "
"під час використання методів візуалізації Forward+ або Compatibility. Однак "
"непотрібні об’єкти все ще знижують продуктивність."

msgid ""
"One way we can potentially reduce the amount to be rendered is to **take "
"advantage of occlusion**. Godot 4.0 and later offers a new approach to "
"occlusion culling using occluder nodes. See :ref:`doc_occlusion_culling` for "
"instructions on setting up occlusion culling in your scene."
msgstr ""
"Один із способів потенційно зменшити кількість відтворюваних зображень — "
"**використати перевагу оклюзії**. Godot 4.0 і новіші версії пропонують новий "
"підхід до видалення оклюзії за допомогою вузлів оклюзії. Перегляньте :ref:"
"`doc_occlusion_culling` для отримання інструкцій щодо налаштування "
"відсічення оклюзії у вашій сцені."

msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"У деяких випадках вам, можливо, доведеться адаптувати дизайн рівня, щоб "
"додати більше можливостей оклюзії. Наприклад, можливо, вам доведеться додати "
"більше стін, щоб запобігти тому, щоб гравець бачив надто далеко, що призведе "
"до зниження продуктивності через втрату можливостей для вилучення оклюзії."

msgid "Transparent objects"
msgstr "Прозорі об'єкти"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot сортує об’єкти за :ref:`Material <class_Material>` і :ref:`Shader "
"<class_Shader>` для покращення продуктивності. Однак цього не можна зробити "
"з прозорими об'єктами. Прозорі об’єкти візуалізуються ззаду вперед, щоб "
"злити те, що знаходиться позаду. Тому **намагайтеся використовувати якомога "
"менше прозорих об’єктів**. Якщо об’єкт має невелику ділянку з прозорістю, "
"спробуйте зробити цю ділянку окремою поверхнею з власного матеріалу."

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr ""
"Додаткову інформацію див. у документі :ref:`GPU optimizations "
"<doc_gpu_optimization>`."

msgid "Level of detail (LOD)"
msgstr "Рівень деталізації (LOD)"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"У деяких ситуаціях, особливо на відстані, може бути гарною ідеєю **замінити "
"складну геометрію на простіші версії**. Кінцевий користувач, ймовірно, не "
"зможе побачити великої різниці. Подивіться на велику кількість дерев у "
"великій відстані. Існує кілька стратегій заміни моделей на різній відстані. "
"Ви можете використовувати нижчі полігональні моделі або використовувати "
"прозорість для імітації складнішої геометрії."

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 пропонує кілька способів керування рівнем деталізації:"

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr "Автоматичний підхід до імпорту сітки за допомогою :ref:`doc_mesh_lod`."

msgid ""
"A manual approach configured in the 3D node using :ref:"
"`doc_visibility_ranges`."
msgstr ""
"Ручний підхід, налаштований у 3D-вузлі за допомогою :ref:"
"`doc_visibility_ranges`."

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""
":ref:`Decals <doc_using_decals>` і :ref:`lights <doc_lights_and_shadows>` "
"також можуть виграти від рівня деталізації за допомогою відповідних "
"властивостей **Distance Fade**."

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""
"Хоча їх можна використовувати окремо, ці підходи є найбільш ефективними, "
"якщо використовувати разом. Наприклад, ви можете налаштувати діапазони "
"видимості, щоб приховати ефекти частинок, які занадто далеко від гравця, щоб "
"їх помітити. У той же час ви можете покластися на LOD сітки, щоб сітки "
"ефекту частинок відтворювалися з меншою кількістю деталей на відстані."

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr ""
"Діапазони видимості також є хорошим способом налаштувати *імпостори* для "
"віддаленої геометрії (див. нижче)."

msgid "Billboards and imposters"
msgstr "Рекламні щити та самозванці"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, see :ref:"
"`doc_gpu_optimization`)."
msgstr ""
"Найпростішим варіантом використання прозорості для боротьби з LOD є "
"білборди. Наприклад, ви можете використовувати один прозорий квадрат для "
"представлення дерева на відстані. Це може бути дуже дешевим для "
"візуалізації, якщо, звичайно, немає багато дерев одне перед одним. У цьому "
"випадку прозорість може почати з’їдати рівень заповнення (додаткову "
"інформацію про рівень заповнення див. :ref:`doc_gpu_optimization`)."

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"Альтернативою є візуалізація не лише одного дерева, а кількох дерев разом як "
"група. Це може бути особливо ефективним, якщо ви бачите певну область, але "
"не можете фізично наблизитися до неї під час гри."

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"Ви можете створювати самозванців, попередньо відображаючи види об’єкта під "
"різними кутами. Або ви навіть можете піти ще далі й періодично повторно "
"візуалізувати вигляд об’єкта на текстурі, яка буде використовуватися як "
"самозванець. На відстані потрібно відсунути глядача на значну відстань, щоб "
"кут зору суттєво змінився. Це може бути складним завданням, але воно того "
"варте залежно від типу проекту, який ви робите."

msgid "Use instancing (MultiMesh)"
msgstr "Використання екземплярів (MultiMesh)"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"Якщо потрібно намалювати кілька ідентичних об’єктів в одному місці або "
"поруч, спробуйте замість цього використати :ref:`MultiMesh "
"<class_MultiMesh>`. MultiMesh дозволяє малювати багато тисяч об’єктів за "
"дуже низьких витрат на продуктивність, що робить його ідеальним для зграй, "
"трави, частинок і всього іншого, де у вас є тисячі ідентичних об’єктів."

msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr ""
"Дивіться також документацію :ref:`Using MultiMesh <doc_using_multimesh>`."

msgid "Bake lighting"
msgstr "Випічка освітлення"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"Освітлення об'єктів - одна з найбільш витратних операцій рендеринга. "
"Освітлення в реальному часі, тіні (особливо кілька джерел світла) і :ref:"
"`глобальне освітлення <doc_introduction_to_global_illumination>` є особливо "
"дорогими. Їх може виявитися занадто багато для мобільних пристроїв з меншою "
"потужністю."

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**Подумайте про використання запеченого освітлення**, особливо для мобільних "
"пристроїв. Це може виглядати фантастично, але має недолік — не буде "
"динамічним. Іноді це компроміс, на який варто піти."

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""
"Перегляньте :ref:`doc_using_lightmap_gi` для отримання інструкцій щодо "
"використання запечених карт світла. Для найкращої продуктивності вам слід "
"встановити режим запікання вогнів на **Статичний** на відміну від "
"**Динамічного** за замовчуванням, оскільки це пропускатиме освітлення в "
"реальному часі на сітках із запікаючим освітленням."

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for the :ref:"
"`class_DirectionalLight3D` node, and use **Static** for most (if not all) "
"omni and spot lights."
msgstr ""
"Недоліком світильників із **Статичним** режимом запікання є те, що вони не "
"можуть відкидати тіні на сітку з запіканням освітлення. Це може зробити "
"сцени з зовнішнім середовищем і динамічними об’єктами виглядати плоскими. "
"Хороший баланс між продуктивністю та якістю полягає в тому, щоб зберегти "
"**Dynamic** для вузла :ref:`class_DirectionalLight3D` і використовувати "
"**Static** для більшості (якщо не всіх) універсальних і точкових "
"світильників."

msgid "Animation and skinning"
msgstr "Анімація та скінінг"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"На деяких платформах анімація та анімація вершин, як-от скінінг та морфінг, "
"можуть бути дуже дорогими. Можливо, вам знадобиться значно знизити кількість "
"полігонів для анімованих моделей або обмежити їх кількість на екрані в будь-"
"який момент часу. Ви також можете зменшити швидкість анімації для віддалених "
"або закритих сіток або повністю призупинити анімацію, якщо гравець навряд чи "
"помітить зупинку анімації."

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` and :ref:"
"`class_VisibleOnScreenNotifier3D` nodes can be useful for this purpose."
msgstr ""
"Для цієї мети можуть бути корисними вузли :ref:"
"`class_VisibleOnScreenEnabler3D` і :ref:`class_VisibleOnScreenNotifier3D`."

msgid "Large worlds"
msgstr "Великі світи"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr ""
"Якщо ви створюєте великі світи, є інші міркування, ніж ті, які вам знайомі з "
"менших ігор."

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"Великі світи, можливо, доведеться побудувати в тайлах, які можна "
"завантажувати на вимогу під час руху по світу. Це може запобігти виходу з-"
"під контролю використання пам’яті, а також обмежити необхідну обробку "
"локальною областю."

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved using :ref:"
"`doc_large_world_coordinates`. If using large world coordinates is not an "
"option, you may be able to use techniques such as orienting the world around "
"the player (rather than the other way around), or shifting the origin "
"periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"У великих світах також можуть виникати збої рендеринга та фізики через "
"помилку з плаваючою комою. Це можна вирішити за допомогою :ref:"
"`doc_large_world_coordinates`. Якщо використання великих світових координат "
"не є варіантом, ви можете скористатися такими методами, як орієнтування "
"світу навколо гравця (а не навпаки) або періодичне зміщення початку "
"координат, щоб утримувати речі в центрі навколо ``Vector3(0, 0, 0)``."
