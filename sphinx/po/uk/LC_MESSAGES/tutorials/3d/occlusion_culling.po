#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Occlusion culling"
msgstr "Вибракування оклюзії"

msgid ""
"In a 3D rendering engine, **occlusion culling** is the process of performing "
"hidden geometry removal."
msgstr ""
"У системі 3D-рендерінгу **відсічення оклюзії** — це процес видалення "
"прихованої геометрії."

msgid "On this page, you'll learn:"
msgstr "На цій сторінці ви дізнаєтеся:"

msgid "What are the advantages and pitfalls of occlusion culling."
msgstr "Які переваги та підводні камені вибракування оклюзії."

msgid "How to set up occlusion culling in Godot."
msgstr "Як налаштувати відбір оклюзії в Godot."

msgid "Troubleshooting common issues with occlusion culling."
msgstr "Усунення поширених проблем з оклюзійним відбором."

msgid ""
"You can see how occlusion culling works in action using the `Occlusion "
"Culling and Mesh LOD demo project <https://github.com/godotengine/godot-demo-"
"projects/tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"Ви можете побачити, як працює відбір оклюзії в дії, використовуючи "
"демонстраційний проект LOD Occlusion Culling and Mesh <https://github.com/"
"godotengine/godot-demo-projects/tree/master/3d/"
"occlusion_culling_mesh_lod>`__."

msgid "Why use occlusion culling"
msgstr "Навіщо використовувати оклюзію"

msgid ""
"In this example scene with hundreds of rooms stacked next to each other, a "
"dynamic object (red sphere) is hidden behind the wall in the lit room (on "
"the left of the door):"
msgstr ""
"У цьому прикладі сцени з сотнями кімнат, розташованих одна біля одної, "
"динамічний об’єкт (червона сфера) приховано за стіною в освітленій кімнаті "
"(ліворуч від дверей):"

msgid "Example scene with an occlusion culling-friendly layout"
msgstr "Приклад сцени з макетом, зручним для вибракування оклюзії"

msgid ""
"With occlusion culling disabled, all the rooms behind the lit room have to "
"be rendered. The dynamic object also has to be rendered:"
msgstr ""
"Якщо вибракування оклюзії вимкнено, усі кімнати за освітленою кімнатою мають "
"бути візуалізовані. Динамічний об’єкт також потрібно відобразити:"

msgid "Example scene with occlusion culling disabled (wireframe)"
msgstr "Приклад сцени з вимкненим блокуванням оклюзії (каркас)"

msgid "Example scene with occlusion culling **disabled** (wireframe)"
msgstr "Приклад сцени з вибракуванням оклюзії **вимкнено** (каркас)"

msgid ""
"With occlusion culling enabled, only the rooms that are actually visible "
"have to be rendered. The dynamic object is also occluded by the wall, and "
"therefore no longer has to be rendered:"
msgstr ""
"Якщо ввімкнуто відсікання оклюзії, потрібно відобразити лише ті кімнати, які "
"фактично видимі. Динамічний об’єкт також закритий стіною, і тому його більше "
"не потрібно візуалізувати:"

msgid "Example scene with occlusion culling enabled (wireframe)"
msgstr "Приклад сцени з увімкненим блокуванням оклюзії (каркас)"

msgid "Example scene with occlusion culling **enabled** (wireframe)"
msgstr "Приклад сцени з **увімкненим** блокуванням оклюзії (каркас)"

msgid ""
"Since the engine has less work to do (fewer vertices to render and fewer "
"draw calls), performance will increase as long as there are enough occlusion "
"culling opportunities in the scene. This means occlusion culling is most "
"effective in indoor scenes, preferably with many smaller rooms instead of "
"fewer larger rooms. Combine this with :ref:`doc_mesh_lod` "
"and :ref:`doc_visibility_ranges` to further improve performance gains."
msgstr ""
"Оскільки рушій має менше роботи (менше вершин для візуалізації та менше "
"викликів малювання), продуктивність зростатиме, доки в сцені є достатньо "
"можливостей відсічення оклюзії. Це означає, що видалення оклюзії є "
"найефективнішим у сценах у приміщенні, бажано з великою кількістю менших "
"кімнат замість меншої кількості великих кімнат. Поєднайте це "
"з :ref:`doc_mesh_lod` і :ref:`doc_visibility_ranges`, щоб ще більше "
"покращити продуктивність."

msgid ""
"When using the Forward+ renderer, the engine already performs a *depth "
"prepass*. This consists in rendering a depth-only version of the scene "
"before rendering the scene's actual materials. This is used to ensure each "
"opaque pixel is only shaded once, reducing the cost of overdraw "
"significantly."
msgstr ""
"Під час використання засобу візуалізації Forward+ механізм уже виконує "
"*попереднє проходження глибини*. Це полягає у відтворенні лише глибинної "
"версії сцени перед відтворенням фактичних матеріалів сцени. Це "
"використовується для того, щоб кожен непрозорий піксель був затінений лише "
"один раз, що значно зменшує вартість перерисовки."

msgid ""
"The greatest performance benefits can be observed when using the Mobile "
"renderer, as it does not feature a depth prepass for performance reasons. As "
"a result, occlusion culling will actively decrease shading overdraw with "
"that renderer."
msgstr ""
"Найбільші переваги в продуктивності можна спостерігати при використанні "
"мобільного рендерера, оскільки він не має попереднього проходу глибини з "
"міркувань продуктивності. Як наслідок, видалення оклюзії активно "
"зменшуватиме надмірне затінення за допомогою цього рендерера."

msgid ""
"Nonetheless, even when using a depth prepass, there is still a noticeable "
"benefit to occlusion culling in complex 3D scenes. However, in scenes with "
"few occlusion culling opportunities, occlusion culling may not be worth the "
"added setup and CPU usage."
msgstr ""
"Тим не менш, навіть при використанні попереднього проходу глибини, є помітна "
"перевага відсікання оклюзії в складних 3D-сценах. Однак у сценах з невеликою "
"кількістю можливостей відсічення оклюзії відсічення оклюзії може не "
"вартувати додаткових налаштувань і використання ЦП."

msgid "How occlusion culling works in Godot"
msgstr "Як працює вибракування оклюзії в Godot"

msgid ""
"\"occluder\" refers to the shape blocking the view, while \"occludee\" "
"refers to the object being hidden."
msgstr ""
"\"окклюдер\" відноситься до форми, яка блокує огляд, тоді як \"окклюдер\" "
"стосується прихованого об'єкта."

msgid ""
"In Godot, occlusion culling works by rasterizing the scene's occluder "
"geometry to a low-resolution buffer on the CPU. This is done using the "
"software raytracing library `Embree <https://github.com/embree/embree>`__."
msgstr ""
"У Godot відбір оклюзії працює шляхом растеризації геометрії оклюдера сцени "
"до буфера низької роздільної здатності на ЦП. Це робиться за допомогою "
"програмної бібліотеки трасування променів `Embree <https://github.com/embree/"
"embree>`__."

msgid ""
"The engine then uses this low-resolution buffer to test the "
"occludee's :abbr:`AABB (Axis-Aligned Bounding Box)` against the occluder "
"shapes. The occludee's :abbr:`AABB (Axis-Aligned Bounding Box)` must be "
"*fully occluded* by the occluder shape to be culled."
msgstr ""
"Далі механізм використовує цей буфер із низькою роздільною здатністю, щоб "
"перевірити :abbr:`AABB (Axis-Aligned Bounding Box)` оклюдера щодо форм "
"оклюдера. :abbr:`AABB (Axis-Aligned Bounding Box)` оклюдії має бути "
"*повністю закрита* формою оклюдера, яку потрібно вилучити."

msgid ""
"As a result, smaller objects are more likely to be effectively culled than "
"larger objects. Larger occluders (such as walls) also tend to be much more "
"effective than smaller ones (such as decoration props)."
msgstr ""
"Як наслідок, менші об’єкти з більшою ймовірністю будуть ефективно "
"відбраковані, ніж більші об’єкти. Більші оклюдери (наприклад, стіни) також, "
"як правило, набагато ефективніші, ніж менші (наприклад, декоративні опори)."

msgid "Setting up occlusion culling"
msgstr "Налаштування вибракування оклюзії"

msgid ""
"The first step to using occlusion culling is to enable the **Rendering > "
"**Occlusion Culling > Use Occlusion Culling** project setting. (Make sure "
"the **Advanced** toggle is enabled in the Project Settings dialog to be able "
"to see it.)"
msgstr ""
"Першим кроком до використання відсіку оклюзії є ввімкнення параметра проекту "
"**Відтворення > **Відсікання перегородок > Використовувати відсіювання "
"перекриття**. (Переконайтеся, що перемикач **Додатково** увімкнено в "
"діалоговому вікні налаштувань проекту, щоб мати змогу його побачити.)"

msgid ""
"This project setting applies immediately, so you don't need to restart the "
"editor."
msgstr ""
"Цей параметр проекту застосовується негайно, тому вам не потрібно "
"перезапускати редактор."

msgid ""
"After enabling the project setting, you still need to create some occluders. "
"For performance reasons, the engine doesn't automatically use all visible "
"geometry as a basis for occlusion culling. Instead, the engine requires a "
"simplified representation of the scene with only static objects to be baked."
msgstr ""
"Після ввімкнення налаштувань проекту вам все одно потрібно створити кілька "
"оклюдерів. З міркувань продуктивності механізм автоматично не використовує "
"всю видиму геометрію як основу для вилучення оклюзії. Натомість двигун "
"вимагає спрощеного представлення сцени лише зі статичними об’єктами, які "
"потрібно запікати."

msgid "There are two ways to set up occluders in a scene:"
msgstr "Існує два способи налаштування оклюдерів у сцені:"

msgid "Automatically baking occluders (recommended)"
msgstr "Автоматичне запікання оклюдерів (рекомендовано)"

msgid ""
"Only MeshInstance3D nodes are currently taken into account in the *occluder* "
"baking process. MultiMeshInstance3D, GPUParticles3D, CPUParticles3D and CSG "
"nodes are **not** taken into account when baking occluders. If you wish "
"those to be treated as occluders, you have to manually create occluder "
"shapes that (roughly) match their geometry."
msgstr ""
"Лише вузли MeshInstance3D наразі враховуються в процесі запікання "
"*occluder*. Вузли MultiMeshInstance3D, GPUParticles3D, CPUParticles3D і CSG "
"**не** враховуються під час запікання оклюдерів. Якщо ви бажаєте, щоб їх "
"розглядали як оклюдери, вам потрібно вручну створити форми оклюдерів, які "
"(приблизно) відповідають їхній геометрії."

msgid ""
"Since Godot 4.4, CSG nodes can be taken into account in the baking process "
"if they are :ref:`converted to a MeshInstance3D "
"<doc_csg_tools_converting_to_mesh_instance_3d>` before baking occluders."
msgstr ""
"Починаючи з Godot 4.4, вузли CSG можна брати до уваги в процесі запікання, "
"якщо їх :ref:`converted to a MeshInstance3D "
"<doc_csg_tools_converting_to_mesh_instance_3d>` перед запіканням оклюдерів."

msgid ""
"This restriction does not apply to *occludees*. Any node type that inherits "
"from GeometryInstance3D can be occluded."
msgstr ""
"Це обмеження не поширюється на *occludees*. Будь-який тип вузла, який "
"успадковується від GeometryInstance3D, може бути закритий."

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level."
msgstr ""
"Увімкнувши згадане вище налаштування проекту відбору оклюзії, додайте вузол "
"OccluderInstance3D до сцени, що містить ваш 3D-рівень."

msgid ""
"Select the OccluderInstance3D node, then click **Bake Occluders** at the top "
"of the 3D editor viewport. After baking, the OccluderInstance3D node will "
"contain an Occluder3D resource that stores a simplified version of your "
"level's geometry. This occluder geometry appears as purple wireframe lines "
"in the 3D view (as long as **View Gizmos** is enabled in the **Perspective** "
"menu). This geometry is then used to provide occlusion culling for both "
"static and dynamic occludees."
msgstr ""
"Виберіть вузол OccluderInstance3D, а потім натисніть **Bake Occluders** у "
"верхній частині вікна перегляду 3D-редактора. Після запікання вузол "
"OccluderInstance3D міститиме ресурс Occluder3D, який зберігає спрощену "
"версію геометрії вашого рівня. Ця геометрія оклюдера відображається як "
"фіолетові каркасні лінії в 3D-перегляді (поки **Перегляд штучок** увімкнено "
"в меню **Перспектива**). Потім ця геометрія використовується для "
"забезпечення відсікання оклюзії як для статичних, так і для динамічних "
"оклюзій."

msgid ""
"After baking, you may notice that your dynamic objects (such as the player, "
"enemies, etc…) are included in the baked mesh. To prevent this, set the "
"**Bake > Cull Mask** property on the OccluderInstance3D to exclude certain "
"visual layers from being baked."
msgstr ""
"Після запікання ви можете помітити, що ваші динамічні об’єкти (такі як "
"гравець, вороги тощо) включені в запечену сітку. Щоб запобігти цьому, "
"установіть властивість **Bake > Cull Mask** на OccluderInstance3D, щоб "
"виключити певні візуальні шари від запікання."

msgid ""
"For example, you can disable layer 2 on the cull mask, then configure your "
"dynamic objects' MeshInstance3D nodes to be located on the visual layer 2 "
"(instead of layer 1). To do so, select the MeshInstance3D node in question, "
"then on the **VisualInstance3D > Layers** property, uncheck layer 1 then "
"check layer 2. After configuring both cull mask and layers, bake occluders "
"again by following the above process."
msgstr ""
"Наприклад, ви можете вимкнути шар 2 на масці відбракування, а потім "
"налаштувати вузли MeshInstance3D своїх динамічних об’єктів на розміщення на "
"візуальному рівні 2 (замість шару 1). Для цього виберіть відповідний вузол "
"MeshInstance3D, а потім у властивості **VisualInstance3D > Layers** зніміть "
"прапорець із шару 1, а потім установіть прапорець із шару 2. Після "
"налаштування маски відбракування та шарів знову запікайте оклюдери, "
"дотримуючись описаного вище процесу."

msgid "Manually placing occluders"
msgstr "Встановлення оклюдерів вручну"

msgid ""
"This approach is more suited for specialized use cases, such as creating "
"occlusion for MultiMeshInstance3D setups or CSG nodes (due to the "
"aforementioned limitation)."
msgstr ""
"Цей підхід більше підходить для спеціальних випадків використання, таких як "
"створення оклюзії для налаштувань MultiMeshInstance3D або вузлів CSG (через "
"згадане вище обмеження)."

msgid ""
"After enabling the occlusion culling project setting mentioned above, add an "
"OccluderInstance3D node to the scene containing your 3D level. Select the "
"OccluderInstance3D node, then choose an occluder type to add in the "
"**Occluder** property:"
msgstr ""
"Увімкнувши згадане вище налаштування проекту відбору оклюзії, додайте вузол "
"OccluderInstance3D до сцени, що містить ваш 3D-рівень. Виберіть вузол "
"OccluderInstance3D, а потім виберіть тип блокувальника, який потрібно додати "
"у властивості **Occluder**:"

msgid "QuadOccluder3D (a single plane)"
msgstr "QuadOccluder3D (одна площина)"

msgid "BoxOccluder3D (a cuboid)"
msgstr "BoxOccluder3D (кубоподібний)"

msgid "SphereOccluder3D (a sphere-shaped occluder)"
msgstr "SphereOccluder3D (оклюдер у формі сфери)"

msgid "PolygonOccluder3D (a 2D polygon with as many points as you want)"
msgstr "PolygonOccluder3D (2D-багатокутник із скільки завгодно точок)"

msgid ""
"There is also ArrayOccluder3D, whose points can't be modified in the editor "
"but can be useful for procedural generation from a script."
msgstr ""
"Існує також ArrayOccluder3D, точки якого не можна змінити в редакторі, але "
"можуть бути корисними для процедурної генерації зі сценарію."

msgid "Previewing occlusion culling"
msgstr "Попередній перегляд оклюзії"

msgid ""
"You can enable a debug draw mode to preview what the occlusion culling is "
"actually \"seeing\". In the top-left corner of the 3D editor viewport, click "
"the **Perspective** button (or **Orthogonal** depending on your current "
"camera mode), then choose **Display Advanced… > Occlusion Culling Buffer**. "
"This will display the low-resolution buffer that is used by the engine for "
"occlusion culling."
msgstr ""
"Ви можете ввімкнути режим малювання налагодження, щоб переглянути, що "
"насправді «бачить» оклюзія. У верхньому лівому куті вікна перегляду 3D-"
"редактора клацніть кнопку **Перспектива** (або **Ортогональна** залежно від "
"поточного режиму камери), а потім виберіть **Відображення розширеного… > "
"Буфер відсікання загородження**. Це відобразить буфер із низькою роздільною "
"здатністю, який використовується механізмом для відсічення оклюзії."

msgid ""
"In the same menu, you can also enable **View Information** and **View Frame "
"Time** to view the number of draw calls and rendered primitives (vertices + "
"indices) in the bottom-right corner, along with the number of frames per "
"second rendered in the top-right corner."
msgstr ""
"У цьому ж меню ви також можете ввімкнути **Переглянути інформацію** та "
"**Переглянути час кадру**, щоб переглянути кількість викликів малювання та "
"відтворених примітивів (вершини + індекси) у нижньому правому куті, а також "
"кількість кадрів за секунду, які відображаються у верхньому правому куті."

msgid ""
"If you toggle occlusion culling in the project settings while this "
"information is displayed, you can see how much occlusion culling improves "
"performance in your scene. Note that the performance benefit highly depends "
"on the 3D editor camera's view angle, as occlusion culling is only effective "
"if there are occluders in front of the camera."
msgstr ""
"Якщо ви увімкнете відсічення оклюзії в налаштуваннях проекту, поки ця "
"інформація відображається, ви зможете побачити, наскільки відсічення оклюзії "
"покращує продуктивність вашої сцени. Зауважте, що перевага продуктивності "
"значною мірою залежить від кута огляду камери 3D-редактора, оскільки оклюзія "
"ефективна, лише якщо перед камерою є оклюдери."

msgid ""
"To toggle occlusion culling at runtime, set ``use_occlusion_culling`` on the "
"root viewport as follows:"
msgstr ""
"Щоб увімкнути відсічення оклюзії під час виконання, встановіть "
"``use_occlusion_culling`` на кореневому вікні перегляду таким чином:"

msgid ""
"Toggling occlusion culling at runtime is useful to compare performance on a "
"running project."
msgstr ""
"Перемикання відсіку оклюзії під час виконання корисно для порівняння "
"продуктивності запущеного проекту."

msgid "Performance considerations"
msgstr "Міркування продуктивності"

msgid "Design your levels to take advantage of occlusion culling"
msgstr "Створюйте рівні, щоб скористатися перевагами оклюзійного відбору"

msgid ""
"**This is the most important guideline.** A good level design is not just "
"about what the gameplay demands; it should also be built with occlusion in "
"mind."
msgstr ""
"**Це найважливіша вказівка.** Хороший дизайн рівнів — це не лише вимоги "
"ігрового процесу; його також слід будувати з урахуванням оклюзії."

msgid ""
"For indoor environments, add opaque walls to \"break\" the line of sight at "
"regular intervals and ensure not too much of the scene can be seen at once."
msgstr ""
"Для внутрішнього середовища додайте непрозорі стіни, щоб «розірвати» лінію "
"огляду через рівні проміжки часу та переконатися, що не надто багато сцени "
"можна побачити одночасно."

msgid ""
"For large open scenes, use a pyramid-like structure for the terrain's "
"elevation when possible. This provides the greatest culling opportunities "
"compared to any other terrain shape."
msgstr ""
"Для великих відкритих сцен використовуйте пірамідоподібну структуру для "
"висоти рельєфу, коли це можливо. Це забезпечує найбільші можливості для "
"вибракування порівняно з будь-якою іншою формою місцевості."

msgid "Avoid moving OccluderInstance3D nodes during gameplay"
msgstr "Уникайте переміщення вузлів OccluderInstance3D під час гри"

msgid ""
"This includes moving the parents of OccluderInstance3D nodes, as this will "
"cause the nodes themselves to move in global space, therefore requiring "
"the :abbr:`BVH (Bounding Volume Hierarchy)` to be rebuilt."
msgstr ""
"Це включає переміщення батьківських вузлів OccluderInstance3D, оскільки це "
"спричинить переміщення самих вузлів у глобальному просторі, отже, вимагаючи "
"перебудови :abbr:`BVH (Bounding Volume Hierarchy)`."

msgid ""
"Toggling an OccluderInstance3D's visibility (or one of its parents' "
"visibility) is not as expensive, as the update only needs to happen once "
"(rather than continuously)."
msgstr ""
"Перемикання видимості OccluderInstance3D (або видимості одного з батьків) не "
"таке дороге, оскільки оновлення має відбуватися лише один раз (а не "
"постійно)."

msgid ""
"For example, if you have a sliding or rotating door, you can make the "
"OccluderInstance3D node not be a child of the door itself (so that the "
"occluder never moves), but you can hide the OccluderInstance3D visibility "
"once the door starts opening. You can then reshow the OccluderInstance3D "
"once the door is fully closed."
msgstr ""
"Наприклад, якщо у вас є розсувні або обертові двері, ви можете зробити так, "
"щоб вузол OccluderInstance3D не був дочірнім елементом самих дверей (щоб "
"загороджувач ніколи не рухався), але ви можете приховати видимість "
"OccluderInstance3D, коли двері почнуть відкриватися. Потім ви можете "
"повторно показати OccluderInstance3D, коли дверцята повністю зачиняться."

msgid ""
"If you absolutely have to move an OccluderInstance3D node during gameplay, "
"use a primitive Occluder3D shape for it instead of a complex baked shape."
msgstr ""
"Якщо вам обов’язково потрібно перемістити вузол OccluderInstance3D під час "
"гри, використовуйте для нього примітивну форму Occluder3D замість складної "
"запеченої форми."

msgid "Use the simplest possible occluder shapes"
msgstr "Використовуйте найпростіші можливі форми оклюдерів"

msgid ""
"If you notice low performance or stuttering in complex 3D scenes, it may "
"mean that the CPU is overloaded as a result of rendering detailed occluders. "
"Select the OccluderInstance3D node, increase the **Bake > Simplification** "
"property then bake occluders again."
msgstr ""
"Якщо ви помітили низьку продуктивність або заїкання в складних 3D-сценах, це "
"може означати, що ЦП перевантажено в результаті візуалізації детальних "
"окклюдерів. Виберіть вузол OccluderInstance3D, збільште властивість **Bake > "
"Simplification**, а потім знову запікайте оклюдери."

msgid ""
"Remember to keep the simplification value reasonable. Values that are too "
"high for the level's geometry may cause incorrect occlusion culling to "
"occur, as in :ref:`doc_occlusion_culling_troubleshooting_false_negative`."
msgstr ""
"Пам’ятайте, що значення спрощення має бути розумним. Значення, які є занадто "
"високими для геометрії рівня, можуть спричинити неправильне відсічення "
"оклюзії, як у :ref:`doc_occlusion_culling_troubleshooting_false_negative`."

msgid ""
"If this still doesn't lead to low enough CPU usage, you can try adjusting "
"the **Rendering > Occlusion Culling > BVH Build Quality** project setting "
"and/or decreasing **Rendering > Occlusion Culling > Occlusion Rays Per "
"Thread**. You'll need to enable the **Advanced** toggle in the Project "
"Settings dialog to see those settings."
msgstr ""
"Якщо це все ще не призводить до достатньо низького використання ЦП, ви "
"можете спробувати відкоригувати параметр проекту **Відображення > Відсічення "
"перекриття > Якість збірки BVH** і/або зменшити значення **Візуалізація > "
"Відсікання перекриття > Промені перекриття на потік**. Вам потрібно буде "
"ввімкнути перемикач **Додатково** у діалоговому вікні налаштувань проекту, "
"щоб побачити ці налаштування."

msgid "Troubleshooting"
msgstr "Вирішення проблем"

msgid "My occludee isn't being culled when it should be"
msgstr "Мій оклюд не вибраковується, коли це повинно бути"

msgid "**On the occluder side:**"
msgstr "**З боку оклюдера:**"

msgid ""
"First, double-check that the **Bake > Cull Mask** property in the "
"OccluderInstance3D is set to allow baking the meshes you'd like. The "
"visibility layer of the MeshInstance3D nodes must be present within the cull "
"mask for the mesh to be included in the bake."
msgstr ""
"По-перше, ще раз переконайтеся, що властивість **Bake > Cull Mask** в "
"OccluderInstance3D налаштовано на дозвіл запікання сіток, які ви хочете. "
"Рівень видимості вузлів MeshInstance3D має бути присутнім у масці "
"відбракування, щоб сітка була включена до запікання."

msgid ""
"Also note that occluder baking only takes meshes with *opaque* materials "
"into account. Surfaces will *transparent* materials will **not** be included "
"in the bake, even if the texture applied on them is fully opaque."
msgstr ""
"Також зауважте, що запікання оклюдера враховує лише сітки з *непрозорими* "
"матеріалами. Поверхні будуть *прозорі* матеріали **не** будуть включені в "
"обпічку, навіть якщо нанесена на них текстура повністю непрозора."

msgid ""
"Lastly, remember that MultiMeshInstance3D, GPUParticles3D, CPUParticles3D "
"and CSG nodes are **not** taken into account when baking occluders. As a "
"workaround, you can add OccluderInstance3D nodes for those manually."
msgstr ""
"Нарешті, пам’ятайте, що вузли MultiMeshInstance3D, GPUParticles3D, "
"CPUParticles3D і CSG **не** враховуються під час запікання оклюдерів. Як "
"обхідний шлях ви можете додати для них вузли OccluderInstance3D вручну."

msgid "**On the occludee side:**"
msgstr "**З боку оклюдії:**"

msgid ""
"Make sure **Extra Cull Margin** is set as low as possible (it should usually "
"be ``0.0``), and that **Ignore Occlusion Culling** is disabled in the "
"object's GeometryInstance3D section."
msgstr ""
"Переконайтеся, що **Extra Cull Margin** установлено якомога менше (зазвичай "
"воно має бути ``0.0``), а **Ignore Occlusion Culling** вимкнено в розділі "
"GeometryInstance3D об’єкта."

msgid ""
"Also, check the AABB's size (which is represented by an orange box when "
"selecting the node). This axis-aligned bounding box must be *fully* occluded "
"by the occluder shapes for the occludee to be hidden."
msgstr ""
"Також перевірте розмір AABB (який позначається помаранчевою рамкою під час "
"вибору вузла). Ця обмежувальна рамка, вирівняна за віссю, має бути "
"*повністю* перекрита формами оклюдера, щоб оклюдію було приховано."

msgid "My occludee is being culled when it shouldn't be"
msgstr "Мій окклюд вибраковується, коли цього не повинно бути"

msgid ""
"The most likely cause for this is that objects that were included in the "
"occluder bake have been moved after baking occluders. For instance, this can "
"occur when moving your level geometry around or rearranging its layout. To "
"fix this, select the OccluderInstance3D node and bake occluders again."
msgstr ""
"Найімовірнішою причиною цього є те, що об’єкти, які були включені до "
"запікання оклюдера, були переміщені після запікання оклюдерів. Наприклад, це "
"може статися під час переміщення геометрії рівня або зміни його макета. Щоб "
"виправити це, виберіть вузол OccluderInstance3D і знову запікайте оклюдери."

msgid ""
"This can also happen because dynamic objects were included in the bake, even "
"though they shouldn't be. Use the :ref:`occlusion culling debug draw mode "
"<doc_occlusion_culling_preview>` to look for occluder shapes that shouldn't "
"be present, then :ref:`adjust the bake cull mask accordingly "
"<doc_occlusion_culling_baking>`."
msgstr ""
"Це також може статися через те, що динамічні об’єкти були включені в пакет, "
"хоча це не повинно бути. Використовуйте :ref:`occlusion culling debug draw "
"mode <doc_occlusion_culling_preview>`, щоб шукати форми окклюдерів, яких не "
"повинно бути, а потім :ref:`adjust the bake cull mask accordingly "
"<doc_occlusion_culling_baking>`."

msgid ""
"The last possible cause for this is overly aggressive mesh simplification "
"during the occluder baking process. Select the OccluderInstance3D node, "
"decrease the **Bake > Simplification** property then bake occluders again."
msgstr ""
"Останньою можливою причиною цього є занадто агресивне спрощення сітки під "
"час запікання оклюдера. Виберіть вузол OccluderInstance3D, зменшіть "
"властивість **Bake > Simplification**, а потім знову запікайте оклюдери."

msgid ""
"As a last resort, you can enable the **Ignore Occlusion Culling** property "
"on the occludee. This will negate the performance improvements of occlusion "
"culling for that object, but it makes sense to do this for objects that will "
"never be culled (such as a first-person view model)."
msgstr ""
"В крайньому випадку, ви можете ввімкнути властивість **Ignore Occlusion "
"Culling** для occludee. Це зведе нанівець покращення продуктивності "
"відсіювання оклюзії для цього об’єкта, але має сенс робити це для об’єктів, "
"які ніколи не будуть відбраковані (наприклад, модель перегляду від першої "
"особи)."
