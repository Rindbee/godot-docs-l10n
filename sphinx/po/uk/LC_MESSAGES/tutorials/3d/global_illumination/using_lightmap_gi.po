#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Lightmap global illumination"
msgstr "Використання глобального освітлення Lightmap"

msgid ""
"Baked lightmaps are a workflow for adding indirect (or fully baked) lighting "
"to a scene. Unlike the :ref:`VoxelGI <doc_using_voxel_gi>` and :ref:`SDFGI "
"<doc_using_sdfgi>` approaches, baked lightmaps work fine on low-end PCs and "
"mobile devices, as they consume almost no resources at runtime. Also unlike "
"VoxelGI and SDFGI, baked lightmaps can optionally be used to store direct "
"lighting, which provides even further performance gains."
msgstr ""
"Запечені карти освітлення — це робочий процес для додавання непрямого (або "
"повністю запеченого) освітлення до сцени. На відміну від "
"підходів :ref:`VoxelGI <doc_using_voxel_gi>` і :ref:`SDFGI "
"<doc_using_sdfgi>`, запечені карти освітлення чудово працюють на недорогих "
"ПК і мобільних пристроях, оскільки вони майже не споживають ресурсів під час "
"виконання. Крім того, на відміну від VoxelGI та SDFGI, запечені карти "
"освітлення можна додатково використовувати для зберігання прямого "
"освітлення, що забезпечує ще більше підвищення продуктивності."

msgid ""
"Unlike VoxelGI and SDFGI, baked lightmaps are completely static. Once baked, "
"they can't be modified at all. They also don't provide the scene with "
"reflections, so using :ref:`doc_reflection_probes` together with it on "
"interiors (or using a Sky on exteriors) is a requirement to get good quality."
msgstr ""
"На відміну від VoxelGI та SDFGI, запечені карти світла повністю статичні. "
"Після випічки їх взагалі не можна змінювати. Вони також не забезпечують "
"відображення сцени, тому використання :ref:`doc_reflection_probes` разом із "
"ним на інтер’єрах (або використання Sky на екстер’єрах) є вимогою для "
"отримання гарної якості."

msgid ""
"As they are baked, they have fewer problems than VoxelGI and SDFGI regarding "
"light bleeding, and indirect light will often look better. The downside is "
"that baking lightmaps takes longer compared to baking VoxelGI. While baking "
"VoxelGI can be done in a matter of seconds, baking lightmaps can take "
"several minutes if not more. This can slow down iteration speed "
"significantly, so it is recommended to bake lightmaps only when you actually "
"need to see changes in lighting. Since Godot 4.0, lightmaps are baked on the "
"GPU, making light baking faster if you have a mid-range or high-end "
"dedicated GPU."
msgstr ""
"Коли вони запікаються, вони мають менше проблем, ніж VoxelGI та SDFGI щодо "
"легкої кровотечі, і непряме світло часто виглядає краще. Недоліком є те, що "
"запікання карт світла займає більше часу порівняно з запіканням VoxelGI. "
"Хоча запікання VoxelGI можна виконати за лічені секунди, запікання карт "
"світла може зайняти кілька хвилин, якщо не більше. Це може значно "
"сповільнити швидкість ітерації, тому рекомендується запікати карти "
"освітлення лише тоді, коли вам дійсно потрібно побачити зміни в освітленні. "
"Починаючи з Godot 4.0, світлові карти запікаються на графічному процесорі, "
"що робить процес освітлення швидшим, якщо у вас є виділений графічний "
"процесор середнього або високого рівня."

msgid ""
"Baking lightmaps will also reserve baked materials' UV2 slot, which means "
"you can no longer use it for other purposes in materials (either in the "
"built-in :ref:`doc_standard_material_3d` or in custom shaders)."
msgstr ""
"Карти освітлення для запікання також зарезервують слот UV2 для запечених "
"матеріалів, що означає, що ви більше не зможете використовувати їх для інших "
"цілей у матеріалах (у вбудованому :ref:`doc_standard_material_3d` або в "
"власних шейдерах)."

msgid ""
"Despite their lack of flexibility, baked lightmaps typically offer both the "
"best quality *and* performance at the same time in (mostly) static scenes. "
"This makes lightmaps still popular in game development, despite lightmaps "
"being the oldest technique for global illumination in video games."
msgstr ""
"Незважаючи на недостатню гнучкість, запечені карти освітлення зазвичай "
"пропонують найкращу якість *і* продуктивність одночасно в (переважно) "
"статичних сценах. Це робить світлові карти все ще популярними в розробці "
"ігор, незважаючи на те, що світлові карти є найстарішою технікою глобального "
"освітлення у відеоіграх."

msgid ""
"Not sure if LightmapGI is suited to your needs? "
"See :ref:`doc_introduction_to_global_illumination_comparison` for a "
"comparison of GI techniques available in Godot 4."
msgstr ""
"Не впевнені, що LightmapGI відповідає вашим потребам? "
"Перегляньте :ref:`doc_introduction_to_global_illumination_comparison` для "
"порівняння методів GI, доступних у Godot 4."

msgid "Visual comparison"
msgstr "Візуальне порівняння"

msgid "LightmapGI disabled."
msgstr "LightmapGI вимкнено."

msgid "LightmapGI enabled (with indirect light baked only)."
msgstr "LightmapGI увімкнуто (тільки з запіканням непрямого світла)."

msgid ""
"LightmapGI enabled (with indirect light baked only). Direct light is still "
"real-time, allowing for subtle changes during gameplay."
msgstr ""
"LightmapGI увімкнуто (тільки з запіканням непрямого світла). Пряме світло "
"все ще працює в режимі реального часу, що дозволяє вносити незначні зміни "
"під час гри."

msgid "LightmapGI enabled (with direct and indirect light baked)."
msgstr "LightmapGI увімкнено (із запіканням прямого та непрямого світла)."

msgid ""
"LightmapGI enabled (with direct and indirect light baked). Best performance, "
"but lower quality visuals. Notice the blurrier sun shadow in the top-right "
"corner."
msgstr ""
"LightmapGI увімкнено (із запіканням прямого та непрямого світла). Найкраща "
"продуктивність, але нижча якість зображення. Зверніть увагу на більш розмиту "
"сонячну тінь у верхньому правому куті."

msgid ""
"Here are some comparisons of how LightmapGI vs. VoxelGI look. Notice that "
"lightmaps are more accurate, but also suffer from the fact that lighting is "
"on an unwrapped texture, so transitions and resolution may not be that good. "
"VoxelGI looks less accurate (as it's an approximation), but smoother overall."
msgstr ""
"Ось кілька порівнянь того, як виглядають LightmapGI та VoxelGI. Зауважте, що "
"карти освітлення точніші, але також страждають від того, що освітлення "
"відбувається на незагорнутій текстурі, тому переходи та роздільна здатність "
"можуть бути не такими хорошими. VoxelGI виглядає менш точним (оскільки це "
"наближення), але в цілому більш плавним."

msgid ""
"SDFGI is also less accurate compared to LightmapGI. However, SDFGI can "
"support large open worlds without any need for baking."
msgstr ""
"SDFGI також менш точний порівняно з LightmapGI. Однак SDFGI може "
"підтримувати великі відкриті світи без необхідності випікання."

msgid "Setting up"
msgstr "Налаштування"

msgid ""
"Baking lightmaps in the Android and web editors is not supported due to "
"graphics API limitations on those devices. On Android and web platforms, "
"only *rendering* lightmaps that were baked on a desktop PC is supported."
msgstr ""
"Запікання світлових карт у Android і веб-редакторах не підтримується через "
"обмеження графічного API на цих пристроях. На платформах Android і веб-"
"платформах підтримується лише *відтворення* світлових карт, створених на "
"настільному ПК."

msgid ""
"The LightmapGI node only bakes nodes that are on the same level as the "
"LightmapGI node (siblings), or nodes that are children of the LightmapGI "
"node. This allows you to use several LightmapGI nodes to bake different "
"parts of the scene, independently from each other."
msgstr ""
"Вузол LightmapGI запікає лише ті вузли, які знаходяться на тому ж рівні, що "
"й вузол LightmapGI (побратими), або вузли, які є дочірніми вузлами вузла "
"LightmapGI. Це дозволяє використовувати кілька вузлів LightmapGI для "
"запікання різних частин сцени незалежно одна від одної."

msgid ""
"First of all, before the lightmapper can do anything, the objects to be "
"baked need a UV2 layer and a texture size. A UV2 layer is a set of secondary "
"texture coordinates that ensures any face in the object has its own place in "
"the UV map. Faces must not share pixels in the texture."
msgstr ""
"Перш за все, перед тим, як Lightmapper зможе щось зробити, об’єктам, які "
"потрібно запікати, потрібен шар UV2 і розмір текстури. Шар UV2 — це набір "
"координат вторинної текстури, який гарантує, що будь-яке обличчя в об’єкті "
"має власне місце на UV-карті. Обличчя не повинні мати спільних пікселів у "
"текстурі."

msgid ""
"There are a few ways to ensure your object has a unique UV2 layer and "
"texture size:"
msgstr ""
"Є кілька способів переконатися, що ваш об'єкт має унікальний шар UV2 і "
"розмір текстури:"

msgid "Unwrap on scene import (recommended)"
msgstr "Розгорнути під час імпорту сцени (рекомендовано)"

msgid ""
"In most scenarios, this is the best approach to use. The only downside is "
"that, on large models, unwrapping can take a while on import. Nonetheless, "
"Godot will cache the UV2 across reimports, so it will only be regenerated "
"when needed."
msgstr ""
"У більшості випадків це найкращий підхід для використання. Єдиним недоліком "
"є те, що на великих моделях розгортання може зайняти деякий час під час "
"імпорту. Незважаючи на це, Godot кешуватиме UV2 під час повторного імпорту, "
"тому його буде відновлено лише за потреби."

msgid ""
"Select the imported scene in the filesystem dock, then go to the **Import** "
"dock. There, the following option can be modified:"
msgstr ""
"Виберіть імпортовану сцену на панелі Файлової системи, а потім перейдіть до "
"панелі **Імпорт**. Там можна змінити наступні опції:"

msgid ""
"The **Meshes > Light Baking** option must be set to **Static Lightmaps "
"(VoxelGI/SDFGI/LightmapGI)**:"
msgstr ""
"Для параметра **Сітки > Випікання світла** має бути встановлено значення "
"**Статичні карти освітлення (VoxelGI/SDFGI/LightmapGI)**:"

msgid ""
"When unwrapping on import, you can adjust the texture size using the "
"**Meshes > Lightmap Texel Size** option. *Lower* values will result in more "
"detailed lightmaps, possibly resulting in higher visual quality at the cost "
"of longer bake times and larger lightmap file sizes. The default value of "
"``0.2`` is suited for small/medium-sized scenes, but you may want to "
"increase it to ``0.5`` or even more for larger scenes. This is especially "
"the case if you're baking indirect lighting only, as indirect light is low-"
"frequency data (which means it doesn't need high-resolution textures to be "
"accurately represented)."
msgstr ""
"Під час розгортання під час імпорту ви можете налаштувати розмір текстури за "
"допомогою параметра **Сітки > Розмір текселів світлової карти**. *Нижчі* "
"значення призведуть до отримання детальніших карт освітлення, що, можливо, "
"призведе до вищої якості зображення за рахунок довшого часу запікання та "
"збільшення розміру файлу карти освітлення. Стандартне значення ``0,2`` "
"підходить для малих/середніх сцен, але ви можете збільшити його до ``0,5`` "
"або навіть більше для більших сцен. Це особливо актуально, якщо ви випікаєте "
"лише непряме освітлення, оскільки непряме світло – це низькочастотні дані "
"(це означає, що для точного представлення текстури з високою роздільною "
"здатністю не потрібні)."

msgid ""
"The effect of setting this option is that all meshes within the scene will "
"have their UV2 maps properly generated."
msgstr ""
"Ефект налаштування цього параметра полягає в тому, що всі меші в межах сцени "
"матимуть свої карти UV2 згенеровані належним чином."

msgid ""
"When reusing a mesh within a scene, keep in mind that UVs will be generated "
"for the first instance found. If the mesh is re-used with different scales "
"(and the scales are wildly different, more than half or twice), this will "
"result in inefficient lightmaps. To avoid this, adjust the **Lightmap "
"Scale** property in the GeometryInstance3D section of a MeshInstance3D node. "
"This lets you *increase* the level of lightmap detail for specific "
"MeshInstance3D nodes (but not decrease it)."
msgstr ""
"Під час повторного використання сітки в сцені майте на увазі, що UV буде "
"згенеровано для першого знайденого екземпляра. Якщо сітку повторно "
"використовувати з різними масштабами (а масштаби сильно відрізняються, більш "
"ніж наполовину або вдвічі), це призведе до неефективних карт освітлення. Щоб "
"уникнути цього, налаштуйте властивість **Lightmap Scale** у розділі "
"GeometryInstance3D вузла MeshInstance3D. Це дозволяє *підвищити* рівень "
"деталізації карти освітлення для конкретних вузлів MeshInstance3D (але не "
"зменшити його)."

msgid ""
"Also, the ``*.unwrap_cache`` files should *not* be ignored in version "
"control as these files guarantee that UV2 reimports are consistent across "
"platforms and engine versions."
msgstr ""
"Крім того, файли ``*.unwrap_cache`` *не* слід ігнорувати в елементі "
"керування версіями, оскільки ці файли гарантують, що повторні імпортування "
"UV2 узгоджені на різних платформах і версіях рушія."

msgid "Unwrap from within Godot"
msgstr "Розгортка всередині Godot"

msgid ""
"If this Mesh menu operation is used on an imported 3D scene, the generated "
"UV2 will be lost when the scene is reloaded."
msgstr ""
"Якщо ця операція меню Mesh використовується для імпортованої 3D-сцени, "
"згенерований UV2 буде втрачено під час перезавантаження сцени."

msgid ""
"Godot has an option to unwrap meshes and visualize the UV channels. After "
"selecting a MeshInstance3D node, it can be found in the **Mesh** menu at the "
"top of the 3D editor viewport:"
msgstr ""
"Godot має опцію розгортання сіток і візуалізації УФ-каналів. Після вибору "
"вузла MeshInstance3D його можна знайти в меню **Mesh** у верхній частині "
"вікна перегляду 3D-редактора:"

msgid ""
"This will generate a second set of UV2 coordinates which can be used for "
"baking. It will also set the texture size automatically."
msgstr ""
"Це створить другий набір координат UV2, який можна використовувати для "
"випічки. Він також автоматично встановить розмір текстури."

msgid "Unwrap from your 3D modeling software"
msgstr "Розгорніть програмне забезпечення для 3D-моделювання"

msgid ""
"The last option is to do it from your favorite 3D app. This approach is "
"generally **not recommended**, but it's explained so that you know it "
"exists. The main advantage is that, on complex objects that you may want to "
"re-import a lot, the texture generation process can be quite costly within "
"Godot, so having it unwrapped before import can be faster."
msgstr ""
"Останній варіант – зробити це з вашої улюбленої програми 3D. Цей підхід "
"зазвичай **не рекомендується**, але він пояснюється, щоб ви знали, що він "
"існує. Основна перевага полягає в тому, що на складних об’єктах, які вам "
"часто захочеться повторно імпортувати, процес створення текстури може бути "
"досить дорогим у Godot, тому розгортання її перед імпортом може бути швидшим."

msgid "Simply do an unwrap on the second UV2 layer."
msgstr "Просто розгорніть розгортку на другому шарі UV2."

msgid ""
"Then import the 3D scene normally. Remember you will need to set the texture "
"size on the mesh after import."
msgstr ""
"Потім імпортуйте 3D-сцену в звичайному режимі. Пам'ятайте, що вам потрібно "
"буде встановити розмір текстури на меші після імпорту."

msgid ""
"If you use external meshes on import, the size will be kept. Be wary that "
"most unwrappers in 3D modeling software are not quality-oriented, as they "
"are meant to work quickly. You will mostly need to use seams or other "
"techniques to create better unwrapping."
msgstr ""
"Якщо ви використовуєте зовнішні сітки під час імпорту, розмір буде "
"збережено. Майте на увазі, що більшість розгортачів програмного забезпечення "
"для 3D-моделювання не орієнтовані на якість, оскільки вони призначені для "
"швидкої роботи. Здебільшого вам знадобиться використовувати шви або інші "
"техніки, щоб краще розгортати."

msgid "Generating UV2 for primitive meshes"
msgstr "Генерація UV2 для примітивних сіток"

msgid ""
"This option is only available for primitive meshes such "
"as :ref:`class_BoxMesh`, :ref:`class_CylinderMesh`, :ref:`class_PlaneMesh`, "
"etc."
msgstr ""
"Цей параметр доступний лише для примітивних сіток, таких "
"як :ref:`class_BoxMesh`, :ref:`class_CylinderMesh`, :ref:`class_PlaneMesh` "
"тощо."

msgid ""
"Enabling UV2 on primitive meshes allows you to make them receive and "
"contribute to baked lighting. This can be used in certain lighting setups. "
"For instance, you could hide a torus that has an emissive material after "
"baking lightmaps to create an area light that follows the shape of a torus."
msgstr ""
"Увімкнення UV2 на примітивних сітках дозволяє змусити їх отримувати "
"освітлення та сприяти йому. Це можна використовувати в певних налаштуваннях "
"освітлення. Наприклад, ви можете приховати тор, який має випромінювальний "
"матеріал, після запікання карт світла, щоб створити область освітлення, яка "
"повторює форму тора."

msgid ""
"By default, primitive meshes do not have UV2 generated to save resources (as "
"these meshes may be created during gameplay). You can edit a primitive mesh "
"in the inspector and enable **Add UV2** to make the engine procedurally "
"generate UV2 for a primitive mesh. The default **UV2 Padding** value is "
"tuned to avoid most lightmap bleeding, without wasting too much space on the "
"edges. If you notice lightmap bleeding on a specific primitive mesh only, "
"you may have to increase **UV2 Padding**."
msgstr ""
"За замовчуванням у примітивних сітках UV2 не генерується для економії "
"ресурсів (оскільки ці сіті можуть створюватися під час гри). Ви можете "
"редагувати примітивну сітку в інспекторі та ввімкнути **Додати UV2**, щоб "
"система процедурно генерувала UV2 для примітивної сітки. Значення за "
"замовчуванням **UV2 Padding** налаштовано так, щоб уникнути більшості "
"розливів карт освітлення, не витрачаючи надто багато місця на краях. Якщо ви "
"помітили розмивання карти світла лише на певній примітивній сітці, можливо, "
"вам доведеться збільшити **UV2 Padding**."

msgid ""
"**Lightmap Size Hint** represents the size taken by a single mesh on the "
"lightmap texture, which varies depending on the mesh's size properties and "
"the **UV2 Padding** value. **Lightmap Size Hint** should not be manually "
"changed, as any modifications will be lost when the scene is reloaded."
msgstr ""
"**Підказка щодо розміру карти освітлення** представляє розмір однієї сітки "
"на текстурі карти освітлення, який змінюється залежно від властивостей "
"розміру сітки та значення **UV2 Padding**. **Підказку щодо розміру карти "
"освітлення** не слід змінювати вручну, оскільки будь-які зміни буде втрачено "
"під час перезавантаження сцени."

msgid "Generating UV2 for CSG nodes"
msgstr "Генерація UV2 для вузлів CSG"

msgid ""
"Since Godot 4.4, you can :ref:`convert a CSG node and its children to a "
"MeshInstance3D <doc_csg_tools_converting_to_mesh_instance_3d>`. This can be "
"used to bake lightmaps on a CSG node by following these steps:"
msgstr ""
"Починаючи з Godot 4.4, ви можете :ref:`convert a CSG node and its children "
"to a MeshInstance3D <doc_csg_tools_converting_to_mesh_instance_3d>`. Це "
"можна використовувати для запікання карт освітлення на вузлі CSG, виконавши "
"такі дії:"

msgid ""
"Select the root CSG node and choose **CSG > Bake Mesh Instance** at the top "
"of the 3D editor viewport."
msgstr ""
"Виберіть кореневий вузол CSG і виберіть **CSG > Запікати екземпляр сітки** у "
"верхній частині вікна перегляду 3D-редактора."

msgid ""
"Hide the root CSG node that was just baked (it is not hidden automatically)."
msgstr ""
"Приховати щойно запечений кореневий вузол CSG (він не прихований "
"автоматично)."

msgid ""
"Select the newly created MeshInstance3D node and choose **Mesh > Unwrap UV2 "
"for Lightmap/AO**."
msgstr ""
"Виберіть щойно створений вузол MeshInstance3D і виберіть **Mesh > Unwrap UV2 "
"for Lightmap/AO**."

msgid "Bake lightmaps."
msgstr "Запекти карти світла."

msgid ""
"Remember to keep the original CSG node in the scene tree, so that you can "
"perform changes to the geometry later if needed. To make changes to the "
"geometry, remove the MeshInstance3D node and make the root CSG node visible "
"again."
msgstr ""
"Не забувайте зберігати вихідний вузол CSG у дереві сцени, щоб у разі потреби "
"пізніше можна було внести зміни до геометрії. Щоб внести зміни в геометрію, "
"видаліть вузол MeshInstance3D і знову зробіть кореневий вузол CSG видимим."

msgid "Checking UV2"
msgstr "Перевірка UV2"

msgid ""
"In the **Mesh** menu mentioned before, the UV2 texture coordinates can be "
"visualized. If something is failing, double-check that the meshes have these "
"UV2 coordinates:"
msgstr ""
"У згаданому вище меню **Mesh** можна візуалізувати координати текстури UV2. "
"Якщо щось не вдається, ще раз перевірте, чи сітки мають такі координати UV2:"

msgid "Setting up the scene"
msgstr "Налаштування сцени"

msgid ""
"Before anything is done, a **LightmapGI** node needs to be added to a scene. "
"This will enable light baking on all nodes (and sub-nodes) in that scene, "
"even on instanced scenes."
msgstr ""
"Перш ніж щось робити, до сцени потрібно додати вузол **LightmapGI**. Це "
"увімкне легке випікання на всіх вузлах (і підвузлах) у цій сцені, навіть на "
"сценах, створених екземплярами."

msgid ""
"A sub-scene can be instanced several times, as this is supported by the "
"baker. Each instance will be assigned a lightmap of its own. To avoid issues "
"with inconsistent lightmap texel scaling, make sure to respect the rule "
"about mesh scaling mentioned before."
msgstr ""
"Підсцена може бути створена декілька разів, оскільки це підтримується "
"бейкером. Кожному екземпляру буде призначено власну світлову карту. Щоб "
"уникнути проблем з непослідовним масштабуванням текселів лайтмапи, "
"переконайтеся, що ви дотримуєтеся правила масштабування сіті, згаданого вище."

msgid "Setting up meshes"
msgstr "Налаштування мешів (сіток)"

msgid ""
"For a **MeshInstance3D** node to take part in the baking process, it needs "
"to have its bake mode set to **Static**. Meshes that have their bake mode "
"set to **Disabled** or **Dynamic** will be ignored by the lightmapper."
msgstr ""
"Щоб вузол **MeshInstance3D** брав участь у процесі запікання, його режим "
"запікання повинен бути встановлений на **Статичний**. Сітки, для яких режим "
"запікання встановлений на **Вимкнено** або **Динамічний**, будуть "
"проігноровані Lightmapper."

msgid ""
"When auto-generating lightmaps on scene import, this is enabled "
"automatically."
msgstr ""
"При автоматичному створенні карт освітлення, ця властивість активується "
"автоматично."

msgid "Setting up lights"
msgstr "Налаштування світла"

msgid ""
"Lights are baked with indirect light only by default. This means that "
"shadowmapping and lighting are still dynamic and affect moving objects, but "
"light bounces from that light will be baked."
msgstr ""
"За замовчуванням освітлення освітлюється лише непрямим світлом. Це означає, "
"що відображення тіней і освітлення все ще динамічні та впливають на рухомі "
"об’єкти, але світло, що відбивається від цього світла, буде запікатися."

msgid ""
"Lights can be disabled (no bake) or be fully baked (direct and indirect). "
"This can be controlled from the **Bake Mode** menu in lights:"
msgstr ""
"Світло можна відключити (не запікати), або запекти повністю (пряме і "
"непряме). Цим можна керувати з меню **Bake Mode** *(Режим запікання)* на "
"світлі:"

msgid "The modes are:"
msgstr "Основні режими:"

msgid "Disabled"
msgstr "Вимкнено"

msgid ""
"The light is ignored when baking lightmaps. This is the mode to use for "
"dynamic lighting effects such as explosions and weapon effects."
msgstr ""
"Під час запікання карт світла світло ігнорується. Цей режим використовується "
"для динамічних світлових ефектів, таких як вибухи та ефекти зброї."

msgid ""
"Hiding a light has no effect on the resulting lightmap bake. This means you "
"must use the Disabled bake mode instead of hiding the Light node by "
"disabling its **Visible** property."
msgstr ""
"Приховування світла не впливає на остаточне запікання карти освітлення. Це "
"означає, що ви повинні використовувати вимкнений режим запікання замість "
"того, щоб приховувати вузол Light, вимкнувши його властивість **Visible**."

msgid "Dynamic"
msgstr "Динамічний"

msgid ""
"This is the default mode, and is a compromise between performance and real-"
"time friendliness. Only indirect lighting will be baked. Direct light and "
"shadows are still real-time, as they would be without LightmapGI."
msgstr ""
"Це режим за замовчуванням і є компромісом між продуктивністю та зручністю "
"роботи в реальному часі. Запалюється лише непряме освітлення. Пряме світло й "
"тіні залишаються в реальному часі, як і без LightmapGI."

msgid ""
"This mode allows performing *subtle* changes to a light's color, energy and "
"position while still looking fairly correct. For example, you can use this "
"to create flickering static torches that have their indirect light baked."
msgstr ""
"Цей режим дозволяє виконувати *тонкі* зміни кольору, енергії та положення "
"світла, і при цьому зберігати досить коректний вигляд. Наприклад, ви можете "
"використовувати його для створення мерехтливих статичних факелів, і запекти "
"їх непряме світло."

msgid ""
"Depending on the value of **Shadowmask Mode**, it is possible to still get "
"distant baked shadows for DirectionalLight3D. This allows shadows up close "
"to be real-time and show dynamic objects, while allowing static objects in "
"the distance to still cast shadows."
msgstr ""
"Залежно від значення **Shadowmask Mode** можна отримати віддалені запечені "
"тіні для DirectionalLight3D. Завдяки цьому тіні зблизька відтворюються в "
"реальному часі та відображають динамічні об’єкти, а статичні об’єкти на "
"відстані відкидають тіні."

msgid "Static"
msgstr "Статичний"

msgid ""
"Both indirect and direct lighting will be baked. Since static surfaces can "
"skip lighting and shadow computations entirely, this mode provides the best "
"performance along with smooth shadows that never fade based on distance. The "
"real-time light will not affect baked surfaces anymore, but it will still "
"affect dynamic objects. When using the **All** bake mode on a light, dynamic "
"objects will not cast real-time shadows onto baked surfaces, so you need to "
"use a different approach such as blob shadows instead. Blob shadows can be "
"implemented with a Decal node."
msgstr ""
"Буде запікатися як непряме, так і пряме освітлення. Оскільки статичні "
"поверхні можуть повністю пропускати обчислення освітлення та тіней, цей "
"режим забезпечує найкращу продуктивність разом із плавними тінями, які "
"ніколи не тьмяніють залежно від відстані. Світло в режимі реального часу "
"більше не впливатиме на запечені поверхні, але воно все ще впливатиме на "
"динамічні об’єкти. У разі використання режиму випікання **Все** на світлі "
"динамічні об’єкти не відкидають тіні в реальному часі на запечені поверхні, "
"тому вам потрібно використовувати інший підхід, наприклад тіні з крапками. "
"Тіні крапки можна реалізувати за допомогою вузла Decal."

msgid ""
"The light will not be adjustable at all during gameplay. Moving the light or "
"changing its color (or energy) will not have any effect on static surfaces."
msgstr ""
"Світло взагалі не можна буде регулювати під час гри. Переміщення світла чи "
"зміна його кольору (або енергії) не матиме жодного впливу на статичні "
"поверхні."

msgid ""
"Since bake modes can be adjusted on a per-light basis, it is possible to "
"create hybrid baked light setups. One popular option is to use a real-time "
"DirectionalLight with its bake mode set to **Dynamic**, and use the "
"**Static** bake mode for OmniLights and SpotLights. This provides good "
"performance while still allowing dynamic objects to cast real-time shadows "
"in outdoor areas."
msgstr ""
"Оскільки режими випічки можна регулювати для кожного світла, можна "
"створювати гібридні налаштування світла для випікання. Одним із популярних "
"варіантів є використання DirectionalLight у реальному часі з режимом "
"запікання **Dynamic** і використання режиму запікання **Static** для "
"OmniLights і SpotLights. Це забезпечує високу продуктивність, водночас "
"дозволяючи динамічним об’єктам відкидати тіні в режимі реального часу на "
"вулицях."

msgid ""
"Fully baked lights can also make use of light nodes' **Size** (omni/spot) or "
"**Angular Distance** (directional) properties. This allows for shadows with "
"realistic penumbra that increases in size as the distance between the caster "
"and the shadow increases. This also has a lower performance cost compared to "
"real-time PCSS shadows, as only dynamic objects have real-time shadows "
"rendered on them."
msgstr ""
"Повністю запечені світильники також можуть використовувати властивості "
"**Розмір** (всесвітній/точковий) або **Кутова відстань** (спрямований) "
"вузлів світла. Це дозволяє створювати тіні з реалістичною півтінню, яка "
"збільшується в розмірі зі збільшенням відстані між заклинателем і тінню. Це "
"також має нижчу вартість продуктивності порівняно з тінями PCSS у реальному "
"часі, оскільки тіні в реальному часі відображаються лише на динамічних "
"об’єктах."

msgid "Baking"
msgstr "Запікання"

msgid ""
"To begin the bake process, click the **Bake Lightmaps** button at the top of "
"the 3D editor viewport when selecting the LightmapGI node:"
msgstr ""
"Щоб почати процес запікання, натисніть кнопку **Запікати карти світла** у "
"верхній частині вікна перегляду 3D-редактора під час вибору вузла LightmapGI:"

msgid ""
"This can take from seconds to minutes (or hours) depending on scene size, "
"bake method and quality selected."
msgstr ""
"Це може зайняти від кількох секунд до хвилин (а то й годин) залежно від "
"розміру сцени, способу запікання та обраної якості."

msgid ""
"Baking lightmaps is a process that can require a lot of video memory, "
"especially if the resulting texture is large. Due to internal limitations, "
"the engine may also crash if the generated texture size is too large (even "
"on systems with a lot of video memory)."
msgstr ""
"Запікання карт світла — це процес, який може вимагати багато відеопам’яті, "
"особливо якщо отримана текстура велика. Через внутрішні обмеження механізм "
"також може аварійно завершувати роботу, якщо розмір згенерованої текстури є "
"завеликим (навіть у системах із великою кількістю відеопам’яті)."

msgid ""
"To avoid crashes, make sure the lightmap texel size in the Import dock is "
"set to a high enough value."
msgstr ""
"Щоб уникнути збоїв, переконайтеся, що розмір текселів карти освітлення в док-"
"станції «Імпорт» має достатньо високе значення."

msgid "Tweaks"
msgstr "Коригування"

msgid ""
"**Quality:** Four bake quality modes are provided: Low, Medium, High, and "
"Ultra. Higher quality takes more time, but result in a better-looking "
"lightmap with less noise. The difference is especially noticeable with "
"emissive materials or areas that get little to no direct lighting. Each bake "
"quality mode can be further adjusted in the Project Settings."
msgstr ""
"**Якість:** Передбачено чотири режими якості випічки: низька, середня, "
"висока та ультра. Вища якість займає більше часу, але в результаті "
"отримується краща карта освітлення з меншим шумом. Різниця особливо помітна "
"з емісійними матеріалами або областями, які практично не освітлюються прямо. "
"Кожен режим якості випічки можна додатково налаштувати в налаштуваннях "
"проекту."

msgid ""
"**Bounces:** The number of bounces to use for indirect lighting. The default "
"value (``3``) is a good compromise between bake times and quality. Higher "
"values will make light bounce around more times before it stops, which makes "
"indirect lighting look smoother (but also possibly brighter depending on "
"materials and geometry)."
msgstr ""
"**Відскоки:** кількість відскоків для непрямого освітлення. Значення за "
"умовчанням (``3``) є хорошим компромісом між часом випікання та якістю. Вищі "
"значення призведуть до того, що світло буде відбиватися більше разів, перш "
"ніж зупинитися, що робить непряме освітлення більш плавним (але також, "
"можливо, яскравішим залежно від матеріалів і геометрії)."

msgid ""
"**Bounce Indirect Energy:** The global multiplier to use when baking lights' "
"indirect energy. This multiplies each light's own **Indirect Energy** value. "
"Values different from ``1.0`` are not physically accurate, but can be used "
"for artistic effect."
msgstr ""
"**Непряма енергія відскоку:** Глобальний множник, який використовується під "
"час запікання непрямої енергії вогнів. Це збільшує власне значення "
"**Непрямої енергії** кожного світла. Значення, відмінні від ``1.0``, не є "
"фізично точними, але їх можна використовувати для художнього ефекту."

msgid ""
"**Directional:** If enabled, stores directional information for lightmaps. "
"This improves normal mapped materials' appearance for baked surfaces, "
"especially with fully baked lights (since they also have direct light "
"baked). The downside is that directional lightmaps are slightly more "
"expensive to render. They also require more time to bake and result in "
"larger file sizes."
msgstr ""
"**Напрямок:** якщо ввімкнено, зберігає інформацію про напрямок для карт "
"освітлення. Це покращує зовнішній вигляд звичайних картованих матеріалів для "
"запечених поверхонь, особливо з повністю запеченими світлами (оскільки вони "
"також мають пряме запікання світлом). Недоліком є те, що направлені карти "
"освітлення трохи дорожчі для візуалізації. Вони також вимагають більше часу "
"для запікання, що призводить до більших розмірів файлів."

msgid ""
"**Shadowmask Mode:** If set to a mode other than **None**, the first "
"DirectionalLight3D in the scene with the **Dynamic** global illumination "
"mode will have its static shadows baked to a separate texture called a "
"*shadowmask*. This can be used to allow distant static objects to cast "
"shadows onto other static objects regardless of the distance from the "
"camera. See the :ref:`section on shadowmasking "
"<doc_using_lightmap_gi_shadowmask>` for further details."
msgstr ""
"**Режим тіньової маски:** якщо встановлено режим, відмінний від **Немає**, "
"перший DirectionalLight3D у сцені з **Динамічним** режимом глобального "
"освітлення матиме свої статичні тіні, запечені в окрему текстуру, яка "
"називається *маска тіні*. Це можна використовувати, щоб дозволити віддаленим "
"статичним об’єктам відкидати тіні на інші статичні об’єкти незалежно від "
"відстані від камери. Перегляньте :ref:`section on shadowmasking "
"<doc_using_lightmap_gi_shadowmask>` для отримання додаткової інформації."

msgid ""
"**Interior:** If enabled, environment lighting will not be sourced. Use this "
"for purely indoor scenes to avoid light leaks."
msgstr ""
"**Інтер’єр:** якщо ввімкнено, джерело освітлення навколишнього середовища не "
"здійснюватиметься. Використовуйте це для сцен виключно в приміщенні, щоб "
"уникнути витоку світла."

msgid ""
"**Use Texture for Bounces:** If enabled, a texture with the lighting "
"information will be generated to speed up the generation of indirect "
"lighting at the cost of some accuracy. The geometry might exhibit extra "
"light leak artifacts when using low resolution lightmaps or UVs that stretch "
"the lightmap significantly across surfaces. Leave this enabled if unsure."
msgstr ""
"**Використовувати текстуру для відскоків:** якщо ввімкнути, буде створено "
"текстуру з інформацією про освітлення, щоб прискорити створення непрямого "
"освітлення ціною певної точності. У геометрії можуть спостерігатися "
"додаткові артефакти витоку світла під час використання карт освітлення з "
"низькою роздільною здатністю або UVs, які значно розтягують карту освітлення "
"по поверхнях. Якщо ви не впевнені, залиште цю функцію ввімкненою."

msgid ""
"**Use Denoiser:** If enabled, uses a denoising algorithm to make the "
"lightmap significantly less noisy. This increases bake times and can "
"occasionally introduce artifacts, but the result is often worth it. "
"See :ref:`doc_using_lightmap_gi_denoising` for more information."
msgstr ""
"**Використовувати шумозаглушувач:** якщо ввімкнено, використовується "
"алгоритм зменшення шуму, щоб зробити карту освітлення значно менш шумною. Це "
"збільшує час випікання та іноді може вводити артефакти, але результат часто "
"того вартий. Перегляньте :ref:`doc_using_lightmap_gi_denoising` для "
"отримання додаткової інформації."

msgid ""
"**Denoiser Strength:** The strength of denoising step applied to the "
"generated lightmaps. Higher values are more effective at removing noise, but "
"can reduce shadow detail for static shadows. Only effective if denoising is "
"enabled and the denoising method is :abbr:`JNLM (Non-Local Means with Joint "
"Filtering)` (:abbr:`OIDN (Open Image Denoise)` does not have a denoiser "
"strength setting)."
msgstr ""
"**Інтенсивність усунення шуму:** Інтенсивність кроку усунення шуму, "
"застосованого до згенерованих карт освітлення. Вищі значення більш ефективні "
"для видалення шуму, але можуть зменшити деталізацію статичних тіней. "
"Ефективно, лише якщо ввімкнуто усунення шумів і метод усунення "
"шумів :abbr:`JNLM (Non-Local Means with Joint Filtering)` (:abbr:`OIDN (Open "
"Image Denoise)` не має налаштування сили усунення шуму)."

msgid ""
"**Bias:** The offset value to use for shadows in 3D units. You generally "
"don't need to change this value, except if you run into issues with light "
"bleeding or dark spots in your lightmap after baking. This setting does not "
"affect real-time shadows casted on baked surfaces (for lights with "
"**Dynamic** bake mode)."
msgstr ""
"**Зміщення:** значення зміщення, яке використовується для тіней у 3D-"
"об’єктах. Зазвичай вам не потрібно змінювати це значення, за винятком "
"випадків, коли у вас виникли проблеми з легкими кровотечами або темними "
"плямами на карті освітлення після запікання. Цей параметр не впливає на тіні "
"в реальному часі, що відкидаються на запечених поверхнях (для світильників "
"із **Динамічним** режимом запікання)."

msgid ""
"**Max Texture Size:** The maximum texture size for the generated texture "
"atlas. Higher values will result in fewer slices being generated, but may "
"not work on all hardware as a result of hardware limitations on texture "
"sizes. Leave this at its default value of ``16384`` if unsure."
msgstr ""
"**Максимальний розмір текстури:** максимальний розмір текстури для "
"створеного атласу текстури. Вищі значення призведуть до створення меншої "
"кількості фрагментів, але можуть працювати не на всьому обладнанні через "
"апаратні обмеження щодо розмірів текстури. Якщо не впевнені, залиште "
"значення за замовчуванням ``16384``."

msgid ""
"**Environment > Mode:** Controls how environment lighting is sourced when "
"baking lightmaps. The default value of **Scene** is suited for levels with "
"visible exterior parts. For purely indoor scenes, set this to **Disabled** "
"to avoid light leaks and speed up baking. This can also be set to **Custom "
"Sky** or **Custom Color** to use environment lighting that differs from the "
"actual scene's environment sky."
msgstr ""
"**Середовище > Режим:** контролює джерело освітлення середовища під час "
"запікання карт освітлення. Значення за замовчуванням **Сцена** підходить для "
"рівнів із видимими зовнішніми частинами. Для сцен виключно в приміщенні "
"встановіть для цього параметра значення **Вимкнено**, щоб уникнути витоку "
"світла та прискорити випікання. Для цього також можна встановити значення "
"**Власне небо** або **Власний колір**, щоб використовувати освітлення "
"середовища, яке відрізняється від реального неба навколишнього середовища "
"сцени."

msgid ""
"**Gen Probes > Subdiv:** See :ref:`doc_using_lightmap_gi_dynamic_objects`."
msgstr ""
"**Gen Probes > Subdiv:** Див. :ref:`doc_using_lightmap_gi_dynamic_objects`."

msgid "**Data > Light Data:** See :ref:`doc_using_lightmap_gi_data`."
msgstr "**Дані > Світлові дані:** Див. :ref:`doc_using_lightmap_gi_data`."

msgid "Using shadowmasking for distant directional shadows"
msgstr "Використання тіньового маскування для віддалених спрямованих тіней"

msgid ""
"When using a DirectionalLight3D, the maximum distance at which it can draw "
"real-time shadows is limited by its **Shadow Max Distance** property. This "
"can be an issue in large scenes, as distant objects won't appear to have any "
"shadows from the DirectionalLight3D. While this can be resolved by using the "
"**Static** global illumination mode on the DirectionalLight3D, this has "
"several downsides:"
msgstr ""
"Під час використання DirectionalLight3D максимальна відстань, на якій він "
"може малювати тіні в реальному часі, обмежена властивістю **Shadow Max "
"Distance**. Це може бути проблемою у великих сценах, оскільки віддалені "
"об’єкти не матимуть жодних тіней від DirectionalLight3D. Хоча цю проблему "
"можна вирішити за допомогою режиму глобального освітлення **Static** на "
"DirectionalLight3D, це має кілька недоліків:"

msgid ""
"Since both direct and indirect light are baked, there is no way for dynamic "
"objects to cast shadows onto static surfaces in a realistic manner. Godot "
"skips shadow sampling entirely in this case to avoid \"double lighting\" "
"artifacts."
msgstr ""
"Оскільки як пряме, так і непряме світло запікаються, динамічні об’єкти не "
"можуть реалістично відкидати тіні на статичні поверхні. У цьому випадку "
"Godot повністю пропускає вибірку тіней, щоб уникнути артефактів «подвійного "
"освітлення»."

msgid ""
"Static shadows up close lack in detail, as they only rely on the lightmap "
"texture and not on real-time shadow cascades."
msgstr ""
"Статичним тіням зблизька бракує деталей, оскільки вони покладаються лише на "
"текстуру карти освітлення, а не на каскади тіней у реальному часі."

msgid ""
"We can avoid these downsides while still benefiting from distant shadows by "
"using *shadowmasking*. While dynamic objects won't receive shadows from the "
"shadowmask, it still greatly improves visuals since most scenes are "
"primarily comprised of static objects."
msgstr ""
"Ми можемо уникнути цих недоліків, але все ще мати переваги від далеких "
"тіней, використовуючи *shadowmasking*. Хоча динамічні об’єкти не отримають "
"тіні від тіньової маски, вона все одно значно покращує візуальні ефекти, "
"оскільки більшість сцен переважно складаються зі статичних об’єктів."

msgid ""
"Since the lightmap texture alone doesn't contain shadow information, we can "
"bake this shadow information to a separate texture called a *shadowmask*."
msgstr ""
"Оскільки текстура карти освітлення сама по собі не містить інформації про "
"тінь, ми можемо записати цю інформацію про тіні в окрему текстуру, яка "
"називається *маска тіні*."

msgid ""
"Shadowmasking only affects the first DirectionalLight3D in the scene "
"(determined by tree order) that has the **Dynamic** global illumination "
"mode. It is not possible to use shadowmasking with the **Static** global "
"illumination mode, as this mode skips shadow sampling on static objects "
"entirely. This is because the Static global illumination mode bakes both "
"direct and indirect light."
msgstr ""
"Маскування тіней впливає лише на перший DirectionalLight3D у сцені "
"(визначений у порядку дерева), який має режим глобального освітлення "
"**Dynamic**. Неможливо використовувати тіньове маскування з режимом "
"глобального освітлення **Static**, оскільки цей режим повністю пропускає "
"вибірку тіні на статичних об’єктах. Це пов’язано з тим, що режим статичного "
"глобального освітлення виділяє як пряме, так і непряме світло."

msgid "Three shadowmasking modes are available:"
msgstr "Доступні три режими маскування тіней:"

msgid ""
"**None (default):** Don't bake a shadowmask texture. Directional shadows "
"will not be visible outside the range specified by the DirectionalLight3D's "
"**Shadow Max Distance** property."
msgstr ""
"**Немає (за замовчуванням):** Не випікати текстуру тіньової маски. "
"Спрямовані тіні не будуть видимі за межами діапазону, визначеного "
"властивістю DirectionalLight3D **Shadow Max Distance**."

msgid ""
"**Replace:** Bakes a shadowmask texture, and uses it to draw directional "
"shadows when outside the range specified by the DirectionalLight3D's "
"**Shadow Max Distance** property. Shadows within this range remain fully "
"real-time. This option generally makes the most sense for most scenes, as it "
"can deal well with static objects that exhibit subtle motion (e.g. foliage "
"shadows)."
msgstr ""
"**Замінити:** створює текстуру тіньової маски та використовує її для "
"малювання спрямованих тіней, коли вони виходять за межі діапазону, "
"визначеного властивістю **Shadow Max Distance** DirectionalLight3D. Тіні в "
"межах цього діапазону залишаються повністю реальними. Цей параметр, як "
"правило, є найбільш доцільним для більшості сцен, оскільки він добре працює "
"зі статичними об’єктами, які демонструють ледь помітний рух (наприклад, тіні "
"листя)."

msgid ""
"**Overlay:** Bakes a shadowmask texture, and uses it to draw directional "
"shadows regardless of the distance from the camera. Shadows within the range "
"of the DirectionalLight3D's **Shadow Max Distance** property will be "
"overlaid with real-time shadows. This can make the transition between real-"
"time and baked shadows less jarring, at the cost of a \"smearing\" effect "
"present on static object shadows depending on lightmap texel density. Also, "
"this mode can't deal as well with static objects that exhibit subtle motion "
"(such as foliage), as the baked shadows can't be animated over time. Still, "
"for scenes where the camera moves quickly, this may be a better choice than "
"**Replace**."
msgstr ""
"**Накладання:** створює текстуру тіньової маски та використовує її для "
"малювання спрямованих тіней незалежно від відстані від камери. Тіні в "
"діапазоні властивості DirectionalLight3D **Shadow Max Distance** будуть "
"накладені тінями в реальному часі. Це може зробити перехід між тінями в "
"реальному часі та запеченими тінями менш різкими, ціною ефекту «змазування», "
"наявного на тінях статичних об’єктів залежно від щільності текселів карти "
"освітлення. Крім того, цей режим не може добре працювати зі статичними "
"об’єктами, які виявляють тонкий рух (наприклад, листя), оскільки запечені "
"тіні не можна анімувати з часом. Тим не менш, для сцен, де камера рухається "
"швидко, це може бути кращим вибором, ніж **Замінити**."

msgid ""
"Here's a visual comparison of the shadowmask modes with a scene where the "
"**Shadow Max Distance** was set very low for comparison purposes. The blue "
"boxes are dynamic objects, while the rest of the scene is a static object. "
"There is only a single DirectionalLight3D in the scene with the Dynamic "
"global illumination mode:"
msgstr ""
"Ось візуальне порівняння режимів тіньової маски зі сценою, де **Максимальна "
"відстань до тіні** була встановлена дуже низькою для порівняння. Сині "
"прямокутники є динамічними об’єктами, тоді як решта сцени є статичними "
"об’єктами. У сцені з режимом динамічного глобального освітлення лише один "
"DirectionalLight3D:"

msgid "Comparison between shadowmask modes"
msgstr "Порівняння між режимами тіньової маски"

msgid ""
"It is possible to switch between the **Replace** and **Overlay** shadowmask "
"modes without having to bake lightmaps again."
msgstr ""
"Можна перемикатися між режимами тіньової маски **Замінити** та **Накладати** "
"без необхідності повторного запікання карт освітлення."

msgid "Balancing bake times with quality"
msgstr "Балансування між часом запікання і якістю"

msgid ""
"Since high-quality bakes can take very long (up to dozens of minutes for "
"large complex scenes), it is recommended to use lower quality settings at "
"first. Then, once you are confident with your scene's lighting setup, raise "
"the quality settings and perform a \"final\" bake before exporting your "
"project."
msgstr ""
"Оскільки високоякісні запікання можуть тривати дуже довго (до десятків "
"хвилин для великих складних сцен), спочатку рекомендується використовувати "
"нижчі налаштування якості. Потім, коли ви впевнені в налаштуваннях "
"освітлення сцени, підвищте параметри якості та виконайте «останнє» запікання "
"перед експортом вашого проекту."

msgid ""
"Reducing the lightmap resolution by increasing **Lightmap Texel Size** on "
"the imported 3D scenes will also speed up baking significantly. However, "
"this will require you to reimport all lightmapped 3D scenes before you can "
"bake lightmaps again."
msgstr ""
"Зменшення роздільної здатності карти освітлення за рахунок збільшення "
"**Розміру текселів карти освітлення** на імпортованих 3D-сценах також значно "
"пришвидшить запікання. Однак для цього вам потрібно буде повторно "
"імпортувати всі 3D-сцени зі світловими картами, перш ніж ви зможете знову "
"запікати карти освітлення."

msgid "Denoising"
msgstr "Усунення шуму"

msgid ""
"Since baking lightmaps relies on raytracing, there will always be visible "
"noise in the \"raw\" baked lightmap. Noise is especially visible in areas "
"that are difficult to reach by bounced light, such as indoor areas with "
"small openings where the sunlight can enter. Noise can be reduced by "
"increasing bake quality, but doing so will increase bake times significantly."
msgstr ""
"Оскільки запікання карт освітлення покладається на трасування променів, у "
"«сирій» запеченій карті освітлення завжди буде видимий шум. Шум особливо "
"помітний у місцях, важкодоступних для відбитого світла, наприклад у "
"приміщеннях із невеликими отворами, куди проникає сонячне світло. Шум можна "
"зменшити, підвищивши якість випікання, але це значно збільшить час випікання."

msgid "Comparison between denoising disabled and enabled"
msgstr "Порівняння між увімкненим і вимкненим шумозаглушенням"

msgid ""
"Comparison between denoising disabled and enabled (with the default JNLM "
"denoiser)."
msgstr ""
"Порівняння між увімкненим і вимкненим шумозаглушенням (із засобом зменшення "
"шуму JNLM за замовчуванням)."

msgid ""
"To combat noise without increasing bake times too much, a denoiser can be "
"used. A denoiser is an algorithm that runs on the final baked lightmap, "
"detects patterns of noise and softens them while attempting to best preserve "
"detail. Godot offers two denoising algorithms:"
msgstr ""
"Щоб боротися з шумом, не надто збільшуючи час випікання, можна "
"використовувати деноайзер. Зменшувач шуму — це алгоритм, який працює на "
"остаточній запеченій карті освітлення, виявляє шаблони шуму та пом’якшує їх, "
"намагаючись якнайкраще зберегти деталі. Godot пропонує два алгоритми "
"усунення шуму:"

msgid "JNLM (Non-Local Means with Joint Filtering)"
msgstr "JNLM (нелокальні засоби зі спільною фільтрацією)"

msgid ""
"JNLM is the default denoising method and is included in Godot. It uses a "
"simple but efficient denoising algorithm known as *non-local means*. JNLM "
"runs on the GPU using a compute shader, and is compatible with any GPU that "
"can run Godot 4's Vulkan-based rendering methods. No additional setup is "
"required."
msgstr ""
"JNLM є стандартним методом усунення шумів і включений у Godot. Він "
"використовує простий, але ефективний алгоритм усунення шумів, відомий як "
"*нелокальні засоби*. JNLM працює на графічному процесорі за допомогою "
"обчислювального шейдера та сумісний з будь-яким графічним процесором, який "
"може запускати методи візуалізації Godot 4 на основі Vulkan. Додаткове "
"налаштування не потрібно."

msgid ""
"JNLM's denoising can be adjusted using the **Denoiser Strength** property "
"that is visible when **Use Denoiser** enabled. Higher values can be more "
"effective at removing noise, at the cost of suppressing shadow detail for "
"static shadows."
msgstr ""
"Усунення шуму JNLM можна налаштувати за допомогою властивості **Denoiser "
"Strength**, яка відображається, коли ввімкнено **Use Denoiser**. Вищі "
"значення можуть бути більш ефективними для видалення шуму, ціною придушення "
"деталей тіні для статичних тіней."

msgid "Comparison between JNLM denoiser strength values"
msgstr "Порівняння значень сили шумозаглушувача JNLM"

msgid ""
"Comparison between JNLM denoiser strength values. Higher values can reduce "
"detail."
msgstr ""
"Порівняння значень сили шумозаглушувача JNLM. Вищі значення можуть зменшити "
"деталізацію."

msgid "OIDN (Open Image Denoise)"
msgstr "OIDN (усунення шуму відкритого зображення)"

msgid ""
"Unlike JNLM, OIDN uses a machine learning approach to denoising lightmaps. "
"It features a model specifically trained to remove noise from lightmaps "
"while preserving more shadow detail in most scenes compared to JNLM."
msgstr ""
"На відміну від JNLM, OIDN використовує підхід машинного навчання для "
"зменшення шуму на картах освітлення. Він містить модель, спеціально навчену "
"видаляти шум із карт освітлення, зберігаючи при цьому більше деталей тіні в "
"більшості сцен порівняно з JNLM."

msgid ""
"OIDN can run on the GPU if hardware acceleration is configured. With a "
"modern high-end GPU, this can provide a speedup of over 50× over CPU-based "
"denoising:"
msgstr ""
"OIDN може працювати на GPU, якщо налаштовано апаратне прискорення. Завдяки "
"сучасному графічному процесору високого класу це може забезпечити "
"прискорення більш ніж у 50 разів порівняно з усуненням шумів на основі ЦП:"

msgid "On AMD GPUs, HIP must be installed and configured."
msgstr "На графічних процесорах AMD потрібно встановити та налаштувати HIP."

msgid ""
"On NVIDIA GPUs, CUDA must be installed and configured. This may "
"automatically be done by the NVIDIA installer, but on Linux, CUDA libraries "
"may not be installed by default. Double-check that the CUDA packages from "
"your Linux distribution are installed."
msgstr ""
"На графічних процесорах NVIDIA необхідно встановити та налаштувати CUDA. Це "
"може автоматично зробити інсталятор NVIDIA, але в Linux бібліотеки CUDA "
"можуть не встановлюватися за замовчуванням. Ще раз перевірте, чи встановлено "
"пакети CUDA з вашого дистрибутива Linux."

msgid "On Intel GPUs, SYCL must be installed and configured."
msgstr ""
"На графічних процесорах Intel необхідно встановити та налаштувати SYCL."

msgid ""
"If hardware acceleration is not available, OIDN will fall back to "
"multithreaded CPU-based denoising. To confirm whether GPU-based denoising is "
"working, use a GPU utilization monitor while baking lightmaps and look at "
"the GPU utilization percentage and VRAM utilization while the denoising step "
"is shown in the Godot editor. The ``nvidia-smi`` command line tool can be "
"useful for this."
msgstr ""
"Якщо апаратне прискорення недоступне, OIDN повернеться до багатопотокового "
"усунення шумів на основі ЦП. Щоб перевірити, чи працює усунення шумів на "
"основі графічного процесора, скористайтеся монітором використання графічного "
"процесора під час запікання світлових карт і подивіться на відсоток "
"використання графічного процесора та використання відеопам’яті, коли етап "
"усунення шуму відображається в редакторі Godot. Для цього може бути корисним "
"інструмент командного рядка ``nvidia-smi``."

msgid ""
"OIDN is not included with Godot due to its relatively large download size. "
"You can download precompiled OIDN binary packages from its `website <https://"
"www.openimagedenoise.org/downloads.html>`__. Extract the package to a "
"location on your PC, then specify the path to the ``oidnDenoise`` executable "
"in the Editor Settings (**FileSystem > Tools > OIDN > OIDN Denoise Path**). "
"This executable is located within the ``bin`` folder of the binary package "
"you extracted."
msgstr ""
"OIDN не включено до Godot через його відносно великий розмір завантаження. "
"Ви можете завантажити попередньо скомпільовані бінарні пакунки OIDN з `веб-"
"сайту <https://www.openimagedenoise.org/downloads.html>`__. Розпакуйте пакет "
"у розташування на вашому комп’ютері, а потім укажіть шлях до виконуваного "
"файлу ``oidnDenoise`` у налаштуваннях редактора (**Файлова система > "
"Інструменти > OIDN > OIDN Denoise Path**). Цей виконуваний файл знаходиться "
"в папці ``bin`` бінарного пакета, який ви роздобули."

msgid ""
"After specifying the path to the OIDN denoising executable, change the "
"denoising method in the project settings by setting **Rendering > "
"Lightmapping > Denoiser** to **OIDN**. This will affect all lightmap bakes "
"on this project after the setting is changed."
msgstr ""
"Після вказівки шляху до виконуваного файлу усунення шуму OIDN змініть метод "
"усунення шуму в налаштуваннях проекту, встановивши для **Відображення > "
"Відображення світла > Усунення шуму** значення **OIDN**. Це вплине на всі "
"запікання карт освітлення в цьому проекті після зміни налаштувань."

msgid ""
"The denoising method is configured in the project settings instead of the "
"editor settings. This is done so that different team members working on the "
"same project are assured to be using the same denoising method for "
"consistent results."
msgstr ""
"Метод усунення шумів налаштовується в налаштуваннях проекту замість "
"налаштувань редактора. Це робиться для того, щоб різні учасники команди, які "
"працюють над одним проектом, могли використовувати один і той самий метод "
"усунення шумів для досягнення стабільних результатів."

msgid "Comparison between JNLM and OIDN denoisers"
msgstr "Порівняння засобів усунення шуму JNLM і OIDN"

msgid ""
"Comparison between JNLM and OIDN denoisers. Notice how OIDN better preserves "
"detail and reduces seams across different objects."
msgstr ""
"Порівняння засобів усунення шуму JNLM і OIDN. Зверніть увагу, як OIDN краще "
"зберігає деталі та зменшує шви між різними об’єктами."

msgid "Dynamic objects"
msgstr "Динамічні об'єкти"

msgid ""
"Unlike VoxelGI and SDFGI, dynamic objects receive indirect lighting "
"differently compared to static objects. This is because lightmapping is only "
"performed on static objects."
msgstr ""
"На відміну від VoxelGI та SDFGI, динамічні об’єкти отримують непряме "
"освітлення інакше, ніж статичні об’єкти. Це пояснюється тим, що відображення "
"світла виконується лише на статичних об’єктах."

msgid ""
"To display indirect lighting on dynamic objects, a 3D probe system is used, "
"with light probes being spread throughout the scene. When baking lightmaps, "
"the lightmapper will calculate the amount of *indirect* light received by "
"the probe. Direct light is not stored within light probes, even for lights "
"that have their bake mode set to **Static** (as dynamic objects continue to "
"be lit in real-time)."
msgstr ""
"Для відображення непрямого освітлення на динамічних об’єктах "
"використовується система 3D-зондів із світловими зондами, розподіленими по "
"всій сцені. Під час запікання світлових карт, Lightmapper обчислить "
"кількість *непрямого* світла, яке отримує зонд. Пряме світло не зберігається "
"в світлових зондах, навіть для світильників, для яких режим запікання "
"встановлено на **Статичний** (оскільки динамічні об’єкти продовжують "
"освітлюватися в режимі реального часу)."

msgid "There are 2 ways to add light probes to a scene:"
msgstr "Є 2 способи додати світлові зонди до сцени:"

msgid ""
"**Automatic:** Set **Gen Probes > Subdiv** to a value other than "
"**Disabled**, then bake lightmaps. The default is ``8``, but you can choose "
"a greater value to improve precision at the cost of longer bake times and "
"larger output file size."
msgstr ""
"**Автоматично:** встановіть для **Gen Probes > Subdiv** значення, відмінне "
"від **Disabled**, а потім запікайте карти освітлення. Типовим значенням є "
"``8``, але ви можете вибрати більше значення, щоб покращити точність ціною "
"довшого часу запікання та більшого розміру вихідного файлу."

msgid ""
"**Manual:** In addition or as an alternative to generating probes "
"automatically, you can add light probes manually by "
"adding :ref:`class_LightmapProbe` nodes to the scene. This can be used to "
"improve lighting detail in areas frequently travelled by dynamic objects. "
"After placing LightmapProbe nodes in the scene, you must bake lightmaps "
"again for them to be effective."
msgstr ""
"**Вручну:** На додаток або як альтернатива автоматичному створенню зондів, "
"ви можете додавати світлові зонди вручну, додаючи "
"вузли :ref:`class_LightmapProbe` до сцени. Це можна використовувати для "
"покращення деталізації освітлення в місцях, де часто подорожують динамічні "
"об’єкти. Після розміщення вузлів LightmapProbe на сцені ви повинні знову "
"запекти карти освітлення, щоб вони були ефективними."

msgid ""
"After baking lightmaps, you will notice white spheres in the 3D scene that "
"represent how baked lighting will affect dynamic objects. These spheres do "
"**not** appear in the running project."
msgstr ""
"Після запікання карт освітлення ви помітите білі сфери в 3D-сцені, які "
"показують, як запечене освітлення впливатиме на динамічні об’єкти. Ці сфери "
"**не** відображаються у запущеному проекті."

msgid ""
"If you want to hide these spheres in the editor, toggle **View > Gizmos > "
"LightmapGI** at the top of the 3D editor (a \"closed eye\" icon indicates "
"the gizmo is hidden)."
msgstr ""
"Якщо ви хочете приховати ці сфери в редакторі, перемкніть **Перегляд > "
"Gizmos > LightmapGI** у верхній частині 3D-редактора (піктограма «закрите "
"око» вказує на те, що гізмо приховано)."

msgid "Lightmap data"
msgstr "Дані карти освітлення"

msgid ""
"The **Data > Light Data** property in the LightmapGI node contains the "
"lightmap data after baking. Textures are saved to disk, but this also "
"contains the capture data for dynamic objects, which can be heavy. If you "
"are using a scene in ``.tscn`` format, you should save this resource to an "
"external binary ``.lmbake`` file to avoid bloating the ``.tscn`` scene with "
"binary data encoded in Base64."
msgstr ""
"Властивість **Data > Light Data** у вузлі LightmapGI містить дані карти "
"освітлення після запікання. Текстури зберігаються на диску, але він також "
"містить дані захоплення динамічних об’єктів, які можуть бути важкими. Якщо "
"ви використовуєте сцену у форматі ``.tscn``, вам слід зберегти цей ресурс у "
"зовнішньому двійковому файлі ``.lmbake``, щоб уникнути роздуття сцени "
"``.tscn`` двійковими даними, закодованими в Base64."

msgid ""
"The generated EXR file can be viewed and even edited using an image editor "
"to perform post-processing if needed. However, keep in mind that changes to "
"the EXR file will be lost when baking lightmaps again."
msgstr ""
"За необхідності згенерований файл EXR можна переглядати і навіть редагувати "
"за допомогою редактора зображень для виконання пост-обробки. Однак майте на "
"увазі, що зміни у файлі EXR будуть втрачені при повторному запіканні карт "
"освітлення."

msgid "Reducing LightmapGI artifacts"
msgstr "Зменшення артефактів LightmapGI"

msgid ""
"If you notice LightmapGI nodes popping in and out of existence as the camera "
"moves, this is most likely because the engine is rendering too many "
"LightmapGI instances at once. Godot is limited to rendering 8 LightmapGI "
"nodes at once, which means up to 8 instances can be in the camera view "
"before some of them will start flickering."
msgstr ""
"Якщо ви помічаєте, що вузли LightmapGI з’являються та зникають під час руху "
"камери, це, швидше за все, тому, що механізм відображає занадто багато "
"екземплярів LightmapGI одночасно. Godot обмежується рендерингом 8 вузлів "
"LightmapGI одночасно, що означає, що в поданні камери може бути до 8 "
"екземплярів, перш ніж деякі з них почнуть мерехтіти."
