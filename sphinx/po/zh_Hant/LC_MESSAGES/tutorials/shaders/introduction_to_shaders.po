#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction to shaders"
msgstr "著色器簡介"

msgid ""
"This page explains what shaders are and will give you an overview of how "
"they work in Godot. For a detailed reference of the engine's shading "
"language, see :ref:`doc_shading_language`."
msgstr ""
"本頁將說明什麼是著色器，並概述其在 Godot 中的運作方式。如需引擎著色語言的詳細"
"參考，請見 :ref:`doc_shading_language`。"

msgid ""
"Shaders are a special kind of program that runs on Graphics Processing Units "
"(GPUs). They were initially used to shade 3D scenes but can nowadays do much "
"more. You can use them to control how the engine draws geometry and pixels "
"on the screen, allowing you to achieve all sorts of effects."
msgstr ""
"著色器（Shader）是一種在圖形處理器（GPU）上執行的特殊程式。最初是用來為 3D 場"
"景進行著色，但現在能做的事情更多。你可以利用著色器控制引擎在螢幕上繪製幾何圖"
"形和像素的方式，實現各種視覺特效。"

msgid ""
"Modern rendering engines like Godot draw everything with shaders: graphics "
"cards can run thousands of instructions in parallel, leading to incredible "
"rendering speed."
msgstr ""
"現代的繪圖引擎（如 Godot）都是透過著色器來繪製畫面：顯示卡能夠同時並行執行數"
"千條指令，帶來極快的算繪速度。"

msgid ""
"Because of their parallel nature, though, shaders don't process information "
"the way a typical program does. Shader code runs on each vertex or pixel in "
"isolation. You cannot store data between frames either. As a result, when "
"working with shaders, you need to code and think differently from other "
"programming languages."
msgstr ""
"由於著色器本質上是並行運算，處理資訊的方式與一般程式不同。著色器的程式碼會獨"
"立地在每個頂點或像素上執行，且無法在畫格間儲存資料。因此，撰寫著色器時，需要"
"用不同於其他程式語言的思維與方式進行設計。"

msgid ""
"Suppose you want to update all the pixels in a texture to a given color. In "
"GDScript, your code would use ``for`` loops:"
msgstr ""
"假設你想把一張紋理中的所有像素都設為某個指定顏色，在 GDScript 中你的程式碼可"
"能會使用 ``for`` 迴圈："

msgid ""
"Your code is already part of a loop in a shader, so the corresponding code "
"would look like this."
msgstr "而在著色器中，你的程式碼本身就處於一個迴圈中，所以對應的寫法會像這樣。"

msgid ""
"The graphics card calls the ``fragment()`` function once or more for each "
"pixel it has to draw. More on that below."
msgstr ""
"顯示卡會針對每個需要繪製的像素呼叫一次或多次 ``fragment()`` 函式。詳細說明請"
"參見下文。"

msgid "Shaders in Godot"
msgstr "Godot 中的著色器"

msgid ""
"Godot provides a shading language based on the popular OpenGL Shading "
"Language (GLSL) but simplified. The engine handles some of the lower-level "
"initialization work for you, making it easier to write complex shaders."
msgstr ""
"Godot 提供的著色語言是基於廣泛使用的 OpenGL Shading Language（GLSL）所簡化而"
"成。引擎會自動處理部分底層初始化作業，使你能更輕鬆地撰寫複雜的著色器。"

msgid ""
"In Godot, shaders are made up of main functions called \"processor "
"functions\". Processor functions are the entry point for your shader into "
"the program. There are seven different processor functions."
msgstr ""
"在 Godot 中，著色器由稱為「處理函式」的主函式組成。處理函式是著色器程式的進入"
"點。共有七種不同的處理函式。"

msgid ""
"The ``vertex()`` function runs over all the vertices in the mesh and sets "
"their positions and some other per-vertex variables. Used "
"in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial "
"shaders <doc_spatial_shader>`."
msgstr ""
"``vertex()`` 函式會針對網格中的所有頂點執行，並設定頂點的位置及其他每個頂點專"
"屬的變數。用於 :ref:`canvas_item 著色器 <doc_canvas_item_shader>` 與 :ref:`空"
"間著色器 <doc_spatial_shader>`。"

msgid ""
"The ``fragment()`` function runs for every pixel covered by the mesh. It "
"uses values output by the ``vertex()`` function, interpolated between the "
"vertices. Used in :ref:`canvas_item shaders <doc_canvas_item_shader>` "
"and :ref:`spatial shaders <doc_spatial_shader>`."
msgstr ""
"``fragment()`` 函式會針對網格所覆蓋的每一個像素執行。它會使用 ``vertex()`` 函"
"式所輸出的值，並對頂點間的數據進行插值。用於 :ref:`canvas_item 著色器 "
"<doc_canvas_item_shader>` 及 :ref:`空間著色器 <doc_spatial_shader>`。"

msgid ""
"The ``light()`` function runs for every pixel and for every light. It takes "
"variables from the ``fragment()`` function and from its previous runs. Used "
"in :ref:`canvas_item shaders <doc_canvas_item_shader>` and :ref:`spatial "
"shaders <doc_spatial_shader>`."
msgstr ""
"``light()`` 函式會針對每個像素、每盞燈光各執行一次。它會取得來自 "
"``fragment()`` 函式及之前執行過的變數。用於 :ref:`canvas_item 著色器 "
"<doc_canvas_item_shader>` 和 :ref:`空間著色器 <doc_spatial_shader>`。"

msgid ""
"The ``start()`` function runs for every particle in a particle system once "
"when the particle is first spawned. Used in :ref:`particles shaders "
"<doc_particle_shader>`."
msgstr ""
"``start()`` 函式會在粒子系統中每個粒子首次生成時執行一次。用於 :ref:`粒子著色"
"器 <doc_particle_shader>`。"

msgid ""
"The ``process()`` function runs for every particle in a particle system for "
"each frame. Used in :ref:`particles shaders <doc_particle_shader>`."
msgstr ""
"``process()`` 函式會在每個影格中，針對粒子系統內的每個粒子執行一次。用"
"於 :ref:`粒子著色器 <doc_particle_shader>`。"

msgid ""
"The ``sky()`` function runs for every pixel in the radiance cubemap when the "
"radiance cubemap needs to be updated, and for every pixel on the current "
"screen. Used in :ref:`sky shaders <doc_sky_shader>`."
msgstr ""
"``sky()`` 函式會在輻射度立方體貼圖需要更新時，針對貼圖中的每個像素執行，也會"
"在目前螢幕上的每個像素執行。用於 :ref:`天空著色器 <doc_sky_shader>`。"

msgid ""
"The ``fog()`` function runs for every froxel in the volumetric fog froxel "
"buffer that intersects with the :ref:`FogVolume <class_FogVolume>`. Used "
"by :ref:`fog shaders <doc_fog_shader>`."
msgstr ""
"``fog()`` 函式會針對體積霧片段體素緩衝區中，與 :ref:`FogVolume "
"<class_FogVolume>` 相交的每個體素執行。用於 :ref:`霧著色器 "
"<doc_fog_shader>`。"

msgid ""
"The ``light()`` function won't run if the ``vertex_lighting`` render mode is "
"enabled, or if **Rendering > Quality > Shading > Force Vertex Shading** is "
"enabled in the Project Settings. It's enabled by default on mobile platforms."
msgstr ""
"如果啟用了 ``vertex_lighting`` 算繪模式，或在專案設定中啟用了 **Rendering > "
"Quality > Shading > Force Vertex Shading** （算繪 > 品質 > 著色 > 強制頂點著"
"色），則 ``light()`` 函式將不會執行。在行動平台上預設啟用此設定。"

msgid ""
"Godot also exposes an API for users to write totally custom GLSL shaders. "
"For more information see :ref:`doc_compute_shaders`."
msgstr ""
"Godot 也提供 API 讓使用者撰寫完全自訂的 GLSL 著色器。詳情請參"
"閱 :ref:`doc_compute_shaders`。"

msgid "Shader types"
msgstr "著色器類型"

msgid ""
"Instead of supplying a general-purpose configuration for all uses (2D, 3D, "
"particles, sky, fog), you must specify the type of shader you're writing. "
"Different types support different render modes, built-in variables, and "
"processing functions."
msgstr ""
"著色器不提供一個適用於所有用途（2D、3D、粒子、天空、霧）的通用型配置，你必須"
"明確指定要編寫的著色器類型。不同類型支援的算繪模式、內建變數與處理函式也都不"
"同。"

msgid ""
"In Godot, all shaders need to specify their type in the first line, like so:"
msgstr "在 Godot 中，所有著色器必須在第一行就指定其類型，例如："

msgid "Here are the available types:"
msgstr "可用的類型如下："

msgid ":ref:`spatial <doc_spatial_shader>` for 3D rendering."
msgstr ":ref:`spatial <doc_spatial_shader>` 用於 3D 算繪。"

msgid ":ref:`canvas_item <doc_canvas_item_shader>` for 2D rendering."
msgstr ":ref:`canvas_item <doc_canvas_item_shader>` 用於 2D 算繪。"

msgid ":ref:`particles <doc_particle_shader>` for particle systems."
msgstr ":ref:`particles <doc_particle_shader>` 用於粒子系統。"

msgid ":ref:`sky <doc_sky_shader>` to render :ref:`Skies <class_Sky>`."
msgstr ":ref:`sky <doc_sky_shader>` 用於算繪 :ref:`Skies <class_Sky>`。"

msgid ""
":ref:`fog <doc_fog_shader>` to render :ref:`FogVolumes <class_FogVolume>`"
msgstr ""
":ref:`fog <doc_fog_shader>` 用於算繪 :ref:`FogVolumes <class_FogVolume>`"

msgid "Render modes"
msgstr "算繪模式"

msgid ""
"Shaders have optional render modes you can specify on the second line, after "
"the shader type, like so:"
msgstr "著色器可以在第二行（類型之後）指定可選的算繪模式，例如："

msgid ""
"Render modes alter the way Godot applies the shader. For example, the "
"``unshaded`` mode makes the engine skip the built-in light processor "
"function."
msgstr ""
"算繪模式會改變 Godot 如何應用著色器的方式。例如，``unshaded`` 模式會讓引擎略"
"過內建的光照處理函式。"

msgid ""
"Each shader type has different render modes. See the reference for each "
"shader type for a complete list of render modes."
msgstr "每種著色器類型支援的算繪模式各不相同，詳情請參考各類型的文件。"

msgid "Vertex processor"
msgstr "頂點處理器"

msgid ""
"The ``vertex()`` processing function is called once for every vertex in "
"``spatial`` and ``canvas_item`` shaders."
msgstr ""
"在 ``spatial`` 與 ``canvas_item`` 著色器中，會針對每個頂點呼叫一次 "
"``vertex()`` 處理函式。"

msgid ""
"Each vertex in your world's geometry has properties like a position and "
"color. The function modifies those values and passes them to the fragment "
"function. You can also use it to send extra data to the fragment function "
"using varyings."
msgstr ""
"在你的世界幾何體中，每個頂點都擁有像是位置、顏色等屬性。此函式會修改這些數"
"值，並將其傳遞給片段函式。你也可以利用 varying 變數，傳遞額外資訊給片段函式。"

msgid ""
"By default, Godot transforms your vertex information for you, which is "
"necessary to project geometry onto the screen. You can use render modes to "
"transform the data yourself; see the :ref:`Spatial shader doc "
"<doc_spatial_shader>` for an example."
msgstr ""
"預設情況下，Godot 會自動幫你轉換頂點資訊，讓幾何體能正確投影到螢幕。你也可以"
"透過算繪模式，自行進行資料變換；範例請見 :ref:`Spatial 著色器文件 "
"<doc_spatial_shader>`。"

msgid "Fragment processor"
msgstr "片段處理器"

msgid ""
"The ``fragment()`` processing function is used to set up the Godot material "
"parameters per pixel. This code runs on every visible pixel the object or "
"primitive draws. It is only available in ``spatial`` and ``canvas_item`` "
"shaders."
msgstr ""
"``fragment()`` 處理函式用於逐像素設定 Godot 材質參數。這段程式碼會在物件或圖"
"元所繪製的每一個可見像素上執行。僅能在 ``spatial`` 與 ``canvas_item`` 著色器"
"中使用。"

msgid ""
"The standard use of the fragment function is to set up material properties "
"used to calculate lighting. For example, you would set values for "
"``ROUGHNESS``, ``RIM``, or ``TRANSMISSION``, which would tell the light "
"function how the lights respond to that fragment. This makes it possible to "
"control a complex shading pipeline without the user having to write much "
"code. If you don't need this built-in functionality, you can ignore it and "
"write your own light processing function, and Godot will optimize it away. "
"For example, if you do not write a value to ``RIM``, Godot will not "
"calculate rim lighting. During compilation, Godot checks to see if ``RIM`` "
"is used; if not, it cuts all the corresponding code out. Therefore, you will "
"not waste calculations on the effects that you do not use."
msgstr ""
"片段函式的標準用途是設定用於光照計算的材質屬性。例如，你可以設定 "
"``ROUGHNESS``、``RIM`` 或 ``TRANSMISSION`` 的數值，這些設定會告訴光照函式該如"
"何處理這個片段。這讓你能夠有效控制複雜的著色流程，而不必撰寫過多程式碼。如果"
"你不需要這些內建功能，也可以忽略它們並自行撰寫光照處理函式，Godot 會自動優"
"化。舉例來說，如果你沒對 ``RIM`` 賦值，Godot 就不會進行邊緣光的計算。在編譯階"
"段，Godot 會檢查 ``RIM`` 是否有被使用，若沒有，相關程式碼就會被移除。因此，你"
"不會在未使用的特效上浪費任何計算資源。"

msgid "Light processor"
msgstr "光照處理器"

msgid ""
"The ``light()`` processor runs per pixel too, and it runs once for every "
"light that affects the object. It does not run if no lights affect the "
"object. It exists as a function called inside the ``fragment()`` processor "
"and typically operates on the material properties setup inside the "
"``fragment()`` function."
msgstr ""
"``light()`` 處理器同樣會針對每個像素執行，且每盞影響該物件的燈光都會執行一"
"次。若沒有任何燈光影響該物件，則不會執行。該函式會在 ``fragment()`` 處理器中"
"被呼叫，通常用於處理在 ``fragment()`` 函式中設置的材質屬性。"

msgid ""
"The ``light()`` processor works differently in 2D than it does in 3D; for a "
"description of how it works in each, see their "
"documentation, :ref:`CanvasItem shaders <doc_canvas_item_shader>` "
"and :ref:`Spatial shaders <doc_spatial_shader>`, respectively."
msgstr ""
"``light()`` 處理器在 2D 和 3D 的運作方式不同，詳細運作原理請參"
"閱 :ref:`CanvasItem 著色器 <doc_canvas_item_shader>` 及 :ref:`Spatial 著色器 "
"<doc_spatial_shader>` 的說明。"
