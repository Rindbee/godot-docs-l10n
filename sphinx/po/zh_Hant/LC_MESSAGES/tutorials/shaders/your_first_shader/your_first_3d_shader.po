#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "你的第一個 3D 著色器"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你決定開始編寫自己的自訂 Spatial 著色器。或許你在網路上看到了很酷的著色器特"
"效，又或是發現 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 無法完全"
"滿足你的需求。無論原因為何，現在你決定自己動手寫一個，只是不知道該從哪裡開"
"始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"本教學將說明如何編寫 Spatial 著色器，並且涵蓋比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 教學更多的主題。"

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatial 著色器比 CanvasItem 著色器擁有更多內建功能。對 Spatial 著色器來說，"
"Godot 已為常見用例提供了豐富功能，使用者只需要於著色器內設定適當參數即可。這"
"一點在 PBR（基於物理的算繪）工作流程中特別明顯。"

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In "
"the :ref:`second part <doc_your_second_spatial_shader>` we will take the "
"concepts from this tutorial and set up custom materials in a fragment shader "
"by writing an ocean water shader."
msgstr ""
"這是一個分為兩部分的教學。在第一部分中，我們將透過頂點函式中的高度圖來進行頂"
"點位移，製作簡單地形。在 :ref:`第二部分 <doc_your_second_spatial_shader>` "
"中，我們將延伸本教學的概念，在片段著色器中設定自訂材質，並編寫海洋水面著色"
"器。"

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"本教學假設你已具備一些著色器的基礎知識，例如型別（``vec2``、``float``、"
"``sampler2D``）以及函式。如果你對這些概念還不熟悉，建議在完成本教學前，先參"
"考 `《著色器之書》 <https://thebookofshaders.com/?lan=ch>`_ 入門。"

msgid "Where to assign my material"
msgstr "在哪裡設定材質"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a "
"few :ref:`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic "
"geometry to a scene without importing Meshes."
msgstr ""
"在 3D 中，物件是透過 :ref:`Mesh <class_Mesh>` 來繪製的。Mesh 是一種資源，會以"
"「表面（surface）」的單位儲存幾何資訊（物件的形狀）與材質（物件的顏色與受光方"
"式）。一個 Mesh 可以有多個表面，也可以只有一個。一般來說，你會從其他軟體（如 "
"Blender）匯入 Mesh，但 Godot 也有一些 :ref:`PrimitiveMesh "
"<class_primitivemesh>` 可讓你直接在場景中新增基本幾何體而不需匯入。"

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also "
"use :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"你可用多種節點型別來繪製 Mesh，主要是 :ref:`MeshInstance3D "
"<class_MeshInstance3D>`，但你也可以使用 :ref:`GPUParticles3D "
"<class_GPUParticles3D>`、:ref:`MultiMesh <class_MultiMesh>`（搭"
"配 :ref:`MultiMeshInstance3D <class_MultiMeshInstance3D>`）等其他節點。"

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常情況下，材質會與 Mesh 的特定表面綁定，但有些節點（如 MeshInstance3D）允許"
"你覆寫單一表面或所有表面的材質。"

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或 Mesh 本身設定材質，所有共用該 Mesh 的 MeshInstance3D 都會共用"
"同一材質。但若你想讓多個 Mesh 實例共用同一 Mesh，且每個實例有不同材質，就應該"
"直接在 MeshInstance3D 上設定材質。"

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"本教學將直接把材質設定在 Mesh 本身，不使用 MeshInstance3D 的材質覆寫功能。"

msgid "Setting up"
msgstr "設定"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "在場景中新增一個 :ref:`MeshInstance3D <class_MeshInstance3D>` 節點。"

msgid ""
"In the inspector tab, set the MeshInstance3D's **Mesh** property to a "
"new :ref:`PlaneMesh <class_planemesh>` resource, by clicking on ``<empty>`` "
"and choosing **New PlaneMesh**. Then expand the resource by clicking on the "
"image of a plane that appears."
msgstr ""
"於屬性面板中，點擊 MeshInstance3D 的 **Mesh** 屬性右側的 ``<空>`` ，選擇新"
"建 :ref:`PlaneMesh <class_planemesh>`，然後點擊出現的平面圖示以展開該資源。"

msgid "This adds a plane to our scene."
msgstr "這會在場景中新增一個平面。"

msgid ""
"Then, in the viewport, click in the upper left corner on the **Perspective** "
"button. In the menu that appears, select **Display Wireframe**."
msgstr ""
"接著，在視窗左上角點擊 **透視** 按鈕，在跳出的選單中選擇 **顯示線框**。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "這樣你就能看到構成平面的三角形了。"

msgid ""
"Now set **Subdivide Width** and **Subdivide Depth** of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"現在將 :ref:`PlaneMesh <class_planemesh>` 的 **Subdivide Width** 和 "
"**Subdivide Depth** 都設為 ``32``。"

msgid ""
"You can see that there are now many more triangles in "
"the :ref:`MeshInstance3D<class_MeshInstance3D>`. This will give us more "
"vertices to work with and thus allow us to add more detail."
msgstr ""
"你會發現 :ref:`MeshInstance3D <class_MeshInstance3D>` 中出現了更多三角形。這"
"樣我們就有更多頂點可以操作，能增加更多細節。"

msgid ""
":ref:`PrimitiveMeshes <class_primitivemesh>`, like PlaneMesh, only have one "
"surface, so instead of an array of materials there is only one. Set the "
"**Material** to a new ShaderMaterial, then expand the material by clicking "
"on the sphere that appears."
msgstr ""
"像 PlaneMesh 這類 :ref:`PrimitiveMesh <class_primitivemesh>` 只會有一個表面，"
"因此材質也只有一個，不是陣列。將 **Material** 設為新的 ShaderMaterial，然後點"
"擊出現的球體圖示展開材質。"

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
"所有繼承自 :ref:`class_Material` 的材質資源（例"
"如 :ref:`class_StandardMaterial3D`、:ref:`class_ParticleProcessMaterial`），"
"都可以轉換為 :ref:`class_ShaderMaterial`，現有的屬性會轉為對應的文字著色器。"
"要進行轉換，只需在檔案系統面板中右鍵點選該材質並選擇 **轉換成 "
"ShaderMaterial**。你也可以在屬性檢視器中，對任何指向材質的屬性右鍵進行同樣操"
"作。"

msgid ""
"Now set the material's **Shader** to a new Shader by clicking ``<empty>`` "
"and select **New Shader...**. Leave the default settings, give your shader a "
"name, and click **Create**."
msgstr ""
"接下來把材質的 **Shader** 設定為新的 Shader，點擊 ``<空>`` 並選擇 **新建 "
"Shader...**。保留預設設定，輸入著色器名稱後按 **建立**。"

msgid ""
"Click on the shader in the inspector, and the shader editor should now pop "
"up. You are ready to begin writing your first Spatial shader!"
msgstr ""
"在屬性面板點擊該 Shader，著色器編輯器就會彈出。現在你就可以開始編寫你的第一"
"個 Spatial 著色器了！"

msgid "Shader magic"
msgstr "著色器魔法"

msgid ""
"The new shader is already generated with a ``shader_type`` variable, the "
"``vertex()`` function, and the ``fragment()`` function. The first thing "
"Godot shaders need is a declaration of what type of shader they are. In this "
"case the ``shader_type`` is set to ``spatial`` because this is a spatial "
"shader."
msgstr ""
"新建立的著色器已經自動產生了 ``shader_type`` 變數、``vertex()`` 函式及 "
"``fragment()`` 函式。Godot 著色器的第一步就是宣告著色器類型。這裡 "
"``shader_type`` 被設為 ``spatial``，因為這是一個 Spatial 著色器。"

msgid ""
"The ``vertex()`` function determines where the vertices of "
"your :ref:`MeshInstance3D<class_MeshInstance3D>` appear in the final scene. "
"We will be using it to offset the height of each vertex and make our flat "
"plane appear like a little terrain."
msgstr ""
"``vertex()`` 函式決定 :ref:`MeshInstance3D <class_MeshInstance3D>` 各頂點在最"
"終場景中的位置。我們將用它來偏移每個頂點的高度，讓平面看起來像小地形。"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can start to make changes by adding a single line:"
msgstr ""
"如果 ``vertex()`` 函式內沒有任何內容，Godot 會使用預設的頂點著色器。我們可以"
"先加一行做出改變："

msgid "Adding this line, you should get an image like the one below."
msgstr "加上這一行後，你應該會看到如下圖所示的效果。"

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to :ref:`cos() <shader_func_cos>` and :ref:`sin() "
"<shader_func_sin>`; that gives us a wave-like appearance across the ``x`` "
"and ``z`` axes."
msgstr ""
"來解釋一下這行程式碼。這裡我們增加了 ``VERTEX`` 的 ``y`` 值，並把 ``VERTEX`` "
"的 ``x`` 和 ``z`` 組件分別作為 :ref:`cos() <shader_func_cos>` 和 :ref:`sin() "
"<shader_func_sin>` 的參數，這會讓平面在 x 與 z 軸上呈現波浪狀外觀。"

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos()`` "
"and ``sin()`` already look kind of like hills. We do so by scaling the "
"inputs to the ``cos()`` and ``sin()`` functions."
msgstr ""
"我們的目的是讓表面看起來像小山丘；而 ``cos()`` 和 ``sin()`` 的曲線本來就很像"
"丘陵。我們只需縮放傳入 ``cos()`` 與 ``sin()`` 的參數即可調整山丘的形狀。"

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "這樣確實好看多了，但還是太尖銳且重複，讓我們讓它變得更有趣一些。"

msgid "Noise heightmap"
msgstr "雜訊高度圖"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"雜訊是模擬地形外觀時很常用的工具。可以想像它像餘弦函式那樣產生一連串小山，但"
"雜訊可以讓每座山的高度都不同。"

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot 提供 :ref:`NoiseTexture2D <class_noisetexture2D>` 資源，可用來產生雜訊"
"貼圖並供著色器存取。"

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"若要在著色器中存取貼圖，請在著色器檔案頂端、``vertex()`` 函式外面加入以下程式"
"碼。"

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called **Shader "
"Parameters**. If you open it up, you'll see a parameter called \"Noise\"."
msgstr ""
"這樣就能傳送雜訊貼圖給著色器了。現在回到屬性面板，在材質底下你會看到 **著色器"
"參數** 區塊，裡面會有一個名為「Noise」的參數。"

msgid ""
"Set this **Noise** parameter to a new :ref:`NoiseTexture2D "
"<class_noisetexture2D>`. Then in your NoiseTexture2D, set its **Noise** "
"property to a new :ref:`FastNoiseLite <class_fastnoiselite>`. The "
"FastNoiseLite class is used by the NoiseTexture2D to generate a heightmap."
msgstr ""
"將這個 **Noise** 參數設為新的 :ref:`NoiseTexture2D <class_noisetexture2D>`，"
"然後在 NoiseTexture2D 裡，將 **Noise** 屬性設為新的 :ref:`FastNoiseLite "
"<class_fastnoiselite>`。FastNoiseLite 會用來產生高度圖。"

msgid "Once you set it up and should look like this."
msgstr "設定好後，應該會像這樣。"

msgid "Now, access the noise texture using the ``texture()`` function:"
msgstr "接下來透過 ``texture()`` 函式來取用雜訊貼圖："

msgid ""
":ref:`texture() <shader_func_texture>` takes a texture as the first argument "
"and a ``vec2`` for the position on the texture as the second argument. We "
"use the ``x`` and ``z`` channels of ``VERTEX`` to determine where on the "
"texture to look up."
msgstr ""
":ref:`texture() <shader_func_texture>` 的第一個參數是貼圖，第二個參數是 "
"``vec2`` 位置。我們用 ``VERTEX`` 的 ``x`` 與 ``z`` 分量來決定查詢貼圖的座標。"

msgid ""
"Since the PlaneMesh coordinates are within the ``[-1.0, 1.0]`` range (for a "
"size of ``2.0``), while the texture coordinates are within ``[0.0, 1.0]``, "
"to remap the coordinates we divide by the size of the PlaneMesh by ``2.0`` "
"and add ``0.5`` ."
msgstr ""
"由於 PlaneMesh 的座標範圍為 ``[-1.0, 1.0]``（寬度為 2.0），而貼圖座標範圍是 "
"``[0.0, 1.0]``，因此我們要將座標除以 2.0 再加 0.5 來對應貼圖座標。"

msgid ""
"``texture()`` returns a ``vec4`` of the ``r, g, b, a`` channels at the "
"position. Since the noise texture is grayscale, all of the values are the "
"same, so we can use any one of the channels as the height. In this case "
"we'll use the ``r``, or ``x`` channel."
msgstr ""
"``texture()`` 會回傳該位置的 ``r, g, b, a`` 四個分量（vec4）。由於雜訊貼圖是"
"灰階的，四個分量都一樣，因此我們可以任選一個分量代表高度。這裡我們會用 "
"``r``，也就是 ``x`` 分量。"

msgid ""
"``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture().x`` "
"above, we could use ``texture().r``. See the `OpenGL documentation <https://"
"www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more details."
msgstr ""
"``xyzw`` 和 GLSL 裡的 ``rgba`` 是一樣的，所以 ``texture().x`` 也可以寫成 "
"``texture().r``。詳情可參考 `OpenGL 文件 <https://www.khronos.org/opengl/"
"wiki/Data_Type_(GLSL)#Vectors>`_。"

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用這段程式碼後，你會看到貼圖產生了隨機的小山丘。"

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前山丘還太尖銳，我們想讓它更平滑一些。這時可以用 uniform 來調整。你已經用 "
"uniform 傳入了雜訊貼圖，現在就來了解 uniform 的運作方式。"

msgid "Uniforms"
msgstr "Uniform（統一變數）"

msgid ""
":ref:`Uniform variables <doc_shading_language_uniforms>` allow you to pass "
"data from the game into the shader. They are very useful for controlling "
"shader effects. Uniforms can be almost any datatype that can be used in the "
"shader. To use a uniform, you declare it in your :ref:`Shader<class_Shader>` "
"using the keyword ``uniform``."
msgstr ""
":ref:`Uniform 變數 <doc_shading_language_uniforms>` 讓你可以從遊戲傳遞資料進"
"入著色器，這對於控制著色器效果非常實用。Uniform 幾乎可以是著色器內任何資料型"
"別。要宣告 uniform，只需在 :ref:`Shader <class_Shader>` 中用 ``uniform`` 關鍵"
"字即可。"

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "我們來寫一個可以調整地形高度的 uniform。"

msgid ""
"Godot lets you initialize a uniform with a value; here, ``height_scale`` is "
"set to ``0.5``. You can set uniforms from GDScript by calling the "
"function :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` on the material "
"corresponding to the shader. The value passed from GDScript takes precedence "
"over the value used to initialize it in the shader."
msgstr ""
"Godot 允許你在宣告 uniform 時給初始值；這裡 ``height_scale`` 設為 ``0.5``。你"
"也可以在 GDScript 裡透過 :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` 函式於對應材質上設定 "
"uniform，這樣從 GDScript 設定的值就會覆蓋著色器內的初始值。"

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"在基於 Spatial 的節點上更改 uniform 的方式與 CanvasItem 型節點不同。本例是在 "
"PlaneMesh 資源裡設定材質，其他 Mesh 資源你可能要先呼叫 "
"``surface_get_material()`` 取得材質，而在 MeshInstance3D 則用 "
"``get_surface_material()`` 或 ``material_override``。"

msgid ""
"Remember that the string passed into ``set_shader_parameter()`` must match "
"the name of the uniform variable in the shader. You can use the uniform "
"variable anywhere inside your shader. Here, we will use it to set the height "
"value instead of arbitrarily multiplying by ``0.5``."
msgstr ""
"請記得，傳給 ``set_shader_parameter()`` 的字串必須與著色器內的 uniform 名稱完"
"全一致。uniform 變數可以在著色器內任何地方使用。這裡我們就用它來設定高度值，"
"不再直接乘 ``0.5``。"

msgid "Now it looks much better."
msgstr "現在看起來好多了。"

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"透過 uniform，我們甚至可以每個影格都改變數值，讓地形高度產生動畫。結"
"合 :ref:`Tween <class_Tween>`，這對動畫特效特別實用。"

msgid "Interacting with light"
msgstr "與光源互動"

msgid ""
"First, turn wireframe off. To do so, open the **Perspective** menu in the "
"upper-left of the viewport again, and select **Display Normal**. "
"Additionally in the 3D scene toolbar, turn off preview sunlight."
msgstr ""
"首先，關閉線框顯示。再次點擊視窗左上角的 **透視**，選擇 **顯示標準**。另外，"
"也可以在 3D 場景工具列中關閉預覽太陽光。"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"你會發現網格顏色變得很平坦。這是因為光照也很平坦，讓我們加盞燈來看看效果！"

msgid ""
"First, we will add an :ref:`OmniLight3D<class_OmniLight3D>` to the scene, "
"and drag it up so it is above the terrain."
msgstr ""
"首先，在場景中新增一個 :ref:`OmniLight3D <class_OmniLight3D>`，並將它拖到地形"
"上方。"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你會看到燈光確實影響地形，但看起來很奇怪，因為光線還是照著平面來計算。這是因"
"為光照計算時用的是 :ref:`Mesh <class_mesh>` 裡的法線。"

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法線原本儲存在 Mesh 內，但我們在著色器裡改變了 Mesh 形狀，導致法線已經不正"
"確。要修正這問題，可以在著色器內重算法線，或是使用和雜訊對應的法線貼圖。"
"Godot 都能輕鬆做到這兩種方法。"

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"你可以在頂點函式內手動計算出新的法線，然後設定給 ``NORMAL``。有了 "
"``NORMAL``，Godot 會自動幫你完成所有複雜的光照計算。這個方法會在教學下一部分"
"詳細介紹，這裡我們先用貼圖的方式獲取法線。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"我們這邊會繼續利用 NoiseTexture 來幫我們產生法線。只要再傳入第二個雜訊貼圖即"
"可。"

msgid ""
"Set this second uniform texture to another :ref:`NoiseTexture2D "
"<class_noisetexture2D>` with another :ref:`FastNoiseLite "
"<class_fastnoiselite>`. But this time, check **As Normal Map**."
msgstr ""
"將第二個 uniform 紋理設為另一個新的 :ref:`NoiseTexture2D "
"<class_noisetexture2D>`，內部也指向一個新的 :ref:`FastNoiseLite "
"<class_fastnoiselite>` ，但這次要勾選 **作為法線圖** （As Normal Map）。"

msgid ""
"When we have normals that correspond to a specific vertex we set ``NORMAL``, "
"but if you have a normalmap that comes from a texture, set the normal using "
"``NORMAL_MAP`` in the ``fragment()`` function. This way Godot will handle "
"wrapping the texture around the mesh automatically."
msgstr ""
"如果有對應特定頂點的法線，可以直接設定 ``NORMAL``，但若是來自紋理的法線貼圖，"
"請在 ``fragment()`` 函式內設定 ``NORMAL_MAP``。如此一來，Godot 會自動處理法線"
"貼圖的包覆。"

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the "
"``VERTEX.xz`` position from the ``vertex()`` function to the ``fragment()`` "
"function. We do that using a :ref:`varying <doc_shading_language_varyings>`."
msgstr ""
"最後，為確保我們從雜訊貼圖與法線貼圖的同一位置讀取資料，我們會把 "
"``VERTEX.xz`` 從 ``vertex()`` 函式傳入 ``fragment()``。這可以"
"用 :ref:`varying <doc_shading_language_varyings>` 來做到。"

msgid ""
"Above the ``vertex()`` define a ``varying vec2`` called ``tex_position``. "
"And inside the ``vertex()`` function assign ``VERTEX.xz`` to "
"``tex_position``."
msgstr ""
"在 ``vertex()`` 之上定義一個名為 ``tex_position`` 的 ``varying vec2``，在 "
"``vertex()`` 函式內將 ``VERTEX.xz`` 賦值給 ``tex_position``。"

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "現在我們就能在 ``fragment()`` 函式中存取 ``tex_position`` 了。"

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "這樣一來，法線正確，燈光就會根據網格高度動態反應。"

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "你可以直接拖曳光源，燈光效果會自動即時更新。"

msgid "Full code"
msgstr "完整程式碼"

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教學的完整程式碼。可以看到，因為 Godot 幫你處理了大部分繁瑣細節，程式"
"碼其實很簡潔。"

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"這就是這一部分的全部內容。希望你現在已大致了解 Godot 中頂點著色器的基本用法。"
"在教學的下一部分，我們將編寫與這個頂點函式配合的片段函式，並介紹更進階的技"
"巧，將這片地形變成有動態波浪的海洋。"
