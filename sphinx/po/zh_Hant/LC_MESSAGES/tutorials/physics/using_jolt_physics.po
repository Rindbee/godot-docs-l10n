#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Jolt Physics"
msgstr "使用 Jolt 物理引擎"

msgid "Introduction"
msgstr "前言"

msgid ""
"The Jolt physics engine was added as an alternative to the existing Godot "
"Physics physics engine in 4.4. Jolt is developed by Jorrit Rouwe with a "
"focus on games and VR applications. Previously it was available as an "
"extension but is now built into Godot."
msgstr ""
"在 4.4 中，Jolt 物理引擎被加入作為現有 Godot Physics 物理引擎的替代方案。"
"Jolt 由 Jorrit Rouwe 開發，重點面向遊戲與 VR 應用。它先前以擴充功能提供，如今"
"已內建於 Godot。"

msgid ""
"It is important to note that the built-in Jolt Physics module is considered "
"**not finished**, **experimental**, and **lacks feature parity** with both "
"Godot Physics and the Godot Jolt extension. Behavior may change as it is "
"developed further. Please keep that in mind when choosing what to use for "
"your project."
msgstr ""
"需要特別注意的是，內建的 Jolt 物理模組目前被視為 **尚未完成**、**實驗性**，且"
"與 Godot Physics 與 Godot Jolt 擴充功能相比 **尚未達到功能一致**。其行為在持"
"續開發中可能改變。選擇要在專案中使用何者時，請將此納入考量。"

msgid ""
"The existing extension is now considered in maintenance mode. That means bug "
"fixes will be merged, and it will be kept compatible with new versions of "
"Godot until the built-in module has feature parity with the extension. The "
"extension can be found `here on GitHub <https://github.com/godot-jolt/godot-"
"jolt>`_ and in Godot's asset library."
msgstr ""
"現有的擴充功能目前處於維護模式。也就是說，錯誤修正仍會合併，並會維持與新版 "
"Godot 的相容性，直到內建模組達到與該擴充功能功能一致為止。你可在 `GitHub 上這"
"裡 <https://github.com/godot-jolt/godot-jolt>`_ 與 Godot 的素材庫中找到該擴充"
"功能。"

msgid ""
"To change the 3D physics engine to be Jolt Physics, set :ref:`Project "
"Settings > Physics > 3D > Physics "
"Engine<class_ProjectSettings_property_physics/3D/Physics_Engine>` to ``Jolt "
"Physics``. Once you've done that, click the **Save & Restart** button. When "
"the editor opens again, 3D scenes should now be using Jolt for physics."
msgstr ""
"若要將 3D 物理引擎切換為 Jolt Physics，請將 :ref:`Project Settings > Physics "
"> 3D > Physics Engine<class_ProjectSettings_property_physics/3D/"
"Physics_Engine>` 設為 ``Jolt Physics``。完成後點擊 **Save & Restart** 按鈕。"
"編輯器重新開啟後，3D 場景就會改用 Jolt 進行物理模擬。"

msgid "Notable differences to Godot Physics"
msgstr "與 Godot Physics 的顯著差異"

msgid ""
"There are many differences between the existing Godot Physics engine and "
"Jolt."
msgstr "現有的 Godot Physics 引擎與 Jolt 之間有許多差異。"

msgid "Joint properties"
msgstr "關節屬性"

msgid ""
"The current interfaces for the 3D joint nodes don't quite line up with the "
"interface of Jolt's own joints. As such, there are a number of joint "
"properties that are not supported, mainly ones related to configuring the "
"joint's soft limits."
msgstr ""
"目前 3D 關節節點的介面與 Jolt 自身關節的介面並不完全一致。因此有一些關節屬性"
"尚未支援，主要是與關節「軟限制」設定相關的屬性。"

msgid "The unsupported properties are:"
msgstr "未支援的屬性如下："

msgid "PinJoint3D: ``bias``, ``damping``, ``impulse_clamp``"
msgstr "PinJoint3D：``bias``、``damping``、``impulse_clamp``"

msgid "HingeJoint3D: ``bias``, ``softness``, ``relaxation``"
msgstr "HingeJoint3D：``bias``、``softness``、``relaxation``"

msgid ""
"SliderJoint3D: ``angular_\\*``, ``\\*_limit/softness``, ``\\*_limit/"
"restitution``, ``\\*_limit/damping``"
msgstr ""
"SliderJoint3D：``angular_\\*``、``\\*_limit/softness``、``\\*_limit/"
"restitution``、``\\*_limit/damping``"

msgid "ConeTwistJoint3D: ``bias``, ``relaxation``, ``softness``"
msgstr "ConeTwistJoint3D：``bias``、``relaxation``、``softness``"

msgid ""
"Generic6DOFJoint3D: ``*_limit_*/softness``, ``*_limit_*/restitution``, "
"``*_limit_*/damping``, ``*_limit_*/erp``"
msgstr ""
"Generic6DOFJoint3D：``*_limit_*/softness``、``*_limit_*/restitution``、"
"``*_limit_*/damping``、``*_limit_*/erp``"

msgid ""
"Currently a warning is emitted if you set these properties to anything but "
"their default values."
msgstr "目前若將上述屬性設定為非預設值，會顯示警告。"

msgid "Single-body joints"
msgstr "單一剛體關節"

msgid ""
"You can, in Godot, omit one of the joint bodies for a two-body joint and "
"effectively have \"the world\" be the other body. However, the node path "
"that you assign your body to (:ref:`node_a<class_Joint3D_property_node_a>` "
"vs :ref:`node_b<class_Joint3D_property_node_b>`) is ignored. Godot Physics "
"will always behave as if you assigned it to ``node_a``, and since ``node_a`` "
"is also what defines the frame of reference for the joint limits, you end up "
"with inverted limits and a potentially strange limit shape, especially if "
"your limits allow both linear and angular degrees of freedom."
msgstr ""
"在 Godot 中，你可以在雙剛體關節中省略其中一個剛體，讓「世界」充當另一個剛體。"
"然而，你為剛體指定的節點路徑（:ref:`node_a<class_Joint3D_property_node_a>` "
"與 :ref:`node_b<class_Joint3D_property_node_b>`）會被忽略。Godot Physics 總是"
"會把它視為指定到 ``node_a``。由於 ``node_a`` 也用來定義關節限制的參考座標，你"
"最終會得到反向的限制，甚至可能出現奇怪的限制形狀，特別是在你的限制同時允許線"
"性與角度自由度時。"

msgid ""
"Jolt will behave as if you assigned the body to ``node_b`` instead, with "
"``node_a`` representing \"the world\". There is a project setting "
"called :ref:`Physics > Jolt Physics 3D > Joints > World "
"Node<class_ProjectSettings_property_physics/jolt_physics_3d/joints/"
"world_node>` that lets you toggle this behavior, if you need compatibility "
"for an existing project."
msgstr ""
"Jolt 則會把你的剛體視為指定到 ``node_b``，並以 ``node_a`` 表示「世界」。如果"
"你需要與既有專案相容，可以透過專案設定 :ref:`Physics > Jolt Physics 3D > "
"Joints > World Node<class_ProjectSettings_property_physics/jolt_physics_3d/"
"joints/world_node>` 來切換此行為。"

msgid "Collision margins"
msgstr "碰撞邊距"

msgid ""
"Jolt (and other similar physics engines) uses something that Jolt refers to "
"as \"convex radius\" to help improve the performance and behavior of the "
"types of collision detection that Jolt relies on for convex shapes. Other "
"physics engines (Godot included) might refer to these as \"collision "
"margins\" instead. Godot exposes these as the ``margin`` property on every "
"Shape3D-derived class, but Godot Physics itself does not use them for "
"anything."
msgstr ""
"Jolt（以及其它類似的物理引擎）使用一種 Jolt 稱為「convex radius」的概念，來改"
"善凸形狀所仰賴的碰撞偵測效能與行為。其他物理引擎（包含 Godot）可能會將其稱為"
"「collision margins（碰撞邊距）」。Godot 在所有繼承自 Shape3D 的類別上以 "
"``margin`` 屬性公開這個值，但 Godot Physics 本身並不使用它。"

msgid ""
"What these collision margins sometimes do in other engines (as described in "
"Godot's documentation) is effectively add a \"shell\" around the shape, "
"slightly increasing its size while also rounding off any edges/corners. In "
"Jolt however, these margins are first used to shrink the shape, and then the "
"\"shell\" is applied, resulting in edges/corners being similarly rounded "
"off, but without increasing the size of the shape."
msgstr ""
"在其他引擎中（如 Godot 文件所述），碰撞邊距有時等同於在形狀外加上一層「殼」，"
"稍微放大形狀並使邊角變得圓滑。然而在 Jolt 中，會先用該邊距縮小形狀，之後再套"
"用「殼」，同樣能讓邊角圓滑，但不會增加形狀的實際尺寸。"

msgid ""
"To prevent having to tweak this margin property manually, since its default "
"value can be problematic for smaller shapes, the Jolt module exposes a "
"project setting called :ref:`Physics > Jolt Physics 3D > Collisions > "
"Collision Margin Fraction<class_ProjectSettings_property_physics/"
"jolt_physics_3d/collisions/collision_margin_fraction>` which is multiplied "
"with the smallest axis of the shape's AABB to calculate the actual margin. "
"The margin property of the shape is then instead used as an upper bound."
msgstr ""
"由於預設邊距對較小的形狀可能造成問題, 為了避免需要手動調整, Jolt 模組提供了專"
"案設定 :ref:`Physics > Jolt Physics 3D > Collisions > Collision Margin "
"Fraction<class_ProjectSettings_property_physics/jolt_physics_3d/collisions/"
"collision_margin_fraction>` , 其會與該形狀 AABB 的最小軸長相乘來計算實際邊"
"距; 而形狀本身的邊距屬性則改作為上限值。"

msgid ""
"These margins should, for most use-cases, be more or less transparent, but "
"can sometimes result in odd collision normals when performing shape queries. "
"You can lower the above mentioned project setting to mitigate some of this, "
"including setting it to ``0.0``, but too small of a margin can also cause "
"odd collision results, so is generally not recommended."
msgstr ""
"在多數情況下，這些邊距應該幾乎是透明無感的，但在進行形狀查詢時，偶爾可能導致"
"奇怪的碰撞法線。你可以降低上述專案設定來緩解（包含設為 ``0.0``），但邊距太小"
"也可能造成異常的碰撞結果，因此通常不建議。"

msgid "Baumgarte stabilization"
msgstr "Baumgarte 穩定化"

msgid ""
"Baumgarte stabilization is a method to resolve penetrating bodies and push "
"them to a state where they are just touching. In Godot Physics this works "
"like a spring. This means that bodies can accelerate and may cause the "
"bodies to overshoot and separate completely. With Jolt, the stabilization is "
"only applied to the position and not to the velocity of the body. This means "
"it cannot overshoot but it may take longer to resolve the penetration."
msgstr ""
"Baumgarte 穩定化是一種處理相互穿透的剛體並將它們推回到恰好接觸狀態的方法。在 "
"Godot Physics 中，它的行為類似彈簧，意味著剛體可能產生加速並造成超調，甚至完"
"全分離。在 Jolt 中，穩定化僅應用於位置而非速度，這表示不會超調，但解除穿透可"
"能需要更長時間。"

msgid ""
"The strength of this stabilization can be tweaked using the project "
"setting :ref:`Physics > Jolt Physics 3D > Simulation > Baumgarte "
"Stabilization Factor<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/baumgarte_stabilization_factor>`. Setting this project setting to "
"``0.0`` will turn Baumgarte stabilization off. Setting it to ``1.0`` will "
"resolve penetration in 1 simulation step. This is fast but often also "
"unstable."
msgstr ""
"可以透過專案設定 :ref:`Physics > Jolt Physics 3D > Simulation > Baumgarte "
"Stabilization Factor<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/baumgarte_stabilization_factor>` 來調整此穩定化的強度。將其設為 "
"``0.0`` 會關閉 Baumgarte 穩定化；設為 ``1.0`` 則會在 1 個模擬步驟內解決穿透，"
"速度很快但通常不太穩定。"

msgid "Ghost collisions"
msgstr "幽靈碰撞"

msgid ""
"Jolt employs two techniques to mitigate ghost collisions, meaning collisions "
"with internal edges of shapes/bodies that result in collision normals that "
"oppose the direction of movement."
msgstr ""
"Jolt 採用兩種技術來減輕幽靈碰撞，也就是與形狀／剛體內部邊緣發生的碰撞，導致碰"
"撞法線方向與移動方向相反的情況。"

msgid ""
"The first technique, called \"active edge detection\", marks edges of "
"triangles in :ref:`class_ConcavePolygonShape3D` "
"or :ref:`class_HeightMapShape3D` as either \"active\" or \"inactive\", based "
"on the angle to the neighboring triangle. When a collision happens with an "
"inactive edge the collision normal will be replaced with the triangle's "
"normal instead, to lessen the effect of ghost collisions."
msgstr ""
"第一種技術稱為「主動邊緣偵測（active edge detection）」，會依照與鄰近三角形的"
"夾角，將 :ref:`class_ConcavePolygonShape3D` 或 :ref:`class_HeightMapShape3D` "
"中三角形的邊標記為「啟用」或「停用」。當碰撞發生在停用的邊上時，會以該三角形"
"的法線取代碰撞法線，以降低幽靈碰撞的影響。"

msgid ""
"The angle threshold for this active edge detection is configurable through "
"the project setting :ref:`Physics >Jolt Physics 3D > Collisions > Active "
"Edge Threshold<class_ProjectSettings_property_physics/jolt_physics_3d/"
"collisions/active_edge_threshold>`."
msgstr ""
"此主動邊緣偵測的角度門檻可透過專案設定 :ref:`Physics > Jolt Physics 3D > "
"Collisions > Active Edge Threshold<class_ProjectSettings_property_physics/"
"jolt_physics_3d/collisions/active_edge_threshold>` 進行設定。"

msgid ""
"The second technique, called \"enhanced internal edge removal\", instead "
"adds runtime checks to detect whether an edge is active or inactive, based "
"on the contact points of the two bodies. This has the benefit of applying "
"not only to collisions with :ref:`class_ConcavePolygonShape3D` "
"and :ref:`class_HeightMapShape3D`, but also edges between any shapes within "
"the same body."
msgstr ""
"第二種技術稱為「增強型內部邊緣移除（enhanced internal edge removal）」，會在"
"執行階段根據兩個剛體的接觸點來檢測邊是否為啟用或停用。此方法的好處是，不僅適"
"用於與 :ref:`class_ConcavePolygonShape3D` 與 :ref:`class_HeightMapShape3D` 的"
"碰撞，也適用於同一剛體內任意形狀之間的邊。"

msgid ""
"Enhanced internal edge removal can be toggled on and off for the various "
"contexts to which it's applied, using the :ref:`Physics >Jolt Physics 3D > "
"Simulation > Use Enhanced Internal Edge "
"Removal<class_ProjectSettings_property_physics/jolt_physics_3d/simulation/"
"use_enhanced_internal_edge_removal>`, project setting, and the similar "
"settings for :ref:`queries<class_ProjectSettings_property_physics/"
"jolt_physics_3d/queries/use_enhanced_internal_edge_removal>` "
"and :ref:`motion queries<class_ProjectSettings_property_physics/"
"jolt_physics_3d/motion_queries/use_enhanced_internal_edge_removal>`."
msgstr ""
"可透過專案設定 :ref:`Physics > Jolt Physics 3D > Simulation > Use Enhanced "
"Internal Edge Removal<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/use_enhanced_internal_edge_removal>` 來在各適用情境中啟用或停用"
"「增強型內部邊緣移除」，以及針"
"對 :ref:`queries<class_ProjectSettings_property_physics/jolt_physics_3d/"
"queries/use_enhanced_internal_edge_removal>` 與 :ref:`motion "
"queries<class_ProjectSettings_property_physics/jolt_physics_3d/"
"motion_queries/use_enhanced_internal_edge_removal>` 的類似設定。"

msgid ""
"Note that neither the active edge detection nor enhanced internal edge "
"removal apply when dealing with ghost collisions between two different "
"bodies."
msgstr ""
"請注意，當涉及兩個不同剛體之間的幽靈碰撞時，無論是主動邊緣偵測或增強型內部邊"
"緣移除都不會套用。"

msgid "Memory usage"
msgstr "記憶體用量"

msgid ""
"Jolt uses a stack allocator for temporary allocations within its simulation "
"step. This stack allocator requires allocating a set amount of memory up "
"front, which can be configured using the :ref:`Physics > Jolt Physics 3D > "
"Limits > Temporary Memory Buffer Size<class_ProjectSettings_property_physics/"
"jolt_physics_3d/limits/temporary_memory_buffer_size>` project setting."
msgstr ""
"Jolt 在模擬步驟中對暫時分配使用堆疊配置器。此堆疊配置器需要預先配置一定量的記"
"憶體，並可透過專案設定 :ref:`Physics > Jolt Physics 3D > Limits > Temporary "
"Memory Buffer Size<class_ProjectSettings_property_physics/jolt_physics_3d/"
"limits/temporary_memory_buffer_size>` 來調整。"

msgid "Ray-cast face index"
msgstr "Ray Cast 面索引"

msgid ""
"The ``face_index`` property returned in the results "
"of :ref:`intersect_ray()<class_PhysicsDirectSpaceState3D_method_intersect_ray>` "
"and RayCast3D will by default always be ``-1`` with Jolt. The project "
"setting :ref:`Physics > Jolt Physics 3D > Queries > Enable Ray Cast Face "
"Index<class_ProjectSettings_property_physics/jolt_physics_3d/queries/"
"enable_ray_cast_face_index>` will enable them."
msgstr ""
"在 Jolt "
"中，:ref:`intersect_ray()<class_PhysicsDirectSpaceState3D_method_intersect_ray>` "
"與 RayCast3D 的結果所回傳的 ``face_index`` 屬性，預設一律為 ``-1``。可透過專"
"案設定 :ref:`Physics > Jolt Physics 3D > Queries > Enable Ray Cast Face "
"Index<class_ProjectSettings_property_physics/jolt_physics_3d/queries/"
"enable_ray_cast_face_index>` 啟用。"

msgid ""
"Note that enabling this setting will increase the memory requirement "
"of :ref:`class_ConcavePolygonShape3D` with about 25%."
msgstr ""
"請注意，啟用此設定會使 :ref:`class_ConcavePolygonShape3D` 的記憶體需求增加約 "
"25%。"

msgid "Kinematic RigidBody3D contacts"
msgstr "運動式 RigidBody3D 的接觸"

msgid ""
"When using Jolt, a :ref:`class_RigidBody3D` frozen "
"with :ref:`FREEZE_MODE_KINEMATIC<class_RigidBody3D_constant_FREEZE_MODE_KINEMATIC>` "
"will by default not report contacts from collisions with other static/"
"kinematic bodies, for performance reasons, even when setting a non-"
"zero :ref:`max_contacts_reported<class_RigidBody3D_property_max_contacts_reported>`. "
"If you have many/large kinematic bodies overlapping with complex static "
"geometry, such as :ref:`class_ConcavePolygonShape3D` "
"or :ref:`class_HeightMapShape3D`, you can end up wasting a significant "
"amount of CPU performance and memory without realizing it."
msgstr ""
"使用 Jolt 時，若 :ref:`class_RigidBody3D` "
"以 :ref:`FREEZE_MODE_KINEMATIC<class_RigidBody3D_constant_FREEZE_MODE_KINEMATIC>` "
"冷凍，基於效能考量，預設不會回報與其他靜態／運動剛體的碰撞接觸，即使"
"將 :ref:`max_contacts_reported<class_RigidBody3D_property_max_contacts_reported>` "
"設為非零亦同。若你有許多／大面積的運動剛體與複雜的靜態幾何"
"（如 :ref:`class_ConcavePolygonShape3D` 或 :ref:`class_HeightMapShape3D`）重"
"疊，可能在不自覺中浪費大量 CPU 效能與記憶體。"

msgid ""
"For this reason this behavior is opt-in through the project "
"setting :ref:`Physics > Jolt Physics 3D > Simulation > Generate All "
"Kinematic Contacts<class_ProjectSettings_property_physics/jolt_physics_3d/"
"simulation/generate_all_kinematic_contacts>`."
msgstr ""
"因此，是否採用此行為需透過專案設定 :ref:`Physics > Jolt Physics 3D > "
"Simulation > Generate All Kinematic "
"Contacts<class_ProjectSettings_property_physics/jolt_physics_3d/simulation/"
"generate_all_kinematic_contacts>` 主動開啟。"

msgid "Contact impulses"
msgstr "接觸衝量"

msgid ""
"Due to limitations internal to Jolt, the contact impulses provided "
"by :ref:`PhysicsDirectBodyState3D.get_contact_impulse()<class_physicsdirectbodystate3d_method_get_contact_impulse>` "
"are estimated ahead of time based on things like the contact manifold and "
"velocities of the colliding bodies. This means that the reported impulses "
"will only be accurate in cases where the two bodies in question are not "
"colliding with any other bodies."
msgstr ""
"由於 Jolt 的內部限"
"制，:ref:`PhysicsDirectBodyState3D.get_contact_impulse()<class_physicsdirectbodystate3d_method_get_contact_impulse>` "
"所提供的接觸衝量是預先估算的，根據接觸流形以及碰撞剛體的速度等資訊推得。這表"
"示僅在所涉兩個剛體沒有與其他剛體碰撞時，回報的衝量才會精確。"

msgid "Area3D and SoftBody3D"
msgstr "Area3D 與 SoftBody3D"

msgid ""
"Jolt does not currently support any interactions "
"between :ref:`class_SoftBody3D` and :ref:`class_Area3D`, such as overlap "
"events, or the wind properties found on :ref:`class_Area3D`."
msgstr ""
"Jolt 目前不支援 :ref:`class_SoftBody3D` 與 :ref:`class_Area3D` 之間的任何互"
"動，例如重疊事件，或 :ref:`class_Area3D` 上的風場屬性。"

msgid "WorldBoundaryShape3D"
msgstr "WorldBoundaryShape3D"

msgid ""
":ref:`class_WorldBoundaryShape3D`, which is meant to represent an infinite "
"plane, is implemented a bit differently in Jolt compared to Godot Physics. "
"Both engines have an upper limit for how big the effective size of this "
"plane can be, but this size is much smaller when using Jolt, in order to "
"avoid precision issues."
msgstr ""
"用來表示無限平面的 :ref:`class_WorldBoundaryShape3D` 在 Jolt 與 Godot "
"Physics 中的實作略有不同。兩者皆對此平面的有效尺寸有上限，但為避免精度問題，"
"Jolt 下的上限要小得多。"

msgid ""
"You can configure this size using the :ref:`Physics > Jolt Physics 3D > "
"Limits > World Boundary Shape Size<class_ProjectSettings_Property_physics/"
"jolt_physics_3d/limits/world_boundary_shape_size>` project setting."
msgstr ""
"你可以透過專案設定 :ref:`Physics > Jolt Physics 3D > Limits > World Boundary "
"Shape Size<class_ProjectSettings_Property_physics/jolt_physics_3d/limits/"
"world_boundary_shape_size>` 來調整此尺寸。"

msgid "Notable differences to the Godot Jolt extension"
msgstr "與 Godot Jolt 擴充功能的顯著差異"

msgid ""
"While the built-in Jolt module is largely a straight port of the Godot Jolt "
"extension, there are a few things that are different."
msgstr ""
"雖然內建的 Jolt 模組在很大程度上是對 Godot Jolt 擴充功能的直接移植，但仍有一"
"些差異。"

msgid "Project settings"
msgstr "專案設定"

msgid ""
"All project settings have been moved from the ``physics/jolt_3d`` category "
"to ``physics/jolt_physics_3d``."
msgstr ""
"所有專案設定皆已從 ``physics/jolt_3d`` 類別移至 ``physics/jolt_physics_3d``。"

msgid ""
"On top of that, there's been some renaming and refactoring of the individual "
"project settings as well. These include:"
msgstr "此外，個別的專案設定也進行了一些重新命名與重構，包括："

msgid "``sleep/enabled`` is now ``simulation/allow_sleep.``"
msgstr "``sleep/enabled`` 現為 ``simulation/allow_sleep.``"

msgid ""
"``sleep/velocity_threshold`` is now ``simulation/sleep_velocity_threshold.``"
msgstr ""
"``sleep/velocity_threshold`` 現為 ``simulation/sleep_velocity_threshold.``"

msgid "``sleep/time_threshold`` is now ``simulation/sleep_time_threshold.``"
msgstr "``sleep/time_threshold`` 現為 ``simulation/sleep_time_threshold.``"

msgid ""
"``collisions/use_shape_margins`` is now ``collisions/"
"collision_margin_fraction``, where a value of 0 is equivalent to disabling "
"it."
msgstr ""
"``collisions/use_shape_margins`` 現為 ``collisions/"
"collision_margin_fraction``，其中值為 0 等同於停用。"

msgid ""
"``collisions/use_enhanced_internal_edge_removal`` is now ``simulation/"
"use_enhanced_internal_edge_removal.``"
msgstr ""
"``collisions/use_enhanced_internal_edge_removal`` 現為 ``simulation/"
"use_enhanced_internal_edge_removal.``"

msgid ""
"``collisions/areas_detect_static_bodies`` is now ``simulation/"
"areas_detect_static_bodies.``"
msgstr ""
"``collisions/areas_detect_static_bodies`` 現為 ``simulation/"
"areas_detect_static_bodies.``"

msgid ""
"``collisions/report_all_kinematic_contacts`` is now ``simulation/"
"generate_all_kinematic_contacts.``"
msgstr ""
"``collisions/report_all_kinematic_contacts`` 現為 ``simulation/"
"generate_all_kinematic_contacts.``"

msgid ""
"``collisions/soft_body_point_margin`` is now ``simulation/"
"soft_body_point_radius.``"
msgstr ""
"``collisions/soft_body_point_margin`` 現為 ``simulation/"
"soft_body_point_radius.``"

msgid ""
"``collisions/body_pair_cache_enabled is now simulation/"
"body_pair_contact_cache_enabled.``"
msgstr ""
"``collisions/body_pair_cache_enabled 現為 simulation/"
"body_pair_contact_cache_enabled.``"

msgid ""
"``collisions/body_pair_cache_distance_threshold`` is ``now simulation/"
"body_pair_contact_cache_distance_threshold.``"
msgstr ""
"``collisions/body_pair_cache_distance_threshold`` 現為 ``simulation/"
"body_pair_contact_cache_distance_threshold.``"

msgid ""
"``collisions/body_pair_cache_angle_threshold is now simulation/"
"body_pair_contact_cache_angle_threshold.``"
msgstr ""
"``collisions/body_pair_cache_angle_threshold 現為 simulation/"
"body_pair_contact_cache_angle_threshold.``"

msgid ""
"``continuous_cd/movement_threshold`` is now ``simulation/"
"continuous_cd_movement_threshold``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``continuous_cd/movement_threshold`` 現為 ``simulation/"
"continuous_cd_movement_threshold``，但以小數（fraction）而非百分比表達。"

msgid ""
"``continuous_cd/max_penetration`` is now ``simulation/"
"continuous_cd_max_penetration``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``continuous_cd/max_penetration`` 現為 ``simulation/"
"continuous_cd_max_penetration``，但以小數（fraction）而非百分比表達。"

msgid ""
"``kinematics/use_enhanced_internal_edge_removal`` is now ``motion_queries/"
"use_enhanced_internal_edge_removal.``"
msgstr ""
"``kinematics/use_enhanced_internal_edge_removal`` 現為 ``motion_queries/"
"use_enhanced_internal_edge_removal.``"

msgid ""
"``kinematics/recovery_iterations`` is now ``motion_queries/"
"recovery_iterations``, but expressed as a fraction instead of a percentage."
msgstr ""
"``kinematics/recovery_iterations`` 現為 ``motion_queries/"
"recovery_iterations``，但以小數（fraction）而非百分比表達。"

msgid ""
"``kinematics/recovery_amount`` is now ``motion_queries/recovery_amount.``"
msgstr ""
"``kinematics/recovery_amount`` 現為 ``motion_queries/recovery_amount.``"

msgid "``queries/use_legacy_ray_casting`` has been removed."
msgstr "``queries/use_legacy_ray_casting`` 已被移除。"

msgid "``solver/position_iterations`` is now ``simulation/position_steps.``"
msgstr "``solver/position_iterations`` 現為 ``simulation/position_steps.``"

msgid "``solver/velocity_iterations`` is now ``simulation/velocity_steps.``"
msgstr "``solver/velocity_iterations`` 現為 ``simulation/velocity_steps.``"

msgid ""
"``solver/position_correction`` is now ``simulation/"
"baumgarte_stabilization_factor``, but expressed as a fraction instead of a "
"percentage."
msgstr ""
"``solver/position_correction`` 現為 ``simulation/"
"baumgarte_stabilization_factor``，但以小數（fraction）而非百分比表達。"

msgid ""
"``solver/active_edge_threshold`` is now ``collisions/active_edge_threshold.``"
msgstr ""
"``solver/active_edge_threshold`` 現為 ``collisions/active_edge_threshold.``"

msgid ""
"``solver/bounce_velocity_threshold`` is now ``simulation/"
"bounce_velocity_threshold.``"
msgstr ""
"``solver/bounce_velocity_threshold`` 現為 ``simulation/"
"bounce_velocity_threshold.``"

msgid ""
"``solver/contact_speculative_distance`` is now ``simulation/"
"speculative_contact_distance.``"
msgstr ""
"``solver/contact_speculative_distance`` 現為 ``simulation/"
"speculative_contact_distance.``"

msgid ""
"``solver/contact_allowed_penetration`` is now ``simulation/"
"penetration_slop.``"
msgstr ""
"``solver/contact_allowed_penetration`` 現為 ``simulation/penetration_slop.``"

msgid "``limits/max_angular_velocity`` is now stored as radians instead."
msgstr "``limits/max_angular_velocity`` 現改以弧度儲存。"

msgid ""
"``limits/max_temporary_memory`` is now ``limits/"
"temporary_memory_buffer_size.``"
msgstr ""
"``limits/max_temporary_memory`` 現為 ``limits/temporary_memory_buffer_size.``"

msgid "Joint nodes"
msgstr "關節節點"

msgid ""
"The joint nodes that are exposed in the Godot Jolt extension "
"(JoltPinJoint3D, JoltHingeJoint3D, JoltSliderJoint3D, JoltConeTwistJoint3D, "
"and JoltGeneric6DOFJoint) have not been included in the Jolt module."
msgstr ""
"Godot Jolt 擴充功能中提供的關節節點（JoltPinJoint3D、JoltHingeJoint3D、"
"JoltSliderJoint3D、JoltConeTwistJoint3D、JoltGeneric6DOFJoint）並未包含在 "
"Jolt 模組中。"

msgid "Thread safety"
msgstr "執行緒安全"

msgid ""
"Unlike the Godot Jolt extension, the Jolt module does have thread-safety, "
"including support for the :ref:`Physics > 3D > Run On Separate "
"Thread<class_ProjectSettings_Property_physics/3d/run_on_separate_thread>` "
"project setting. However this has not been tested very thoroughly, so it "
"should be considered experimental."
msgstr ""
"與 Godot Jolt 擴充功能不同，Jolt 模組具備執行緒安全，包含支援專案設"
"定 :ref:`Physics > 3D > Run On Separate "
"Thread<class_ProjectSettings_Property_physics/3d/run_on_separate_thread>`。然"
"而這方面尚未經過非常充分的測試，應視為實驗性功能。"
