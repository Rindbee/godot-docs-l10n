#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using physics interpolation"
msgstr "使用物理插值"

msgid ""
"How do we incorporate physics interpolation into a Godot game? Are there any "
"caveats?"
msgstr "我們要如何在 Godot 專案中應用物理插值？有什麼需要注意的事項嗎？"

msgid ""
"We have tried to make the system as easy to use as possible, and many "
"existing games will work with few changes. That said there are some "
"situations which require special treatment, and these will be described."
msgstr ""
"我們盡量讓這個系統易於使用，許多現有專案只需少量修改即可運作。不過某些情境下"
"仍需特別處理，這些狀況將於下方說明。"

msgid "Turn on the physics interpolation setting"
msgstr "開啟物理插值設定"

msgid ""
"The first step is to turn on physics interpolation in :ref:`Project Settings "
"> Physics > Common > Physics "
"Interpolation<class_ProjectSettings_property_physics/common/"
"physics_interpolation>` You can now run your game."
msgstr ""
"第一步是於 :ref:`專案設定 > 物理 > 共用 > 物理插值"
"<class_ProjectSettings_property_physics/common/physics_interpolation>` 開啟物"
"理插值。這樣就可以開始執行你的遊戲了。"

msgid ""
"It is likely that nothing looks hugely different, particularly if you are "
"running physics at 60 TPS or a multiple of it. However, quite a bit more is "
"happening behind the scenes."
msgstr ""
"你可能不會發現明顯的差異，特別是當你的物理更新率設為 60 TPS 或其倍數時。然"
"而，底層其實已經進行了許多運算。"

msgid ""
"To convert an existing game to use interpolation, it is highly recommended "
"that you temporarily set :ref:`Project Settings > Physics > Common > Physics "
"Tick per Second<class_ProjectSettings_property_physics/common/"
"physics_ticks_per_second>` to a low value such as ``10``, which will make "
"interpolation problems more obvious."
msgstr ""
"若要將舊有遊戲轉換為使用插值，建議你暫時將 :ref:`專案設定 > 物理 > 共用 > 每"
"秒物理更新次數<class_ProjectSettings_property_physics/common/"
"physics_ticks_per_second>` 設為較低的值（例如 ``10``），這會讓插值問題變得更"
"明顯，方便偵錯。"

msgid "Move (almost) all game logic from _process to _physics_process"
msgstr "將（幾乎）所有遊戲邏輯從 _process 移至 _physics_process"

msgid ""
"The most fundamental requirement for physics interpolation (which you may be "
"doing already) is that you should be moving and performing game logic on "
"your objects within ``_physics_process`` (which runs at a physics tick) "
"rather than ``_process`` (which runs on a rendered frame). This means your "
"scripts should typically be doing the bulk of their processing within "
"``_physics_process``, including responding to input and AI."
msgstr ""
"物理插值最根本的要求（你可能已經這麼做了）是：所有物件的移動與遊戲邏輯，應該"
"在 ``_physics_process``（每次物理更新時觸發）中執行，而不是在 ``_process``"
"（每個畫面更新時觸發）中。換句話說，你的腳本應該主要在 ``_physics_process`` "
"處理大部分邏輯，包括處理輸入與 AI。"

msgid ""
"Setting the transform of objects only within physics ticks allows the "
"automatic interpolation to deal with transforms *between* physics ticks, and "
"ensures the game will run the same whatever machine it is run on. As a "
"bonus, this also reduces CPU usage if the game is rendering at high FPS, "
"since AI logic (for example) will no longer run on every rendered frame."
msgstr ""
"僅在物理更新時設定物件的變換，可讓自動插值系統處理物理更新之間的變換，同時確"
"保遊戲在不同裝置上表現一致。此外，若遊戲在高 FPS 下執行，這也能減少 CPU 負"
"擔，因為像 AI 這類邏輯將不會在每個畫面更新時都執行。"

msgid ""
"If you attempt to set the transform of interpolated objects *outside* the "
"physics tick, the calculations for the interpolated position will be "
"incorrect, and you will get jitter. This jitter may not be visible on your "
"machine, but it *will* occur for some players. For this reason, setting the "
"transform of interpolated objects should be avoided outside of the physics "
"tick. Godot will attempt to produce warnings in the editor if this case is "
"detected."
msgstr ""
"如果你在物理更新之外設定插值物件的變換，插值的位置計算將會錯誤，導致抖動。這"
"種抖動可能在你的裝置上看不出來，但對某些玩家來說會很明顯。因此，應避免在物理"
"更新之外修改插值物件的變換。Godot 編輯器偵測到這種情況時，會嘗試給予警告。"

msgid ""
"This is only a *soft rule*. There are some occasions where you might want to "
"teleport objects outside of the physics tick (for instance when starting a "
"level, or respawning objects). Still, in general, you should be applying "
"transforms from the physics tick."
msgstr ""
"這僅是*軟性規定*。有些情況下你可能需要在物理更新之外瞬移物件（例如關卡開始、"
"物件重生時）。不過一般來說，建議你還是盡量在物理更新中處理節點變換。"

msgid "Ensure that all indirect movement happens during physics ticks"
msgstr "確保所有間接移動都在物理更新時進行"

msgid ""
"Consider that in Godot, nodes can be moved not just directly in your own "
"scripts, but also by automatic methods such as tweening, animation, and "
"navigation. All these methods should also have their timing set to operate "
"on the physics tick rather than each frame (\"idle\"), **if** you are using "
"them to move objects (*these methods can also be used to control properties "
"that are not interpolated*)."
msgstr ""
"請注意，在 Godot 中，節點不僅可以在腳本中直接移動，也能透過 Tween、動畫、路徑"
"導引等自動方法移動。如果你用這些方法移動物件，應將它們的時序設為在物理更新"
"（而不是每個畫面更新，即「idle」）時執行。(*這些方法也可用於控制不插值的屬"
"性，這種情況則不受限於此*)。"

msgid ""
"Also consider that nodes can be moved not just by moving themselves, but "
"also by moving parent nodes in the :ref:`SceneTree<class_SceneTree>`. The "
"movement of parents should therefore also only occur during physics ticks."
msgstr ""
"此外，節點除了可以直接移動，也可能因為父節點在 :ref:`場景樹"
"<class_SceneTree>` 中移動而間接移動。因此，父節點的移動也應盡量只在物理更新時"
"進行。"

msgid "Choose a physics tick rate"
msgstr "選擇物理更新頻率"

msgid ""
"When using physics interpolation, the rendering is decoupled from physics, "
"and you can choose any value that makes sense for your game. You are no "
"longer limited to values that are multiples of the user's monitor refresh "
"rate (for stutter-free gameplay if the target FPS is reached)."
msgstr ""
"啟用物理插值後，畫面算繪與物理運算將分離，你可以根據遊戲需求自由選擇物理更新"
"頻率。不再受限於螢幕刷新率的整數倍（以避免卡頓的情況）。"

msgid "As a rough guide:"
msgstr "以下是簡單的參考建議："

msgid "Low tick rates (10-30)"
msgstr "低更新率（10-30）"

msgid "Medium tick rates (30-60)"
msgstr "中等更新率（30-60）"

msgid "High tick rates (60+)"
msgstr "高更新率（60 以上）"

msgid "Better CPU performance"
msgstr "CPU 效能較佳"

msgid "Good physics behavior in complex scenes"
msgstr "複雜場景下物理表現良好"

msgid "Good with fast physics"
msgstr "適合物理運算要求快的遊戲"

msgid "Add some delay to input"
msgstr "輸入會有些微延遲"

msgid "Good for first person games"
msgstr "適合第一人稱遊戲"

msgid "Good for racing games"
msgstr "適合賽車遊戲"

msgid "Simple physics behaviour"
msgstr "物理運算較簡單"

msgid ""
"You can always change the tick rate as you develop, it is as simple as "
"changing the project setting."
msgstr "在開發過程中，你隨時可以調整物理更新頻率，只需修改專案設定即可。"

msgid "Call ``reset_physics_interpolation()`` when teleporting objects"
msgstr "物件瞬移時請呼叫 ``reset_physics_interpolation()``"

msgid ""
"Most of the time, interpolation is what you want between two physics ticks. "
"However, there is one situation in which it may *not* be what you want. That "
"is when you are initially placing objects, or moving them to a new location. "
"Here, you don't want a smooth motion between where the object was (e.g. the "
"origin) and the initial position - you want an instantaneous move."
msgstr ""
"大多數情況下，你會希望在兩個物理更新之間進行插值。但有一種例外：當你一開始擺"
"放物件，或將物件瞬移到新位置時，此時你不希望物件從原來位置（如原點）到新位置"
"產生平滑移動，而是希望物件瞬間移動。"

msgid ""
"The solution to this is to call "
"the :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>` "
"function. What this function does under the hood is set the internally "
"stored *previous transform* of the object to be equal to the *current "
"transform*. This ensures that when interpolating between these two equal "
"transforms, there will be no movement."
msgstr ""
"這時候，你應該呼"
"叫 :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`。"
"這個方法會將物件內部儲存的「前一個變換」設為與「當前變換」相同，如此在插值運"
"算時就不會產生移動。"

msgid ""
"Even if you forget to call this, it will usually not be a problem in most "
"situations (especially at high tick rates). This is something you can easily "
"leave to the polishing phase of your game. The worst that will happen is "
"seeing a streaking motion for a frame or so when you move them - you will "
"know when you need it!"
msgstr ""
"即便你忘了呼叫這個方法，在多數情況下（尤其是高更新率時）其實也不太會有問題。"
"這通常可以等到遊戲優化時再處理。最嚴重的情況是，物件瞬移時會有一兩個影格出現"
"「拖影」現象，你一看就會發現需要補上這行程式碼!"

msgid "There are actually two ways to use ``reset_physics_interpolation()``:"
msgstr "實際上，``reset_physics_interpolation()`` 有兩種常見用法："

msgid "*Standing start (e.g. player)*"
msgstr "*靜止起始（例如玩家角色）*"

msgid "Set the initial transform"
msgstr "設定初始變換"

msgid "Call ``reset_physics_interpolation()``"
msgstr "呼叫 ``reset_physics_interpolation()``"

msgid ""
"The previous and current transforms will be identical, resulting in no "
"initial movement."
msgstr "這樣前後兩次的變換會完全一致，就不會產生起始時的移動。"

msgid "*Moving start (e.g. bullet)*"
msgstr "*動態起始（例如子彈）*"

msgid "Immediately set the transform expected after the first tick of motion"
msgstr "直接設定物件於首次移動後應有的變換"

msgid ""
"The previous transform will be the starting position, and the current "
"transform will act as though a tick of simulation has already taken place. "
"This will immediately start moving the object, instead of having a tick "
"delay standing still."
msgstr ""
"這麼做會讓前一個變換為起始位置，並且讓當前變換看起來像已經模擬過一次。這樣物"
"件會立刻開始移動，不會在原地多停留一個更新週期。"

msgid ""
"Make sure you set the transform and call ``reset_physics_interpolation()`` "
"in the correct order as shown above, otherwise you will see unwanted "
"\"streaking\"."
msgstr ""
"請務必依照上述順序先設定變換，再呼叫 ``reset_physics_interpolation()``，否則"
"會看到不必要的「拖影」現象。"

msgid "Testing and debugging tips"
msgstr "測試與除錯建議"

msgid ""
"Even if you intend to run physics at 60 TPS, in order to thoroughly test "
"your interpolation and get the smoothest gameplay, it is highly recommended "
"to temporarily set the physics tick rate to a low value such as 10 TPS."
msgstr ""
"即使你打算用 60 TPS 執行物理運算，為了徹底測試插值效果並確保遊戲體驗順暢，強"
"烈建議你暫時將物理更新率設為較低的值（如 10 TPS）。"

msgid ""
"The gameplay may not work perfectly, but it should enable you to more easily "
"see cases where you should be "
"calling :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`, "
"or where you should be using your own custom interpolation on e.g. "
"a :ref:`Camera3D<class_Camera3D>`. Once you have these cases fixed, you can "
"set the physics tick rate back to the desired setting."
msgstr ""
"雖然遊戲流程可能不會完全如你預期，但這樣能更容易找出哪些地方需要呼"
"叫 :ref:`Node.reset_physics_interpolation<class_Node_method_reset_physics_interpolation>`，"
"或是哪裡你該對（例如 :ref:`Camera3D<class_Camera3D>`）自訂插值。等這些問題都"
"修正後，再把物理更新率調回你想要的數值。"

msgid ""
"The other great advantage to testing at a low tick rate is you can often "
"notice other game systems that are synchronized to the physics tick and "
"creating glitches which you may want to work around. Typical examples "
"include setting animation blend values, which you may decide to set in "
"``_process()`` and interpolate manually."
msgstr ""
"低物理更新率測試還有另一個好處：你能更容易發現其他和物理更新同步的子系統也可"
"能導致異常。常見例子如動畫混合值，有時你可能會選擇在 ``_process()`` 裡手動插"
"值處理這類屬性。"
