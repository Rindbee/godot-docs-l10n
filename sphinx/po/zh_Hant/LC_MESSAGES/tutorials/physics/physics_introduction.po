#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "物理系統簡介"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"在遊戲開發時，經常需要得知遊戲中兩個物件是否相交或接觸。這稱為 **碰撞偵測**。"
"偵測到碰撞後，通常會希望產生某些反應，這稱為 **碰撞回應**。"

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"Godot 在 2D 與 3D 中提供多種碰撞物件，能同時進行碰撞偵測與回應。專案開發時要"
"選用哪一種常令人感到困惑。只要瞭解各種碰撞物件的運作方式與優缺點，即可避免問"
"題並讓開發過程更順利。"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你將學到："

msgid "Godot's four collision object types"
msgstr "Godot 的四種碰撞物件型態"

msgid "How each collision object works"
msgstr "各種碰撞物件的運作方式"

msgid "When and why to choose one type over another"
msgstr "何時、為何選用特定碰撞物件"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"本文範例皆以 2D 物件為主。每種 2D 物理物件與碰撞形狀，在 3D 中都有相對應的版"
"本，並且大多數情況下運作方式一致。"

msgid "Collision objects"
msgstr "碰撞物件"

msgid ""
"Godot offers four kinds of collision objects which all "
"extend :ref:`CollisionObject2D <class_CollisionObject2D>`. The last three "
"listed below are physics bodies and additionally extend :ref:`PhysicsBody2D "
"<class_PhysicsBody2D>`."
msgstr ""
"Godot 提供四種碰撞物件，皆繼承自 :ref:`CollisionObject2D "
"<class_CollisionObject2D>`。下列其中三種同時為物理主體，進一步繼承"
"自 :ref:`PhysicsBody2D <class_PhysicsBody2D>`。"

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"``Area2D`` 節點提供**偵測**與**影響**功能。它可偵測物件重疊，並在有物體進入或"
"離開時發出訊號。``Area2D`` 也能用來覆寫特定區域內的物理屬性，如重力或阻尼。"

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ":ref:`StaticBody2D <class_StaticBody2D>`"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"靜態主體是不會被物理引擎移動的物件。它會參與碰撞偵測，但不會因碰撞而產生移"
"動。通常用於場景環境或不需動態行為的物件。"

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ":ref:`RigidBody2D <class_RigidBody2D>`"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting "
"movement. :ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"這個節點用來進行 2D 物理模擬。你無法直接控制 ``RigidBody2D``，而是透過施加各"
"種力（例如重力、脈衝等），由物理引擎自動計算運動結果。:ref:`深入了解剛體的使"
"用方法 <doc_rigid_body>`"

msgid ":ref:`CharacterBody2D <class_CharacterBody2D>`"
msgstr ":ref:`CharacterBody2D <class_CharacterBody2D>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"這種主體提供碰撞偵測，但不會有物理模擬。所有移動及碰撞回應都必須自行以程式碼"
"實作。"

msgid "Physics material"
msgstr "物理材質"

msgid ""
"Static bodies and rigid bodies can be configured to use "
"a :ref:`PhysicsMaterial <class_PhysicsMaterial>`. This allows adjusting the "
"friction and bounce of an object, and set if it's absorbent and/or rough."
msgstr ""
"靜態主體與剛體可設定為使用 :ref:`PhysicsMaterial <class_PhysicsMaterial>`。這"
"讓你能調整物件的摩擦力與彈性，並可設為具有吸收性或粗糙效果。"

msgid "Collision shapes"
msgstr "碰撞形狀"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"一個物理主體可以有多個 :ref:`Shape2D <class_Shape2D>` 子物件。這些形狀用來定"
"義物件的碰撞範圍，並偵測與其他物件的接觸。"

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr "為了進行碰撞偵測，至少需要給物件指派一個 ``Shape2D``。"

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"最常見的指派形狀方式，是新增 :ref:`CollisionShape2D "
"<class_CollisionShape2D>` 或 :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` 為子節點。這些節點可讓你直接在編輯器工作區繪製碰"
"撞形狀。"

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"請注意，千萬不要在編輯器中縮放碰撞形狀。檢查器（Inspector）中的「Scale」屬性"
"應維持 ``(1, 1)``。要改變碰撞形狀的大小，請務必使用尺寸控制點，**不要** 用 "
"``Node2D`` 的縮放工具。縮放碰撞形狀會導致碰撞行為異常。"

msgid "Physics process callback"
msgstr "物理處理回呼"

msgid ""
"The physics engine runs at a fixed rate (a default of 60 iterations per "
"second). This rate is typically different from the frame rate which "
"fluctuates based on what is rendered and available resources."
msgstr ""
"物理引擎以固定速率執行（預設每秒 60 次）。這個速率通常不同於畫面更新率"
"（frame rate），後者會根據渲染內容與資源而變動。"

msgid ""
"It is important that all physics related code runs at this fixed rate. "
"Therefore Godot differentiates :ref:`between physics and idle processing "
"<doc_idle_and_physics_processing>`. Code that runs each frame is called idle "
"processing and code that runs on each physics tick is called physics "
"processing. Godot provides two different callbacks, one for each of those "
"processing rates."
msgstr ""
"所有與物理相關的程式碼都應在這個固定速率下執行。因此 Godot 區分了 :ref:`物理"
"處理與空閒處理 <doc_idle_and_physics_processing>`。每幀執行的程式碼稱為空閒處"
"理（idle processing），每次物理步進執行的程式碼則稱為物理處理。Godot 提供兩種"
"不同的回呼函式，分別對應這兩種處理速率。"

msgid ""
"The physics callback, :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`, is called before each physics "
"step. Any code that needs to access a body's properties should be run in "
"here. This method will be passed a ``delta`` parameter, which is a floating-"
"point number equal to the time passed in *seconds* since the last step. When "
"using the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"物理回呼 :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>` 會在每個物理步驟前呼叫。任何需"
"要存取物理主體屬性的程式碼都應在這裡執行。這個方法會傳入一個 ``delta`` 參數，"
"表示自上次步進後經過的秒數，為浮點數。預設 60Hz 更新率時，通常為 "
"``0.01666...`` （但不一定，詳見下述）。"

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"建議在需要時於物理運算中一定要使用 ``delta`` 參數，這樣無論更改物理更新率或玩"
"家裝置效能不足，遊戲都能正確運作。"

msgid "Collision layers and masks"
msgstr "碰撞層與遮罩"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 32 different physics layers it "
"can interact with."
msgstr ""
"碰撞層系統是 Godot 物理系統中既強大又常被誤解的功能之一。這個系統可用來建立各"
"種物件間的複雜互動。其核心概念是**層（Layer）**與**遮罩（Mask）**。每個 "
"``CollisionObject2D`` 最多可設定 32 層物理互動。"

msgid "Let's look at each of the properties in turn:"
msgstr "我們來依序看看每個屬性的作用："

msgid "collision_layer"
msgstr "collision_layer"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr "這個屬性表示物件**所在**的層。預設情況下，所有主體都位於第 ``1`` 層。"

msgid "collision_mask"
msgstr "collision_mask"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"這個屬性表示主體會**偵測**哪些層的碰撞。如果某物件不在遮罩指定的層內，就會被"
"忽略。預設所有主體都偵測第 ``1`` 層。"

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr "這些屬性可透過程式碼設定，或直接在屬性檢視器（Inspector）中設定。"

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in **Project Settings > Layer Names > 2D Physics**."
msgstr ""
"管理每個層的用途有時會變得混亂，因此建議幫常用的層命名。可至 **專案設定 > 層"
"名稱 > 2D 物理** 指定各層名稱。"

msgid "GUI example"
msgstr "介面範例"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"假設遊戲中有四種節點：牆（Wall）、玩家（Player）、敵人（Enemy）、金幣"
"（Coin）。玩家與敵人都會與牆碰撞。玩家會偵測敵人和金幣的碰撞，但敵人與金幣互"
"不理會。"

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"請先將 1~4 層分別命名為「walls」、「player」、「enemies」和「coins」，並用"
"「Layer」屬性將各節點指定到對應層。再用「Mask」屬性選擇該節點要偵測哪些層。以"
"玩家為例，設定如下："

msgid "Code example"
msgstr "程式碼範例"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0xffffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"在呼叫函式時，層是用位元遮罩（bitmask）指定的。預設啟用所有層時，遮罩值為 "
"``0xffffffff``。你可用二進位、十六進位或十進位來寫遮罩值，依個人習慣調整。"

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows:"
msgstr "若要啟用第 1、3、4 層，對應的程式碼如下："

msgid ""
"You can also set bits independently by calling "
"``set_collision_layer_value(layer_number, value)`` or "
"``set_collision_mask_value(layer_number, value)`` on any "
"given :ref:`CollisionObject2D <class_CollisionObject2D>` as follows:"
msgstr ""
"也可以在任一 :ref:`CollisionObject2D <class_CollisionObject2D>` 上呼叫 "
"``set_collision_layer_value(layer_number, value)`` 或 "
"``set_collision_mask_value(layer_number, value)`` 來獨立設定各位元，範例如"
"下："

msgid ""
"Export annotations can be used to export bitmasks in the editor with a user-"
"friendly GUI:"
msgstr "也可以利用匯出註解在編輯器中以友善的圖形介面匯出位元遮罩："

msgid ""
"Additional export annotations are available for render and navigation "
"layers, in both 2D and 3D. "
"See :ref:`doc_gdscript_exports_exporting_bit_flags`."
msgstr ""
"在 2D 與 3D 中，渲染層與導覽層也有額外的 export 註解可用。詳"
"見 :ref:`doc_gdscript_exports_exporting_bit_flags`。"

msgid "Area2D"
msgstr "Area2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"Area 節點提供**偵測**與**影響**功能。它能偵測物件重疊，並在有主體進入或離開時"
"發出訊號。Area 也可用來覆寫特定區域的物理屬性，如重力或阻尼。"

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr ":ref:`Area2D <class_Area2D>` 主要有三種用途："

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "在指定區域內覆寫物理參數（如重力）。"

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr "偵測其他主體進入、離開區域，或查詢目前區域內有哪些主體。"

msgid "Checking other areas for overlap."
msgstr "檢查與其他 Area 是否有重疊。"

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "預設情況下，Area 也會接收滑鼠與觸控輸入。"

msgid "StaticBody2D"
msgstr "StaticBody2D"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"靜態主體不會被物理引擎移動。它會參與碰撞偵測，但遇到碰撞時不會移動。不過，你"
"可以用 ``constant_linear_velocity`` 及 ``constant_angular_velocity`` 屬性，讓"
"它像在移動一樣對碰撞到的物件產生推動或旋轉效果。"

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"``StaticBody2D`` 節點多半用於場景環境用物件，或是不需有動態行為的物體上。"

msgid "Example uses for ``StaticBody2D``:"
msgstr "``StaticBody2D`` 常見用途："

msgid "Platforms (including moving platforms)"
msgstr "平臺（包含移動平臺）"

msgid "Conveyor belts"
msgstr "輸送帶"

msgid "Walls and other obstacles"
msgstr "牆壁與其他障礙物"

msgid "RigidBody2D"
msgstr "RigidBody2D"

msgid ""
"This is the node that implements simulated 2D physics. You do not control "
"a :ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces "
"to it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"這個節點可以進行 2D 物理模擬。你不能直接控制 :ref:`RigidBody2D "
"<class_RigidBody2D>`，而是對它施加各種力，由物理引擎計算運動與碰撞反應（如彈"
"跳、旋轉等）。"

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"你可以在屬性檢視器設定剛體的「Mass」（質量）、「Friction」（摩擦）或"
"「Bounce」（彈性）等屬性來調整剛體行為。"

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"**Project Settings > Physics**, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"主體的行為也會受到世界屬性的影響，這些屬性可在 **專案設定 > 物理** 中設定，或"
"是進入一個有覆寫全域物理屬性的 :ref:`Area2D <class_Area2D>` 也會影響。"

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"剛體靜止一段時間後會進入睡眠狀態。進入睡眠的剛體會像靜態主體一樣，其力運算不"
"再執行。當受到外力（碰撞或程式碼）時，會再次喚醒。"

msgid "Using RigidBody2D"
msgstr "使用 RigidBody2D"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"使用剛體的好處之一，是許多物理行為可自動產生而無需寫程式。例如要做一個「憤怒"
"鳥」遊戲，有掉落方塊時，只需建立多個 RigidBody2D 並調整屬性，堆疊、掉落、彈跳"
"等都會自動運算。"

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use "
"the :ref:`_integrate_forces() "
"<class_RigidBody2D_private_method__integrate_forces>` callback instead of "
"``_physics_process()``. In this callback, you have access to the "
"body's :ref:`PhysicsDirectBodyState2D <class_PhysicsDirectBodyState2D>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"但如果你想要手動控制剛體，請特別注意——直接修改剛體的 ``position``、"
"``linear_velocity`` 等屬性，可能會導致怪異行為。若需修改物理相關屬性，應該"
"在 :ref:`_integrate_forces() "
"<class_RigidBody2D_private_method__integrate_forces>` 回呼中處理，而不是在 "
"``_physics_process()``。在這個回呼中，你可以安全地存"
"取 :ref:`PhysicsDirectBodyState2D <class_PhysicsDirectBodyState2D>`，同步屬性"
"變更與物理引擎。"

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "例如，這是「太空侵略者」風格太空船的程式碼："

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"請注意，我們並未直接設定 ``linear_velocity`` 或 ``angular_velocity`` 屬性，而"
"是對剛體施加推力（``thrust``）與扭力（``torque``），讓物理引擎自動計算運動結"
"果。"

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling "
"the :ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be "
"aware that this can have a negative effect on performance."
msgstr ""
"剛體進入睡眠狀態時，``_integrate_forces()`` 不會被呼叫。若需強制保持喚醒，可"
"以讓它持續碰撞、持續施加外力，或關閉 :ref:`can_sleep "
"<class_RigidBody2D_property_can_sleep>` 屬性。注意這可能會影響效能。"

msgid "Contact reporting"
msgstr "碰撞接觸回報"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained "
"via :ref:`PhysicsDirectBodyState2D.get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` and related "
"functions."
msgstr ""
"預設情況下，剛體不會記錄碰撞接觸點，因為場景物件數量多時會佔用大量記憶體。如"
"需開啟碰撞回報，請將 :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` 設為非零，之後可"
"用 :ref:`PhysicsDirectBodyState2D.get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` 等方法取得接觸資"
"訊。"

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. "
"See :ref:`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"如需用訊號（signal）監控碰撞，可開啟 :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` 屬性。可參考 :ref:`RigidBody2D "
"<class_RigidBody2D>` 文件了解可用訊號清單。"

msgid "CharacterBody2D"
msgstr "CharacterBody2D"

msgid ""
":ref:`CharacterBody2D <class_CharacterBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a character body."
msgstr ""
":ref:`CharacterBody2D <class_CharacterBody2D>` 會偵測與其他主體的碰撞，但不會"
"受到重力、摩擦等物理屬性影響。必須由使用者以程式碼控制其移動，物理引擎不會自"
"動推動角色主體。"

msgid ""
"When moving a character body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"移動角色主體時，不應直接設定其 ``position``，而應使用 ``move_and_collide()`` "
"或 ``move_and_slide()`` 方法。這些方法會沿指定向量移動主體，若偵測到碰撞則會"
"立即停止。碰撞後的行為需自行以程式碼處理。"

msgid "Character collision response"
msgstr "角色主體碰撞回應"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"CharacterBody2D."
msgstr ""
"碰撞後，你可能希望物件反彈、沿牆滑動，或改變被撞擊物件屬性。你要如何處理碰撞"
"回應，取決於你用哪種方法來移動 CharacterBody2D。"

msgid ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"
msgstr ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"

msgid ""
"When using ``move_and_collide()``, the function returns "
"a :ref:`KinematicCollision2D <class_KinematicCollision2D>` object, which "
"contains information about the collision and the colliding body. You can use "
"this information to determine the response."
msgstr ""
"使用 ``move_and_collide()`` 時，該方法會回傳一個 :ref:`KinematicCollision2D "
"<class_KinematicCollision2D>` 物件，內含碰撞與撞擊對象的詳細資訊。你可以利用"
"這些資訊決定後續的碰撞回應。"

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr "例如，若要取得碰撞發生的空間座標："

msgid "Or to bounce off of the colliding object:"
msgstr "或讓角色主體從碰撞物件彈開："

msgid ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"滑動是一種很常見的碰撞回應，例如玩家在俯視遊戲中沿牆移動，或在橫向卷軸遊戲中"
"上下坡。雖然用 ``move_and_collide()`` 後可以手動寫出滑動邏輯，但 "
"``move_and_slide()`` 提供了更方便的作法，讓你無需大量程式碼即可實現滑動移動。"

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``. This does "
"**not** apply to ``gravity`` as it is an acceleration and is time dependent, "
"and needs to be scaled by ``delta``."
msgstr ""
"``move_and_slide()`` 會自動處理時間步進（timestep），所以你**不需要**將速度向"
"量乘上 ``delta``。但 ``gravity`` 屬於加速度，與時間有關，仍需乘上 ``delta``。"

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"例如，下面的程式碼可以讓角色主體沿地面（包含坡道）行走，並在站穩地面時跳躍："

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"更多 ``move_and_slide()`` 的使用細節，請參"
"考 :ref:`doc_kinematic_character_2d`，內含詳細程式碼的範例專案。"
