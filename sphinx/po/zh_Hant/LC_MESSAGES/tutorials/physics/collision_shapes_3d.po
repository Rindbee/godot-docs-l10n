#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (3D)"
msgstr "碰撞形狀 (3D)"

msgid "This guide explains:"
msgstr "本教學將說明："

msgid "The types of collision shapes available in 3D in Godot."
msgstr "Godot 3D 可用的碰撞形狀類型。"

msgid "Using a convex or a concave mesh as a collision shape."
msgstr "如何使用凸形或凹形網格作為碰撞形狀。"

msgid "Performance considerations regarding 3D collisions."
msgstr "有關 3D 碰撞的效能注意事項。"

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr "Godot 提供多種碰撞形狀，各有不同的效能與精確度權衡。"

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody3D` by adding one or "
"more :ref:`CollisionShape3Ds <class_CollisionShape3D>` as *direct* child "
"nodes. Indirect child nodes (i.e. children of child nodes) will be ignored "
"and won't be used as collision shapes. Also, note that you must add "
"a :ref:`class_Shape3D` *resource* to collision shape nodes in the Inspector "
"dock."
msgstr ""
"你可以為 :ref:`PhysicsBody3D <class_PhysicsBody3D>` 加入一個或多個 作為*直接*"
"子節點的 :ref:`CollisionShape3D <class_CollisionShape3D>` 來定義其碰撞形狀。"
"間接子節點（例如子節點的子節點）將會被忽略，且不會用於碰撞計算。另外，請注意"
"必須在屬性面板（Inspector）為碰撞形狀節點指定 :ref:`Shape3D <class_Shape3D>` "
"*資源*。"

msgid ""
"When you add multiple collision shapes to a single PhysicsBody, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"當你將多個碰撞形狀加入同一個 PhysicsBody 時，不需要擔心它們會互相重疊，這些形"
"狀彼此之間不會「碰撞」。"

msgid "Primitive collision shapes"
msgstr "基本碰撞形狀"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godot 提供下列基本碰撞形狀型別："

msgid ":ref:`class_BoxShape3D`"
msgstr ":ref:`class_BoxShape3D`"

msgid ":ref:`class_SphereShape3D`"
msgstr ":ref:`class_SphereShape3D`"

msgid ":ref:`class_CapsuleShape3D`"
msgstr ":ref:`class_CapsuleShape3D`"

msgid ":ref:`class_CylinderShape3D`"
msgstr ":ref:`class_CylinderShape3D`"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"多數小型物件的碰撞可以使用一個或多個基本碰撞形狀來表示。但對於較複雜的物件，"
"如大型船艦或整個關卡，則可能需要使用凸形或凹形碰撞形狀。詳細內容請見下文。"

msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"建議對於動態物件（如 RigidBody 與 CharacterBody）優先使用基本碰撞形狀，這樣行"
"為最穩定可靠，且通常能提供更佳效能。"

msgid "Convex collision shapes"
msgstr "凸形碰撞形狀"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape3D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
":ref:`凸形碰撞形狀 <class_ConvexPolygonShape3D>` 是基本碰撞形狀與凹形碰撞形狀"
"之間的折衷方案。它們可以表示任何複雜度的形狀，但要注意，每一個凸形碰撞形狀只"
"能表示*凸*的形狀。例如，金字塔是*凸*的，但空心盒子則屬於*凹*形。若要用單一碰"
"撞形狀來描述凹形物件，必須用凹形碰撞形狀。"

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"根據物件的複雜度，使用多個凸形碰撞形狀來取代單一凹形碰撞形狀，通常能獲得更好"
"的效能。Godot 可透過*凸分解*自動產生多個大致符合物件外型的凸形狀。但若凸形狀"
"數量過多，這種效能優勢就會消失。對於大型或複雜物件（如整個關卡），建議仍直接"
"使用凹形碰撞形狀。"

msgid ""
"You can generate one or several convex collision shapes from the editor by "
"selecting a MeshInstance3D and using the **Mesh** menu at the top of the 3D "
"viewport. The editor exposes two generation modes:"
msgstr ""
"你可以在編輯器中選取 MeshInstance3D，並在 3D 視窗頂部的 **網格** 功能表，產生"
"一個或多個凸形碰撞形狀。編輯器提供兩種產生模式："

msgid ""
"**Create Single Convex Collision Sibling** uses the Quickhull algorithm. It "
"creates one CollisionShape node with an automatically generated convex "
"collision shape. Since it only generates a single shape, it provides good "
"performance and is ideal for small objects."
msgstr ""
"**建立單一凸形碰撞同級** 使用 Quickhull 演算法，會建立一個帶有自動產生凸形狀"
"的 CollisionShape 節點。由於只產生單一形狀，效能極佳，非常適合小型物件。"

msgid ""
"**Create Multiple Convex Collision Siblings** uses the V-HACD algorithm. It "
"creates several CollisionShape nodes, each with a convex shape. Since it "
"generates multiple shapes, it is more accurate for concave objects at the "
"cost of performance. For objects with medium complexity, it will likely be "
"faster than using a single concave collision shape."
msgstr ""
"**建立多個凸形碰撞同級** 使用 V-HACD 演算法，會建立多個各自帶有凸形狀的 "
"CollisionShape 節點。由於產生多個形狀，對於凹形物件來說精度較高，但效能較差。"
"對於中等複雜度的物件，這種方式通常比用單一凹形碰撞形狀效能更好。"

msgid "Concave or trimesh collision shapes"
msgstr "凹形或三角網格碰撞形狀"

msgid ""
":ref:`Concave collision shapes <class_ConcavePolygonShape3D>`, also called "
"trimesh collision shapes, can take any form, from a few triangles to "
"thousands of triangles. Concave shapes are the slowest option but are also "
"the most accurate in Godot. **You can only use concave shapes within "
"StaticBodies.** They will not work with CharacterBodies or RigidBodies "
"unless the RigidBody's mode is Static."
msgstr ""
":ref:`凹形碰撞形狀 <class_ConcavePolygonShape3D>`，又稱為三角網格碰撞形狀，可"
"以由少數到數千個三角形組成，能呈現任何形態。凹形碰撞形狀在 Godot 中雖然效能最"
"慢，但精度最高。**凹形碰撞形狀僅能用於 StaticBody。** 除非 RigidBody 的模式設"
"為靜態，否則無法用於 CharacterBody 或 RigidBody。"

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr ""
"即使凹形碰撞形狀提供最精確的*碰撞*檢測，接觸點回報的精度仍可能比基本形狀差。"

msgid ""
"When not using GridMaps for level design, concave shapes are the best "
"approach for a level's collision. That said, if your level has small "
"details, you may want to exclude those from collision for performance and "
"game feel. To do so, you can build a simplified collision mesh in a 3D "
"modeler and have Godot generate a collision shape for it automatically. More "
"on that below"
msgstr ""
"如果你不採用 GridMap 來設計關卡，凹形碰撞形狀通常是關卡碰撞的最佳選擇。不過，"
"若關卡中有細小細節，為了效能與遊戲手感，建議排除這些細節的碰撞。你可以在 3D "
"建模軟體內建立簡化的碰撞網格，然後讓 Godot 自動為其產生碰撞形狀。詳情請見下文"

msgid ""
"Note that unlike primitive and convex shapes, a concave collision shape "
"doesn't have an actual \"volume\". You can place objects both *outside* of "
"the shape as well as *inside*."
msgstr ""
"請注意，和基本形狀、凸形狀不同，凹形碰撞形狀沒有真正的「體積」。你可以將物件"
"放在其*外部*，也可以放在*內部*。"

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"MeshInstance3D and using the **Mesh** menu at the top of the 3D viewport. "
"The editor exposes two options:"
msgstr ""
"你可以在編輯器中選取 MeshInstance3D，並從 3D 視窗頂部的 **網格** 功能表，產生"
"凹形碰撞形狀。編輯器提供兩個選項："

msgid ""
"**Create Trimesh Static Body** is a convenient option. It creates a "
"StaticBody containing a concave shape matching the mesh's geometry."
msgstr ""
"**建立三角網格靜態剛體** 是一個方便的選項，會建立一個帶有與網格幾何一致凹形"
"的 StaticBody。"

msgid ""
"**Create Trimesh Collision Sibling** creates a CollisionShape node with a "
"concave shape matching the mesh's geometry."
msgstr ""
"**建立三角網格碰撞同級** 則會建立一個帶有與網格幾何一致凹形的 CollisionShape "
"節點。"

msgid ""
"See :ref:`doc_importing_3d_scenes` for information on how to export models "
"for Godot and automatically generate collision shapes on import."
msgstr ""
"有關如何將模型匯出到 Godot 並在匯入時自動產生碰撞形狀的資訊，請參"
"閱 :ref:`doc_importing_3d_scenes`。"

msgid "Performance caveats"
msgstr "效能注意事項"

msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"每個 PhysicsBody 並不限於只能有一個碰撞形狀，但建議盡量減少碰撞形狀的數量，特"
"別是動態物件（如 RigidBody 與 CharacterBody），以提升效能。此外，請避免在執行"
"時對碰撞形狀進行移動、旋轉或縮放，這樣才能讓物理引擎充分發揮內部最佳化。"

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"若 StaticBody 僅有單一且未經縮放或旋轉的碰撞形狀時，引擎的 *廣義階段* 演算法"
"能有效忽略不活躍的物理物件， *狹義階段* 只需檢查活躍物件。但如果一個 "
"StaticBody 擁有多個碰撞形狀，廣義階段會失效，狹義階段（速度較慢）則必須對每個"
"形狀進行碰撞檢查。"

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"如果遇到效能問題，你可能需要在精度與效能間做出取捨。多數遊戲的碰撞判斷並非 "
"100% 精確，通常會用一些技巧將誤差隱藏，讓玩家在遊玩過程中察覺不到。"
