#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Vector math"
msgstr "向量數學"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"本教學簡要且實用地介紹了線性代數在遊戲開發中的應用。線性代數是研究向量及其用"
"途的學科。向量在 2D 和 3D 遊戲開發中都非常常見，Godot 也大量運用它們。若想成"
"為優秀的遊戲開發者，深入理解向量數學是不可或缺的。"

msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"本教學 **不是** 線性代數的正式教科書，我們僅關注其在遊戲開發上的應用。若想更"
"全面地瞭解相關數學，請參見 https://www.khanacademy.org/math/linear-algebra"

msgid "Coordinate systems (2D)"
msgstr "座標系統（2D）"

msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"在 2D 空間中，座標是由水平軸（``x``）與垂直軸（``y``）定義。2D 空間中的特定位"
"置會以一對數值表示，例如 ``(4, 3)``。"

msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"如果你是電腦圖學新手，可能會覺得很奇怪，正的 ``y`` 軸方向是**向下**，而不是像"
"數學課上學到的那樣向上。但這在大多數電腦繪圖應用程式中非常普遍。"

msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"2D 平面上的任何位置都可以用一對數值來表示。我們也可以將 ``(4, 3)`` 視為從 "
"``(0, 0)`` （即**原點**）出發的**偏移量**。可以畫一個箭頭從原點指向該點："

msgid ""
"This is a **vector**. A vector represents a lot of useful information. As "
"well as telling us that the point is at ``(4, 3)``, we can also think of it "
"as an angle ``θ`` (theta) and a length (or magnitude) ``m``. In this case, "
"the arrow is a **position vector** - it denotes a position in space, "
"relative to the origin."
msgstr ""
"這就是**向量**。向量包含了許多有用資訊。除了表示該點位於 ``(4, 3)`` 外，也可"
"以將它視為角度 ``θ``（theta）與長度（或稱幅度）``m``。在這個例子中，這個箭頭"
"就是一個**位置向量**—代表相對於原點的空間位置。"

msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"關於向量，非常重要的一點是：它們僅代表**相對**方向和大小，並沒有“向量本身的位"
"置”這個概念。下列兩個向量是完全相同的："

msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"這兩個向量都代表從某一個起點往右 4 單位、往下 3 單位的位置。你在平面上哪邊畫"
"這個向量都一樣，它始終代表相對的方向和大小。"

msgid "Vector operations"
msgstr "向量運算"

msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"你可以用 x、y 座標或角度和長度來表示一個向量，但為了方便，程式設計師大多使用"
"座標表示法。例如，在 Godot 中，螢幕左上角是原點。若要將一個名為 ``Node2D`` "
"的 2D 節點放在向右 400 像素、向下 300 像素的位置，請用以下程式碼："

msgid ""
"Godot supports both :ref:`Vector2 <class_Vector2>` and :ref:`Vector3 "
"<class_Vector3>` for 2D and 3D usage, respectively. The same mathematical "
"rules discussed in this article apply to both types, and wherever we link to "
"``Vector2`` methods in the class reference, you can also check out their "
"``Vector3`` counterparts."
msgstr ""
"Godot 分別提供 :ref:`Vector2 <class_Vector2>` 和 :ref:`Vector3 "
"<class_Vector3>` 來處理 2D 與 3D 向量。本文討論的數學規則對這兩種型別都適用。"
"只要在類別參考中連結到 ``Vector2`` 方法的地方，你也可以查閱 ``Vector3`` 的對"
"應方法。"

msgid "Member access"
msgstr "成員存取"

msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr "你可以直接用名稱來存取向量的各個組件。"

msgid "Adding vectors"
msgstr "向量相加"

msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr "當兩個向量相加或相減時，各分量會一一相加或相減："

msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr "我們也可以用圖像方式理解：把第二個向量接在第一個向量的尾端。"

msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr "注意，``a + b`` 的結果和 ``b + a`` 是一樣的。"

msgid "Scalar multiplication"
msgstr "標量乘法"

msgid ""
"Vectors represent both direction and magnitude. A value representing only "
"magnitude is called a **scalar**. Scalars use the :ref:`class_float` type in "
"Godot."
msgstr ""
"向量同時代表方向和大小（幅值）。只代表大小的值稱為**標量**。在 Godot 中，標量"
"為 :ref:`class_float` 型別。"

msgid "A vector can be multiplied by a **scalar**:"
msgstr "向量可以乘上一個**標量**："

msgid ""
"Multiplying a vector by a positive scalar does not change its direction, "
"only its magnitude. Multiplying with a negative scalar results in a vector "
"in the opposite direction. This is how you **scale** a vector."
msgstr ""
"向量乘以正的標量時，方向不變，只會改變大小。若乘以負的標量，則方向會相反。這"
"就是**縮放**向量的方法。"

msgid "Practical applications"
msgstr "實務應用"

msgid "Let's look at two common uses for vector addition and subtraction."
msgstr "來看看向量加減法兩個常見的應用場景。"

msgid "Movement"
msgstr "移動"

msgid ""
"A vector can represent **any** quantity with a magnitude and direction. "
"Typical examples are: position, velocity, acceleration, and force. In this "
"image, the spaceship at step 1 has a position vector of ``(1, 3)`` and a "
"velocity vector of ``(2, 1)``. The velocity vector represents how far the "
"ship moves each step. We can find the position for step 2 by adding the "
"velocity to the current position."
msgstr ""
"向量可以表示**任何**有大小和方向的量，常見例子有：位置、速度、加速度、力等。"
"在這個例子中，第一步驟時太空船的位置向量為 ``(1, 3)``，速度向量為 ``(2, "
"1)``。速度向量表示每一步太空船移動的距離。只要將速度加到當前位置，就能算出下"
"一步的位置。"

msgid ""
"Velocity measures the **change** in position per unit of time. The new "
"position is found by adding the velocity multiplied by the elapsed time "
"(here assumed to be one unit, e.g. 1 s) to the previous position."
msgstr ""
"速度代表單位時間內位置的**變化量**。新位置可以用「前一位置 + 速度 × 經過時"
"間」（這裡假設經過 1 單位時間，例如 1 秒）來計算。"

msgid ""
"In a typical 2D game scenario, you would have a velocity in pixels per "
"second, and multiply it by the ``delta`` parameter (time elapsed since the "
"previous frame) from the :ref:`_process() "
"<class_Node_private_method__process>` or :ref:`_physics_process() "
"<class_Node_private_method__physics_process>` callbacks."
msgstr ""
"在典型的 2D 遊戲場景中，你通常會有以每秒像素為單位的速度，然後乘"
"上 :ref:`_process() <class_Node_private_method__process>` "
"或 :ref:`_physics_process() <class_Node_private_method__physics_process>` 回"
"呼中傳入的 ``delta`` 參數（也就是自上一影格以來經過的時間）。"

msgid "Pointing toward a target"
msgstr "指向目標"

msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"在這個情境下，你有一輛坦克要把炮塔對準一個機器人。用機器人的位置減去坦克的位"
"置，就能得到從坦克指向機器人的向量。"

msgid "To find a vector pointing from ``A`` to ``B``, use ``B - A``."
msgstr "要找到從 ``A`` 指向 ``B`` 的向量，只要用 ``B - A`` 即可。"

msgid "Unit vectors"
msgstr "單位向量"

msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"**大小為 1** 的向量稱作**單位向量**，有時也稱**方向向量**或**法線**。當你只需"
"要記錄方向時，單位向量非常有用。"

msgid "Normalization"
msgstr "正規化"

msgid ""
"**Normalizing** a vector means reducing its length to ``1`` while preserving "
"its direction. This is done by dividing each of its components by its "
"magnitude. Because this is such a common operation, Godot provides a "
"dedicated :ref:`normalized() <class_Vector2_method_normalized>` method for "
"this:"
msgstr ""
"**正規化** 一個向量，是指將其長度縮減到 ``1`` ，但方向不變。做法就是將每個分"
"量都除以該向量的大小。由於這操作很常見，Godot 提供了 :ref:`normalized() "
"<class_Vector2_method_normalized>` 這個專用方法："

msgid ""
"Because normalization involves dividing by the vector's length, you cannot "
"normalize a vector of length ``0``. Attempting to do so would normally "
"result in an error. In GDScript though, trying to call the ``normalized()`` "
"method on a vector of length 0 leaves the value untouched and avoids the "
"error for you."
msgstr ""
"因為正規化必須除以向量的長度，所以無法對長度為 ``0`` 的向量進行正規化。通常這"
"麼做會造成錯誤。不過在 GDScript 中，對長度為 0 的向量呼叫 ``normalized()`` 方"
"法時，會直接返回原值，不會丟出錯誤。"

msgid "Reflection"
msgstr "反射"

msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"單位向量的一個常見用途是表示**法線**。法線向量是與表面垂直的單位向量，定義了"
"表面的方向。它們常被用在光照、碰撞判斷，以及其他涉及表面的運算。"

msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr "舉例來說，假如我們有一個移動的球要讓它從牆壁或其他物件反彈："

msgid ""
"The surface normal has a value of ``(0, -1)`` because this is a horizontal "
"surface. When the ball collides, we take its remaining motion (the amount "
"left over when it hits the surface) and reflect it using the normal. In "
"Godot, there is a :ref:`bounce() <class_Vector2_method_bounce>` method to "
"handle this. Here is a code example of the above diagram using "
"a :ref:`CharacterBody2D <class_CharacterBody2D>`:"
msgstr ""
"這是一個水平表面，因此法線向量為 ``(0, -1)``。當球碰撞時，我們會取它剩餘的運"
"動（也就是撞到表面時還沒走完的移動量），並用法線方向來反射。在 Godot 中，可以"
"使用 :ref:`bounce() <class_Vector2_method_bounce>` 方法來處理。以下為上述情境"
"搭配 :ref:`CharacterBody2D <class_CharacterBody2D>` 的範例程式碼："

msgid "Dot product"
msgstr "點積"

msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"**點積**是向量數學中非常重要、但經常被誤解的概念之一。點積是針對兩個向量運"
"算，結果會得到一個**標量值**。和同時有大小與方向的向量不同，標量只有大小。"

msgid "The formula for dot product takes two common forms:"
msgstr "點積有兩種常見寫法："

msgid "and"
msgstr "和"

msgid ""
"The mathematical notation *||A||* represents the magnitude of vector ``A``, "
"and *A*\\ :sub:`x` means the ``x`` component of vector ``A``."
msgstr ""
"數學符號 *||A||* 表示向量 ``A`` 的大小，*A*\\ :sub:`x` 表示向量 ``A`` 的 x 分"
"量。"

msgid ""
"However, in most cases it is easiest to use the built-in :ref:`dot() "
"<class_Vector2_method_dot>` method. Note that the order of the two vectors "
"does not matter:"
msgstr ""
"不過在大多數情況下，直接用內建的 :ref:`dot() <class_Vector2_method_dot>` 方法"
"最方便。注意，兩個向量的順序不影響結果："

msgid ""
"The dot product is most useful when used with unit vectors, making the first "
"formula reduce to just ``cos(θ)``. This means we can use the dot product to "
"tell us something about the angle between two vectors:"
msgstr ""
"點積搭配單位向量時最常用，這樣第一個公式就變成 ``cos(θ)``。這代表我們可以利用"
"點積來判斷兩個向量之間的角度："

msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr "若是單位向量，點積的結果一定介於 ``-1`` （180°）到 ``1`` （0°）之間。"

msgid "Facing"
msgstr "朝向判斷"

msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"我們可以利用這個特性來判斷一個物件是否朝向另一個物件。在下圖中，玩家 ``P`` 嘗"
"試閃避殭屍 ``A`` 和 ``B``。假設殭屍的視野為 **180°**，他們看得到玩家嗎？"

msgid ""
"The green arrows ``fA`` and ``fB`` are **unit vectors** representing the "
"zombie's facing direction and the blue semicircle represents its field of "
"view. For zombie ``A``, we find the direction vector ``AP`` pointing to the "
"player using ``P - A`` and normalize it, however, Godot has a helper method "
"to do this called :ref:`direction_to() <class_Vector2_method_direction_to>`. "
"If the angle between this vector and the facing vector is less than 90°, "
"then the zombie can see the player."
msgstr ""
"綠色箭頭 ``fA`` 和 ``fB`` 是**單位向量**，分別代表殭屍的朝向；藍色半圓則是其"
"視野。對殭屍 ``A`` 而言，我們用 ``P - A`` 算出指向玩家的方向向量，再進行正規"
"化（Godot 有 :ref:`direction_to() <class_Vector2_method_direction_to>` 輔助方"
"法）。若這個向量和朝向向量的夾角小於 90°，殭屍就能看到玩家。"

msgid "In code it would look like this:"
msgstr "程式實作範例如下："

msgid "Cross product"
msgstr "外積"

msgid ""
"Like the dot product, the **cross product** is an operation on two vectors. "
"However, the result of the cross product is a vector with a direction that "
"is perpendicular to both. Its magnitude depends on their relative angle. If "
"two vectors are parallel, the result of their cross product will be a null "
"vector."
msgstr ""
"和點積類似， **外積** （cross product）也是兩個向量的運算。但外積的結果是一個"
"同時垂直於兩個原始向量的向量，其大小取決於兩者的夾角。若兩個向量平行，則外積"
"的結果會是零向量。"

msgid "The cross product is calculated like this:"
msgstr "外積的計算公式如下："

msgid ""
"With Godot, you can use the built-in :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` method:"
msgstr ""
"在 Godot 裡，可以使用內建的 :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` 方法："

msgid ""
"The cross product is not mathematically defined in 2D. "
"The :ref:`Vector2.cross() <class_Vector2_method_cross>` method is a commonly "
"used analog of the 3D cross product for 2D vectors."
msgstr ""
"外積在數學上沒有針對 2D 定義。Godot 的 :ref:`Vector2.cross() "
"<class_Vector2_method_cross>` 方法則是一種常見的 2D 外積類比運算。"

msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"外積運算順序會影響結果。``a.cross(b)`` 的結果與 ``b.cross(a)`` 會相反，兩者指"
"向**相反方向**。"

msgid "Calculating normals"
msgstr "計算法線"

msgid ""
"One common use of cross products is to find the surface normal of a plane or "
"surface in 3D space. If we have the triangle ``ABC`` we can use vector "
"subtraction to find two edges ``AB`` and ``AC``. Using the cross product, "
"``AB × AC`` produces a vector perpendicular to both: the surface normal."
msgstr ""
"外積一個常見用途是在 3D 空間裡求平面或曲面的法線向量。假設有三角形 ``ABC``，"
"可以用向量減法算出兩條邊 ``AB`` 和 ``AC``，接著用外積 ``AB × AC`` 得到同時垂"
"直於兩者的向量，也就是表面的法線。"

msgid "Here is a function to calculate a triangle's normal:"
msgstr "下列是計算三角形法線的函式範例："

msgid "Pointing to a target"
msgstr "指向目標"

msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"在上面的點積說明中，我們已經看到可以藉由點積計算兩個向量的夾角。然而在 3D 空"
"間中，這還不足夠。你還需要知道應該繞哪個軸旋轉。這時可以用目前朝向與目標方向"
"的外積來計算，所得垂直向量就是旋轉軸。"

msgid "More information"
msgstr "更多資訊"

msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr "想進一步瞭解 Godot 中的向量數學應用，請參考下列文章："

msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
