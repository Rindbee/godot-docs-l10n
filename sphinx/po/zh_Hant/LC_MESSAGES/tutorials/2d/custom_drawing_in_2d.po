#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "2D 中的自訂繪圖"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, text, and many other "
"common game development needs. However, if you need something specific not "
"covered with the standard nodes you can make any 2D node (for "
"example, :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`-"
"based) draw on screen using custom commands."
msgstr ""
"Godot 內建了用於繪製精靈、Polygon、多邊形、粒子、文字等各種常見遊戲開發場景的"
"節點。不過，如果你需要做一些標準節點無法覆蓋的特殊需求，可以讓任何 2D 節點"
"（例如 :ref:`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>` 衍生節"
"點）用自訂繪圖指令直接在畫面上繪製。"

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr "2D 節點中的自訂繪製*非常*有用。下面是一些用例："

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"繪製現有節點型別無法完成的形狀或邏輯，例如帶有軌跡或特殊動態多邊形的圖像。"

msgid ""
"Drawing a large number of simple objects, such as a grid or a board for a 2d "
"game. Custom drawing avoids the overhead of using a large number of nodes, "
"possibly lowering memory usage and improving performance."
msgstr ""
"繪製大量簡單物件，例如 2D 遊戲用的格線或棋盤。自訂繪圖可以避免使用大量節點帶"
"來的額外負擔，有機會降低記憶體用量並提升效能。"

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr "製作自訂的 UI 控制項，以滿足很多可用的控制項之外的特別需求。"

msgid "Drawing"
msgstr "繪製"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, "
"like :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then "
"override the :ref:`_draw()<class_CanvasItem_private_method__draw>` function."
msgstr ""
"將腳本新增到任何 :ref:`CanvasItem <class_CanvasItem>` 衍生節點（例"
"如 :ref:`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>`）上。然後覆"
"寫 :ref:`_draw()<class_CanvasItem_private_method__draw>` 方法。"

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them and we will see some of them in "
"the examples below."
msgstr ""
"繪圖指令的詳細說明可參見 :ref:`CanvasItem <class_CanvasItem>` 類別說明文件。"
"這類指令非常多，下面範例會介紹其中幾個常用的。"

msgid "Updating"
msgstr "更新"

msgid ""
"The :ref:`_draw <class_CanvasItem_private_method__draw>` function is only "
"called once, and then the draw commands are cached and remembered, so "
"further calls are unnecessary."
msgstr ""
":ref:`_draw <class_CanvasItem_private_method__draw>` 方法只會被呼叫一次，之後"
"繪圖指令會被快取起來，所以不需要再重複呼叫。"

msgid ""
"If re-drawing is required because a variable or something else changed, "
"call :ref:`CanvasItem.queue_redraw <class_CanvasItem_method_queue_redraw>` "
"in that same node and a new ``_draw()`` call will happen."
msgstr ""
"如果變數或狀態改變後需要重繪，只要在該節點呼叫 :ref:`CanvasItem.queue_redraw "
"<class_CanvasItem_method_queue_redraw>`，就會觸發新的 ``_draw()`` 呼叫。"

msgid ""
"Here is a little more complex example, where we have a texture variable that "
"can be modified at any time, and using "
"a :ref:`setter<doc_gdscript_basics_setters_getters>`, it forces a redraw of "
"the texture when modified:"
msgstr ""
"以下是一個稍微複雜一點的範例，我們有一個可以隨時修改的貼圖變數，並且透"
"過 :ref:`setter<doc_gdscript_basics_setters_getters>`，在貼圖變更時強制重繪："

msgid ""
"To see it in action, you can set the texture to be the Godot icon on the "
"editor by dragging and dropping the default ``icon.svg`` from the "
"``FileSystem`` tab to the Texture property on the ``Inspector`` tab. When "
"changing the ``Texture`` property value while the previous script is "
"running, the texture will also change automatically."
msgstr ""
"你可以在編輯器中將 ``FileSystem`` 分頁下的預設 ``icon.svg`` 拖曳到 "
"``Inspector`` 分頁的 Texture 屬性，來測試這段程式。當上面的腳本正在執行時，只"
"要變更 Texture 屬性的值，貼圖也會隨之自動更新。"

msgid ""
"In some cases, we may need to redraw every frame. For this, "
"call :ref:`queue_redraw <class_CanvasItem_method_queue_redraw>` from "
"the :ref:`_process <class_Node_private_method__process>` method, like this:"
msgstr ""
"有時我們可能需要每一禎都重繪。這時可以在 :ref:`_process "
"<class_Node_private_method__process>` 方法裡呼叫 :ref:`queue_redraw "
"<class_CanvasItem_method_queue_redraw>`，像這樣："

msgid "Coordinates and line width alignment"
msgstr "座標與線寬對齊"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. This means ``_draw()`` uses the coordinate space created "
"after applying the CanvasItem's transform. Additionally, you can apply a "
"custom transform on top of it by "
"using :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"or :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"繪圖 API 使用的是 CanvasItem 的座標系統，不一定是像素座標。也就是說，"
"``_draw()`` 用的是應用過 CanvasItem 轉換後的座標空間。此外，你還可以"
"用 :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"或 :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>` "
"再加上自訂轉換。"

msgid ""
"When using :ref:`draw_line <class_CanvasItem_method_draw_line>`, you should "
"consider the width of the line. When using a width that is an odd size, the "
"position of the start and end points should be shifted by ``0.5`` to keep "
"the line centered, as shown below."
msgstr ""
"使用 :ref:`draw_line <class_CanvasItem_method_draw_line>` 時，應注意線寬。如"
"果線寬為奇數，起點和終點座標應加上 ``0.5``，才能讓線條置中，如下圖所示。"

msgid ""
"The same applies to the :ref:`draw_rect <class_CanvasItem_method_draw_rect>` "
"method with ``filled = false``."
msgstr ""
"同理，對 :ref:`draw_rect <class_CanvasItem_method_draw_rect>` 方法（``filled "
"= false``）也適用。"

msgid "Antialiased drawing"
msgstr "抗鋸齒繪圖"

msgid ""
"Godot offers method parameters "
"in :ref:`draw_line<class_CanvasItem_method_draw_line>` to enable "
"antialiasing, but not all custom drawing methods offer this ``antialiased`` "
"parameter."
msgstr ""
"Godot在 :ref:`draw_line<class_CanvasItem_method_draw_line>` 中提供方法參數來"
"啟用抗鋸齒功能，但並非所有自訂繪圖方法都提供這個 ``抗鋸齒（antialiased）`` 參"
"數。"

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"對於不提供 ``抗鋸齒（antialiased）`` 參數的自訂繪圖方法，你可以啟用 2D MSAA，"
"這會影響整個視口的算繪。這個功能（2D MSAA）提供了高品質的抗鋸齒，但性能成本更"
"高，而且只適用於特定元素。參見 :ref:`doc_2d_antialiasing` 以瞭解更多資訊。"

msgid ""
"Here is a comparison of a line of minimal width (``width=-1``) drawn with "
"``antialiased=false``, ``antialiased=true``, and ``antialiased=false`` with "
"2D MSAA 2x, 4x, and 8x enabled."
msgstr ""
"下圖比較了最小寬度（``width=-1``）的線條在 ``antialiased=false``、"
"``antialiased=true``，以及啟用 2D MSAA 2x、4x、8x（``antialiased=false``）下"
"的效果。"

msgid "Tools"
msgstr "工具"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior."
msgstr ""
"有時你也會希望在編輯器中運行節點時自訂繪圖，這可以用來做功能或行為的預覽與視"
"覺化。"

msgid ""
"To do this, you can use the :ref:`tool annotation<doc_gdscript_tool_mode>` "
"on both GDScript and C#. See :ref:`the example "
"below<doc_draw_show_drawing_while_editing_example>` "
"and :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"你可以在 GDScript 和 C# 中使用 :ref:`tool "
"annotation<doc_gdscript_tool_mode>` 來達成這個效果。更多資訊請參考下方 :ref:`"
"範例<doc_draw_show_drawing_while_editing_example>` 以"
"及 :ref:`doc_running_code_in_the_editor`。"

msgid "Example 1: drawing a custom shape"
msgstr "範例 1：繪製自訂形狀"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. We will recreate the "
"Godot logo but with code- only using drawing functions."
msgstr ""
"現在我們會用 Godot 的自訂繪圖功能，畫出 Godot 內建函式無法直接繪製的東西。我"
"們將用程式碼，純粹用繪圖指令重現 Godot 標誌。"

msgid "You will have to code a function to perform this and draw it yourself."
msgstr "你需要自行寫一個函式來完成這個繪圖。"

msgid ""
"The following instructions use a fixed set of coordinates that could be too "
"small for high resolution screens (larger than 1080p). If that is your case, "
"and the drawing is too small consider increasing your window scale in the "
"project setting :ref:`Display > Window > Stretch > "
"Scale<class_ProjectSettings_property_display/window/stretch/scale>` to "
"adjust the project to a higher resolution (a 2 or 4 scale tends to work "
"well)."
msgstr ""
"以下教學會使用固定座標集，這在高解析度螢幕（大於 1080p）下可能會顯得太小。如"
"果你遇到這種情況，可以在專案設定的 :ref:`Display > Window > Stretch > "
"Scale<class_ProjectSettings_property_display/window/stretch/scale>` 中調高視"
"窗縮放比例（2 或 4 通常效果不錯），以因應高解析度顯示。"

msgid "Drawing a custom polygon shape"
msgstr "繪製自訂多邊形"

msgid ""
"While there is a dedicated node to draw custom polygons ( :ref:`Polygon2D "
"<class_Polygon2D>`), we will use in this case exclusively lower level "
"drawing functions to combine them on the same node and be able to create "
"more complex shapes later on."
msgstr ""
"雖然有專門用來繪製自訂多邊形的節點（:ref:`Polygon2D <class_Polygon2D>`），但"
"這裡我們只用較低階的繪圖函式，將所有形狀畫在同一個節點上，這樣之後也方便擴充"
"出更複雜的圖形。"

msgid ""
"First, we will define a set of points -or X and Y coordinates- that will "
"form the base of our shape:"
msgstr "首先，我們要定義一組點（X 和 Y 座標），作為這個形狀的基礎："

msgid ""
"This format, while compact, is not the one that Godot understands to draw a "
"polygon. In a different scenario we could have to load these coordinates "
"from a file or calculate the positions while the application is running, so "
"some transformation may be needed."
msgstr ""
"這種格式雖然精簡，但 Godot 並不直接支援用來繪製多邊形。在不同情境下，你可能需"
"要從檔案讀取這些座標，或在執行時動態計算，因此可能要進行額外的轉換。"

msgid ""
"To transform these coordinates into the right format, we will create a new "
"method ``float_array_to_Vector2Array()``. Then we will override the "
"``_ready()`` function, which Godot will call only once -at the start of the "
"execution- to load those coordinates into a variable:"
msgstr ""
"為了將這些座標轉換成 Godot 可用的格式，我們會寫一個新的方法 "
"``float_array_to_Vector2Array()``。接著覆寫 ``_ready()`` 函式（Godot 會在執行"
"開始時只呼叫一次），將這些座標載入變數："

msgid ""
"To finally draw our first shape, we will use the method :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>` and pass the points (as an array of "
"Vector2 coordinates) and its color, like this:"
msgstr ""
"最後，我們會使用 :ref:`draw_polygon <class_CanvasItem_method_draw_polygon>` "
"方法來繪製這個形狀，傳入點的陣列（Vector2 格式）和顏色，如下所示："

msgid "When running it you should see something like this:"
msgstr "執行時你應該會看到類似這樣的畫面："

msgid ""
"Note the lower part of the logo looks segmented- this is because a low "
"amount of points were used to define that part. To simulate a smooth curve, "
"we could add more points to our array, or maybe use a mathematical function "
"to interpolate a curve and create a smooth shape from code "
"(see :ref:`example 2<doc_draw_custom_example_2>`)."
msgstr ""
"請注意，Logo 下半部看起來呈現分段狀，這是因為這部分只用了少量點來定義。若想要"
"模擬平滑曲線，可以在陣列中增加更多點，或用數學函式來插值產生曲線，直接在程式"
"碼中建立平滑形狀（詳見 :ref:`範例 2<doc_draw_custom_example_2>`）。"

msgid ""
"Polygons will always **connect its last defined point to its first one** in "
"order to have a closed shape."
msgstr "多邊形會自動將最後一個點與第一個點連接，形成封閉形狀。"

msgid "Drawing connected lines"
msgstr "繪製連續線段"

msgid ""
"Drawing a sequence of connected lines that don't close down to form a "
"polygon is very similar to the previous method. We will use a connected set "
"of lines to draw Godot's logo mouth."
msgstr ""
"繪製一串不封閉成多邊形的連續線段，其方式與前述方法相似。我們會用連續線段來繪"
"製 Godot 標誌上的嘴巴。"

msgid ""
"First, we will define the list of coordinates that form the mouth shape, "
"like this:"
msgstr "首先，定義構成嘴巴形狀的座標列表，如下所示："

msgid ""
"We will load these coordinates into a variable and define an additional "
"variable with the configurable line thickness:"
msgstr "我們會將這些座標載入一個變數，並另外定義一個可調整的線寬變數："

msgid ""
"And finally we will use the method :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>` to actually draw the line, like "
"this:"
msgstr ""
"最後，我們用 :ref:`draw_polyline <class_CanvasItem_method_draw_polyline>` 方"
"法來真正畫出這條線，如下："

msgid "You should get the following output:"
msgstr "你應該會看到以下結果："

msgid ""
"Unlike ``draw_polygon()``, polylines can only have a single unique color for "
"all its points (the second argument). This method has 2 additional "
"arguments: the width of the line (which is as small as possible by default) "
"and enabling or disabling the antialiasing (it is disabled by default)."
msgstr ""
"和 ``draw_polygon()`` 不同的是，polyline 只能為所有點指定一個單一顏色（第二個"
"參數）。這個方法還有兩個額外參數：線寬（預設為最細），以及是否啟用抗鋸齒（預"
"設關閉）。"

msgid ""
"The order of the ``_draw`` calls is important- like with the Node positions "
"on the tree hierarchy, the different shapes will be drawn from top to "
"bottom, resulting in the latest shapes hiding earlier ones if they overlap. "
"In this case we want the mouth drawn over the head, so we put it afterwards."
msgstr ""
"``_draw`` 的呼叫順序很重要——就像場景樹中的節點一樣，繪圖會從上到下依序執行，"
"被後畫的圖形會覆蓋在前面的圖形上。如果兩個圖形重疊，最晚繪製的會蓋住之前的。"
"在這個例子中，我們希望嘴巴畫在頭的上方，所以將其放在後面。"

msgid ""
"Notice how we can define colors in different ways, either with a hexadecimal "
"code or a predefined color name. Check the class :ref:`Color <class_Color>` "
"for other constants and ways to define Colors."
msgstr ""
"注意，我們可以用不同的方式定義顏色，例如十六進位色碼或預設顏色名稱。更多常數"
"和顏色定義方式請參考 :ref:`Color <class_Color>` 類別。"

msgid "Drawing circles"
msgstr "繪製圓形"

msgid ""
"To create the eyes, we are going to add 4 additional calls to draw the eye "
"shapes, in different sizes, colors and positions."
msgstr ""
"要畫出眼睛，我們會額外呼叫 4 次繪圖函式，分別以不同的大小、顏色與位置來畫出眼"
"睛的形狀。"

msgid ""
"To draw a circle, you position it based on its center using "
"the :ref:`draw_circle <class_CanvasItem_method_draw_circle>` method. The "
"first parameter is a :ref:`Vector2<class_Vector2>` with the coordinates of "
"its center, the second is its radius, and the third is its color:"
msgstr ""
"要畫圓形，可以用 :ref:`draw_circle <class_CanvasItem_method_draw_circle>` 方"
"法，指定圓心的位置（以 :ref:`Vector2<class_Vector2>` 表示）、半徑與顏色："

msgid "When executing it, you should have something like this:"
msgstr "執行時你應該會看到這樣的畫面："

msgid ""
"For partial, unfilled arcs (portions of a circle shape between certain "
"arbitrary angles), you can use the method :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."
msgstr ""
"若要繪製不填滿的圓弧（由特定角度決定的圓的一部分），可以用 :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>` 方法。"

msgid "Drawing lines"
msgstr "繪製線條"

msgid ""
"To draw the final shape (the nose) we will use a line to approximate it."
msgstr "最後要繪製鼻子這個形狀時，我們會用一條線來近似。"

msgid ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` can be used to draw a "
"single segment by providing its start and end coordinates as arguments, like "
"this:"
msgstr ""
"你可以用 :ref:`draw_line <class_CanvasItem_method_draw_line>` 方法來畫一段線"
"段，只需提供起點和終點座標，如下："

msgid "You should now be able to see the following shape on screen:"
msgstr "現在你應該能在螢幕上看到下列形狀："

msgid ""
"Note that if multiple unconnected lines are going to be drawn at the same "
"time, you may get additional performance by drawing all of them in a single "
"call, using the :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` method."
msgstr ""
"注意，如果要同時畫多條不連接的線段，可以用 :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` 方法一次畫出所有線段，這樣效能會更"
"好。"

msgid "Drawing text"
msgstr "繪製文字"

msgid ""
"While using the :ref:`Label <class_Label>` Node is the most common way to "
"add text to your application, the low-level `_draw` function includes "
"functionality to add text to your custom Node drawing. We will use it to add "
"the name \"GODOT\" under the robot head."
msgstr ""
"雖然最常見的文字顯示方法是使用 :ref:`Label <class_Label>` 節點，但底層的 "
"`_draw` 函式也能讓你在自訂節點繪圖中加入文字。我們會用這個方法在機器人頭下方"
"加上「GODOT」字樣。"

msgid ""
"We will use the :ref:`draw_string <class_CanvasItem_method_draw_string>` "
"method to do it, like this:"
msgstr ""
"這裡我們會用 :ref:`draw_string <class_CanvasItem_method_draw_string>` 方法來"
"達成："

msgid ""
"Here we first load into the defaultFont variable the configured default "
"theme font (a custom one can be set instead) and then we pass the following "
"parameters: font, position, text, horizontal alignment, width, and font size."
msgstr ""
"這裡我們先將預設主題字型載入到 defaultFont 變數（你也可以用自訂字型），接著傳"
"入參數：字型、位置、文字內容、水平對齊方式、寬度，以及字體大小。"

msgid "You should see the following on your screen:"
msgstr "你應該會在螢幕上看到下列畫面："

msgid ""
"Additional parameters as well as other methods related to text and "
"characters can be found on the :ref:`CanvasItem <class_CanvasItem>` class "
"reference."
msgstr ""
"更多文字相關的參數與方法，請參考 :ref:`CanvasItem <class_CanvasItem>` 類別說"
"明文件。"

msgid "Show the drawing while editing"
msgstr "在編輯時顯示繪圖"

msgid ""
"While the code so far is able to draw the logo on a running window, it will "
"not show up on the ``2D view`` on the editor. In certain cases you would "
"also like to show your custom Node2D or control on the editor, to position "
"and scale it appropriately, like most other nodes do."
msgstr ""
"目前為止的程式碼雖然能在執行時畫出 logo，但在編輯器的「2D 檢視」中並不會顯"
"示。有些情況下，你也會希望自訂的 Node2D 或控制項能在編輯器中顯示，方便定位和"
"調整大小，就像其他節點一樣。"

msgid ""
"To show the logo directly on the editor (without running it), you can use "
"the :ref:`@tool<doc_gdscript_tool_mode>` annotation to request the custom "
"drawing of the node to also appear while editing, like this:"
msgstr ""
"若要讓 logo 直接在編輯器中顯示（不執行時也能看見），你可以加"
"上 :ref:`@tool<doc_gdscript_tool_mode>` 註解，讓自訂節點的繪圖也會在編輯時出"
"現，例如："

msgid ""
"You will need to save your scene, rebuild your project (for C# only) and "
"reload the current scene manually at the menu option ``Scene > Reload Saved "
"Scene`` to refresh the current node in the ``2D`` view the first time you "
"add or remove the ``@tool`` annotation."
msgstr ""
"在你第一次新增或移除 ``@tool`` 註解後，需要儲存場景，並（C# 專案）重新編譯，"
"再從選單選取「場景 > 重新載入已儲存場景」刷新 ``2D`` 檢視，這樣才能看到節點的"
"最新繪圖。"

msgid "Animation"
msgstr "動畫"

msgid ""
"If we wanted to make the custom shape change at runtime, we could modify the "
"methods called or its arguments at execution time, or apply a transform."
msgstr ""
"如果想在執行時讓自訂形狀變化，可以在執行期間修改呼叫的方法或其參數，或是套用"
"變換。"

msgid ""
"For example, if we want the custom shape we just designed to rotate, we "
"could add the following variable and code to the ``_ready`` and ``_process`` "
"methods:"
msgstr ""
"例如，若想讓剛剛設計的自訂形狀旋轉，可以在 ``_ready`` 和 ``_process`` 方法中"
"加上以下變數與程式碼："

msgid ""
"The problem with the above code is that because we have created the points "
"approximately on a rectangle starting from the upper left corner, the ``(0, "
"0)`` coordinate and extending to the right and down, we see that the "
"rotation is done using the top left corner as pivot. A position transform "
"change on the node won't help us here, as the rotation transform is applied "
"first."
msgstr ""
"上面的程式碼有個問題：由於我們的點是從左上角 ``(0, 0)`` 開始，一路往右下建"
"立，因此旋轉時會以左上角為中心。單純改變節點的位置變換沒辦法解決，因為旋轉變"
"換會先套用。"

msgid ""
"While we could rewrite all of the points' coordinates to be centered around "
"``(0, 0)``, including negative coordinates, that would be a lot of work."
msgstr ""
"雖然我們可以將所有點的座標重寫成以 ``(0, 0)`` 為中心（包含負座標），但這樣會"
"相當麻煩。"

msgid ""
"One possible way to work around this is to use the lower "
"level :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"method to fix this issue, translating all points in the CanvasItem's own "
"space, and then moving it back to its original place with a regular node "
"transform, either in the editor or in code, like this:"
msgstr ""
"一個解決方式是用較低階"
"的 :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` 方"
"法，先把所有點在 CanvasItem 的座標空間中平移，把中心移到你想要的軸心，然後再"
"用節點的平移將它移回原本位置（可在編輯器或程式中設定），像這樣："

msgid "This is the result, rotating around a pivot now on ``(60, 60)``:"
msgstr "這樣結果就會繞著 ``(60, 60)`` 為中心旋轉："

msgid ""
"If what we wanted to animate was a property inside the ``_draw()`` call, we "
"must remember to call ``queue_redraw()`` to force a refresh, as otherwise it "
"would not be updated on screen."
msgstr ""
"如果想讓 ``_draw()`` 中的某個屬性產生動畫，要記得呼叫 ``queue_redraw()`` 強制"
"重繪，否則畫面不會即時更新。"

msgid ""
"For example, this is how we can make the robot appear to open and close its "
"mouth, by changing the width of its mouth line follow a sinusoidal "
"(:ref:`sin<class_@globalscope_method_sin>`) curve:"
msgstr ""
"例如，我們可以改變機器人嘴巴的線段寬度，讓它看起來像是在張嘴和閉嘴，讓寬度隨"
"著正弦波（:ref:`sin<class_@globalscope_method_sin>`）變化："

msgid "It will look somewhat like this when run:"
msgstr "執行時大致會長這樣："

msgid ""
"Please note that ``_mouth_width`` is a user defined property like any other "
"and it or any other used as a drawing argument can be animated using more "
"standard and high-level methods such as a :ref:`Tween<class_Tween>` or "
"an :ref:`AnimationPlayer<class_AnimationPlayer>` Node. The only difference "
"is that a ``queue_redraw()`` call is needed to apply those changes so they "
"get shown on screen."
msgstr ""
"請注意，``_mouth_width`` 和其他自訂屬性一樣，也可以用更高階的方式（例"
"如 :ref:`Tween<class_Tween>` "
"或 :ref:`AnimationPlayer<class_AnimationPlayer>` 節點）來製作動畫。唯一的差別"
"是，你必須呼叫 ``queue_redraw()`` 才會讓螢幕及時顯示動畫效果。"

msgid "Example 2: drawing a dynamic line"
msgstr "範例 2：繪製動態線段"

msgid ""
"The previous example was useful to learn how to draw and modify nodes with "
"custom shapes and animations. This could have some advantages, such as using "
"exact coordinates and vectors for drawing, rather than bitmaps -which means "
"they will scale well when transformed on screen. In some cases, similar "
"results could be achieved composing higher level functionality with nodes "
"such as :ref:`sprites<class_Sprite2D>` "
"or :ref:`AnimatedSprites<class_AnimatedSprite2D>` loading SVG resources "
"(which are also images defined with vectors) and "
"the :ref:`AnimationPlayer<class_AnimationPlayer>` node."
msgstr ""
"前面的範例讓你學會了如何用自訂形狀和動畫來繪製和修改節點。這種做法有一些優"
"點，例如可用精確座標與向量繪圖（不是用點陣圖），因此在螢幕縮放時會維持品質。"
"有時候也可以用更高階的元件組合出類似效果，例如"
"用 :ref:`Sprite2D<class_Sprite2D>`、:ref:`AnimatedSprite2D<class_AnimatedSprite2D>` "
"載入 SVG 資源（SVG 也是向量圖），搭"
"配 :ref:`AnimationPlayer<class_AnimationPlayer>` 節點。"

msgid ""
"In other cases that will not be possible because we will not know what the "
"resulting graphical representation will be before running the code. Here we "
"will see how to draw a dynamic line whose coordinates are not known "
"beforehand, and are affected by the user's input."
msgstr ""
"有些情況下，執行前並不知道圖形的最終樣貌，因此無法預先準備。這裡我們會示範如"
"何畫出一條座標未知、會根據使用者輸入動態變化的線段。"

msgid "Drawing a straight line between 2 points"
msgstr "繪製兩點之間的直線"

msgid ""
"Let's assume we want to draw a straight line between 2 points, the first one "
"will be fixed on the upper left corner ``(0, 0)`` and the second will be "
"defined by the cursor position on screen."
msgstr ""
"假設我們要畫一條連接兩點的直線，第一個點固定在左上角 ``(0, 0)``，第二個點則由"
"螢幕上的游標位置決定。"

msgid "We could draw a dynamic line between those 2 points like this:"
msgstr "可以用下列方式畫出這兩點之間的動態直線："

msgid ""
"In this example we obtain the position of the mouse in the default viewport "
"every frame with the method :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. If the position has changed "
"since the last draw request (a small optimization to avoid redrawing on "
"every frame)- we will schedule a redraw. Our ``_draw()`` method only has one "
"line: requesting the drawing of a green line of width 10 pixels between the "
"top left corner and that obtained position."
msgstr ""
"這個範例中，我們每一禎都"
"用 :ref:`get_mouse_position<class_Viewport_method_get_mouse_position>` 取得滑"
"鼠在預設視口中的位置。如果位置自上次繪製以來有變化（這樣可以避免每一禎都重"
"繪），就安排重繪。``_draw()`` 方法只會畫一條線：從左上角到滑鼠位置的綠色線"
"段，寬度為 10 像素。"

msgid ""
"The width, color, and position of the starting point can be configured with "
"with the corresponding properties."
msgstr "線段的寬度、顏色和起點位置都可以用對應的屬性來設定。"

msgid "It should look like this when run:"
msgstr "執行時效果如下："

msgid "Drawing an arc between 2 points"
msgstr "繪製兩點之間的圓弧"

msgid ""
"The above example works, but we may want to join those 2 points with a "
"different shape or function, other than a straight line."
msgstr ""
"上面的範例可以運作，不過有時候你可能想用直線以外的形狀或方式連接這兩個點。"

msgid ""
"Let's try now creating an arc (a portion of a circumference) between both "
"points."
msgstr "這次我們試著在兩點間畫出一段圓弧（圓的一部分）。"

msgid ""
"Exporting the line starting point, segments, width, color, and antialiasing "
"will allow us to modify those properties very easily directly from the "
"editor inspector panel:"
msgstr ""
"如果將線的起點、分段數、寬度、顏色與抗鋸齒等屬性導出（export），就可以直接在"
"編輯器屬性面板輕鬆調整這些參數："

msgid ""
"To draw the arc, we can use the "
"method :ref:`draw_arc<class_CanvasItem_method_draw_arc>`. There are many "
"arcs that pass through 2 points, so we will chose for this example the "
"semicircle that has its center in the middle point between the 2 initial "
"points."
msgstr ""
"畫圓弧時，可以用 :ref:`draw_arc<class_CanvasItem_method_draw_arc>` 方法。能通"
"過兩點的圓弧有很多種，這裡我們選擇將圓心設在這兩點的中點，畫出一段半圓。"

msgid "Calculating this arc will be more complex than in the case of the line:"
msgstr "計算這段圓弧會比直線稍微複雜一點："

msgid ""
"The center of the semicircle will be the middle point between both points. "
"The radius will be half the distance between both points. The start and end "
"angles will be the angles of the vector from point1 to point2 and vice-"
"versa. Note we had to normalize the ``end_angle`` in positive values because "
"if ``end_angle`` is less than ``start_angle``, the arc will be drawn counter-"
"clockwise, which we don't want in this case (the arc would be upside-down)."
msgstr ""
"這裡半圓的圓心會設在兩點的中點，半徑是兩點距離的一半。起始角度和結束角度分別"
"是 point1 到 point2 或從 point2 到 point1 的向量角度。注意我們要把 "
"``end_angle`` 轉成正值，否則如果 ``end_angle`` 小於 ``start_angle``，圓弧會逆"
"時針繪製（這不是我們想要的，因為這樣會畫在上方）。"

msgid ""
"The result should be something like this, with the arc going down and "
"between the points:"
msgstr "結果應該會如下圖，圓弧往下並連接兩點："

msgid ""
"Feel free to play with the parameters in the inspector to obtain different "
"results: change the color, the width, the antialiasing, and increase the "
"number of segments to increase the curve smoothness, at the cost of extra "
"performance."
msgstr ""
"你可以隨意在屬性面板調整這些參數，獲得不同效果：改變顏色、線寬、抗鋸齒或增加"
"分段數讓曲線更平滑（但會消耗更多效能）。"
