#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "使用 InputEvent"

msgid "What is it?"
msgstr "什麼是 InputEvent？"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"無論在任何作業系統或平台上，管理輸入通常都很複雜。為了簡化這個過程，Godot 提"
"供了一個特殊的內建型別 :ref:`InputEvent <class_InputEvent>`。這個型別可以被設"
"為包含多種輸入事件。輸入事件會在引擎中流動，並根據用途在多個位置被接收。"

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "以下是一個簡單範例：當按下 Escape 鍵時關閉遊戲："

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"然而，更乾淨且靈活的做法是使用 Godot 提供的 :ref:`InputMap <class_InputMap>` "
"功能，可讓你定義輸入動作並分配多個不同按鍵。如此一來，你可以將多個按鍵（如鍵"
"盤的 ESC 與手把的開始鍵）對應到同一個動作。你也可以在專案設定中輕鬆變更對應，"
"無需修改程式碼，甚至可以擴充成遊戲內的自訂按鍵功能，讓玩家於執行時變更操作按"
"鍵！"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"你可以在 **專案 > 專案設定 > 輸入對應** 下設定你的 InputMap，並像這樣使用這些"
"動作："

msgid "How does it work?"
msgstr "它的運作方式是什麼？"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"每個輸入事件最初來自使用者／玩家（當然，也可以自行產生 InputEvent 並餵給引"
"擎，這在手勢等應用時很有用）。各平台的 DisplayServer 會從作業系統讀取事件，然"
"後傳遞給根 :ref:`Window <class_Window>`。"

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"視窗的 :ref:`Viewport <class_Viewport>` 會依序對收到的輸入事件執行多項處理："

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"如果 Viewport 內嵌了 Window，Viewport 會以視窗管理員的角色解讀事件（例如調整 "
"Window 大小或移動視窗）。"

msgid ""
"Next if an embedded Window is focused, the event is sent to that Window and "
"processed in the Window's Viewport and afterwards treated as handled. If no "
"embedded Window is focused, the event is sent to the nodes of the current "
"viewport in the following order."
msgstr ""
"接著，若有內嵌 Window 取得焦點，事件會送往該 Window 並於其 Viewport 中處理，"
"之後視為已處理。若沒有內嵌 Window 聚焦，事件會依下列順序傳遞給目前視口的節"
"點。"

msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing "
"with :ref:`Node.set_process_input() <class_Node_method_set_process_input>`). "
"If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"首先，會呼叫任何有覆寫 :ref:`Node._input() "
"<class_Node_private_method__input>` 的節點（且未"
"用 :ref:`Node.set_process_input() <class_Node_method_set_process_input>` 停用"
"輸入處理）。若事件在此被消耗，可以呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` 阻止事件繼續傳播。這確保你可以"
"在 GUI 之前就攔截感興趣的事件。對於遊戲主要輸入，通常建議"
"用 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`，因為這讓 GUI 有機會優先處理。"

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will "
"call :ref:`Control.accept_event() <class_Control_method_accept_event>` and "
"the event will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether "
"a :ref:`Control <class_Control>` is notified of mouse events "
"via :ref:`Control._gui_input() <class_Control_private_method__gui_input>` "
"callback, and whether these events are propagated further."
msgstr ""
"其次，系統會嘗試將輸入傳遞至 GUI，看有無控制項可接收。若有，將會呼"
"叫 :ref:`Control <class_Control>` 的虛擬方法 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`，並發出 \"gui_input\" 訊號（此方法"
"可於腳本繼承時覆寫）。若控制項需「消耗」該事件，會呼"
"叫 :ref:`Control.accept_event() <class_Control_method_accept_event>`，事件便"
"不再繼續傳遞。你可透過 :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` 屬性，控制 :ref:`Control "
"<class_Control>` 是否透過 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` 回呼接收滑鼠事件，以及事件是否會繼"
"續傳遞。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only "
"for :ref:`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"如果事件尚未被消耗，且有覆寫 :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>`（且未"
"用 :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>` 停用），則會呼叫該回呼。這僅"
"針對 :ref:`InputEventKey <class_InputEventKey>`、:ref:`InputEventShortcut "
"<class_InputEventShortcut>` 與 :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`。如事件被消耗，可呼"
"叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` 阻止事件繼續傳播。此回呼非常適"
"合處理快捷鍵相關事件。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled "
"with :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is an :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"如果事件尚未被消耗，且有覆寫 :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>`（且未"
"用 :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>` 停用），則會呼叫該回呼。"
"這僅當事件為 :ref:`InputEventKey <class_InputEventKey>` 時才會發生。如事件被"
"消耗，可呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` 阻止事件繼續傳播。這個回呼很適"
"合處理鍵盤事件。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"如果事件仍未被消耗，且有覆寫 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`（且未"
"用 :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>` 停用），則會呼叫該回呼。若有"
"函式消耗事件，可呼叫 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>` 阻止事件繼續傳播。這個回呼很適"
"合處理全螢幕遊戲事件（GUI 元件啟用時不會收到）。"

msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled "
"in :ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"如果事件到現在都沒被消耗，且已啟用 :ref:`物件選取 "
"<class_viewport_property_physics_object_picking>`，則該事件會用於物件選取。對"
"於根視口，也可在 :ref:`專案設定 <class_ProjectSettings_property_physics/"
"common/enable_object_picking>` 啟用此功能。若是 3D 場景且 Viewport 有指"
"派 :ref:`Camera3D <class_Camera3D>`，則會從點擊方向發射射線到物理世界，命中物"
"件時會呼叫該物件的 :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>`。2D 場景則同理，呼"
"叫 :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`。"

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"將事件傳送給所有子孫節點時，Viewport 會採用反向深度優先順序：從場景樹底層節點"
"到根節點。Window 與 SubViewport 不參與此流程。"

msgid ""
"This order doesn't apply to :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, which uses a different method "
"based on event location or focused Control. GUI **mouse** events also travel "
"up the scene tree, subject to the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` restrictions described above. "
"However, since these events target specific Controls, only direct ancestors "
"of the targeted Control node receive the event. GUI **keyboard and joypad** "
"events *do not* travel up the scene tree, and can only be handled by the "
"Control that received them. Otherwise, they will be propagated as non-GUI "
"events through :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`."
msgstr ""
"這個順序不適用於 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`，GUI 事件的分派會依事件位置或焦點"
"控制元件而異。GUI **滑鼠** 事件也會沿著場景樹向上傳遞，受限於前述"
"的 :ref:`Control.mouse_filter <class_Control_property_mouse_filter>` 設定。不"
"過，這類事件只會傳給目標 Control 節點的直接父系。GUI **鍵盤和手把** 事件則*不"
"會*沿場景樹傳遞，只能由收到事件的控制元件處理，否則會以非 GUI 事件形式傳遞"
"至 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`。"

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"由於 Viewport 不會將事件傳遞給其他 :ref:`SubViewport <class_SubViewport>`，你"
"必須使用下列其中一種方法："

msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
"使用 :ref:`SubViewportContainer <class_SubViewportContainer>`，它會"
"在 :ref:`Node._input() <class_Node_private_method__input>` "
"或 :ref:`Control._gui_input() <class_Control_private_method__gui_input>` 執行"
"後，自動將事件傳送給其子 :ref:`SubViewports <class_SubViewport>`。"

msgid "Implement event propagation based on the individual requirements."
msgstr "根據自身需求實作事件傳遞邏輯。"

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"這符合 Godot 節點導向設計，使專用子節點能處理並消耗特定事件，而父級或場景根節"
"點則可依需要提供更一般性的行為。"

msgid "Anatomy of an InputEvent"
msgstr "InputEvent 結構解析"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` 只是基本的內建類型，不代表任何特定事件，"
"只包含基本資訊，如事件 ID（每個事件遞增）、裝置索引等。"

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr "InputEvent 有多種專門型別，說明如下表所示："

msgid "Event"
msgstr "事件"

msgid "Description"
msgstr "說明"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "空輸入事件。"

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "包含一個按鍵碼、Unicode 值，以及修飾鍵。"

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr "包含點擊資訊，例如按鈕、修飾鍵等。"

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr "包含移動資訊，如相對／絕對位置與速度。"

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "包含搖桿／手把類比軸資訊。"

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "包含搖桿／手把按鈕資訊。"

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr "包含多點觸控的按下／釋放資訊。（僅限行動裝置）"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr "包含多點觸控的拖曳資訊。（僅限行動裝置）"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "包含位置、縮放係數與修飾鍵。"

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr "包含位置、位移量與修飾鍵。"

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr ":ref:`InputEventMIDI <class_InputEventMIDI>`"

msgid "Contains MIDI-related information."
msgstr "包含 MIDI 相關資訊。"

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr ":ref:`InputEventShortcut <class_InputEventShortcut>`"

msgid "Contains a shortcut."
msgstr "包含一組快捷鍵。"

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr "包含一般動作。這類事件通常由開發者作為回饋手動產生。（詳見下文）"

msgid "Input actions"
msgstr "輸入動作"

msgid ""
"Input actions are a grouping of zero or more InputEvents into a commonly "
"understood title (for example, the default \"ui_left\" action grouping both "
"joypad-left input and a keyboard's left arrow key). They are not required to "
"represent an InputEvent but are useful because they abstract various inputs "
"when programming the game logic."
msgstr ""
"輸入動作是將零個或多個 InputEvent 群組成一個容易理解的名稱（例如預設的"
"「ui_left」可同時代表手把左鍵和鍵盤左方向鍵）。動作本身不一定要對應單一 "
"InputEvent，但這種抽象化設計能讓你在撰寫遊戲邏輯時同時支援多種輸入裝置。"

msgid "This allows for:"
msgstr "這能帶來下列好處："

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr "相同程式碼適用於不同裝置的不同輸入（如 PC 鍵盤與主機手把）。"

msgid "Input to be reconfigured at runtime."
msgstr "可於執行時重新設定輸入對應。"

msgid "Actions to be triggered programmatically at runtime."
msgstr "可於程式中在執行時自動觸發動作。"

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr "你可以在「專案設定」的 **輸入對應** 分頁建立動作並分配輸入事件。"

msgid ""
"Any event has the methods :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`, :ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` and :ref:`InputEvent.is_echo() "
"<class_InputEvent_method_is_echo>`."
msgstr ""
"任何事件都具備 :ref:`InputEvent.is_action() "
"<class_InputEvent_method_is_action>`、:ref:`InputEvent.is_pressed() "
"<class_InputEvent_method_is_pressed>` 與 :ref:`InputEvent.is_echo() "
"<class_InputEvent_method_is_echo>` 這些方法。"

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"你也可以從遊戲程式碼主動送出一個動作（例如用於手勢偵測）。Input 單例物件提供"
"此功能：:ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`。通常你會這樣用："

msgid ""
"See :ref:`doc_first_3d_game_input_actions` for a tutorial on adding input "
"actions in the project settings."
msgstr ""
"關於如何在專案設定中新增輸入動作，請參"
"閱 :ref:`doc_first_3d_game_input_actions` 教學。"

msgid "InputMap"
msgstr "輸入映射表"

msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at runtime. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"從程式碼自訂與重映射輸入是常見需求。如果你的系統完全依賴動作，:ref:`InputMap "
"<class_InputMap>` 單例非常適合於執行時重新分配或建立不同動作。這個單例的狀態"
"不會自動儲存（需自行處理），其預設值來自專案設定（project.godot）。因此，任何"
"這類動態系統都須自行決定設定儲存方式。"
