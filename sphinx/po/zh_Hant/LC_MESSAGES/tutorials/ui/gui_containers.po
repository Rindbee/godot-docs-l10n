#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Containers"
msgstr "使用容器"

msgid ""
":ref:`Anchors <doc_size_and_anchors>` are an efficient way to handle "
"different aspect ratios for basic multiple resolution handling in GUIs."
msgstr ""
":ref:`錨點 <doc_size_and_anchors>` 是在 GUI 中進行基礎多解析度與不同螢幕比例"
"處理的高效方法。"

msgid "For more complex user interfaces, they can become difficult to use."
msgstr "對於更複雜的使用者介面，錨點就會變得難以操作。"

msgid ""
"This is often the case of games, such as RPGs, online chats, tycoons or "
"simulations. Another common case where more advanced layout features may be "
"required is in-game tools (or simply just tools)."
msgstr ""
"這通常發生在遊戲中，例如角色扮演、線上聊天、經營或模擬類型。另一個常見需要進"
"階佈局功能的場景是遊戲內工具（或一般工具）。"

msgid ""
"All these situations require a more capable OS-like user interface, with "
"advanced layout and formatting. For that, :ref:`Containers "
"<class_container>` are more useful."
msgstr ""
"這些情境都需要更強大、類似作業系統的使用者介面，具備進階佈局與格式功能。此"
"時，:ref:`Container <class_container>` 會更適合。"

msgid "Container layout"
msgstr "容器佈局"

msgid ""
"Containers provide a huge amount of layout power (as an example, the Godot "
"editor user interface is entirely done using them):"
msgstr ""
"容器提供了強大的佈局功能（例如，Godot 編輯器的使用者介面就是完全用容器製作"
"的）："

msgid ""
"When a :ref:`Container <class_Container>`-derived node is used, all "
"children :ref:`Control <class_Control>` nodes give up their own positioning "
"ability. This means the *Container* will control their positioning and any "
"attempt to manually alter these nodes will be either ignored or invalidated "
"the next time their parent is resized."
msgstr ""
"當你使用 :ref:`Container <class_Container>` 衍生節點時，所有作為子項"
"的 :ref:`Control <class_Control>` 節點都會放棄自身定位能力。這表示 *容器* 會"
"接管它們的位置控制，任何手動調整這些節點位置的動作，都會在父節點下次調整大小"
"時被忽略或覆蓋。"

msgid ""
"Likewise, when a *Container* derived node is resized, all its children will "
"be re-positioned according to it, with a behavior based on the type of "
"container used:"
msgstr ""
"同樣地，當 *Container* 衍生節點被調整大小時，它的所有子節點會根據容器類型自動"
"重新定位："

msgid "Example of *HBoxContainer* resizing children buttons."
msgstr "*HBoxContainer* 調整子按鈕大小的範例。"

msgid ""
"The real strength of containers is that they can be nested (as nodes), "
"allowing the creation of very complex layouts that resize effortlessly."
msgstr ""
"容器最大的優勢在於它們可以巢狀（作為節點），讓你能輕鬆建立可自動調整的複雜佈"
"局。"

msgid "Sizing options"
msgstr "尺寸選項"

msgid ""
"When adding a node to a container, the way the container treats each child "
"depends mainly on their *container sizing options*. These options can be "
"found by inspecting the layout of any *Control* that is a child of a "
"*Container*."
msgstr ""
"將節點加入容器時，容器如何處理每個子節點，主要取決於它們的 *尺寸旗標*。這些旗"
"標可在 *Container* 的子 *Control* 節點的佈局屬性中找到。"

msgid ""
"Sizing options are independent for vertical and horizontal sizing and not "
"all containers make use of them (but most do):"
msgstr ""
"尺寸旗標在垂直和水平方向上是獨立的，雖然不是每種容器都會用到，但大多數容器都"
"會使用這些旗標："

msgid ""
"**Fill**: Ensures the control *fills* the designated area within the "
"container. No matter if a control *expands* or not (see below), it will only "
"*fill* the designated area when this is toggled on (it is by default)."
msgstr ""
"**填充（Fill）**：確保控制項 *填滿* 容器內指定區域。不論控制項是否 *擴展*（見"
"下方），只有啟用這個選項時（預設為開啟），才會 *填充* 指定區域。"

msgid ""
"**Expand**: Attempts to use as much space as possible in the parent "
"container (in each axis). Controls that don't expand will be pushed away by "
"those that do. Between expanding controls, the amount of space they take "
"from each other is determined by the *Stretch Ratio* (see below). This "
"option is only available when the parent Container is of the right type, for "
"example the *HBoxContainer* has this option for horizontal sizing."
msgstr ""
"**擴展（Expand）**：在父容器內（於各軸）盡可能佔用空間。未啟用擴展的控制項會"
"被啟用擴展的控制項擠開。多個擴展控制項之間的空間分配，取決於 *比例（Stretch "
"Ratio）*（詳見下方）。此選項僅當父容器支援時才可用，例如 *HBoxContainer* 支援"
"水平擴展。"

msgid ""
"**Shrink Begin** When expanding, try to remain at the left or top of the "
"expanded area."
msgstr ""
"**收縮起始（Shrink Begin）**：當啟用擴展時，盡量保持在擴展區域的左側或頂部。"

msgid ""
"**Shrink Center** When expanding, try to remain at the center of the "
"expanded area."
msgstr ""
"**收縮置中（Shrink Center）**：當啟用擴展時，盡量保持在擴展區域的中央。"

msgid ""
"**Shrink End** When expanding, try to remain at the right or bottom of the "
"expanded area."
msgstr ""
"**收縮結尾（Shrink End）**：當啟用擴展時，盡量保持在擴展區域的右側或底部。"

msgid ""
"**Stretch Ratio**: The ratio of how much expanded controls take up the "
"available space in relation to each other. A control with \"2\", will take "
"up twice as much available space as one with \"1\"."
msgstr ""
"**比例（Stretch Ratio）**：決定多個啟用擴展的控制項相互分配可用空間的比例。例"
"如，比例設為「2」的控制項將獲得比例為「1」的兩倍空間。"

msgid ""
"Experimenting with these flags and different containers is recommended to "
"get a better grasp on how they work."
msgstr "建議實際嘗試這些旗標與不同類型的容器，以更深入理解它們的運作原理。"

msgid "Container types"
msgstr "容器類型"

msgid ""
"Godot provides several container types out of the box as they serve "
"different purposes:"
msgstr "Godot 內建多種容器類型，以因應不同的使用需求："

msgid "Box Containers"
msgstr "盒式容器"

msgid ""
"Arranges child controls vertically or horizontally (via :ref:`HBoxContainer "
"<class_HBoxContainer>` and :ref:`VBoxContainer <class_VBoxContainer>`). In "
"the opposite of the designated direction (as in, vertical for a horizontal "
"container), it just expands the children."
msgstr ""
"將子控制項依指定方向（垂直或水平）排列（分別為 :ref:`HBoxContainer "
"<class_HBoxContainer>` 和 :ref:`VBoxContainer <class_VBoxContainer>`）。在非"
"排列方向（例如水平方向的容器在垂直方向），子節點只會被擴展。"

msgid ""
"These containers make use of the *Stretch Ratio* property for children with "
"the *Expand* flag set."
msgstr ""
"這些容器會對啟用 *擴展（Expand）* 的子節點，套用 *比例（Stretch Ratio）* 屬"
"性。"

msgid "Grid Container"
msgstr "網格容器"

msgid ""
"Arranges child controls in a grid layout (via :ref:`GridContainer "
"<class_GridContainer>`, amount of columns must be specified). Uses both the "
"vertical and horizontal expand flags."
msgstr ""
"將子控制項以網格方式排列（使用 :ref:`GridContainer <class_GridContainer>`，須"
"設定欄數），同時支援垂直和水平擴展旗標。"

msgid "Margin Container"
msgstr "邊距容器"

msgid ""
"Child controls are expanded towards the bounds of this control "
"(via :ref:`MarginContainer <class_MarginContainer>`). Padding will be added "
"on the margins depending on the theme configuration."
msgstr ""
"子控制項會被擴展至本容器邊界（使用 :ref:`MarginContainer "
"<class_MarginContainer>`）。邊距（Padding）會依據主題設定自動加入。"

msgid ""
"Again, keep in mind that the margins are a *Theme* value, so they need to be "
"edited from the constants overrides section of each control:"
msgstr "請注意，邊距屬於 *主題* 設定值，需在各控制項的「常數覆寫」欄位中調整："

msgid "Tab Container"
msgstr "分頁容器"

msgid ""
"Allows you to place several child controls stacked on top of each other "
"(via :ref:`TabContainer <class_TabContainer>`), with only the *current* one "
"visible."
msgstr ""
"允許將多個子控制項堆疊（使用 :ref:`TabContainer <class_TabContainer>`），僅顯"
"示當前（*目前*）的那一個。"

msgid ""
"Changing the *current* one is done via tabs located at the top of the "
"container, via clicking:"
msgstr "可以透過點擊容器頂端的分頁來切換顯示 *目前* 的子控制項："

msgid ""
"The titles are generated from the node names by default (although they can "
"be overridden via *TabContainer* API)."
msgstr ""
"分頁標題預設會根據節點名稱產生（也可透過 *TabContainer* API 進行覆寫）。"

msgid ""
"Settings such as tab placement and *StyleBox* can be modified in the "
"*TabContainer* theme overrides."
msgstr "如分頁位置、*StyleBox* 等設定，可於 *TabContainer* 的主題覆寫中調整。"

msgid "Split Container"
msgstr "分割容器"

msgid ""
"Accepts only one or two children controls, then places them side to side "
"with a divisor (via :ref:`HSplitContainer <class_HSplitContainer>` "
"and :ref:`VSplitContainer <class_VSplitContainer>`). Respects both "
"horizontal and vertical flags, as well as *Ratio*."
msgstr ""
"僅接受一至兩個子控制項，並以分隔線並排顯示（使用 :ref:`HSplitContainer "
"<class_HSplitContainer>` 和 :ref:`VSplitContainer "
"<class_VSplitContainer>`）。支援水平與垂直旗標，以及 *比例* 屬性。"

msgid ""
"The divisor can be dragged around to change the size relation between both "
"children:"
msgstr "你可以拖曳分隔線來調整兩個子控制項的尺寸比例："

msgid "PanelContainer"
msgstr "PanelContainer"

msgid ""
"A container that draws a *StyleBox*, then expands children to cover its "
"whole area (via :ref:`PanelContainer <class_PanelContainer>`, respecting the "
"*StyleBox* margins). It respects both the horizontal and vertical sizing "
"options."
msgstr ""
"這個容器會繪製 *StyleBox*，並將子節點擴展覆蓋整個區域（通"
"過 :ref:`PanelContainer <class_PanelContainer>`，會考慮 *StyleBox* 邊距）。同"
"時支援水平與垂直尺寸選項。"

msgid ""
"This container is useful as a top-level control, or just to add custom "
"backgrounds to sections of a layout."
msgstr "這個容器適合用作頂層容器，也很適合為佈局區塊新增自訂背景。"

msgid "FoldableContainer"
msgstr "FoldableContainer"

msgid ""
"A container that can be expanded/collapsed (via :ref:`FoldableContainer "
"<class_FoldableContainer>`). Child controls are hidden when it is collapsed."
msgstr ""
"可展開/收合的容器（透過 :ref:`FoldableContainer "
"<class_FoldableContainer>`）。收合時會隱藏其子控制項。"

msgid "ScrollContainer"
msgstr "ScrollContainer"

msgid ""
"Accepts a single child node. If the child node is bigger than the container, "
"scrollbars will be added to allow panning the node around "
"(via :ref:`ScrollContainer <class_ScrollContainer>`). Both vertical and "
"horizontal size options are respected, and the behavior can be turned on or "
"off per axis in the properties."
msgstr ""
"只接受一個子節點。若子節點的尺寸大於容器，會加入捲動條以便平移該節點（透"
"過 :ref:`ScrollContainer <class_ScrollContainer>`）。垂直與水平的尺寸選項都會"
"被遵守，且可在屬性中針對各軸向啟用或停用此行為。"

msgid ""
"Mouse wheel and touch drag (when touch is available) are also valid ways to "
"pan the child control around."
msgstr "你也可以用滑鼠滾輪或觸控拖曳（若裝置支援）來移動子控制項。"

msgid ""
"As in the example above, one of the most common ways to use this container "
"is together with a *VBoxContainer* as child."
msgstr ""
"如上例所示，這個容器最常見的用法，是配合 *VBoxContainer* 作為子節點共同使用。"

msgid "AspectRatioContainer"
msgstr "比例容器"

msgid ""
"A container type that arranges its child controls in a way that preserves "
"their proportions automatically when the container is resized. "
"(via :ref:`AspectRatioContainer <class_AspectRatioContainer>`). It has "
"multiple stretch modes, providing options for adjusting the child controls' "
"sizes concerning the container: \"fill,\" \"width control height,\" \"height "
"control width,\" and \"cover.\""
msgstr ""
"這是一種會在容器調整大小時，自動保持子控制項長寬比例的容器（使"
"用 :ref:`AspectRatioContainer <class_AspectRatioContainer>`）。它具備多種伸展"
"模式，包括「填滿」、「寬度控制高度」、「高度控制寬度」及「覆蓋」等選項，可彈"
"性調整子控制項的尺寸"

msgid ""
"It is useful when you have a container that needs to be dynamic and "
"responsive to different screen sizes, and you want the child elements to "
"scale proportionally without losing their intended shapes."
msgstr ""
"當你需要讓容器能夠動態因應不同螢幕尺寸，並希望子元素能維持比例縮放而不失真"
"時，這個容器很實用。"

msgid "FlowContainer"
msgstr "流式容器"

msgid ""
"FlowContainer is a container that arranges its child controls either "
"horizontally or vertically (via :ref:`HFlowContainer <class_HFlowContainer>` "
"and via :ref:`VFlowContainer <class_VFlowContainer>`). When the available "
"space runs out, it wraps the children to the next line or column, similar to "
"how text wraps in a book."
msgstr ""
"FlowContainer 會將子控制項依水平方向或垂直方向排列（分別"
"為 :ref:`HFlowContainer <class_HFlowContainer>` 與 :ref:`VFlowContainer "
"<class_VFlowContainer>`）。當可用空間不足時，會自動換行或換欄，類似文字在書本"
"中的換行。"

msgid ""
"It is useful for creating flexible layouts where the child controls adjust "
"automatically to the available space without overlapping."
msgstr "這種容器適合建立彈性佈局，讓子控制項自動依可用空間調整排列，避免重疊。"

msgid "CenterContainer"
msgstr "置中容器"

msgid ""
"CenterContainer is a container that automatically keeps all of its child "
"controls centered within it at their minimum size. It ensures that the child "
"controls are always aligned to the center, making it easier to create "
"centered layouts without manual positioning (via :ref:`CenterContainer "
"<class_CenterContainer>`)."
msgstr ""
"置中容器會自動將所有子控制項以其最小尺寸置中對齊於容器內。不需手動調整，即可"
"輕鬆實現置中佈局（使用 :ref:`CenterContainer <class_CenterContainer>`）。"

msgid "SubViewportContainer"
msgstr "SubViewportContainer"

msgid ""
"This is a special control that will only accept a single *Viewport* node as "
"child, and it will display it as if it was an image "
"(via :ref:`SubViewportContainer <class_SubViewportContainer>`)."
msgstr ""
"這是個特殊控制項，只能接受單一 *Viewport* 節點作為子節點，並將其當作圖片顯示"
"（使用 :ref:`SubViewportContainer <class_SubViewportContainer>`）。"

msgid "Creating custom Containers"
msgstr "建立自訂容器"

msgid ""
"It is possible to create a custom container using a script. Here is an "
"example of a container that fits children to its size:"
msgstr "可以用腳本建立自訂容器。以下是一個會讓子節點適應自身大小的容器範例："
