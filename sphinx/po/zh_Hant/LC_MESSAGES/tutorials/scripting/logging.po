#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logging"
msgstr "記錄"

msgid "Godot comes with several ways to organize and collect log messages."
msgstr "Godot 提供多種方式來整理與蒐集日誌訊息。"

msgid "Printing messages"
msgstr "列印訊息"

msgid ""
"See :ref:`doc_output_panel_printing_messages` for instructions on printing "
"messages. The printed output is generally identical to the logged output."
msgstr ""
"關於如何列印訊息，請見 :ref:`doc_output_panel_printing_messages`。列印輸出通"
"常與記錄的輸出相同。"

msgid ""
"When running a project from the editor, the editor will display logged text "
"in the :ref:`doc_output_panel`."
msgstr "從編輯器執行專案時，編輯器會在 :ref:`doc_output_panel` 顯示日誌文字。"

msgid "Project settings"
msgstr "專案設定"

msgid ""
"There are several project settings to control logging behavior in Godot:"
msgstr "Godot 提供數個專案設定可控制日誌行為："

msgid ""
"**Application > Run > Disable stdout:** Disables logging to standard output "
"entirely. This also affects what custom loggers receive. This can be "
"controlled at runtime by setting :ref:`Engine.print_to_stdout "
"<class_Engine_property_print_to_stdout>`."
msgstr ""
"**Application > Run > Disable stdout:** 完全停用輸出到標準輸出的日誌。這也會"
"影響自訂記錄器所接收到的內容。執行時可透過設定 :ref:`Engine.print_to_stdout "
"<class_Engine_property_print_to_stdout>` 來控制."

msgid ""
"**Application > Run > Disable stderr:** Disables logging to standard error "
"entirely. This also affects what custom loggers receive. This can be "
"controlled at runtime by setting :ref:`Engine.print_error_messages "
"<class_Engine_property_print_error_messages>`."
msgstr ""
"**Application > Run > Disable stderr:** 完全停用輸出到標準錯誤的日誌。這也會"
"影響自訂記錄器所接收到的內容。執行時可透過設"
"定 :ref:`Engine.print_error_messages "
"<class_Engine_property_print_error_messages>` 來控制."

msgid ""
"**Debug > Settings > stdout > Verbose stdout:** Enables verbose logging to "
"standard output. Prints from :ref:`print_verbose() "
"<class_@GlobalScope_method_print_verbose>` are only visible if verbose mode "
"is enabled."
msgstr ""
"**Debug > Settings > stdout > Verbose stdout:** 啟用輸出到標準輸出的詳細日"
"誌。來自 :ref:`print_verbose() <class_@GlobalScope_method_print_verbose>` 的"
"輸出僅在啟用詳細模式時可見。"

msgid ""
"**Debug > Settings > stdout > Print FPS:** Prints the frames per second "
"every second, as well as the V-Sync status on startup (as it can effectively "
"cap the maximum framerate)."
msgstr ""
"**Debug > Settings > stdout > Print FPS:** 每秒列印每秒幀數, 並在啟動時列印 "
"V-Sync 狀態 (因為它會有效限制最大幀率)。"

msgid ""
"**Debug > Settings > stdout > Print GPU Profile:** Prints a report of GPU "
"utilization every second, using the same data source as "
"the :ref:`doc_debugger_panel_visual_profiler`."
msgstr ""
"**Debug > Settings > stdout > Print GPU Profile:** 每秒列印 GPU 使用狀況報"
"告, 資料來源與 :ref:`doc_debugger_panel_visual_profiler` 相同。"

msgid ""
"Some of these project settings can also be overridden using :ref:`command "
"line arguments <doc_command_line_tutorial>` such as ``--quiet``, ``--"
"verbose``, and ``--print-fps``."
msgstr ""
"其中一些專案設定也可透過 :ref:`指令列參數 <doc_command_line_tutorial>` 覆寫，"
"例如 ``--quiet``、``--verbose`` 與 ``--print-fps``。"

msgid ""
"The engine's own file logging is also configurable, as described in the "
"section below."
msgstr "引擎內建的檔案日誌也可設定，如下節所述。"

msgid "Built-in file logging"
msgstr "內建檔案日誌"

msgid ""
"By default, Godot writes log files in ``user://logs/godot.log`` on desktop "
"platforms. You can change this location by modifying the ``debug/"
"file_logging/log_path`` project setting. Logs are rotated to keep older "
"files available for inspection. Each session creates a new log file, with "
"the old file renamed to contain the date at which it was rotated. Up to 5 "
"log files are kept by default, which can be adjusted using the ``debug/"
"file_logging/max_log_files`` project setting."
msgstr ""
"預設情況下，Godot 會在桌面平台的 ``user://logs/godot.log`` 寫入日誌檔。你可透"
"過修改專案設定 ``debug/file_logging/log_path`` 來變更此位置。為了保留舊檔供檢"
"視，日誌會進行輪替。每次執行都會建立新的日誌檔，舊檔則會重新命名以包含被輪替"
"時的日期。預設會保留最多 5 個日誌檔，可透過 ``debug/file_logging/"
"max_log_files`` 調整。"

msgid ""
"File logging can also be disabled completely using the ``debug/file_logging/"
"enable_file_logging`` project setting."
msgstr "也可透過 ``debug/file_logging/enable_file_logging`` 完全停用檔案日誌。"

msgid ""
"When the project crashes, crash logs are written to the same file as the log "
"file. The crash log will only contain a usable backtrace if the binary that "
"was run contains debugging symbols, or if it can find a debug symbols file "
"that matches the binary. Official binaries don't provide debugging symbols, "
"so this requires a custom build to work. See :ref:`Debugging symbols "
"<doc_introduction_to_the_buildsystem_debugging_symbols>` for guidance on "
"compiling binaries with debugging symbols enabled."
msgstr ""
"當專案崩潰時，崩潰日誌會寫入與一般日誌相同的檔案。只有在執行的二進位包含除錯"
"符號，或能找到與之相符的除錯符號檔時，崩潰日誌才會包含可用的回溯。官方二進位"
"不提供除錯符號，因此需要自訂建置才能生效。請見 :ref:`除錯符號 "
"<doc_introduction_to_the_buildsystem_debugging_symbols>` 以了解如何在啟用除錯"
"符號的情況下編譯二進位。"

msgid ""
"Log files for :ref:`print() <class_@GlobalScope_method_print>` statements "
"are updated when standard output is *flushed* by the engine. Standard output "
"is flushed on every print in debug builds only. In projects that are "
"exported in release mode, standard output is only flushed when the project "
"exits or crashes to improve performance, especially if the project is often "
"printing text to standard output."
msgstr ""
"針對 :ref:`print() <class_@GlobalScope_method_print>` 所列印的訊息, 日誌檔會"
"在引擎將標準輸出 *flush* 時更新。僅在除錯建置中, 標準輸出會於每次列印時進行 "
"flush。在以發行模式匯出的專案中, 標準輸出只會在專案結束或崩潰時才進行 flush, "
"以提升效能, 特別是在專案經常列印文字到標準輸出的情況下。"

msgid ""
"On the other hand, the standard error stream (used by :ref:`printerr() "
"<class_@GlobalScope_method_printerr>`, :ref:`push_error() "
"<class_@GlobalScope_method_push_error>`, and :ref:`push_warning() "
"<class_@GlobalScope_method_push_warning>`) is always flushed on every print, "
"even in projects exported in release mode."
msgstr ""
"相對地，標準錯誤串流（由 :ref:`printerr() "
"<class_@GlobalScope_method_printerr>`、:ref:`push_error() "
"<class_@GlobalScope_method_push_error>` 與 :ref:`push_warning() "
"<class_@GlobalScope_method_push_warning>` 使用）在每次列印時都會進行沖洗，即"
"使在以發行模式匯出的專案也是如此。"

msgid ""
"For some use cases like dedicated servers, it can be preferred to have "
"release builds always flush stdout on print, so that logging services like "
"journald can collect logs while the process is running. This can be done by "
"enabling ``application/run/flush_stdout_on_print`` in the Project Settings."
msgstr ""
"在某些情境（如專用伺服器）下，可能希望發行建置在列印時也總是沖洗標準輸出，讓 "
"journald 等日誌服務能在行程執行期間收集日誌。你可以在專案設定中啟用 "
"``application/run/flush_stdout_on_print`` 來達成。"

msgid "Script backtraces"
msgstr "腳本回溯"

msgid ""
"Since Godot 4.5, when GDScript code encounters an error, it will log a "
"backtrace that points to the origin of the error, while also containing the "
"call stack leading to it. This behavior is always enabled when running in "
"the editor, or when the project is exported in debug mode."
msgstr ""
"自 Godot 4.5 起，當 GDScript 程式碼遇到錯誤時，會記錄一份回溯，指出錯誤的來"
"源，並包含導致該錯誤的呼叫堆疊。此行為在編輯器中執行或以除錯模式匯出專案時一"
"律啟用。"

msgid ""
"In projects exported in release mode, backtraces are disabled by default for "
"performance reasons. You can enable them by checking **Debug > Settings > "
"GDScript > Always Track Call Stacks** in the Project Settings. If you use a "
"custom logging system that reports exceptions to a remote service, it's "
"recommended to enable this to make reported errors more actionable."
msgstr ""
"在以發行模式匯出的專案中，為了效能，預設會停用回溯。你可以在專案設定中勾選 "
"**Debug > Settings > GDScript > Always Track Call Stacks** 來啟用它。若你使用"
"自訂的日誌系統將例外回報到遠端服務，建議啟用此選項以提升錯誤的可處理性。"

msgid "Crash backtraces"
msgstr "崩潰回溯"

msgid ""
"Crash backtraces are only useful if they were recorded in a build that "
"contains :ref:`debugging symbols "
"<doc_introduction_to_the_buildsystem_debugging_symbols>`. Official Godot "
"binaries do not contain debugging symbols, so you must compile a custom "
"editor or export template binary to get useful crash backtraces."
msgstr ""
"崩潰回溯只有在以包含 :ref:`除錯符號 "
"<doc_introduction_to_the_buildsystem_debugging_symbols>` 的建置記錄時才有用。"
"官方 Godot 二進位不含除錯符號，因此你必須自行編譯自訂的編輯器或匯出樣板二進"
"位，才能取得有用的崩潰回溯。"

msgid ""
"When the project crashes, a crash backtrace is printed to the standard error "
"stream. This is what it can look like in a build with debug symbols:"
msgstr ""
"當專案崩潰時，崩潰回溯會列印到標準錯誤串流。以下是在包含除錯符號的建置中可能"
"的樣子："

msgid ""
"On the other hand, without debug symbols, it will look like this instead:"
msgstr "相對地，若沒有除錯符號，則會長得像這樣："

msgid ""
"This backtrace is also logged to the file for the current session, but it is "
"**not** visible in the editor Output panel. Since the engine's scripting "
"system is not running anymore when the engine is crashing, it is not "
"possible to access it from scripting in the same session. However, you can "
"still read the crash backtrace on the next session by loading log files and "
"searching for the crash backtrace string (``Program crashed with signal``) "
"using :ref:`class_FileAccess`. This allows you to access the backtrace "
"information even after a crash, as long as the user restarts the project and "
"file logging is enabled:"
msgstr ""
"這份回溯也會記錄到目前工作階段的日誌檔中, 但它在編輯器的 Output 面板中是看 **"
"不** 到的。由於引擎在崩潰時, 其腳本系統已不再執行, 因此無法在同一工作階段中以"
"腳本方式存取。不過, 你仍可在下一次啟動時讀取日誌檔, 並使"
"用 :ref:`class_FileAccess` 搜尋崩潰回溯字串 (``Program crashed with "
"signal``) 以取得回溯資訊, 只要使用者重新啟動專案且已啟用檔案日誌即可:"

msgid ""
"You can customize the message that appears at the top of the backtrace using "
"the **Debug > Settings > Crash Handler > Message** project setting. This can "
"be used to point to a URL or email address that users can report issues to."
msgstr ""
"你可以透過專案設定 **Debug > Settings > Crash Handler > Message** 自訂回溯頂"
"端顯示的訊息。這可用來提供回報問題的 URL 或電子郵件地址。"

msgid "Creating custom loggers"
msgstr "建立自訂記錄器"

msgid ""
"Since Godot 4.5, it is possible to create custom loggers. This custom "
"logging can be used for many purposes:"
msgstr "自 Godot 4.5 起，可以建立自訂記錄器。這類自訂記錄可用於多種目的："

msgid ""
"Show an in-game console with the same messages as printed by the engine, "
"without requiring other scripts to be modified."
msgstr "顯示遊戲內主控台，與引擎所列印的訊息保持一致，而無需修改其他腳本。"

msgid ""
"Report printed errors from the player's machine to a remote server. This can "
"make it easier for developers to fix bugs when the game is already released, "
"or during playtesting."
msgstr ""
"將玩家機器上列印出的錯誤回報到遠端伺服器，讓開發者在遊戲已發行或測試期間更容"
"易修復問題。"

msgid "Integrate a dedicated server export with monitoring platforms."
msgstr "將專用伺服器的匯出版本與監控平台整合。"

msgid ""
"A custom logger can be registered by creating a class that inherits "
"from :ref:`class_logger`, then passing an instance of this class "
"to :ref:`OS.add_logger <class_OS_method_add_logger>`, in a "
"script's :ref:`_init() <class_Object_private_method__init>` method. A good "
"place to do this is an :ref:`autoload <doc_singletons_autoload>`."
msgstr ""
"要註冊自訂記錄器，先建立一個繼承自 :ref:`class_logger` 的類別，然後在腳本"
"的 :ref:`_init() <class_Object_private_method__init>` 方法中，將其實例傳"
"給 :ref:`OS.add_logger <class_OS_method_add_logger>`。不錯的放置地點是 :ref:`"
"自動載入 <doc_singletons_autoload>`。"

msgid ""
"The class must define two methods: :ref:`_log_message() "
"<class_Logger_private_method__log_message>` and :ref:`_log_error() "
"<class_Logger_private_method__log_error>`."
msgstr ""
"該類別必須定義兩個方法：:ref:`_log_message() "
"<class_Logger_private_method__log_message>` 與 :ref:`_log_error() "
"<class_Logger_private_method__log_error>`。"

msgid ""
"Here is a minimal working example of a custom logger, with the script added "
"as an autoload:"
msgstr "以下是一個可運作的最小自訂記錄器範例，並將腳本加入為自動載入："

msgid ""
"Note that to avoid infinite recursion, you cannot effectively "
"use :ref:`print() <class_@GlobalScope_method_print>` and its related methods "
"in ``_log_message()``. You also can't effectively use :ref:`push_error() "
"<class_@GlobalScope_method_push_error>` or :ref:`push_warning() "
"<class_@GlobalScope_method_push_warning>` in ``_log_error()``. Attempting to "
"do so will print a message to the same stream as the original message. This "
"message is not available in the custom logger, which is what prevents "
"infinite recursion from occurring:"
msgstr ""
"請注意，為了避免無限遞迴，你無法在 ``_log_message()`` 中有效地使"
"用 :ref:`print() <class_@GlobalScope_method_print>` 及其相關方法；同樣地，你"
"也無法在 ``_log_error()`` 中有效地使用 :ref:`push_error() "
"<class_@GlobalScope_method_push_error>` 或 :ref:`push_warning() "
"<class_@GlobalScope_method_push_warning>`。嘗試這麼做時，會將訊息列印到與原始"
"訊息相同的串流。此訊息不會出現在自訂記錄器中，如此即可避免發生無限遞迴："

msgid ""
"You can find an example of an in-game console built with a custom logger in "
"the `Custom Logging demo project <https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/custom_logging>`__."
msgstr ""
"你可以在 `自訂記錄範例專案 <https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/custom_logging>`__ 中找到一個以自訂記錄器製作的遊戲"
"內主控台範例。"
