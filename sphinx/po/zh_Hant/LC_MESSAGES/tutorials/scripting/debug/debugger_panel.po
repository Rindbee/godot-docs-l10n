#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Debugger panel"
msgstr "除錯器面板"

msgid ""
"Many of Godot's debugging tools, including the debugger, can be found in the "
"debugger panel at the bottom of the screen. Click on **Debugger** to open it."
msgstr ""
"Godot 的多項除錯工具（包含主除錯器）都集中於畫面下方的除錯器面板。點選 **除錯"
"器** 分頁即可開啟。"

msgid ""
"The debugger panel is split into several tabs, each focusing on a specific "
"task."
msgstr "除錯器面板分為多個分頁，每個分頁專注於不同的除錯任務。"

msgid "Stack Trace"
msgstr "堆疊追蹤"

msgid ""
"The Stack Trace tab opens automatically when the GDScript compiler reaches a "
"breakpoint in your code."
msgstr "當 GDScript 編譯器執行至你程式碼中的中斷點時，堆疊追蹤分頁會自動開啟。"

msgid ""
"It gives you a `stack trace <https://en.wikipedia.org/wiki/Stack_trace>`__, "
"information about the state of the object, and buttons to control the "
"program's execution. When the debugger breaks on a breakpoint, a green "
"triangle arrow is visible in the script editor's gutter. This arrow "
"indicates the line of code the debugger broke on."
msgstr ""
"此分頁會顯示 `堆疊追蹤 <https://en.wikipedia.org/wiki/Stack_trace>`__，包含物"
"件狀態資訊，以及多個可控制程式執行流程的按鈕。當偵錯器於中斷點暫停時，腳本編"
"輯器行號旁會顯示綠色三角箭頭，指示目前中斷的程式碼行。"

msgid ""
"You can create a breakpoint by clicking the gutter in the left of the script "
"editor (on the left of the line numbers). When hovering this gutter, you "
"will see a transparent red dot appearing, which turns into an opaque red dot "
"after the breakpoint is placed by clicking. Click the red dot again to "
"remove the breakpoint. Breakpoints created this way persist across editor "
"restarts, even if the script wasn't saved when exiting the editor."
msgstr ""
"您可以透過點選腳本編輯器左側的裝訂線（行號左側）來建立斷點。將滑鼠懸停在該排"
"水溝上時，您會看到出現一個透明的紅點，點擊放置斷點後，該紅點會變成不透明的紅"
"點。再次點選紅點即可刪除斷點。以這種方式建立的斷點在編輯器重新啟動後仍然存"
"在，即使退出編輯器時未儲存腳本也是如此。"

msgid ""
"You can also use the ``breakpoint`` keyword in GDScript to create a "
"breakpoint that is stored in the script itself. Unlike breakpoints created "
"by clicking in the gutter, this keyword-based breakpoint is persistent "
"across different machines when using version control."
msgstr ""
"你也可以在 GDScript 腳本中使用 ``breakpoint`` 關鍵字，於原始碼內建立中斷點。"
"與用滑鼠點擊行號邊緣建立的中斷點不同，這種做法可讓中斷點隨版本控制同步到不同"
"機器。"

msgid "You can use the buttons in the top-right corner to:"
msgstr "你可以使用右上角的按鈕執行以下操作："

msgid ""
"Skip all breakpoints. That way, you can save breakpoints for future "
"debugging sessions."
msgstr "跳過所有中斷點（保留斷點但暫時不觸發），方便未來持續除錯。"

msgid "Copy the current error message."
msgstr "複製當前錯誤訊息。"

msgid ""
"**Step Into** the code. This button takes you to the next line of code, and "
"if it's a function, it steps line-by-line through the function."
msgstr "**步入** 程式碼：跳到下一行，若進入函式則會逐行執行。"

msgid ""
"**Step Over** the code. This button goes to the next line of code, but it "
"doesn't step line-by-line through functions."
msgstr "**步過** 程式碼：跳到下一行，但遇到函式時不會進入內部，直接跳過。"

msgid "**Break**. This button pauses the game's execution."
msgstr "**中斷**：暫停遊戲執行。"

msgid "**Continue**. This button resumes the game after a breakpoint or pause."
msgstr "**繼續**：於中斷點或暫停後繼續執行遊戲。"

msgid ""
"Using the debugger and breakpoints on :ref:`tool scripts "
"<doc_running_code_in_the_editor>` is not currently supported. Breakpoints "
"placed in the script editor or using the ``breakpoint`` keyword are ignored. "
"You can use print statements to display the contents of variables instead."
msgstr ""
"目前不支援在 :ref:`工具腳本 <doc_running_code_in_the_editor>` 上使用偵錯器與"
"中斷點。無論在腳本編輯器中設置的中斷點，或使用 ``breakpoint`` 關鍵字，皆會被"
"忽略。你可以改用列印語句來顯示變數內容。"

msgid "Errors"
msgstr "錯誤"

msgid ""
"This is where error and warning messages are printed while running the game."
msgstr "此分頁會顯示遊戲運行時的錯誤與警告訊息。"

msgid ""
"You can disable specific warnings in **Project Settings > Debug > GDScript**."
msgstr "你可在 **專案設定 > 除錯 > GDScript** 中關閉特定警告。"

msgid "Evaluator"
msgstr "運算器"

msgid ""
"This tab contains an expression evaluator, also known as a :abbr:`REPL (Read-"
"Eval-Print Loop)`. This is a more powerful complement to the Stack Variables "
"tree available in the Stack Trace tab."
msgstr ""
"此分頁內建運算式求值器 :abbr:`REPL (Read-Eval-Print Loop)`，可即時計算表達"
"式，功能比堆疊追蹤分頁中的變數樹更強大。"

msgid ""
"When the project is interrupted in the debugger (due to a breakpoint or "
"script error), you can enter an expression in the text field at the top. If "
"the project is running, the expression field won't be editable, so you will "
"need to set a breakpoint first. Expressions can be persisted across runs by "
"unchecking **Clear on Run**, although they will be lost when the editor "
"quits."
msgstr ""
"當專案在除錯器中暫停時（因中斷點或腳本錯誤），你可於上方文字欄輸入運算式。若"
"專案仍在運作，則此欄位無法編輯，需先設中斷點。只要取消勾選 **執行時清空**，輸"
"入的運算式可跨執行次數保留，但關閉編輯器後會遺失。"

msgid ""
"Expressions are evaluated using :ref:`Godot's expression language "
"<doc_evaluating_expressions>`, which allows you to perform arithmetic and "
"call some functions within the expression. Expressions can refer to member "
"variables, or local variables within the same scope as the line the "
"breakpoint is on. You can also enter constant values, which makes it usable "
"as a built-in calculator."
msgstr ""
"運算式以 :ref:`Godot 表達式語言 <doc_evaluating_expressions>` 執行，可進行運"
"算並呼叫部分內建函式。可存取成員變數或同一作用域下的區域變數，也能直接輸入常"
"數，等同小型計算機。"

msgid "Consider the following script:"
msgstr "參考以下腳本範例："

msgid ""
"If the debugger breaks on the **first** line containing ``breakpoint``, the "
"following expressions return non-null values:"
msgstr "若偵錯器在**第一個** ``breakpoint`` 行暫停，下列運算式均有效："

msgid "**Constant expression:** ``2 * PI + 5``"
msgstr "**常數運算式：** ``2 * PI + 5``"

msgid "**Member variable:** ``counter``, ``counter ** 2``, ``sqrt(counter)``"
msgstr "**成員變數：** ``counter``、``counter ** 2``、``sqrt(counter)``"

msgid ""
"**Local variable or function parameter:** ``delta``, ``text``, "
"``text.to_upper()``"
msgstr "**區域變數或參數：** ``delta``、``text``、``text.to_upper()``"

msgid ""
"If the debugger breaks on the **second** line containing ``breakpoint``, the "
"following expressions return non-null values:"
msgstr "若偵錯器在**第二個** ``breakpoint`` 行暫停，下列運算式有效："

msgid ""
"**Local variable or function parameter:** ``delta``, ``other_text``, "
"``other_text.to_upper()``"
msgstr ""
"**區域變數或參數：** ``delta``、``other_text``、``other_text.to_upper()``"

msgid "Profiler"
msgstr "效能分析"

msgid ""
"The profiler is used to see what code is running while your project is in "
"use, and how that effects performance."
msgstr "效能分析器用於檢視專案執行時，哪些程式碼正在運作，以及其對效能的影響。"

msgid ""
"A detailed explanation of how to use the profiler can be found in the "
"dedicated :ref:`doc_the_profiler` page."
msgstr "效能分析器的詳細使用說明，請參閱專屬頁面：:ref:`doc_the_profiler`。"

msgid "Visual Profiler"
msgstr "視覺化分析"

msgid ""
"The Visual Profiler can be used to monitor what is taking the most time when "
"rendering a frame on the CPU and GPU respectively. This allows tracking "
"sources of potential CPU and GPU bottlenecks caused by rendering."
msgstr ""
"視覺化分析器可用於監控每個畫面在 CPU 與 GPU 上分別花費的時間，協助追蹤因繪圖"
"產生的潛在效能瓶頸。"

msgid ""
"The Visual Profiler only measures CPU time taken for rendering tasks, such "
"as performing draw calls. The Visual Profiler does **not** include CPU time "
"taken for other tasks such as scripting and physics. Use the standard "
"Profiler tab to track non-rendering-related CPU tasks."
msgstr ""
"視覺化分析器僅測量繪圖相關任務（例如 draw call）消耗的 CPU 時間， **不** 包含"
"腳本執行、物理等其他 CPU 任務。如需追蹤非繪圖任務，請使用標準「效能分析」分"
"頁。"

msgid ""
"To use the visual profiler, run the project, switch to the **Visual "
"Profiler** tab within the Debugger bottom panel, then click **Start**:"
msgstr ""
"要使用視覺化分析器，請執行專案，切換到下方面板的 **Visual Profiler** 分頁，然"
"後點選 **開始**："

msgid ""
"Visual Profiler tab after clicking Start, waiting for a few seconds, then "
"clicking Stop"
msgstr "啟動視覺化分析器後，等待數秒再停止，即可看到分析結果："

msgid ""
"Visual Profiler tab after clicking **Start**, waiting for a few seconds, "
"then clicking **Stop**"
msgstr "**開始** 後等數秒，再按 **停止** 即可看到結果"

msgid ""
"You can also check **Autostart**, which will make the visual profiler "
"automatically start when the project is run the next time. Note that the "
"**Autostart** checkbox's state is not preserved across editor sessions."
msgstr ""
"你也可勾選 **自動開始**，專案下次執行時自動啟動分析。注意：自動開始設定不會跨"
"編輯器啟動保存。"

msgid ""
"You will see categories and results appearing as the profiler is running. "
"Graph lines also appear, with the left side being a CPU framegraph and the "
"right side being a GPU framegraph."
msgstr ""
"分析進行時會即時顯示各種分類與結果。圖表左側為 CPU 幀圖，右側為 GPU 幀圖。"

msgid ""
"Click **Stop** to finish profiling, which will keep the results visible but "
"frozen in place. Results remain visible after stopping the running project, "
"but not after exiting the editor."
msgstr ""
"按下 **停止** 結束分析後，分析結果仍會保留於面板上，即使停止專案執行亦可瀏"
"覽，但關閉編輯器後資料將消失。"

msgid ""
"Click on result categories on the left to highlight them in the CPU and GPU "
"graphs on the right. You can also click on the graph to move the cursor to a "
"specific frame number and highlight the selected data type in the result "
"categories on the left."
msgstr ""
"點選左側分類可於右側 CPU/GPU 圖表標示。也可點擊圖表游標，跳至指定幀數並反白左"
"側分類。"

msgid ""
"You can switch the result display between a time value (in milliseconds per "
"frame) or a percentage of the target frametime (which is currently hardcoded "
"to 16.67 milliseconds, or 60 FPS)."
msgstr ""
"結果可切換顯示為每幀毫秒數，或目標幀時間的百分比（目前預設為 16.67 毫秒＝60 "
"幀/秒）。"

msgid ""
"If framerate spikes occur during profiling, this can cause the graph to be "
"poorly scaled. Disable **Fit to Frame** so that the graph will zoom onto the "
"60 FPS+ portion."
msgstr ""
"若在分析期間出現幀率飆高，圖表可能會縮放不當。此時可停用 **自動縮放至全幀**，"
"聚焦於 60 FPS 以上部分。"

msgid ""
"Remember that Visual Profiler results can vary **heavily** based on viewport "
"resolution, which is determined by the window size if using the ``disabled`` "
"or ``canvas_items`` :ref:`stretch modes <doc_multiple_resolutions>`."
msgstr ""
"請注意，視覺化分析器的結果會因視窗解析度差異而**有很大變化**。若使用 "
"``disabled`` 或 ``canvas_items`` :ref:`延展模式 <doc_multiple_resolutions>`，"
"則由視窗大小決定解析度。"

msgid ""
"When comparing results across different runs, make sure to use the same "
"viewport size for all runs."
msgstr "比較多次分析結果時，請確保所有情境下的視窗大小一致。"

msgid ""
"Visual Profiler is supported when using any rendering method (Forward+, "
"Mobile or Compatibility), but the reported categories will vary depending on "
"the current rendering method as well as the enabled graphics features. For "
"example, when using Forward+, a simple 2D scene with shadow-casting lights "
"will result in the following categories appearing:"
msgstr ""
"視覺化分析器支援所有繪圖後端（Forward+、Mobile、相容模式），但報告分類會依目"
"前繪圖方法與啟用的圖形功能不同而異。例如使用 Forward+ 時，單純 2D 場景加陰影"
"光源時會出現以下分類："

msgid "Example results from a 2D scene in the Visual Profiler"
msgstr "2D 場景於視覺化分析器的範例結果"

msgid ""
"To give another example with Forward+, a 3D scene with shadow-casting lights "
"and various effects enabled will result in the following categories enabled:"
msgstr "再舉 Forward+ 為例，若 3D 場景啟用陰影與多種特效，則會產生下列分類："

msgid "Example results from a 3D scene in the Visual Profiler"
msgstr "3D 場景於視覺化分析器的範例結果"

msgid ""
"Notice how in the 3D example, several of the categories have **(Parallel)** "
"appended to their name. This hints that multiple tasks are being performed "
"in parallel on the GPU. This generally means that disabling only one of the "
"features involved won't improve performance as much as anticipated, as the "
"other task still needs to be performed sequentially."
msgstr ""
"注意在 3D 範例中，部份分類名稱會標記 **(Parallel)**，代表 GPU 正同時執行多項"
"任務。這通常意味著僅關閉單一功能未必大幅提升效能，因其他任務仍需序列執行。"

msgid ""
"The Visual Profiler is not supported when using the Compatibility renderer "
"on macOS, due to platform limitations."
msgstr "由於平台限制，在 macOS 上使用相容性轉譯器時不支援視覺效能分析器。"

msgid "Network Profiler"
msgstr "網路分析器"

msgid ""
"The Network Profiler contains a list of all the nodes that communicate over "
"the multiplayer API and, for each one, some counters on the amount of "
"incoming and outgoing network interactions. It also features a bandwidth "
"meter that displays the total bandwidth usage at any given moment."
msgstr ""
"網路分析器會列出所有透過多人 API 通訊的節點，並為每個節點統計進出封包數量，同"
"時提供即時頻寬監控圖表。"

msgid ""
"The bandwidth meter does **not** take the :ref:`doc_high_level_multiplayer` "
"API's own compression system into account. This means that changing the "
"compression algorithm used will not change the metrics reported by the "
"bandwidth meter."
msgstr ""
"頻寬監控儀**不**會考慮 :ref:`doc_high_level_multiplayer` API 的內建壓縮。更改"
"壓縮演算法並不會影響此圖表顯示的數據。"

msgid "Monitors"
msgstr "效能監控"

msgid ""
"The monitors are graphs of several aspects of the game while it's running "
"such as FPS, memory usage, how many nodes are in a scene and more. All "
"monitors keep track of stats automatically, so even if one monitor isn't "
"open while the game is running, you can open it later and see how the values "
"changed."
msgstr ""
"監視器會在遊戲執行時以圖表顯示多項指標，例如 FPS、記憶體用量、場景中的節點數"
"量等。所有監視器都會自動追蹤統計資料，因此就算遊戲執行時沒有開啟某個監視器，"
"你之後仍可開啟並查看數值如何變化。"

msgid ""
"In addition to the default performance monitors, you can also "
"create :ref:`custom performance monitors <doc_custom_performance_monitors>` "
"to track arbitrary values in your project."
msgstr ""
"除了預設效能監控外，還可依需求建立 :ref:`自訂效能監控 "
"<doc_custom_performance_monitors>`，追蹤專案內任意數值。"

msgid "Video RAM"
msgstr "顯示記憶體"

msgid ""
"The **Video RAM** tab shows the video RAM usage of the game while it is "
"running. It provides a list of every resource using video RAM by resource "
"path, the type of resource it is, what format it is in, and how much Video "
"RAM that resource is using. There is also a total video RAM usage number at "
"the top right of the panel."
msgstr ""
"**顯示記憶體** 分頁會顯示遊戲執行時所有佔用顯示記憶體的資源清單，列出路徑、資"
"源類型、格式及佔用量。右上角可見總顯示記憶體用量。"

msgid "Misc"
msgstr "其他"

msgid ""
"The **Misc** tab contains tools to identify the control nodes you are "
"clicking at runtime:"
msgstr "**其他** 分頁提供運作時辨識所點擊控制節點的工具："

msgid ""
"**Clicked Control** tells you where the clicked node is in the scene tree."
msgstr "**點擊節點** 會顯示所點擊節點在場景樹的位置。"

msgid "**Clicked Control Type** tells you the type of the node you clicked is."
msgstr "**點擊節點型別** 會顯示點擊節點的類型。"
