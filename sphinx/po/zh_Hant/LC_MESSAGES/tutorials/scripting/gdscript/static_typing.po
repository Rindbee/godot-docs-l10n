#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Static typing in GDScript"
msgstr "GDScript 的靜態型別"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你將學到："

msgid "how to use static typing in GDScript;"
msgstr "如何在 GDScript 中使用靜態型別;"

msgid "that static types can help you avoid bugs;"
msgstr "靜態型別可以幫助你避免錯誤;"

msgid "that static typing improves your experience with the editor."
msgstr "靜態型別可以提升你在編輯器中的使用體驗。"

msgid ""
"Where and how you use this language feature is entirely up to you: you can "
"use it only in some sensitive GDScript files, use it everywhere, or don't "
"use it at all."
msgstr ""
"你可以完全自由決定在哪裡以及如何使用這個語言特性：你可以只在某些關鍵的 "
"GDScript 檔案使用、全專案都使用，或完全不使用。"

msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr "你可以在變數、常數、函式、參數及回傳型別上使用靜態型別。"

msgid "A brief look at static typing"
msgstr "靜態型別簡介"

msgid ""
"With static typing, GDScript can detect more errors without even running the "
"code. Also type hints give you and your teammates more information as you're "
"working, as the arguments' types show up when you call a method. Static "
"typing improves editor autocompletion and :ref:`documentation "
"<doc_gdscript_documentation_comments>` of your scripts."
msgstr ""
"有了靜態型別，GDScript 可以在不執行程式碼的情況下偵測出更多錯誤。型別提示也能"
"在你或團隊成員撰寫程式時，於方法呼叫時顯示參數型別，讓大家獲得更多資訊。靜態"
"型別還能提升編輯器的自動補全與 :ref:`腳本註解文件 "
"<doc_gdscript_documentation_comments>` 的效果。"

msgid ""
"Imagine you're programming an inventory system. You code an ``Item`` class, "
"then an ``Inventory``. To add items to the inventory, the people who work "
"with your code should always pass an ``Item`` to the ``Inventory.add()`` "
"method. With types, you can enforce this:"
msgstr ""
"想像你正在撰寫一個物品欄系統。你寫了一個 ``Item`` 類別，然後再寫一個 "
"``Inventory``。要把物品加入物品欄，使用你程式碼的人應該永遠把 ``Item`` 傳給 "
"``Inventory.add()`` 方法。有了型別，你可以強制這件事："

msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options."
msgstr ""
"靜態型別也能帶來更優秀的程式碼自動補全體驗。下面可以看到動態型別與靜態型別的"
"補全選項差異。"

msgid ""
"You've probably encountered a lack of autocomplete suggestions after a dot:"
msgstr "你也許遇過在輸入「.」後沒有自動補全建議："

msgid "Completion options for dynamic typed code."
msgstr "動態型別程式碼的補全選項。"

msgid ""
"This is due to dynamic code. Godot cannot know what value type you're "
"passing to the function. If you write the type explicitly however, you will "
"get all methods, properties, constants, etc. from the value:"
msgstr ""
"這是因為動態程式碼下，Godot 無法知道你傳遞給函式的值是什麼型別。如果你明確寫"
"出型別，補全就會顯示該型別的所有方法、屬性、常數等："

msgid "Completion options for static typed code."
msgstr "靜態型別程式碼的補全選項。"

msgid ""
"If you prefer static typing, we recommend enabling the **Text Editor > "
"Completion > Add Type Hints** editor setting. Also consider enabling `some "
"warnings <Warning system_>`_ that are disabled by default."
msgstr ""
"如果你偏好靜態型別，建議啟用 **文字編輯器 > 自動完成 > 新增型別提示** 編輯器"
"設定，也可考慮啟用預設停用的 `部分警告 <Warning system>`_ 。"

msgid ""
"Also, typed GDScript improves performance by using optimized opcodes when "
"operand/argument types are known at compile time. More GDScript "
"optimizations are planned in the future, such as JIT/AOT compilation."
msgstr ""
"此外，使用靜態型別的 GDScript 在編譯時若已知運算元／參數型別，會自動使用最佳"
"化的位元碼，提升執行效能。未來還會加入更多最佳化，例如 JIT/AOT 編譯。"

msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you're working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people's code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"總體來說，靜態型別讓你的程式架構更明確，有助於防止錯誤，也讓腳本更容易自我說"
"明。在團隊協作或長期專案中特別實用：研究顯示，多數開發者花最多的時間在閱讀他"
"人或自己過去寫但早已忘記的程式碼。程式碼越清晰、結構越明確，理解就越快，也能"
"讓開發更順暢。"

msgid "How to use static typing"
msgstr "如何使用靜態型別"

msgid ""
"To define the type of a variable, parameter, or constant, write a colon "
"after the name, followed by its type. E.g. ``var health: int``. This forces "
"the variable's type to always stay the same:"
msgstr ""
"要定義變數、參數或常數的型別，在名稱後面寫上冒號，接著是型別。例如 ``var "
"health: int``。這會強制該變數的型別保持不變："

msgid ""
"Godot will try to infer types if you write a colon, but you omit the type:"
msgstr "若你寫了冒號卻省略型別，Godot 會嘗試推斷型別："

msgid "There is no difference between ``=`` and ``:=`` for constants."
msgstr "對於常數來說，``=`` 與 ``:=`` 沒有差別。"

msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer. Also, this is useful for typed arrays (like "
"``const A: Array[int] = [1, 2, 3]``), since untyped arrays are used by "
"default."
msgstr ""
"常數不一定要寫型別提示，Godot 會自動根據賦值推斷型別。不過，如果你要讓程式碼"
"意圖更明確，還是可以寫上型別。特別是陣列，如果需要使用有型別的陣列（如 "
"``const A: Array[int] = [1, 2, 3]``），就很有幫助，因為預設是無型別陣列。"

msgid "What can be a type hint"
msgstr "哪些內容可以作為型別提示"

msgid "Here is a complete list of what can be used as a type hint:"
msgstr "以下是所有可以用來當作型別提示的項目："

msgid ""
"``Variant``. Any type. In most cases this is not much different from an "
"untyped declaration, but increases readability. As a return type, forces the "
"function to explicitly return some value."
msgstr ""
"``Variant``。代表任何型別。通常和未指定型別差異不大，但能提升可讀性。若指定為"
"回傳型別，則強制函式必須有回傳值。"

msgid ""
"*(Only return type)* ``void``. Indicates that the function does not return "
"any value."
msgstr "（僅用於回傳型別） ``void``。代表函式不會有回傳值。"

msgid ":ref:`Built-in types <doc_gdscript_builtin_types>`."
msgstr ":ref:`內建型別 <doc_gdscript_builtin_types>`。"

msgid "Native classes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)."
msgstr "原生類別（如 ``Object``、``Node``、``Area2D``、``Camera2D`` 等）。"

msgid ":ref:`Global classes <doc_gdscript_basics_class_name>`."
msgstr ":ref:`全域類別 <doc_gdscript_basics_class_name>`。"

msgid ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."
msgstr ":ref:`內部類別 <doc_gdscript_basics_inner_classes>`。"

msgid ""
"Global, native and custom named enums. Note that an enum type is just an "
"``int``, there is no guarantee that the value belongs to the set of enum "
"values."
msgstr ""
"全域、核心與自訂命名的 enum。請注意 enum 實際上是 ``int`` 型別，無法保證它的"
"值一定來自 enum 列舉值集合。"

msgid ""
"Constants (including local ones) if they contain a preloaded class or enum."
msgstr "常數（包含區域常數），只要內容是預載入的類別或 enum。"

msgid ""
"You can use any class, including your custom classes, as types. There are "
"two ways to use them in scripts. The first method is to preload the script "
"you want to use as a type in a constant:"
msgstr ""
"你可以使用任何類別（包含自訂類別）作為型別。在腳本中有兩種使用方式。第一種是"
"先在常數中預載要作為型別的腳本："

msgid ""
"The second method is to use the ``class_name`` keyword when you create. For "
"the example above, your ``rifle.gd`` would look like this:"
msgstr ""
"第二種方法是在建立類別時使用 ``class_name`` 關鍵字。以上述範例來說，你的 "
"``rifle.gd`` 會像這樣："

msgid ""
"If you use ``class_name``, Godot registers the ``Rifle`` type globally in "
"the editor, and you can use it anywhere, without having to preload it into a "
"constant:"
msgstr ""
"如果使用 ``class_name``，Godot 會在編輯器中將 ``Rifle`` 型別註冊為全域，你就"
"可以在任何地方使用它，而不需要先預載到常數："

msgid "Specify the return type of a function with the arrow ``->``"
msgstr "用箭頭 ``->`` 指定函式的回傳型別"

msgid ""
"To define the return type of a function, write a dash and a right angle "
"bracket ``->`` after its declaration, followed by the return type:"
msgstr ""
"若要定義函式的回傳型別，在宣告後加上一個連字號與右角括號 ``->``，接著寫上回傳"
"型別："

msgid ""
"The type ``void`` means the function does not return anything. You can use "
"any type, as with variables:"
msgstr ""
"型別 ``void`` 代表函式不回傳任何東西。就像變數一樣，你可以使用任何型別："

msgid "You can also use your own classes as return types:"
msgstr "你也可以使用自己的類別作為回傳型別："

msgid "Covariance and contravariance"
msgstr "協變與逆變"

msgid ""
"When inheriting base class methods, you should follow the `Liskov "
"substitution principle <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__."
msgstr ""
"繼承基底類別方法時，應遵循 `Liskov 替換原則 <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__。"

msgid ""
"**Covariance:** When you inherit a method, you can specify a return type "
"that is more specific (**subtype**) than the parent method."
msgstr ""
"**協變(Covariance)：** 當你覆寫繼承的方法時，可以指定比父類別更具體（**子型別"
"**）的回傳型別。"

msgid ""
"**Contravariance:** When you inherit a method, you can specify a parameter "
"type that is less specific (**supertype**) than the parent method."
msgstr ""
"**逆變(Contravariance)：** 當你覆寫繼承的方法時，可以指定比父類別更寬泛（**父"
"型別**）的參數型別。"

msgid "Example:"
msgstr "範例："

msgid "Specify the element type of an ``Array``"
msgstr "指定 ``Array`` 元素的型別"

msgid "To define the type of an ``Array``, enclose the type name in ``[]``."
msgstr "要定義 ``Array`` 的型別，請把型別名稱放在 ``[]`` 內。"

msgid ""
"An array's type applies to ``for`` loop variables, as well as some operators "
"like ``[]``, ``[...] =`` (assignment), and ``+``. Array methods (such as "
"``push_back``) and other operators (such as ``==``) are still untyped. Built-"
"in types, native and custom classes, and enums may be used as element types. "
"Nested array types (like ``Array[Array[int]]``) are not supported."
msgstr ""
"陣列的元素型別會套用到 ``for`` 迴圈變數, 以及某些運算子, 如 ``[]`` 、 "
"``[...] =`` (指定) 與 ``+``。不過, 陣列方法 (例如 ``push_back``) 以及其他運算"
"子 (例如 ``==``) 仍是不具型別的。元素型別可以是內建型別、原生與自訂類別, 也可"
"以是列舉。巢狀陣列型別 (例如 ``Array[Array[int]]``) 目前不支援。"

msgid ""
"Since Godot 4.2, you can also specify a type for the loop variable in a "
"``for`` loop. For instance, you can write:"
msgstr "自 Godot 4.2 起，也可以在 ``for`` 迴圈中為迴圈變數指定型別。例如："

msgid ""
"The array will remain untyped, but the ``name`` variable within the ``for`` "
"loop will always be of ``String`` type."
msgstr ""
"陣列本身仍然是無型別，但 ``for`` 內的 ``name`` 變數會被固定為 ``String`` 型"
"別。"

msgid "Specify the element type of a ``Dictionary``"
msgstr "指定 ``Dictionary`` 的元素型別"

msgid ""
"To define the type of a ``Dictionary``'s keys and values, enclose the type "
"name in ``[]`` and separate the key and value type with a comma."
msgstr ""
"要定義 ``Dictionary`` 的鍵與值的型別，請將型別名稱包在 ``[]`` 內，並以逗號分"
"隔鍵與值的型別。"

msgid ""
"A dictionary's value type applies to ``for`` loop variables, as well as some "
"operators like ``[]`` and ``[...] =`` (assignment). Dictionary methods that "
"return values and other operators (such as ``==``) are still untyped. Built-"
"in types, native and custom classes, and enums may be used as element types. "
"Nested typed collections (like ``Dictionary[String, Dictionary[String, "
"int]]``) are not supported."
msgstr ""
"字典的值型別會套用到 ``for`` 迴圈中的變數, 以及某些運算子, 如 ``[]`` 與 "
"``[...] =`` (指定)。回傳值的字典方法與其他運算子 (例如 ``==``) 仍是不具型別"
"的。元素型別可以是內建型別、原生與自訂類別, 或列舉。巢狀具型別的集合 (例如 "
"``Dictionary[String, Dictionary[String, int]]``) 目前不支援。"

msgid "Type casting"
msgstr "型別轉換"

msgid ""
"Type casting is an important concept in typed languages. Casting is the "
"conversion of a value from one type to another."
msgstr ""
"型別轉換是有型別語言很重要的觀念，意思是將一個值從一種型別轉成另一種型別。"

msgid ""
"Imagine an ``Enemy`` in your game, that ``extends Area2D``. You want it to "
"collide with the ``Player``, a ``CharacterBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``body_entered`` signal to "
"detect the collision. With typed code, the body you detect is going to be a "
"generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"假設你的遊戲中有一個繼承自 ``Area2D`` 的 ``Enemy``，你希望它能和附有 "
"``PlayerController`` 腳本的 ``CharacterBody2D`` 玩家碰撞，並用 "
"``body_entered`` 訊號來偵測。這時，型別化的程式碼中你取得到的 body 其實是通用"
"的 ``PhysicsBody2D``，而不是你自訂的 ``PlayerController``。"

msgid ""
"You can check if this ``PhysicsBody2D`` is your ``Player`` with the ``as`` "
"keyword, and using the colon ``:`` again to force the variable to use this "
"type. This forces the variable to stick to the ``PlayerController`` type:"
msgstr ""
"你可以用 ``as`` 關鍵字檢查這個 ``PhysicsBody2D`` 是否是你的 ``Player``，並再"
"次使用冒號 ``:`` 來強制變數採用該型別。這會讓變數被固定為 "
"``PlayerController`` 型別："

msgid ""
"As we're dealing with a custom type, if the ``body`` doesn't extend "
"``PlayerController``, the ``player`` variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"因為這裡處理的是自訂型別，如果 ``body`` 不是 ``PlayerController`` 的子類，"
"``player`` 變數就會是 ``null``。你可以用這個特性來判斷 body 是否為玩家。轉型"
"之後，player 變數也會有完整的自動補全。"

msgid ""
"The ``as`` keyword silently casts the variable to ``null`` in case of a type "
"mismatch at runtime, without an error/warning. While this may be convenient "
"in some cases, it can also lead to bugs. Use the ``as`` keyword only if this "
"behavior is intended. A safer alternative is to use the ``is`` keyword:"
msgstr ""
"``as`` 關鍵字在執行階段若型別不相符，會在沒有錯誤或警告的情況下，將變數悄悄轉"
"為 ``null``。雖然某些情況下很方便，但也可能造成錯誤。只有在你確實想要這種行為"
"時才使用 ``as``。較安全的替代作法是使用 ``is`` 關鍵字："

msgid "You can also simplify the code by using the ``is not`` operator:"
msgstr "你也可以使用 ``is not`` 運算子讓程式碼更簡潔："

msgid "Alternatively, you can use the ``assert()`` statement:"
msgstr "或者，你也可以使用 ``assert()`` 敘述："

msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr "如果你嘗試轉型成內建型別但失敗，Godot 會直接拋出錯誤。"

msgid "Safe lines"
msgstr "安全行"

msgid ""
"You can also use casting to ensure safe lines. Safe lines are a tool to tell "
"you when ambiguous lines of code are type-safe. As you can mix and match "
"typed and dynamic code, at times, Godot doesn't have enough information to "
"know if an instruction will trigger an error or not at runtime."
msgstr ""
"你也可以用型別轉換來確保安全行。安全行是 Godot 的一種輔助工具，用來告訴你某行"
"有歧義的程式碼在型別上是否安全。因為你可以混用有型別和動態程式碼，有時 Godot "
"無法判斷某行指令在執行時會不會錯。"

msgid ""
"This happens when you get a child node. Let's take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don't care about the "
"node's type as long as it has the methods you need to call."
msgstr ""
"這種情況通常發生在你取得子節點時。以 Timer 為例，動態寫法可以用 ``$Timer`` 直"
"接取得節點。GDScript 支援 `鴨子型別 <https://stackoverflow.com/a/"
"4205163/8125343>`__，所以即使 Timer 是 ``Timer`` 型別，它同時也是 ``Node`` "
"和 ``Object``。用動態 GDScript，只要該節點有你要呼叫的方法，型別不是重點。"

msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as CharacterBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"你可以用型別轉換讓 Godot 知道你預期取得什麼型別的節點，例如 ``($Timer as "
"Timer)``、``($Player as CharacterBody2D)`` 等。Godot 會檢查型別是否正確，如果"
"正確，腳本編輯器左側的行號會變綠色。"

msgid "Unsafe vs Safe Line"
msgstr "不安全 v.s. 安全行"

msgid "Unsafe line (line 7) vs Safe Lines (line 6 and 8)"
msgstr "不安全行（第 7 行）v.s. 安全行（第 6、8 行）"

msgid ""
"Safe lines do not always mean better or more reliable code. See the note "
"above about the ``as`` keyword. For example:"
msgstr ""
"所謂的安全行並不一定代表程式碼更好或更可靠；請參考上面關於 ``as`` 關鍵字的說"
"明。例如："

msgid ""
"Even though ``node_2`` declaration is marked as an unsafe line, it is more "
"reliable than ``node_1`` declaration. Because if you change the node type in "
"the scene and accidentally forget to change it in the script, the error will "
"be detected immediately when the scene is loaded. Unlike ``node_1``, which "
"will be silently cast to ``null`` and the error will be detected later."
msgstr ""
"即使 ``node_2`` 宣告被標記為不安全，但其實比 ``node_1`` 更可靠。因為如果你在"
"場景裡變更節點型別，在腳本裡沒同步更新，載入場景時會立刻報錯。反之，"
"``node_1`` 會靜默被轉成 ``null``，錯誤會延後發現。"

msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr "你可以在編輯器設定中關閉安全行功能，或改變其顏色。"

msgid "Typed or dynamic: stick to one style"
msgstr "靜態型別或動態型別：建議統一風格"

msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But "
"it's recommended to stick to either style for consistency in your codebase, "
"and for your peers. It's easier for everyone to work together if you follow "
"the same guidelines, and faster to read and understand other people's code."
msgstr ""
"靜態型別和動態型別的 GDScript 可以在同一個專案共存，但建議你選擇一種風格統一"
"使用，有助於團隊協作和維護。大家遵循同一套規範，彼此閱讀、理解程式碼會更有效"
"率。"

msgid ""
"Typed code takes a little more writing, but you get the benefits we "
"discussed above. Here's an example of the same, empty script, in a dynamic "
"style:"
msgstr ""
"帶型別的寫法會多一些字，但你能獲得上述的好處。以下是相同的空白腳本，以動態風"
"格撰寫："

msgid "And with static typing:"
msgstr "改用靜態型別則如下："

msgid ""
"As you can see, you can also use types with the engine's virtual methods. "
"Signal callbacks, like any methods, can also use types. Here's a "
"``body_entered`` signal in a dynamic style:"
msgstr ""
"如你所見，也可以在引擎的虛擬方法上使用型別。訊號回呼（和任何方法一樣）也可以"
"使用型別。以下是以動態風格撰寫的 ``body_entered`` 訊號："

msgid "And the same callback, with type hints:"
msgstr "同樣的回呼，加入型別提示："

msgid "::"
msgstr "::"

msgid "func _on_area_2d_body_entered(body: PhysicsBody2D) -> void:"
msgstr "func _on_area_2d_body_entered(body: PhysicsBody2D) -> void:"

msgid "pass"
msgstr "階段"

msgid "Warning system"
msgstr "警告系統"

msgid ""
"Detailed documentation about the GDScript warning system has been moved "
"to :ref:`doc_gdscript_warning_system`."
msgstr ""
"關於 GDScript 警告系統的詳細說明請參見 :ref:`doc_gdscript_warning_system`。"

msgid ""
"Godot gives you warnings about your code as you write it. The engine "
"identifies sections of your code that may lead to issues at runtime, but "
"lets you decide whether or not you want to leave the code as it is."
msgstr ""
"Godot 會在你寫程式時即時顯示警告。引擎會標示出可能在執行時發生問題的程式碼區"
"段，但最終是否要修改還是保留原樣，由你自己決定。"

msgid ""
"We have a number of warnings aimed specifically at users of typed GDScript. "
"By default, these warnings are disabled, you can enable them in Project "
"Settings (**Debug > GDScript**, make sure **Advanced Settings** is enabled)."
msgstr ""
"系統中有不少警告特別針對使用靜態型別 GDScript 的用戶。這些警告預設是關閉的，"
"你可以在專案設定（**偵錯 > GDScript**，記得先開啟 **進階設定**）裡啟用。"

msgid ""
"You can enable the ``UNTYPED_DECLARATION`` warning if you want to always use "
"static types. Additionally, you can enable the ``INFERRED_DECLARATION`` "
"warning if you prefer a more readable and reliable, but more verbose syntax."
msgstr ""
"如果你想要強制全程使用靜態型別，可以啟用 ``UNTYPED_DECLARATION`` 警告。若你偏"
"好更可讀、更可靠但較冗長的語法，也可以啟用 ``INFERRED_DECLARATION`` 警告。"

msgid ""
"``UNSAFE_*`` warnings make unsafe operations more noticeable, than unsafe "
"lines. Currently, ``UNSAFE_*`` warnings do not cover all cases that unsafe "
"lines cover."
msgstr ""
"``UNSAFE_*`` 警告會讓不安全的操作比安全行標記更顯眼。目前 ``UNSAFE_*`` 警告還"
"沒有涵蓋所有安全行會標示的狀況。"

msgid "Common unsafe operations and their safe counterparts"
msgstr "常見的不安全操作與對應的安全寫法"

msgid "``UNSAFE_PROPERTY_ACCESS`` and ``UNSAFE_METHOD_ACCESS`` warnings"
msgstr "``UNSAFE_PROPERTY_ACCESS`` 和 ``UNSAFE_METHOD_ACCESS`` 警告"

msgid ""
"In this example, we aim to set a property and call a method on an object "
"that has a script attached with ``class_name MyScript`` and that ``extends "
"Node2D``. If we have a reference to the object as a ``Node2D`` (for "
"instance, as it was passed to us by the physics system), we can first check "
"if the property and method exist and then set and call them if they do:"
msgstr ""
"在這個例子中, 我們想要對一個物件設定屬性並呼叫方法; 該物件掛有使用 "
"``class_name MyScript`` 、且 ``extends Node2D`` 的腳本。若我們手上的參考是 "
"``Node2D`` (例如由物理系統傳入), 可以先檢查該屬性與方法是否存在, 若存在再設定"
"與呼叫:"

msgid ""
"However, this code will produce ``UNSAFE_PROPERTY_ACCESS`` and "
"``UNSAFE_METHOD_ACCESS`` warnings as the property and method are not present "
"in the referenced type - in this case a ``Node2D``. To make these operations "
"safe, you can first check if the object is of type ``MyScript`` using the "
"``is`` keyword and then declare a variable with the type ``MyScript`` on "
"which you can set its properties and call its methods:"
msgstr ""
"然而，這段程式碼會產生 ``UNSAFE_PROPERTY_ACCESS`` 與 "
"``UNSAFE_METHOD_ACCESS`` 警告，因為所參考的型別（本例為 ``Node2D``）並沒有這"
"個屬性與方法。為了讓操作安全，你可以先用 ``is`` 關鍵字檢查物件是否為 "
"``MyScript`` 型別，然後宣告一個 ``MyScript`` 型別的變數，再對其設定屬性並呼叫"
"方法："

msgid ""
"Alternatively, you can declare a variable and use the ``as`` operator to try "
"to cast the object. You'll then want to check whether the cast was "
"successful by confirming that the variable was assigned:"
msgstr ""
"或者，你可以先宣告一個變數，並使用 ``as`` 運算子嘗試轉型。接著檢查該變數是否"
"已被賦值，以確認轉型是否成功："

msgid "``UNSAFE_CAST`` warning"
msgstr "``UNSAFE_CAST`` 警告"

msgid ""
"In this example, we would like the label connected to an object entering our "
"collision area to show the area's name. Once the object enters the collision "
"area, the physics system sends a signal with a ``Node2D`` object, and the "
"most straightforward (but not statically typed) solution to do what we want "
"could be achieved like this:"
msgstr ""
"在此例中，我們希望當有物件進入碰撞區域時，與該物件關聯的標籤能顯示此區域的名"
"稱。當物件進入碰撞區域時，物理系統會送出帶有 ``Node2D`` 物件的訊號；最直接"
"（但不是靜態型別）的作法如下："

msgid ""
"This piece of code produces an ``UNSAFE_PROPERTY_ACCESS`` warning because "
"``label`` is not defined in ``Node2D``. To solve this, we could first check "
"if the ``label`` property exist and cast it to type ``Label`` before "
"settings its text property like so:"
msgstr ""
"這段程式碼會產生 ``UNSAFE_PROPERTY_ACCESS`` 警告，因為 ``Node2D`` 中未定義 "
"``label``。要解決這點，可以先檢查 ``label`` 屬性是否存在，並在設定其文字屬性"
"之前將其轉型為 ``Label``："

msgid ""
"However, this produces an ``UNSAFE_CAST`` warning because ``body.label`` is "
"of a ``Variant`` type. To safely get the property in the type you want, you "
"can use the ``Object.get()`` method which returns the object as a "
"``Variant`` value or returns ``null`` if the property doesn't exist. You can "
"then determine whether the property contains an object of the right type "
"using the ``is`` keyword, and finally declare a statically typed variable "
"with the object:"
msgstr ""
"不過，這會產生 ``UNSAFE_CAST`` 警告，因為 ``body.label`` 的型別是 "
"``Variant``。要安全地以你想要的型別取得該屬性，可以使用 ``Object.get()`` 方法"
"取得它；該方法會回傳 ``Variant`` 值，若屬性不存在則回傳 ``null``。接著使用 "
"``is`` 關鍵字判斷是否為正確型別，最後以該物件宣告一個靜態型別變數："

msgid "Cases where you can't specify types"
msgstr "無法指定型別的情境"

msgid ""
"To wrap up this introduction, let's mention cases where you can't use type "
"hints. This will trigger a **syntax error**."
msgstr "最後補充無法使用型別提示的情況。以下做法都會造成 **語法錯誤** 。"

msgid ""
"You can't specify the type of individual elements in an array or a "
"dictionary:"
msgstr "你不能為陣列或字典的個別元素指定型別："

msgid "Nested types are not currently supported:"
msgstr "目前不支援巢狀型別："

msgid "Summary"
msgstr "總結"

msgid ""
"Typed GDScript is a powerful tool. It helps you write more structured code, "
"avoid common errors, and create scalable and reliable systems. Static types "
"improve GDScript performance and more optimizations are planned for the "
"future."
msgstr ""
"靜態型別的 GDScript 是一項強大的工具。它能幫助你寫出結構更清晰的程式、減少常"
"見錯誤，並建立更具擴充性與可靠性的系統。靜態型別也能提升 GDScript 效能，未來"
"還會有更多最佳化。"
