#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Idle and Physics Processing"
msgstr "空閒處理與物理處理"

msgid ""
"Games run in a loop. Each frame, you need to update the state of your game "
"world before drawing it on screen. Godot provides two virtual methods in the "
"Node class to do so: :ref:`Node._process() "
"<class_Node_private_method__process>` and :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`. If you define either or both "
"in a script, the engine will call them automatically."
msgstr ""
"遊戲運作時會不斷循環。每一個畫面影格，你都需要在將畫面繪製到螢幕前，先更新遊"
"戲世界的狀態。Godot 在 Node 類別中提供了兩個虛擬方法來達成這個目"
"的：:ref:`Node._process() <class_Node_private_method__process>` "
"和 :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`。只要你在腳本裡定義了這兩個方法"
"之一或兩者，引擎就會自動呼叫它們。"

msgid "There are two types of processing available to you:"
msgstr "你可以使用兩種不同類型的處理流程："

msgid ""
"**Idle processing** allows you to run code that updates a node every frame, "
"as often as possible."
msgstr ""
"**空閒處理** （Idle processing）讓你可以在每一個影格盡可能頻繁地執行程式碼來"
"更新節點。"

msgid ""
"**Physics processing** happens at a fixed rate, 60 times per second by "
"default. This is independent of your game's actual framerate, and keeps "
"physics running smoothly. You should use it for anything that involves the "
"physics engine, like moving a body that collides with the environment."
msgstr ""
"**物理處理** （Physics processing）則是以固定的頻率執行，預設每秒 60 次。這個"
"頻率與遊戲實際的影格率無關，可以讓物理運算保持穩定流暢。任何涉及物理引擎的運"
"算，例如移動會與環境碰撞的物件，都應該使用物理處理。"

msgid ""
"You can activate idle processing by defining the ``_process()`` method in a "
"script. You can turn it off and back on by calling :ref:`Node.set_process() "
"<class_Node_method_set_process>`."
msgstr ""
"你可以在腳本中定義 ``_process()`` 方法來啟用空閒處理。可以透過呼"
"叫 :ref:`Node.set_process() <class_Node_method_set_process>` 來啟用或停用空閒"
"處理。"

msgid "The engine calls this method every time it draws a frame:"
msgstr "每當引擎繪製一個畫面影格時，會自動呼叫這個方法："

msgid ""
"Keep in mind that the frequency at which the engine calls ``_process()`` "
"depends on your application's framerate, which varies over time and across "
"devices."
msgstr ""
"請注意，``_process()`` 的呼叫頻率取決於應用程式當下的影格率（FPS），而這個數"
"值會因為裝置或運行狀況而有所不同。"

msgid ""
"The function's ``delta`` parameter is the time elapsed in seconds since the "
"previous call to ``_process()``. Use this parameter to make calculations "
"independent of the framerate. For example, you should always multiply a "
"speed value by ``delta`` to animate a moving object."
msgstr ""
"這個方法的 ``delta`` 參數代表自上次呼叫 ``_process()`` 以來經過的秒數。你應該"
"利用這個參數來讓計算與影格率無關。例如，對於移動物件的動畫，應該始終將速度值"
"乘上 ``delta``。"

msgid ""
"Physics processing works with a similar virtual function: "
"``_physics_process()``. Use it for calculations that must happen before each "
"physics step, like moving a character that collides with the game world. As "
"mentioned above, ``_physics_process()`` runs at fixed time intervals as much "
"as possible to keep the physics interactions stable. You can change the "
"interval between physics steps in the Project Settings, under Physics -> "
"Common -> Physics Fps. By default, it's set to run 60 times per second."
msgstr ""
"物理處理則使用類似的虛擬方法：``_physics_process()``。這個方法適合用於必須在"
"每個物理步驟發生前執行的計算，例如移動會與世界碰撞的角色。如前所述，"
"``_physics_process()`` 會盡可能以固定時間間隔執行，以確保物理互動的穩定性。你"
"可以在「專案設定」的「Physics → Common → Physics Fps」中調整物理步驟的間隔，"
"預設為每秒 60 次。"

msgid "The engine calls this method before every physics step:"
msgstr "每當引擎執行物理步驟前，會自動呼叫這個方法："

msgid ""
"The function ``_process()`` is not synchronized with physics. Its rate "
"depends on hardware and game optimization. It also runs after the physics "
"step in single-threaded games."
msgstr ""
"``_process()`` 方法並不會與物理處理同步。它的執行頻率取決於硬體效能與遊戲最佳"
"化狀況。在單執行緒遊戲中，_process() 會在物理步驟執行之後才被呼叫。"

msgid ""
"You can see the ``_process()`` function at work by creating a scene with a "
"single Label node, with the following script attached to it:"
msgstr ""
"你可以透過建立一個含有單一 Label 節點的場景，並掛載以下腳本，來觀察 "
"``_process()`` 方法的運作："

msgid "When you run the scene, you should see a counter increasing each frame."
msgstr "執行場景時，你會看到計數器隨著每一影格持續增加。"
