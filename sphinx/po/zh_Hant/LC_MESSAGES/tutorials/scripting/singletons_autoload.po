#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Singletons (Autoload)"
msgstr "單例（自動載入）"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot's scene system, while powerful and flexible, has a drawback: there is "
"no method for storing information (e.g. a player's score or inventory) that "
"is needed by more than one scene."
msgstr ""
"Godot 的場景系統雖然強大且彈性，但有個缺點：沒有方法可以儲存多個場景間需要共"
"享的資訊（例如玩家分數或物品欄）。"

msgid ""
"It's possible to address this with some workarounds, but they come with "
"their own limitations:"
msgstr "雖然可以用一些權宜之計來處理，但這些方法都有各自的限制："

msgid ""
"You can use a \"master\" scene that loads and unloads other scenes as its "
"children. However, this means you can no longer run those scenes "
"individually and expect them to work correctly."
msgstr ""
"你可以使用一個「主控」場景，將其他場景作為子場景載入與卸載。但這樣的話，這些"
"子場景就無法再獨立執行並正常運作。"

msgid ""
"Information can be stored to disk in ``user://`` and then loaded by scenes "
"that require it, but frequently saving and loading data is cumbersome and "
"may be slow."
msgstr ""
"你可以將資訊儲存到 ``user://`` 中，再讓需要的場景讀取，但頻繁的儲存與載入資料"
"既麻煩又可能拖慢速度。"

msgid ""
"The `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`_ "
"is a useful tool for solving the common use case where you need to store "
"persistent information between scenes. In our case, it's possible to reuse "
"the same scene or class for multiple singletons as long as they have "
"different names."
msgstr ""
"`單例模式 <https://zh.wikipedia.org/zh-tw/"
"%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F>`_ 是解決多場景間保存持續性資料的常見好"
"工具。在這裡，只要命名不同，就能用同一個場景或類別作為多個單例。"

msgid "Using this concept, you can create objects that:"
msgstr "利用此概念，你可以建立具備以下特性的物件："

msgid "Are always loaded, no matter which scene is currently running."
msgstr "無論目前執行哪個場景，都會一直被載入。"

msgid "Can store global variables such as player information."
msgstr "可儲存全域變數，如玩家資訊。"

msgid "Can handle switching scenes and between-scene transitions."
msgstr "可處理場景切換與場景間的轉場。"

msgid ""
"*Act* like a singleton, since GDScript does not support global variables by "
"design."
msgstr "**行為上** 如同單例，因為 GDScript 設計上並不支援全域變數。"

msgid "Autoloading nodes and scripts can give us these characteristics."
msgstr "自動載入節點與腳本便可實現這些特性。"

msgid ""
"Godot won't make an Autoload a \"true\" singleton as per the singleton "
"design pattern. It may still be instanced more than once by the user if "
"desired."
msgstr ""
"Godot 並不會讓自動載入成為「真正」的單例（如單例設計模式），如果需要，使用者"
"仍可將自動載入重複實體化。"

msgid ""
"If you're creating an autoload as part of an editor plugin, "
"consider :ref:`registering it automatically in the Project Settings "
"<doc_making_plugins_autoload>` when the plugin is enabled."
msgstr ""
"如果你是在開發編輯器外掛時建立自動載入，請考慮在啟用外掛時 :ref:`自動註冊到專"
"案設定 <doc_making_plugins_autoload>`。"

msgid "Autoload"
msgstr "自動載入"

msgid ""
"You can create an Autoload to load a scene or a script that inherits "
"from :ref:`class_Node`."
msgstr "你可以建立自動載入來載入從 :ref:`class_Node` 繼承的場景或腳本。"

msgid ""
"When autoloading a script, a :ref:`class_Node` will be created and the "
"script will be attached to it. This node will be added to the root viewport "
"before any other scenes are loaded."
msgstr ""
"當自動載入腳本時，會建立一個 :ref:`class_Node` 並附加該腳本。此節點會在其他場"
"景載入前被加到根檢視區。"

msgid ""
"To autoload a scene or script, start from the menu and navigate to **Project "
"> Project Settings > Globals > Autoload**."
msgstr ""
"要自動載入場景或腳本，請從選單進入 **專案 > 專案設定 > 全域 > 自動載入**。"

msgid ""
"Here you can add any number of scenes or scripts. Each entry in the list "
"requires a name, which is assigned as the node's ``name`` property. The "
"order of the entries as they are added to the global scene tree can be "
"manipulated using the up/down arrow keys. Like regular scenes, the engine "
"will read these nodes in top-to-bottom order."
msgstr ""
"你可以在這裡新增任意數量的場景或腳本。列表中的每個項目都需指定一個名稱，這會"
"成為節點的 ``name`` 屬性。加入全域場景樹的順序可用上下箭頭調整，和一般場景一"
"樣，會按由上至下順序讀取這些節點。"

msgid ""
"If the **Enable** column is checked (which is the default), then the "
"singleton can be accessed directly in GDScript:"
msgstr ""
"如果勾選了 **Enable** （啟用）欄（預設已勾選），就可以直接在 GDScript 以名稱"
"存取這個單例："

msgid ""
"The **Enable** column has no effect in C# code. However, if the singleton is "
"a C# script, a similar effect can be achieved by including a static property "
"called ``Instance`` and assigning it in ``_Ready()``:"
msgstr ""
"**Enable** （啟用）欄對 C# 程式碼沒有影響。不過，如果該單例是 C# 腳本，可以透"
"過新增一個名為 ``Instance`` 的靜態屬性，並在 ``_Ready()`` 指派來達到類似效"
"果："

msgid ""
"This allows the singleton to be accessed from C# code without ``GetNode()`` "
"and without a typecast:"
msgstr ""
"這可以讓 C# 程式碼在不使用 ``GetNode()`` 及不需型別轉換的情況下直接存取單例："

msgid ""
"Note that autoload objects (scripts and/or scenes) are accessed just like "
"any other node in the scene tree. In fact, if you look at the running scene "
"tree, you'll see the autoloaded nodes appear:"
msgstr ""
"請注意，存取自動載入物件（腳本或場景）方式和場景樹中其他節點相同。事實上，檢"
"查執行時的場景樹，就會看到自動載入的節點："

msgid ""
"Autoloads must **not** be removed using ``free()`` or ``queue_free()`` at "
"runtime, or the engine will crash."
msgstr ""
"執行時**絕對不能**用 ``free()`` 或 ``queue_free()`` 移除自動載入，否則引擎會"
"崩潰。"

msgid "Custom scene switcher"
msgstr "自訂場景切換器"

msgid ""
"This tutorial will demonstrate building a scene switcher using autoloads. "
"For basic scene switching, you can use "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method "
"(see :ref:`doc_scene_tree` for details). However, if you need more complex "
"behavior when changing scenes, this method provides more functionality."
msgstr ""
"本教學會示範如何用自動載入來製作場景切換器。若只需基本場景切換，可"
"用 :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 方法（詳"
"見 :ref:`doc_scene_tree`）。但如果切換場景時需要更複雜的行為，可用此方法獲得"
"更強功能。"

msgid ""
"To begin, download the template from here: `singleton_autoload_starter.zip "
"<https://github.com/godotengine/godot-docs-project-starters/releases/"
"download/latest-4.x/singleton_autoload_starter.zip>`_ and open it in Godot."
msgstr ""
"首先，請下載這個樣板：`singleton_autoload_starter.zip <https://github.com/"
"godotengine/godot-docs-project-starters/releases/download/latest-4.x/"
"singleton_autoload_starter.zip>`_ 並在 Godot 開啟。"

msgid ""
"A window notifying you that the project was last opened in an older Godot "
"version may appear, that's not an issue. Click *Ok* to open the project."
msgstr ""
"可能會出現一個視窗通知您專案上次是在較舊的 Godot 版本中開啟，這不是問題。點擊"
"「確定」以開啟專案。"

msgid ""
"The project contains two scenes: ``scene_1.tscn`` and ``scene_2.tscn``. Each "
"scene contains a label displaying the scene name and a button with its "
"``pressed()`` signal connected. When you run the project, it starts in "
"``scene_1.tscn``. However, pressing the button does nothing."
msgstr ""
"這個專案包含兩個場景：``scene_1.tscn`` 和 ``scene_2.tscn``。每個場景都有一個"
"顯示場景名稱的標籤和一個連結了 ``pressed()`` 訊號的按鈕。執行專案時會從 "
"``scene_1.tscn`` 開始，但按下按鈕目前不會有反應。"

msgid "Creating the script"
msgstr "建立腳本"

msgid ""
"Open the **Script** window and create a new script called ``global.gd``. "
"Make sure it inherits from ``Node``:"
msgstr ""
"切換到 **腳本** 視窗，建立一個名為 ``global.gd`` 的新腳本，並確認它繼承自 "
"``Node``："

msgid ""
"Now whenever we run any scene in the project, this script will always be "
"loaded."
msgstr "現在，無論執行專案裡哪個場景，這個腳本都會自動載入。"

msgid ""
"Returning to the script, it needs to fetch the current scene in the "
"`_ready()` function. Both the current scene (the one with the button) and "
"``global.gd`` are children of root, but autoloaded nodes are always first. "
"This means that the last child of root is always the loaded scene."
msgstr ""
"回到腳本，我們需要在 `_ready()` 取得目前場景。當前場景（有按鈕的那個）和 "
"``global.gd`` 都是根節點的子節點，但自動載入節點總是最先加入。這表示根節點的"
"最後一個子節點永遠是目前載入的場景。"

msgid ""
"Now we need a function for changing the scene. This function needs to free "
"the current scene and replace it with the requested one."
msgstr ""
"接著需要一個切換場景的函式，這個函式必須釋放目前的場景並換成指定的新場景。"

msgid ""
"Using :ref:`Object.call_deferred() <class_Object_method_call_deferred>`, the "
"second function will only run once all code from the current scene has "
"completed. Thus, the current scene will not be removed while it is still "
"being used (i.e. its code is still running)."
msgstr ""
"透過 :ref:`Object.call_deferred() <class_Object_method_call_deferred>`，第二"
"個函式只會在目前場景所有程式都執行完後才執行。如此就不會在場景還被使用（程式"
"還在跑）時將其移除。"

msgid ""
"Finally, we need to fill the empty callback functions in the two scenes:"
msgstr "最後，我們要在兩個場景裡填入空的回呼函式："

msgid "and"
msgstr "和"

msgid ""
"Run the project and test that you can switch between scenes by pressing the "
"button."
msgstr "執行專案並測試能否透過按鈕切換場景。"

msgid ""
"When scenes are small, the transition is instantaneous. However, if your "
"scenes are more complex, they may take a noticeable amount of time to "
"appear. To learn how to handle this, see the next "
"tutorial: :ref:`doc_background_loading`."
msgstr ""
"當場景很小時，切換會即時完成。但如果場景較複雜，可能會有明顯等待時間。想瞭解"
"如何處理，請參考下一篇教學：:ref:`doc_background_loading`。"

msgid ""
"Alternatively, if the loading time is relatively short (less than 3 seconds "
"or so), you can display a \"loading plaque\" by showing some kind of 2D "
"element just before changing the scene. You can then hide it just after the "
"scene is changed. This can be used to indicate to the player that a scene is "
"being loaded."
msgstr ""
"另外，如果載入時間不長（如小於 3 秒），可以在切換場景前先顯示某些 2D 元素，作"
"為「載入畫面」。場景切換完再隱藏這些元素。這樣可讓玩家知道場景正在載入。"
