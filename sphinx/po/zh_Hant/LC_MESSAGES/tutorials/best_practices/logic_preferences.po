#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Logic preferences"
msgstr "邏輯偏好"

msgid ""
"Ever wondered whether one should approach problem X with strategy Y or Z? "
"This article covers a variety of topics related to these dilemmas."
msgstr ""
"可曾想過問題 X 要用策略 Y 還是 Z 來解決？本篇文章將探討關於這類難題的各種主"
"題。"

msgid "Adding nodes and changing properties: which first?"
msgstr "先新增節點還是先修改屬性？"

msgid ""
"When initializing nodes from a script at runtime, you may need to change "
"properties such as the node's name or position. A common dilemma is, when "
"should you change those values?"
msgstr ""
"運作時使用腳本初始化節點時，你可能需要對節點的名稱、位置等屬性進行修改。常見"
"的糾結點在於，你應該什麼時候去修改？"

msgid ""
"It is the best practice to change values on a node before adding it to the "
"scene tree. Some property's setters have code to update other corresponding "
"values, and that code can be slow! For most cases, this code has no impact "
"on your game's performance, but in heavy use cases such as procedural "
"generation, it can bring your game to a crawl."
msgstr ""
"最佳實踐是在節點加入場景樹之前修改取值。部分屬性的 setter 程式碼會更新其他對"
"應的值，可能會比較慢！大多數情況下，這樣的程式碼不會對遊戲的性能產生影響，但"
"對於程式式生成之類的重型使用場景，就可能讓遊戲卡成 PPT。"

msgid ""
"For these reasons, it is usually best practice to set the initial values of "
"a node before adding it to the scene tree. There are some exceptions where "
"values *can't* be set before being added to the scene tree, like setting "
"global position."
msgstr ""
"基於這些原因，通常最佳實務是在將節點加入場景樹之前設定其初始值。但也存在一些"
"例外情況，某些值在加入場景樹之前 *無法* 設定，例如設定全域位置。"

msgid "Loading vs. preloading"
msgstr "載入 (Load) vs. 預載入 (Preload)"

msgid ""
"In GDScript, there exists the global :ref:`preload "
"<class_@GDScript_method_preload>` method. It loads resources as early as "
"possible to front-load the \"loading\" operations and avoid loading "
"resources while in the middle of performance-sensitive code."
msgstr ""
"在 GDScript 中，有一個全域的 :ref:`preload <class_@GDScript_method_preload>` "
"方法。通過這個方法可以儘量將「載入」操作提早執行，並避免在效能敏感的程式執行"
"時載入資源。"

msgid ""
"Its counterpart, the :ref:`load <class_@GDScript_method_load>` method, loads "
"a resource only when it reaches the load statement. That is, it will load a "
"resource in-place which can cause slowdowns when it occurs in the middle of "
"sensitive processes. The ``load()`` function is also an alias "
"for :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` "
"which is accessible to *all* scripting languages."
msgstr ""
"相對地，:ref:`load <class_@GDScript_method_load>` 方法則只會在碰到 load 陳述"
"式時才載入資源。也就是說，load 方法只會就地載入資源，而當在敏感的處理過程中使"
"用 load 就會讓程式變慢。 ``load`` 方法同時也"
"是 :ref:`ResourceLoader.load(path) <class_ResourceLoader_method_load>` 的別"
"名，這個方法可以在 **所有** 腳本語言中存取。"

msgid ""
"So, when exactly does preloading occur versus loading, and when should one "
"use either? Let's see an example:"
msgstr ""
"那麼，Load 與 Preload 實際上到底差在哪裡呢？什麼時候又該用什麼呢？請看看這個"
"範例："

msgid ""
"If something else could replace the value (like a scene's exported "
"initialization), then preloading the value has no meaning. This point isn't "
"a significant factor if one intends to always create the script on its own."
msgstr ""
"若可以使用其他東西來代替某個值 (特別是場景的匯出初始化)，則預加載這個值就沒有"
"意義。如果平常都是自行製作腳本的話，那麼這一點就並非重要因素。"

msgid ""
"If one wishes only to 'import' another class resource (script or scene), "
"then using a preloaded constant is often the best course of action. However, "
"in exceptional cases, one may wish not to do this:"
msgstr ""
"如果只是想要「匯入」另一個類別資源 (腳本或場景)，那麼使用預加載的常數應該是最"
"好的方法。但是，有幾個例外情況下最好不要這麼做："

msgid ""
"If the 'imported' class is liable to change, then it should be a property "
"instead, initialized either using an ``@export`` or a ``load()`` (and "
"perhaps not even initialized until later)."
msgstr ""
"如果這個「被匯入」的類別可能會變動，那麼它應該是一個屬性，並透過 ``@export`` "
"或 ``load()`` 進行初始化（甚至可能延後初始化）。"

msgid "Large levels: static vs. dynamic"
msgstr "大型關卡：靜態 vs. 動態"

msgid ""
"Well, the simple answer is, \"when the performance requires it.\" The "
"dilemma associated with the two options is one of the age-old programming "
"choices: does one optimize memory over speed, or vice versa?"
msgstr ""
"這個嘛，用一句話來回答的話就是，「如果效能有需要的時候。」。其實這種兩難的情"
"況跟一個古老的程式設計問題有關：要對記憶體最佳化還是對速度最佳化？"

msgid ""
"The naive answer is to use a static level that loads everything at once. "
"But, depending on the project, this could consume a large amount of memory. "
"Wasting users' RAM leads to programs running slow or outright crashing from "
"everything else the computer tries to do at the same time."
msgstr ""
"而最簡單的方法就是使用單一靜態關卡，並一次載入所有東西。但是，依據不同的專"
"案，這樣可能會吃掉很多的記憶體。浪費使用者的 RAM 也會導致程式執行地很慢，或是"
"當電腦嘗試同時做其他事情時讓遊戲當機。"

msgid ""
"No matter what, one should break larger scenes into smaller ones (to aid in "
"reusability of assets). Developers can then design a node that manages the "
"creation/loading and deletion/unloading of resources and nodes in real-time. "
"Games with large and varied environments or procedurally generated elements "
"often implement these strategies to avoid wasting memory."
msgstr ""
"無論如何，我們都應該將大型場景切分成許多小的場景 (來提升素材的可復用性)。開發"
"人員可以設計一個節點，來即時管理資源與節點的建立／載入與刪除／取消載入。有大"
"型且多樣化環境的遊戲，或是會連續產生多個元素的遊戲，通常會使用這種策略來減少"
"浪費記憶體。"

msgid "As such, the best options would be..."
msgstr "因此，最好的做法應該是…"

msgid ""
"For an example of the various ways one can swap scenes around at runtime, "
"please see the :ref:`\"Change scenes manually\" "
"<doc_change_scenes_manually>` documentation."
msgstr ""
"有關在執行時間切換場景的各種方法的範例，請參考 :ref:`「手動更改場景」 "
"<doc_change_scenes_manually>` 說明文件。"
