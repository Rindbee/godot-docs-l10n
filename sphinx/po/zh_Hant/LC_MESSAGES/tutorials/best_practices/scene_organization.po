#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "場景組織"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should you use? Where should you place them? How should "
"they interact?"
msgstr ""
"本篇文章涵蓋了與有效組織場景內容相關的主題。您應該使用哪些節點？應該將它們放"
"置在哪裡？它們應該如何互動？"

msgid "How to build relationships effectively"
msgstr "如何有效地建立關係"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "當 Godot 使用者開始製作自己的場景時，通常會遇到下列問題："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"建立好第一個場景並往場景中加上內容，最後會開始覺得場景逐漸變得複雜，應該要把"
"東西都切割成小塊，所以就將場景中的各個分支都保存為獨立的場景。但是，接著就會"
"發現之前在腳本裡直接引用其他節點的方法不能用了。在多個地方重複使用場景也會出"
"問題，因為沒辦法用節點路徑找到目標，然後在編輯器中建的訊號連接也會斷開。"

msgid ""
"To fix these problems, you must instantiate the sub-scenes without them "
"requiring details about their environment. You need to be able to trust that "
"the sub-scene will create itself without being picky about how it's used."
msgstr ""
"為了解決這些問題，您必須實例化子場景，使其不需要關於其環境的詳細資訊。您需要"
"能夠信任子場景會自行建立，而不會挑剔其使用方式。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"OOP 中要考慮的最重要的一點就是要維持一個專注且單一目的的類別，並與程式碼中其"
"他部分 `鬆散耦合 <https://zh.wikipedia.org/zh-tw/"
"%E6%9D%BE%E8%80%A6%E5%90%88>`_ 。這樣可以讓物件的大小維持得比較小 (為了可維護"
"性) 並提高類別的可用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "這些 OOP 最佳實踐在場景結構與腳本使用上實際是 **數種** 最佳實踐。"

msgid ""
"**If at all possible, you should design scenes to have no dependencies.** "
"That is, you should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**如果可以的話，您應該設計場景使其沒有依賴性。** 也就是說，您應該創建將所需的"
"一切都包含在自身之內的場景。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"若場景必須要與外部的東西互動，則有經驗的工程師推薦使用 `依賴注入 <https://"
"zh.wikipedia.org/zh-tw/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_ 。這個技術是使"
"用高等 API 來提動低等 API 的相依性。為什麼要這麼做？因為仰賴外部環境的類別可"
"能會不小心觸發 Bug 或未預期的行為。"

msgid ""
"To do this, you must expose data and then rely on a parent context to "
"initialize it:"
msgstr "若要這麼做，您必須公開資料，然後依賴父層上下文來初始化它："

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"連接訊號。非常安全，但訊號應該只用來「回覆」一個行為，而不是執行行為。請注"
"意，訊號名稱通常使用過去式動詞，如「entered」、「skill_activated」或"
"「item_collected」。"

msgid "Call a method. Used to start behavior."
msgstr "呼叫方法。用於開始一個行為。"

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`Callable <class_Callable>` 屬性。比起方法物件更安全，因為無需考"
"慮方法的所有權。用於啟動行為。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 參照。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. You can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"這些選項會隱藏子節點的存取點。 這反過來使子節點與其環境保持**鬆散耦合**。 您"
"可以在其他情境中重複使用它，而無需對其 API 進行任何額外的變更。"

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their own hierarchies while an ancestor mediates "
"their communications and references."
msgstr ""
"雖然上面的範例說明了父子關係，但相同的原則適用於所有物件關係。同層級的節點應"
"該只知道它們自己的階層，而由共同的祖先節點來協調它們之間的溝通和引用。"

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object owns the other objects "
"should manage the relationships between them."
msgstr ""
"相同的原則也適用於非節點物件，它們也可能維持著對其他物件的依賴關係。無論哪個"
"物件擁有其他物件，都應該管理它們之間的關係。"

msgid ""
"You should favor keeping data in-house (internal to a scene), though, as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation to use it safely is error-prone by default."
msgstr ""
"不過，你應該傾向於將資料保留在內部（場景內部），因為即使是鬆散耦合地依賴外部"
"環境，仍然意味著節點會期望其環境中存在某些條件。專案的設計理念應該避免這種情"
"況發生。如果沒有，程式碼固有的缺陷將迫使開發者使用文件來追蹤微觀層面的物件關"
"係；這也就是俗稱的開發地獄。編寫依賴外部文件才能安全使用的程式碼，預設就容易"
"出錯。"

msgid ""
"To avoid creating and maintaining such documentation, you convert the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no "
"child :ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The "
"editor then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""
"為了避免建立和維護這類文件，您可以將依賴的節點（上方的「子節點」）轉換為實作 "
"``_get_configuration_warnings()`` 的工具腳本。 從該函式回傳一個非空的 "
"PackedStringArray 會使「場景」停靠視窗在該節點旁產生一個警告圖示，並將字串內"
"容顯示為工具提示。這與 :ref:`Area2D <class_Area2D>` 節點在沒有定義"
"子 :ref:`CollisionShape2D <class_CollisionShape2D>` 節點時所顯示的警告圖示相"
"同。如此一來，編輯器便能透過腳本程式碼自我說明場景，無需再重複撰寫文件內容。"

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"像這樣的 GUI 可以更好的通知專案使用者有關節點的重要訊息。節點有外部相依性嗎？"
"相依性有滿足嗎？其他的程式設計師，尤其是設計師與作家，會需要更清楚的指示來瞭"
"解如何正確設定這些節點。"

msgid ""
"So, why does all this complex switcheroo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class, and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely affecting other classes dependent on it."
msgstr ""
"那麼，為什麼這一切複雜的轉換手法會有效呢？嗯，因為場景在獨立運作時表現最好。"
"如果無法獨立運作，那麼匿名地與其他場景協同工作（盡可能減少硬依賴，也就是鬆散"
"耦合）就是次佳的選擇。不可避免地，類別可能需要進行變更，如果這些變更導致它以"
"無法預見的方式與其他場景互動，那麼事情就會開始出錯。所有這些間接手段的重點在"
"於避免最終陷入一種情況：變更一個類別會對依賴它的其他類別產生不利影響。"

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"節點與場景，作為引擎類別的延伸，應該要能套用 **所有** OOP 原則。這些原則的例"
"子包含..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr ""
"`SOLID <https://zh.wikipedia.org/zh-tw/"
"SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr ""
"`DRY <https://zh.wikipedia.org/zh-tw/"
"%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://zh.wikipedia.org/zh-tw/KISS%E5%8E%9F%E5%88%99>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://zh.wikipedia.org/zh-tw/YAGNI>`_"

msgid "Choosing a node tree structure"
msgstr "選擇一種節點樹架構"

msgid ""
"You might start to work on a game but get overwhelmed by the vast "
"possibilities before you. You might know what you want to do, what systems "
"you want to have, but *where* do you put them all? How you go about making "
"your game is always up to you. You can construct node trees in countless "
"ways. If you are unsure, this guide can give you a sample of a decent "
"structure to start with."
msgstr ""
"您可能剛開始製作遊戲，但卻被眼前廣泛的可能性弄得不知所措。您可能知道想做什"
"麼、想要哪些系統，但*要將它們都放在哪裡*呢？如何著手製作您的遊戲始終取決於"
"您。您可以用無數種方式建構節點樹。如果您不確定，本指南可以提供一個不錯的起始"
"結構範例供您參考。"

msgid ""
"A game should always have an \"entry point\"; somewhere you can definitively "
"track where things begin so that you can follow the logic as it continues "
"elsewhere. It also serves as a bird's eye view of all other data and logic "
"in the program. For traditional applications, this is normally a \"main\" "
"function. In Godot, it's a Main node."
msgstr ""
"一個遊戲應該總是會有一個「進入點」；一個你可以明確追蹤事物從何開始的地方，這"
"樣你才能夠在邏輯延續到其他地方時跟隨它。它也像是一個鳥瞰圖，呈現程式中所有其"
"他的資料和邏輯。對於傳統應用程式來說，這通常是一個「main」函式。在 Godot 裡，"
"它是一個主要的節點（Main node）。"

msgid "Node \"Main\" (main.gd)"
msgstr "Node「Main」(main.gd)"

msgid ""
"The ``main.gd`` script will serve as the primary controller of your game."
msgstr "``main.gd`` 這個腳本將會作為你遊戲的主要控制器。"

msgid ""
"Then you have an in-game \"World\" (a 2D or 3D one). This can be a child of "
"Main. In addition, you will need a primary GUI for your game that manages "
"the various menus and widgets the project needs."
msgstr ""
"接著您會有一個遊戲內的「世界」(2D 或 3D 的)。它可以是 Main 的子節點。此外，您"
"的遊戲會需要一個主要的 GUI (圖形使用者介面)，用來管理專案所需的各種選單和小工"
"具。"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D “世界”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control「GUI」(gui.gd)"

msgid ""
"When changing levels, you can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives you "
"full control over how your game world transitions."
msgstr ""
"當切換關卡時，您可以替換 \"World\" 節點的子節點。:ref:`手動切換場景 "
"<doc_change_scenes_manually>` 讓您完全掌控遊戲世界的轉換方式。"

msgid ""
"The next step is to consider what gameplay systems your project requires. If "
"you have a system that..."
msgstr "下一步是考量你的專案需要哪些遊戲機制。如果你有一個機制是..."

msgid "tracks all of its data internally"
msgstr "能在內部追蹤所有的資料"

msgid "should be globally accessible"
msgstr "可以在所有地方存取"

msgid "should exist in isolation"
msgstr "獨立存在"

msgid ""
"... then you should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"... 那麼您應該建立一個 :ref:`自動載入的「單例」節點 "
"<doc_singletons_autoload>`。"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method to swap out the main "
"scene's content. This structure more or less keeps the \"World\" as the main "
"game node."
msgstr ""
"對於小型遊戲，一個較簡單但可控性較低的做法是建立一個「Game」單例，並單純呼"
"叫 :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 來切換主場景內容。這種架構會將"
"「World」作為主要的遊戲節點保留。"

msgid ""
"Any GUI would also need to be either a singleton, a transitory part of the "
"\"World\", or manually added as a direct child of the root. Otherwise, the "
"GUI nodes would also delete themselves during scene transitions."
msgstr ""
"任何 GUI 也需要是單例（singleton）、世界（World）的暫時性部分，或是手動新增為"
"根節點的直接子節點。否則，GUI 節點也會在場景切換期間自行刪除。"

msgid ""
"If you have systems that modify other systems' data, you should define those "
"as their own scripts or scenes, rather than autoloads. For more information, "
"see :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>`."
msgstr ""
"如果您有會修改其他系統資料的系統，您應該將它們定義為獨立的腳本或場景，而不是"
"自動載入。更多資訊請參閱：:ref:`自動載入與一般節點的比較 "
"<doc_autoloads_versus_internal_nodes>` 。"

msgid ""
"Each subsystem within your game should have its own section within the "
"SceneTree. You should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that the children should also be removed? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"您遊戲中的每個子系統都應該在場景樹中擁有自己的區塊。您應該只在節點實際上是其"
"父節點的組成元素時，才使用父子關係。移除父節點是否合理地意味著子節點也應該被"
"移除？如果不是，那麼它應該在層級結構中作為同層級節點或其他關係擁有自己的位"
"置。"

msgid ""
"In some cases, you need these separated nodes to *also* position themselves "
"relative to each other. You can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"在某些情況下，您會需要這些分離的節點彼此之間也能夠相對定位。您可以使"
"用 :ref:`RemoteTransform3D "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` 節點來達成這個目的。它們能讓目標節點有條件地繼承來"
"自 Remote\\* 節點所選取的變形元素。要指定 ``target`` :ref:`NodePath "
"<class_NodePath>`，請使用下列其中一種方式："

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "可信的第三方，可能是母節點，來居中分配。"

msgid ""
"A group, to pull a reference to the desired node (assuming there will only "
"ever be one of the targets)."
msgstr "一個群組，用於拉取對目標節點的參照（假設目標只會有一個）。"

msgid ""
"When you should do this is subjective. The dilemma arises when you must "
"micro-manage when a node must move around the SceneTree to preserve itself. "
"For example..."
msgstr ""
"何時應該這樣做是很主觀的。當你為了保存節點而必須細微地管理它在場景樹中的移動"
"時，這個難題就產生了。例如..."

msgid "Add a \"player\" node to a \"room\"."
msgstr "將「玩家」節點加到「房間」中。"

msgid "Need to change rooms, so you must delete the current room."
msgstr "需要更換房間，因此您必須刪除目前的房間。"

msgid ""
"Before the room can be deleted, you must preserve and/or move the player."
msgstr "在刪除房間之前，您必須保留和/或移動玩家。"

msgid "If memory is not a concern, you can..."
msgstr "如果記憶體不是問題，你可以..."

msgid "Create the new room."
msgstr "建立新的房間。"

msgid "Move the player to the new room."
msgstr "將玩家移動到新的房間。"

msgid "Delete the old room."
msgstr "刪除舊房間。"

msgid "If memory is a concern, instead you will need to..."
msgstr "如果考量到記憶體用量，那麼你需要..."

msgid "Move the player somewhere else in the tree."
msgstr "將玩家移動到樹狀結構中其他地方。"

msgid "Delete the room."
msgstr "刪除房間。"

msgid "Instantiate and add the new room."
msgstr "實體化並建立新的房間。"

msgid "Re-add the player to the new room."
msgstr "將玩家重新加入新的房間。"

msgid ""
"The issue is that the player here is a \"special case\" where the developers "
"must *know* that they need to handle the player this way for the project. "
"The only way to reliably share this information as a team is to *document* "
"it. Keeping implementation details in documentation is dangerous. It's a "
"maintenance burden, strains code readability, and unnecessarily bloats the "
"intellectual content of a project."
msgstr ""
"問題在於此處的玩家是一個「特殊情況」，開發者必須「知道」專案需要以這種方式處"
"理玩家。團隊可靠地共享此資訊的唯一方法是將其「文件化」。將實作細節保留在文件"
"中是很危險的。這會增加維護負擔、降低程式碼可讀性，並不必要地膨脹專案的智力內"
"容。"

msgid ""
"In a more complex game with larger assets, it can be a better idea to keep "
"the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"在擁有較大型素材的複雜遊戲中，將玩家物件完全放在場景樹的其他地方可能會是更好"
"的做法。這會帶來："

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "沒有必須要寫成文件並在其他地方維護的「特例」。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "不會因為沒有注意到細節而有發生錯誤的機會。"

msgid ""
"In contrast, if you ever need a child node that does *not* inherit the "
"transform of its parent, you have the following options:"
msgstr ""
"相對地，如果您需要一個 **不** 繼承其父節點變形（transform）的子節點，您可以考"
"慮以下選項："

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. Since it doesn't have a transform, they won't pass this information to "
"its children."
msgstr ""
"**宣告式** 解決方案：在它們之間放置一個 :ref:`節點 <class_Node>`。由於它沒有"
"變換（transform），因此不會將此資訊傳遞給其子節點。"

msgid ""
"The **imperative** solution: Use the ``top_level`` property for "
"the :ref:`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**指令式** 解法：在 :ref:`CanvasItem <class_CanvasItem_property_top_level>` "
"或 :ref:`Node3D <class_Node3D_property_top_level>` 節點上設定 ``top_level`` "
"屬性。這樣該節點會忽略繼承來的變換。"

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic - they only need their own. Keeping them in a "
"separate branch from the \"world\" can help simplify the management of game "
"connections and the like."
msgstr ""
"如果正在開發網路遊戲，請記住哪些節點和遊戲系統是所有玩家都相關的，哪些僅適用"
"於權威伺服器。例如，使用者並不需要擁有每個玩家「PlayerController」邏輯的副本 "
"- 他們只需要自己的。將這些邏輯放在與「世界」不同的分支中，有助於簡化遊戲連線"
"等管理。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"場景組織的關鍵就是要以關聯的方式來考量 SceneTree 而不是用空間性來考量。節點是"
"否會仰賴母節點的存在？若不仰賴，則節點可以就完全可以在別的地方活得好好的。若"
"有依賴母節點，則這種依賴關係就是子節點要是母節點的子節點的原因 (而且，顯然必"
"須是母節點的場景中的一部分，如果還不是母節點的場景中的一部分的話)。"

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"you still have the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"這表示節點本身就是組件嗎？一點也不是。Godot 的節點樹形成的是聚合關係，而不是"
"組合關係。不過，雖然您仍然可以彈性地移動節點，但預設情況下最好還是避免這種移"
"動。"
