#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "A better XR start script"
msgstr "更完善的 XR 啟動腳本"

msgid ""
"In :ref:`doc_setting_up_xr` we introduced a startup script that initialises "
"our setup which we used as our script on our main node. This script performs "
"the minimum steps required for any given interface."
msgstr ""
"在 :ref:`doc_setting_up_xr` 中，我們介紹了一個初始化 XR 設定的啟動腳本，並將"
"其作為主節點的腳本。該腳本執行了每個介面所需的最基本步驟。"

msgid ""
"When using OpenXR there are a number of improvements we should do here. For "
"this we've created a more elaborate starting script. You will find these "
"used in our demo projects."
msgstr ""
"當使用 OpenXR 時，這裡有許多可以改進的地方。為此，我們設計了一個更完整的啟動"
"腳本，你可以在我們的範例專案中看到這些腳本的應用。"

msgid ""
"Alternatively, if you are using XR Tools "
"(see :ref:`doc_introducing_xr_tools`) it contains a version of this script "
"updated with some features related to XR tools."
msgstr ""
"另外，如果你使用 XR Tools（請參閱 :ref:`doc_introducing_xr_tools`），其中包含"
"了針對 XR 工具功能升級過的這個腳本版本。"

msgid ""
"Below we will detail out the script used in our demos and explain the parts "
"that are added."
msgstr "以下我們會詳細說明範例專案中所使用的腳本，並解釋新增的部分。"

msgid "Signals for our script"
msgstr "腳本訊號"

msgid ""
"We are introducing 3 signals to our script so that our game can add further "
"logic:"
msgstr "我們為腳本新增了三個訊號，讓遊戲可以根據這些事件添加額外邏輯："

msgid ""
"``focus_lost`` is emitted when the player takes off their headset or when "
"the player enters the menu system of the headset."
msgstr ""
"當玩家取下頭戴式裝置或進入頭戴式裝置的選單系統時，會發出 ``focus_lost`` 訊"
"號。"

msgid ""
"``focus_gained`` is emitted when the player puts their headset back on or "
"exits the menu system and returns to the game."
msgstr ""
"當玩家戴回頭戴式裝置或從選單系統返回遊戲時，會發出 ``focus_gained`` 訊號。"

msgid ""
"``pose_recentered`` is emitted when the headset requests the player's "
"position to be reset."
msgstr "當頭戴式裝置要求重設玩家的位置時，會發出 ``pose_recentered`` 訊號。"

msgid "Our game should react accordingly to these signals."
msgstr "我們的遊戲應根據這些訊號作出相應的反應。"

msgid "Variables for our script"
msgstr "腳本變數"

msgid "We introduce a few new variables to our script as well:"
msgstr "我們也為腳本新增了一些變數："

msgid ""
"``maximum_refresh_rate`` will control the headsets refresh rate if this is "
"supported by the headset."
msgstr "如果裝置支援，``maximum_refresh_rate`` 會控制頭戴式裝置的更新率。"

msgid ""
"``xr_interface`` holds a reference to our XR interface, this already existed "
"but we now type it to get full access to our :ref:`XRInterface "
"<class_xrinterface>` API."
msgstr ""
"``xr_interface`` 儲存 XR 介面的參考。這個變數本來就存在，但我們現在加上型別，"
"以便完整存取 :ref:`XRInterface <class_xrinterface>` API。"

msgid "``xr_is_focussed`` will be set to true whenever our game has focus."
msgstr "只要遊戲處於焦點狀態，``xr_is_focussed`` 就會設為 true。"

msgid "Our updated ready function"
msgstr "已更新的 ready 函式"

msgid "We add a few things to the ready function."
msgstr "我們為 ready 函式增加了一些處理。"

msgid ""
"If we're using the mobile or forward+ renderer we set the viewport's "
"``vrs_mode`` to ``VRS_XR``. On platforms that support this, this will enable "
"foveated rendering."
msgstr ""
"若使用 mobile 或 forward+ 算繪器，請將檢視埠的 ``vrs_mode`` 設為 ``VRS_XR``。"
"在支援的平台上，這會啟用注視點算繪（foveated rendering）。"

msgid ""
"If we're using the compatibility renderer, we check if the OpenXR foveated "
"rendering settings are configured and if not, we output a warning. "
"See :ref:`OpenXR Settings <doc_openxr_settings>` for further details."
msgstr ""
"如果使用 compatibility 繪圖器，會檢查 OpenXR 的視網膜渲染設定是否已正確設置，"
"若否則會顯示警告。詳情請參閱 :ref:`OpenXR 設定 <doc_openxr_settings>`。"

msgid ""
"We hook up a number of signals that will be emitted by the :ref:`XRInterface "
"<class_xrinterface>`. We'll provide more detail about these signals as we "
"implement them."
msgstr ""
"我們連接數個來自 :ref:`XRInterface <class_xrinterface>` 的訊號。接下來會詳細"
"介紹這些訊號的處理方式。"

msgid ""
"We also quit our application if we couldn't successfully initialise OpenXR. "
"Now this can be a choice. If you are making a mixed mode game you setup the "
"VR mode of your game on success, and setup the non-VR mode of your game on "
"failure. However, when running a VR only application on a standalone "
"headset, it is nicer to exit on failure than to hang the system."
msgstr ""
"如果無法成功初始化 OpenXR，則會直接結束應用程式。這可以視需求調整：若你的遊戲"
"支援混合模式，可以在初始化成功時啟用 VR 模式，失敗時則切換為非 VR 模式。不"
"過，若是在獨立頭戴裝置上執行僅支援 VR 的遊戲，失敗時直接結束程式會比讓系統卡"
"住來得友善。"

msgid "On session begun"
msgstr "啟動階段"

msgid ""
"This signal is emitted by OpenXR when our session is setup. This means the "
"headset has run through setting everything up and is ready to begin "
"receiving content from us. Only at this time various information is properly "
"available."
msgstr ""
"當 OpenXR 完成初始化並建立連線後，會發送此訊號。這代表頭戴裝置已完成所有設"
"定，準備好接收內容。此時，各項資訊才會正確取得。"

msgid ""
"The main thing we do here is to check our headset's refresh rate. We also "
"check the available refresh rates reported by the XR runtime to determine if "
"we want to set our headset to a higher refresh rate."
msgstr ""
"此處的重點是檢查頭戴裝置的更新頻率。我們也會查看 XR 執行階段回報的可用更新頻"
"率，以決定是否要將頭戴裝置設定為更高的更新頻率。"

msgid ""
"Finally we match our physics update rate to our headset update rate. Godot "
"runs at a physics update rate of 60 updates per second by default while "
"headsets run at a minimum of 72, and for modern headsets often up to 144 "
"frames per second. Not matching the physics update rate will cause "
"stuttering as frames are rendered without objects moving."
msgstr ""
"最後，我們會將物理運算更新率調整為與頭戴裝置的更新率一致。Godot 預設每秒進行 "
"60 次物理更新，而頭戴裝置最低通常為 72Hz，現代裝置甚至可達 144Hz。如果兩者不"
"同步，會導致畫面更新但物件未移動，造成卡頓現象。"

msgid "On visible state"
msgstr "進入可見狀態"

msgid ""
"This signal is emitted by OpenXR when our game becomes visible but is not "
"focused. This is a bit of a weird description in OpenXR but it basically "
"means that our game has just started and we're about to switch to the "
"focused state next, that the user has opened a system menu or the user has "
"just took their headset off."
msgstr ""
"當遊戲變為可見但未取得焦點時，OpenXR 會發出這個訊號。這在 OpenXR 中的描述有點"
"特殊，但基本上代表遊戲剛啟動、接下來即將切換為焦點狀態，或使用者開啟了系統選"
"單，或是剛取下頭戴裝置。"

msgid ""
"On receiving this signal we'll update our focused state, we'll change the "
"process mode of our node to disabled which will pause processing on this "
"node and its children, and emit our ``focus_lost`` signal."
msgstr ""
"收到此訊號時，我們會更新焦點狀態，將本節點的處理模式設為停用，以暫停此節點與"
"其子節點的處理，並發出 ``focus_lost`` 訊號。"

msgid ""
"If you've added this script to your root node, this means your game will "
"automatically pause when required. If you haven't, you can connect a method "
"to the signal that performs additional changes."
msgstr ""
"如果你將這個腳本加在根節點，則遊戲會在必要時自動暫停。若未加在根節點，也可以"
"連接自訂方法到這個訊號，以實現額外的行為。"

msgid ""
"While your game is in visible state because the user has opened a system "
"menu, Godot will keep rendering frames and head tracking will remain active "
"so your game will remain visible in the background. However controller and "
"hand tracking will be disabled until the user exits the system menu."
msgstr ""
"當遊戲因使用者開啟系統選單而處於可見狀態時，Godot 仍會持續渲染畫面且頭部追蹤"
"仍然啟用，因此遊戲會在背景中保持可見。不過，控制器與手部追蹤將會停用，直到玩"
"家離開系統選單。"

msgid "On focussed state"
msgstr "取得焦點狀態"

msgid ""
"This signal is emitted by OpenXR when our game gets focus. This is done at "
"the completion of our startup, but it can also be emitted when the user "
"exits a system menu, or put their headset back on."
msgstr ""
"當遊戲取得焦點時，OpenXR 會發出此訊號。這通常是在啟動過程結束時發出，但也可能"
"在玩家離開系統選單或戴回頭戴裝置時發出。"

msgid ""
"Note also that when your game starts while the user is not wearing their "
"headset, the game stays in 'visible' state until the user puts their headset "
"on."
msgstr ""
"請注意，如果遊戲啟動時使用者尚未戴上頭戴裝置，遊戲會維持在「可見」狀態，直到"
"玩家戴上裝置才會取得焦點。"

msgid ""
"It is thus important to keep your game paused while in visible mode. If you "
"don't the game will keep on running while your user isn't interacting with "
"your game. Also when the game returns to the focused mode, suddenly all "
"controller and hand tracking is re-enabled and could have game breaking "
"consequences if you do not react to this accordingly. Be sure to test this "
"behavior in your game!"
msgstr ""
"因此，當遊戲處於可見模式時，務必保持遊戲暫停。否則，遊戲會在玩家未互動時持續"
"運作。而當重新取得焦點時，所有控制器與手部追蹤會瞬間重新啟用，若未妥善處理，"
"可能造成遊戲破壞性的後果。請務必在遊戲內測試這些行為！"

msgid ""
"While handling our signal we will update the focuses state, unpause our node "
"and emit our ``focus_gained`` signal."
msgstr ""
"在處理該訊號時，我們會更新焦點狀態，解除節點暫停，並發出 ``focus_gained`` 訊"
"號。"

msgid "On stopping state"
msgstr "停止狀態"

msgid ""
"This signal is emitted by OpenXR when we enter our stop state. There are "
"some differences between platforms when this happens. On some platforms this "
"is only emitted when the game is being closed. But on other platforms this "
"will also be emitted every time the player takes off their headset."
msgstr ""
"當進入停止狀態時，OpenXR 會發出此訊號。各平台觸發時機略有不同，有些平台僅在遊"
"戲關閉時發出，有些則在玩家每次取下頭戴裝置時也會發出。"

msgid "For now this method is only a place holder."
msgstr "目前這個方法僅作為預留位置。"

msgid "On pose recentered"
msgstr "重新置中定位"

msgid ""
"This signal is emitted by OpenXR when the user requests their view to be "
"recentered. Basically this communicates to your game that the user is now "
"facing forward and you should re-orient the player so they are facing "
"forward in the virtual world."
msgstr ""
"當玩家要求重新置中視角時，OpenXR 會發出此訊號。這代表玩家現在正面朝前，應將遊"
"戲中的角色朝向虛擬世界的正前方。"

msgid ""
"As doing so is dependent on your game, your game needs to react accordingly."
msgstr "由於具體行為取決於你的遊戲，因此需要根據需求適當處理。"

msgid ""
"All we do here is emit the ``pose_recentered`` signal. You can connect to "
"this signal and implement the actual recenter code. Often it is enough to "
"call :ref:`center_on_hmd() <class_XRServer_method_center_on_hmd>`."
msgstr ""
"這裡我們只需發出 ``pose_recentered`` 訊號。你可以連接此訊號並實作實際的重新置"
"中程式碼，通常只要呼叫 :ref:`center_on_hmd() "
"<class_XRServer_method_center_on_hmd>` 即可。"

msgid ""
"And that finished our script. It was written so that it can be re-used over "
"multiple projects. Just add it as the script on your main node (and extend "
"it if needed) or add it on a child node specific for this script."
msgstr ""
"這樣我們的腳本就完成了。此腳本設計可在多個專案中重複使用。你只需將其作為主節"
"點的腳本（有需要可擴充），或加在專用的子節點上即可。"
