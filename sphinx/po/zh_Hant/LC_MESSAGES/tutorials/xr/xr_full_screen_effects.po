#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "XR full screen effects"
msgstr "XR 全螢幕效果"

msgid ""
"When adding custom full screen effects to your XR application, one approach "
"is using a full screen quad and applying effects to that quad's shader. Add "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene as a child "
"of your :ref:`XRCamera3D <class_XRCamera3D>`, and set the ``mesh`` property "
"to a :ref:`QuadMesh <class_QuadMesh>`. Set the width and height of the quad "
"to ``2``."
msgstr ""
"在 XR 應用程式中加入自訂的全螢幕效果時，一種做法是使用覆蓋全螢幕的四邊形，並"
"將效果套用至該四邊形的著色器。請在場景中、你的 :ref:`XRCamera3D "
"<class_XRCamera3D>` 節點下新增一個 :ref:`MeshInstance3D "
"<class_MeshInstance3D>` 節點，將其 ``mesh`` 屬性設為 :ref:`QuadMesh "
"<class_QuadMesh>`，並將四邊形的寬與高設為 ``2``。"

msgid ""
"You can then add a shader to your quad to make it cover the screen. This is "
"done by setting the vertex shader's ``POSITION`` built-in to "
"``vec4(VERTEX.xy, 1.0, 1.0)``. However, when creating an effect that is "
"centered straight ahead in the user's view (such as a vignette effect), the "
"end result may look incorrect in XR."
msgstr ""
"接著替四邊形加入著色器，讓它覆蓋整個畫面。方法是將頂點著色器的內建 "
"``POSITION`` 設為 ``vec4(VERTEX.xy, 1.0, 1.0)``。然而，當你要製作一個在使用者"
"視野正前方置中的效果（例如暗角）時，最終結果在 XR 中可能會看起來不正確。"

msgid ""
"Below shows captures of the right-eye view with a vignette shader, both from "
"the headset and the render target itself. The left captures are an "
"unmodified shader; the right captures adjust the full screen quad using the "
"projection matrix. While the capture on the left is centered in the render "
"target, it is off-center in the headset view. But, after applying the "
"projection matrix, we see that the effect is centered in the headset itself."
msgstr ""
"下方展示了右眼視圖使用暗角著色器的擷取畫面，包含來自頭戴裝置與算繪目標本身的"
"影像。左側是未修改的著色器；右側則是使用投影矩陣調整過的全螢幕四邊形。左側影"
"像雖在算繪目標中置中，但在頭戴裝置中卻偏離中心；在套用投影矩陣後，效果就會在"
"頭戴裝置中正確置中。"

msgid "Applying the projection matrix"
msgstr "套用投影矩陣"

msgid ""
"To properly center the effect, the ``POSITION`` of the full screen quad "
"needs to take the asymmetric field of view into account. To do this while "
"also ensuring the quad has full coverage of the entire render target, we can "
"subdivide the quad and apply the projection matrix to the inner vertices. "
"Let's increase the subdivide width and depth of the quad."
msgstr ""
"要讓效果正確置中，必須在全螢幕四邊形的 ``POSITION`` 中考量非對稱視野。為了同"
"時確保四邊形仍能完整覆蓋整個算繪目標，我們可以將四邊形細分，並將投影矩陣套用"
"到內部的頂點。先將四邊形的細分寬度與深度調高。"

msgid ""
"Then, in the vertex function of our shader, we apply an offset from the "
"projection matrix to the inner vertices. Here's an example of how you might "
"do this with the above simple vignette shader:"
msgstr ""
"接著在著色器的頂點函式中，將投影矩陣導出的偏移套用到內部頂點。以下示範如何在"
"上面的簡單暗角著色器中完成這件事："

msgid ""
"For more info on asymmetric FOV and its purpose, see this `Meta Asymmetric "
"Field of View FAQ <https://developers.meta.com/horizon/documentation/unity/"
"unity-asymmetric-fov-faq/>`_."
msgstr ""
"關於非對稱視野及其用途的更多資訊，請參考此文件：`Meta Asymmetric Field of "
"View FAQ <https://developers.meta.com/horizon/documentation/unity/unity-"
"asymmetric-fov-faq/>`_。"

msgid "Limitations"
msgstr "限制"

msgid ""
"This full screen effect method has no performance concerns for per-pixel "
"effects such as the above vignette shader. However, it is not recommended to "
"read from the screen texture when using this technique. Full screen effects "
"that require reading from the screen texture effectively disable all "
"rendering performance optimizations in XR. This is because, when reading "
"from the screen texture, Godot makes a full copy of the render buffer; this "
"drastically increases the workload for the GPU and can create performance "
"concerns."
msgstr ""
"上述這種全螢幕效果的做法，對於像是暗角這類逐像素效果而言沒有效能疑慮。然而，"
"不建議在使用此技巧時從螢幕紋理進行讀取。需要讀取螢幕紋理的全螢幕效果，會實際"
"上停用 XR 中所有的算繪效能最佳化。原因在於，一旦需要讀取螢幕紋理，Godot 會完"
"整拷貝算繪緩衝區，這會大幅增加 GPU 的工作量並引發效能問題。"
