#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_Hant\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The main game scene"
msgstr "測試場景"

msgid ""
"Now it's time to bring everything we did together into a playable game scene."
msgstr "現在是時候將我們所做的一切整合到一個可玩的遊戲場景中了。"

msgid ""
"Create a new scene and add a :ref:`Node <class_Node>` named ``Main``. (The "
"reason we are using Node instead of Node2D is because this node will be a "
"container for handling game logic. It does not require 2D functionality "
"itself.)"
msgstr ""
"創建新場景，然後加入一個 :ref:`Node <class_Node>` 節點，並命名為``Main``\\ 。"
"（我們之所以使用 Node 而不是 Node2D ，是因為這個節點是處理遊戲邏輯的容器，本"
"身並不需 2D 的功能。）"

msgid ""
"Click the **Instance** button (represented by a chain link icon) and select "
"your saved ``player.tscn``."
msgstr ""
"點擊 **產生實體** 按鈕（由鏈條圖示表示）並選擇保存的 ``player.tscn`` 。"

msgid ""
"Now, add the following nodes as children of ``Main``, and name them as shown:"
msgstr "現在，將下列節點新增為 ``Main`` 的子節點，並依照所示命名："

msgid ""
":ref:`Timer <class_Timer>` (named ``MobTimer``) - to control how often mobs "
"spawn"
msgstr ""
":ref:`Timer <class_Timer>` （名稱為 ``MobTimer`` ）——用以控制怪物產生的頻率"

msgid ""
":ref:`Timer <class_Timer>` (named ``ScoreTimer``) - to increment the score "
"every second"
msgstr ""
":ref:`Timer <class_Timer>` （名稱為 ``ScoreTimer`` ）——用以每秒增加成績"

msgid ""
":ref:`Timer <class_Timer>` (named ``StartTimer``) - to give a delay before "
"starting"
msgstr ""
":ref:`Timer <class_Timer>` （名稱為 ``StartTimer`` ）——用以在開始前延遲"

msgid ""
":ref:`Marker2D <class_Marker2D>` (named ``StartPosition``) - to indicate the "
"player's start position"
msgstr ""
":ref:`Marker2D <class_Marker2D>`（命名為 ``StartPosition``）—用來標示玩家的起"
"始位置"

msgid ""
"Set the ``Wait Time`` property of each of the ``Timer`` nodes as follows "
"(values are in seconds):"
msgstr "將每個 ``Timer`` 節點的 ``等待時間`` 屬性設定如下（數值單位為秒）："

msgid "``MobTimer``: ``0.5``"
msgstr "``MobTimer``: ``0.5``"

msgid "``ScoreTimer``: ``1``"
msgstr "``ScoreTimer``: ``1``"

msgid "``StartTimer``: ``2``"
msgstr "``StartTimer``: ``2``"

msgid ""
"In addition, set the ``One Shot`` property of ``StartTimer`` to \"On\" and "
"set ``Position`` of the ``StartPosition`` node to ``(240, 450)``."
msgstr ""
"另外，將 ``StartTimer`` 的 ``One Shot`` 屬性設為「開啟」，並將 "
"``StartPosition`` 節點的 ``Position`` 設為 ``(240, 450)`` 。"

msgid "Spawning mobs"
msgstr "產生怪物"

msgid ""
"The Main node will be spawning new mobs, and we want them to appear at a "
"random location on the edge of the screen. Click the ``Main`` node in the "
"Scene dock, then add a child :ref:`Path2D <class_Path2D>` node named "
"``MobPath``. When you select ``Path2D``, you will see some new buttons at "
"the top of the editor:"
msgstr ""
"Main 節點將會產生新的怪物，而我們希望它們在螢幕邊緣的隨機位置出現。於 Scene "
"面板點選 ``Main`` 節點，新增一個名為 ``MobPath`` 的子節點 :ref:`Path2D "
"<class_Path2D>`。選取 ``Path2D`` 後，你會在編輯器上方看到一些新的按鈕："

msgid ""
"Select the middle one (\"Add Point\") and draw the path by clicking to add "
"the points at the corners shown. To have the points snap to the grid, make "
"sure \"Use Grid Snap\" and \"Use Smart Snap\" are both selected. These "
"options can be found to the left of the \"Lock\" button, appearing as a "
"magnet next to some dots and intersecting lines, respectively."
msgstr ""
"選擇中間的按鈕 (「新增控制點」)，然後點擊顯示的轉角處來新增控制點並繪製路徑。"
"若要將控制點吸附到網格上，請開啟「使用網格吸附」與「使用吸附」選項，這兩個選"
"項在「鎖定」按鈕的左邊，顯示的圖示是一個磁鐵跟幾條相交的線。"

msgid ""
"Draw the path in *clockwise* order, or your mobs will spawn pointing "
"*outwards* instead of *inwards*!"
msgstr ""
"請確定以 **順時針** 方向繪製路徑，不然的話怪物會 **向外** 產生而不是 **向內"
"** 產生！"

msgid ""
"After placing point ``4`` in the image, click the \"Close Curve\" button and "
"your curve will be complete."
msgstr ""
"在圖片內放置了點 ``4`` 以後，點擊「關閉曲線」按鈕，就可以完成繪製曲線。"

msgid ""
"Now that the path is defined, add a :ref:`PathFollow2D <class_PathFollow2D>` "
"node as a child of ``MobPath`` and name it ``MobSpawnLocation``. This node "
"will automatically rotate and follow the path as it moves, so we can use it "
"to select a random position and direction along the path."
msgstr ""
"現在路徑已經定義好了，接著我們新增一個 :ref:`PathFollow2D "
"<class_PathFollow2D>` 節點作為 ``MobPath`` 的子節點，並將其命名為 "
"``MobSpawnLocation`` 。這個節點會在移動的時候自動旋轉並跟著路徑移動，所以我們"
"可以用 MobPath 來在路徑上隨機選擇位置與方向。"

msgid "Your scene should look like this:"
msgstr "現在場景看起來會這樣："

msgid "Main script"
msgstr "Main（主要）腳本"

msgid ""
"Add a script to ``Main``. At the top of the script, we use ``@export var "
"mob_scene: PackedScene`` to allow us to choose the Mob scene we want to "
"instance."
msgstr ""
"為 ``Main`` 新增一個腳本。在腳本的頂部，我們會用 ``export (PackedScene)`` 來"
"選擇要實體化的 ``Mob`` 場景。"

msgid ""
"Click the ``Main`` node and you will see the ``Mob Scene`` property in the "
"Inspector under \"Main.gd\"."
msgstr ""
"點擊 ``Main`` 節點，您會在 Inspector（屬性檢視器）中「Main.gd」下方看到 "
"``Mob Scene`` 屬性。"

msgid "You can assign this property's value in two ways:"
msgstr "要為這個屬性賦值有兩個方法："

msgid ""
"Drag ``mob.tscn`` from the \"FileSystem\" dock and drop it in the **Mob "
"Scene** property."
msgstr "從「檔案系統」面板中拖移 ``Mob.tscn`` 到 ``Mob`` 屬性來。"

msgid ""
"Click the down arrow next to \"[empty]\" and choose \"Load\". Select "
"``mob.tscn``."
msgstr "點擊「[空]」旁邊的下拉箭頭，並選擇「載入」。接著選擇 ``Mob.tscn`` 。"

msgid ""
"Next, select the instance of the ``Player`` scene under ``Main`` node in the "
"Scene dock, and access the Node dock on the sidebar. Make sure to have the "
"Signals tab selected in the Node dock."
msgstr ""
"接著，從場景 Dock 中選擇 ``Player`` 節點，然後前往側欄的節點 Dock 中。節選選"
"擇節點 Dock 中的 [訊號] 分頁。"

msgid ""
"You should see a list of the signals for the ``Player`` node. Find and "
"double-click the ``hit`` signal in the list (or right-click it and select "
"\"Connect...\"). This will open the signal connection dialog. We want to "
"make a new function named ``game_over``, which will handle what needs to "
"happen when a game ends. Type \"game_over\" in the \"Receiver Method\" box "
"at the bottom of the signal connection dialog and click \"Connect\". You are "
"aiming to have the ``hit`` signal emitted from ``Player`` and handled in the "
"``Main`` script. Add the following code to the new function, as well as a "
"``new_game`` function that will set everything up for a new game:"
msgstr ""
"接著應該可以看到所有 ``Player`` 節點的訊號。點兩下列表中的 ``hit`` 訊號 (或是"
"右鍵點擊然後選擇 [連接...])。這樣便可以打開訊號連接對話框。這裡我們要把新函式"
"命名為 ``game_over`` ，這個函式會負責處理遊戲結束時要做的事。在 [連接訊號] 視"
"窗中的 [Receiver 方法] 內輸入「game_over」，並點擊 [連接]。將下列程式碼加到新"
"建立的函式當中，接著新增一個 ``new_game`` 函式，負責在遊戲開始時搞定一切："

msgid ""
"Now we'll connect the ``timeout()`` signal of each Timer node "
"(``StartTimer``, ``ScoreTimer``, and ``MobTimer``) to the main script. For "
"each of the three timers, select the timer in the Scene dock, open the "
"Signals tab of the Node dock, then double-click the ``timeout()`` signal in "
"the list. This will open a new signal connection dialog. The default "
"settings in this dialog should be fine, so select **Connect** to create a "
"new signal connection."
msgstr ""
"接著我們要把每個 Timer 節點（``StartTimer``、``ScoreTimer``、``MobTimer``）"
"的 ``timeout()`` 訊號連到主腳本。對每個計時器，在 Scene 面板選中後，打開右側 "
"Node 面板的 Signals 分頁，接著在清單中按兩下 ``timeout()`` 訊號。會開啟新的訊"
"號連線對話框，使用預設設定即可，點選 **Connect** 建立連線。"

msgid ""
"Once all three timers have this set up, you should be able to see each timer "
"have a Signal connection for their respective ``timeout()`` signal, showing "
"in green, within their respective Signals tabs:"
msgstr ""
"三個計時器都設定完成後，你應該能在各自的 Signals 分頁中看到其 ``timeout()`` "
"訊號已顯示為綠色並完成連線："

msgid "(For MobTimer): ``_on_mob_timer_timeout()``"
msgstr "（MobTimer）：``_on_mob_timer_timeout()``"

msgid "(For ScoreTimer): ``_on_score_timer_timeout()``"
msgstr "（ScoreTimer）：``_on_score_timer_timeout()``"

msgid "(For StartTimer): ``_on_start_timer_timeout()``"
msgstr "（StartTimer）：``_on_start_timer_timeout()``"

msgid ""
"Now we define how each of these timers operate by adding the code below. "
"Notice that ``StartTimer`` will start the other two timers, and that "
"``ScoreTimer`` will increment the score by 1."
msgstr ""
"現在我們以以下程式碼定義各計時器的行為。請注意，``StartTimer`` 會啟動另外兩個"
"計時器，而 ``ScoreTimer`` 會將分數加 1。"

msgid ""
"In ``_on_mob_timer_timeout()``, we will create a mob instance, pick a random "
"starting location along the ``Path2D``, and set the mob in motion. The "
"``PathFollow2D`` node will automatically rotate as it follows the path, so "
"we will use that to select the mob's direction as well as its position. When "
"we spawn a mob, we'll pick a random value between ``150.0`` and ``250.0`` "
"for how fast each mob will move (it would be boring if they were all moving "
"at the same speed)."
msgstr ""
"接著我們在 ``_on_MobTimer_timeout()`` 中建立怪物的實體，並沿著 ``Path2D`` 來"
"隨機選擇一個起始位置，然後讓怪物開始移動。在跟隨路徑時 ``PathFollow2D`` 節點"
"會自動旋轉，所以我們在使用這個節點來選擇怪物的位置的同時也會一起選擇方向。"

msgid ""
"Note that a new instance must be added to the scene using ``add_child()``."
msgstr ""
"需要注意的是，新建立的節點必須要使用 ``add_child()`` 來將節點新增到場景中。"

msgid ""
"Why ``PI``? In functions requiring angles, Godot uses *radians*, not "
"degrees. Pi represents a half turn in radians, about ``3.1415`` (there is "
"also ``TAU`` which is equal to ``2 * PI``). If you're more comfortable "
"working with degrees, you'll need to use the ``deg_to_rad()`` and "
"``rad_to_deg()`` functions to convert between the two."
msgstr ""
"為什麼要使用 ``PI`` （圓周率）呢？在需要角度的函式中，GDScript 會使用 **弧度"
"** 而不是角度。如果你比較喜歡用角度的話，則需要使用 ``deg2rad()`` （角度轉弧"
"度）與 ``rad2deg()`` （弧度轉角度）兩個函式來轉換弧度與角度。"

msgid "Testing the scene"
msgstr "測試場景"

msgid ""
"Let's test the scene to make sure everything is working. Add this "
"``new_game`` call to ``_ready()``:"
msgstr ""
"來測試一下場景，看看是不是所有東西都正常了。將下面這段程式碼新增至 "
"``_ready()`` 中："

msgid ""
"Let's also assign ``Main`` as our \"Main Scene\" - the one that runs "
"automatically when the game launches. Press the \"Play\" button and select "
"``main.tscn`` when prompted."
msgstr ""
"同時，將 ``Main`` 設為「主要場景」——也就是遊戲啟動後會自動執行的場景。點擊"
"「執行」按鈕，當提示框出現後選擇 ``Main.tscn`` 。"

msgid ""
"If you had already set another scene as the \"Main Scene\", you can right "
"click ``main.tscn`` in the FileSystem dock and select \"Set As Main Scene\"."
msgstr ""
"如果你已經將別的場景設定為“主場景”了，你可以在“檔案系統”面板上右鍵點擊 "
"``main.tscn`` 並選擇“設為主場景”。"

msgid ""
"You should be able to move the player around, see mobs spawning, and see the "
"player disappear when hit by a mob."
msgstr ""
"現在應該可以到處移動玩家了，並會看到怪物產生出來。玩家在被怪物撞到後會消失。"

msgid ""
"When you're sure everything is working, remove the call to ``new_game()`` "
"from ``_ready()`` and replace it with ``pass``."
msgstr ""
"當您確定一切運作正常後，請從 ``_ready()`` 中移除呼叫 ``new_game()`` 的程式"
"碼，並將其替換為 ``pass`` 。"

msgid ""
"What's our game lacking? Some user interface. In the next lesson, we'll add "
"a title screen and display the player's score."
msgstr ""
"我們的遊戲還缺點啥？缺使用者介面。在下一課中，我們將會新增標題介面並且顯示玩"
"家的分數。"
