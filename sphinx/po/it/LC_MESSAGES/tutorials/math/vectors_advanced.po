#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "Matematica vettoriale avanzata"

msgid "Planes"
msgstr "Piani"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"Il prodotto scalare ha un'altra proprietà interessante con i vettori "
"unitari. Immagina che la perpendicolare a quel vettore (e passante per "
"l'origine) passi un piano. I piani dividono l'intero spazio in positivo "
"(sopra il piano) e negativo (sotto il piano), e (contrariamente a quanto si "
"pensa) puoi utilizzare la loro matematica anche in 2D:"

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"I vettori unitari perpendicolari a una superficie (che quindi ne descrivono "
"l'orientamento) sono chiamati **vettori normali unitari** (o versori). "
"Tuttavia, di solito sono semplicemente abbreviati in *normali*. Le normali "
"compaiono nei piani, nella geometria 3D (per determinare dove è rivolta ogni "
"faccia o vertice), ecc. Una **normale** *è* un **vettore unitario**, ma si "
"chiama *normale* per via del suo utilizzo. (Proprio come chiamiamo (0,0) "
"l'Origine!)."

msgid ""
"The plane passes by the origin and the surface of it is perpendicular to the "
"unit vector (or *normal*). The side the vector points to is the positive "
"half-space, while the other side is the negative half-space. In 3D this is "
"exactly the same, except that the plane is an infinite surface (imagine an "
"infinite, flat sheet of paper that you can orient and is pinned to the "
"origin) instead of a line."
msgstr ""
"Il piano passa per l'origine e la sua superficie è perpendicolare al vettore "
"unitario (o *normale*). Il lato verso cui punta il vettore è il semispazio "
"positivo, mentre l'altro lato è il semispazio negativo. In 3D è esattamente "
"la stessa cosa, tranne per il fatto che il piano è una superficie infinita "
"(immagina un foglio di carta piatto, infinito, fissato all'origine e che "
"puoi orientare) invece di una linea."

msgid "Distance to plane"
msgstr "Distanza dal piano"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"Ora che è chiaro cos'è un piano, torniamo al prodotto scalare. Il prodotto "
"scalare tra un **vettore unitario** e un qualsiasi **punto nello spazio** "
"(sì, questa volta facciamo il prodotto scalare tra vettore e posizione), "
"restituisce la **distanza dal punto al piano**:"

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr ""
"Ma non solo la distanza assoluta, se il punto si trova nel semispazio "
"negativo anche la distanza sarà negativa:"

msgid "This allows us to tell which side of the plane a point is."
msgstr ""
"Questo ci permette di stabilire da quale lato del piano si trova un punto."

msgid "Away from the origin"
msgstr "Lontano dall'origine"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"So cosa stai pensando! Fin qui tutto bene, ma i piani *reali* sono ovunque "
"nello spazio, non passano solo per l'origine. Vuoi vera azione sui *piani* e "
"la vuoi *adesso*."

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"Ricorda che i piani non solo dividono lo spazio in due, ma hanno anche una "
"*polarità*. Ciò significa che è possibile avere piani perfettamente "
"sovrapposti, ma i loro semispazi negativo e positivo sono invertiti."

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"Con questo in mente, descriviamo un piano completo come una **normale** *N* "
"e uno scalare **distanza dall'origine** *D*. Quindi, il nostro piano è "
"rappresentato da N e D. Per esempio:"

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"Per la matematica 3D, Godot fornisce un tipo integrato :ref:`Plane "
"<class_Plane>` che gestisce questo."

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"In sostanza, N e D possono rappresentare qualsiasi piano nello spazio, sia "
"in 2D sia in 3D (a seconda del numero di dimensioni di N) e la matematica è "
"la stessa per entrambi. È la stessa di prima, ma D è la distanza "
"dall'origine al piano, che si muove nella direzione N. Ad esempio, immagina "
"di voler raggiungere un punto nel piano:"

msgid "The same thing, using a built-in function:"
msgstr "La stessa cosa, utilizzando una funzione integrata:"

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"L'inversione della polarità del piano può essere ottenuta negando sia N sia "
"D. Questo si tradurrà in un piano nella stessa posizione, ma con i semispazi "
"negativo e positivo invertiti:"

msgid ""
"Godot also implements this operator in :ref:`Plane <class_Plane>`. So, using "
"the format below will work as expected:"
msgstr ""
"Godot implementa questo operatore anche in :ref:`Plane <class_Plane>`. "
"Quindi, utilizzando il formato seguente funzionerà come previsto:"

msgid "Constructing a plane in 2D"
msgstr "Costruire un piano in 2D"

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so calculate D from the dot product of the normal and "
"the point."
msgstr ""
"Nel caso di una normale e un punto, la maggior parte del lavoro è già stata "
"fatta, poiché la normale è già calcolata, quindi calcola D dal prodotto "
"scalare della normale e del punto."

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90 degrees to either "
"side:"
msgstr ""
"Per due punti nello spazio, ci sono in realtà due piani che li attraversano, "
"condividendo lo stesso spazio ma con la normale rivolta in direzioni "
"opposte. Per calcolare la normale ai due punti, bisogna prima ricavare il "
"vettore direzione, e poi ruotarlo di 90 gradi da un lato o dall'altro:"

msgid ""
"The rest is the same as the previous example. Either point_a or point_b will "
"work, as they are in the same plane:"
msgstr ""
"Il resto è identico all'esempio precedente. Sia point_a sia point_b "
"funzioneranno, poiché si trovano sullo stesso piano:"

msgid ""
"Doing the same in 3D is a little more complex and is explained further down."
msgstr "Fare lo stesso in 3D è un po' più complesso ed è spiegato più avanti."

msgid "Some examples of planes"
msgstr "Qualche esempio di piano"

msgid ""
"Here is an example of what planes are useful for. Imagine you have a `convex "
"<https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"Ecco un esempio su cosa servono i piani. Immagina di avere un poligono "
"`convesso <https://www.mathsisfun.com/definitions/convex.html>`__. Ad "
"esempio, un rettangolo, un trapezio, un triangolo o qualsiasi altro poligono "
"in cui nessuna faccia si pieghi verso l'interno."

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"Per ogni segmento del poligono, calcoliamo il piano che passa per quel "
"segmento. Una volta ottenuta la lista dei piani, possiamo fare cose "
"interessanti, ad esempio verificare se un punto è interno al poligono."

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"Passiamo attraverso tutti i piani: se riusciamo a trovare un piano la cui "
"distanza dal punto sia positiva, allora il punto è esterno al poligono. Se "
"non ci riusciamo, allora il punto è interno."

msgid "Code should be something like this:"
msgstr "Il codice dovrebbe assomigliare a questo:"

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"Davvero geniale, eh? Ma c'è di meglio! Con un po' più di impegno, una logica "
"simile ci permette di sapere anche quando due poligoni convessi si "
"sovrappongono. Questo è chiamato il teorema dell'asse di separazione (o SAT) "
"e gran parte dei motori di fisica lo utilizza per rilevare le collisioni."

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"Con un punto, è sufficiente verificare se un piano restituisce una distanza "
"positiva per stabilire se il punto è esterno. Con un altro poligono, "
"dobbiamo trovare un piano in cui *tutti* *gli* *altri* *punti* *del "
"poligono* restituiscano una distanza positiva. Questa verifica è effettuata "
"con i piani di A contro i punti di B, e poi con i piani di B contro i punti "
"di A:"

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"Come puoi vedere, i piani sono piuttosto utili, e questa è solo la punta "
"dell'iceberg. Potreste chiedervi cosa succede con un poligono non convesso. "
"Di solito è gestito dividendo il poligono concavo in poligoni convessi più "
"piccoli, o utilizzando una tecnica come BSP (la quale non è molto comune al "
"giorno d'oggi)."

msgid "Collision detection in 3D"
msgstr "Rilevamento di collisioni in 3D"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"Questo è un altro bonus, una ricompensa per la pazienza e per aver seguito "
"questo lungo tutorial. Ecco un altra perla di saggezza. Potrebbe non essere "
"utile direttamente (Godot già rileva le collisioni piuttosto bene), ma è "
"utilizzato da quasi tutti i motori di fisica e le librerie di rilevamento "
"delle collisioni :)"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"Ricordi che la conversione di una forma convessa in 2D in una matrice di "
"piani 2D era utile per rilevare il rilevamento delle collisioni? Potevi "
"rilevare se un punto si trovava all'interno di una qualsiasi forma convessa, "
"o se due forme convesse 2D si sovrapponevano."

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"Beh, ciò funziona anche in 3D: se due forme poliedriche 3D entrano in "
"collisione, non riuscirai a trovare un piano di separazione. Se ci riesci, "
"allora le forme non sono entrate in collisione, decisamente."

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"Per rinfrescare un po' la memoria, un piano di separazione significa che "
"tutti i vertici del poligono A si trovano su un lato del piano, e tutti i "
"vertici del poligono B si trovano sull'altro lato. Questo piano è sempre uno "
"dei piani delle facce del poligono A o del poligono B."

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"In 3D, tuttavia, c'è un problema con questo approccio, perché è possibile "
"che, in alcuni casi, non sia possibile trovare un piano di separazione. Ecco "
"un esempio di tale situazione:"

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"Per evitarlo, alcuni piani aggiuntivi si devono testare come separatori. "
"Questi piani sono il prodotto vettoriale tra i bordi del poligono A e i "
"bordi del poligono B"

msgid "So the final algorithm is something like:"
msgstr "Quindi l'algoritmo finale è qualcosa del genere:"

msgid "More information"
msgstr "Maggiori informazioni"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr ""
"Per maggiori informazioni sull'utilizzo della matematica vettoriale in "
"Godot, consulta il seguente articolo:"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
