#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Vector math"
msgstr "Matematica vettoriale"

msgid "Introduction"
msgstr "Introduzione"

msgid ""
"This tutorial is a short and practical introduction to linear algebra as it "
"applies to game development. Linear algebra is the study of vectors and "
"their uses. Vectors have many applications in both 2D and 3D development and "
"Godot uses them extensively. Developing a good understanding of vector math "
"is essential to becoming a strong game developer."
msgstr ""
"Questo tutorial è un'introduzione breve e pratica all'algebra lineare "
"applicata allo sviluppo di giochi. L'algebra lineare è lo studio dei vettori "
"e dei loro utilizzi. I vettori hanno numerose applicazioni nello sviluppo "
"sia 2D sia 3D e Godot li usa ampiamente. Sviluppare una buona comprensione "
"della matematica vettoriale è essenziale per diventare un bravo sviluppatore "
"di giochi."

msgid ""
"This tutorial is **not** a formal textbook on linear algebra. We will only "
"be looking at how it is applied to game development. For a broader look at "
"the mathematics, see https://www.khanacademy.org/math/linear-algebra"
msgstr ""
"Questo tutorial **non** è un libro di testo formale sull'algebra lineare. Ci "
"limiteremo a vedere come è applicata allo sviluppo di giochi. Per una "
"panoramica più ampia sulla matematica, consultare https://"
"www.khanacademy.org/math/linear-algebra"

msgid "Coordinate systems (2D)"
msgstr "Sistemi di coordinate (2D)"

msgid ""
"In 2D space, coordinates are defined using a horizontal axis (``x``) and a "
"vertical axis (``y``). A particular position in 2D space is written as a "
"pair of values such as ``(4, 3)``."
msgstr ""
"Nello spazio 2D, le coordinate sono definite da un asse orizzontale (``x``) "
"e un asse verticale (``y``). Una posizione specifica nello spazio 2D è "
"scritta come una coppia di valori come ``(4, 3)``."

msgid ""
"If you're new to computer graphics, it might seem odd that the positive "
"``y`` axis points **downwards** instead of upwards, as you probably learned "
"in math class. However, this is common in most computer graphics "
"applications."
msgstr ""
"Se sei nuovo con la computer grafica, potrebbe sembrare strano che l'asse "
"``y`` positivo punti **verso il basso** invece che verso l'alto, come "
"probabilmente hai imparato a lezione di matematica. Tuttavia, questo è "
"comune nella maggior parte delle applicazioni di computer grafica."

msgid ""
"Any position in the 2D plane can be identified by a pair of numbers in this "
"way. However, we can also think of the position ``(4, 3)`` as an **offset** "
"from the ``(0, 0)`` point, or **origin**. Draw an arrow pointing from the "
"origin to the point:"
msgstr ""
"Qualsiasi posizione nel piano 2D può essere identificata da una coppia di "
"numeri in questo modo. Tuttavia, possiamo anche pensare alla posizione ``(4, "
"3)`` come a una **differenza** dal punto ``(0, 0)``, o **origine**. Disegna "
"una freccia che punta dall'origine al punto:"

msgid ""
"This is a **vector**. A vector represents a lot of useful information. As "
"well as telling us that the point is at ``(4, 3)``, we can also think of it "
"as an angle ``θ`` (theta) and a length (or magnitude) ``m``. In this case, "
"the arrow is a **position vector** - it denotes a position in space, "
"relative to the origin."
msgstr ""
"Questo è un **vettore**. Un vettore rappresenta molte utili informazioni. "
"Oltre a dirci che il punto si trova a ``(4, 3)``, possiamo anche "
"considerarlo come un angolo ``θ`` (theta) e una lunghezza (o modulo, "
"magnitudine) ``m``. In questo caso, la freccia è un **vettore di posizione** "
"- indica una posizione nello spazio, relativa all'origine."

msgid ""
"A very important point to consider about vectors is that they only represent "
"**relative** direction and magnitude. There is no concept of a vector's "
"position. The following two vectors are identical:"
msgstr ""
"Un aspetto molto importante da considerare riguardo ai vettori è che "
"rappresentano solo direzione e modulo **relativi**. Non esiste il concetto "
"di posizione di un vettore. I seguenti due vettori sono identici:"

msgid ""
"Both vectors represent a point 4 units to the right and 3 units below some "
"starting point. It does not matter where on the plane you draw the vector, "
"it always represents a relative direction and magnitude."
msgstr ""
"Entrambi i vettori rappresentano un punto 4 unità a destra e 3 unità sotto "
"un punto di partenza. Non importa in quale punto del piano si traccia il "
"vettore, rappresenta sempre una direzione e un modulo relativi."

msgid "Vector operations"
msgstr "Operazioni vettoriali"

msgid ""
"You can use either method (x and y coordinates or angle and magnitude) to "
"refer to a vector, but for convenience, programmers typically use the "
"coordinate notation. For example, in Godot, the origin is the top-left "
"corner of the screen, so to place a 2D node named ``Node2D`` 400 pixels to "
"the right and 300 pixels down, use the following code:"
msgstr ""
"È possibile utilizzare entrambi i metodi (coordinate x e y, angolo e modulo) "
"per riferirsi a un vettore, ma per comodità, i programmatori in genere "
"utilizzano la notazione di coordinate. Ad esempio, in Godot, l'origine è "
"l'angolo in alto a sinistra dello schermo, quindi per posizionare un nodo 2D "
"denominato ``Node2D`` 400 pixel a destra e 300 pixel in basso, utilizza il "
"seguente codice:"

msgid ""
"Godot supports both :ref:`Vector2 <class_Vector2>` and :ref:`Vector3 "
"<class_Vector3>` for 2D and 3D usage, respectively. The same mathematical "
"rules discussed in this article apply to both types, and wherever we link to "
"``Vector2`` methods in the class reference, you can also check out their "
"``Vector3`` counterparts."
msgstr ""
"Godot supporta sia :ref:`Vector2 <class_Vector2>` sia :ref:`Vector3 "
"<class_Vector3>`, rispettivamente per l'utilizzo in 2D e 3D. Le stesse "
"regole matematiche discusse in questo articolo si applicano a entrambi i "
"tipi e, ogni volta che includiamo collegamenti ai metodi di ``Vector2`` nel "
"riferimento alle classi, puoi anche consultare le loro controparti di "
"``Vector3``."

msgid "Member access"
msgstr "Accesso ai membri"

msgid ""
"The individual components of the vector can be accessed directly by name."
msgstr ""
"È possibile accedere direttamente ai singoli componenti del vettore per nome."

msgid "Adding vectors"
msgstr "Addizione di vettori"

msgid ""
"When adding or subtracting two vectors, the corresponding components are "
"added:"
msgstr ""
"Quando si sommano o si sottraggono due vettori, i componenti corrispondenti "
"sono sommati:"

msgid ""
"We can also see this visually by adding the second vector at the end of the "
"first:"
msgstr ""
"Possiamo anche visualizzarlo aggiungendo il secondo vettore alla fine del "
"primo:"

msgid "Note that adding ``a + b`` gives the same result as ``b + a``."
msgstr "Nota che sommare ``a + b`` dà lo stesso risultato di ``b + a``."

msgid "Scalar multiplication"
msgstr "Moltiplicazione scalare"

msgid ""
"Vectors represent both direction and magnitude. A value representing only "
"magnitude is called a **scalar**. Scalars use the :ref:`class_float` type in "
"Godot."
msgstr ""
"I vettori rappresentano sia la direzione sia la magnitudine (o modulo). Un "
"valore che rappresenta solo la magnitudine è chiamato **scalare**. Gli "
"scalari usano il tipo :ref:`class_float` in Godot."

msgid "A vector can be multiplied by a **scalar**:"
msgstr "Un vettore può essere moltiplicato per uno **scalare**:"

msgid ""
"Multiplying a vector by a positive scalar does not change its direction, "
"only its magnitude. Multiplying with a negative scalar results in a vector "
"in the opposite direction. This is how you **scale** a vector."
msgstr ""
"Moltiplicare un vettore per uno scalare positivo non ne cambia la direzione, "
"ma solo il modulo. Moltiplicare per uno scalare negativo produce un vettore "
"nella direzione opposta. Così si **scala** un vettore."

msgid "Practical applications"
msgstr "Applicazioni pratiche"

msgid "Let's look at two common uses for vector addition and subtraction."
msgstr ""
"Diamo un'occhiata a due utilizzi comuni dell'addizione e della sottrazione "
"vettoriale."

msgid "Movement"
msgstr "Movimento"

msgid ""
"A vector can represent **any** quantity with a magnitude and direction. "
"Typical examples are: position, velocity, acceleration, and force. In this "
"image, the spaceship at step 1 has a position vector of ``(1, 3)`` and a "
"velocity vector of ``(2, 1)``. The velocity vector represents how far the "
"ship moves each step. We can find the position for step 2 by adding the "
"velocity to the current position."
msgstr ""
"Un vettore può rappresentare **qualsiasi** grandezza con modulo e direzione. "
"Esempi tipici sono: posizione, velocità, accelerazione e forza. In questa "
"immagine, al primo passo, l'astronave ha un vettore posizione pari a ``(1, "
"3)`` e un vettore velocità pari a ``(2, 1)``. Il vettore velocità "
"rappresenta la distanza percorsa dall'astronave a ogni passo. Possiamo "
"ricavare la posizione al secondo passo sommando la velocità alla posizione "
"attuale."

msgid ""
"Velocity measures the **change** in position per unit of time. The new "
"position is found by adding the velocity multiplied by the elapsed time "
"(here assumed to be one unit, e.g. 1 s) to the previous position."
msgstr ""
"La velocità misura la **variazione** di posizione per unità di tempo. La "
"nuova posizione è ricavata sommando la velocità moltiplicata per il tempo "
"trascorso (qui si presume un'unità, ad esempio 1 s) alla posizione "
"precedente."

msgid ""
"In a typical 2D game scenario, you would have a velocity in pixels per "
"second, and multiply it by the ``delta`` parameter (time elapsed since the "
"previous frame) from the :ref:`_process() "
"<class_Node_private_method__process>` or :ref:`_physics_process() "
"<class_Node_private_method__physics_process>` callbacks."
msgstr ""
"In un tipico scenario di gioco 2D, dovresti avere una velocità in pixel al "
"secondo e moltiplicarla per il parametro ``delta`` (tempo trascorso dal "
"frame precedente) dai callback :ref:`_process() "
"<class_Node_private_method__process>` o :ref:`_physics_process() "
"<class_Node_private_method__physics_process>`."

msgid "Pointing toward a target"
msgstr "Puntare verso un bersaglio"

msgid ""
"In this scenario, you have a tank that wishes to point its turret at a "
"robot. Subtracting the tank's position from the robot's position gives the "
"vector pointing from the tank to the robot."
msgstr ""
"In questo scenario, abbiamo un carro armato che desidera puntare la sua "
"torretta verso un robot. Sottraendo la posizione del carro armato da quella "
"del robot, si ottiene il vettore che punta dal carro armato al robot."

msgid "To find a vector pointing from ``A`` to ``B``, use ``B - A``."
msgstr "Per ricavare un vettore che punta da ``A`` a ``B``, usa ``B - A``."

msgid "Unit vectors"
msgstr "Vettori unitari"

msgid ""
"A vector with **magnitude** of ``1`` is called a **unit vector**. They are "
"also sometimes referred to as **direction vectors** or **normals**. Unit "
"vectors are helpful when you need to keep track of a direction."
msgstr ""
"Un vettore con **modulo** pari a ``1`` è chiamato **vettore unitario**. A "
"volte sono anche chiamati **vettori di direzione** o **normali**. I vettori "
"unitari sono utili quando si deve tenere traccia di una direzione."

msgid "Normalization"
msgstr "Normalizzazione"

msgid ""
"**Normalizing** a vector means reducing its length to ``1`` while preserving "
"its direction. This is done by dividing each of its components by its "
"magnitude. Because this is such a common operation, Godot provides a "
"dedicated :ref:`normalized() <class_Vector2_method_normalized>` method for "
"this:"
msgstr ""
"**Normalizzare** un vettore significa ridurne la lunghezza a ``1`` "
"preservandone la direzione. Ciò si ottiene dividendo ciascuna delle sue "
"componenti per il suo modulo. Poiché si tratta di un'operazione così comune, "
"Godot fornisce un metodo :ref:`normalized() "
"<class_Vector2_method_normalized>` dedicato per questo:"

msgid ""
"Because normalization involves dividing by the vector's length, you cannot "
"normalize a vector of length ``0``. Attempting to do so would normally "
"result in an error. In GDScript though, trying to call the ``normalized()`` "
"method on a vector of length 0 leaves the value untouched and avoids the "
"error for you."
msgstr ""
"Poiché la normalizzazione richiede la divisione per la lunghezza del "
"vettore, non è possibile normalizzare un vettore di lunghezza ``0``. Tentare "
"di farlo solitamente genera un errore. In GDScript, tuttavia, se si prova a "
"chiamare il metodo ``normalized()`` su un vettore di lunghezza 0, il valore "
"viene lasciato intatto e l'errore viene evitato."

msgid "Reflection"
msgstr "Riflessione"

msgid ""
"A common use of unit vectors is to indicate **normals**. Normal vectors are "
"unit vectors aligned perpendicularly to a surface, defining its direction. "
"They are commonly used for lighting, collisions, and other operations "
"involving surfaces."
msgstr ""
"Un utilizzo comune dei vettori unitari è quello di indicare le **normali**. "
"I vettori normali sono vettori unitari allineati perpendicolarmente a una "
"superficie, che ne definiscono la direzione. Sono comunemente utilizzati per "
"l'illuminazione, le collisioni e altre operazioni che riguardano superfici."

msgid ""
"For example, imagine we have a moving ball that we want to bounce off a wall "
"or other object:"
msgstr ""
"Ad esempio, immaginiamo di avere una palla in movimento che vogliamo far "
"rimbalzare contro un muro o un altro oggetto:"

msgid ""
"The surface normal has a value of ``(0, -1)`` because this is a horizontal "
"surface. When the ball collides, we take its remaining motion (the amount "
"left over when it hits the surface) and reflect it using the normal. In "
"Godot, there is a :ref:`bounce() <class_Vector2_method_bounce>` method to "
"handle this. Here is a code example of the above diagram using "
"a :ref:`CharacterBody2D <class_CharacterBody2D>`:"
msgstr ""
"La normale alla superficie ha un valore di ``(0, -1)`` perché è una "
"superficie orizzontale. Quando la palla si scontra, prendiamo il suo "
"movimento rimanente (la quantità che rimane quando colpisce la superficie) e "
"lo riflettiamo utilizzando la normale. In Godot, esiste il "
"metodo :ref:`bounce() <class_Vector2_method_bounce>` per gestire ciò. Ecco "
"un esempio di codice del diagramma sopra utilizzando "
"un :ref:`CharacterBody2D <class_CharacterBody2D>`:"

msgid "Dot product"
msgstr "Prodotto scalare"

msgid ""
"The **dot product** is one of the most important concepts in vector math, "
"but is often misunderstood. Dot product is an operation on two vectors that "
"returns a **scalar**. Unlike a vector, which contains both magnitude and "
"direction, a scalar value has only magnitude."
msgstr ""
"Il **prodotto scalare** è uno dei concetti più importanti nella matematica "
"vettoriale, ma è spesso incompreso. Il prodotto scalare è un'operazione su "
"due vettori che restituisce uno **scalare**. A differenza di un vettore, che "
"contiene sia modulo sia direzione, un valore scalare ha solo modulo."

msgid "The formula for dot product takes two common forms:"
msgstr "La formula del prodotto scalare assume due forme comuni:"

msgid "and"
msgstr "e"

msgid ""
"The mathematical notation *||A||* represents the magnitude of vector ``A``, "
"and *A*\\ :sub:`x` means the ``x`` component of vector ``A``."
msgstr ""
"La notazione matematica *||A||* rappresenta il modulo del vettore ``A``, e "
"*A*\\ :sub:`x` indica la componente ``x`` del vettore ``A``."

msgid ""
"However, in most cases it is easiest to use the built-in :ref:`dot() "
"<class_Vector2_method_dot>` method. Note that the order of the two vectors "
"does not matter:"
msgstr ""
"Tuttavia, nella maggior parte dei casi è più semplice utilizzare il metodo "
"integrato :ref:`dot() <class_Vector2_method_dot>`. Nota che l'ordine dei due "
"vettori non è importante:"

msgid ""
"The dot product is most useful when used with unit vectors, making the first "
"formula reduce to just ``cos(θ)``. This means we can use the dot product to "
"tell us something about the angle between two vectors:"
msgstr ""
"Il prodotto scalare è particolarmente utile se utilizzato con vettori "
"unitari, riducendo la prima formula soltanto in ``cos(θ)``. Questo significa "
"che possiamo usare il prodotto scalare per ottenere informazioni sull'angolo "
"tra due vettori:"

msgid ""
"When using unit vectors, the result will always be between ``-1`` (180°) and "
"``1`` (0°)."
msgstr ""
"Quando si utilizzano vettori unitari, il risultato sarà sempre compreso tra "
"``-1`` (180°) e ``1`` (0°)."

msgid "Facing"
msgstr "Orientazione"

msgid ""
"We can use this fact to detect whether an object is facing toward another "
"object. In the diagram below, the player ``P`` is trying to avoid the "
"zombies ``A`` and ``B``. Assuming a zombie's field of view is **180°**, can "
"they see the player?"
msgstr ""
"Possiamo usare questo fatto per rilevare se un oggetto è rivolto verso un "
"altro oggetto. Nel diagramma sottostante, il giocatore ``P`` sta cercando di "
"evitare gli zombi ``A`` e ``B``. Supponendo che il campo visivo di uno zombi "
"sia di **180°**, riesce a vedere il giocatore?"

msgid ""
"The green arrows ``fA`` and ``fB`` are **unit vectors** representing the "
"zombie's facing direction and the blue semicircle represents its field of "
"view. For zombie ``A``, we find the direction vector ``AP`` pointing to the "
"player using ``P - A`` and normalize it, however, Godot has a helper method "
"to do this called :ref:`direction_to() <class_Vector2_method_direction_to>`. "
"If the angle between this vector and the facing vector is less than 90°, "
"then the zombie can see the player."
msgstr ""
"Le frecce verdi ``fA`` e ``fB`` sono **vettori unitari** che rappresentano "
"la direzione in cui è rivolto lo zombi e il semicerchio blu rappresenta il "
"suo campo visivo. Per lo zombi ``A``, troviamo il vettore di direzione "
"``AP``, che punta al giocatore, tramite ``P - A`` e lo normalizziamo. "
"Tuttavia, Godot ha un metodo ausiliare per fare ciò "
"chiamato :ref:`direction_to() <class_Vector2_method_direction_to>`. Se "
"l'angolo tra questo vettore e il vettore rivolto è inferiore a 90°, lo zombi "
"può vedere il giocatore."

msgid "In code it would look like this:"
msgstr "Nel codice, apparirebbe così:"

msgid "Cross product"
msgstr "Prodotto vettoriale"

msgid ""
"Like the dot product, the **cross product** is an operation on two vectors. "
"However, the result of the cross product is a vector with a direction that "
"is perpendicular to both. Its magnitude depends on their relative angle. If "
"two vectors are parallel, the result of their cross product will be a null "
"vector."
msgstr ""
"Come il prodotto scalare, il **prodotto vettoriale** è un'operazione su due "
"vettori. Tuttavia, il risultato del prodotto vettoriale è un vettore con una "
"direzione che è perpendicolare a entrambi. Il suo modulo dipende dal loro "
"angolo relativo. Se due vettori sono paralleli, il risultato del loro "
"prodotto vettoriale sarà un vettore nullo."

msgid "The cross product is calculated like this:"
msgstr "Il prodotto vettoriale si calcola così:"

msgid ""
"With Godot, you can use the built-in :ref:`Vector3.cross() "
"<class_Vector3_method_cross>` method:"
msgstr ""
"Con Godot, puoi utilizzare il metodo integrato :ref:`Vector3.cross() "
"<class_Vector3_method_cross>`:"

msgid ""
"The cross product is not mathematically defined in 2D. "
"The :ref:`Vector2.cross() <class_Vector2_method_cross>` method is a commonly "
"used analog of the 3D cross product for 2D vectors."
msgstr ""
"Il prodotto vettoriale non è definito matematicamente in 2D. Il "
"metodo :ref:`Vector2.cross() <class_Vector2_method_cross>` è un equivalente "
"comunemente utilizzato del prodotto vettoriale 3D per i vettori 2D."

msgid ""
"In the cross product, order matters. ``a.cross(b)`` does not give the same "
"result as ``b.cross(a)``. The resulting vectors point in **opposite** "
"directions."
msgstr ""
"Nel prodotto vettoriale, l'ordine è importante. ``a.cross(b)`` non dà lo "
"stesso risultato di ``b.cross(a)``. I vettori risultanti puntano in "
"direzioni **opposte**."

msgid "Calculating normals"
msgstr "Calcolo delle normali"

msgid ""
"One common use of cross products is to find the surface normal of a plane or "
"surface in 3D space. If we have the triangle ``ABC`` we can use vector "
"subtraction to find two edges ``AB`` and ``AC``. Using the cross product, "
"``AB × AC`` produces a vector perpendicular to both: the surface normal."
msgstr ""
"Un utilizzo comune dei prodotti vettoriali è ricavare la normale a una "
"superficie o a un piano nello spazio 3D. Se abbiamo il triangolo ``AB``, "
"possiamo utilizzare la sottrazione vettoriale per trovare due lati ``AB`` e "
"``AC``. Attraverso il prodotto vettoriale ``AB × AC``, si ottiene un vettore "
"perpendicolare a entrambi: la normale alla superficie."

msgid "Here is a function to calculate a triangle's normal:"
msgstr "Ecco una funzione per calcolare la normale di un triangolo:"

msgid "Pointing to a target"
msgstr "Puntare verso un bersaglio"

msgid ""
"In the dot product section above, we saw how it could be used to find the "
"angle between two vectors. However, in 3D, this is not enough information. "
"We also need to know what axis to rotate around. We can find that by "
"calculating the cross product of the current facing direction and the target "
"direction. The resulting perpendicular vector is the axis of rotation."
msgstr ""
"Nella sezione precedente sul prodotto scalare, abbiamo visto come questo si "
"possa utilizzare per calcolare l'angolo tra due vettori. Tuttavia, in 3D, "
"questa informazione non è sufficiente. Dobbiamo anche sapere attorno a quale "
"asse ruotare. Possiamo ricavarlo calcolando il prodotto vettoriale tra la "
"direzione attuale e la direzione del bersaglio. Il vettore perpendicolare "
"risultante è l'asse di rotazione."

msgid "More information"
msgstr "Maggiori informazioni"

msgid ""
"For more information on using vector math in Godot, see the following "
"articles:"
msgstr ""
"Per maggiori informazioni sull'utilizzo della matematica vettoriale in "
"Godot, consulta i seguenti articoli:"

msgid ":ref:`doc_vectors_advanced`"
msgstr ":ref:`doc_vectors_advanced`"

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
