#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Saving games"
msgstr "Salvataggio di giochi"

msgid "Introduction"
msgstr "Introduzione"

msgid ""
"Save games can be complicated. For example, it may be desirable to store "
"information from multiple objects across multiple levels. Advanced save game "
"systems should allow for additional information about an arbitrary number of "
"objects. This will allow the save function to scale as the game grows more "
"complex."
msgstr ""
"Salvare giochi può essere complicato. Ad esempio, potrebbe essere opportuno "
"memorizzare informazioni da più oggetti distribuiti su più livelli. I "
"sistemi avanzati di salvataggio dovrebbero consentire di ottenere "
"informazioni aggiuntive su un numero arbitrario di oggetti. Ciò consentirà "
"alla funzione di salvataggio di adattarsi man mano che il gioco diventa più "
"complesso."

msgid ""
"If you're looking to save user configuration, you can use "
"the :ref:`class_ConfigFile` class for this purpose."
msgstr ""
"Se si sta cercando di salvare la configurazione utente, è possibile "
"utilizzare la classe :ref:`class_ConfigFile` a questo proposito."

msgid ""
"You can see how saving and loading works in action using the `Saving and "
"Loading (Serialization) demo project <https://github.com/godotengine/godot-"
"demo-projects/blob/master/loading/serialization>`__."
msgstr ""
"È possibile osservare come funzionano il salvataggio e il caricamento in "
"azione attraverso il `progetto demo Salvataggio e caricamento "
"(serializzazione) <https://github.com/godotengine/godot-demo-projects/blob/"
"master/loading/serialization>`__."

msgid "Identify persistent objects"
msgstr "Identificare gli oggetti persistenti"

msgid ""
"Firstly, we should identify what objects we want to keep between game "
"sessions and what information we want to keep from those objects. For this "
"tutorial, we will use groups to mark and handle objects to be saved, but "
"other methods are certainly possible."
msgstr ""
"Innanzitutto, dobbiamo identificare quali oggetti vogliamo conservare tra "
"una sessione di gioco e l'altra e quali informazioni vogliamo conservare da "
"quegli oggetti. In questo tutorial, useremo i gruppi per segnare e gestire "
"gli oggetti da salvare, ma sono certamente possibili anche altri metodi."

msgid ""
"We will start by adding objects we wish to save to the \"Persist\" group. We "
"can do this through either the GUI or script. Let's add the relevant nodes "
"using the GUI:"
msgstr ""
"Inizieremo aggiungendo gli oggetti che desideriamo salvare al gruppo "
"\"Persist\". Possiamo farlo tramite l'interfaccia grafica o tramite script. "
"Aggiungiamo i nodi desiderati tramite l'interfaccia grafica:"

msgid ""
"Once this is done, when we need to save the game, we can get all objects to "
"save them and then tell them all to save with this script:"
msgstr ""
"Una volta fatto ciò, quando dovremo salvare il gioco, potremo far sì che "
"tutti gli oggetti li salvino e poi dire a tutti di salvare con questo script:"

msgid "Serializing"
msgstr "Serializzazione"

msgid ""
"The next step is to serialize the data. This makes it much easier to read "
"from and store to disk. In this case, we're assuming each member of group "
"Persist is an instanced node and thus has a path. GDScript has the helper "
"class :ref:`JSON<class_json>` to convert between dictionary and string. Our "
"node needs to contain a save function that returns this data. The save "
"function will look like this:"
msgstr ""
"Il passo successivo è serializzare i dati. Questo semplifica notevolmente la "
"lettura e l'archiviazione su disco. In questo caso, presumiamo che ogni "
"membro del gruppo Persist sia un nodo istanziato e quindi abbia un percorso. "
"GDScript ha la classe ausiliare :ref:`JSON<class_json>` per convertire tra "
"dizionario e stringa. Il nostro nodo deve contenere una funzione di "
"salvataggio che restituisca questi dati. La funzione di salvataggio avrà "
"questo aspetto:"

msgid ""
"This gives us a dictionary with the style "
"``{ \"variable_name\":value_of_variable }``, which will be useful when "
"loading."
msgstr ""
"Questo ci fornisce un dizionario con lo stile "
"``{ \"variable_name\":value_of_variable }``, che sarà utile per il "
"caricamento."

msgid "Saving and reading data"
msgstr "Salvare e leggere i dati"

msgid ""
"As covered in the :ref:`doc_filesystem` tutorial, we'll need to open a file "
"so we can write to it or read from it. Now that we have a way to call our "
"groups and get their relevant data, let's use the "
"class :ref:`JSON<class_json>` to convert it into an easily stored string and "
"store them in a file. Doing it this way ensures that each line is its own "
"object, so we have an easy way to pull the data out of the file as well."
msgstr ""
"Come spiegato nel tutorial :ref:`doc_filesystem`, dovremo aprire un file per "
"poterlo scrivere o leggere. Ora che abbiamo un modo per chiamare i nostri "
"gruppi e ottenere i dati rilevanti, utilizziamo la "
"classe :ref:`JSON<class_json>` per convertirli in una stringa facilmente "
"memorizzabile e salvarli in un file. Facendo così ci assicuriamo che ogni "
"riga sia un oggetto a sé stante, quindi abbiamo anche un modo semplice per "
"estrarre i dati dal file."

msgid ""
"Game saved! Now, to load, we'll read each line. Use "
"the :ref:`parse<class_JSON_method_parse>` method to read the JSON string "
"back to a dictionary, and then iterate over the dict to read our values. But "
"we'll need to first create the object and we can use the filename and parent "
"values to achieve that. Here is our load function:"
msgstr ""
"Partita salvata! Ora, per caricare, leggeremo ogni riga. Utilizziamo il "
"metodo :ref:`parse<class_JSON_method_parse>` per convertire la stringa JSON "
"in un dizionario, quindi iteriamo sul dizionario per leggere i nostri "
"valori. Ma prima dobbiamo creare l'oggetto, e possiamo usare il nome del "
"file e i valori padre per farlo. Ecco la nostra funzione di caricamento:"

msgid ""
"Now we can save and load an arbitrary number of objects laid out almost "
"anywhere across the scene tree! Each object can store different data "
"depending on what it needs to save."
msgstr ""
"Ora possiamo salvare e caricare un numero arbitrario di oggetti disposti "
"praticamente ovunque nell'albero di scene! Ogni oggetto può memorizzare dati "
"diversi a seconda di ciò che necessita di salvare."

msgid "Some notes"
msgstr "Alcune note"

msgid ""
"We have glossed over setting up the game state for loading. It's ultimately "
"up to the project creator where much of this logic goes. This is often "
"complicated and will need to be heavily customized based on the needs of the "
"individual project."
msgstr ""
"Abbiamo sorvolato sulla configurazione dello stato del gioco per il "
"caricamento. Spetta ultimamente al creatore del progetto decidere dove "
"indirizzare gran parte di questa logica. Questa è spesso complicata e dovrà "
"essere ampiamente personalizzata in base alle esigenze del singolo progetto."

msgid ""
"Additionally, our implementation assumes no Persist objects are children of "
"other Persist objects. Otherwise, invalid paths would be created. To "
"accommodate nested Persist objects, consider saving objects in stages. Load "
"parent objects first so they are available for the :ref:`add_child() "
"<class_node_method_add_child>` call when child objects are loaded. You will "
"also need a way to link children to parents as the :ref:`NodePath "
"<class_nodepath>` will likely be invalid."
msgstr ""
"Inoltre, la nostra implementazione presuppone che nessun oggetto Persist sia "
"figlio di altri oggetti Persist. Altrimenti, verrebbero creati percorsi non "
"validi. Per gestire gli oggetti Persist annidati, si consiglia di salvare "
"gli oggetti in più fasi. Caricare prima gli oggetti padre in modo che siano "
"disponibili per la chiamata a :ref:`add_child() "
"<class_node_method_add_child>` quando vengono caricati gli oggetti figlio. "
"Sarà inoltre necessario un modo per collegare i figli ai genitori, poiché "
"il :ref:`NodePath <class_nodepath>` probabilmente non sarà valido."

msgid "JSON vs binary serialization"
msgstr "Serializzazione JSON contro binaria"

msgid ""
"For simple game state, JSON may work and it generates human-readable files "
"that are easy to debug."
msgstr ""
"Per lo stato di un gioco semplice, JSON può funzionare e genera file "
"leggibili in chiaro, facili da sottoporre a debug."

msgid ""
"But JSON has many limitations. If you need to store more complex game state "
"or a lot of it, :ref:`binary serialization<doc_binary_serialization_api>` "
"may be a better approach."
msgstr ""
"Tuttavia, JSON ha numerose limitazioni. Se è necessario memorizzare stati di "
"gioco più complessi o in grandi quantità, la :ref:`serializzazione binaria "
"<doc_binary_serialization_api>` potrebbe essere un approccio migliore."

msgid "JSON limitations"
msgstr "Limitazioni di JSON"

msgid "Here are some important gotchas to know about when using JSON."
msgstr ""
"Ecco alcuni grattacapi importanti da tenere a mente quando si utilizza JSON."

msgid ""
"**Filesize:** JSON stores data in text format, which is much larger than "
"binary formats."
msgstr ""
"**Dimensione di file:** JSON memorizza i dati in formato testuale, che è "
"molto più grande dei formati binari."

msgid ""
"**Data types:** JSON only offers a limited set of data types. If you have "
"data types that JSON doesn't have, you will need to translate your data to "
"and from types that JSON can handle. For example, some important types that "
"JSON can't parse are: ``Vector2``, ``Vector3``, ``Color``, ``Rect2``, and "
"``Quaternion``."
msgstr ""
"**Tipi di dati:** JSON offre solo un insieme limitato di tipi di dati. Se si "
"dispone di tipi di dati non supportati da JSON, sarà necessario tradurre i "
"dati da/a i tipi che JSON può gestire. Ad esempio, alcuni tipi importanti "
"che JSON non può analizzare sono: ``Vector2``, ``Vector3``, ``Color``, "
"``Rect2`` e ``Quaternion``."

msgid ""
"**Custom logic needed for encoding/decoding:** If you have any custom "
"classes that you want to store with JSON, you will need to write your own "
"logic for encoding and decoding those classes."
msgstr ""
"**Logica personalizzata necessaria per la codifica/decodifica:** Se si "
"dispone di classi personalizzate che si desidera memorizzare con JSON, sarà "
"necessario scrivere la propria logica per codificare e decodificare tali "
"classi."

msgid "Binary serialization"
msgstr "Serializzazione binaria"

msgid ""
":ref:`Binary serialization<doc_binary_serialization_api>` is an alternative "
"approach for storing game state, and you can use it with the functions "
"``get_var`` and ``store_var`` of :ref:`class_FileAccess`."
msgstr ""
"La :ref:`serializzazione binaria<doc_binary_serialization_api>` è un "
"approccio alternativo per memorizzare lo stato del gioco e si può utilizzare "
"con le funzioni ``get_var`` e ``store_var`` di :ref:`class_FileAccess`."

msgid "Binary serialization should produce smaller files than JSON."
msgstr "La serializzazione binaria dovrebbe produrre file più piccoli di JSON."

msgid "Binary serialization can handle most common data types."
msgstr ""
"La serializzazione binaria può gestire la maggior parte dei tipi di dati più "
"comuni."

msgid ""
"Binary serialization requires less custom logic for encoding and decoding "
"custom classes."
msgstr ""
"La serializzazione binaria richiede meno logica personalizzata per la "
"codifica e la decodifica delle classi personalizzate."

msgid ""
"Note that not all properties are included. Only properties that are "
"configured with "
"the :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"flag set will be serialized. You can add a new usage flag to a property by "
"overriding "
"the :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"method in your class. You can also check how property usage is configured by "
"calling ``Object._get_property_list``. "
"See :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` for the "
"possible usage flags."
msgstr ""
"Si noti che non tutte le proprietà sono incluse. Saranno serializzate solo "
"le proprietà configurate con il "
"flag :ref:`PROPERTY_USAGE_STORAGE<class_@GlobalScope_constant_PROPERTY_USAGE_STORAGE>` "
"impostato. È possibile aggiungere un nuovo flag di uso a una proprietà "
"sovrascrivendo il "
"metodo :ref:`_get_property_list<class_Object_private_method__get_property_list>` "
"nella classe. È anche possibile verificare come è configurato l'uso della "
"proprietà chiamando ``Object._get_property_list``. "
"Consultare :ref:`PropertyUsageFlags<enum_@GlobalScope_PropertyUsageFlags>` "
"per i possibili flag di uso."
