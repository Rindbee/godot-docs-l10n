#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: it\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "Ottimizzare le prestazioni della navigazione"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr ""
"I problemi comuni relativi alle prestazioni di navigazione si possono "
"categorizzare nei seguenti argomenti:"

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr ""
"Problemi di prestazioni durante l'analisi dei nodi nell'albero di scene per "
"la preparazione delle mesh di navigazione."

msgid "Performance problems with baking the actual navigation mesh."
msgstr ""
"Problemi di prestazioni durante la preparazione delle mesh effettive di "
"navigazione."

msgid "Performance problems with NavigationAgent path queries."
msgstr ""
"Problemi di prestazioni con le ricerche dei percorsi per gli agenti di "
"navigazione."

msgid "Performance problems with the actual path search."
msgstr "Problemi di prestazioni con le ricerche effettive di percorsi."

msgid "Performance problems with synchronizing the navigation map."
msgstr ""
"Problemi di prestazioni con la sincronizzazione della mappa di navigazione."

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"Nelle sezioni seguenti è possibile trovare informazioni su come "
"identificare, correggere, o almeno mitigare il loro impatto sui frame rate."

msgid "Performance problems with parsing scene tree nodes"
msgstr ""
"Problemi di prestazioni durante l'analisi dei nodi nell'albero di scene"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"Preferisci usare forme semplici con il minor numero possibile di spigoli, ad "
"esempio niente di arrotondato come un cerchio, una sfera o un toro."

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"Preferisci usare forme di collisione fisica invece di mesh visive complesse "
"come geometria sorgente, poiché le mesh devono essere copiate dalla GPU e "
"sono solitamente molto più dettagliate del necessario."

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"In generale, evita di utilizzare geometrie molto complesse come geometria "
"sorgente per la preparazione delle mesh di navigazione. Ad esempio, non "
"utilizzare mai una mesh visiva molto dettagliata; analizzare la sua forma in "
"array di dati, e \"voxelizzarla\" per preparare le mesh di navigazione, "
"richiederà molto tempo senza migliorare notevolmente la qualità della mesh "
"di navigazione finale. Utilizza invece una versione molto più semplificata "
"(LOD) di una forma. Ancora meglio, utilizza forme molto primitive come "
"riquadri e rettangoli che coprono solo approssimativamente la stessa "
"geometria ma producono comunque un risultato di preparazione abbastanza "
"buono per il pathfinding."

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"Preferisco utilizzare semplici forme di collisione fisica rispetto alle mesh "
"visive come geometria sorgente per la creazione delle mesh di navigazione. "
"Le forme fisiche sono, di norma, molto limitate e ottimizzate, facili e "
"veloci da analizzare. Una mesh visiva, d'altra parte, può variare da "
"semplice a complessa. Inoltre, per accedere ai dati della mesh visiva, il "
"parser deve richiedere gli array dei dati della mesh al RenderingServer, "
"poiché i dati della mesh visiva sono memorizzati direttamente sulla GPU e "
"non nella cache della CPU. Ciò richiede il blocco del thread del "
"RenderingServer e può influire gravemente sul frame rate durante "
"l'esecuzione, mentre il rendering è eseguito in più thread. Se il rendering "
"è eseguito in un singolo thread, l'impatto sul frame rate potrebbe essere "
"ancora peggiore e l'analisi della mesh potrebbe bloccare l'intero gioco per "
"alcuni secondi su mesh complesse."

msgid "Performance problems with navigation mesh baking"
msgstr "Problemi di prestazioni con la preparazione delle mesh di navigazione"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr ""
"In fase di esecuzione, è sempre preferibile utilizzare un thread in "
"background per la preparazione delle mesh di navigazione."

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"Aumenta ``cell_size`` e ``cell_height`` di NavigationMesh per creare meno "
"voxel."

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr ""
"Cambia ``SamplePartitionType`` da watershed a monotone o layers per "
"migliorare le prestazioni di preparazione."

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"NON cambiare MAI la scala della geometria sorgente con i nodi per evitare "
"errori di precisione. La maggiorità delle scale si applica solo visivamente "
"e le forme molto grandi alla loro scala base richiedono comunque molta "
"elaborazione in più, anche se rimpicciolite."

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"Se possibile, la preparazione delle mesh di navigazione in fase di "
"esecuzione si dovrebbe sempre eseguire in un thread in background. Anche le "
"mesh di navigazione di piccole dimensioni possono richiedere molto più tempo "
"di quanto sia possibile stringere in un singolo frame, assumendo che il "
"frame rate debba rimanere a un livello tollerabile."

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out of memory in the middle "
"and crashes the game. The partition type can also be lowered depending on "
"how complex the games source geometry is to gain some performance. E.g. "
"games with mostly flat surfaces with blocky geometry can get away with the "
"monotone or layers mode that are a lot faster to bake (e.g. because they "
"require no distance field pass)."
msgstr ""
"La complessità dei dati della geometria sorgente analizzati dai nodi "
"dell'albero di scene ha un impatto significativo sulle prestazioni di "
"preparazione, poiché tutto deve essere mappato su una griglia/voxel. Per le "
"prestazioni di preparazione in fase di esecuzione, la dimensione e l'altezza "
"delle celle di un NavigationMesh si devono impostare il più alte possibile, "
"senza causare problemi di qualità della mesh per un gioco. Se la dimensione "
"o l'altezza delle celle sono impostate troppo basse, la preparazione è "
"costretta a creare una quantità eccessiva di voxel per elaborare la "
"geometria sorgente. Se la geometria sorgente si estende su un mondo molto "
"ampio di gioco, è persino possibile che il processo di preparazione "
"esaurisca la memoria nel mezzo e provochi un arresto anomalo. Anche il tipo "
"di partizione si può ridurre a seconda della complessità della geometria "
"sorgente per ottenere prestazioni migliori. Ad esempio, i giochi con "
"superfici prevalentemente piatte e geometria a blocchi possono utilizzare la "
"modalità monotona o a strati, che sono molto più veloci da preparare (ad "
"esempio perché non richiedono passaggi di campo a distanza)."

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"Non cambiare mai la scala della geometria sorgente con i nodi. Non solo può "
"causare molti errori di precisione con vertici e spigoli non corrispondenti "
"correttamente, ma alcuni cambiamenti sono presenti solo come elementi visivi "
"e non nei dati effettivamente analizzati. Ad esempio, se una mesh viene "
"rimpicciolita visivamente nell'Editor, ad esempio impostando la scala a "
"0,001 su una MeshInstance, per la preparazione la mesh richiede comunque di "
"elaborare una griglia voxel gigantesca e molto complessa."

msgid "Performance problems with NavigationAgent path queries"
msgstr ""
"Problemi di prestazioni con le ricerche di percorsi degli agenti di "
"navigazione"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr ""
"Evita inutili ripristini del percorso e richieste a ogni frame negli script "
"degli agenti di navigazione."

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr ""
"Evitare di aggiornare tutti i percorsi degli agenti di navigazione nello "
"stesso frame."

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"Errori logici e operazioni inutili negli script personalizzati degli agenti "
"sono cause molto comuni di problemi di prestazioni, ad esempio presta "
"attenzione se il percorso è ripristinato a ogni singolo frame. Normalmente, "
"gli agenti di navigazione sono ottimizzati per richiedere nuovi percorsi "
"solo quando la posizione di destinazione cambia, la mappa di navigazione "
"cambia o vengono forzati a una distanza troppo lontana dal percorso "
"desiderato."

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"Ad esempio, quando l'IA deve spostarsi verso il giocatore, la posizione di "
"destinazione non si dovrebbe impostare sulla posizione del giocatore a ogni "
"singolo frame, poiché ciò richiede un nuovo percorso a ogni frame. Invece, "
"la distanza tra la posizione di destinazione attuale e la posizione del "
"giocatore si dovrebbe confrontare, e solo quando il giocatore si è spostato "
"troppo lontano si dovrebbe impostare una nuova posizione di destinazione."

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"Non verificare in anticipo se una posizione di destinazione è raggiungibile "
"a ogni frame. Ciò che sembra una verifica innocua è equivalente a una "
"costosa ricerca di percorso dietro le quinte. Se si prevede di richiedere "
"comunque un nuovo percorso nel caso in cui la posizione sia raggiungibile, "
"si dovrebbe richiedere direttamente un percorso. Esaminando l'ultima "
"posizione del percorso restituito e se tale posizione si trova a una "
"distanza \"raggiungibile\" dalla posizione verificata, si risponde alla "
"domanda \"questa posizione è raggiungibile?\". Ciò evita di eseguire "
"l'equivalente di due ricerche di percorso complete a ogni frame per lo "
"stesso agente."

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"Dividi il numero totale di agenti di navigazione in gruppi di aggiornamento "
"oppure utilizza timer casuali, in modo che non richiedano tutti nuovi "
"percorsi nello stesso frame."

msgid "Performance problems with the actual path search"
msgstr "Problemi di prestazioni con le ricerca effettive di percorsi"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr ""
"Ottimizza le mesh di navigazione eccessivamente dettagliate, riducendo la "
"quantità di poligoni e bordi."

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"Il costo della ricerca effettiva del percorso è direttamente correlato alla "
"quantità di poligoni e bordi della mesh di navigazione, e non alle "
"dimensioni reali del mondo di gioco. Se un mondo gigante di gioco utilizza "
"mesh di navigazione altamente ottimizzate, con solo pochi poligoni che "
"coprono ampie aree, le prestazioni dovrebbero essere accettabili. Se il "
"mondo di gioco è suddiviso in mesh di navigazione molto piccole, ciascuna "
"composta da poligoni minuscoli (come nel caso delle TileMap), le prestazioni "
"di pathfinding saranno ridotte."

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"Un problema comune è un improvviso calo delle prestazioni quando una "
"posizione di destinazione non è raggiungibile in una ricerca di percorso. "
"Questo calo delle prestazioni è \"normale\" ed è il risultato di una mesh di "
"navigazione troppo grande e non ottimizzata, con troppi poligoni e bordi da "
"esplorare. Nelle normali ricerche di percorso, in cui la posizione di "
"destinazione può essere raggiunta rapidamente, il pathfinding terminerà "
"anticipatamente non appena la posizione viene raggiunta, il che può "
"nascondere la mancanza di questa ottimizzazione per un po'. Se non è "
"possibile raggiungere la posizione di destinazione, il pathfinding deve "
"effettuare una ricerca molto più lunga tra i poligoni disponibili per "
"confermare che la posizione non è assolutamente raggiungibile."

msgid "Performance problems with navigation map synchronization"
msgstr ""
"Problemi di prestazioni con la sincronizzazione della mappa di navigazione"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr ""
"Unisci i poligoni delle mesh di navigazione per vertice anziché per "
"connessioni tra bordi, ove possibile."

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"Quando vengono apportate modifiche, ad esempio, alle mesh di navigazione o "
"alle regioni di navigazione, il NavigationServer deve sincronizzare la mappa "
"di navigazione. A seconda della complessità delle mesh di navigazione, ciò "
"può richiedere molto tempo, il che potrebbe avere un impatto sul frame rate."

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"Il NavigationServer unisce le mesh di navigazione per vertice o per "
"connessione di spigolo. L'unione per vertice avviene quando i due vertici di "
"due spigoli diversi si trovano nelle stesse celle della griglia della mappa. "
"È un'operazione piuttosto rapida e a basso costo. L'unione per connessione "
"di spigolo avviene in un secondo passaggio per tutti gli spigoli non ancora "
"uniti. Tutti gli spigoli liberi sono verificati per possibili connessioni di "
"spigolo in base sia alla distanza sia all'angolo, il che è piuttosto costoso."

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"Quindi, oltre alla regola generale di avere il minor numero possibile di "
"spigoli poligonali, il maggior numero possibile di spigoli dovrebbe essere "
"unito per vertice in anticipo, in modo che solo pochi spigoli siano lasciati "
"per il calcolo più costoso della connessione degli spigoli. Il "
"PerformanceMonitor di debug per la navigazione si può utilizzare per "
"ottenere statistiche su quanti poligoni e spigoli sono disponibili e quanti "
"di essi non sono uniti o non uniti per vertice. Se il rapporto tra vertici "
"uniti e connessioni degli spigoli è molto diverso (per i vertici dovrebbe "
"essere notevolmente più alto), le mesh di navigazione vengono create "
"correttamente o posizionate molto inefficientemente."
