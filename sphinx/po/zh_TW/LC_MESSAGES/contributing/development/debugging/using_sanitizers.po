#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using sanitizers"
msgstr "使用 Sanitizer"

msgid "What are sanitizers?"
msgstr "什麼是 Sanitizer？"

msgid ""
"Sanitizers are static instrumentation tools that help find bugs that "
"traditional debuggers usually cannot catch. This is particularly useful when "
"combined with :ref:`doc_unit_testing` in continuous integration."
msgstr ""
"Sanitizer 是一種靜態檢測工具，能夠協助找出傳統除錯器通常無法發現的錯誤。這在"
"持續整合流程中，與 :ref:`doc_unit_testing` 結合時特別有用。"

msgid ""
"Sanitizers can be used on Windows, macOS and Linux by using the Clang "
"(LLVM), GCC or Visual Studio compilers. :ref:`Certain platforms "
"<doc_using_sanitizers_platform_specific_sanitizers>` may also have their own "
"sanitizers available. In situations where a single sanitizer is provided by "
"several different compilers, remember that their output and behavior will "
"differ slightly."
msgstr ""
"可於 Windows、macOS 與 Linux 上，透過 Clang（LLVM）、GCC 或 Visual Studio 編"
"譯器使用 Sanitizer。:ref:`部分平台 "
"<doc_using_sanitizers_platform_specific_sanitizers>` 也可能提供其專屬的 "
"Sanitizer。同一種 Sanitizer 若由不同編譯器提供，其輸出結果與行為可能會略有差"
"異。"

msgid "Using sanitizers on Godot"
msgstr "在 Godot 中使用 Sanitizer"

msgid ""
"Sanitizers **require** recompiling the binary. This means you cannot use "
"official Godot binaries to run sanitizers."
msgstr ""
"Sanitizer **必須** 重新編譯執行檔，這表示無法直接用官方 Godot 執行檔來運作 "
"Sanitizer。"

msgid ""
"When :ref:`compiling <toc-devel-compiling>` with any of the sanitizers "
"enabled, the resulting binary will have the ``.san`` suffix added to its "
"name to distinguish it from a binary without sanitizers."
msgstr ""
"啟用任一種 Sanitizer 進行 :ref:`編譯 <toc-devel-compiling>` 時，產生的執行檔"
"名稱會加上 ``.san`` 後綴，以和未啟用 Sanitizer 的版本做區分。"

msgid ""
"There is a performance impact as many additional runtime checks need to be "
"performed. Memory utilization will also increase. It is possible to enable "
"certain combinations of multiple sanitizers in a single build. Beware of the "
"performance impact when using multiple sanitizers at once though, as the "
"resulting binary may be excessively slow."
msgstr ""
"由於需要進行許多額外的執行時檢查，因此會影響效能，記憶體用量也會增加。部分 "
"Sanitizer 可以於單一建置中同時啟用多種組合，但需注意同時啟用多個 Sanitizer 會"
"大幅降低效能，導致產生的執行檔運作極慢。"

msgid ""
"Certain options can be passed to sanitizers without having to recompile the "
"binary using environment variables."
msgstr "某些選項可以透過環境變數傳遞給 Sanitizer，無需重新編譯執行檔。"

msgid "Address sanitizer (ASAN)"
msgstr "位址 Sanitizer（ASAN）"

msgid "Available in Clang and GCC."
msgstr "適用於 Clang 與 GCC。"

msgid "**Supported platforms:** Linux, macOS, Windows (Visual Studio), Web"
msgstr "**支援平台：** Linux、macOS、Windows（Visual Studio）、Web"

msgid ""
"`Clang ASAN documentation <https://clang.llvm.org/docs/"
"AddressSanitizer.html>`__"
msgstr ""
"`Clang ASAN 文件 <https://clang.llvm.org/docs/AddressSanitizer.html>`__"

msgid ""
"The address sanitizer is generally the most frequently used sanitizer. It "
"can diagnose issues such as buffer overruns and out-of-bounds access. If the "
"engine crashes with a message such as ``free(): invalid pointer``, this is "
"typically the result of a buffer overrun. (This message is printed by the C "
"runtime, not Godot.)"
msgstr ""
"Address Sanitizer 通常是最常用的工具。它可以偵測像是緩衝區溢位或越界存取等問"
"題。如果引擎當機並顯示像是 ``free(): invalid pointer`` 的訊息，通常就是緩衝區"
"溢位所導致的。（這個訊息是由 C 執行時環境印出的，不是 Godot 印出的。）"

msgid ""
"In certain situations (such as detecting uninitialized memory reads), the "
"address sanitizer doesn't suffice. "
"The :ref:`doc_using_sanitizers_memory_sanitizer` should be used instead."
msgstr ""
"在某些情況下（如偵測未初始化的記憶體讀取），位址 Sanitizer 並不適用，請改"
"用 :ref:`doc_using_sanitizers_memory_sanitizer`。"

msgid ""
"It is also possible to detect use-after-return situations by specifying the "
"``ASAN_OPTIONS=detect_stack_use_after_return=1`` environment variable before "
"*running* Godot (not when compiling it). This increases the address "
"sanitizer's runtime overhead, so only enable this feature when you actually "
"need it."
msgstr ""
"你也可以在*執行* Godot 前（非編譯時）設定 "
"``ASAN_OPTIONS=detect_stack_use_after_return=1`` 環境變數，來偵測函式返回後的"
"存取行為。此功能會增加位址 Sanitizer 的執行時負擔，建議僅在必要時啟用。"

msgid ""
"To enable the address sanitizer in a Godot build, pass the ``use_asan=yes`` "
"SCons option when compiling. Enabling ASAN generally makes the resulting "
"binary about 2× slower."
msgstr ""
"如需在 Godot 編譯時啟用位址 Sanitizer，請於編譯指令加入 ``use_asan=yes`` "
"SCons 參數。啟用 ASAN 通常會讓產生的執行檔效能降低約兩倍。"

msgid ""
"Due to a `design decision <https://stackoverflow.com/questions/36971902/why-"
"cant-clang-enable-all-sanitizers/>`__, the address, memory and thread "
"sanitizers are mutually exclusive. This means you can only use one of those "
"sanitizers in a given binary."
msgstr ""
"由於 `設計決策 <https://stackoverflow.com/questions/36971902/why-cant-clang-"
"enable-all-sanitizers/>`__，位址、記憶體及執行緒 Sanitizer 彼此互斥，單一執行"
"檔僅能啟用其中之一。"

msgid "Leak sanitizer (LSAN)"
msgstr "洩漏 Sanitizer（LSAN）"

msgid "**Supported platforms:** Linux, Web"
msgstr "**支援平台：** Linux、Web"

msgid ""
"`Clang LSAN documentation <https://clang.llvm.org/docs/LeakSanitizer.html>`__"
msgstr "`Clang LSAN 文件 <https://clang.llvm.org/docs/LeakSanitizer.html>`__"

msgid ""
"The leak sanitizer can detect memory leaks, which are situations where "
"memory that is no longer in use is never freed by the running program. This "
"can potentially lead to out-of-memory situations if the program runs for "
"long enough. Since Godot may run on :ref:`dedicated servers "
"<doc_exporting_for_dedicated_servers>` for months or even years without a "
"restart, it's important to fix memory leaks when they occur."
msgstr ""
"洩漏 Sanitizer 能偵測記憶體洩漏，也就是程式已經不再使用、但未釋放的記憶體。如"
"果程式長時間執行，最終可能造成記憶體耗盡。由於 Godot 可能會運作於 :ref:`專用"
"伺服器 <doc_exporting_for_dedicated_servers>` 上數月甚至數年不重啟，因此發現"
"洩漏時務必修正。"

msgid ""
"To enable the leak sanitizer in a Godot build, pass the ``use_lsan=yes`` "
"SCons option when compiling. Enabling LSAN only has a small performance "
"overhead, but the program will be much slower to exit as leak detection "
"occurs when the program exits."
msgstr ""
"如需於 Godot 建置啟用洩漏 Sanitizer，請於編譯指令加入 ``use_lsan=yes`` SCons "
"參數。啟用 LSAN 對效能影響很小，但程式結束時因進行洩漏檢查，結束速度會明顯變"
"慢。"

msgid "Memory sanitizer (MSAN)"
msgstr "記憶體 Sanitizer（MSAN）"

msgid "Available in Clang only, not GCC."
msgstr "僅支援 Clang，不支援 GCC。"

msgid "**Supported platforms:** Linux"
msgstr "**支援平台：** Linux"

msgid ""
"`Clang MSAN documentation <https://clang.llvm.org/docs/"
"MemorySanitizer.html>`__"
msgstr "`Clang MSAN 文件 <https://clang.llvm.org/docs/MemorySanitizer.html>`__"

msgid ""
"The memory sanitizer complements "
"the :ref:`doc_using_sanitizers_address_sanitizer`. Unlike the address "
"sanitizer, the memory sanitizer can detect uninitialized memory reads."
msgstr ""
"記憶體 Sanitizer 補足了 :ref:`doc_using_sanitizers_address_sanitizer` 的不"
"足。與位址 Sanitizer 不同，MSAN 能偵測未初始化記憶體的讀取行為。"

msgid ""
"To enable the memory sanitizer in a Godot build, pass the ``use_msan=yes`` "
"SCons option when compiling. Enabling MSAN generally makes the resulting "
"binary about 3× slower."
msgstr ""
"如需在 Godot 建置時啟用記憶體 Sanitizer，請在編譯時加入 ``use_msan=yes`` "
"SCons 參數。啟用 MSAN 通常會讓產生的執行檔效能降低約三倍。"

msgid "Thread sanitizer (TSAN)"
msgstr "執行緒 Sanitizer（TSAN）"

msgid "**Supported platforms:** Linux, macOS"
msgstr "**支援平台：** Linux、macOS"

msgid ""
"`Clang TSAN documentation <https://clang.llvm.org/docs/"
"ThreadSanitizer.html>`__"
msgstr "`Clang TSAN 文件 <https://clang.llvm.org/docs/ThreadSanitizer.html>`__"

msgid ""
"The thread sanitizer is used to track down race conditions related to "
"multithreading. A race condition is when multiple threads try to modify the "
"same data at the same time. Since thread scheduling can be ordered in any "
"fashion by the operating system, this leads to incorrect behavior that only "
"occurs occasionally (and can be difficult to track as a result). To prevent "
"a race condition, you need to add a lock to ensure only one thread can "
"access the shared data at a given time."
msgstr ""
"執行緒 Sanitizer 用於追蹤多執行緒運作時的競爭條件。競爭條件是指多個執行緒同時"
"嘗試修改同一份資料。作業系統排程執行緒的順序是不可預測的，這會導致僅偶發的不"
"正確行為，因此也很難追蹤。為避免競爭條件，需加上鎖定，確保同一時間僅有一個執"
"行緒能存取共享資料。"

msgid ""
"To enable the thread sanitizer in a Godot build, pass the ``use_tsan=yes`` "
"SCons option when compiling. Enabling TSAN generally makes the resulting "
"binary 10× slower, while also multiplying memory usage by an approximately "
"8× factor."
msgstr ""
"如需於 Godot 建置啟用執行緒 Sanitizer，請於編譯時加入 ``use_tsan=yes`` SCons "
"參數。啟用 TSAN 通常會讓執行檔效能降低約 10 倍，且記憶體使用量大幅增加（約 8 "
"倍）。"

msgid "On Linux, if you stumble upon the following error:"
msgstr "在 Linux 上，如果你遇到以下錯誤："

msgid "``FATAL: ThreadSanitizer: unexpected memory mapping``"
msgstr "``FATAL: ThreadSanitizer: unexpected memory mapping``"

msgid ""
"You may need to temporarily lower the Address Space Layout Randomization "
"(ASLR) entropy in your system with:"
msgstr ""
"你可能需要暫時降低系統中的位址空間配置隨機化（ASLR）熵值，可以執行以下指令："

msgid "Or preferably disable it entirely with:"
msgstr "或者建議直接完全停用 ASLR，可以執行："

msgid ""
"And as soon as you are done with the thread sanitizer, increase the ASLR "
"entropy with:"
msgstr "等你完成 ThreadSanitizer 的使用後，請用下列指令提高 ASLR 熵值："

msgid "Or re-enable ASLR with:"
msgstr "或用下列指令重新啟用 ASLR："

msgid ""
"Rebooting your machine will also revert the ASLR state to its default values."
msgstr "重新啟動你的電腦也會將 ASLR 狀態恢復為預設值。"

msgid ""
"It's important to revert the changes as soon as possible because lowering "
"the ASLR entropy or disabling ASLR entirely can be a security risk."
msgstr "請儘快還原這些設定，因為降低 ASLR 熵值或完全停用 ASLR 會帶來安全風險。"

msgid "Undefined behavior sanitizer (UBSAN)"
msgstr "未定義行為 Sanitizer（UBSAN）"

msgid "**Supported platforms:** Linux, macOS, Web"
msgstr "**支援平台：** Linux、macOS、Web"

msgid ""
"`Clang UBSAN documentation <https://clang.llvm.org/docs/"
"UndefinedBehaviorSanitizer.html>`__"
msgstr ""
"`Clang UBSAN 文件 <https://clang.llvm.org/docs/"
"UndefinedBehaviorSanitizer.html>`__"

msgid ""
"The undefined behavior sanitizer is used to track down situations where the "
"program exhibits random and unpredictable behavior. This is due to C/C++ "
"code that is accepted by the compiler, but is not *correct*. Compiling with "
"a different set of optimizations can also change the observed results of "
"undefined behavior."
msgstr ""
"未定義行為 Sanitizer 用於追蹤程式出現隨機或不可預期行為的情境。這通常源於被編"
"譯器接受、但並不*正確*的 C/C++ 程式碼。使用不同最佳化選項編譯，同樣的未定義行"
"為也可能導致不同執行結果。"

msgid ""
"To enable the undefined behavior sanitizer in a Godot build, pass the "
"``use_ubsan=yes`` SCons option when compiling. Enabling UBSAN only has a "
"small performance overhead."
msgstr ""
"如需於 Godot 建置啟用未定義行為 Sanitizer，請於編譯時加入 ``use_ubsan=yes`` "
"SCons 參數。啟用 UBSAN 對效能影響極小。"

msgid "Platform-specific sanitizers"
msgstr "特定平台 Sanitizer"

msgid "Web"
msgstr "Web"

msgid ""
"When :ref:`compiling for the Web <doc_compiling_for_web>`, there are 2 "
"additional sanitizer SCons options available:"
msgstr ""
"當你 :ref:`為 Web 編譯 <doc_compiling_for_web>` 時，還有另外兩個可用的 "
"Sanitizer SCons 選項："

msgid ""
"``use_assertions=yes`` enables runtime Emscripten assertions, which can "
"catch various issues."
msgstr ""
"``use_assertions=yes`` 會啟用 Emscripten 執行時斷言，可用於偵測各類錯誤。"

msgid ""
"``use_safe_heap=yes`` enables `Emscripten's SAFE_HEAP sanitizer <https://"
"emscripten.org/docs/debugging/Sanitizers.html>`__. It provides similar "
"functionality to ASAN, but it focuses on issues that are specific to "
"WebAssembly. ``SAFE_HEAP`` is not guaranteed to be compatible with ASAN and "
"UBSAN in the same binary, so you may have to build it separately."
msgstr ""
"``use_safe_heap=yes`` 會啟用 `Emscripten 的 SAFE_HEAP Sanitizer <https://"
"emscripten.org/docs/debugging/Sanitizers.html>`__。其功能類似於 ASAN，但專注"
"於 WebAssembly 特有的問題。``SAFE_HEAP`` 無法保證和同一執行檔內的 ASAN 與 "
"UBSAN 相容，因此可能需分開建置。"
