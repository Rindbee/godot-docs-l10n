#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Core types"
msgstr "核心型別"

msgid ""
"Godot has a rich set of classes and templates that compose its core, and "
"everything is built upon them."
msgstr "Godot 具有一套豐富的類別與範本，構成其核心，所有功能皆建立於此之上。"

msgid ""
"This reference will try to list them in order for their better understanding."
msgstr "本參考資料將依序列出這些型別，幫助使用者更好地理解。"

msgid "Definitions"
msgstr "定義"

msgid ""
"Godot uses the standard C99 datatypes, such as ``uint8_t``, ``uint32_t``, "
"``int64_t``, etc. which are nowadays supported by every compiler. "
"Reinventing the wheel for those is not fun, as it makes code more difficult "
"to read."
msgstr ""
"Godot 採用標準的 C99 資料型別，例如 ``uint8_t``、``uint32_t``、``int64_t`` "
"等，現今幾乎所有編譯器皆支援。這些型別若自行重複實作，會降低程式碼的可讀性，"
"因此沒有必要。"

msgid ""
"For Unicode characters, CharType instead of wchar_t is used, because many "
"architectures have 4 bytes long wchar_t, where 2 bytes might be desired. "
"However, by default, this has not been forced and CharType maps directly to "
"wchar_t."
msgstr ""
"處理 Unicode 字元時，會使用 CharType 而非 wchar_t，因為許多架構上的 wchar_t "
"長度為 4 位元組，但有時只需 2 位元組。不過預設情況下，CharType 會直接對應到 "
"wchar_t。"

msgid ""
"`core/typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"
msgstr ""
"`core/typedefs.h <https://github.com/godotengine/godot/blob/master/core/"
"typedefs.h>`__"

msgid "Memory model"
msgstr "記憶體模型"

msgid ""
"PC is a wonderful architecture. Computers often have gigabytes of RAM, "
"terabytes of storage and gigahertz of CPU, and when an application needs "
"more resources the OS will swap out the inactive ones. Other architectures "
"(like mobile or consoles) are in general more limited."
msgstr ""
"PC 是很棒的架構。電腦通常有數 GB 記憶體、數 TB 儲存空間與 GHz 級 CPU，當應用"
"需要更多資源時，作業系統會自動切換未使用的資源。其他架構（如行動裝置或遊戲主"
"機）一般限制較多。"

msgid ""
"The most common memory model is the heap, where an application will request "
"a region of memory, and the underlying OS will try to fit it somewhere and "
"return it. This often works best and is flexible, but over time and with "
"abuse, this can lead to segmentation."
msgstr ""
"最常見的記憶體模型為堆積（heap），應用程式請求一段記憶體區域後，由底層作業系"
"統配置並回傳。這種方式彈性高且效果良好，但長時間或不當使用可能產生記憶體分段"
"（segmentation）問題。"

msgid ""
"Segmentation slowly creates holes that are too small for most common "
"allocations, so that memory is wasted. There is a lot of literature about "
"heap and segmentation, so this topic will not be developed further here. "
"Modern operating systems use paged memory, which helps mitigate the problem "
"of segmentation but doesn't solve it."
msgstr ""
"分段會漸漸產生許多過於細小、不適合一般分配的空洞，進而導致記憶體浪費。已有大"
"量相關文獻，因此本處不再詳述。現代作業系統採用分頁式記憶體，有助於減緩分段問"
"題，但無法徹底解決。"

msgid ""
"However, in many studies and tests, it is shown that given enough memory, if "
"the maximum allocation size is below a given threshold in proportion to the "
"maximum heap size and proportion of memory intended to be unused, "
"segmentation will not be a problem over time as it will remain constant. In "
"other words, leave 10-20% of your memory free and perform all small "
"allocations and you are fine."
msgstr ""
"不過，多項研究與測試發現，只要記憶體充足，且最大分配單位低於堆積總容量和預留"
"未使用記憶體的一定比例，分段問題將會維持在穩定狀態。換句話說，如果保留 10–"
"20% 記憶體未使用，就算進行多次小型分配也不會有太大問題。"

msgid "Allocating memory"
msgstr "記憶體分配"

msgid ""
"Godot has many tools for tracking memory usage in a game, especially during "
"debug. Because of this, the regular C and C++ library calls should not be "
"used. Instead, a few other ones are provided."
msgstr ""
"Godot 提供多種工具以追蹤遊戲記憶體使用狀況，特別是在偵錯時。因此不建議直接使"
"用標準的 C 或 C++ 函式庫分配函式，而應使用 Godot 提供的替代方案。"

msgid "For C-style allocation, Godot provides a few macros:"
msgstr "對於 C 風格分配，Godot 提供了一些巨集："

msgid "For C++-style allocation, special macros are provided:"
msgstr "C++ 風格則提供了特殊巨集："

msgid ""
"memnew/memdelete also use a little C++ magic and notify Objects right after "
"they are created, and right before they are deleted."
msgstr ""
"memnew/memdelete 也利用一些 C++ 技巧，會在物件剛建立或即將刪除時通知對應的 "
"Object。"

msgid ""
"For dynamic memory, use one of Godot's sequence types such as ``Vector<>`` "
"or ``LocalVector<>``. ``Vector<>`` behaves much like an STL "
"``std::vector<>``, but is simpler and uses Copy-On-Write (CoW) semantics. "
"CoW copies of ``Vector<>`` can safely access the same data from different "
"threads, but several threads cannot access the same ``Vector<>`` instance "
"safely. It can be safely passed via public API if it has a ``Packed`` alias."
msgstr ""
"動態記憶體分配建議使用 Godot 的序列型別，例如 ``Vector<>`` 或 "
"``LocalVector<>``。``Vector<>`` 類似 STL 的 ``std::vector<>``，但更簡單並採用"
"寫入時複製（Copy-On-Write, CoW）語意。CoW 複製的 ``Vector<>`` 可在多執行緒下"
"安全存取相同資料，但多條執行緒不可同時存取同一個 ``Vector<>`` 實例。若有 "
"``Packed`` 別名時，可安心經由公開 API 傳遞。"

msgid ""
"The ``Packed*Array`` :ref:`types <doc_gdscript_packed_arrays>` are aliases "
"for specific ``Vector<*>`` types (e.g., ``PackedByteArray``, "
"``PackedInt32Array``) that are accessible via GDScript. Outside of core, "
"prefer using the ``Packed*Array`` aliases for functions exposed to scripts, "
"and ``Vector<>`` for other occasions."
msgstr ""
"``Packed*Array`` :ref:`型別 <doc_gdscript_packed_arrays>` 是特定 "
"``Vector<*>`` 型別的別名（如 ``PackedByteArray``、``PackedInt32Array``），可"
"於 GDScript 存取。核心之外，對外公開給腳本的函式建議使用 ``Packed*Array``，其"
"他場合則用 ``Vector<>``。"

msgid ""
"``LocalVector<>`` is much more like ``std::vector`` than ``Vector<>``. It is "
"non-CoW, with less overhead. It is intended for internal use where the "
"benefits of CoW are not needed. Note that neither ``LocalVector<>`` nor "
"``Vector<>`` are drop-in replacements for each other. They are two unrelated "
"types with similar interfaces, both using a buffer as their storage strategy."
msgstr ""
"``LocalVector<>`` 更接近 ``std::vector``，不採用 CoW，開銷更小。主要用於內部"
"用途，不需 CoW 好處時適用。請注意，``LocalVector<>`` 與 ``Vector<>`` 不能直接"
"互換，這兩者僅介面類似，本質是不同型別，皆以緩衝區作為儲存策略。"

msgid ""
"``List<>`` is another Godot sequence type, using a doubly-linked list as its "
"storage strategy. Prefer ``Vector<>`` (or ``LocalVector<>``) over ``List<>`` "
"unless you're sure you need it, as cache locality and memory fragmentation "
"tend to be more important with small collections."
msgstr ""
"``List<>`` 是另一種 Godot 序列型別，採用雙向鏈結串列作為儲存策略。除非確定需"
"要，否則建議以 ``Vector<>`` 或 ``LocalVector<>`` 取代 ``List<>``，因為對於小"
"型集合而言，快取區域性與記憶體碎片化更為重要。"

msgid ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"
msgstr ""
"`core/os/memory.h <https://github.com/godotengine/godot/blob/master/core/os/"
"memory.h>`__"

msgid "Containers"
msgstr "容器"

msgid "Comment"
msgstr "註解"

msgid "|vector|"
msgstr "|vector|"

msgid "Math types"
msgstr "數學型別"

msgid ""
"`core/math <https://github.com/godotengine/godot/tree/master/core/math>`__"
msgstr ""
"`core/math <https://github.com/godotengine/godot/tree/master/core/math>`__"

msgid "NodePath"
msgstr "NodePath"

msgid ""
"`core/string/node_path.h <https://github.com/godotengine/godot/blob/master/"
"core/string/node_path.h>`__"
msgstr ""
"`core/string/node_path.h <https://github.com/godotengine/godot/blob/master/"
"core/string/node_path.h>`__"

msgid "RID"
msgstr "RID"

msgid ""
"`core/templates/rid.h <https://github.com/godotengine/godot/blob/master/core/"
"templates/rid.h>`__"
msgstr ""
"`core/templates/rid.h <https://github.com/godotengine/godot/blob/master/core/"
"templates/rid.h>`__"
