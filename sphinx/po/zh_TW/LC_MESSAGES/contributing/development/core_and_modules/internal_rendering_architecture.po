#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Internal rendering architecture"
msgstr "對其他架構重複相同的過程。"

msgid ""
"This page is a high-level overview of Godot 4's internal renderer design. It "
"does not apply to previous Godot versions."
msgstr ""
"這個頁面是對 Godot 4 內部算繪器設計的高階概述。不適用於舊版本的 Godot。"

msgid ""
"The goal of this page is to document design decisions taken to best suit :"
"ref:`Godot's design philosophy "
"<doc_best_practices_for_engine_contributors>`, while providing a starting "
"point for new rendering contributors."
msgstr ""
"這個頁面的目標是記述最符合 :ref:`Godot 設計理念 "
"<doc_best_practices_for_engine_contributors>`的設計決策，為新的算繪貢獻者提供"
"入手點。"

msgid ""
"If you have questions about rendering internals not answered here, feel free "
"to ask in the ``#rendering`` channel of the `Godot Contributors Chat "
"<https://chat.godotengine.org/channel/rendering>`__."
msgstr ""
"如果你有關於內部算繪的問題在此未得到解答，歡迎在 `Godot 貢獻者聊天 <https://"
"chat.godotengine.org/channel/rendering>`__的 ``#rendering`` 頻道中進行提問。"

msgid ""
"If you have difficulty understanding concepts on this page, it is "
"recommended to go through an OpenGL tutorial such as `LearnOpenGL <https://"
"learnopengl.com/>`__."
msgstr ""
"如果你在理解這個頁面上的概念時遇到了困難，建議先過一遍 `LearnOpenGL <https://"
"learnopengl.com/>`__ 等 OpenGL 教學。"

msgid "Rendering methods"
msgstr "算繪"

msgid "Forward+"
msgstr "Forward+"

msgid ""
"This is a forward renderer that uses a *clustered* approach to lighting."
msgstr "這是一種前向算繪器，使用*集群*方法實作光照。"

msgid ""
"Clustered lighting uses a compute shader to group lights into a 3D frustum "
"aligned grid. Then, at render time, pixels can lookup what lights affect the "
"grid cell they are in and only run light calculations for lights that might "
"affect that pixel."
msgstr ""
"集群光照使用計算著色器將燈光按照 3D 視錐柵格進行群組。然後在算繪時，像素就能"
"夠查詢影響某個柵格單元的有哪些燈光，僅對影響該像素的燈光進行光照計算。"

msgid ""
"This approach can greatly speed up rendering performance on desktop "
"hardware, but is substantially less efficient on mobile."
msgstr "這種方法能夠大幅提升在桌面硬體上的算繪性能，但是在移動端會略為低效。"

msgid "Mobile"
msgstr "移動裝置"

msgid ""
"Intended for mobile platforms, but can also run on desktop platforms. This "
"rendering method is optimized to perform well on mobile GPUs. Mobile GPUs "
"have a very different architecture compared to desktop GPUs due to their "
"unique constraints around battery usage, heat, and overall bandwidth "
"limitations of reading and writing data. Compute shaders also have very "
"limited support or aren't supported at all. As a result, the mobile renderer "
"purely uses raster-based shaders (fragment/vertex)."
msgstr ""
"針對移動平臺設計，但是也能夠在桌面平臺運作。這種算繪方法針對移動 GPU 進行了優"
"化。移動 GPU 的架構與桌面 GPU 有很大的區別，因為需要考慮電池使用、散熱、讀寫"
"資料時的總體頻寬限制等約束。對計算著色器的支援也非常有限，甚至完全不支援。因"
"此，移動算繪器單純使用基於光柵的著色器（片段/頂點）。"

msgid ""
"Unlike desktop GPUs, mobile GPUs perform *tile-based rendering*. Instead of "
"rendering the whole image as a single unit, the image is divided in smaller "
"tiles that fit within the faster internal memory of the mobile GPU. Each "
"tile is rendered and then written out to the destination texture. This all "
"happens automatically on the graphics driver."
msgstr ""
"與桌面 GPU 不同，移動 GPU 執行的是*基於圖塊的算繪*。整個圖像不是作為整體算繪"
"的，而是會細分為較小的圖塊，適合放置到移動 GPU 更快的內部儲存中。圖塊單獨算繪"
"後就會寫入到目標紋理上。圖形驅動會自動進行這一步操作。"

msgid ""
"The problem is that this introduces bottlenecks in our traditional approach. "
"For desktop rendering, we render all opaque geometry, then handle the "
"background, then transparent geometry, then post-processing. Each pass will "
"need to read the current result into tile memory, perform its operations and "
"then write it out again. We then wait for all tiles to be completed before "
"moving on to the next pass."
msgstr ""
"問題在於，這種做法會在我們的傳統方法中造成瓶頸。對於桌面算繪，我們會先算繪所"
"有不透明的幾何體，然後處理背景，再處理透明的幾何體，最後進行後期處理。每個步"
"驟都需要將目前的結果讀進圖塊記憶體，執行對應的運算後再寫出。我們需要等待所有"
"圖塊都完成後才能繼續下一個階段。"

msgid ""
"The second important change is the use of sub-passes whenever possible. Sub-"
"passes allows us to perform the rendering steps end-to-end per tile saving "
"on the overhead introduced by reading from and writing to the tiles between "
"each rendering pass. The ability to use sub-passes is limited by the "
"inability to read neighboring pixels, as we're constrained to working within "
"a single tile."
msgstr ""
"第二個重要更改就是盡可能使用子階段（sub-pass）。子階段能夠按照圖塊來執行算繪"
"步驟，節省每個算繪階段之間讀寫圖塊帶來的開銷。使用子階段帶來的限制是無法讀取"
"相鄰像素，因為我們只能針對單一圖塊進行處理。"

msgid ""
"This limitation of subpasses results in not being able to implement features "
"such as glow and depth of field efficiently. Similarly, if there is a "
"requirement to read from the screen texture or depth texture, we must fully "
"write out the rendering result limiting our ability to use sub-passes. When "
"such features are enabled, a mix of sub-passes and normal passes are used, "
"and these features result in a notable performance penalty."
msgstr ""
"子階段的這一限制導致我們無法高效實作輝光、景深等功能。類似地，如果需要讀取螢"
"幕紋理或者深度紋理，我們就必須將算繪結果完全寫出，限制對子階段的使用。啟用這"
"種功能時，會混用子階段和正常階段，因此會帶來明顯的性能損失。"

msgid ""
"Given its low-end focus, this rendering method does not provide high-end "
"rendering features such as SDFGI and :ref:`doc_volumetric_fog`. Several post-"
"processing effects are also not available."
msgstr ""
"由於關注點在於低端裝置，這種算繪方法並不提供 SDFGI、:ref:`doc_volumetric_fog`"
"等高端算繪功能。部分後期處理效果也不可用。"

msgid "Compatibility"
msgstr "編譯"

msgid ""
"Like the Mobile renderer, the Compatibility renderer uses an R10G10B10A2 "
"UNORM texture for 3D rendering. Unlike the mobile renderer, colors are "
"tonemapped and stored in sRGB format so there is no HDR support. This avoids "
"the need for a tonemapping pass and allows us to use the lower bit texture "
"without substantial banding."
msgstr ""
"與“移動”算繪器類似，“相容”算繪器在進行 3D 算繪時使用的也是 R10G10B10A2 UNORM "
"紋理。與移動算繪器不同的是，顏色都經過了色調對應，以 sRGB 格式儲存，因此不支"
"援 HDR。這樣就不需要再執行色調對應階段，能夠使用低位紋理，不會產生明顯的條"
"帶。"

msgid ""
"The Compatibility renderer uses a traditional forward single-pass approach "
"to drawing objects with lights, but it uses a multi-pass approach to draw "
"lights with shadows. Specifically, in the first pass, it can draw multiple "
"lights without shadows and up to one DirectionalLight3D with shadows. In "
"each subsequent pass, it can draw up to one OmniLight3D, one SpotLight3D and "
"one DirectionalLight3D with shadows. Lights with shadows will affect the "
"scene differently than lights without shadows, as the lighting is blended in "
"sRGB space instead of linear space. This difference in lighting will impact "
"how the scene looks and needs to be kept in mind when designing scenes for "
"the Compatibility renderer."
msgstr ""
"“相容”算繪器在繪製帶光照的物件時使用的傳統的單階段向前方法，但是帶陰影的燈光"
"會使用多階段方法。確切地說，第一個階段能夠繪製多個不帶陰影的燈光以及一個帶陰"
"影的 DirectionalLight3D。後續的各個階段中，最多只能分別繪製一個帶陰影的 "
"OmniLight3D、 SpotLight3D、 DirectionalLight3D。帶陰影的燈光對場景的影響與不"
"帶陰影的燈光不同，因為光照的混合使用的是 sRGB 空間而不是線性空間。這種區別會"
"影響場景的外觀，針對“相容”算繪器設計場景時需要謹記於心。"

msgid "Why not deferred rendering?"
msgstr "為什麼不使用延遲算繪？"

msgid ""
"Forward rendering generally provides a better tradeoff for performance "
"versus flexibility, especially when a clustered approach to lighting is "
"used. While deferred rendering can be faster in some cases, it's also less "
"flexible and requires using hacks to be able to use MSAA. Since games with a "
"less realistic art style can benefit a lot from MSAA, we chose to go with "
"forward rendering for Godot 4 (like Godot 3)."
msgstr ""
"向前算繪通常能夠在性能和靈活性之間達到更好的平衡，尤其是在燈光使用了集群方法"
"的情況下。延遲算繪雖然在某些情況下更快，但是靈活性較低、使用 MSAA 需要特殊處"
"理。MSAA 能夠為非寫實畫風的遊戲帶來很大提升，因此我們選擇在 Godot 4 使用向前"
"算繪（Godot 3 也一樣）。"

msgid ""
"That said, parts of the forward renderer *are* performed with a deferred "
"approach to allow for some optimizations when possible. This applies to "
"VoxelGI and SDFGI in particular."
msgstr ""
"話雖如此，向前算繪器中*確實*有一部分是使用延遲方法執行的，以便在可能的情況下"
"進行一些優化。這一點尤其適用於 VoxelGI 和 SDFGI。"

msgid ""
"A clustered deferred renderer may be developed in the future. This renderer "
"could be used in situations where performance is favored over flexibility."
msgstr ""
"未來可能會開發集群延遲算繪器。這種算繪器可以在對性能的要求大於靈活性的場合使"
"用。"

msgid "Rendering drivers"
msgstr "算繪"

msgid "Godot 4 supports the following graphics APIs:"
msgstr "Godot 可匯入下列圖片格式："

msgid "Vulkan"
msgstr "Vulkan"

msgid ""
"This is the main driver in Godot 4, with most of the development focus going "
"towards this driver."
msgstr "這是 Godot 4 的主要驅動，大部分開發集中在這個驅動上。"

msgid ""
"Vulkan 1.0 is required as a baseline, with optional Vulkan 1.1 and 1.2 "
"features used when available. `volk <https://github.com/zeux/volk>`__ is "
"used as a Vulkan loader, and `Vulkan Memory Allocator <https://github.com/"
"GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator>`__ is used for memory "
"management."
msgstr ""
"Vulkan 1.0 是必要的基準，Vulkan 1.1 和 1.2 的功能會有可用時使用。我們使用 "
"`volk <https://github.com/zeux/volk>`__ 作為 Vulkan 載入器，使用 `Vulkan "
"Memory Allocator <https://github.com/GPUOpen-LibrariesAndSDKs/"
"VulkanMemoryAllocator>`__ 進行記憶體管理。"

msgid ""
"Both the Forward+ and Mobile :ref:"
"`doc_internal_rendering_architecture_methods` are supported when using the "
"Vulkan driver."
msgstr ""
"使用 Vulkan 驅動時支援 Forward+ 和移動 :ref:"
"`doc_internal_rendering_architecture_methods`。"

msgid "**Vulkan context creation:**"
msgstr "**Vulkan 本文的建立：**"

msgid "Direct3D 12"
msgstr "字典"

msgid ""
"Like Vulkan, the Direct3D 12 driver targets modern platforms only. It is "
"designed to target both Windows and Xbox (whereas Vulkan can't be used "
"directly on Xbox)."
msgstr ""
"與 Vulkan 類似，Direct3D 12 驅動僅支援現代平臺，是針對 Windows 和 Xbox 設計的"
"（鑒於 Xbox 上無法直接使用 Vulkan）。"

msgid ""
"Both the Forward+ and Mobile :ref:"
"`doc_internal_rendering_architecture_methods` can be used with Direct3D 12."
msgstr ""
"使用 Direct3D 12 時支援 Forward+ 和移動 :ref:"
"`doc_internal_rendering_architecture_methods`。"

msgid "Metal"
msgstr "Metal"

msgid "OpenGL"
msgstr "OpenGL"

msgid ""
"This driver uses OpenGL ES 3.0 and targets legacy and low-end devices that "
"don't support Vulkan. OpenGL 3.3 Core Profile is used on desktop platforms "
"to run this driver, as most graphics drivers on desktop don't support OpenGL "
"ES. WebGL 2.0 is used for web exports."
msgstr ""
"這個驅動使用 OpenGL ES 3.0，針對的是不支援 Vulkan 的舊有裝置以及低端裝置。桌"
"面平臺運作該驅動時使用的是 OpenGL 3.3 Core Profile，因為桌面平臺的大部分圖形"
"驅動不支援 OpenGL ES。Web 匯出使用的是 WebGL 2.0。"

msgid ""
"Only the :ref:`doc_internal_rendering_architecture_compatibility` rendering "
"method can be used with the OpenGL driver."
msgstr ""
"使用 OpenGL 驅動是只能使用 :ref:"
"`doc_internal_rendering_architecture_compatibility` 算繪方法。"

msgid ""
":ref:`doc_internal_rendering_architecture_core_shaders` are entirely "
"different from the Vulkan renderer."
msgstr ""
":ref:`doc_internal_rendering_architecture_core_shaders` 與 Vulkan 算繪器完全"
"不同。"

msgid "Summary of rendering drivers/methods"
msgstr "算繪驅動/方法總結"

msgid ""
"The following rendering API + rendering method combinations are currently "
"possible:"
msgstr "目前可用的算繪 API + 算繪方法組合如下："

msgid "Direct3D 12 + Forward+"
msgstr "Direct3D 12 + Forward+"

msgid ""
"Each combination has its own limitations and performance characteristics. "
"Make sure to test your changes on all rendering methods if possible before "
"opening a pull request."
msgstr ""
"每種組合都有其自身的限制和性能特徵。如果可能，請確保在打開拉取請求之前測試所"
"有算繪方法的變更。"

msgid "RenderingDevice abstraction"
msgstr "RenderingDevice 抽象"

msgid "The OpenGL driver does not use the RenderingDevice abstraction."
msgstr "OpenGL 驅動不使用 RenderingDevice 抽象。"

msgid ""
"To make the complexity of modern low-level graphics APIs more manageable, "
"Godot uses its own abstraction called RenderingDevice."
msgstr ""
"為了使現代低階圖形 API 的複雜性更易於管理，Godot 使用自己的抽象，稱為 "
"RenderingDevice。"

msgid "**Vulkan RenderingDevice implementation:**"
msgstr "**Vulkan RenderingDevice 實作：**"

msgid "Core rendering classes architecture"
msgstr "核心算繪類架構"

msgid ""
"This diagram represents the structure of rendering classes in Godot, "
"including the RenderingDevice abstraction:"
msgstr "下圖展示了 Godot 中算繪類別的結構，包括 RenderingDevice 抽象："

msgid "Core shaders"
msgstr "自定功能"

msgid ""
"While shaders in Godot projects are written using a :ref:`custom language "
"inspired by GLSL <doc_shading_language>`, core shaders are written directly "
"in GLSL."
msgstr ""
"使用 `參考 GLSL 製作的著色器語言 <doc_shading_language>`_ 之純文字著色器。"

msgid ""
"These core shaders are embedded in the editor and export template binaries "
"at compile-time. To see any changes you've made to those GLSL shaders, you "
"need to recompile the editor or export template binary."
msgstr ""
"這些核心著色器嵌入在編輯器中，並在編譯時匯出模板二進位。要查看這些 GLSL 著色"
"器所做的任何更改，您需要重新編譯編輯器或匯出模板二進位。"

msgid ""
"Some material features such as height mapping, refraction and proximity fade "
"are not part of core shaders, and are performed in the default "
"BaseMaterial3D using the Godot shader language instead (not GLSL). This is "
"done by procedurally generating the required shader code depending on the "
"features enabled in the material."
msgstr ""
"某些材質功能（例如高度貼圖、折射和鄰近淡入淡出）不是核心著色器的一部分，而是"
"使用 Godot 著色器語言（不是 GLSL）在預設的 BaseMaterial3D 中執行。這是透過根"
"據材質中啟用的功能按程式產生所需的著色器程式碼來完成的。"

msgid ""
"By convention, shader files with ``_inc`` in their name are included in "
"other GLSL files for better code reuse. Standard GLSL preprocessing is used "
"to achieve this."
msgstr ""
"按照慣例，名稱中帶有 _inc 的著色器檔案包含在其他 GLSL 檔案中，以便更好地重複"
"使用程式碼。標準 GLSL 預處理用於實作此目的。"

msgid ""
"Core material shaders will be used by every material in the scene – both "
"with the default BaseMaterial3D and custom shaders. As a result, these "
"shaders must be kept as simple as possible to avoid performance issues and "
"ensure shader compilation doesn't become too slow."
msgstr ""
"場景中的每種材質都將使用核心材質著色器 - 包括預設的 BaseMaterial3D 和自訂著色"
"器。因此，這些著色器必須盡可能簡單，以避免效能問題並確保著色器編譯不會變得太"
"慢。"

msgid ""
"If you use ``if`` branching in a shader, performance may decrease as :abbr:"
"`VGPR (Vector General-Purpose Register)` usage will increase in the shader. "
"This happens even if all pixels evaluate to ``true`` or ``false`` in a given "
"frame."
msgstr ""
"如果您在著色器中使用「if」分支，效能可能會下降，因為著色器中的 VGPR（向量通用"
"暫存器）使用量會增加。即使給定影格中所有像素的計算結果為“true”或“false”，也會"
"發生這種情況。"

msgid ""
"If you use ``#if`` preprocessor branching, the number of required shader "
"versions will increase in the scene. In a worst-case scenario, adding a "
"single boolean ``#define`` can *double* the number of shader versions that "
"may need to be compiled in a given scene. In some cases, Vulkan "
"specialization constants can be used as a faster (but more limited) "
"alternative."
msgstr ""
"如果您使用「#if」預處理器分支，則場景中所需的著色器版本的數量將會增加。在最壞"
"的情況下，新增單一布林值「#define」可以使給定場景中可能需要編譯的著色器版本的"
"數量加倍。在某些情況下，Vulkan 專業化常數可以用作更快（但更有限）的替代方案。"

msgid ""
"This means there is a high barrier to adding new built-in material features "
"in Godot, both in the core shaders and BaseMaterial3D. While BaseMaterial3D "
"can make use of dynamic code generation to only include the shader code if "
"the feature is enabled, it'll still require generating more shader versions "
"when these features are used in a project. This can make shader compilation "
"stutter more noticeable in complex 3D scenes."
msgstr ""
"這意味著在 Godot 中新增新的內建材質功能存在很高的障礙，無論是在核心著色器還"
"是 BaseMaterial3D 中。雖然 BaseMaterial3D 可以利用動態程式碼產生僅在啟用該功"
"能的情況下包含著色器程式碼，但當在專案中使用這些功能時，它仍然需要產生更多著"
"色器版本。這會使著色器編譯的卡頓現像在複雜的 3D 場景中更加明顯。"

msgid ""
"See `The Shader Permutation Problem <https://therealmjp.github.io/posts/"
"shader-permutations-part1/>`__ and `Branching on a GPU <https://medium.com/"
"@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2>`__ blog posts for more "
"information."
msgstr ""
"請參閱「著色器排列問題<https://therealmjp.github.io/posts/shader-"
"permutations-part1/>`__ 和「GPU 上的分支<https://medium.com/"
"@jasonbooth_86226/branching-on - a-gpu-18bfc83694f2>`__ 部落格文章以獲取更多"
"資訊。"

msgid "**Core GLSL material shaders:**"
msgstr "**核心 GLSL 材質著色器：**"

msgid "**Material shader generation:**"
msgstr "**材質著色器生成：**"

msgid "**Other GLSL shaders for the Compatibility rendering method:**"
msgstr "**Compatibility 算繪方法的其他 GLSL 著色器：**"

msgid "2D and 3D rendering separation"
msgstr "2D 與 3D 算繪的拆分"

msgid ""
"2D and 3D are rendered to separate buffers, as 2D rendering in Godot is "
"performed in :abbr:`LDR (Low Dynamic Range)` sRGB-space while 3D rendering "
"uses :abbr:`HDR (High Dynamic Range)` linear space."
msgstr ""
"2D 和 3D 算繪到單獨的緩衝區，因為 Godot 中的 2D 算繪是在 LDR（低動態範圍）"
"sRGB 空間中執行的，而 3D 算繪則使用 HDR（高動態範圍）線性空間。"

msgid ""
"The color format used for 2D rendering is RGB8 (RGBA8 if the **Transparent** "
"property on the Viewport is enabled). 3D rendering uses a 24-bit unsigned "
"normalized integer depth buffer, or 32-bit signed floating-point if a 24-bit "
"depth buffer is not supported by the hardware. 2D rendering does not use a "
"depth buffer."
msgstr ""
"用於 2D 算繪的顏色格式是 RGB8（如果啟用了視窗上的 **Transparent** 屬性，則為 "
"RGBA8）。 3D 算繪使用 24 位元無符號標準化整數深度緩衝區，如果硬體不支援 24 位"
"元深度緩衝區，則使用 32 位元有符號浮點。 2D 算繪不使用深度緩衝區。"

msgid ""
"3D resolution scaling is performed differently depending on whether bilinear "
"or FSR 1.0 scaling is used. When bilinear scaling is used, no special "
"upscaling shader is run. Instead, the viewport's texture is stretched and "
"displayed with a linear sampler (which makes the filtering happen directly "
"on the hardware). This allows maximizing the performance of bilinear 3D "
"scaling."
msgstr ""
"根據是否使用雙線性縮放或 FSR 1.0 縮放，3D 解析度縮放的執行方式有所不同。使用"
"雙線性縮放時，不會執行特殊的放大著色器。相反，視口的紋理被拉伸並使用線性取樣"
"器顯示（這使得篩選直接在硬體上發生）。這可以最大限度地提高雙線性 3D 縮放的效"
"能。"

msgid ""
"The ``configure()`` function in RenderSceneBuffersRD reallocates the 2D/3D "
"buffers when the resolution or scaling changes."
msgstr ""
"當解析度或縮放比例改變時，RenderSceneBuffersRD 中的「configure()」函式會重新"
"分配 2D/3D 緩衝區。"

msgid ""
"Dynamic resolution scaling isn't supported yet, but is planned in a future "
"Godot release."
msgstr "目前尚不支援動態解析度縮放，但計劃在未來的 Godot 版本中支援。"

msgid "**2D and 3D rendering buffer configuration C++ code:**"
msgstr "**2D與3D算繪緩衝區配置C++程式碼：**"

msgid "2D rendering techniques"
msgstr "Animation - 動畫選項"

msgid ""
"2D light rendering is performed in a single pass to allow for better "
"performance with large amounts of lights."
msgstr "2D 燈光算繪在單通道中執行，以便在大量燈光下獲得更好的效能。"

msgid ""
"The Forward+ and Mobile rendering methods don't feature 2D batching yet, but "
"it's planned for a future release."
msgstr ""
"Forward+ 和 Mobile 算繪方法尚不具備 2D 批次功能，但計劃在未來版本中提供。"

msgid ""
"MSAA can be enabled in 2D to provide \"automatic\" line and polygon "
"antialiasing, but FXAA does not affect 2D rendering as it's calculated "
"before 2D rendering begins. Godot's 2D drawing methods such as the Line2D "
"node or some CanvasItem ``draw_*()`` methods provide their own way of "
"antialiasing based on triangle strips and vertex colors, which don't require "
"MSAA to work."
msgstr ""
"可以在 2D 中啟用 MSAA 以提供「自動」線條和多邊形抗鋸齒，但 FXAA 不會影響 2D "
"算繪，因為它是在 2D 算繪開始之前計算的。 Godot 的 2D 繪圖方法（例如 Line2D 節"
"點或某些 CanvasItem “draw_*()” 方法）提供了自己的基於三角形條和頂點顏色的抗鋸"
"齒方式，不需要 MSAA 即可運作。"

msgid "**2D SDF generation GLSL shader:**"
msgstr "**2D SDF 生成 GLSL 著色器：**"

msgid "3D rendering techniques"
msgstr "Animation - 動畫選項"

msgid "Batching and instancing"
msgstr "Animation - 動畫選項"

msgid "Light, decal and reflection probe rendering"
msgstr "Sprite、多邊形與線條算繪引擎。"

msgid ""
"All rendering methods also support rendering up to 8 directional lights at "
"the same time (albeit with lower shadow quality when more than one light has "
"shadows enabled)."
msgstr ""
"所有算繪方法還支援同時算繪最多 8 個定向光源（儘管當多個光源啟用陰影時陰影品質"
"較低）。"

msgid ""
"In all 3 methods, lights without shadows are much cheaper than lights with "
"shadows. To improve performance, lights are only updated when the light is "
"modified or when objects in its radius are modified. Godot currently doesn't "
"separate static shadow rendering from dynamic shadow rendering, but this is "
"planned in a future release."
msgstr ""
"在所有 3 種方法中，沒有陰影的光線比有陰影的燈光便宜得多。為了提高效能，僅當修"
"改燈光或其半徑內的物件時才會更新燈光。 Godot 目前並未將靜態陰影算繪與動態陰影"
"算繪分開，但計劃在未來版本中實作這一點。"

msgid "Shadow mapping"
msgstr "陰影貼圖"

msgid ""
"Additionally, both shadow-mapping techniques rotate the kernel on a per-"
"pixel basis to help soften under-sampling artifacts."
msgstr ""
"此外，這兩種陰影貼圖技術都會在每個像素的基礎上旋轉內核，以幫助柔化取樣不足的"
"偽影。"

msgid "Temporal antialiasing"
msgstr "多取樣抗鋸齒"

msgid ""
"Godot uses a custom TAA implementation based on the old TAA implementation "
"from `Spartan Engine <https://github.com/PanosK92/SpartanEngine>`__."
msgstr ""
"Godot 使用基於「Spartan Engine <https://github.com/PanosK92/SpartanEngine>」"
"的舊 TAA 實作的自訂 TAA 實作。"

msgid ""
"Temporal antialiasing requires motion vectors to work. If motion vectors are "
"not correctly generated, ghosting will occur when the camera or objects move."
msgstr ""
"時間抗鋸齒需要運動向量才能發揮作用。如果運動向量沒有正確生成，當相機或物體移"
"動時就會出現重影。"

msgid ""
"Motion vectors are generated on the GPU in the main material shader. This is "
"done by running the vertex shader corresponding to the previous rendered "
"frame (with the previous camera transform) in addition to the vertex shader "
"for the current rendered frame, then storing the difference between them in "
"a color buffer."
msgstr ""
"運動向量在 GPU 上的主材質著色器中產生。這是透過除了目前算繪影格的頂點著色器之"
"外還運作與先前算繪影格（使用先前的相機變換）相對應的頂點著色器，然後將它們之"
"間的差異儲存在顏色緩衝區中來完成的。"

msgid "**TAA resolve:**"
msgstr "**TAA 解決方案：**"

msgid "Global illumination"
msgstr "定數"

msgid ""
"Godot supports voxel-based GI (VoxelGI), signed distance field GI (SDFGI) "
"and lightmap baking and rendering (LightmapGI). These techniques can be used "
"simultaneously if desired."
msgstr ""
"Godot 支援基於體素的 GI (VoxelGI)、有符號距離場 GI (SDFGI) 以及光照貼圖烘焙和"
"算繪 (LightmapGI)。如果需要，這些技術可以同時使用。"

msgid "**Core GI C++ code:**"
msgstr "**核心 GI C++ 程式碼：**"

msgid "**Core GI GLSL shaders:**"
msgstr "**核心 GI GLSL 著色器：**"

msgid "**Lightmapper C++ code:**"
msgstr "**光照貼圖器 C++ 程式碼：**"

msgid "**Lightmapper GLSL shaders:**"
msgstr "**光照貼圖器 GLSL 著色器：**"

msgid "Depth of field"
msgstr "景深"

msgid ""
"Box, hexagon and circle bokeh shapes are available (from fastest to "
"slowest). Depth of field can optionally be jittered every frame to improve "
"its appearance when temporal antialiasing is enabled."
msgstr ""
"提供方框、六邊形和圓形散景形狀（從最快到最慢）。當啟用時間抗鋸齒時，可以選擇"
"每個畫面抖動景深以改善其外觀。"

msgid "**Depth of field C++ code:**"
msgstr "景深"

msgid "**Depth of field GLSL shader (compute - used for Forward+):**"
msgstr "**景深 GLSL 著色器（計算 - 用於 Forward+）：**"

msgid "Screen-space effects (SSAO, SSIL, SSR, SSS)"
msgstr "螢幕空間反射(SSR)"

msgid ""
"SSAO uses an implementation derived from Intel's `ASSAO <https://www.intel."
"com/content/www/us/en/developer/articles/technical/adaptive-screen-space-"
"ambient-occlusion.html>`__ (converted to Vulkan). SSIL is derived from SSAO "
"to provide high-performance indirect lighting."
msgstr ""
"SSAO 使用源自英特爾`ASSAO <https://www.intel.com/content/www/us/en/developer/"
"articles/technical/adaptive-screen-space-ambient-occlusion.html>`__ 的實作"
"（轉換為到伏爾甘）。 SSIL源自SSAO，提供高效能間接照明。"

msgid ""
"When both SSAO and SSIL are enabled, parts of SSAO and SSIL are shared to "
"reduce the performance impact."
msgstr "當 SSAO 和 SSIL 同時啟用時，部分 SSAO 和 SSIL 會被共用以減少效能影響。"

msgid ""
"SSAO and SSIL are performed at half resolution by default to improve "
"performance. SSR is always performed at half resolution to improve "
"performance."
msgstr ""
"預設情況下，SSAO 和 SSIL 以半解析度執行以提高效能。 SSR 始終以半解析度執行以"
"提高效能。"

msgid "**Screen-space effects C++ code:**"
msgstr "**GLES3:** 螢幕空間反射。"

msgid "**Screen-space ambient occlusion GLSL shader:**"
msgstr "**GLES3:** 螢幕空間週遭遮擋。"

msgid "**Screen-space indirect lighting GLSL shader:**"
msgstr "**螢幕空間間接光照 GLSL 著色器：**"

msgid "**Screen-space reflections GLSL shader:**"
msgstr "**GLES3:** 螢幕空間反射。"

msgid "**Subsurface scattering GLSL:**"
msgstr "次表面散射"

msgid "Sky rendering"
msgstr "算繪"

msgid ":ref:`doc_sky_shader`"
msgstr ":ref:`doc_spatial_shader`"

msgid ""
"Godot supports using shaders to render the sky background. The radiance map "
"(which is used to provide ambient light and reflections for PBR materials) "
"is automatically updated based on the sky shader."
msgstr ""
"Godot 支援使用著色器來算繪天空背景。輻射度貼圖（用於為 PBR 材質提供環境光和反"
"射）會根據天空著色器自動更新。"

msgid ""
"The SkyMaterial resources such as ProceduralSkyMaterial, PhysicalSkyMaterial "
"and PanoramaSkyMaterial generate a built-in shader for sky rendering. This "
"is similar to what BaseMaterial3D provides for 3D scene materials."
msgstr ""
"SkyMaterial 資源（例如 ProceduralSkyMaterial、PhysicalSkyMaterial 和 "
"PanoramaSkyMaterial）產生用於天空算繪的內建著色器。這類似於 BaseMaterial3D "
"為 3D 場景材質提供的內容。"

msgid ""
"A detailed technical implementation can be found in the `Custom sky shaders "
"in Godot 4.0 <https://godotengine.org/article/custom-sky-shaders-"
"godot-4-0>`__ article."
msgstr ""
"詳細的技術實作可以在《Godot 4.0 中的自訂天空著色器 <https://godotengine.org/"
"article/custom-sky-shaders-godot-4-0>》一文中找到。"

msgid "**Sky rendering C++ code:**"
msgstr "**天空算繪 C++ 程式碼：**"

msgid "**Sky rendering GLSL shader:**"
msgstr "**天空算繪 GLSL 著色器：**"

msgid "Volumetric fog"
msgstr "體積霧"

msgid ":ref:`doc_fog_shader`"
msgstr ":ref:`doc_spatial_shader`"

msgid ""
"Godot supports a frustum-aligned voxel (froxel) approach to volumetric fog "
"rendering. As opposed to a post-processing filter, this approach is more "
"general-purpose as it can work with any light type. Fog can also use shaders "
"for custom behavior, which allows animating the fog or using a 3D texture to "
"represent density."
msgstr ""
"Godot 支援使用平截頭體對準體素 (froxel) 方法來進行體積霧算繪。與後處理濾鏡相"
"反，這種方法更通用，因為它可以適用於任何光線型別。霧還可以使用著色器進行自訂"
"行為，從而允許對霧進行動畫處理或使用 3D 紋理來表示密度。"

msgid ""
"The FogMaterial resource generates a built-in shader for FogVolume nodes. "
"This is similar to what BaseMaterial3D provides for 3D scene materials."
msgstr ""
"FogMaterial 資源為 FogVolume 節點產生內建著色器。這類似於 BaseMaterial3D 為 "
"3D 場景材質提供的內容。"

msgid ""
"A detailed technical explanation can be found in the `Fog Volumes arrive in "
"Godot 4.0 <https://godotengine.org/article/fog-volumes-arrive-in-godot-4>`__ "
"article."
msgstr ""
"詳細的技術解釋可以在《Godot 4.0 中引入 Fog Volumes <https://godotengine.org/"
"article/fog-volumes-arrive-in-godot-4>》一文中找到。"

msgid "**Volumetric fog C++ code:**"
msgstr "**體積霧 C++ 程式碼：**"

msgid "**Volumetric fog GLSL shaders:**"
msgstr "**體積霧 GLSL 著色器：**"

msgid "Occlusion culling"
msgstr "遮擋剔除"

msgid ""
"As complex occluders can introduce a lot of strain on the CPU, baked "
"occluders can be simplified automatically when generated in the editor."
msgstr ""
"由於複雜的遮蔽物會對 CPU 造成很大的壓力，因此在編輯器中產生時可以自動簡化烘焙"
"的遮蔽物。"

msgid ""
"This CPU-based approach has a few advantages over other solutions, such as "
"portals and rooms or a GPU-based culling solution:"
msgstr ""
"與其他解決方案（例如入口網站和房間或基於 GPU 的剔除解決方案）相比，這種基於 "
"CPU 的方法具有一些優點："

msgid ""
"No manual setup required (but can be tweaked manually for best performance)."
msgstr "無需手動設定（但可以手動調整以獲得最佳性能）。"

msgid ""
"No frame delay, which is problematic in cutscenes during camera cuts or when "
"the camera moves fast behind a wall."
msgstr ""
"沒有畫面延遲，這在攝影機切換期間或攝影機在牆後快速移動時的過場動畫中是有問題"
"的。"

msgid ""
"Works the same on all rendering drivers and methods, with no unpredictable "
"behavior depending on the driver or GPU hardware."
msgstr ""
"在所有算繪驅動程式和方法上的工作方式相同，根據驅動程式或 GPU 硬件，不會出現不"
"可預測的行為。"

msgid ""
"Occlusion culling is performed by registering occluder meshes, which is done "
"using OccluderInstance3D *nodes* (which themselves use Occluder3D "
"*resources*). RenderingServer then performs occlusion culling by calling "
"Embree in RendererSceneOcclusionCull."
msgstr ""
"遮擋剔除是透過註冊遮擋器網格來執行的，這是使用 OccluderInstance3D *節點*（其"
"本身使用 Occlusionr3D *資源*）完成的。然後RenderingServer透過呼叫"
"RendererSceneOcclusionCull中的Embree來執行遮蔽剔除。"

msgid "**Occlusion culling C++ code:**"
msgstr "遮擋模式"

msgid "Visibility range (LOD)"
msgstr "Visibility Rect(可見性區域)"

msgid ""
"Godot supports manually authored hierarchical level of detail (HLOD), with "
"distances specified by the user in the inspector."
msgstr "Godot 支援手動建立的細節層級 (HLOD)，距離由使用者在檢視器中指定。"

msgid ""
"In RenderingSceneCull, the ``_scene_cull()`` and ``_render_scene()`` "
"functions are where most of the LOD determination happens. Each viewport can "
"render the same mesh with different LODs (to allow for split screen "
"rendering to look correct)."
msgstr ""
"在 RenderingSceneCull 中，「_scene_cull()」和「_render_scene()」函式是大多數 "
"LOD 決定發生的地方。每個視窗都可以使用不同的 LOD 算繪相同的網格（以允許分割畫"
"面算繪看起來正確）。"

msgid "**Visibility range C++ code:**"
msgstr "**可見範圍C++程式碼：**"

msgid "Automatic mesh LOD"
msgstr "自動重新匯入"

msgid ""
"The ImporterMesh class is used for the 3D mesh import workflow in the "
"editor. Its ``generate_lods()`` function handles generating using the "
"`meshoptimizer <https://meshoptimizer.org/>`__ library."
msgstr ""
"ImporterMesh 類別用於編輯器中的 3D 網格匯入工作流程。它的「generate_lods()」"
"函式使用「meshoptimizer <https://meshoptimizer.org/>」函式庫處理產生。"

msgid ""
"LOD mesh generation also generates shadow meshes at the same time. These are "
"meshes that have their vertices welded regardless of smoothing and "
"materials. This is used to improve shadow rendering performance by lowering "
"the vertex throughput required to render shadows."
msgstr ""
"LOD網格生成同時也產生陰影網格。這些網格的頂點都是焊接的，無論平滑度和材料如"
"何。這用於透過降低算繪陰影所需的頂點吞吐量來提高陰影算繪效能。"

msgid ""
"The RenderingSceneCull class's ``_render_scene()`` function determines which "
"mesh LOD should be used when rendering. Each viewport can render the same "
"mesh with different LODs (to allow for split screen rendering to look "
"correct)."
msgstr ""
"RenderingSceneCull 類別的 _render_scene() 函式決定算繪時應使用哪個網格 LOD。"
"每個視窗都可以使用不同的 LOD 算繪相同的網格（以允許分割畫面算繪看起來正確）。"

msgid ""
"The mesh LOD is automatically chosen based on a screen coverage metric. This "
"takes resolution and camera FOV changes into account without requiring user "
"intervention. The threshold multiplier can be adjusted in the project "
"settings."
msgstr ""
"網格 LOD 是根據螢幕覆蓋指標自動選擇的。這會考慮解析度和相機視場變化，而無需使"
"用者乾預。閾值乘數可以在專案設定中調整。"

msgid ""
"To improve performance, shadow rendering and reflection probe rendering also "
"choose their own mesh LOD thresholds (which can be different from the main "
"scene rendering)."
msgstr ""
"為了提高效能，陰影算繪和反射探查算繪還選擇自己的網格 LOD 閾值（可以與主場景算"
"繪不同）。"

msgid "**Mesh LOD generation on import C++ code:**"
msgstr "**匯入 C++ 程式碼時產生網格 LOD：**"

msgid "**Mesh LOD determination C++ code:**"
msgstr "**網格LOD測定C++程式碼：**"
