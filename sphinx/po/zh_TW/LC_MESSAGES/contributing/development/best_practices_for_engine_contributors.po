#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Best practices for engine contributors"
msgstr "引擎貢獻者最佳實踐"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot has a large amount of users who have the ability to contribute because "
"the project itself is aimed mainly at users who can code. That being said, "
"not all of them have the same level of experience working in large projects "
"or in software engineering, which can lead to common misunderstandings and "
"bad practices during the process of contributing code to the project."
msgstr ""
"Godot 擁有大量具備貢獻能力的使用者，因為這個專案本身主要面向會寫程式的人。但"
"並不是每個人都具備大型專案或軟體工程的經驗，這在貢獻程式碼的過程中，容易導致"
"常見的誤解與不良實踐。"

msgid "Language"
msgstr "用語"

msgid ""
"The scope of this document is to be a list of best practices for "
"contributors to follow, as well as to create a language they can use to "
"refer to common situations that arise in the process of submitting their "
"contributions."
msgstr ""
"本文旨在列出貢獻者應遵循的最佳實踐，並建立一套可於貢獻過程中討論常見情境時使"
"用的用語。"

msgid ""
"While a generalized list of software development best practices might be "
"useful, we'll focus on the situations that are most common in our project."
msgstr ""
"雖然一般化的軟體開發最佳實踐很有參考價值，但我們會聚焦於 Godot 專案中最常見的"
"情境。"

msgid ""
"Contributions are most of the time categorized as bug fixes, enhancements or "
"new features. To abstract this idea, we will call them *Solutions*, because "
"they always seek to solve something that can be described as a *Problem*."
msgstr ""
"貢獻大致可分為修正錯誤、改善功能或新增功能。為了簡化說明，這些我們都稱為「解"
"決方案」，因為它們都是針對某個可以被稱為「問題」的狀況來解決。"

msgid "Best Practices"
msgstr "最佳實踐"

msgid "#1: The problem always comes first"
msgstr "#1：問題優先"

msgid ""
"Many contributors are extremely creative and just enjoy the process of "
"designing abstract data structures, creating nice user interfaces, or simply "
"love programming. Whatever the case may be, they come up with cool ideas, "
"which may or may not solve real problems."
msgstr ""
"許多貢獻者極具創意，享受設計抽象資料結構、打造良好使用者介面，或單純喜歡寫程"
"式。不論動機為何，他們會想出許多點子，但這些點子未必能真正解決實際問題。"

msgid ""
"These are usually called *solutions in search of a problem*. In an ideal "
"world, they would not be harmful but, in reality, code takes time to write, "
"takes up space and requires maintenance once it exists. Avoiding the "
"addition of anything unnecessary is always considered a good practice in "
"software development."
msgstr ""
"這類情況通常被稱為「為問題而尋找解決方案」。理論上這沒什麼壞處，但實際上，程"
"式碼需要花時間撰寫、佔用空間，且一旦存在就需維護。避免加入不必要的內容，始終"
"是軟體開發中的好習慣。"

msgid "#2: To solve the problem, it has to exist in the first place"
msgstr "#2：解決問題前，必須先確認問題真的存在"

msgid ""
"This is a variation of the previous practice. Adding anything unnecessary is "
"not a good idea, but what constitutes what is necessary and what isn't?"
msgstr ""
"這是前一個最佳實踐的變體。雖然說加入不必要的東西不好，但什麼叫做必要、什麼又"
"是不必要？"

msgid ""
"The answer to this question is that the problem needs to *exist* before it "
"can be actually solved. It must not be speculation or a belief. The user "
"must be using the software as intended to create something they *need*. In "
"this process, the user may stumble upon a problem that requires a solution "
"to proceed, or in order to achieve greater productivity. In this case, *a "
"solution is needed*."
msgstr ""
"這個問題的答案是，只有「確實存在」的問題才值得解決。問題不能只是臆測或想像。"
"使用者必須以預期方式操作軟體、產生需求，在過程中遇到阻礙或為了提升效率產生問"
"題，這時才真正需要解決方案。"

msgid ""
"Believing that problems may arise in the future and that the software needs "
"to be ready to solve them by the time they appear is called *\"Future "
"proofing\"* and its characterized by lines of thought such as:"
msgstr ""
"認為未來可能出現的問題必須預先因應，這種想法稱為「未雨綢繆（Future "
"proofing）」，常見表現如下："

msgid "I think it would be useful for users to..."
msgstr "我認為如果讓使用者可以…會很實用…"

msgid "I think users will eventually need to..."
msgstr "我覺得使用者以後一定會需要……"

msgid ""
"This is generally considered a bad habit because trying to solve problems "
"that *don't actually exist* in the present will often lead to code that will "
"be written but never used, or that is considerably more complex to use and "
"maintain than it needs to be."
msgstr ""
"這通常被認為是壞習慣。試圖解決「目前根本不存在」的問題，常會導致寫出沒有人會"
"用到的程式碼，或者讓系統比實際需求複雜、難以維護。"

msgid "#3: The problem has to be complex or frequent"
msgstr "#3：問題必須夠複雜或夠常見"

msgid ""
"Software is designed to solve problems, but we can't expect it to solve "
"*every problem that exists under the sun*. As a game engine, Godot will help "
"you make games better and faster, but it won't make an *entire game* for "
"you. A line must be drawn somewhere."
msgstr ""
"軟體的目的是解決問題，但我們不能期望它解決「所有」問題。Godot 作為一套遊戲引"
"擎，可以幫助你更好、更快地開發遊戲，但它不會幫你做完一整個遊戲。我們必須劃出"
"界線。"

msgid ""
"Whether a problem is worth solving is determined by the effort that is "
"required to work around it. The required effort depends on:"
msgstr "一個問題是否值得解決，可以從使用者是否容易繞過來判斷。判斷標準如下："

msgid "The complexity of the problem"
msgstr "問題的複雜度"

msgid "The frequency the problem"
msgstr "問題的發生頻率"

msgid ""
"If the problem is *too complex* for most users to solve, then the software "
"should offer a ready-made solution for it. Likewise, if the problem is easy "
"for the user to work around, offering such a solution is unnecessary."
msgstr ""
"如果問題對大多數使用者來說「太複雜」而難以自行解決，軟體就應該提供現成的解決"
"方案。同理，若問題很容易繞過，那就沒有必要額外提供解法。"

msgid ""
"The exception, however, is when the user encounters a problem *frequently "
"enough* that having to do the simple solution every time becomes an "
"annoyance. In this case, the software should offer a solution to simplify "
"the use case."
msgstr ""
"但有個例外：如果某問題「非常常見」，即使每次繞過都很簡單，久了也會造成困擾。"
"這時候，軟體就應該提供簡化流程的解決方案。"

msgid ""
"It's usually easy to tell if a problem is complex or frequent, but it can be "
"difficult. This is why discussing with other developers (next point) is "
"always advised."
msgstr ""
"通常我們很容易判斷問題是否複雜或常見，但有時也會遇到難分的情況。所以我們建議"
"多和其他開發者討論（見下一點）。"

msgid "#4: The solution must be discussed with others"
msgstr "#4：解決方案必須和他人討論"

msgid ""
"Often, users will be immersed in their own projects when they stumble upon "
"problems. These users will naturally try to solve the problem from their "
"perspective, thinking only about their own use case. As a result, user "
"proposed solutions don't always contemplate all use cases and are often "
"biased towards the user's own requirements."
msgstr ""
"當使用者在自己的專案中遇到問題時，往往只會從自己的角度思考解決方法。因此提出"
"的方案未必能兼顧所有使用情境，常常只符合個人需求。"

msgid ""
"For developers, the perspective is different. They may find the user's "
"problem too unique to justify a solution (instead of a workaround), or they "
"might suggest a partial (usually simpler or lower level) solution that "
"applies to a wider range of known problems and leave the rest of the "
"solution up to the user."
msgstr ""
"開發者則會用不同角度來看待。他們可能覺得某個使用者的問題過於特殊而無需專門解"
"法（而是建議繞過），或建議一個較簡單、較底層的通用方案，讓使用者自行處理剩下"
"部分。"

msgid ""
"In any case, before attempting to contribute, it is important to discuss the "
"actual problems with the other developers or contributors, so a better "
"agreement on implementation can be reached."
msgstr ""
"無論如何，在貢獻之前，務必和其他開發者或貢獻者充分討論實際遇到的問題，才能達"
"成更好的實作共識。"

msgid ""
"The only exception is when an area of code has a clear agreed upon owner, "
"who talks to users directly and has the most knowledge to implement a "
"solution directly."
msgstr ""
"唯一的例外是，若該區塊的程式碼有明確的負責人，且他直接與使用者溝通、最了解如"
"何實作解決方法，則可直接由其決定。"

msgid ""
"Also, Godot's philosophy is to favor ease of use and maintenance over "
"absolute performance. Performance optimizations will be considered, but they "
"may not be accepted if they make something too difficult to use or if they "
"add too much complexity to the codebase."
msgstr ""
"此外，Godot 的理念是「易用性與可維護性」優先於絕對效能。我們會考慮效能優化，"
"但如果因此讓東西變得難用或讓程式碼過於複雜，可能就不會採納。"

msgid "#5: To each problem, its own solution"
msgstr "#5：每個問題各有其最佳解法"

msgid ""
"For programmers, it is always a most enjoyable challenge to find the most "
"optimal solutions to problems. It is possible to go overboard, though. "
"Sometimes, contributors will try to come up with solutions that solve as "
"many problems as possible."
msgstr ""
"對程式設計師來說，尋找最優解總是一大樂趣，但有時會做過頭，試圖提出一個能包山"
"包海、解決無數問題的方案。"

msgid ""
"The situation will often take a turn for the worse when, in order to make "
"this solution appear even more fantastic and flexible, the pure speculation-"
"based problems (as described in #2) also make their appearance on stage."
msgstr ""
"這種情況往往會更糟，因為為了讓解決方案看起來更厲害、更彈性，許多純粹臆測的問"
"題（見#2）也會被硬塞進來。"

msgid ""
"The main problem is that, in reality, it rarely works this way. Most of the "
"time, writing an individual solution to each problem results in code that is "
"simpler and more maintainable."
msgstr ""
"其實現實中這種做法很少有效。大部分時候，針對各別問題寫獨立解決方案，反而讓程"
"式碼更簡潔、更容易維護。"

msgid ""
"Additionally, solutions that target individual problems are better for the "
"users. Targeted solutions allow users find something that does exactly what "
"they need, without having to learn a more complex system they will only need "
"for simple tasks."
msgstr ""
"此外，針對特定問題設計的方案對使用者更友善。這讓使用者能直接找到剛好符合需求"
"的功能，而不用為了單純任務去學更複雜的系統。"

msgid ""
"Big and flexible solutions also have an additional drawback which is that, "
"over time, they are rarely flexible enough for all users. Users end up "
"requesting more and more functionality which ends up making the API and "
"codebase more and more complex."
msgstr ""
"又大又彈性的解決方案還有一個缺點：長期來看，它們往往沒辦法滿足所有人的需求，"
"導致使用者不斷要求加新功能，讓 API 與程式碼基礎越來越複雜。"

msgid "#6: Cater to common use cases, leave the door open for the rare ones"
msgstr "#6：優先滿足常見需求，罕見需求保持彈性"

msgid ""
"This is a continuation of the previous point, which further explains why "
"this way of thinking and designing software is preferred."
msgstr "這點是前述內容的延伸，進一步說明為何這種思維與設計方式比較好。"

msgid ""
"As mentioned before (in point #2), it is very difficult for us (as human "
"beings who design software) to actually understand all future user needs. "
"Trying to write very flexible structures that cater to many use cases at "
"once is often a mistake."
msgstr ""
"如前面（#2）提過，作為軟體設計者，我們很難預知所有未來的使用需求。嘗試一次設"
"計能涵蓋所有情境的超彈性架構，通常會適得其反。"

msgid ""
"We may come up with something we believe is brilliant, but later find out "
"that users will never even use half of it or that they require features that "
"don't quite fit into our original design, forcing us to either throw it away "
"or make it even more complex."
msgstr ""
"我們可能會自認設計得很棒，但事後卻發現使用者根本用不到一半功能，或他們需要的"
"東西和原本設計沒法吻合，最後不是被迫放棄，就是被迫讓系統變更複雜。"

msgid ""
"The question is then, how do we design software that both allows users to do "
"*what we know they need to do* now and allows them to do *what we don't yet "
"know they'll need to do* in the future?"
msgstr ""
"那問題來了：我們要如何設計一套軟體，既能滿足「已知需求」，又能在未來適度開放"
"給「目前未知的需求」？"

msgid ""
"The answer to this question is that, to ensure users still can do what they "
"want to do, we need to give them access to a *low-level API* that they can "
"use to achieve what they want, even if it's more work for them because it "
"means reimplementing some logic that already exists."
msgstr ""
"答案是：為了讓使用者能做想做的事，我們必須提供「底層 API」讓他們自行實作，即"
"使這樣會讓他們多花點功夫（因為可能得自行重寫部分邏輯）。"

msgid ""
"In real-life scenarios, these use cases will be at most rare and uncommon "
"anyway, so it makes sense a custom solution needs to be written. This is why "
"it's important to still provide users the basic building blocks to do it."
msgstr ""
"現實上，這類情境非常少見，所以讓使用者自行寫專屬解法是合理的。這就是為什麼要"
"提供基礎組件，讓使用者有辦法客製化。"

msgid "#7: Prefer local solutions"
msgstr "#7：優先採用局部解決方案"

msgid ""
"When looking for a solution to a problem, be it implementing a new feature "
"or fixing a bug, sometimes the easiest path is to add data or a new function "
"in the core layers of code."
msgstr ""
"在尋找問題解法時，不論是新增功能還是修正錯誤，有時最簡單的做法就是直接在核心"
"層增加資料或新函式。"

msgid ""
"The main problem here is, adding something to the core layers that will only "
"be used from a single location far away will not only make the code more "
"difficult to follow (split in two), but also make the core API larger, more "
"complex, more difficult to understand in general."
msgstr ""
"這麼做的主要問題是，若加到核心層的東西只在遠端某一處才會被用到，不僅讓程式碼"
"難以追蹤（被拆散），還會讓核心 API 變肥大、複雜、更難理解。"

msgid ""
"This is bad, because readability and cleanness of core APIs is always of "
"extreme importance given how much code relies on it, and because it's key "
"for new contributors as a starting point to learning the codebase."
msgstr ""
"這樣不好，因為核心 API 需維持高度可讀性與清晰度，畢竟有大量程式碼依賴它。而且"
"新進貢獻者學習程式碼時，通常也是從核心 API 開始。"

msgid ""
"A common reason for wanting to do this is that it's usually less code to "
"simply add a hack in the core layers."
msgstr "會想直接加在核心層，通常只是因為這樣寫起來程式碼最少。"

msgid ""
"Doing so is not advised. Generally, the code for a solution should be closer "
"to where the problem originates, even if it involves additional, duplicated, "
"more complex, or less efficient code. More creativity might be needed, but "
"this path is always the advised one."
msgstr ""
"但這種做法並不建議。原則上，解決方案的程式碼應該盡量靠近問題發生處，即使這樣"
"會讓程式碼變更多、重複、複雜或稍微沒那麼有效率。這也許需要更多創意，但這才是"
"推薦的做法。"

msgid "#8: Don't use complex canned solutions for simple problems"
msgstr "#8：不要用複雜解法處理簡單問題"

msgid ""
"Not every problem has a simple solution and, many times, the right choice is "
"to use a third-party library to solve the problem."
msgstr "不是每個問題都有簡單解法，很多時候，正確做法是引入第三方函式庫。"

msgid ""
"As Godot requires to be shipped in a large amount of platforms, we can't "
"link libraries dynamically. Instead, we bundle them in our source tree."
msgstr ""
"由於 Godot 需要支援多平台發行，我們無法動態載入函式庫，只能將其直接內嵌於原始"
"碼樹中。"

msgid ""
"As a result, we are very picky with what goes in, and we tend to prefer "
"smaller libraries (single header ones are our favorite). We will only bundle "
"something larger if there is no other choice."
msgstr ""
"因此，我們對要加入的函式庫相當謹慎，傾向採用輕量級函式庫（最佳是單一標頭檔"
"案）。只有在別無選擇時，才會考慮嵌入大型函式庫。"

msgid ""
"Libraries must use a permissive enough license to be included into Godot. "
"Some examples of acceptable licenses are Apache 2.0, BSD, MIT, ISC, and MPL "
"2.0. In particular, we cannot accept libraries licensed under the GPL or "
"LGPL since these licenses effectively disallow static linking in proprietary "
"software (which Godot is distributed as in most exported projects). This "
"requirement also applies to the editor, since we may want to run it on iOS "
"in the long term. Since iOS doesn't support dynamic linking, static linking "
"is the only option on that platform."
msgstr ""
"此外，函式庫的授權必須夠開放才能納入 Godot。可接受的授權條款如 Apache 2.0、"
"BSD、MIT、ISC、MPL 2.0 等。我們無法接受 GPL 或 LGPL 授權的函式庫，因為它們不"
"允許靜態連結到專有軟體（Godot 匯出專案大多如此發行）。這個要求也適用於編輯"
"器，因為我們未來可能要讓編輯器在 iOS 上執行。由於 iOS 不支援動態連結，只能使"
"用靜態連結。"
