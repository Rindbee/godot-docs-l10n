#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Pull request workflow"
msgstr "Pull Request 工作流程"

msgid ""
"The so-called \"PR workflow\" used by Godot is common to many projects using "
"Git, and should be familiar to veteran free software contributors. The idea "
"is that only a small number (if any) commit directly to the *master* branch. "
"Instead, contributors *fork* the project (i.e. create a copy of it, which "
"they can modify as they wish), and then use the GitHub interface to request "
"a *pull* from one of their fork's branches to one branch of the original "
"(often named *upstream*) repository."
msgstr ""
"Godot 所採用的「PR 工作流程」在許多使用 Git 的專案中都很常見，對資深自由軟體"
"貢獻者來說應該不陌生。其核心觀念是，只有極少數（或甚至沒有）人會直接在 "
"*master* 分支上提交（commit）。大多數貢獻者會先 *fork* 專案（即建立一份可自由"
"修改的副本），再透過 GitHub 介面，從自己 fork 的分支發起 *pull request* 到原"
"始儲存庫（通常稱為 *upstream*）的某個分支。"

msgid ""
"The resulting *pull request* (PR) can then be reviewed by other "
"contributors, which might approve it, reject it, or most often request that "
"modifications be done. Once approved, the PR can then be merged by one of "
"the core developers, and its commit(s) will become part of the target branch "
"(usually the *master* branch)."
msgstr ""
"所產生的 *Pull Request*（PR）會由其他貢獻者審核，可能會被通過、拒絕，或最常見"
"的是被要求修改。經審核通過後，PR 會由核心開發者合併，其 commit 便會成為目標分"
"支（通常是 *master*）的一部分。"

msgid ""
"We will go together through an example to show the typical workflow and "
"associated Git commands. But first, let's have a quick look at the "
"organization of Godot's Git repository."
msgstr ""
"接下來，我們會透過一個範例來說明典型的工作流程和相關 Git 指令。不過在此之前，"
"先快速介紹一下 Godot 的 Git 儲存庫結構。"

msgid "Git source repository"
msgstr "Git 原始碼儲存庫"

msgid ""
"The `repository on GitHub <https://github.com/godotengine/godot>`_ is a `Git "
"<https://git-scm.com>`_ code repository together with an embedded issue "
"tracker and PR system."
msgstr ""
"`GitHub 上的儲存庫 <https://github.com/godotengine/godot>`_ 是一個 `Git "
"<https://git-scm.com>`_ 原始碼儲存庫，內含議題追蹤（Issue Tracker）與 PR 系"
"統。"

msgid ""
"If you are contributing to the documentation, its repository can be found "
"`here <https://github.com/godotengine/godot-docs>`_."
msgstr ""
"如果你要貢獻說明文件，可以在 `這裡 <https://github.com/godotengine/godot-"
"docs>`_ 找到相關儲存庫。"

msgid ""
"The Git version control system is the tool used to keep track of successive "
"edits to the source code - to contribute efficiently to Godot, learning the "
"basics of the Git command line is *highly* recommended. There exist some "
"graphical interfaces for Git, but they usually encourage users to take bad "
"habits regarding the Git and PR workflow, and we therefore recommend not to "
"use them. In particular, we advise not to use GitHub's online editor for "
"code contributions (although it's tolerated for small fixes or documentation "
"changes) as it enforces one commit per file and per modification, which "
"quickly leads to PRs with an unreadable Git history (especially after peer "
"review)."
msgstr ""
"Git 版本控制系統用於追蹤原始碼的連續修改。若想有效率地貢獻 Godot，*強烈* 建議"
"學習 Git 指令列的基本操作。雖然有圖形化 Git 工具，但這些工具往往會讓使用者養"
"成不良的 Git 或 PR 習慣，因此我們不推薦這樣做。特別是，對於程式碼貢獻，我們不"
"建議使用 GitHub 的線上編輯器（雖然小幅修正或文件調整還可以），因為它會對每次"
"單一檔案修改產生一個 commit，這樣 PR 的 Git 歷史很快就會變得難以閱讀（尤其經"
"過同儕審查之後）。"

msgid ""
"The first sections of Git's \"Book\" are a good introduction to the tool's "
"philosophy and the various commands you need to master in your daily "
"workflow. You can read them online on the `Git SCM <https://git-scm.com/book/"
"en/v2>`_ website. You can also try out `GitHub's interactive guide <https://"
"try.github.io/>`__."
msgstr ""
"想認識 Git 的理念及日常所需指令，可以參考 Git「Book」的前幾章。你可以在 `Git "
"SCM <https://git-scm.com/book/zh-tw/v2>`_ 網站線上閱讀，也可試試 `GitHub 的互"
"動教學 <https://try.github.io/>`__。"

msgid "The branches on the Git repository are organized as follows:"
msgstr "Git 儲存庫的分支結構如下："

msgid ""
"The ``master`` branch is where the development of the next major version "
"occurs. As a development branch, it can be unstable and is not meant for use "
"in production. This is where PRs should be done in priority."
msgstr ""
"``master`` 分支是用來開發下一個主要版本的地方。作為開發分支，裡面的內容可能不"
"穩定，不建議用於正式環境。大多數 PR 都應該優先對此分支提出。"

msgid ""
"The stable branches are named after their version, e.g. ``3.1`` and ``2.1``. "
"They are used to backport bugfixes and enhancements from the ``master`` "
"branch to the currently maintained stable release (e.g. 3.1.2 or 2.1.6). As "
"a rule of thumb, the last stable branch is maintained until the next minor "
"version (e.g. the ``3.0`` branch was maintained until the release of Godot "
"3.1). If you want to make PRs against a maintained stable branch, please "
"check first if your changes are also relevant for the ``master`` branch, and "
"if so make the PR for the ``master`` branch in priority. Release managers "
"can then cherry-pick the fix to a stable branch if relevant."
msgstr ""
"穩定版分支會以版本命名，例如 ``3.1``、``2.1``。這些分支用來從 ``master`` 分支"
"回補（backport）修正與改進到目前維護的穩定版（如 3.1.2 或 2.1.6）。通常，最後"
"一個穩定分支會維護到下一版釋出（例如 ``3.0`` 會維護到 Godot 3.1 發佈為止）。"
"如果想對穩定分支提出 PR，請先檢查更動是否也適用於 ``master``，若是，請優先對 "
"``master`` 提出 PR。釋出管理員會再視情況將修正 cherry-pick 到穩定分支。"

msgid ""
"There might occasionally be feature branches, usually meant to be merged "
"into the ``master`` branch at some time."
msgstr "有時會有功能性分支，通常最終會合併回 ``master`` 分支。"

msgid "Forking and cloning"
msgstr "Fork 與 Clone"

msgid ""
"The first step is to *fork* the `godotengine/godot <https://github.com/"
"godotengine/godot>`_ repository on GitHub. To do so, you will need to have a "
"GitHub account and to be logged in. In the top right corner of the "
"repository's GitHub page, you should see the \"Fork\" button as shown below:"
msgstr ""
"第一步是在 GitHub 上 *fork* `godotengine/godot <https://github.com/"
"godotengine/godot>`_ 儲存庫。你需要有 GitHub 帳號並登入後，在該儲存庫頁面右上"
"角就能看到「Fork」按鈕："

msgid ""
"Click it, and after a while you should be redirected to your own fork of the "
"Godot repo, with your GitHub username as namespace:"
msgstr ""
"點擊後稍等片刻，你會被導向你自己 fork 的 Godot 儲存庫，命名空間會以你的 "
"GitHub 使用者名稱開頭："

msgid ""
"You can then *clone* your fork, i.e. create a local copy of the online "
"repository (in Git speak, the *origin remote*). If you haven't already, "
"download Git from `its website <https://git-scm.com>`_ if you're using "
"Windows or macOS, or install it through your package manager if you're using "
"Linux."
msgstr ""
"接下來你可以 *clone* 你的 fork，也就是把線上儲存庫複製到本地端（在 Git 裡稱"
"為 *origin remote*）。如果還沒安裝 Git，Windows 或 macOS 請從 `Git 網站 "
"<https://git-scm.com>`_ 下載，Linux 則可用套件管理員安裝。"

msgid ""
"If you are on Windows, open Git Bash to type commands. macOS and Linux users "
"can use their respective terminals."
msgstr "Windows 請使用 Git Bash 輸入指令，macOS 與 Linux 則可用各自的終端機。"

msgid "To clone your fork from GitHub, use the following command:"
msgstr "要從 GitHub clone 你的 fork，請用以下指令："

msgid ""
"After a little while, you should have a ``godot`` directory in your current "
"working directory. Move into it using the ``cd`` command:"
msgstr ""
"過一會兒，在你的目前工作目錄中會出現 ``godot`` 資料夾。請用 ``cd`` 指令切換進"
"去："

msgid ""
"We will start by setting up a reference to the original repository that we "
"forked:"
msgstr "接下來要設定一個指向原始儲存庫的參照："

msgid ""
"This will create a reference named ``upstream`` pointing to the original "
"``godotengine/godot`` repository. This will be useful when you want to pull "
"new commits from its ``master`` branch to update your fork. You have another "
"remote reference named ``origin``, which points to your fork (``USERNAME/"
"godot``)."
msgstr ""
"這樣會建立一個名為 ``upstream`` 的參照，指向原始的 ``godotengine/godot`` 儲存"
"庫。方便之後從 ``upstream`` 的 ``master`` 分支拉取最新 commit 來更新你的 "
"fork。另外還有一個 ``origin`` 參照，指向你自己的 fork（``使用者名稱/"
"godot``）。"

msgid ""
"You only need to do the above steps once, as long as you keep that local "
"``godot`` folder (which you can move around if you want, the relevant "
"metadata is hidden in its ``.git`` subfolder)."
msgstr ""
"只要你保留本機的 ``godot`` 資料夾（可隨意搬動，相關資訊都在 ``.git`` 子資料"
"夾），上述步驟只需做一次。"

msgid ""
"*Branch it, pull it, code it, stage it, commit, push it, rebase it... "
"technologic.*"
msgstr "*建立分支、拉取、撰寫程式碼、暫存、提交、推送、rebase…… 全都是技術。*"

msgid ""
"This bad take on Daft Punk's *Technologic* shows the general conception Git "
"beginners have of its workflow: lots of strange commands to learn by copy "
"and paste, hoping they will work as expected. And that's actually not a bad "
"way to learn, as long as you're curious and don't hesitate to question your "
"search engine when lost, so we will give you the basic commands to know when "
"working in Git."
msgstr ""
"這段改編自 Daft Punk *Technologic* 的歌詞，反映了 Git 初學者對工作流程的常見"
"印象：學一堆陌生指令、複製貼上，希望能正常運作。其實這種學法沒什麼不好，只要"
"你保有好奇心、遇到問題願意查詢，學習效果會很不錯。接下來我們會列出使用 Git 時"
"必備的基本指令。"

msgid ""
"In the following, we will assume as an example that you want to implement a "
"feature in Godot's Project Manager, which is coded in the ``editor/"
"project_manager.cpp`` file."
msgstr ""
"以下我們假設你要在 Godot 的專案管理員中實作新功能，相關程式碼位於 ``editor/"
"project_manager.cpp``。"

msgid "Branching"
msgstr "建立分支"

msgid ""
"By default, the ``git clone`` should have put you on the ``master`` branch "
"of your fork (``origin``). To start your own feature development, we will "
"create a feature branch:"
msgstr ""
"預設情況下，``git clone`` 會讓你在 fork（``origin``）的 ``master`` 分支上。要"
"開始開發新功能時，請另外建立一個功能分支："

msgid "This command is equivalent:"
msgstr "這個指令也有同樣效果："

msgid "If you want to go back to the ``master`` branch, you'd use:"
msgstr "如果要切回 ``master`` 分支，可以這樣做："

msgid ""
"You can see which branch you are currently on with the ``git branch`` "
"command:"
msgstr "可以用 ``git branch`` 指令查看目前所在的分支："

msgid ""
"Be sure to always go back to the ``master`` branch before creating a new "
"branch, as your current branch will be used as the base for the new one. "
"Alternatively, you can specify a custom base branch after the new branch's "
"name:"
msgstr ""
"請務必在建立新分支前先切回 ``master``，因為新分支會以當下分支為基礎。你也可以"
"在新分支名稱後指定基礎分支："

msgid "Updating your branch"
msgstr "更新分支"

msgid ""
"This would not be needed the first time (just after you forked the upstream "
"repository). However, the next time you want to work on something, you will "
"notice that your fork's ``master`` is several commits behind the upstream "
"``master`` branch: pull requests from other contributors would have been "
"merged in the meantime."
msgstr ""
"第一次 fork 完通常不用更新。但之後要再開發時，你會發現自己的 fork ``master`` "
"分支可能已經落後上游 ``master`` 幾個 commit，因為其他貢獻者的 PR 已被合併進去"
"了。"

msgid ""
"To ensure there won't be conflicts between the feature you develop and the "
"current upstream ``master`` branch, you will have to update your branch by "
"*pulling* the upstream branch."
msgstr ""
"為避免你開發的功能與最新 upstream ``master`` 分支衝突，需要從 upstream 拉取"
"（pull）最新內容來更新分支。"

msgid ""
"The ``--rebase`` argument will ensure that any local changes that you "
"committed will be re-applied *on top* of the pulled branch, which is usually "
"what we want in our PR workflow. This way, when you open a pull request, "
"your own commits will be the only difference with the upstream ``master`` "
"branch."
msgstr ""
"加上 ``--rebase`` 參數，會讓你的本地 commit 被「套用在」拉下來的 upstream 分"
"支最前面，這是 PR 工作流程中推薦的做法。如此一來，開 PR 時，你的 commit 就會"
"是跟 upstream ``master`` 唯一的差異。"

msgid ""
"While rebasing, conflicts may arise if your commits modified code that has "
"been changed in the upstream branch in the meantime. If that happens, Git "
"will stop at the conflicting commit and will ask you to resolve the "
"conflicts. You can do so with any text editor, then stage the changes (more "
"on that later), and proceed with ``git rebase --continue``. Repeat the "
"operation if later commits have conflicts too, until the rebase operation "
"completes."
msgstr ""
"進行 rebase 時，如果你的 commit 修改到和 upstream 分支相同的程式碼，可能會發"
"生衝突。這時 Git 會在有衝突的 commit 停下來，要求你解決衝突。你可以用任何文字"
"編輯器解決，然後將更動暫存（stage），再執行 ``git rebase --continue``。如果後"
"續 commit 也有衝突，請重複此步驟，直到 rebase 結束。"

msgid ""
"If you're unsure about what is going on during a rebase and you panic (no "
"worry, we all do the first few times), you can abort the rebase with ``git "
"rebase --abort``. You will then be back to the original state of your branch "
"before calling ``git pull --rebase``."
msgstr ""
"如果 rebase 過程讓你慌張（別擔心，大家第一次都會），可以用 ``git rebase --"
"abort`` 中止 rebase，這樣會回到執行 ``git pull --rebase`` 之前的狀態。"

msgid ""
"If you omit the ``--rebase`` argument, you will instead create a merge "
"commit which tells Git what to make of the two distinct branches. If any "
"conflicts arise, they would be resolved all at once via this merge commit."
msgstr ""
"如果沒加 ``--rebase``，會產生一個 merge commit，告訴 Git 如何合併這兩個分支。"
"如果有衝突，這個 merge commit 會一次處理所有衝突。"

msgid ""
"While this is a valid workflow and the default behavior of ``git pull``, "
"merge commits within PRs are frowned upon in our PR workflow. We only use "
"them when merging PRs into the upstream branch."
msgstr ""
"雖然這是個可行的流程，也是 ``git pull`` 的預設行為，但我們的 PR 流程不建議在 "
"PR 裡產生 merge commit。我們只會在將 PR 合併回 upstream 時才使用 merge "
"commit。"

msgid ""
"The philosophy is that a PR should represent the final stage of the changes "
"made to the codebase, and we are not interested in mistakes and fixes that "
"would have been done in intermediate stages before merging. Git gives us "
"great tools to \"rewrite the history\" and make it as if we got things right "
"the first time, and we're happy to use it to ensure that changes are easy to "
"review and understand long after they have been merged."
msgstr ""
"這麼做的理念是，PR 應該代表對程式碼最終的變更狀態，我們不需要看到合併前那些中"
"間修正與錯誤。Git 提供了優秀的「重寫歷史」工具，讓我們能讓歷史看起來一開始就"
"正確。這有助於讓更動在合併後很久都能容易審查與理解。"

msgid ""
"If you have already created a merge commit without using ``rebase``, or have "
"made any other changes that have resulted in undesired history, the best "
"option is to use an *interactive rebase* on the upstream branch. See "
"the :ref:`dedicated section <doc_pr_workflow_rebase>` for instructions."
msgstr ""
"如果你沒用 ``rebase``，已經產生 merge commit，或造成了不理想的歷史紀錄，最好"
"的辦法是對 upstream 分支進行 *互動式 rebase*。詳細步驟請見 :ref:`專章 "
"<doc_pr_workflow_rebase>`。"

msgid ""
"If at any time you want to *reset* a local branch to a given commit or "
"branch, you can do so with ``git reset --hard <commit ID>`` or ``git reset --"
"hard <remote>/<branch>`` (e.g. ``git reset --hard upstream/master``)."
msgstr ""
"任何時候想要 *重設* 本地分支到某個 commit 或分支，可以用 ``git reset --hard "
"<commit ID>`` 或 ``git reset --hard <remote>/<branch>``（例如 ``git reset --"
"hard upstream/master``）。"

msgid ""
"Be warned that this will remove any changes that you might have committed in "
"this branch. If you ever lose commits by mistake, use the ``git reflog`` "
"command to find the commit ID of the previous state that you would like to "
"restore, and use it as argument of ``git reset --hard`` to go back to that "
"state."
msgstr ""
"注意，這麼做會移除目前分支上所有已提交的更改。如果不小心丟失 commit，可以用 "
"``git reflog`` 找回想要還原的 commit ID，再用 ``git reset --hard`` 回到那個狀"
"態。"

msgid "Making changes"
msgstr "進行修改"

msgid ""
"You would then do your changes to our example's ``editor/"
"project_manager.cpp`` file with your usual development environment (text "
"editor, IDE, etc.)."
msgstr ""
"你可以用自己慣用的開發環境（文字編輯器、IDE 等）來修改 ``editor/"
"project_manager.cpp`` 這個檔案。"

msgid ""
"By default, those changes are *unstaged*. The staging area is a layer "
"between your working directory (where you make your modifications) and the "
"local Git repository (the commits and all the metadata in the ``.git`` "
"folder). To bring changes from the working directory to the Git repository, "
"you need to *stage* them with the ``git add`` command, and then to commit "
"them with the ``git commit`` command."
msgstr ""
"預設情況下，這些修改處於「未暫存（unstaged）」狀態。暫存區（staging area）就"
"是介於你工作目錄（你編輯的地方）和本地 Git 儲存庫（所有 commit 與 .git 資料"
"夾）之間的中介。要把更改從工作目錄帶進 Git 儲存庫，必須先用 ``git add`` 暫"
"存，再用 ``git commit`` 提交。"

msgid ""
"There are various commands you should know to review your current work, "
"before staging it, while it is staged, and after it has been committed."
msgstr ""
"你應該認識幾個常用指令，來檢查目前的修改狀態：無論是暫存前、暫存時，還是已提"
"交之後。"

msgid ""
"``git diff`` will show you the current unstaged changes, i.e. the "
"differences between your working directory and the staging area."
msgstr ""
"``git diff`` 會顯示目前未暫存（unstaged）的更動，也就是工作目錄與暫存區之間的"
"差異。"

msgid ""
"``git checkout -- <files>`` will undo the unstaged changes to the given "
"files."
msgstr "``git checkout -- <檔案>`` 可以還原指定檔案的未暫存更改。"

msgid "``git add <files>`` will *stage* the changes on the listed files."
msgstr "``git add <檔案>`` 會將所列檔案的更改「暫存」（stage）。"

msgid ""
"``git diff --staged`` will show the current staged changes, i.e. the "
"differences between the staging area and the last commit."
msgstr ""
"``git diff --staged`` 會顯示已暫存的內容，也就是暫存區與上一次 commit 間的差"
"異。"

msgid "``git reset HEAD <files>`` will *unstage* changes to the listed files."
msgstr "``git reset HEAD <檔案>`` 會將所列檔案的內容「取消暫存」（unstage）。"

msgid ""
"``git status`` will show you what are the currently staged and unstaged "
"modifications."
msgstr "``git status`` 會顯示目前有哪些已暫存、哪些未暫存的修改。"

msgid ""
"``git commit`` will commit the staged files. It will open a text editor (you "
"can define the one you want to use with the ``GIT_EDITOR`` environment "
"variable or the ``core.editor`` setting in your Git configuration) to let "
"you write a commit log. You can use ``git commit -m \"Cool commit log\"`` to "
"write the log directly."
msgstr ""
"``git commit`` 會將已暫存的檔案提交（commit）。預設會開啟文字編輯器（可用 "
"``GIT_EDITOR`` 環境變數或 Git 設定中的 ``core.editor`` 指定），讓你撰寫 "
"commit 訊息。也可以直接用 ``git commit -m \"你的 commit 訊息\"``。"

msgid ""
"``git commit --amend`` lets you amend the last commit with your currently "
"staged changes (added with ``git add``). This is the best option if you want "
"to fix a mistake in the last commit (bug, typo, style issue, etc.)."
msgstr ""
"``git commit --amend`` 會將目前暫存的內容（用 ``git add`` 加入的）修正到上一"
"個 commit。想修正上一個 commit 的錯誤（bug、錯字、格式問題等）時很實用。"

msgid ""
"``git log`` will show you the last commits of your current branch. If you "
"did local commits, they should be shown at the top."
msgstr ""
"``git log`` 會顯示目前分支的 commit 記錄。你剛做的本地 commit 應該會在最上"
"方。"

msgid ""
"``git show`` will show you the changes of the last commit. You can also "
"specify a commit hash to see the changes for that commit."
msgstr ""
"``git show`` 會顯示最新 commit 的內容，也可以指定 commit 雜湊值來查看特定 "
"commit 的變更。"

msgid ""
"That's a lot to memorize! Don't worry, just check this cheat sheet when you "
"need to make changes, and learn by doing."
msgstr "這資訊有點多！別擔心，改動時查這張小抄就好，邊做邊學最有效。"

msgid "Here's how the shell history could look like on our example:"
msgstr "在這個範例中，shell 的操作歷史可能像這樣："

msgid ""
"With this, we should have two new commits in our ``better-project-manager`` "
"branch which were not in the ``master`` branch. They are still only local "
"though, the remote fork does not know about them, nor does the upstream repo."
msgstr ""
"這樣下來，我們會在 ``better-project-manager`` 分支上有兩個新的 commit，這些 "
"commit 不會出現在 ``master`` 分支。注意，目前這些 commit 只在本地，遠端 fork "
"與 upstream 都還不知道。"

msgid "Pushing changes to a remote"
msgstr "推送（push）更動到遠端"

msgid ""
"That's where ``git push`` will come into play. In Git, a commit is always "
"done in the local repository (unlike Subversion where a commit will modify "
"the remote repository directly). You need to *push* the new commits to a "
"remote branch to share them with the world. The syntax for this is:"
msgstr ""
"這時候就要用 ``git push`` 了。在 Git 裡，所有 commit 都是先在本地完成（不像 "
"Subversion 會直接改遠端）。你需要 *push* 這些 commit 到遠端分支，讓大家都能看"
"到。語法如下："

msgid ""
"The part about the remote branch can be omitted if you want it to have the "
"same name as the local branch, which is our case in this example, so we will "
"do:"
msgstr ""
"如果遠端分支名稱跟本機分支相同，可以省略不寫。在這個例子就是如此，因此我們會"
"這樣做："

msgid ""
"Git will ask you for your username and password. For your password, enter "
"your GitHub Personal Access Token (PAT). If you do not have a GitHub "
"Personal Access Token, or do not have one with the correct permissions for "
"your newly forked repository, you will need to create one. Follow this link "
"to create your Personal Access Token: `Creating a personal access token "
"<https://docs.github.com/en/authentication/keeping-your-account-and-data-"
"secure/creating-a-personal-access-token>`_."
msgstr ""
"Git 會要求你輸入帳號密碼。密碼請填入你的 GitHub 個人存取權杖（PAT）。如果還沒"
"有 PAT，或沒有正確權限，需要先建立一個。請參考這個連結：`建立個人存取權杖 "
"<https://docs.github.com/en/authentication/keeping-your-account-and-data-"
"secure/creating-a-personal-access-token>`_。"

msgid ""
"After you have successfully verified your account using your PAT, the "
"changes will be sent to your remote repository. If you check the fork's page "
"on GitHub, you should see a new branch with your added commits."
msgstr ""
"帳號驗證成功後，修改內容就會被推送到你的遠端儲存庫。在 GitHub 上查看你的 "
"fork，可以看到剛剛 push 上去的新分支與 commit。"

msgid "Issuing a pull request"
msgstr "建立 Pull Request"

msgid ""
"When you load your fork's branch on GitHub, you should see a line saying "
"*\"This branch is 2 commits ahead of godotengine:master.\"* (and potentially "
"some commits behind, if your ``master`` branch was out of sync with the "
"upstream ``master`` branch)."
msgstr ""
"在 GitHub 上瀏覽 fork 的分支時，會看到一句話：「This branch is 2 commits "
"ahead of godotengine:master.」（如果 ``master`` 分支沒和 upstream 同步，這個"
"數字可能會更多）。"

msgid ""
"On that line, there is a \"Pull request\" link. Clicking it will open a form "
"that will let you issue a pull request on the ``godotengine/godot`` upstream "
"repository. It should show you your two commits, and state \"Able to "
"merge\". If not (e.g. it has way more commits, or says there are merge "
"conflicts), don't create the PR yet, something went wrong. Go to our `Godot "
"Contributors Chat <https://chat.godotengine.org/>`_ and ask for support :)"
msgstr ""
"在那行旁邊會有「Pull request」連結。點下去會打開表單，讓你對 ``godotengine/"
"godot`` 上游儲存庫建立 PR。這裡應該會顯示你的兩個 commit，並標示「Able to "
"merge」。如果不是（例如 commit 太多、或有 merge 衝突），請先不要發 PR，這代表"
"有地方出錯。可以到 `Godot 貢獻者聊天室 <https://chat.godotengine.org/>`_ 尋求"
"協助 :)"

msgid ""
"Use an explicit title for the PR and put the necessary details in the "
"comment area. You can drag and drop screenshots, GIFs or zipped projects if "
"relevant, to showcase what your work implements. Click \"Create a pull "
"request\", and tadaa!"
msgstr ""
"請為 PR 加上明確標題，並在留言區填寫必要細節。有需要可以拖曳截圖、GIF 或壓縮"
"專案檔案，展示你的實作內容。點下「Create a pull request」，就完成了！"

msgid "Modifying a pull request"
msgstr "修改 Pull Request"

msgid ""
"While it is reviewed by other contributors, you will often need to make "
"changes to your yet-unmerged PR, either because contributors requested them, "
"or because you found issues yourself while testing."
msgstr ""
"在其他貢獻者審查 PR 期間，你常常會需要修改尚未合併的 PR，可能是因為審查者要"
"求，也可能是自己測試時發現有問題。"

msgid ""
"The good news is that you can modify a pull request simply by acting on the "
"branch you made the pull request from. You can e.g. make a new commit on "
"that branch, push it to your fork, and the PR will be updated automatically:"
msgstr ""
"好消息是，你只要在發 PR 用的分支繼續修改即可。你可以在該分支 commit 新內容，"
"push 到 fork，PR 就會自動跟著更新："

msgid ""
"However, be aware that in our PR workflow, we favor commits that bring the "
"codebase from one functional state to another functional state, without "
"having intermediate commits fixing up bugs in your own code or style issues. "
"Most of the time, we will prefer a single commit in a given PR (unless "
"there's a good reason to keep the changes separate). Instead of authoring a "
"new commit, consider using ``git commit --amend`` to amend the previous "
"commit with your fixes. The above example would then become:"
msgstr ""
"不過請注意，我們的 PR 流程偏好讓整體程式碼從一個功能狀態直接躍遷到另一個功能"
"狀態的 commit，中間不應有修正自己 bug 或樣式問題的中間 commit。大多數情況下，"
"我們希望一個 PR 只包含一個 commit（除非有很好的理由分開）。因此，與其建立新 "
"commit，不如用 ``git commit --amend`` 把修正合併到前一個 commit。例如前面的範"
"例可以改成："

msgid "The interactive rebase"
msgstr "互動式 rebase"

msgid ""
"If you didn't follow the above steps closely to *amend* changes into a "
"commit instead of creating fixup commits, or if you authored your changes "
"without being aware of our workflow and Git usage tips, reviewers might "
"request you to *rebase* your branch to *squash* some or all of the commits "
"into one."
msgstr ""
"如果你沒有遵照前述方式把修正內容 *amend* 到原本的 commit，而是產生了多個修正 "
"commit，或一開始不清楚我們的工作流程與 Git 習慣，審查者可能會請你 *rebase* 分"
"支，把部分或全部 commit *squash* （壓縮合併）成一個。"

msgid ""
"Indeed, if some commits have been made following reviews to fix bugs, typos, "
"etc. in the original commit, they are not relevant to a future changelog "
"reader who would want to know what happened in the Godot codebase, or when "
"and how a given file was last modified."
msgstr ""
"畢竟，有些 commit 是審查後用來修正 bug、錯字等，這些內容對未來讀 changelog 想"
"追蹤 Godot 原始碼狀態或某檔案變動時，其實沒有意義。"

msgid ""
"To squash those extraneous commits into the main one, we will have to "
"*rewrite history*. Right, we have that power. You may read that it's a bad "
"practice, and it's true when it comes to branches of the upstream repo. But "
"in your fork, you can do whatever you want, and everything is allowed to get "
"neat PRs :)"
msgstr ""
"要把這些多餘的 commit 壓進主 commit，就得 *重寫歷史*。沒錯，我們有這個能力。"
"你或許聽過這麼做不是好習慣，這點在 upstream repo 分支上確實如此，但在你自己"
"的 fork 裡，為了乾淨的 PR，怎麼做都可以 :)"

msgid ""
"We will use the *interactive rebase* ``git rebase -i`` to do this. This "
"command takes a commit ID or a branch name as argument, and will let you "
"modify all commits between that commit/branch and the last one in your "
"working branch, the so-called ``HEAD``."
msgstr ""
"我們會用 *互動式 rebase* （ ``git rebase -i`` ）來處理。這個指令以 commit ID "
"或分支名稱為參數，讓你能修改從該點到你目前分支最新 commit（HEAD）之間的所有 "
"commit。"

msgid ""
"While you can give any commit ID to ``git rebase -i`` and review everything "
"in between, the most common and convenient workflow involves rebasing on the "
"upstream ``master`` branch, which you can do with:"
msgstr ""
"雖然你可以給 ``git rebase -i`` 任意 commit ID 來檢查所有 commit，但最常見、最"
"方便的做法是以 upstream ``master`` 分支為基礎做 rebase，指令如下："

msgid ""
"Referencing branches in Git is a bit tricky due to the distinction between "
"remote and local branches. Here, ``upstream/master`` (with a `/`) is a local "
"branch which has been pulled from the ``upstream`` remote's ``master`` "
"branch."
msgstr ""
"在 Git 裡參照分支時要注意區分本地與遠端分支。這裡的 ``upstream/master`` （有 "
"`/`）是指從遠端 upstream 的 master 分支拉下來的本地分支。"

msgid ""
"Interactive rebases can only be done on local branches, so the `/` is "
"important here. As the upstream remote changes frequently, your local "
"``upstream/master`` branch may become outdated, so you can update it with "
"``git fetch upstream master``. Contrarily to ``git pull --rebase upstream "
"master`` which would update your currently checked out branch, ``fetch`` "
"will only update the ``upstream/master`` reference (which is distinct from "
"your local ``master`` branch... yes it's confusing, but you'll become "
"familiar with this little by little)."
msgstr ""
"互動式 rebase 只能在本地分支操作，所以這裡的 `/` 很重要。由於 upstream 常常有"
"變動，你本地的 ``upstream/master`` 可能會過時，可以用 ``git fetch upstream "
"master`` 來更新。``git pull --rebase upstream master`` 會拉到你目前簽出的分"
"支，而 ``fetch`` 只會更新 ``upstream/master`` 這個參照（和你自己的 "
"``master`` 分支不同……雖然一開始很混亂，但慢慢就會上手）。"

msgid ""
"This will open a text editor (``vi`` by default, see `Git docs <https://git-"
"scm.com/book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`_ to "
"configure your favorite one) with something which may look like this:"
msgstr ""
"這會開啟一個文字編輯器（預設是 ``vi``，參見 `Git docs <https://git-scm.com/"
"book/en/v2/Customizing-Git-Git-Configuration#_core_editor>`_ 設定你喜歡的編輯"
"器），內容大致如下："

msgid ""
"The editor will also show instructions regarding how you can act on those "
"commits. In particular, it should tell you that \"pick\" means to use that "
"commit (do nothing), and that \"squash\" and \"fixup\" can be used to *meld* "
"the commit in its parent commit. The difference between \"squash\" and "
"\"fixup\" is that \"fixup\" will discard the commit log from the squashed "
"commit. In our example, we are not interested in keeping the log of the "
"\"Fix a typo\" commit, so we use:"
msgstr ""
"編輯器同時會顯示可用的指令說明。簡單來說，「pick」表示直接使用該 commit（不變"
"動），「squash」和「fixup」可以把 commit *合併* 到上一個 commit。差別是"
"「fixup」會直接丟掉被合併 commit 的訊息。在例子中，「Fix a typo」的 commit "
"log 不需保留，所以我們會這樣寫："

msgid ""
"Upon saving and quitting the editor, the rebase will occur. The second "
"commit will be melded into the first one, and ``git log`` and ``git show`` "
"should now confirm that you have only one commit with the changes from both "
"previous commits."
msgstr ""
"儲存並離開編輯器後，rebase 會開始。第二個 commit 會被合併進第一個，這時用 "
"``git log`` 或 ``git show`` 就能看到這兩次更動已經合而為一。"

msgid ""
"But! You rewrote the history, and now your local and remote branches have "
"diverged. Indeed, commit 1b4aad7 in the above example will have changed, and "
"therefore got a new commit hash. If you try to push to your remote branch, "
"it will raise an error:"
msgstr ""
"不過！你剛剛已經重寫了歷史，所以本地和遠端分支會出現分歧。例如上例中的 "
"1b4aad7 commit 內容已經變了、hash 也不同。如果你此時嘗試 push，會出現錯誤："

msgid ""
"This is reasonable behavior, Git will not let you push changes that would "
"override remote content. But that's actually what we want to do here, so we "
"will have to *force* it:"
msgstr ""
"這是正常現象，Git 不會讓你直接覆蓋遠端內容。但這次我們就是要強制這麼做，所以"
"要用 *force push*："

msgid ""
"And tadaa! Git will happily *replace* your remote branch with what you had "
"locally (so make sure that's what you wanted, using ``git log``). This will "
"also update the PR accordingly."
msgstr ""
"完成！Git 會用你本地的分支 *取代* 遠端分支（請先用 ``git log`` 確認內容正"
"確）。這樣 PR 也會自動更新。"

msgid "Rebasing onto another branch"
msgstr "將變更 rebase 到其他分支"

msgid ""
"If you have accidentally opened your PR on the wrong branch, or need to "
"target another branch for some reason, you might need to filter out a lot of "
"commits that differ between the old branch (for example ``4.2``) and the new "
"branch (for example ``master``). This can make rebasing difficult and "
"tedious. Fortunately ``git`` has a command just for this situation, ``git "
"rebase --onto``."
msgstr ""
"如果你不小心在錯誤的分支上發了 PR，或因某些原因需要更換目標分支，可能必須篩掉"
"舊分支（如 ``4.2``）與新分支（如 ``master``）之間的許多 commit。這會讓 "
"rebase 變得困難又繁瑣。幸好 Git 有專為這種情境設計的 ``git rebase --onto`` 指"
"令。"

msgid ""
"If your PR was created from the ``4.2`` branch and you want to update it to "
"instead start at ``master`` the following steps *should* fix this in one "
"step:"
msgstr ""
"假設你的 PR 是從 ``4.2`` 分支建立，而你想要改從 ``master`` 開始，只要依下列步"
"驟操作，*應該* 就能一次完成："

msgid ""
"This will take all the commits on your branch *after* the ``4.2`` branch, "
"and then splice them on top of ``master``, ignoring any commits from the "
"``4.2`` branch not on the ``master`` branch. You may still need to do some "
"fixing, but this command should save you a lot of tedious work removing "
"commits."
msgstr ""
"這會把你分支上「在 ``4.2`` 之後」的所有 commit，直接接到 ``master`` 上，並忽"
"略 ``4.2`` 分支上不屬於 ``master`` 的 commit。雖然可能還需要手動修正，但這個"
"指令能省下大量移除 commit 的繁瑣工夫。"

msgid ""
"Just like above for the interactive rebase you need to force push your "
"branch to handle the different changes:"
msgstr "跟前面互動式 rebase 一樣，這時你也需要強制 push 分支才能處理這些不同："

msgid "Deleting a Git branch"
msgstr "刪除 Git 分支"

msgid ""
"After your pull request gets merged, there's one last thing you should do: "
"delete your Git branch for the PR. There won't be issues if you don't delete "
"your branch, but it's good practice to do so. You'll need to do this twice, "
"once for the local branch and another for the remote branch on GitHub."
msgstr ""
"當你的 PR 被合併後，最後還有一件事：把這個 PR 用過的 Git 分支刪掉。不刪不會出"
"問題，但養成刪除分支的習慣很好。你需要做兩次：一次是本地分支，一次是 GitHub "
"遠端分支。"

msgid "To delete our better Project Manager branch locally, use this command:"
msgstr "要在本機刪除我們的 better Project Manager 分支，請用這個指令："

msgid ""
"Alternatively, if the branch hadn't been merged yet and we wanted to delete "
"it anyway, instead of ``-d`` you would use ``-D``."
msgstr "若該分支還沒合併但你仍想刪除，請將 ``-d`` 換成 ``-D``。"

msgid "Next, to delete the remote branch on GitHub use this command:"
msgstr "接著，若要刪除 GitHub 上的遠端分支，請用這個指令："

msgid ""
"You can also delete the remote branch from the GitHub PR itself, a button "
"should appear once it has been merged or closed."
msgstr ""
"你也可以直接在 GitHub PR 頁面刪除遠端分支，當 PR 合併或關閉後應該會出現相關按"
"鈕。"
