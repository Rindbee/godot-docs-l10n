#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using NavigationPaths"
msgstr "使用 NavigationPaths"

msgid "Obtaining a NavigationPath"
msgstr "取得導覽路徑"

msgid ""
"Navigation paths can be directly queried from the NavigationServer and do "
"not require any additional nodes or objects as long as the navigation map "
"has a navigation mesh to work with."
msgstr ""
"只要導覽地圖已有可用的導覽網格，導覽路徑就能直接從 NavigationServer 查詢，不"
"需額外新增任何節點或物件。"

msgid ""
"To obtain a 2D path, use ``NavigationServer2D.map_get_path(map, from, to, "
"optimize, navigation_layers)``."
msgstr ""
"若要取得 2D 路徑，請使用 ``NavigationServer2D.map_get_path(map, from, to, "
"optimize, navigation_layers)``。"

msgid ""
"To obtain a 3D path, use ``NavigationServer3D.map_get_path(map, from, to, "
"optimize, navigation_layers)``."
msgstr ""
"若要取得 3D 路徑，請使用 ``NavigationServer3D.map_get_path(map, from, to, "
"optimize, navigation_layers)``。"

msgid ""
"For more customizable navigation path queries that require additional setup "
"see :ref:`doc_navigation_using_navigationpathqueryobjects`."
msgstr ""
"如需進行更多自訂化，並需額外設定的導覽路徑查詢，請參"
"考 :ref:`doc_navigation_using_navigationpathqueryobjects`。"

msgid ""
"One of the required parameters for the query is the RID of the navigation "
"map. Each game world has a default navigation map automatically created. The "
"default navigation maps can be retrieved with "
"``get_world_2d().get_navigation_map()`` from any Node2D inheriting node or "
"``get_world_3d().get_navigation_map()`` from any Node3D inheriting node. The "
"second and third parameters are the starting position and the target "
"position as Vector2 for 2D or Vector3 for 3D."
msgstr ""
"查詢時需提供導覽地圖的 RID。每個遊戲世界都會自動建立一個預設導覽地圖。在任何"
"繼承自 Node2D 的節點上，可使用 ``get_world_2d().get_navigation_map()`` 取得 "
"2D 導覽地圖；在任何繼承自 Node3D 的節點上，則可用 "
"``get_world_3d().get_navigation_map()`` 取得 3D 導覽地圖。第二與第三個參數分"
"別為起點與目標位置，2D 使用 Vector2，3D 則為 Vector3。"

msgid ""
"If the ``optimized`` parameter is ``true``, path positions will be shortened "
"along polygon corners with an additional funnel algorithm pass. This works "
"well for free movement on navigation meshes with unequally sized polygons as "
"the path will hug around corners along the polygon corridor found by the A* "
"algorithm. With small cells the A* algorithm creates a very narrow funnel "
"corridor that can create ugly corner paths when used with grids."
msgstr ""
"若 ``optimized`` 參數為 ``true``，則會額外經過漏斗演算法處理，使路徑點順著多"
"邊形角落縮短。這對於多邊形大小不一的導覽網格，且需自由移動時效果良好，因為路"
"徑會沿著 A* 演算法找到的多邊形通道貼近轉角。但若格網很小時，A* 可能產生非常狹"
"窄的漏斗型通道，會導致在格狀網格上出現不自然的轉角路徑。"

msgid ""
"If the ``optimized`` parameter is ``false``, path positions will be placed "
"at the center of each polygon edge. This works well for pure grid movement "
"on navigation meshes with equally sized polygons as the path will go through "
"the center of the grid cells. Outside of grids due to polygons often "
"covering large open areas with a single, long edge this can create paths "
"with unnecessary long detours."
msgstr ""
"若 ``optimized`` 參數為 ``false``，路徑點則會落在每個多邊形邊的中心。這適合用"
"於多邊形大小一致、以格子移動為主的導覽網格，因為路徑會穿越格子中心。若在非格"
"子狀網格上，因多邊形常以單一長邊覆蓋大片開放區域，路徑可能會出現不必要的冗長"
"繞路。"

msgid ""
"A returned ``path`` by the NavigationServer will be a ``PackedVector2Array`` "
"for 2D or a ``PackedVector3Array`` for 3D. These are just a memory-optimized "
"``Array`` of vector positions. All position vectors inside the array are "
"guaranteed to be inside a NavigationPolygon or NavigationMesh. The path "
"array, if not empty, has the navigation mesh position closest to the "
"starting position at the first index ``path[0]`` position. The closest "
"available navigation mesh position to the target position is the last index "
"``path[path.size()-1]`` position. All indexes between are the path points "
"that an actor should follow to reach the target without leaving the "
"navigation mesh."
msgstr ""
"NavigationServer 回傳的 ``path`` 會是 2D 的 ``PackedVector2Array`` 或 3D 的 "
"``PackedVector3Array``，皆為記憶體優化的向量陣列。陣列中所有位置向量都保證位"
"於 NavigationPolygon 或 NavigationMesh 內。若路徑陣列非空，第一個索引 "
"``path[0]`` 會是離起點最近的網格位置，最後一個索引 ``path[path.size()-1]`` 則"
"為距目標最近的可用網格位置。中間的索引則是角色在不離開導覽網格情況下，應依序"
"通過的路徑點。"

msgid ""
"If the target position is on a different navigation mesh that is not merged "
"or connected the navigation path will lead to the closest possible position "
"on the starting position navigation mesh."
msgstr ""
"若目標位置位於未合併或未連接的不同導覽網格，則導覽路徑會引導到起點所屬網格"
"中，距離目標位置最近的可達點。"

msgid ""
"The following script moves a Node3D inheriting node along a navigation path "
"using the default navigation map by setting the target position with "
"``set_movement_target()``."
msgstr ""
"以下程式碼範例說明如何在 Node3D 繼承節點中，透過 ``set_movement_target()`` 設"
"定目標位置，並利用預設導覽地圖讓節點沿著導覽路徑移動。"
