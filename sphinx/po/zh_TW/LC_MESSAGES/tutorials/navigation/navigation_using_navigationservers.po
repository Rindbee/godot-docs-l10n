#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using NavigationServer"
msgstr "使用 NavigationServer"

msgid ""
"2D and 3D version of the NavigationServer are available "
"as :ref:`NavigationServer2D<class_NavigationServer2D>` "
"and :ref:`NavigationServer3D<class_NavigationServer3D>` respectively."
msgstr ""
"NavigationServer 提供了 2D 和 3D 兩個版本，分別"
"為 :ref:`NavigationServer2D<class_NavigationServer2D>` "
"與 :ref:`NavigationServer3D<class_NavigationServer3D>`。"

msgid ""
"Both 2D and 3D use the same NavigationServer with NavigationServer3D being "
"the primary server. The NavigationServer2D is a frontend that converts 2D "
"positions into 3D positions and back. Hence it is entirely possible (if not "
"a little cumbersome) to exclusively use the NavigationServer3D API for 2D "
"navigation."
msgstr ""
"2D 與 3D 實際上共用同一個 NavigationServer，其中以 NavigationServer3D 為主要"
"伺服器。NavigationServer2D 是一個前端，它負責將 2D 位置轉換為 3D 位置再轉回"
"來。因此，完全可以（只是有點麻煩）只使用 NavigationServer3D API 來實作 2D 導"
"覽。"

msgid "Communicating with the NavigationServer"
msgstr "與 NavigationServer 溝通"

msgid ""
"To work with the NavigationServer means to prepare parameters for a "
"**query** that can be sent to the NavigationServer for updates or requesting "
"data."
msgstr ""
"要與 NavigationServer 互動，必須先準備好查詢（**query**）的參數，這些查詢可以"
"發送給 NavigationServer 以進行更新或取得資料。"

msgid ""
"To reference the internal NavigationServer objects like maps, regions and "
"agents RIDs are used as identification numbers. Every navigation related "
"node in the scene tree has a function that returns the RID for this node."
msgstr ""
"導覽伺服器內部的地圖、區域與代理等物件，都是用 RID 作為識別碼來引用。場景樹中"
"每個與導覽相關的節點都提供一個可取得該節點 RID 的函式。"

msgid "Threading and Synchronization"
msgstr "執行緒與同步"

msgid ""
"The NavigationServer does not update every change immediately but waits "
"until the end of the **physics frame** to synchronize all the changes "
"together."
msgstr ""
"NavigationServer 並不會立即套用每一次的變更，而是等到**物理影格（physics "
"frame）**結束時再一次同步所有的更動。"

msgid ""
"Waiting for synchronization is required to apply changes to all maps, "
"regions and agents. Synchronization is done because some updates like a "
"recalculation of the entire navigation map are very expensive and require "
"updated data from all other objects. Also the NavigationServer uses a "
"**threadpool** by default for some functionality like avoidance calculation "
"between agents."
msgstr ""
"所有對地圖、區域與代理的變更都必須經過同步後才會生效。進行同步是因為某些更新"
"（如重新計算整張導覽地圖）非常耗費資源，也需要其他物件的最新資料。此外，"
"NavigationServer 某些功能（如代理之間的避障計算）預設會使用**執行緒池"
"（threadpool）**來處理。"

msgid ""
"Waiting is not required for most ``get()`` functions that only request data "
"from the NavigationServer without making changes. Note that not all data "
"will account for changes made in the same frame. E.g. if an avoidance agent "
"changed the navigation map this frame the ``agent_get_map()`` function will "
"still return the old map before the synchronization. The exception to this "
"are nodes that store their values internally before sending the update to "
"the NavigationServer. When a getter on a node is used for a value that was "
"updated in the same frame it will return the already updated value stored on "
"the node."
msgstr ""
"大多數僅用於取得資料、不會進行更動的 ``get()`` 函式，都不需要等待同步。但請注"
"意，這些資料不一定會反映同一影格內做出的變更。例如，如果一個避障代理在這一影"
"格修改了導覽地圖，那麼 ``agent_get_map()`` 在同步前仍會回傳舊地圖。例外情況"
"是：有些節點會在送出更新給 NavigationServer 前，先在內部暫存資料，這種情況"
"下，若在同一影格內用 getter 取得該值，就會拿到已被更新的內容。"

msgid ""
"The NavigationServer is **thread-safe** as it places all API calls that want "
"to make changes in a queue to be executed in the synchronization phase. "
"Synchronization for the NavigationServer happens in the middle of the "
"physics frame after scene input from scripts and nodes are all done."
msgstr ""
"NavigationServer 具備**執行緒安全性（thread-safe）**，因為所有會產生變更的 "
"API 呼叫都會放進佇列，等同步階段時再一起執行。導覽伺服器的同步會在物理影格"
"內、所有腳本與節點場景輸入都處理完之後進行。"

msgid ""
"The important takeaway is that most NavigationServer changes take effect "
"after the next physics frame and not immediately. This includes all changes "
"made by navigation related nodes in the scene tree or through scripts."
msgstr ""
"重點是：大多數對 NavigationServer 的變更都要等到下一個物理影格後才會生效，而"
"不是馬上見效。這包含在場景樹導覽相關節點或腳本中做的所有變動。"

msgid "All setters and delete functions require synchronization."
msgstr "所有 setter 與刪除類型的函式都需要同步後才會生效。"

msgid "2D and 3D NavigationServer differences"
msgstr "2D 與 3D NavigationServer 的差異"

msgid ""
"NavigationServer2D and NavigationServer3D are equivalent in functionality "
"for their dimension and both use the same NavigationServer behind the scene."
msgstr ""
"NavigationServer2D 與 NavigationServer3D 在各自維度的功能是等價的，且底層都共"
"用同一個 NavigationServer。"

msgid ""
"Strictly technical a NavigationServer2D is a myth. The NavigationServer2D is "
"a frontend to facilitate conversions of ``Vector2(x, y)`` to ``Vector3(x, "
"0.0, z)`` and back for the NavigationServer3D API. 2D uses a flat 3D mesh "
"pathfinding and the NavigationServer2D facilitates the conversions. When a "
"guide uses just NavigationServer without the 2D or 3D suffix it usually "
"works for both servers by exchange ``Vector2(x, y)`` with ``Vector3(x, 0.0, "
"z)`` or reverse."
msgstr ""
"嚴格來說，NavigationServer2D 其實只是個前端介面。它的作用是把 ``Vector2(x, "
"y)`` 和 ``Vector3(x, 0.0, z)`` 互相轉換，以便調用 NavigationServer3D 的 API。"
"2D 的導覽路徑規劃其實是基於平面的 3D 網格，NavigationServer2D 只負責轉換座"
"標。當說明文件只提 NavigationServer 而沒加 2D 或 3D 字尾時，通常表示你只需把 "
"``Vector2(x, y)`` 跟 ``Vector3(x, 0.0, z)`` 互換即可。"

msgid ""
"Technically it is possible to use the tools for creating navigation meshes "
"in one dimension for the other dimension, e.g. baking a 2D navigation mesh "
"with the 3D NavigationMesh when using flat 3D source geometry or creating 3D "
"flat navigation meshes with the polygon outline draw tools of "
"NavigationRegion2D and NavigationPolygons."
msgstr ""
"技術上來說，也可以用一個維度的導覽網格工具來建立另一個維度的網格，例如：用平"
"面 3D 幾何體搭配 3D NavigationMesh 來烘焙 2D 導覽網格，或是用 "
"NavigationRegion2D 與 NavigationPolygons 的多邊形繪製工具來產生平面 3D 導覽網"
"格。"

msgid ""
"Any RID created with the NavigationServer2D API works on the "
"NavigationServer3D API as well and both 2D and 3D avoidance agents can exist "
"on the same map."
msgstr ""
"任何用 NavigationServer2D API 建立的 RID 也能直接用於 NavigationServer3D "
"API，2D 與 3D 的避障代理也可以同時存在於同一張地圖上。"

msgid ""
"Regions created in 2D and 3D will merge their navigation meshes when placed "
"on the same map and merge conditions apply. The NavigationServer does not "
"discriminate between NavigationRegion2D and NavigationRegion3D nodes as both "
"are regions on the server. By default those nodes register on different "
"navigation maps so this merge can only happen when maps are changed manually "
"e.g. with scripts."
msgstr ""
"在 2D 與 3D 中建立的區域，只要放到同一個地圖上，且符合合併條件時，它們的導覽"
"網格就會被合併。NavigationServer 不會區分 NavigationRegion2D 與 "
"NavigationRegion3D 節點，因為在伺服器端它們都是區域。預設情況下，這些節點會註"
"冊到不同的導覽地圖，所以只有手動變更地圖（例如用腳本時）才會發生這種合併。"

msgid ""
"Actors with avoidance enabled will avoid both 2D and 3D avoidance agents "
"when placed on the same map."
msgstr ""
"若 Actor 啟用避障功能，當其與 2D 和 3D 的避障代理同時存在於同一張地圖時，都會"
"進行避障。"

msgid ""
"It is not possible to use NavigationServer2D while disabling 3D on a Godot "
"custom build."
msgstr "在 Godot 自訂編譯時若停用 3D，將無法使用 NavigationServer2D。"

msgid "Waiting for synchronization"
msgstr "等待同步"

msgid ""
"At the start of the game, a new scene or procedural navigation changes any "
"path query to a NavigationServer will return empty or wrong."
msgstr ""
"在遊戲剛開始、新場景載入，或是程式動態變更導覽時，對 NavigationServer 發出的"
"任何路徑查詢，可能都會回傳空值或錯誤值。"

msgid ""
"The navigation map is still empty or not updated at this point. All nodes "
"from the scene tree need to first upload their navigation related data to "
"the NavigationServer. Each added or changed map, region or agent need to be "
"registered with the NavigationServer. Afterward the NavigationServer "
"requires a **physics frame** for synchronization to update the maps, regions "
"and agents."
msgstr ""
"這是因為導覽地圖此時尚未建構或尚未更新。場景樹中的所有節點都必須先把各自的導"
"覽資料上傳到 NavigationServer，每個新增或變動的地圖、區域、代理都需要向伺服器"
"註冊。完成後，NavigationServer 需要經過一個**物理影格**的同步流程，才能讓地"
"圖、區域與代理的狀態正確更新。"

msgid ""
"One workaround is to make a deferred call to a custom setup function (so all "
"nodes are ready). The setup function makes all the navigation changes, e.g. "
"adding procedural stuff. Afterwards the function waits for the next physics "
"frame before continuing with path queries."
msgstr ""
"一種解法是使用延遲呼叫（deferred call）來執行自訂初始化函式，確保所有節點都已"
"經準備好。在這個設定函式裡進行所有導覽相關的變更（比如新增程式產生的內容），"
"然後等待下一個物理影格，再進行路徑查詢。"

msgid "Server Avoidance Callbacks"
msgstr "伺服器避障回呼"

msgid ""
"If RVO avoidance agents are registered for avoidance callbacks the "
"NavigationServer dispatches their ``velocity_computed`` signals just before "
"the PhysicsServer synchronization."
msgstr ""
"如果 RVO 避障代理註冊了避障回呼，NavigationServer 會在 PhysicsServer 同步前，"
"發出這些代理的 ``velocity_computed`` 訊號。"

msgid ""
"To learn more about NavigationAgents "
"see :ref:`doc_navigation_using_navigationagents`."
msgstr ""
"想進一步了解 NavigationAgent，請參"
"閱 :ref:`doc_navigation_using_navigationagents`。"

msgid ""
"The simplified order of execution for NavigationAgents that use avoidance:"
msgstr "使用避障功能的 NavigationAgent 執行流程簡述如下："

msgid "physics frame starts."
msgstr "物理影格開始。"

msgid "``_physics_process(delta)``."
msgstr "執行 ``_physics_process(delta)``。"

msgid "``velocity`` property is set on NavigationAgent Node."
msgstr "在 NavigationAgent 節點設置 ``velocity`` 屬性。"

msgid "Agent sends velocity and position to NavigationServer."
msgstr "代理將速度與位置傳送給 NavigationServer。"

msgid "NavigationServer waits for synchronization."
msgstr "NavigationServer 等待同步。"

msgid ""
"NavigationServer synchronizes and computes avoidance velocities for all "
"registered avoidance agents."
msgstr "NavigationServer 進行同步，並計算所有註冊避障代理的避障速度。"

msgid ""
"NavigationServer sends safe velocity vector with signals for each registered "
"avoidance agents."
msgstr ""
"NavigationServer 會針對每個已註冊的避障代理，發送安全速度向量（safe "
"velocity）訊號。"

msgid ""
"Agents receive the signal and move their parent e.g. with ``move_and_slide`` "
"or ``linear_velocity``."
msgstr ""
"代理收到訊號後，會用 ``move_and_slide`` 或 ``linear_velocity`` 等方式移動其父"
"節點。"

msgid "PhysicsServer synchronizes."
msgstr "PhysicsServer 進行同步。"

msgid "physics frame ends."
msgstr "物理影格結束。"

msgid ""
"Therefore moving a physicsbody actor in the callback function with the safe "
"velocity is perfectly thread- and physics-safe as all happens inside the "
"same physics frame before the PhysicsServer commits to changes and does its "
"own calculations."
msgstr ""
"因此，在回呼函式中用安全速度（safe velocity）移動 physicsbody actor 是完全執"
"行緒安全且物理安全的，因為這一切都發生在同一個物理影格內、PhysicsServer 正式"
"套用所有變更與進行物理運算之前。"
