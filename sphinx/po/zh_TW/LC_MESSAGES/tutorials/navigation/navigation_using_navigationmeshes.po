#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using navigation meshes"
msgstr "使用導航網格"

msgid ""
"2D and 3D versions of the navigation mesh are available "
"as :ref:`NavigationPolygon<class_NavigationPolygon>` "
"and :ref:`NavigationMesh<class_NavigationMesh>`  respectively."
msgstr ""
"導航網格的 2D 與 3D 版本分別"
"為 :ref:`NavigationPolygon<class_NavigationPolygon>` "
"與 :ref:`NavigationMesh<class_NavigationMesh>`。"

msgid ""
"A navigation mesh only describes a traversable area for an agent's center "
"position. Any radius values an agent may have are ignored. If you want "
"pathfinding to account for an agent's (collision) size you need to shrink "
"the navigation mesh accordingly."
msgstr ""
"導航網格僅描述代理物件中心點可通行的區域，不會考慮代理物件的半徑大小。如果你"
"需要尋路時考慮代理物件（碰撞）尺寸，必須相應縮小導航網格。"

msgid ""
"Navigation works independently from other engine parts like rendering or "
"physics. Navigation meshes are the only things considered when doing "
"pathfinding, e.g. visuals and collision shapes for example are completely "
"ignored by the navigation system. If you need to take other data (like "
"visuals for example) into account when doing pathfinding, you need to adapt "
"your navigation meshes accordingly. The process of factoring in navigation "
"restrictions in navigation meshes is commonly referred to as navigation mesh "
"baking."
msgstr ""
"導航功能與引擎其他部分（如繪圖或物理）是獨立運作的。進行尋路時，系統只會參考"
"導航網格，其它如可見物件或碰撞形狀都會被完全忽略。如果你希望尋路時考慮其他資"
"料（例如可見物件），就必須自行調整導航網格。將這些限制條件烘焙進導航網格的過"
"程，通常稱為導航網格烘焙（baking）。"

msgid "Navigation mesh polygon convex vs concave comparison"
msgstr "導航網格多邊形：凸 vs 凹 比較"

msgid ""
"A navigation mesh describes a surface that an agent can stand on safely with "
"its center compared to physics shapes that describe outer collision bounds."
msgstr ""
"導航網格描述的是代理物件中心能安全站立的表面，這與物理形狀描述外部碰撞邊界不"
"同。"

msgid ""
"If you experience clipping or collision problems while following navigation "
"paths, always remember that you need to tell the navigation system what your "
"intentions are through an appropriate navigation mesh. By itself the "
"navigation system will never know \"this is a tree / rock / wall collision "
"shape or visual mesh\" because it only knows that \"here I was told I can "
"path safely because it is on a navigation mesh\"."
msgstr ""
"如果在循導航路徑時發生穿模或碰撞問題，請記得必須透過合適的導航網格來告知導航"
"系統你的設計意圖。導航系統本身並不會知道「這裡是一棵樹／石頭／牆壁的碰撞形狀"
"或視覺網格」，它只知道「這裡有導航網格，所以可以安全通行」。"

msgid ""
"Navigation mesh baking can be done either by using "
"a :ref:`NavigationRegion2D<class_NavigationRegion2D>` "
"or :ref:`NavigationRegion3D<class_NavigationRegion3D>`, or by using "
"the :ref:`NavigationServer2D<class_NavigationServer2D>` "
"and :ref:`NavigationServer3D<class_NavigationServer3D>` API directly."
msgstr ""
"導航網格的烘焙可以透過 :ref:`NavigationRegion2D<class_NavigationRegion2D>` "
"或 :ref:`NavigationRegion3D<class_NavigationRegion3D>` 節點來進行，也可以直接"
"使用 :ref:`NavigationServer2D<class_NavigationServer2D>` "
"與 :ref:`NavigationServer3D<class_NavigationServer3D>` API 來操作。"

msgid "Baking a navigation mesh with a NavigationRegion"
msgstr "使用 NavigationRegion 烘焙導航網格"

msgid "Navigation mesh baking steps"
msgstr "導航網格烘焙步驟"

msgid "Baking a navigation mesh with agent radius offset from geometry."
msgstr "根據代理半徑對幾何進行偏移後烘焙導航網格。"

msgid ""
"The navigation mesh baking is made more accessible with the NavigationRegion "
"node. When baking with a NavigationRegion node, the individual parsing, "
"baking, and region update steps are all combined into one function."
msgstr ""
"透過 NavigationRegion 節點，導航網格烘焙變得更方便。使用 NavigationRegion 節"
"點烘焙時，解析、烘焙與區域更新等步驟會自動整合為單一功能。"

msgid ""
"The nodes are available in 2D and 3D "
"as :ref:`NavigationRegion2D<class_NavigationRegion2D>` "
"and :ref:`NavigationRegion3D<class_NavigationRegion3D>` respectively."
msgstr ""
"這些節點在 2D 與 3D 中分別"
"為 :ref:`NavigationRegion2D<class_NavigationRegion2D>` "
"與 :ref:`NavigationRegion3D<class_NavigationRegion3D>`。"

msgid ""
"The navigation mesh ``source_geometry_mode`` can be switched to parse "
"specific node group names so nodes that should be baked can be placed "
"anywhere in the scene."
msgstr ""
"導航網格的 ``source_geometry_mode`` 可切換為僅解析特定節點群組名稱，讓需要被"
"烘焙的節點可以放在場景的任意位置。"

msgid "Baking with a NavigationRegion2D"
msgstr "使用 NavigationRegion2D 進行烘焙"

msgid ""
"When a NavigationRegion2D node is selected in the Editor, bake options as "
"well as polygon draw tools appear in the top bar of the Editor."
msgstr ""
"當在編輯器選擇 NavigationRegion2D 節點時，頂部工具列會顯示烘焙選項與多邊形繪"
"製工具。"

msgid ""
"In order for the region to work "
"a :ref:`NavigationPolygon<class_NavigationPolygon>` resource needs to be "
"added."
msgstr ""
"為了讓此區域能運作，必須新增一"
"個 :ref:`NavigationPolygon<class_NavigationPolygon>` 資源。"

msgid ""
"The properties to parse and bake a navigation mesh are then part of the used "
"resource and can be found in the resource Inspector."
msgstr "用來解析與烘焙導航網格的屬性會在該資源中，並可於資源屬性檢查器中找到。"

msgid ""
"The result of the source geometry parsing can be influenced with the "
"following properties."
msgstr "以下屬性可影響來源幾何解析的結果。"

msgid ""
"The ``parsed_geometry_type`` that filters if visual objects or physics "
"objects or both should be parsed from the :ref:`SceneTree<class_SceneTree>`. "
"For more details on what objects are parsed and how, see the section about "
"parsing source geometry below."
msgstr ""
"``parsed_geometry_type`` 用來過濾是否從 :ref:`SceneTree<class_SceneTree>` 解"
"析視覺物件、物理物件，或兩者都解析。更多細節請參考下方的『解析來源幾何』章"
"節。"

msgid ""
"The ``collision_mask`` filters which physics collision objects are included "
"when the ``parsed_geometry_type`` includes static colliders."
msgstr ""
"當 ``parsed_geometry_type`` 包含靜態碰撞器時，``collision_mask`` 可以用來過濾"
"哪些物理碰撞物件會被包含。"

msgid ""
"The ``source_geometry_mode`` that defines on which node(s) to start the "
"parsing, and how to traverse the :ref:`SceneTree<class_SceneTree>`."
msgstr ""
"``source_geometry_mode`` 用來定義從哪些節點開始解析，以及如何遍"
"歷 :ref:`SceneTree<class_SceneTree>`。"

msgid ""
"The ``source_geometry_group_name`` is used when only a certain node group "
"should be parsed. Depends on the selected ``source_geometry_mode``."
msgstr ""
"僅解析某個節點群組時，請設置 ``source_geometry_group_name``，實際效果取決於 "
"``source_geometry_mode``。"

msgid ""
"With the source geometry added, the result of the baking can be controlled "
"with the following properties."
msgstr "設置來源幾何之後，可用以下屬性調整烘焙結果。"

msgid ""
"The ``cell_size`` sets the rasterization grid size and should match the "
"navigation map size."
msgstr "``cell_size`` 設定網格的像素（格點）大小，應與導航地圖尺寸相符。"

msgid ""
"The ``agent_radius`` shrinks the baked navigation mesh to have enough margin "
"for the agent (collision) size."
msgstr ""
"``agent_radius`` 會縮小烘焙後的導航網格，為代理物件（碰撞）尺寸預留足夠邊界。"

msgid "The NavigationRegion2D baking can also be used at runtime with scripts."
msgstr "NavigationRegion2D 的烘焙功能也可以於執行時透過腳本使用。"

msgid "To quickly test the 2D baking with default settings:"
msgstr "要快速測試 2D 導航網格的預設烘焙流程："

msgid "Add a :ref:`NavigationRegion2D<class_NavigationRegion2D>`."
msgstr "新增一個 :ref:`NavigationRegion2D<class_NavigationRegion2D>`。"

msgid ""
"Add a :ref:`NavigationPolygon<class_NavigationPolygon>` resource to the "
"NavigationRegion2D."
msgstr ""
"在 NavigationRegion2D 上新"
"增 :ref:`NavigationPolygon<class_NavigationPolygon>` 資源。"

msgid "Add a :ref:`Polygon2D<class_Polygon2D>` below the NavigationRegion2D."
msgstr "在 NavigationRegion2D 節點下方新增 :ref:`Polygon2D<class_Polygon2D>`。"

msgid ""
"Draw 1 NavigationPolygon outline with the selected NavigationRegion2D draw "
"tool."
msgstr ""
"使用 NavigationRegion2D 的多邊形繪製工具繪製一個 NavigationPolygon 外框。"

msgid ""
"Draw 1 Polygon2D outline inside the NavigationPolygon outline with the "
"selected Polygon2D draw tool."
msgstr ""
"使用 Polygon2D 的繪製工具，在 NavigationPolygon 外框內畫出一個 Polygon2D 外"
"框。"

msgid "Hit the Editor bake button and a navigation mesh should appear."
msgstr "點擊編輯器的烘焙按鈕，即可看到生成的導航網格。"

msgid "Baking with a NavigationRegion3D"
msgstr "使用 NavigationRegion3D 進行烘焙"

msgid ""
"When a NavigationRegion3D node is selected in the Editor, bake options "
"appear in the top bar of the Editor."
msgstr ""
"在編輯器中選擇 NavigationRegion3D 節點時，頂部工具列會顯示烘焙相關選項。"

msgid ""
"In order for the region to work "
"a :ref:`NavigationMesh<class_NavigationMesh>` resource needs to be added."
msgstr ""
"必須新增一個 :ref:`NavigationMesh<class_NavigationMesh>` 資源到該區域才能運"
"作。"

msgid ""
"The ``cell_size`` and ``cell_height`` sets the rasterization voxel grid size "
"and should match the navigation map size."
msgstr ""
"``cell_size`` 與 ``cell_height`` 設定體素網格的格點大小，應與導航地圖尺寸相"
"符。"

msgid ""
"The ``agent_height`` excludes areas from the navigation mesh where the agent "
"is too tall to fit in."
msgstr "``agent_height`` 用於排除代理物件高度無法通過的區域。"

msgid ""
"The ``agent_max_climb`` and ``agent_max_slope`` removes areas where the "
"height difference between neighboring voxels is too large, or where their "
"surface is too steep."
msgstr ""
"``agent_max_climb`` 與 ``agent_max_slope`` 可排除相鄰體素高度差過大或表面坡度"
"過陡的區域。"

msgid ""
"A too small ``cell_size`` or ``cell_height`` can create so many voxels that "
"it has the potential to freeze the game or even crash."
msgstr ""
"``cell_size`` 或 ``cell_height`` 設得太小時，將產生過多體素，可能導致遊戲卡死"
"甚至崩潰。"

msgid "The NavigationRegion3D baking can also be used at runtime with scripts."
msgstr "NavigationRegion3D 的烘焙功能也可於執行時透過腳本使用。"

msgid "To quickly test the 3D baking with default settings:"
msgstr "要快速測試 3D 導航網格的預設烘焙流程："

msgid "Add a :ref:`NavigationRegion3D<class_NavigationRegion3D>`."
msgstr "新增一個 :ref:`NavigationRegion3D<class_NavigationRegion3D>`。"

msgid ""
"Add a :ref:`NavigationMesh<class_NavigationMesh>` resource to the "
"NavigationRegion3D."
msgstr ""
"在 NavigationRegion3D 上新增 :ref:`NavigationMesh<class_NavigationMesh>` 資"
"源。"

msgid ""
"Add a :ref:`MeshInstance3D<class_MeshInstance3D>` below the "
"NavigationRegion3D."
msgstr ""
"在 NavigationRegion3D 節點下方新"
"增 :ref:`MeshInstance3D<class_MeshInstance3D>`。"

msgid "Add a :ref:`PlaneMesh<class_PlaneMesh>` to the MeshInstance3D."
msgstr "在 MeshInstance3D 上新增一個 :ref:`PlaneMesh<class_PlaneMesh>`。"

msgid "Baking a navigation mesh with the NavigationServer"
msgstr "使用 NavigationServer 烘焙導航網格"

msgid ""
"The :ref:`NavigationServer2D<class_NavigationServer2D>` "
"and :ref:`NavigationServer3D<class_NavigationServer3D>` have API functions "
"to call each step of the navigation mesh baking process individually."
msgstr ""
":ref:`NavigationServer2D<class_NavigationServer2D>` "
"與 :ref:`NavigationServer3D<class_NavigationServer3D>` 提供 API，可分別呼叫導"
"航網格烘焙流程中的各個步驟。"

msgid ""
"``parse_source_geometry_data()`` can be used to parse source geometry to a "
"reusable and serializable resource."
msgstr ""
"``parse_source_geometry_data()`` 用於將來源幾何解析為可重複使用並可序列化的資"
"源。"

msgid ""
"``bake_from_source_geometry_data()`` can be used to bake a navigation mesh "
"from already parsed data e.g. to avoid runtime performance issues with "
"(redundant) parsing."
msgstr ""
"``bake_from_source_geometry_data()`` 用於根據已解析的資料烘焙導航網格，例如可"
"避免執行時重複解析而導致效能問題。"

msgid ""
"``bake_from_source_geometry_data_async()`` is the same but bakes the "
"navigation mesh deferred with threads, not blocking the main thread."
msgstr ""
"``bake_from_source_geometry_data_async()`` 功能相同，但會以多線程方式延遲烘焙"
"導航網格，不會阻塞主線程。"

msgid ""
"Compared to a NavigationRegion, the NavigationServer offers finer control "
"over the navigation mesh baking process. In turn it is more complex to use "
"but also provides more advanced options."
msgstr ""
"與 NavigationRegion 相比，NavigationServer 提供更細緻的導航網格烘焙流程控制，"
"但相對更複雜，也具備更多進階選項。"

msgid ""
"Some other advantages of the NavigationServer over a NavigationRegion are:"
msgstr "NavigationServer 相較於 NavigationRegion 的其他優點包括："

msgid ""
"The server can parse source geometry without baking, e.g. to cache it for "
"later use."
msgstr "伺服器可僅解析來源幾何而不立即烘焙，例如用於快取以便日後使用。"

msgid ""
"The server allows selecting the root node at which to start the source "
"geometry parsing manually."
msgstr "伺服器允許手動指定來源幾何解析時的根節點。"

msgid ""
"The server can accept and bake from procedurally generated source geometry "
"data."
msgstr "伺服器可接受並烘焙由程式產生的來源幾何資料。"

msgid ""
"The server can bake multiple navigation meshes in sequence while (re)using "
"the same source geometry data."
msgstr "伺服器可連續烘焙多個導航網格，並重複利用同一組來源幾何資料。"

msgid ""
"To bake navigation meshes with the NavigationServer, source geometry is "
"required. Source geometry is geometry data that should be considered in a "
"navigation mesh baking process. Both navigation meshes for 2D and 3D are "
"created by baking them from source geometry."
msgstr ""
"使用 NavigationServer 烘焙導航網格時，必須有來源幾何。來源幾何即是導航網格烘"
"焙過程中應考慮的幾何資料。2D 與 3D 導航網格皆是由來源幾何烘焙而成。"

msgid ""
"2D and 3D versions of the source geometry resources are available "
"as :ref:`NavigationMeshSourceGeometryData2D<class_NavigationMeshSourceGeometryData2D>` "
"and :ref:`NavigationMeshSourceGeometryData3D<class_NavigationMeshSourceGeometryData3D>`  "
"respectively."
msgstr ""
"來源幾何資源在 2D 與 3D 中分別"
"為 :ref:`NavigationMeshSourceGeometryData2D<class_NavigationMeshSourceGeometryData2D>` "
"與 :ref:`NavigationMeshSourceGeometryData3D<class_NavigationMeshSourceGeometryData3D>`。"

msgid ""
"Source geometry can be geometry parsed from visual meshes, from physics "
"collision, or procedural created arrays of data, like outlines (2D) and "
"triangle faces (3D). For convenience, source geometry is commonly parsed "
"directly from node setups in the SceneTree. For runtime navigation mesh "
"(re)bakes, be aware that the geometry parsing always happens on the main "
"thread."
msgstr ""
"來源幾何可以來自視覺網格、物理碰撞，或程式產生的資料陣列（例如 2D 輪廓、3D 三"
"角面）。一般情況下，來源幾何會直接從 SceneTree 的節點配置中解析。注意，執行時"
"重新烘焙導航網格時，解析幾何資料一定會在主線程進行。"

msgid ""
"The SceneTree is not thread-safe. Parsing source geometry from the SceneTree "
"can only be done on the main thread."
msgstr "SceneTree 並非執行緒安全，從 SceneTree 解析來源幾何只能在主線程執行。"

msgid ""
"The data from visual meshes and polygons needs to be received from the GPU, "
"stalling the RenderingServer in the process. For runtime (re)baking prefer "
"using physics shapes as parsed source geometry."
msgstr ""
"從視覺網格與多邊形取得資料時需由 GPU 傳回，過程會讓 RenderingServer 停頓。執"
"行時重新烘焙導航網格時，建議盡量使用物理形狀作為解析來源幾何。"

msgid ""
"Source geometry is stored inside resources so the created geometry can be "
"reused for multiple bakes. E.g. baking multiple navigation meshes for "
"different agent sizes from the same source geometry. This also allows to "
"save source geometry to disk so it can be loaded later, e.g. to avoid the "
"overhead of parsing it again at runtime."
msgstr ""
"來源幾何會存於資源中，因此可多次重複利用，例如針對不同代理尺寸烘焙多個導航網"
"格。也可以將來源幾何儲存到磁碟以便日後載入，避免執行時重複解析造成效能負擔。"

msgid ""
"The geometry data should be in general kept very simple. As many edges as "
"are required but as few as possible. Especially in 2D duplicated and nested "
"geometry should be avoided as it forces polygon hole calculation that can "
"result in flipped polygons. An example for nested geometry would be a "
"smaller StaticBody2D shape placed completely inside the bounds of another "
"StaticBody2D shape."
msgstr ""
"幾何資料應盡量簡單，邊數只要足夠即可，避免冗餘。特別是在 2D 中，應避免重複或"
"巢狀幾何，否則會強制啟用多邊形洞計算，導致多邊形翻轉。例如，一個較小的 "
"StaticBody2D 完全放在另一個 StaticBody2D 範圍內，就是巢狀幾何。"

msgid "Baking navigation mesh chunks for large worlds"
msgstr "在大型世界場景中分塊烘焙導航網格"

msgid "Building navigation mesh chunks"
msgstr "建立導航網格分塊"

msgid "Building and updating individual navigation mesh chunks at runtime."
msgstr "執行時建立與更新各個導航網格分塊。"

msgid ""
"You can see the navigation mesh chunk baking in action in the `Navigation "
"Mesh Chunks 2D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/2d/navigation_mesh_chunks>`__ and `Navigation Mesh Chunks 3D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/3d/"
"navigation_mesh_chunks>`__ demo projects."
msgstr ""
"你可以在 `Navigation Mesh Chunks 2D <https://github.com/godotengine/godot-"
"demo-projects/tree/master/2d/navigation_mesh_chunks>`__ 與 `Navigation Mesh "
"Chunks 3D <https://github.com/godotengine/godot-demo-projects/tree/master/3d/"
"navigation_mesh_chunks>`__ 範例專案中看到導航網格分塊烘焙的實際運作。"

msgid ""
"To avoid misaligned edges between different region chunks the navigation "
"meshes have two important properties for the navigation mesh baking process. "
"The baking bound and the border size. Together they can be used to ensure "
"perfectly aligned edges between region chunks."
msgstr ""
"為避免不同區塊之間的邊緣錯位，導航網格烘焙過程有兩個重要屬性：烘焙邊界"
"（baking bound）與邊界尺寸（border size）。兩者搭配可確保區塊之間的邊緣完美對"
"齊。"

msgid "Navigation mesh chunk with bake bound and border size"
msgstr "帶烘焙邊界與邊界尺寸的導航網格分塊"

msgid ""
"Navigation mesh chunk baked with bake bound or baked with additional border "
"size."
msgstr "導航網格分塊可僅設烘焙邊界，或額外加上邊界尺寸來烘焙。"

msgid ""
"The baking bound, which is an axis-aligned :ref:`Rect2<class_Rect2>` for 2D "
"and :ref:`AABB<class_AABB>` for 3D, limits the used source geometry by "
"discarding all the geometry that is outside of the bounds."
msgstr ""
"烘焙邊界在 2D 中為軸對齊的 :ref:`Rect2<class_Rect2>`，在 3D 中"
"為 :ref:`AABB<class_AABB>`，會將烘焙範圍外的來源幾何全部排除。"

msgid ""
"The :ref:`NavigationPolygon<class_NavigationPolygon>` properties "
"``baking_rect`` and ``baking_rect_offset`` can be used to create and place "
"the 2D baking bound."
msgstr ""
":ref:`NavigationPolygon<class_NavigationPolygon>` 的 ``baking_rect`` 與 "
"``baking_rect_offset`` 屬性可用來設定 2D 烘焙邊界與其位置。"

msgid ""
"The :ref:`NavigationMesh<class_NavigationMesh>` properties "
"``filter_baking_aabb`` and ``filter_baking_aabb_offset`` can be used to "
"create and place the 3D baking bound."
msgstr ""
":ref:`NavigationMesh<class_NavigationMesh>` 的 ``filter_baking_aabb`` 與 "
"``filter_baking_aabb_offset`` 屬性可用來設定 3D 烘焙邊界與其位置。"

msgid ""
"With only the baking bound set another problem still exists. The resulting "
"navigation mesh will inevitably be affected by necessary offsets like the "
"``agent_radius`` which makes the edges not align properly."
msgstr ""
"僅設置烘焙邊界仍會有問題，例如 ``agent_radius`` 等必要偏移會導致產生的導航網"
"格邊緣無法正確對齊。"

msgid "Navigation mesh chunks with gaps"
msgstr "有間隙的導航網格分塊"

msgid ""
"Navigation mesh chunks with noticeable gaps due to baked agent radius offset."
msgstr "由於烘焙時考慮代理半徑偏移，導航網格分塊之間會出現明顯間隙。"

msgid ""
"This is where the ``border_size`` property for navigation mesh comes in. The "
"border size is an inward margin from the baking bound. The important "
"characteristic of the border size is that it is unaffected by most offsets "
"and postprocessing like the ``agent_radius``."
msgstr ""
"這時就需要使用導航網格的 ``border_size`` 屬性。邊界尺寸是烘焙邊界向內的留白，"
"其特點是大多數偏移與後處理（如 ``agent_radius``）都不會影響它。"

msgid ""
"Instead of discarding source geometry, the border size discards parts of the "
"final surface of the baked navigation mesh. If the baking bound is large "
"enough the border size can remove the problematic surface parts so that only "
"the intended chunk size is left."
msgstr ""
"邊界尺寸不是用來排除來源幾何，而是用來裁剪烘焙後導航網格的表面。如果烘焙邊界"
"夠大，邊界尺寸就能移除有問題的表面，只留下預期尺寸的分塊。"

msgid "Navigation mesh chunks without gaps"
msgstr "無間隙的導航網格分塊"

msgid "Navigation mesh chunks with aligned edges and without gaps."
msgstr "邊緣對齊且無間隙的導航網格分塊。"

msgid ""
"The baking bounds need to be large enough to include a reasonable amount of "
"source geometry from all the neighboring chunks."
msgstr "烘焙邊界必須足夠大，才能涵蓋所有相鄰分塊的合理來源幾何。"

msgid "In 3D the functionality of the border size is limited to the xz-axis."
msgstr "在 3D 中，邊界尺寸僅作用於 xz 平面。"

msgid "Navigation mesh baking common problems"
msgstr "導航網格烘焙常見問題"

msgid ""
"There are some common user problems and important caveats to consider when "
"creating or baking navigation meshes."
msgstr "建立或烘焙導航網格時，常見以下問題與注意事項。"

msgid "Navigation mesh baking creates frame rate problems at runtime"
msgstr "導航網格烘焙於執行時造成 FPS 掉幀"

msgid ""
"The navigation mesh baking is by default done on a background thread, so as "
"long as the platform supports threads, the actual baking is rarely the "
"source of any performance issues (assuming a reasonably sized and complex "
"geometry for runtime rebakes)."
msgstr ""
"導航網格烘焙預設會在背景執行緒進行，只要平台支援多執行緒，實際上烘焙本身很少"
"成為效能問題來源（前提是執行時重新烘焙的幾何數量與複雜度是合理的）。"

msgid ""
"The common source for performance issues at runtime is the parsing step for "
"source geometry that involves nodes and the SceneTree. The SceneTree is not "
"thread-safe so all the nodes need to be parsed on the main thread. Some "
"nodes with a lot of data can be very heavy and slow to parse at runtime, "
"e.g. a TileMap has one or more polygons for every single used cell and "
"TileMapLayer to parse. Nodes that hold meshes need to request the data from "
"the RenderingServer stalling the rendering in the process."
msgstr ""
"執行時效能問題多半來自來源幾何的解析階段，這通常需要存取節點與 SceneTree。而 "
"SceneTree 並非執行緒安全，所有節點必須在主線程解析。部分數據量龐大的節點（如 "
"TileMap，每個格子及圖層都需解析多邊形）在執行時解析會相當耗時。包含網格的節點"
"還需從 RenderingServer 請求資料，也會讓渲染過程暫停。"

msgid ""
"To improve performance, use more optimized shapes, e.g. collision shapes "
"over detailed visual meshes, and merge and simplify as much geometry as "
"possible upfront. If nothing helps, don't parse the SceneTree and add the "
"source geometry procedural with scripts. If only pure data arrays are used "
"as source geometry, the entire baking process can be done on a background "
"thread."
msgstr ""
"提升效能的方法包括：盡可能使用簡化的形狀（如碰撞形狀代替複雜視覺網格）、預先"
"合併與簡化幾何。若仍無法改善，則不要從 SceneTree 解析，而是用腳本程式生成來源"
"幾何。若來源僅為純資料陣列，整個烘焙過程皆可於背景執行緒進行。"

msgid "Navigation mesh creates unintended holes in 2D."
msgstr "2D 導航網格產生非預期的孔洞。"

msgid ""
"The navigation mesh baking in 2D is done by doing polygon clipping "
"operations based on outline paths. Polygons with \"holes\" are a necessary "
"evil to create more complex 2D polygons but can become unpredictable for "
"users with many complex shapes involved."
msgstr ""
"2D 導航網格烘焙會根據外框路徑進行多邊形裁切。多邊形上的「孔洞」是為了支援更複"
"雜的 2D 形狀，但當有眾多複雜形狀時，這些孔洞的結果可能會變得難以預測。"

msgid ""
"To avoid any unexpected problems with polygon hole calculations, avoid "
"nesting any outlines inside other outlines of the same type (traversable / "
"obstruction). This includes the parsed shapes from nodes. E.g. placing a "
"smaller StaticBody2D shape inside a larger StaticBody2D shape can result in "
"the resulting polygon being flipped."
msgstr ""
"為避免多邊形孔洞計算產生非預期問題，請避免在同類型（可通行／障礙）外框內巢狀"
"其他外框，包括節點解析所得的形狀。例如，將一個小的 StaticBody2D 放在較大的 "
"StaticBody2D 內，可能會導致多邊形翻轉。"

msgid "Navigation mesh appears inside geometry in 3D."
msgstr "3D 導航網格出現在幾何體內部。"

msgid ""
"The navigation mesh baking in 3D has no concept of \"inside\". The voxel "
"cells used to rasterize the geometry are either occupied or not. Remove the "
"geometry that is on the ground inside the other geometry. If that is not "
"possible, add smaller \"dummy\" geometry inside with as few triangles as "
"possible so the cells are occupied with something."
msgstr ""
"3D 導航網格烘焙時並沒有「內部」的概念，體素格點只分為被佔據或未被佔據。請移除"
"被其他幾何包覆的地面幾何。如果不行，可以在內部加入最簡單的「假」幾何（少量三"
"角形），讓這些格點有所佔用。"

msgid ""
"A :ref:`NavigationObstacle3D<class_NavigationObstacle3D>` shape set to bake "
"with navigation mesh can be used to discard geometry as well."
msgstr ""
"也可以將 :ref:`NavigationObstacle3D<class_NavigationObstacle3D>` 設為參與導航"
"網格烘焙，以移除不需要的幾何。"

msgid "NavigationObstacle3D unwanted geometry discard"
msgstr "NavigationObstacle3D 移除不需要的幾何"

msgid ""
"A NavigationObstacle3D shape can be used to discard unwanted navigation mesh "
"parts."
msgstr "可利用 NavigationObstacle3D 形狀來移除不需要的導航網格部分。"

msgid "Navigation mesh script templates"
msgstr "導航網格腳本範本"

msgid ""
"The following script uses the NavigationServer to parse source geometry from "
"the scene tree, bakes a navigation mesh, and updates a navigation region "
"with the updated navigation mesh."
msgstr ""
"以下腳本範例會使用 NavigationServer 解析 SceneTree 的來源幾何，烘焙導航網格，"
"並用新導航網格更新導航區域。"

msgid ""
"The following script uses the NavigationServer to update a navigation region "
"with procedurally generated navigation mesh data."
msgstr ""
"以下腳本範例會利用 NavigationServer 將程式生成的導航網格資料套用於導航區域。"
