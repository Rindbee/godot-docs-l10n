#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "最佳化導覽效能"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr "常見的導覽相關效能問題可分為以下幾類："

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr "解析場景樹節點以進行導覽網格烘焙時的效能問題。"

msgid "Performance problems with baking the actual navigation mesh."
msgstr "烘焙實際導覽網格時的效能問題。"

msgid "Performance problems with NavigationAgent path queries."
msgstr "NavigationAgent 路徑查詢的效能問題。"

msgid "Performance problems with the actual path search."
msgstr "實際路徑搜尋的效能問題。"

msgid "Performance problems with synchronizing the navigation map."
msgstr "同步導覽地圖時的效能問題。"

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr "以下章節將說明如何識別並修正這些問題，或至少減輕它們對影格率的影響。"

msgid "Performance problems with parsing scene tree nodes"
msgstr "解析場景樹節點的效能問題"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"建議使用邊緣數量盡量少的簡單形狀，例如避免使用圓形、球體或甜甜圈等曲面。"

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"建議以物理碰撞形狀取代複雜的視覺網格作為來源幾何，因為網格需要從 GPU 複製，且"
"細節通常遠超所需。"

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"一般來說，避免使用過於複雜的幾何作為烘焙導覽網格的來源。例如，切勿使用細節極"
"高的視覺網格，因為將其解析為資料陣列並體素化以進行導覽網格烘焙會花費大量時"
"間，且對最終導覽網格品質幾乎沒有提升。建議改用非常簡化的細節等級，甚至使用像"
"方塊、矩形等原始形狀，只需大致覆蓋同樣的幾何範圍，就能產生足夠好的路徑規劃效"
"果。"

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"導覽網格烘焙時，請優先選擇簡單的物理碰撞形狀作為來源幾何。物理形狀預設就是精"
"簡且最佳化的，解析速度快、效率高。反之，視覺網格的複雜度落差很大。特別是，解"
"析視覺網格資料時，系統需從 RenderingServer 請求網格資料陣列，因為這些資料直接"
"儲存於 GPU，並未快取於 CPU。這會造成 RenderingServer 執行緒鎖定，若渲染運作於"
"多執行緒時，會嚴重影響運行時影格率；若為單執行緒，效能影響更明顯，解析複雜網"
"格時甚至可能讓整個遊戲卡住數秒。"

msgid "Performance problems with navigation mesh baking"
msgstr "導覽網格烘焙的效能問題"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr "執行時如需烘焙導覽網格，請務必使用背景執行緒。"

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr ""
"將 NavigationMesh 的 ``cell_size`` 和 ``cell_height`` 調高，可以減少產生的體"
"素數量。"

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr ""
"將 ``SamplePartitionType`` 從 watershed 改為 monotone 或 layers，可以提升烘焙"
"效能。"

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"切勿用節點縮放來源幾何，以免產生精度誤差。大多數縮放僅影響視覺效果，若物件本"
"身極大，即使縮小後仍需大量額外處理。"

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"運行時進行導覽網格烘焙，應盡可能在背景執行緒完成。即使是小型導覽網格，也可能"
"需要花費超過單一影格可容納的時間，特別是在必須維持流暢影格率時。"

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake "
"(e.g. because they require no distance field pass)."
msgstr ""
"從場景樹節點解析的來源幾何資料複雜度會大幅影響烘焙效能，因為所有資料都需對應"
"到格線或體素。在運行時，建議將 NavigationMesh 的 cell size 與 cell height 設"
"定得儘量大，只要不影響遊戲導覽網格的品質即可。若 cell size 或 cell height 設"
"定過小，烘焙過程會被迫產生大量體素來處理來源幾何。若來源幾何涵蓋極大遊戲世"
"界，甚至可能導致烘焙時記憶體耗盡而當機。Partition type 也可依據來源幾何複雜度"
"調整，例如多為平坦、方塊狀幾何的遊戲，可以採用 monotone 或 layers 模式，烘焙"
"速度更快（如無需距離場處理）。"

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"切勿用節點縮放來源幾何。這不只會導致頂點與邊緣對齊錯誤產生精度誤差，且部分縮"
"放僅作用於視覺，並未反映於實際解析資料。例如你在編輯器將 MeshInstance 的 "
"scale 設為 0.001，雖然畫面很小，實際烘焙時仍需處理極大且複雜的體素網格。"

msgid "Performance problems with NavigationAgent path queries"
msgstr "NavigationAgent 路徑查詢的效能問題"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr "在 NavigationAgent 腳本中，避免每一影格都重設或查詢路徑。"

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr "避免在同一影格內同時更新所有 NavigationAgent 的路徑。"

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"自訂 NavigationAgent 腳本中的邏輯錯誤與多餘操作，是效能問題的常見主因。例如每"
"影格重設路徑就是常見錯誤。預設情況下，NavigationAgent 只會在目標位置變動、導"
"航地圖變更，或被迫偏離預期路徑距離過遠時才查詢新路徑。"

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"例如，當 AI 需移動至玩家時，不應每一影格都將目標位置設為玩家座標，否則會每影"
"格查詢新路徑。正確做法是：比較目前目標位置與玩家位置的距離，只有當玩家移動過"
"遠時才設定新目標位置。"

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"不要每一影格都檢查目標位置是否可到達。這種看似無害的檢查其實等同於進行昂貴的"
"路徑查詢。如果本來就打算查詢新路徑，可直接查詢，然後只需檢查返迴路徑的最後一"
"點與目標位置的距離，判斷是否「可到達」。這樣可避免同一 NavigationAgent 每影格"
"進行兩次完整路徑查詢。"

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"可將所有 NavigationAgent 分組更新，或用隨機計時器，使它們不會在同一影格同時請"
"求新路徑。"

msgid "Performance problems with the actual path search"
msgstr "實際路徑搜尋的效能問題"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr "若導覽網格過度細緻，請減少多邊形與邊的數量以提升效能。"

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"實際路徑搜尋的運算成本與導覽網格的多邊形數量與邊數直接相關，而非遊戲世界的大"
"小。若龐大遊戲世界僅用少量大面積的多邊形作為導覽網格，效能通常可接受；反之，"
"若世界被分割成許多極小的網格（例如 TileMap），尋路效能會大幅下降。"

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"常見問題之一是，當查詢路徑時目標位置不可達，效能會突然下降。這其實是「正常」"
"現象，原因是導覽網格過大且未優化，需遍歷過多多邊形與邊。若可快速抵達目標，尋"
"路會提前結束，暫時掩蓋優化不足的問題；若目標不可達，系統必須遍歷所有多邊形才"
"能確認，導致效能急劇下滑。"

msgid "Performance problems with navigation map synchronization"
msgstr "導覽地圖同步的效能問題"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr "盡量透過頂點合併導覽網格的多邊形，而非僅以邊連接合併。"

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"如對導覽網格或區域進行更動時，NavigationServer 需同步導覽地圖。依網格複雜度，"
"這可能相當耗時，進而影響影格率。"

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"NavigationServer 會以頂點或邊連接的方式合併導覽網格。當兩個不同邊的頂點落於同"
"一地圖格時，會進行頂點合併，這是快速且低成本的操作。尚未合併的邊則在第二階段"
"進行邊連接合併，會根據距離與角度檢查所有自由邊，這步驟相對耗時。"

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"除了盡量減少多邊形邊數的原則外，也應盡可能預先以頂點合併多邊形，只留下極少數"
"邊交給耗時的邊連接合併。可使用偵錯導覽效能監視器（Navigation "
"PerformanceMonitor）檢查多邊形、邊的數量，以及未合併或未經頂點合併的比例。若"
"頂點合併與邊連接的比例失衡（應以頂點合併為主），代表導覽網格建立或擺放方式極"
"為低效。"
