#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "3D gizmo plugins"
msgstr "3D 小工具外掛"

msgid "Introduction"
msgstr "前言"

msgid ""
"3D gizmo plugins are used by the editor and custom plugins to define the "
"gizmos attached to any kind of Node3D node."
msgstr ""
"3D 小工具外掛由編輯器與自訂外掛用來定義附加在各類 Node3D 節點上的小工具。"

msgid ""
"This tutorial shows the two main approaches to defining your own custom "
"gizmos. The first option works well for simple gizmos and creates less "
"clutter in your plugin structure, and the second one will let you store some "
"per-gizmo data."
msgstr ""
"本教學展示定義自訂小工具的兩種主要方法。第一種適合簡單小工具，可讓你的外掛結"
"構較為精簡；第二種則能讓你為每個小工具儲存額外資料。"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page."
msgstr ""
"本教學假設你已經了解如何製作一般外掛。如有疑問，請參"
"考 :ref:`doc_making_plugins` 頁面。"

msgid "The EditorNode3DGizmoPlugin"
msgstr "EditorNode3DGizmoPlugin"

msgid ""
"Regardless of the approach we choose, we will need to create a "
"new :ref:`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>`. This "
"will allow us to set a name for the new gizmo type and define other "
"behaviors such as whether the gizmo can be hidden or not."
msgstr ""
"無論我們選擇哪種方法，都必須建立一個新的 :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>`。這讓我們可以為新小工具類型命名，並定義其它"
"行為，例如是否可以隱藏該小工具。"

msgid "This would be a basic setup:"
msgstr "這是一個基本設定："

msgid ""
"For simple gizmos, inheriting :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>` is enough. If you want to store some per-"
"gizmo data or you are porting a Godot 3.0 gizmo to 3.1+, you should go with "
"the second approach."
msgstr ""
"對於簡單的小工具，只要繼承 :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>` 即可。如果你需要為每個小工具儲存資料，或是"
"從 Godot 3.0 移植小工具到 3.1 以上，建議使用第二種方法。"

msgid "Simple approach"
msgstr "簡易方法"

msgid ""
"The first step is to, in our custom gizmo plugin, override "
"the :ref:`_has_gizmo()<class_EditorNode3DGizmoPlugin_private_method__has_gizmo>` "
"method so that it returns ``true`` when the node parameter is of our target "
"type."
msgstr ""
"第一步，在我們的自訂小工具外掛中，覆"
"寫 :ref:`_has_gizmo()<class_EditorNode3DGizmoPlugin_private_method__has_gizmo>` "
"方法，讓當傳入節點參數為目標型別時返回 ``true``。"

msgid ""
"Then we can override methods "
"like :ref:`_redraw()<class_EditorNode3DGizmoPlugin_private_method__redraw>` "
"or all the handle related ones."
msgstr ""
"接著我們可以覆寫像"
"是 :ref:`_redraw()<class_EditorNode3DGizmoPlugin_private_method__redraw>` 或"
"所有與控制點相關的方法。"

msgid ""
"Note that we created a material in the `_init` method, and retrieved it in "
"the `_redraw` method "
"using :ref:`get_material()<class_EditorNode3DGizmoPlugin_method_get_material>`. "
"This method retrieves one of the material's variants depending on the state "
"of the gizmo (selected and/or editable)."
msgstr ""
"請注意，我們在 `_init` 方法中建立材質，並在 `_redraw` 方法中使"
"用 :ref:`get_material()<class_EditorNode3DGizmoPlugin_method_get_material>` "
"取得材質。此方法會根據小工具的狀態（選取和／或可編輯）取得對應的材質變體。"

msgid "So the final plugin would look somewhat like this:"
msgstr "因此，完整的外掛大致如下："

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks "
"in :ref:`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>` to get "
"properly working handles."
msgstr ""
"請注意，我們僅在 `_redraw` 方法中新增了一些控制點，但仍需"
"在 :ref:`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>` 中實作其他"
"與控制點相關的回呼函式，才能讓控制點正常運作。"

msgid "Alternative approach"
msgstr "進階方法"

msgid ""
"In some cases we want to provide our own implementation "
"of :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>`, maybe because we want "
"to have some state stored in each gizmo or because we are porting an old "
"gizmo plugin and we don't want to go through the rewriting process."
msgstr ""
"有時我們會希望自訂 :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>` 的實作，"
"例如需要在每個小工具中儲存狀態，或是移植舊版小工具外掛且不想全部重寫。"

msgid ""
"In these cases all we need to do is, in our new gizmo plugin, "
"override :ref:`_create_gizmo()<class_EditorNode3DGizmoPlugin_private_method__create_gizmo>`, "
"so it returns our custom gizmo implementation for the Node3D nodes we want "
"to target."
msgstr ""
"這種情況下，只需在新的小工具外掛中覆"
"寫 :ref:`_create_gizmo()<class_EditorNode3DGizmoPlugin_private_method__create_gizmo>`，"
"讓它針對目標 Node3D 節點返回我們的自訂小工具實作即可。"

msgid ""
"This way all the gizmo logic and drawing methods can be implemented in a new "
"class extending :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>`, like so:"
msgstr ""
"如此一來，所有小工具的邏輯與繪製方法都可以在繼"
"承 :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>` 的新類別中實作，例如："

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks "
"in :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>` to get properly working "
"handles."
msgstr ""
"請注意，我們僅在 `_redraw` 方法內新增了一些控制點，但仍需要"
"在 :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>` 中補齊其他與控制點相關的"
"回呼，才能讓控制點運作正常。"
