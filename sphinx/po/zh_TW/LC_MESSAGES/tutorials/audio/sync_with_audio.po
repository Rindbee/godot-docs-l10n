#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Sync the gameplay with audio and music"
msgstr "將遊戲流程與音效及音樂同步"

msgid "Introduction"
msgstr "前言"

msgid ""
"In any application or game, sound and music playback will have a slight "
"delay. For games, this delay is often so small that it is negligible. Sound "
"effects will come out a few milliseconds after any play() function is "
"called. For music this does not matter as in most games it does not interact "
"with the gameplay."
msgstr ""
"在任何應用程式或遊戲中，聲音與音樂播放都會有些微延遲。對大多數遊戲來說，這種"
"延遲通常小到可以忽略。每次呼叫 play() 函式後，音效會在幾毫秒後才發出。對於音"
"樂而言，這通常不是問題，因為在多數遊戲中音樂不會與遊戲流程直接互動。"

msgid ""
"Still, for some games (mainly, rhythm games), it may be required to "
"synchronize player actions with something happening in a song (usually in "
"sync with the BPM). For this, having more precise timing information for an "
"exact playback position is useful."
msgstr ""
"但對某些遊戲（主要是節奏遊戲）來說，可能需要讓玩家的操作與歌曲內發生的事件同"
"步（通常要對齊 BPM 節奏）。這時，取得更精確的播放位置時間資訊就非常重要。"

msgid ""
"Achieving very low playback timing precision is difficult. This is because "
"many factors are at play during audio playback:"
msgstr ""
"要達到極低的播放時序誤差其實很困難，因為音訊播放過程中有很多因素會影響同步："

msgid ""
"Audio is mixed in chunks (not continuously), depending on the size of audio "
"buffers used (check latency in project settings)."
msgstr ""
"音訊是以區塊（非連續）進行混音的，這取決於所設定的音訊緩衝區大小（可於專案設"
"定檢查延遲）。"

msgid "Mixed chunks of audio are not played immediately."
msgstr "混音後的音訊區塊不會立即播放。"

msgid "Graphics APIs display two or three frames late."
msgstr "圖形 API 通常會延遲兩到三個畫格才顯示。"

msgid "When playing on TVs, some delay may be added due to image processing."
msgstr "在電視上播放時，影像處理流程可能會再增加些許延遲。"

msgid ""
"The most common way to reduce latency is to shrink the audio buffers (again, "
"by editing the latency setting in the project settings). The problem is that "
"when latency is too small, sound mixing will require considerably more CPU. "
"This increases the risk of skipping (a crack in sound because a mix callback "
"was lost)."
msgstr ""
"最常見的減少延遲方式是縮小音訊緩衝區（同樣是在專案設定中調整延遲參數）。但如"
"果延遲設得太小，混音時會消耗更多 CPU 資源，這樣反而容易導致音訊破音（因混音回"
"呼來不及處理而跳音）。"

msgid ""
"This is a common tradeoff, so Godot ships with sensible defaults that should "
"not need to be altered."
msgstr "這是一種常見的取捨，因此 Godot 預設值已經相當合理，通常無需調整。"

msgid ""
"The problem, in the end, is not this slight delay but synchronizing graphics "
"and audio for games that require it. Some helpers are available to obtain "
"more precise playback timing."
msgstr ""
"其實問題不在於這些微小的延遲，而是在於對於需要音畫同步的遊戲，如何讓遊戲畫面"
"與音訊真正同步。Godot 提供一些輔助方法，可以取得更精確的播放時序資訊。"

msgid "Using the system clock to sync"
msgstr "使用系統時鐘進行同步"

msgid ""
"As mentioned before, If you "
"call :ref:`AudioStreamPlayer.play()<class_AudioStreamPlayer_method_play>`, "
"sound will not begin immediately, but when the audio thread processes the "
"next chunk."
msgstr ""
"如前所述，如果你呼"
"叫 :ref:`AudioStreamPlayer.play()<class_AudioStreamPlayer_method_play>`，聲音"
"並不會立即播放，而是等到音訊執行緒處理到下一個音訊區塊時才開始。"

msgid ""
"This delay can't be avoided but it can be estimated by "
"calling :ref:`AudioServer.get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>`."
msgstr ""
"這個延遲無法避免，但可以透過呼"
"叫 :ref:`AudioServer.get_time_to_next_mix()<class_AudioServer_method_get_time_to_next_mix>` "
"來預估。"

msgid ""
"The output latency (what happens after the mix) can also be estimated by "
"calling :ref:`AudioServer.get_output_latency()<class_AudioServer_method_get_output_latency>`."
msgstr ""
"輸出延遲（即混音之後到實際發聲的延遲）也能透過呼"
"叫 :ref:`AudioServer.get_output_latency()<class_AudioServer_method_get_output_latency>` "
"來預估。"

msgid ""
"Add these two and it's possible to guess almost exactly when sound or music "
"will begin playing in the speakers during *_process()*:"
msgstr ""
"將這兩個值加總後，就能在 *_process()* 內大致推算出音效或音樂何時會於喇叭開始"
"播放："

msgid ""
"In the long run, though, as the sound hardware clock is never exactly in "
"sync with the system clock, the timing information will slowly drift away."
msgstr ""
"但長期來看，聲音硬體的時鐘與系統時鐘永遠無法完全同步，因此計時資訊會隨時間逐"
"漸產生誤差。"

msgid ""
"For a rhythm game where a song begins and ends after a few minutes, this "
"approach is fine (and it's the recommended approach). For a game where "
"playback can last a much longer time, the game will eventually go out of "
"sync and a different approach is needed."
msgstr ""
"對於一首歌只有幾分鐘長的節奏遊戲來說，這種作法已經很夠用（也是推薦的作法）。"
"但如果你的遊戲會連續播放很長時間，最終還是會發生音畫不同步的狀況，這時就需要"
"採用不同的同步方法。"

msgid "Using the sound hardware clock to sync"
msgstr "使用聲音硬體時鐘進行同步"

msgid ""
"Using :ref:`AudioStreamPlayer.get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` "
"to obtain the current position for the song sounds ideal, but it's not that "
"useful as-is. This value will increment in chunks (every time the audio "
"callback mixed a block of sound), so many calls can return the same value. "
"Added to this, the value will be out of sync with the speakers too because "
"of the previously mentioned reasons."
msgstr ""
"看似可以利"
"用 :ref:`AudioStreamPlayer.get_playback_position()<class_AudioStreamPlayer_method_get_playback_position>` "
"取得歌曲目前播放位置，但實際上並不完全可行。這個值會以區塊為單位遞增（每當音"
"訊回呼處理一塊音訊時），因此多次查詢可能會拿到同樣的結果。此外，這個值也可能"
"因前述原因而與實際喇叭播放時間不同步。"

msgid ""
"To compensate for the \"chunked\" output, there is a function that can "
"help: :ref:`AudioServer.get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>`."
msgstr ""
"為補償這種「區塊化」輸出，Godot 提供一個輔助函"
"式 :ref:`AudioServer.get_time_since_last_mix()<class_AudioServer_method_get_time_since_last_mix>` 。"

msgid ""
"Adding the return value from this function to *get_playback_position()* "
"increases precision:"
msgstr "將這個函式的回傳值加到 *get_playback_position()* 上可以提升時序精度："

msgid ""
"To increase precision, subtract the latency information (how much it takes "
"for the audio to be heard after it was mixed):"
msgstr ""
"若要進一步提升精度，還可以減去延遲資訊（即混音後到實際聽到聲音所需的時間）："

msgid ""
"The result may be a bit jittery due how multiple threads work. Just check "
"that the value is not less than in the previous frame (discard it if so). "
"This is also a less precise approach than the one before, but it will work "
"for songs of any length, or synchronizing anything (sound effects, as an "
"example) to music."
msgstr ""
"由於多執行緒機制，這個結果可能會有些微跳動。只要檢查該值有無小於前一畫格（如"
"果有就忽略），即可。雖然這種方法比前述方式精度略低，但能支援任意長度的歌曲，"
"或將其他音效等與音樂同步。"

msgid "Here is the same code as before using this approach:"
msgstr "以下是採用這種方式的範例程式碼："
