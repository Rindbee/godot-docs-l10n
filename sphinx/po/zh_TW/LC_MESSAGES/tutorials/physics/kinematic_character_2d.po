#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Kinematic character (2D)"
msgstr "運動學角色（2D）"

msgid "Introduction"
msgstr "前言"

msgid ""
"Yes, the name sounds strange. \"Kinematic Character\". What is that? The "
"reason for the name is that, when physics engines came out, they were called "
"\"Dynamics\" engines (because they dealt mainly with collision responses). "
"Many attempts were made to create a character controller using the dynamics "
"engines, but it wasn't as easy as it seemed. Godot has one of the best "
"implementations of dynamic character controller you can find (as it can be "
"seen in the 2d/platformer demo), but using it requires a considerable level "
"of skill and understanding of physics engines (or a lot of patience with "
"trial and error)."
msgstr ""
"是的，這個名字聽起來很奇怪。「運動學角色」到底是什麼？會有這個名稱，是因為早"
"期物理引擎問世時，被稱為「動力學（Dynamics）」引擎（因為它們主要處理碰撞回"
"應）。當時有許多嘗試想用動力學引擎做角色控制器，但實際上沒那麼簡單。Godot 擁"
"有目前最好的動力學角色控制器實作之一（可以在 2D 平台範例中看到），但要使用它"
"需要對物理引擎有相當深的理解與技巧（或者你要有很多耐心來摸索）。"

msgid ""
"Some physics engines, such as Havok seem to swear by dynamic character "
"controllers as the best option, while others (PhysX) would rather promote "
"the kinematic one."
msgstr ""
"有些物理引擎（像 Havok）認為動力學角色控制器是最佳選擇，但也有其他（例如 "
"PhysX）則更偏好推廣運動學角色控制器。"

msgid "So, what is the difference?:"
msgstr "那麼，兩者到底有什麼區別？："

msgid ""
"A **dynamic character controller** uses a rigid body with an infinite "
"inertia tensor. It's a rigid body that can't rotate. Physics engines always "
"let objects move and collide, then solve their collisions all together. This "
"makes dynamic character controllers able to interact with other physics "
"objects seamlessly, as seen in the platformer demo. However, these "
"interactions are not always predictable. Collisions can take more than one "
"frame to be solved, so a few collisions may seem to displace a tiny bit. "
"Those problems can be fixed, but require a certain amount of skill."
msgstr ""
"**動力學角色控制器** 是用一個具有無限慣性張量的剛體（RigidBody），這種剛體是"
"不能旋轉的。物理引擎會讓物體移動與碰撞，再一起解決碰撞反應。這讓動力學角色控"
"制器可以像平台遊戲範例那樣，和其他物理物件無縫互動。不過，這些互動並非總是可"
"預測的。有時碰撞會需要超過一個影格才能解決，因此碰撞時可能會有輕微的偏移。這"
"些問題雖然能解決，但需要一定程度的技巧。"

msgid ""
"A **kinematic character controller** is assumed to always begin in a non-"
"colliding state, and will always move to a non-colliding state. If it starts "
"in a colliding state, it will try to free itself like rigid bodies do, but "
"this is the exception, not the rule. This makes their control and motion a "
"lot more predictable and easier to program. However, as a downside, they "
"can't directly interact with other physics objects, unless done by hand in "
"code."
msgstr ""
"**運動學角色控制器** 則假設一開始總是在非碰撞狀態，並且移動時也會保持非碰撞狀"
"態。如果它一開始就處於碰撞狀態，會像剛體一樣嘗試自我脫離，但這是例外狀況。這"
"讓它的控制和移動更加可預測，也更容易寫程式。不過缺點是：不能直接和其他物理物"
"件互動，除非你在程式裡手動處理。"

msgid ""
"This short tutorial focuses on the kinematic character controller. It uses "
"the old-school way of handling collisions, which is not necessarily simpler "
"under the hood, but well hidden and presented as an API."
msgstr ""
"這個簡短教學主要聚焦在運動學角色控制器。它採用傳統的碰撞處理方式（底層未必比"
"較簡單，只是都被很好地包裝在 API 裡了）。"

msgid "Physics process"
msgstr "物理處理流程"

msgid ""
"To manage the logic of a kinematic body or character, it is always advised "
"to use physics process, because it's called before physics step and its "
"execution is in sync with physics server, also it is called the same amount "
"of times per second, always. This makes physics and motion calculation work "
"in a more predictable way than using regular process, which might have "
"spikes or lose precision if the frame rate is too high or too low."
msgstr ""
"要管理 Kinematic 角色或物體的邏輯，建議都放在物理處理流程（_physics_process）"
"裡，因為它會在物理步驟前呼叫，並且和物理伺服器同步，而且每秒呼叫次數固定。這"
"樣做，物理和移動的計算會比用一般的 process 更可預測，不會因為影格率太高或太低"
"而產生誤差或抖動。"

msgid "Scene setup"
msgstr "場景設定"

msgid ""
"To have something to test, here's the scene (from the tilemap tutorial): "
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_. We'll be creating a new scene for the "
"character. Use the robot sprite and create a scene like this:"
msgstr ""
"要方便測試，這裡有一個場景（來自 TileMap 教學）："
"`kinematic_character_2d_starter.zip <https://github.com/godotengine/godot-"
"docs-project-starters/releases/download/latest-4.x/"
"kinematic_character_2d_starter.zip>`_。我們會為角色建立一個新場景。請使用機器"
"人角色圖，並建立如下圖的場景："

msgid ""
"You'll notice that there's a warning icon next to our CollisionShape2D node; "
"that's because we haven't defined a shape for it. Create a new CircleShape2D "
"in the shape property of CollisionShape2D. Click on <CircleShape2D> to go to "
"the options for it, and set the radius to 30:"
msgstr ""
"你會注意到 CollisionShape2D 節點旁邊有個警告圖示，因為還沒設定形狀。請在 "
"CollisionShape2D 的 shape 屬性裡建立一個新的 CircleShape2D，然後點擊 "
"<CircleShape2D> 進入選項，把半徑（radius）設為 30："

msgid ""
"**Note: As mentioned before in the physics tutorial, the physics engine "
"can't handle scale on most types of shapes (only collision polygons, planes "
"and segments work), so always change the parameters (such as radius) of the "
"shape instead of scaling it. The same is also true for the kinematic/rigid/"
"static bodies themselves, as their scale affects the shape scale.**"
msgstr ""
"**注意：如同之前物理教學提到，物理引擎無法正確處理大多數形狀的縮放（只有碰撞"
"多邊形、平面和線段除外），所以請直接修改形狀的參數（例如半徑），而不是去縮放"
"它。對於 Kinematic/Rigid/Static 這些物理節點本身也是一樣，因為它們的 scale 會"
"影響碰撞形狀。**"

msgid ""
"Now, create a script for the character, the one used as an example above "
"should work as a base."
msgstr "現在，請為這個角色建立腳本，可以用上面範例作為基礎。"

msgid ""
"Finally, instance that character scene in the tilemap, and make the map "
"scene the main one, so it runs when pressing play."
msgstr ""
"最後，將角色場景實例化到 TileMap 場景中，並把地圖場景設為主場景，這樣按下執行"
"時就會直接運作。"

msgid "Moving the kinematic character"
msgstr "移動運動學角色"

msgid ""
"Go back to the character scene, and open the script, the magic begins now! "
"Kinematic body will do nothing by default, but it has a useful function "
"called ``CharacterBody2D.move_and_collide()``. This function takes "
"a :ref:`Vector2 <class_Vector2>` as an argument, and tries to apply that "
"motion to the kinematic body. If a collision happens, it stops right at the "
"moment of the collision."
msgstr ""
"回到角色場景並打開腳本，魔法即將開始！Kinematic 物件預設什麼都不會做，但它有"
"一個很實用的方法 ``CharacterBody2D.move_and_collide()``。這個方法會接收一"
"個 :ref:`Vector2 <class_Vector2>` 參數，並嘗試讓角色移動這個向量的距離。如果"
"過程中發生碰撞，角色就會停在碰撞點。"

msgid "So, let's move our sprite downwards until it hits the floor:"
msgstr "所以，讓我們把角色往下移動，直到碰到地板為止："

msgid ""
"The result is that the character will move, but stop right when hitting the "
"floor. Pretty cool, huh?"
msgstr "結果會發現角色會移動，但在碰到地板時就會停下來。很酷吧？"

msgid ""
"The next step will be adding gravity to the mix, this way it behaves a "
"little more like a regular game character:"
msgstr "下一步是加上重力，這樣角色行為會更像一般遊戲角色："

msgid ""
"Now the character falls smoothly. Let's make it walk to the sides, left and "
"right when touching the directional keys. Remember that the values being "
"used (for speed at least) are pixels/second."
msgstr ""
"現在角色會順暢地落下了。接下來讓它在按下左右方向鍵時往左右移動。記得這裡的速"
"度單位是像素／秒。"

msgid "This adds basic support for walking when pressing left and right:"
msgstr "這樣就支援按下左右鍵時角色能左右走動了："

msgid "And give it a try."
msgstr "可以試試看效果。"

msgid ""
"This is a good starting point for a platformer. A more complete demo can be "
"found in the demo zip distributed with the engine, or in the https://"
"github.com/godotengine/godot-demo-projects/tree/master/2d/"
"kinematic_character."
msgstr ""
"這就是平台遊戲設計的好起點。更完整的範例可以在 Godot 官方提供的 demo zip 或 "
"https://github.com/godotengine/godot-demo-projects/tree/master/2d/"
"kinematic_character 找到。"
