#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using RigidBody"
msgstr "使用 RigidBody"

msgid "What is a rigid body?"
msgstr "什麼是剛體？"

msgid ""
"A rigid body is one that is directly controlled by the physics engine in "
"order to simulate the behavior of physical objects. In order to define the "
"shape of the body, it must have one or more :ref:`Shape3D <class_Shape3D>` "
"objects assigned. Note that setting the position of these shapes will affect "
"the body's center of mass."
msgstr ""
"剛體是由物理引擎直接控制，以模擬實際物件行為的物件。為了定義剛體的形狀，必須"
"指派一個或多個 :ref:`Shape3D <class_Shape3D>` 物件。請注意，設定這些形狀的位"
"置會影響剛體的質心。"

msgid "How to control a rigid body"
msgstr "如何控制剛體"

msgid ""
"A rigid body's behavior can be altered by setting its properties, such as "
"mass and weight. A physics material needs to be added to the rigid body to "
"adjust its friction and bounce, and set if it's absorbent and/or rough. "
"These properties can be set in the Inspector or via code. "
"See :ref:`RigidBody3D <class_RigidBody3D>` and :ref:`PhysicsMaterial "
"<class_PhysicsMaterial>` for the full list of properties and their effects."
msgstr ""
"剛體的行為可以透過設定其屬性來調整，例如質量和重量。你需要為剛體新增物理材"
"質，以調整其摩擦力和彈力，並設定其是否具備吸收性或粗糙度。這些屬性可以在屬性"
"檢查器中設定，或是透過程式碼調整。完整屬性列表及其效果，請參"
"考 :ref:`RigidBody3D <class_RigidBody3D>` 與 :ref:`PhysicsMaterial "
"<class_PhysicsMaterial>` 。"

msgid ""
"There are several ways to control a rigid body's movement, depending on your "
"desired application."
msgstr "依照你的需求，有多種方式可以控制剛體的移動。"

msgid ""
"If you only need to place a rigid body once, for example to set its initial "
"location, you can use the methods provided by the :ref:`Node3D "
"<class_Node3D>` node, such as ``set_global_transform()`` or ``look_at()``. "
"However, these methods cannot be called every frame or the physics engine "
"will not be able to correctly simulate the body's state. As an example, "
"consider a rigid body that you want to rotate so that it points towards "
"another object. A common mistake when implementing this kind of behavior is "
"to use ``look_at()`` every frame, which breaks the physics simulation. "
"Below, we'll demonstrate how to implement this correctly."
msgstr ""
"如果你只需要設定剛體一次，例如設定其初始位置，可以使用 :ref:`Node3D "
"<class_Node3D>` 節點所提供的方法，例如 ``set_global_transform()`` 或 "
"``look_at()``。但這些方法不能在每一幀都呼叫，否則物理引擎將無法正確模擬剛體的"
"狀態。舉例來說，假設你想讓一個剛體旋轉並指向另一個物件，一個常見錯誤是每幀都"
"使用 ``look_at()``，這會破壞物理模擬。以下我們會示範正確的實作方式。"

msgid ""
"The fact that you can't use ``set_global_transform()`` or ``look_at()`` "
"methods doesn't mean that you can't have full control of a rigid body. "
"Instead, you can control it by using the ``_integrate_forces()`` callback. "
"In this method, you can add *forces*, apply *impulses*, or set the "
"*velocity* in order to achieve any movement you desire."
msgstr ""
"無法使用 ``set_global_transform()`` 或 ``look_at()`` 方法並不代表你就不能完全"
"控制剛體。你可以透過 ``_integrate_forces()`` 回呼函式來控制剛體。在這個方法"
"中，你可以加上*力*、施加*衝量*，或設定*速度*，來達到你想要的任何移動效果。"

msgid "The \"look at\" method"
msgstr "「look at」方法"

msgid ""
"As described above, using the Node3D's ``look_at()`` method can't be used "
"each frame to follow a target. Here is a custom ``look_at()`` method called "
"``look_follow()`` that will work with rigid bodies:"
msgstr ""
"如上所述，使用 Node3D 的 ``look_at()`` 方法不能在每一幀用來追蹤目標。這裡提供"
"一個自訂的 ``look_follow()`` 方法，適用於剛體："

msgid ""
"This method uses the rigid body's ``angular_velocity`` property to rotate "
"the body. The axis to rotate around is given by the cross product between "
"the current forward direction and the direction one wants to look in. The "
"``clamp`` is a simple method used to prevent the amount of rotation from "
"going past the direction which is wanted to be looked in, as the total "
"amount of rotation needed is given by the arccosine of the dot product. This "
"method can be used with ``axis_lock_angular_*`` as well. If more precise "
"control is needed, solutions such as ones relying on :ref:`class_Quaternion` "
"may be required, as discussed in :ref:`doc_using_transforms`."
msgstr ""
"這個方法會利用剛體的 ``angular_velocity`` 屬性來旋轉剛體。旋轉軸是由當前前方"
"方向與目標方向的向量叉積所決定。``clamp`` 則用來避免旋轉量超過所需的目標方"
"向，因為實際所需的旋轉量是由兩向量的點積再取反餘弦得出。這個方法也可以搭配 "
"``axis_lock_angular_*`` 屬性一起使用。如果需要更精確的控制，可能需要依"
"賴 :ref:`class_Quaternion` 等方案，如 :ref:`doc_using_transforms` 所討論。"
