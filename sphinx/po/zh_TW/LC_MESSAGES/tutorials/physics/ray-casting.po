#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Ray-casting"
msgstr "射線投射"

msgid "Introduction"
msgstr "前言"

msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"遊戲開發中最常見的任務之一就是發射射線（或自訂形狀的物件）並檢查撞擊目標。這"
"能實現複雜的行為、AI 等等。本教學將說明如何在 2D 與 3D 中執行這項操作。"

msgid ""
"Godot stores all the low-level game information in servers, while the scene "
"is only a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, nodes like :ref:`RayCast3D <class_RayCast3D>` "
"and :ref:`RayCast2D <class_RayCast2D>` will work, as they return every frame "
"what the result of a raycast is."
msgstr ""
"Godot 將所有底層遊戲資訊儲存在伺服器中，場景僅作為前端。因此，射線投射通常屬"
"於較底層的操作。對於簡單的射線投射，可以使用 :ref:`RayCast3D "
"<class_RayCast3D>` 和 :ref:`RayCast2D <class_RayCast2D>` 節點，這些節點會在每"
"個畫面更新時回傳射線投射的結果。"

msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr "但許多情況下，射線投射需要更具互動性，因此必須能以程式碼進行操作。"

msgid "Space"
msgstr "空間"

msgid ""
"In the physics world, Godot stores all the low-level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, "
"it's :ref:`Node3D.get_world_3d().space <class_Node3D_method_get_world_3d>`."
msgstr ""
"在物理系統中，Godot 將所有底層的碰撞與物理資訊儲存在 *空間* 中。目前的 2D 空"
"間（用於 2D 物理）可透過 :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>` 取得。3D 空間則可透"
"過 :ref:`Node3D.get_world_3d().space <class_Node3D_method_get_world_3d>` 取"
"得。"

msgid ""
"The resulting space :ref:`RID <class_RID>` can be used "
"in :ref:`PhysicsServer3D <class_PhysicsServer3D>` and :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>` respectively for 3D and 2D."
msgstr ""
"取得的空間 :ref:`RID <class_RID>` 可以分別用於 3D 的 :ref:`PhysicsServer3D "
"<class_PhysicsServer3D>` 及 2D 的 :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>`。"

msgid "Accessing space"
msgstr "存取空間"

msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during "
"the :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>` callback. Accessing it from "
"outside this function may result in an error due to space being *locked*."
msgstr ""
"Godot 的物理系統預設和遊戲邏輯運作於同一執行緒，但也可以設定於不同執行緒中以"
"提升效能。因此，僅在 :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>` 回呼中存取空間是安全的。若在此"
"函式之外存取，可能因空間被 *鎖定* 而導致錯誤。"

msgid ""
"To perform queries into physics space, the :ref:`PhysicsDirectSpaceState2D "
"<class_PhysicsDirectSpaceState2D>` and :ref:`PhysicsDirectSpaceState3D "
"<class_PhysicsDirectSpaceState3D>` must be used."
msgstr ""
"要對物理空間進行查詢，必須使用 :ref:`PhysicsDirectSpaceState2D "
"<class_PhysicsDirectSpaceState2D>` 與 :ref:`PhysicsDirectSpaceState3D "
"<class_PhysicsDirectSpaceState3D>`。"

msgid "Use the following code in 2D:"
msgstr "在 2D 中使用以下程式碼："

msgid "Or more directly:"
msgstr "或更直接："

msgid "And in 3D:"
msgstr "在 3D 中："

msgid "Raycast query"
msgstr "射線查詢"

msgid ""
"For performing a 2D raycast query, the "
"method :ref:`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"要執行 2D 射線查詢，可以使用 :ref:`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` 方法。例如："

msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"結果會是一個字典。如果射線未撞擊任何物件，字典會是空的；如果有撞擊，則會包含"
"碰撞相關資訊："

msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr "碰撞發生時，``result`` 字典會包含下列資料："

msgid ""
"The data is similar in 3D space, using Vector3 coordinates. Note that to "
"enable collisions with Area3D, the boolean parameter ``collide_with_areas`` "
"must be set to ``true``."
msgstr ""
"在 3D 空間中資料類似，僅座標型態為 Vector3。請注意，若要讓射線與 Area3D 發生"
"碰撞，必須將布林參數 ``collide_with_areas`` 設為 ``true``。"

msgid "Collision exceptions"
msgstr "碰撞例外"

msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"射線投射常用於讓角色偵測周圍世界。然而，角色本身通常有碰撞體，導致射線只偵測"
"到自己的碰撞體，如下圖："

msgid ""
"To avoid self-intersection, the ``intersect_ray()`` parameters object can "
"take an array of exceptions via its ``exclude`` property. This is an example "
"of how to use it from a CharacterBody2D or any other collision object node:"
msgstr ""
"為避免自體相交，``intersect_ray()`` 的參數物件可透過 ``exclude`` 屬性設定例外"
"清單。以下是在 CharacterBody2D 或任意碰撞物件節點中使用的範例："

msgid "The exceptions array can contain objects or RIDs."
msgstr "例外清單陣列可包含物件或 RID。"

msgid "Collision Mask"
msgstr "碰撞遮罩"

msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"雖然例外清單適用於排除單一或少量物件，但若需要大量或動態排除，建議使用碰撞層"
"／遮罩系統，效率更高。"

msgid ""
"The ``intersect_ray()`` parameters object can also be supplied a collision "
"mask. For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable. The array of exceptions can be supplied "
"as the last argument as well:"
msgstr ""
"``intersect_ray()`` 的參數物件也可以設定碰撞遮罩。例如，若要與父物件使用同一"
"遮罩，可指定 ``collision_mask`` 成員變數。排除清單則可作為最後一個參數傳入："

msgid ""
"See :ref:`doc_physics_introduction_collision_layer_code_example` for details "
"on how to set the collision mask."
msgstr ""
"關於如何設定碰撞遮罩，請參"
"閱 :ref:`doc_physics_introduction_collision_layer_code_example`。"

msgid "3D ray casting from screen"
msgstr "從螢幕進行 3D 射線投射"

msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject3D "
"<class_CollisionObject3D>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"從螢幕向 3D 物理空間發射射線在物件選取上很有用。但通常不需這麼做，"
"因 :ref:`CollisionObject3D <class_CollisionObject3D>` 已有 \"input_event\" 訊"
"號可偵測點擊。若想手動實作，可依以下方式進行。"

msgid ""
"To cast a ray from the screen, you need a :ref:`Camera3D <class_Camera3D>` "
"node. A ``Camera3D`` can be in two projection modes: perspective and "
"orthogonal. Because of this, both the ray origin and direction must be "
"obtained. This is because ``origin`` changes in orthogonal mode, while "
"``normal`` changes in perspective mode:"
msgstr ""
"要從螢幕發射射線，需要一個 :ref:`Camera3D <class_Camera3D>` 節點。"
"``Camera3D`` 支援兩種投影模式：透視與正交。因此必須同時取得射線的原點與方向，"
"因為 ``origin`` 在正交模式下會變動，而 ``normal`` 會在透視模式下變動："

msgid "To obtain it using a camera, the following code can be used:"
msgstr "可透過相機使用以下程式碼取得："

msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"請注意，在 ``_input()`` 執行期間空間可能會被鎖定，因此實務上建議在 "
"``_physics_process()`` 內進行查詢。"
