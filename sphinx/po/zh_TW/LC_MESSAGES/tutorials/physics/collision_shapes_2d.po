#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (2D)"
msgstr "碰撞形狀（2D）"

msgid "This guide explains:"
msgstr "本教學將說明："

msgid "The types of collision shapes available in 2D in Godot."
msgstr "Godot 2D 中可用的碰撞形狀類型。"

msgid "Using an image converted to a polygon as a collision shape."
msgstr "使用影像轉換為多邊形作為碰撞形狀。"

msgid "Performance considerations regarding 2D collisions."
msgstr "2D 碰撞的效能考量。"

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr "Godot 提供多種碰撞形狀，各有不同的效能與精確度權衡。"

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody2D` by adding one or "
"more :ref:`CollisionShape2Ds <class_CollisionShape2D>` "
"or :ref:`CollisionPolygon2Ds <class_CollisionPolygon2D>` as *direct* child "
"nodes. Indirect child nodes (i.e. children of child nodes) will be ignored "
"and won't be used as collision shapes. Also, note that you must add "
"a :ref:`class_Shape2D` *resource* to collision shape nodes in the Inspector "
"dock."
msgstr ""
"你可以在 :ref:`class_PhysicsBody2D` 下新增一個或多個 :ref:`CollisionShape2D "
"<class_CollisionShape2D>` 或 :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` 作為*直接*子節點來定義碰撞形狀。間接子節點（例如"
"子節點的子節點）會被忽略，不會作為碰撞形狀使用。此外，請注意必須在屬性面板中"
"為碰撞形狀節點指定 :ref:`class_Shape2D` *資源*。"

msgid ""
"When you add multiple collision shapes to a single PhysicsBody2D, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"當你在同一個 PhysicsBody2D 上新增多個碰撞形狀時，不需擔心它們會互相『碰撞』或"
"重疊，因為它們彼此不會產生碰撞。"

msgid "Primitive collision shapes"
msgstr "基本碰撞形狀"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godot 提供下列基本碰撞形狀型別："

msgid ":ref:`class_RectangleShape2D`"
msgstr ":ref:`class_RectangleShape2D`"

msgid ":ref:`class_CircleShape2D`"
msgstr ":ref:`class_CircleShape2D`"

msgid ":ref:`class_CapsuleShape2D`"
msgstr ":ref:`class_CapsuleShape2D`"

msgid ":ref:`class_SegmentShape2D`"
msgstr ":ref:`class_SegmentShape2D`"

msgid ":ref:`class_SeparationRayShape2D` (designed for characters)"
msgstr ":ref:`class_SeparationRayShape2D` （專為角色設計）"

msgid ":ref:`class_WorldBoundaryShape2D` (infinite plane)"
msgstr ":ref:`class_WorldBoundaryShape2D` （無限平面）"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"多數小型物件的碰撞可以使用一個或多個基本碰撞形狀來表示。但對於較複雜的物件，"
"如大型船艦或整個關卡，則可能需要使用凸形或凹形碰撞形狀。詳細內容請見下文。"

msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"建議對於動態物件（如 RigidBody 與 CharacterBody）優先使用基本碰撞形狀，這樣行"
"為最穩定可靠，且通常能提供更佳效能。"

msgid "Convex collision shapes"
msgstr "凸形碰撞形狀"

msgid ""
"Godot currently doesn't offer a built-in way to create 2D convex collision "
"shapes. This section is mainly here for reference purposes."
msgstr "Godot 目前沒有內建建立 2D 凸形碰撞形狀的方法。這一節僅供參考。"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape2D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
":ref:`凸形碰撞形狀<class_ConvexPolygonShape2D>` 介於基本碰撞形狀與凹形碰撞形"
"狀之間。它們可以表示任意複雜的形狀，但有一個重點限制：每個凸形只能表示*凸*的"
"形狀。例如，金字塔是*凸*的，而空心盒子則屬於*凹*。如果要用單一碰撞形狀定義凹"
"形物件，就得使用凹形碰撞形狀。"

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"根據物件的複雜度，使用多個凸形碰撞形狀來取代單一凹形碰撞形狀，通常能獲得更好"
"的效能。Godot 可透過*凸分解*自動產生多個大致符合物件外型的凸形狀。但若凸形狀"
"數量過多，這種效能優勢就會消失。對於大型或複雜物件（如整個關卡），建議仍直接"
"使用凹形碰撞形狀。"

msgid "Concave or trimesh collision shapes"
msgstr "凹形或三角網格碰撞形狀"

msgid ""
":ref:`Concave collision shapes <class_ConcavePolygonShape2D>`, also called "
"trimesh collision shapes, can take any form, from a few triangles to "
"thousands of triangles. Concave shapes are the slowest option but are also "
"the most accurate in Godot. **You can only use concave shapes within "
"StaticBodies.** They will not work with CharacterBodies or RigidBodies "
"unless the RigidBody's mode is Static."
msgstr ""
":ref:`凹形碰撞形狀<class_ConcavePolygonShape2D>`，也稱為三角網格碰撞形狀，可"
"以組成任何形狀，從少數三角形到數千個三角形。凹形碰撞形狀效能最差，但精度最"
"高。**凹形只能用於 StaticBody（靜態物件）**。若用於 CharacterBody 或 "
"RigidBody，除非該 RigidBody 模式設為 Static，否則將無法使用。"

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr ""
"即使凹形碰撞形狀提供最精確的*碰撞*檢測，接觸點回報的精度仍可能比基本形狀差。"

msgid ""
"When not using TileMaps for level design, concave shapes are the best "
"approach for a level's collision."
msgstr "若關卡設計未採用 TileMap，凹形碰撞形狀是最適合的碰撞解決方案。"

msgid ""
"You can configure the CollisionPolygon2D node's *build mode* in the "
"inspector. If it is set to **Solids** (the default), collisions will include "
"the polygon and its contained area. If it is set to **Segments**, collisions "
"will only include the polygon edges."
msgstr ""
"你可以在屬性面板調整 CollisionPolygon2D 節點的*建立模式*。若設為 **Solids**"
"（預設），碰撞區域包括多邊形與其內部範圍；若設為 **Segments**，碰撞僅包含多邊"
"形邊緣。"

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"Sprite2D and using the **Sprite2D** menu at the top of the 2D viewport. The "
"Sprite2D menu dropdown exposes an option called **Create CollisionPolygon2D "
"Sibling**. Once you click it, it displays a menu with 3 settings:"
msgstr ""
"你可以在編輯器中選取 Sprite2D，然後於 2D 視窗上方的 **Sprite2D** 選單中選擇**"
"建立 CollisionPolygon2D 同級**，即可自動產生凹形碰撞形狀。此選項會出現三個設"
"定："

msgid ""
"**Simplification:** Higher values will result in a less detailed shape, "
"which improves performance at the cost of accuracy."
msgstr "**簡化：** 數值越高，形狀越簡化，有助提升效能但降低精度。"

msgid ""
"**Shrink (Pixels):** Higher values will shrink the generated collision "
"polygon relative to the sprite's edges."
msgstr "**縮小（像素）：** 數值越高，碰撞多邊形會比原始圖片邊緣更內縮。"

msgid ""
"**Grow (Pixels):** Higher values will grow the generated collision polygon "
"relative to the sprite's edges. Note that setting Grow and Shrink to equal "
"values may yield different results than leaving both of them on 0."
msgstr ""
"**擴大（像素）：** 數值越高，碰撞多邊形會比原始圖片邊緣更外擴。注意：將擴大與"
"縮小設為相同數值，結果可能和都設為 0 不同。"

msgid ""
"If you have an image with many small details, it's recommended to create a "
"simplified version and use it to generate the collision polygon. This can "
"result in better performance and game feel, since the player won't be "
"blocked by small, decorative details."
msgstr ""
"如果圖片細節繁多，建議製作簡化版並用來產生碰撞多邊形，這樣效能與遊戲手感都會"
"更好，玩家也不會被細小裝飾卡住。"

msgid ""
"To use a separate image for collision polygon generation, create another "
"Sprite2D, generate a collision polygon sibling from it then remove the "
"Sprite2D node. This way, you can exclude small details from the generated "
"collision."
msgstr ""
"如需用不同圖片來產生碰撞多邊形，請建立另一個 Sprite2D，用該圖片產生碰撞多邊形"
"同級節點，然後再刪除這個 Sprite2D 節點。如此即可排除不必要的細節。"

msgid "Performance caveats"
msgstr "效能注意事項"

msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"每個 PhysicsBody 並不限於只能有一個碰撞形狀，但建議盡量減少碰撞形狀的數量，特"
"別是動態物件（如 RigidBody 與 CharacterBody），以提升效能。此外，請避免在執行"
"時對碰撞形狀進行移動、旋轉或縮放，這樣才能讓物理引擎充分發揮內部最佳化。"

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"若 StaticBody 僅有單一且未經縮放或旋轉的碰撞形狀時，引擎的 *廣義階段* 演算法"
"能有效忽略不活躍的物理物件， *狹義階段* 只需檢查活躍物件。但如果一個 "
"StaticBody 擁有多個碰撞形狀，廣義階段會失效，狹義階段（速度較慢）則必須對每個"
"形狀進行碰撞檢查。"

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"如果遇到效能問題，你可能需要在精度與效能間做出取捨。多數遊戲的碰撞判斷並非 "
"100% 精確，通常會用一些技巧將誤差隱藏，讓玩家在遊玩過程中察覺不到。"
