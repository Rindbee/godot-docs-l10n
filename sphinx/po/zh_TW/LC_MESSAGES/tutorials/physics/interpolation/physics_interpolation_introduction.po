#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "前言"

msgid "Physics ticks and rendered frames"
msgstr "物理更新與畫面算繪"

msgid ""
"One key concept to understand in Godot is the distinction between physics "
"ticks (sometimes referred to as iterations or physics frames), and rendered "
"frames. The physics proceeds at a fixed tick rate (set in :ref:`Project "
"Settings > Physics > Common > Physics Tick per "
"Second<class_ProjectSettings_property_physics/common/"
"physics_ticks_per_second>`), which defaults to 60 ticks per second."
msgstr ""
"在 Godot 中需要理解的一個重要概念是物理更新 (有時也稱為迭代或物理幀) 與算繪幀"
"之間的區別。物理是以固定的更新率進行的 (在 :ref:`專案設定 > 物理 > 通用 > 每"
"秒物理更新次數<class_ProjectSettings_property_physics/common/"
"physics_ticks_per_second>` 中設定，預設為每秒 60 次更新)。"

msgid ""
"However, the engine does not necessarily **render** at the same rate. "
"Although many monitors refresh at 60 Hz (cycles per second), many refresh at "
"completely different frequencies (e.g. 75 Hz, 144 Hz, 240 Hz or more). Even "
"though a monitor may be able to show a new frame e.g. 60 times a second, "
"there is no guarantee that the CPU and GPU will be able to *supply* frames "
"at this rate. For instance, when running with V-Sync, the computer may be "
"too slow for 60 and only reach the deadlines for 30 FPS, in which case the "
"frames you see will change at 30 FPS (resulting in stuttering)."
msgstr ""
"然而，遊戲引擎不一定會以相同的速率進行**算繪**。雖然許多螢幕的更新頻率是 60 "
"Hz（每秒週期），但也有許多螢幕使用完全不同的頻率（例如 75 Hz、144 Hz、240 Hz "
"或更高）。即使螢幕可能能夠每秒顯示 60 個新影格，也不能保證 CPU 和 GPU 能夠以"
"這個速率 *提供* 影格。舉例來說，當啟用垂直同步時，電腦可能速度不夠快而無法達"
"到 60 FPS，只能趕上 30 FPS 的時限，在這種情況下，您看到的影格將以 30 FPS 的速"
"率變化（導致畫面卡頓）。"

msgid ""
"But there is a problem here. What happens if the physics ticks do not "
"coincide with frames? What happens if the physics tick rate is out of phase "
"with the frame rate? Or worse, what happens if the physics tick rate is "
"*lower* than the rendered frame rate?"
msgstr ""
"但這裡有個問題。如果物理更新的頻率和畫面更新的頻率不同步會怎麼樣？如果物理更"
"新的時序和畫面更新的時序不同步又會怎麼樣？更糟的是，如果物理更新的頻率 *低於"
"* 算繪的畫面更新頻率會怎麼樣？"

msgid ""
"This problem is easier to understand if we consider an extreme scenario. If "
"you set the physics tick rate to 10 ticks per second, in a simple game with "
"a rendered frame rate of 60 FPS. If we plot a graph of the positions of an "
"object against the rendered frames, you can see that the positions will "
"appear to \"jump\" every 1/10th of a second, rather than giving a smooth "
"motion. When the physics calculates a new position for a new object, it is "
"not rendered in this position for just one frame, but for 6 frames."
msgstr ""
"如果我們考慮一個極端情境，這個問題會更容易理解。假設您將物理更新頻率設定為每"
"秒 10 次，在一個簡單的遊戲中，算繪幀率為每秒 60 幀。如果我們繪製一個物件位置"
"相對於算繪幀的圖表，您會看到物件的位置每 1/10 秒會「跳動」一次，而不是呈現平"
"滑的運動。當物理計算出一個新物件的新位置時，這個新位置不會只在一個影格中算"
"繪，而是會持續 6 個影格。"

msgid ""
"This jump can be seen in other combinations of tick / frame rate as "
"glitches, or jitter, caused by this staircasing effect due to the "
"discrepancy between physics tick time and rendered frame time."
msgstr ""
"這種跳動在其他刻度/影格率的組合中可能會看見，表現為故障、抖動或不穩，這是因為"
"物理刻度時間和算繪影格時間之間的差異所造成的階梯效應。"

msgid "What can we do about frames and ticks being out of sync?"
msgstr "幀數和刻度不同步的問題，我們該怎麼處理？"

msgid "Lock the tick / frame rate together?"
msgstr "鎖定幀率與物理更新率同步？"

msgid ""
"The most obvious solution is to get rid of the problem, by ensuring there is "
"a physics tick that coincides with every frame. This used to be the approach "
"on old consoles and fixed hardware computers. If you know that every player "
"will be using the same hardware, you can ensure it is fast enough to "
"calculate ticks and frames at e.g. 50 FPS, and you will be sure it will work "
"great for everybody."
msgstr ""
"最直觀的解決方案是直接消除問題，方法是確保每個影格都伴隨著一次物理更新。這在"
"舊式遊戲主機和固定規格的電腦上曾經是常見的做法。如果你確定所有玩家都會使用相"
"同的硬體，你可以確保硬體效能足夠快速，能夠以例如 50 FPS 的速度計算物理更新和"
"影格，這樣就能確保所有人的體驗都很順暢。"

msgid ""
"However, modern games are often no longer made for fixed hardware. You will "
"often be planning to release on desktop computers, mobiles, and more. All of "
"which have huge variations in performance, as well as different monitor "
"refresh rates. We need to come up with a better way of dealing with the "
"problem."
msgstr ""
"然而，現代遊戲通常不再是為固定硬體打造。您經常會計劃在桌上型電腦、行動裝置以"
"及更多平台上發行。這些平台在效能上差異極大，螢幕更新率也各不相同。我們需要想"
"出更好的方法來處理這個問題。"

msgid "Adapt the tick rate?"
msgstr "調整刻度率？"

msgid ""
"Instead of designing the game at a fixed physics tick rate, we could allow "
"the tick rate to scale according to the end users hardware. We could for "
"example use a fixed tick rate that works for that hardware, or even vary the "
"duration of each physics tick to match a particular frame duration."
msgstr ""
"與其用固定的物理更新頻率來設計遊戲，我們可以允許更新頻率根據終端使用者的硬體"
"進行調整。例如，我們可以針對該硬體使用一個可行的固定更新頻率，甚至可以調整每"
"次物理更新的時間長度，使其符合特定的畫面更新時間。"

msgid ""
"This works, but there is a problem. Physics (*and game logic*, which is "
"often also run in the ``_physics_process``) work best and most consistently "
"when run at a **fixed**, predetermined tick rate. If you attempt to run a "
"racing game physics that has been designed for 60 TPS (ticks per second) at "
"e.g. 10 TPS, the physics will behave completely differently. Controls may be "
"less responsive, collisions / trajectories can be completely different. You "
"may test your game thoroughly at 60 TPS, then find it breaks on end users "
"machines when it runs at a different tick rate."
msgstr ""
"這樣做可行，但有個問題。物理（ *以及遊戲邏輯* ，通常也運行在 "
"``_physics_process`` 中）在以 **固定** 、預先決定的更新頻率運行時，表現最好且"
"最穩定。如果您嘗試以例如 10 TPS（每秒更新次數）運行一個專為 60 TPS 設計的賽車"
"遊戲物理，物理行為將會完全不同。控制可能較不靈敏，碰撞／軌跡可能會完全改變。"
"您可能在 60 TPS 下徹底測試您的遊戲，然後發現在終端使用者的電腦上以不同的更新"
"頻率運行時發生錯誤。"

msgid ""
"This can make quality assurance difficult with hard to reproduce bugs, "
"especially in AAA games where problems of this sort can be very costly. This "
"can also be problematic for multiplayer games for competitive integrity, as "
"running the game at certain tick rates may be more advantageous than others."
msgstr ""
"這可能會使品質保證變得困難，尤其是在難以重現的錯誤方面，在 AAA 級遊戲中，這類"
"問題的代價可能非常高昂。對於多人遊戲的競技公平性而言，這也可能造成問題，因為"
"以特定的更新頻率運行遊戲可能比其他頻率更有優勢。"

msgid ""
"Lock the tick rate, but use interpolation to smooth frames in between "
"physics ticks"
msgstr "鎖定更新頻率，但使用插值來平滑物理更新之間的畫面"

msgid ""
"This has become one of the most popular approaches to deal with the problem, "
"although it is optional and disabled by default."
msgstr "這已成為處理此問題最受歡迎的方法之一，雖然它是可選的，並且預設為停用。"

msgid ""
"We have established that the most desirable physics/game logic arrangement "
"for consistency and predictability is a physics tick rate that is fixed at "
"design-time. The problem is the discrepancy between the physics position "
"recorded, and where we \"want\" a physics object to be shown on a frame to "
"give smooth motion."
msgstr ""
"我們已經確立，為了保持一致性和可預測性，最理想的物理/遊戲邏輯安排是將物理更新"
"頻率在設計時就固定下來。問題在於記錄的物理位置，以及為了在畫面呈現流暢的運"
"動，我們「希望」物理物件顯示在哪裡之間存在差異。"

msgid ""
"The answer turns out to be simple, but can be a little hard to get your head "
"around at first."
msgstr "答案其實很簡單，但一開始可能有點難以理解。"

msgid ""
"Instead of keeping track of just the current position of a physics object in "
"the engine, we keep track of *both the current position of the object, and "
"the previous position* on the previous physics tick."
msgstr ""
"引擎中，我們不只追蹤物理物件的當前位置，還會追蹤 **物件的當前位置，以及前一個"
"物理週期的前一個位置** 。"

msgid ""
"Why do we need the previous position *(in fact the entire transform, "
"including rotation and scaling)*? By using a little math magic, we can use "
"**interpolation** to calculate what the transform of the object would be "
"between those two points, in our ideal world of smooth continuous movement."
msgstr ""
"為什麼我們需要前一個位置 *(實際上是整個變換，包含旋轉和縮放)* ？透過一點數學"
"技巧，我們可以使用 **插值** 來計算物體在這兩個點之間，在我們理想的平滑連續運"
"動世界中，其變換會是什麼。"

msgid "Linear interpolation"
msgstr "線性內插"

msgid ""
"The simplest way to achieve this is linear interpolation, or lerping, which "
"you may have used before."
msgstr "達成此目的最簡單的方法是線性內插，或稱作 Lerp，您之前可能已經使用過。"

msgid ""
"Let us consider only the position, and a situation where we know that the "
"previous physics tick X coordinate was 10 units, and the current physics "
"tick X coordinate is 30 units."
msgstr ""
"我們只考慮位置，以及一種情況：我們知道前一個物理幀的 X 座標是 10 單位，而目前"
"的物理幀的 X 座標是 30 單位。"

msgid ""
"Although the maths is explained here, you do not have to worry about the "
"details, as this step will be performed for you. Under the hood, Godot may "
"use more complex forms of interpolation, but linear interpolation is the "
"easiest in terms of explanation."
msgstr ""
"雖然這裡解釋了數學原理，但你不需要擔心細節，因為這個步驟會自動為你執行。在底"
"層，Godot 可能會使用更複雜的差值運算，但線性差值就解釋而言是最容易理解的。"

msgid "The physics interpolation fraction"
msgstr "物理插值比例"

msgid ""
"If our physics ticks are happening 10 times per second (for this example), "
"what happens if our rendered frame takes place at time 0.12 seconds? We can "
"do some math to figure out where the object would be to obtain a smooth "
"motion between the two ticks."
msgstr ""
"如果我們的物理更新頻率是每秒 10 次（以這個例子來說），那麼當我們的算繪畫面發"
"生在 0.12 秒時會發生什麼事？我們可以做一些數學運算來找出物件在兩個物理更新之"
"間應該在哪個位置，以獲得平滑的運動。"

msgid ""
"First of all, we have to calculate how far through the physics tick we want "
"the object to be. If the last physics tick took place at 0.1 seconds, we are "
"0.02 seconds *(0.12 - 0.1)* through a tick that we know will take 0.1 "
"seconds (10 ticks per second). The fraction through the tick is thus:"
msgstr ""
"首先，我們必須計算物件在物理更新的哪個時間點。如果上次物理更新發生在 0.1 秒，"
"那麼我們目前處於一個已知會耗時 0.1 秒（每秒 10 次更新）的更新週期中的 0.02 "
"秒 *(0.12 - 0.1)*。因此，這個更新週期所經過的比例是："

msgid ""
"This is called the **physics interpolation fraction**, and is handily "
"calculated for you by Godot. It can be retrieved on any frame by "
"calling :ref:`Engine.get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>`."
msgstr ""
"這稱為 **物理內插比例** ，Godot 會方便地為您計算好。您可以在任何影格中透過呼"
"叫 :ref:`Engine.get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>` "
"來取得這個數值。"

msgid "Calculating the interpolated position"
msgstr "計算插值後的位置"

msgid ""
"Once we have the interpolation fraction, we can insert it into a standard "
"linear interpolation equation. The X coordinate would thus be:"
msgstr ""
"一旦我們取得插值比例，就可以將其代入標準的線性插值方程式。因此，X 座標會是："

msgid "So substituting our ``x_prev`` as 10, and ``x_curr`` as 30:"
msgstr "因此，將我們的 ``x_prev`` 代入 10，且 ``x_curr`` 代入 30："

msgid "Let's break that down:"
msgstr "讓我們逐步解析："

msgid ""
"We know the X starts from the coordinate on the previous tick (``x_prev``) "
"which is 10 units."
msgstr ""
"我們知道 X 軸是從前一個刻度 (``x_prev``) 的座標開始，該座標是 10 個單位。"

msgid ""
"We know that after the full tick, the difference between the current tick "
"and the previous tick will have been added (``x_curr - x_prev``) (which is "
"20 units)."
msgstr ""
"我們知道在完整物理幀之後，目前物理幀和前一個物理幀之間的差值（ ``x_curr - "
"x_prev`` ）將會被加上（也就是 20 個單位）。"

msgid ""
"The only thing we need to vary is the proportion of this difference we add, "
"according to how far we are through the physics tick."
msgstr ""
"我們唯一需要調整的是加入這個差異的比例，取決於我們在物理更新週期中的進度。"

msgid ""
"Although this example interpolates the position, the same thing can be done "
"with the rotation and scale of objects. It is not necessary to know the "
"details as Godot will do all this for you."
msgstr ""
"雖然這個範例是針對位置進行插值，但物體的旋轉和縮放也能以相同方式處理。不需要"
"了解細節，Godot 會為您處理所有這些事情。"

msgid "Smoothed transformations between physics ticks?"
msgstr "物理更新間的平滑變形？"

msgid ""
"Putting all this together shows that it should be possible to have a nice "
"smooth estimation of the transform of objects between the current and "
"previous physics tick."
msgstr ""
"總結以上所述，這表示應該可以對物件在目前和前一個物理週期之間的變換進行良好且"
"平滑的估算。"

msgid ""
"But wait, you may have noticed something. If we are interpolating between "
"the current and previous ticks, we are not estimating the position of the "
"object *now*, we are estimating the position of the object in the past. To "
"be exact, we are estimating the position of the object *between 1 and 2 "
"ticks* into the past."
msgstr ""
"等等，您可能已經注意到一些事情。如果我們是在目前和前一個影格之間進行插值，我"
"們並非在估算物件「現在」的位置，而是在估算物件「過去」的位置。更精確地說，我"
"們估算的是物件在「過去 1 到 2 個影格之間」的位置。"

msgid "In the past"
msgstr "過去"

msgid ""
"What does this mean? This scheme does work, but it does mean we are "
"effectively introducing a delay between what we see on the screen, and where "
"the objects *should* be."
msgstr ""
"這是什麼意思？這個方法確實可行，但這也表示我們實際上會在螢幕上看到的畫面，和"
"物件 *應該* 在的位置之間，引入一個延遲。"

msgid ""
"In practice, most people won't notice this delay, or rather, it is typically "
"not *objectionable*. There are already significant delays involved in games, "
"we just don't typically notice them. The most significant effect is there "
"can be a slight delay to input, which can be a factor in fast twitch games. "
"In some of these fast input situations, you may wish to turn off physics "
"interpolation and use a different scheme, or use a high tick rate, which "
"mitigates these delays."
msgstr ""
"實際上，大多數人不會注意到這個延遲，或者更確切地說，它通常 **不會令人反感"
"** 。遊戲中本來就存在顯著的延遲，只是我們通常不會察覺。最主要的影響是輸入可能"
"會有一點延遲，這在需要快速反應的遊戲中可能會是一個考量因素。在某些需要快速輸"
"入的情況下，您可能會希望關閉物理插值並使用不同的方案，或者使用較高的更新頻率"
"（tick rate），這樣可以減輕這些延遲。"

msgid "Why look into the past? Why not predict the future?"
msgstr "為何回顧過去？為何不預測未來？"

msgid ""
"There is an alternative to this scheme, which is: instead of interpolating "
"between the previous and current tick, we use maths to *extrapolate* into "
"the future. We try to predict where the object *will be*, rather than show "
"it where it was. This can be done and may be offered as an option in future, "
"but there are some significant downsides:"
msgstr ""
"這個方案有個替代做法：不是在先前和目前的刻度之間進行內插，而是使用數學來 *外"
"插* 到未來。我們嘗試預測物體 *將會* 在哪裡，而不是顯示它過去在哪裡。這可以做"
"到，未來也可能作為一個選項提供，但存在一些顯著的缺點："

msgid ""
"The prediction may not be correct, especially when an object collides with "
"another object during the physics tick."
msgstr "預測可能不準確，尤其是在物理更新時物件與其他物件發生碰撞的情況下。"

msgid ""
"Where a prediction was incorrect, the object may extrapolate into an "
"\"impossible\" position, like inside a wall."
msgstr "當預測不正確時，物件可能會外插到「不可能」的位置，像是牆壁裡面。"

msgid ""
"Providing the movement speed is slow, these incorrect predictions may not be "
"too much of a problem."
msgstr "如果移動速度不快，這些不正確的預測可能不會是太大的問題。"

msgid ""
"When a prediction was incorrect, the object may have to jump or snap back "
"onto the corrected path. This can be visually jarring."
msgstr ""
"當預測不正確時，物件可能需要跳躍或突然彈回修正後的路徑。這在視覺上可能會很突"
"兀。"

msgid "Fixed timestep interpolation"
msgstr "固定時間步差值"

msgid ""
"In Godot this whole system is referred to as physics interpolation, but you "
"may also hear it referred to as **\"fixed timestep interpolation\"**, as it "
"is interpolating between objects moved with a fixed timestep (physics ticks "
"per second). In some ways the second term is more accurate, because it can "
"also be used to interpolate objects that are not driven by physics."
msgstr ""
"在 Godot 中，這個完整的系統稱為物理內插，但您也可能聽過它被稱為 **「固定時間"
"步內插」** ，因為它是基於以固定時間步（每秒物理更新次數）移動的物件之間進行內"
"插。在某些方面，第二個名稱更準確，因為它也可以用於內插非物理驅動的物件。"

msgid ""
"Although physics interpolation is usually a good choice, there are "
"exceptions where you may choose not to use Godot's built-in physics "
"interpolation (or use it in a limited fashion). An example category is "
"internet multiplayer games. Multiplayer games often receive tick or timing "
"based information from other players or a server and these may not coincide "
"with local physics ticks, so a custom interpolation technique can often be a "
"better fit."
msgstr ""
"雖然物理插值通常是不錯的選擇，但有些例外情況您可能會選擇不使用 Godot 內建的物"
"理插值（或僅限部分使用）。一個例子是網路多人遊戲。多人遊戲經常從其他玩家或伺"
"服器接收基於時間或時序的資訊，這些資訊可能與本地物理更新不同步，因此自訂的插"
"值技術通常會更適合。"
