#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced physics interpolation"
msgstr "進階物理插值"

msgid ""
"Although the previous instructions will give satisfactory results in a lot "
"of games, in some cases you will want to go a stage further to get the best "
"possible results and the smoothest possible experience."
msgstr ""
"前述方法在多數遊戲中都能得到令人滿意的效果，但有些情況下你可能會希望進一步調"
"整，以獲得最佳和最流暢的體驗。"

msgid "Exceptions to automatic physics interpolation"
msgstr "自動物理插值的例外情境"

msgid ""
"Even with physics interpolation active, there may be some local situations "
"where you would benefit from disabling automatic interpolation for "
"a :ref:`Node<class_Node>` (or branch of "
"the :ref:`SceneTree<class_SceneTree>`), and have the finer control of "
"performing interpolation manually."
msgstr ""
"即使啟用了物理插值，某些情況下你可能會希望為某個 :ref:`Node<class_Node>`（或"
"某個 :ref:`SceneTree<class_SceneTree>` 分支）關閉自動插值，改由自己手動控制插"
"值行為。"

msgid ""
"This is possible using "
"the :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"property which is present in all Nodes. If you for example, turn off "
"interpolation for a Node, the children will recursively also be affected (as "
"they default to inheriting the parent setting). This means you can easily "
"disable interpolation for an entire subscene."
msgstr ""
"你可以透過每個節點都具備"
"的 :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"屬性來達成。例如，如果你對一個節點關閉插值，所有子節點預設也會繼承這個設定，"
"這樣就能輕鬆為整個子場景關閉物理插值。"

msgid ""
"The most common situation where you may want to perform your own "
"interpolation is Cameras."
msgstr "最常見需要手動插值的情境就是攝影機。"

msgid "Cameras"
msgstr "攝影機"

msgid ""
"In many cases, a :ref:`Camera3D<class_Camera3D>` can use automatic "
"interpolation just like any other node. However, for best results, "
"especially at low physics tick rates, it is recommended that you take a "
"manual approach to camera interpolation."
msgstr ""
"在許多情況下，:ref:`Camera3D<class_Camera3D>` 可以像其他節點一樣使用自動插"
"值。但為了獲得最佳效果（尤其在低物理更新率下），建議你對攝影機手動進行插值。"

msgid ""
"This is because viewers are very sensitive to camera movement. For instance, "
"a Camera3D that realigns slightly every 1/10th of a second (at 10tps tick "
"rate) will often be noticeable. You can get a much smoother result by moving "
"the camera each frame in ``_process``, and following an interpolated target "
"manually."
msgstr ""
"這是因為玩家對攝影機移動極為敏感。例如，若 Camera3D 每 1/10 秒才微調一次（10 "
"TPS 時），這種突兀跳動很容易被察覺。你可以在 ``_process`` 中每個畫面更新時手"
"動移動攝影機，並自行插值追蹤目標，這樣效果會流暢許多。"

msgid "Manual camera interpolation"
msgstr "手動攝影機插值"

msgid "Ensure the camera is using global coordinate space"
msgstr "確保攝影機使用全域座標空間"

msgid ""
"The very first step when performing manual camera interpolation is to make "
"sure the Camera3D transform is specified in *global space* rather than "
"inheriting the transform of a moving parent. This is because feedback can "
"occur between the movement of a parent node of a Camera3D and the movement "
"of the camera Node itself, which can mess up the interpolation."
msgstr ""
"你要手動插值攝影機時，第一步是確保 Camera3D 的變換是在*全域座標* 下進行，而不"
"是繼承自移動的父節點。否則，父節點移動與攝影機本身的移動會互相干擾，導致插值"
"出現異常。"

msgid "There are two ways of doing this:"
msgstr "有兩種方式可以這樣做："

msgid ""
"Move the Camera3D so it is independent on its own branch, rather than being "
"a child of a moving object."
msgstr "將 Camera3D 移到自己的分支，使其不再是移動物件的子節點。"

msgid ""
"Call :ref:`Node3D.top_level<class_Node3D_property_top_level>` and set this "
"to ``true``, which will make the Camera ignore the transform of its parent."
msgstr ""
"呼叫 :ref:`Node3D.top_level<class_Node3D_property_top_level>` 並設為 "
"``true``，這樣攝影機就會忽略父節點的變換。"

msgid "Typical example"
msgstr "常見範例"

msgid ""
"A typical example of a custom approach is to use the ``look_at`` function in "
"the Camera3D every frame in ``_process()`` to look at a target node (such as "
"the player)."
msgstr ""
"常見的自訂方式是，每個畫面更新時在 Camera3D 的 ``_process()`` 中呼叫 "
"``look_at``，讓攝影機持續盯著目標節點（例如玩家）。"

msgid ""
"But there is a problem. If we use the traditional ``get_global_transform()`` "
"on a Camera3D \"target\" node, this transform will only focus the Camera3D "
"on the target *at the current physics tick*. This is *not* what we want, as "
"the camera will jump about on each physics tick as the target moves. Even "
"though the camera may be updated each frame, this does not help give smooth "
"motion if the *target* is only changing each physics tick."
msgstr ""
"但這裡有個問題：如果我們對 Camera3D 的目標節點直接用傳統的 "
"``get_global_transform()``，那麼攝影機只會對準目標在*當前物理更新*的座標。這"
"不是我們想要的，因為目標每次物理更新才變動一次，攝影機看起來還是會跳躍。即使"
"攝影機每個畫面都更新，若目標只在物理刻度才移動，還是無法獲得平滑畫面。"

msgid "get_global_transform_interpolated()"
msgstr "get_global_transform_interpolated()"

msgid ""
"What we really want to focus the camera on, is not the position of the "
"target on the physics tick, but the *interpolated* position, i.e. the "
"position at which the target will be rendered."
msgstr ""
"我們其實希望攝影機追蹤的，是目標的*插值座標*，也就是畫面上實際算繪時的座標，"
"而非僅是物理更新時的座標。"

msgid ""
"We can do this using "
"the :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"function. This acts exactly like "
"getting :ref:`Node3D.global_transform<class_Node3D_property_global_transform>` "
"but it gives you the *interpolated* transform (during a ``_process()`` call)."
msgstr ""
"可以透"
"過 :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"來取得插值後的變換。這個方法"
"和 :ref:`Node3D.global_transform<class_Node3D_property_global_transform>` 類"
"似，但會在 ``_process()`` 期間取得*插值* 變換。"

msgid ""
"``get_global_transform_interpolated()`` should only be used once or twice "
"for special cases such as cameras. It should **not** be used all over the "
"place in your code (both for performance reasons, and to give correct "
"gameplay)."
msgstr ""
"``get_global_transform_interpolated()`` 僅建議用於像攝影機這類特殊情境，一般"
"遊戲邏輯不應大量使用（不論是考量效能還是確保遊戲行為正確）。"

msgid ""
"Aside from exceptions like the camera, in most cases, your game logic should "
"be in ``_physics_process()``. In game logic you should be calling "
"``get_global_transform()`` or ``get_transform()``, which will give the "
"current physics transform (in global or local space respectively), which is "
"usually what you will want for gameplay code."
msgstr ""
"除了攝影機等極少數例外，大部分遊戲邏輯都應該寫在 ``_physics_process()`` 裡，"
"並使用 ``get_global_transform()`` 或 ``get_transform()`` 取得物理更新時的變換"
"（全域/區域），這才是遊戲邏輯通常需要的資訊。"

msgid "Example manual camera script"
msgstr "手動攝影機腳本範例"

msgid ""
"Here is an example of a simple fixed camera which follows an interpolated "
"target:"
msgstr "以下是一個簡易的固定攝影機範例，會追蹤插值過的目標："

msgid "Mouse look"
msgstr "滑鼠視角"

msgid ""
"Mouse look is a very common way of controlling cameras. But there is a "
"problem. Unlike keyboard input which can be sampled periodically on the "
"physics tick, mouse move events can come in continuously. The camera will be "
"expected to react and follow these mouse movements on the next frame, rather "
"than waiting until the next physics tick."
msgstr ""
"滑鼠視角（Mouse look）是很常見的攝影機控制方式。但它有個問題：鍵盤輸入可以每"
"個物理更新取樣，但滑鼠移動事件是連續發生的，玩家預期攝影機能即時跟隨滑鼠移"
"動，而不是等到下個物理更新才反應。"

msgid ""
"In this situation, it can be better to disable physics interpolation for the "
"camera node "
"(using :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"and directly apply the mouse input to the camera rotation, rather than apply "
"it in ``_physics_process``."
msgstr ""
"在這種情況，建議針對攝影機節點關閉物理插值（透"
"過 :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`），"
"直接在每幀將滑鼠輸入應用於攝影機旋轉，而非僅在 ``_physics_process`` 處理。"

msgid ""
"Sometimes, especially with cameras, you will want to use a combination of "
"interpolation and non-interpolation:"
msgstr "有時候（尤其是攝影機）你可能會想混合插值與非插值操作："

msgid ""
"A first person camera may position the camera at a player location (perhaps "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"but control the Camera rotation from mouse look *without* interpolation."
msgstr ""
"第一人稱攝影機可以用插值方式對齊玩家位置（例如"
"用 :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`），"
"但攝影機旋轉則直接用滑鼠控制，*不進行插值*。"

msgid ""
"A third person camera may similarly determine the look at (target location) "
"of the camera "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"but position the camera using mouse look *without* interpolation."
msgstr ""
"第三人稱攝影機類似，可以透"
"過 :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"取得目標座標（look at），但攝影機本身的位置則用滑鼠視角直接控制，不進行插值。"

msgid ""
"There are many permutations and variations of camera types, but it should be "
"clear that in many cases, disabling automatic physics interpolation and "
"handling this yourself can give a better result."
msgstr ""
"攝影機型態有許多變化，不過可以看出很多情境下，手動管理插值、關閉自動插值能得"
"到更好的結果。"

msgid "Disabling interpolation on other nodes"
msgstr "關閉其他節點的插值"

msgid ""
"Although cameras are the most common example, there are a number of cases "
"when you may wish other nodes to control their own interpolation, or be non-"
"interpolated. Consider for example, a player in a top view game whose "
"rotation is controlled by mouse look. Disabling physics rotation allows the "
"player rotation to match the mouse in real-time."
msgstr ""
"雖然攝影機是最常見的例子，但有時你也會希望其他節點自行管理插值、甚至完全不插"
"值。舉例來說，上視角遊戲的玩家角色旋轉是由滑鼠視角控制的，此時將物理旋轉插值"
"關閉，就能讓角色旋轉即時對應滑鼠操作。"

msgid "MultiMeshes"
msgstr "MultiMeshes（多重網格）"

msgid ""
"Although most visual Nodes follow the single Node single visual instance "
"paradigm, MultiMeshes can control several instances from the same Node. "
"Therefore, they have some extra functions for controlling interpolation "
"functionality on a *per-instance* basis. You should explore these functions "
"if you are using interpolated MultiMeshes."
msgstr ""
"多數視覺節點都是一個節點對應一個可見實例，但 MultiMeshes 可以在單一節點下控制"
"多個實例。因此，它額外提供了針對*各個實例*控制插值的功能。如果你使用插值功能"
"的 MultiMeshes，建議深入了解這些 API。"

msgid ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"
msgstr ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"

msgid ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"
msgstr ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"

msgid ""
"Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation."
msgstr "詳細資訊請參閱 :ref:`MultiMesh<class_MultiMesh>` 文件。"
