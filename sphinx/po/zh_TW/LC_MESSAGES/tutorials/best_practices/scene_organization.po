#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "場景組織"

msgid "How to build relationships effectively"
msgstr "如何有效地建立關係"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "當 Godot 使用者開始製作自己的場景時，通常會遇到下列問題："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"建立好第一個場景並往場景中加上內容，最後會開始覺得場景逐漸變得複雜，應該要把"
"東西都切割成小塊，所以就將場景中的各個分支都保存為獨立的場景。但是，接著就會"
"發現之前在腳本裡直接引用其他節點的方法不能用了。在多個地方重複使用場景也會出"
"問題，因為沒辦法用節點路徑找到目標，然後在編輯器中建的訊號連接也會斷開。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"OOP 中要考慮的最重要的一點就是要維持一個專注且單一目的的類別，並與程式碼中其"
"他部分 `鬆散耦合 <https://zh.wikipedia.org/zh-tw/"
"%E6%9D%BE%E8%80%A6%E5%90%88>`_ 。這樣可以讓物件的大小維持得比較小 (為了可維護"
"性) 並提高類別的可用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "這些 OOP 最佳實踐在場景結構與腳本使用上實際是 **數種** 最佳實踐。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"若場景必須要與外部的東西互動，則有經驗的工程師推薦使用 `依賴注入 <https://zh."
"wikipedia.org/zh-tw/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_ 。這個技術是使用"
"高等 API 來提動低等 API 的相依性。為什麼要這麼做？因為仰賴外部環境的類別可能"
"會不小心觸發 Bug 或未預期的行為。"

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"連接訊號。非常安全，但訊號應該只用來「回覆」一個行為，而不是執行行為。請注"
"意，訊號名稱通常使用過去式動詞，如「entered」、「skill_activated」或"
"「item_collected」。"

msgid "Call a method. Used to start behavior."
msgstr "呼叫方法。用於開始一個行為。"

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`FuncRef <class_FuncRef>` 屬性。比使用方法來得安全，因為不需在意"
"方法的所有權。用來開始行為。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 參照。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"像這樣的 GUI 可以更好的通知專案使用者有關節點的重要訊息。節點有外部相依性嗎？"
"相依性有滿足嗎？其他的程式設計師，尤其是設計師與作家，會需要更清楚的指示來瞭"
"解如何正確設定這些節點。"

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr ""
"節點與場景，作為引擎類別的延伸，應該要能套用 **所有** OOP 原則。這些原則的例"
"子包含..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr ""
"`SOLID <https://zh.wikipedia.org/zh-tw/"
"SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr ""
"`DRY <https://zh.wikipedia.org/zh-tw/"
"%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://zh.wikipedia.org/zh-tw/KISS%E5%8E%9F%E5%88%99>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr ""
"`YAGNI (英文) <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "選擇一種節點樹架構"

msgid "Node \"Main\" (main.gd)"
msgstr "Node「Main」(main.gd)"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D “世界”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control「GUI」(gui.gd)"

msgid "tracks all of its data internally"
msgstr "能在內部追蹤所有的資料"

msgid "should be globally accessible"
msgstr "可以在所有地方存取"

msgid "should exist in isolation"
msgstr "獨立存在"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"to swap out the main scene's content. This structure more or less keeps the "
"\"World\" as the main game node."
msgstr ""
"對於比較小的遊戲，有另一種控制比較少東西的替代方案為用一個只呼叫 :ref:"
"`SceneTree.change_scene() <class_SceneTree_method_change_scene>` 的「Game」單"
"例來切換主要場景的內容。這種結構或多或少將「World」場景作為主要遊戲節點保留。"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "可信的第三方，可能是母節點，來居中分配。"

msgid "Add a \"player\" node to a \"room\"."
msgstr "將「玩家」節點加到「房間」中。"

msgid "Move the player somewhere else in the tree."
msgstr "將玩家移動到樹狀結構中其他地方。"

msgid "Delete the room."
msgstr "刪除房間。"

msgid "Instantiate and add the new room."
msgstr "實體化並建立新的房間。"

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "沒有必須要寫成文件並在其他地方維護的「特例」。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "不會因為沒有注意到細節而有發生錯誤的機會。"

msgid ""
"The **imperative** solution: Use the ``top_level`` property for the :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**指令式** 解法：在 :ref:`CanvasItem "
"<class_CanvasItem_method_set_as_toplevel>` 或 :ref:`Spatial "
"<class_Spatial_method_set_as_toplevel>` 上使用 ``set_as_toplover`` Setter。這"
"樣一來便可讓節點忽略其繼承的變換。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"場景組織的關鍵就是要以關聯的方式來考量 SceneTree 而不是用空間性來考量。節點是"
"否會仰賴母節點的存在？若不仰賴，則節點可以就完全可以在別的地方活得好好的。若"
"有依賴母節點，則這種依賴關係就是子節點要是母節點的子節點的原因 (而且，顯然必"
"須是母節點的場景中的一部分，如果還不是母節點的場景中的一部分的話)。"
