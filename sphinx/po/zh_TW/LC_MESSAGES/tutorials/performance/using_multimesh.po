#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using MultiMeshes"
msgstr "使用 MultiMesh 進行優化"

msgid ""
"For large amount of instances (in the thousands), that need to be constantly "
"processed (and certain amount of control needs to be retained), :ref:`using "
"servers directly <doc_using_servers>` is the recommended optimization."
msgstr ""
"對於大量的實例(成千上萬), 需要不斷處理(需要保留一定的控制), 建議優化 :ref:`直"
"接使用服務 <doc_using_servers>` ."

msgid ""
"When the amount of objects reach the hundreds of thousands or millions, none "
"of these approaches are efficient anymore. Still, depending on the "
"requirements, there is one more optimization possible."
msgstr ""
"當物件數量達到數十萬或數百萬時, 這些方法都不再有效. 儘管如此, 根據要求, 還有"
"另一種可能的優化方法."

msgid "MultiMeshes"
msgstr "MultiMeshes（多重網格）"

msgid ""
"A :ref:`MultiMesh<class_MultiMesh>` is a single draw primitive that can draw "
"up to millions of objects in one go. It's extremely efficient because it "
"uses the GPU hardware to do this."
msgstr ""
":ref:`MultiMesh<class_MultiMesh>` 是一個單次繪製的像素，可以一次性繪製多達數"
"百萬個物件。它的效率非常高，因為它使用 GPU 硬體來做這件事（不過在 OpenGL ES "
"2.0 中，它的效率較低，因為沒有硬體支援）。"

msgid ""
"The only drawback is that there is no *screen* or *frustum* culling possible "
"for individual instances. This means, that millions of objects will be "
"*always* or *never* drawn, depending on the visibility of the whole "
"MultiMesh. It is possible to provide a custom visibility rect for them, but "
"it will always be *all-or-none* visibility."
msgstr ""
"唯一的缺點是, 對於單個實例, 不可能進行 *螢幕* 或 *視錐* 剔除. 這意味著, 根據"
"整個MultiMesh的可見性, 數百萬個物件將被 *始終* 或 *不會* 繪製. 可以為它們提供"
"一個自訂的可見性矩形, 但它將始終是 *全或無* 的可見性."

msgid ""
"If the objects are simple enough (just a couple of vertices), this is "
"generally not much of a problem as most modern GPUs are optimized for this "
"use case. A workaround is to create several MultiMeshes for different areas "
"of the world."
msgstr ""
"如果物件足夠簡單(只有幾個頂點), 這通常不是什麼大問題, 因為大多數現代GPU都為這"
"種用例進行了優化. 一個變通的方法是為世界的不同區域建立多個MultiMeshes."

msgid ""
"It is also possible to execute some logic inside the vertex shader (using "
"the ``INSTANCE_ID`` or ``INSTANCE_CUSTOM`` built-in constants). For an "
"example of animating thousands of objects in a MultiMesh, see "
"the :ref:`Animating thousands of fish <doc_animating_thousands_of_fish>` "
"tutorial. Information to the shader can be provided via textures (there are "
"floating-point :ref:`Image<class_Image>` formats which are ideal for this)."
msgstr ""
"也可以在頂點著色器中執行一些邏輯(使用 ``INSTANCE_ID`` 或 ``INSTANCE_CUSTOM`` "
"內建常數). 關於在MultiMesh中對數千個物件進行動畫製作的例子, 請參"
"見 :ref:`Animating thousands of fish <doc_animating_thousands_of_fish>` 教"
"學. 可以通過紋理向著色器提供資訊(有浮點 :ref:`Image<class_Image>` 格式是理想"
"的格式)."

msgid ""
"Another alternative is to use a GDExtension and C++, which should be "
"extremely efficient (it's possible to set the entire state for all objects "
"using linear memory via the :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>` function). This way, "
"the array can be created with multiple threads, then set in one call, "
"providing high cache efficiency."
msgstr ""
"另一個選擇是使用 GDExtension 和 C++，這通常非常高效（你可以"
"用 :ref:`RenderingServer.multimesh_set_buffer() "
"<class_RenderingServer_method_multimesh_set_buffer>` 函式，透過線性記憶體一次"
"設定所有物件狀態）。如此能用多執行緒產生陣列，然後一次設定，快取效率極高。"

msgid ""
"Finally, it's not required to have all MultiMesh instances visible. The "
"amount of visible ones can be controlled with "
"the :ref:`MultiMesh.visible_instance_count "
"<class_MultiMesh_property_visible_instance_count>` property. The typical "
"workflow is to allocate the maximum amount of instances that will be used, "
"then change the amount visible depending on how many are currently needed."
msgstr ""
"最後, 並不是所有的MultiMesh實例都必須是可見的. 可以通"
"過 :ref:`MultiMesh.visible_instance_count "
"<class_MultiMesh_property_visible_instance_count>` 屬性來控制可見的數量. 典型"
"的工作流程是先分配最大數量的實例, 然後根據目前需要的數量改變可見的數量."

msgid "Multimesh example"
msgstr "計時器範例"

msgid ""
"Here is an example of using a MultiMesh from code. Languages other than "
"GDScript may be more efficient for millions of objects, but for a few "
"thousands, GDScript should be fine."
msgstr ""
"這裡是一個從程式碼中使用MultiMesh的例子.GDScript以外的其他語言對於數百萬個物"
"件來說可能更有效, 但對於幾千個物件來說,GDScript應該是可以的."
