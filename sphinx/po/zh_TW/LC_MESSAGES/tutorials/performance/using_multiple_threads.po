#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using multiple threads"
msgstr "使用多執行緒"

msgid "Threads"
msgstr "執行緒"

msgid ""
"Threads allow simultaneous execution of code. It allows off-loading work "
"from the main thread."
msgstr "執行緒允許程式碼同時執行，可將工作從主執行緒分離出去執行。"

msgid "Godot supports threads and provides many handy functions to use them."
msgstr "Godot 支援執行緒，並提供許多方便操作的功能。"

msgid ""
"If using other languages (C#, C++), it may be easier to use the threading "
"classes they support."
msgstr ""
"如果你使用其他語言（如 C#、C++），建議直接使用它們提供的執行緒類別會更方便。"

msgid ""
"Before using a built-in class in a thread, read :ref:`doc_thread_safe_apis` "
"first to check whether it can be safely used in a thread."
msgstr ""
"在執行緒中使用內建類別之前，請先閱讀 :ref:`doc_thread_safe_apis`，確認該類別"
"是否可安全用於多執行緒。"

msgid "Creating a Thread"
msgstr "建立執行緒"

msgid "To create a thread, use the following code:"
msgstr "要建立執行緒，請使用以下程式碼："

msgid ""
"Your function will, then, run in a separate thread until it returns. Even if "
"the function has returned already, the thread must collect it, so "
"call :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`, "
"which will wait until the thread is done (if not done yet), then properly "
"dispose of it."
msgstr ""
"此時你的函式將會在獨立的執行緒中執行，直到結束為止。即使函式已經結束，該執行"
"緒還是需要回收，因此必須呼"
"叫 :ref:`Thread.wait_to_finish()<class_Thread_method_wait_to_finish>`，它會等"
"待執行緒完成（如果尚未完成），然後正確釋放資源。"

msgid ""
"Creating threads is a slow operation, especially on Windows. To avoid "
"unnecessary performance overhead, make sure to create threads before heavy "
"processing is needed instead of creating threads just-in-time."
msgstr ""
"建立執行緒是一個較慢的操作，特別是在 Windows 系統上。為了避免不必要的效能損"
"耗，應該在需要大量處理之前先建立好執行緒，而不是臨時才建立。"

msgid ""
"For example, if you need multiple threads during gameplay, you can create "
"threads while the level is loading and only actually start processing with "
"them later on."
msgstr ""
"舉例來說，如果遊戲進行時需要多個執行緒，可以在關卡載入階段先建立執行緒，之後"
"再開始讓它們處理任務。"

msgid ""
"Additionally, locking and unlocking of mutexes can also be an expensive "
"operation. Locking should be done carefully; avoid locking too often (or for "
"too long)."
msgstr ""
"另外，鎖定與解鎖 Mutex 也會消耗效能。應謹慎進行鎖定，避免過於頻繁或長時間的鎖"
"定。"

msgid "Mutexes"
msgstr "Mutex（互斥鎖）"

msgid ""
"Accessing objects or data from multiple threads is not always supported (if "
"you do it, it will cause unexpected behaviors or crashes). Read "
"the :ref:`doc_thread_safe_apis` documentation to understand which engine "
"APIs support multiple thread access."
msgstr ""
"從多個執行緒存取物件或資料並不總是被支援（如果這麼做，可能會導致非預期行為或"
"當機）。請閱讀 :ref:`doc_thread_safe_apis` 文件，瞭解哪些引擎 API 支援多執行"
"緒存取。"

msgid ""
"When processing your own data or calling your own functions, as a rule, try "
"to avoid accessing the same data directly from different threads. You may "
"run into synchronization problems, as the data is not always updated between "
"CPU cores when modified. Always use a :ref:`Mutex<class_Mutex>` when "
"accessing a piece of data from different threads."
msgstr ""
"當你處理自己的資料或呼叫自己的函式時，原則上應避免不同執行緒直接存取同一份資"
"料。這樣做可能會遇到同步問題，因為資料在 CPU 核心間並不一定會即時更新。從多個"
"執行緒存取同一資料時，請務必使用 :ref:`Mutex<class_Mutex>`。"

msgid ""
"When calling :ref:`Mutex.lock()<class_Mutex_method_lock>`, a thread ensures "
"that all other threads will be blocked (put on suspended state) if they try "
"to *lock* the same mutex. When the mutex is unlocked by "
"calling :ref:`Mutex.unlock()<class_Mutex_method_unlock>`, the other threads "
"will be allowed to proceed with the lock (but only one at a time)."
msgstr ""
"當呼叫 :ref:`Mutex.lock()<class_Mutex_method_lock>` 時，該執行緒會確保其他執"
"行緒如果試圖 *鎖定* 同一個 mutex，就會被阻擋（進入暫停狀態）。當使"
"用 :ref:`Mutex.unlock()<class_Mutex_method_unlock>` 解鎖時，其他執行緒將可以"
"繼續鎖定（但一次只會有一個執行緒取得鎖定）。"

msgid "Here is an example of using a Mutex:"
msgstr "以下是一個使用 Mutex 的範例："

msgid "Semaphores"
msgstr "Semaphore（訊號量）"

msgid ""
"Sometimes you want your thread to work *\"on demand\"*. In other words, tell "
"it when to work and let it suspend when it isn't doing anything. For "
"this, :ref:`Semaphores<class_Semaphore>` are used. The "
"function :ref:`Semaphore.wait()<class_Semaphore_method_wait>` is used in the "
"thread to suspend it until some data arrives."
msgstr ""
"有時你希望執行緒能夠「按需」工作。換句話說，你會指定什麼時候讓它工作，沒事時"
"自動暫停。這時可以使用 :ref:`Semaphore<class_Semaphore>`。在執行緒中呼"
"叫 :ref:`Semaphore.wait()<class_Semaphore_method_wait>` 來讓它暫停，直到有資"
"料到來。"

msgid ""
"The main thread, instead, "
"uses :ref:`Semaphore.post()<class_Semaphore_method_post>` to signal that "
"data is ready to be processed:"
msgstr ""
"主執行緒則會呼叫 :ref:`Semaphore.post()<class_Semaphore_method_post>` 來通知"
"資料已經準備好要被處理："
