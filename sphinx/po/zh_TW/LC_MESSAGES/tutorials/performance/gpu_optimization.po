#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "GPU 最佳化"

msgid "Introduction"
msgstr "前言"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"對於新圖形功能與進步的需求，幾乎可以確定你會遇到圖形瓶頸。有些瓶頸可能發生在 "
"CPU 端，例如 Godot 引擎內部為算繪物件所做的計算。有時瓶頸也可能出現在圖形驅動"
"程式的 CPU 部分，負責整理並傳遞指令給 GPU，或是指令傳輸過程中。最終，瓶頸也會"
"發生在 GPU 本身。"

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"算繪時瓶頸出現的位置高度依賴於硬體。特別是行動裝置上的 GPU，可能會對於桌面端"
"能輕鬆運作的場景感到吃力。"

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"理解並分析 GPU 瓶頸與 CPU 上的情況略有不同。這是因為你通常只能透過改變給 GPU "
"的指令來間接調整效能。此外，量測起來也較困難。在許多情況下，唯一能衡量效能的"
"方式就是觀察每個影格的算繪時間變化。"

msgid "Draw calls, state changes, and APIs"
msgstr "繪圖呼叫、狀態切換與 API"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"以下內容雖然與終端使用者無直接關聯，但能協助理解後續章節所需的背景知識。"

msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"Godot 透過圖形 API（Vulkan、OpenGL、OpenGL ES 或 WebGL）向 GPU 發送指令。這些"
"溝通與驅動處理會消耗不少資源，特別是在 OpenGL、OpenGL ES 與 WebGL 上。如果我"
"們能以驅動程式和 GPU 最佳化的方式給予指令，則可以大幅提升效能。"

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"在 OpenGL 中，幾乎每個 API 指令都必須做一定的驗證，以確保 GPU 處於正確狀態。"
"即使是看似簡單的指令，也會引發大量幕後的管理作業。因此，我們的目標是將這些指"
"令減至最低，並盡可能將相似的物件分組，以便一起算繪，或以最少的昂貴狀態切換完"
"成。"

msgid "2D batching"
msgstr "2D 批次處理（Batching）"

msgid "3D batching"
msgstr "3D 批次處理（Batching）"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"在 3D 算繪中，我們同樣希望減少繪圖呼叫與狀態切換。不過，將多個 3D 物件合併成"
"單一繪圖呼叫會更困難。3D 網格通常包含數百到數千個三角形，實時合併大型網格的成"
"本極高。隨著每個網格三角形數增加，合併的效益很快就被成本抵銷。一個更好的做法"
"是**事先將網格合併**（即靜態物件之間的合併），可以由美術人員在 DCC 工具中完"
"成，也可在 Godot 內透過外掛程式自動化。"

msgid ""
"For more information on 3D specific optimizations, "
"see :ref:`doc_optimizing_3d_performance`."
msgstr ""
"如需更多 3D 特定最佳化資訊，請參考 :ref:`doc_optimizing_3d_performance`。"

msgid "Reuse shaders and materials"
msgstr "重複利用著色器與材質"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"Godot 的算繪器設計與其他引擎略有不同，目標是盡量減少 GPU 狀態切"
"換。 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 能在需要相似著色器"
"時有效重複利用材質。如果你使用自訂著色器，也請儘可能進行重複利用。Godot 的優"
"化優先順序如下："

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"**重複利用材質：** 場景中材質種類越少，算繪速度就越快。如果場景中物件數量龐大"
"（數百到數千），應盡可能共用材質。最糟情況下，可使用圖集（atlas）來減少紋理切"
"換次數。"

msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"**重複利用著色器：** 如果材質無法共用，至少要嘗試共用著色器。注意：只要 "
"StandardMaterial3D 設定相同（例如核取方塊開關的功能），即使參數不同，Godot 也"
"會自動共用同一份著色器。"

msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"假設一個場景有 20,000 個物件、每個物件都用不同材質，算繪效能會非常低。如果同"
"樣的場景只有 100 種材質共用，算繪就會快許多。"

msgid "Pixel cost versus vertex cost"
msgstr "像素成本 vs 頂點成本"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"你可能聽說過模型的多邊形數越少，算繪速度就越快。這事實上只是 *相對而言*，還牽"
"涉許多其他因素。"

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"在現代 PC 與主機上，頂點成本其實很低。早期的 GPU 只算繪三角形，這意謂著每個影"
"格："

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr "所有頂點都必須由 CPU 處理（包括裁切/clipping）。"

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr "所有頂點都必須從主記憶體傳送到 GPU 記憶體。"

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"現在這一切都在 GPU 內部處理，效能大幅提升。3D 美術常誤以為多邊形數會嚴重拖慢"
"效能，是因為 3D 建模軟體（如 Blender、3ds Max 等）為了編輯方便，必須將幾何資"
"料留在 CPU 記憶體，導致效能較差。遊戲引擎則大多將運算交由 GPU，因此可更高效地"
"算繪大量三角形。"

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"在行動裝置上則不同。PC 和主機的 GPU 可以無限制地從電網取得電力，屬於高效能"
"型；而行動 GPU 受限於小型電池，必須極度講究效能與耗能。"

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"為了提升效率，行動 GPU 會盡量避免 *重複繪製（overdraw）*。所謂 overdraw，是指"
"螢幕上同一像素被多次算繪。例如一個小鎮有多棟建築，GPU 無法預先知道哪些遮擋哪"
"些，必須先算繪後判斷。假設一棟房子先被畫出來，後又有另一棟房子在前方遮住，導"
"致同一像素被算繪兩次。PC GPU 通常不太在意這點，只要加更多像素處理器來彌補（但"
"會消耗更多電力）。"

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"在行動裝置上無法無限制用電，因此大多採用 *圖塊式算繪（Tile-based rendering）"
"* 技術，將螢幕劃分為網格，每個格子會記錄哪些三角形要繪製，並根據深度排序以減"
"少 overdraw。這種技術提升了效能並降低功耗，但會犧牲頂點處理效能，導致每次可算"
"繪的頂點與三角形數量變少。"

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"此外，圖塊式算繪在螢幕局部有大量幾何細節的小物件時效率會大幅下降。這會造成單"
"一圖塊負載過重，其他區域必須等待該圖塊算繪完成才能顯示影格，導致整體效能降"
"低。"

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"總結來說，在行動裝置上不用太擔心頂點總數，而是要**避免頂點過度集中在螢幕某一"
"小區域**。若角色、NPC、車輛等距離很遠（在螢幕上很小），應降低 LOD（細節層"
"級）。即使在桌面端，也避免讓三角形小於螢幕一個像素的大小。"

msgid "Pay attention to the additional vertex processing required when using:"
msgstr "使用以下功能時，請留意額外的頂點運算成本："

msgid "Skinning (skeletal animation)"
msgstr "蒙皮（骨骼動畫）"

msgid "Morphs (shape keys)"
msgstr "變形（形狀鍵）"

msgid "Vertex-lit objects (common on mobile)"
msgstr "頂點光照物件（行動裝置常見）"

msgid "Pixel/fragment shaders and fill rate"
msgstr "像素/片元著色器與填充速率（Fill Rate）"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"相較於頂點運算，片元（像素）著色的成本近年來大幅提升。螢幕解析度從 640×480 "
"VGA（僅 307,200 像素）躍升到 4K（8,294,400 像素），面積暴增 27 倍！加上現代物"
"理式算繪（PBR）導致片元著色器極度複雜，每個像素都需繁複運算。"

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"你可以很容易測試專案是否受填充速率限制。請先關閉 V-Sync（避免 FPS 被上限限"
"制），然後比較大視窗與極小視窗下的 FPS。如果有用到陰影，試著減小陰影貼圖尺"
"寸。通常你會發現小視窗時 FPS 大幅提升，代表你受限於填充速率；若提升有限，瓶頸"
"則在其他地方。"

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the "
"number and size of textures used. Also, when using non-unshaded particles, "
"consider forcing vertex shading in their material to decrease the shading "
"cost."
msgstr ""
"若專案受限於填充速率，可透過減少 GPU 負擔來提升效能，比如簡化著色器（若"
"是 :ref:`StandardMaterial3D <class_StandardMaterial3D>`，可關閉高成本選項）、"
"減少紋理數量與尺寸。若粒子不是 Unshaded，建議在材質中強制使用頂點著色模式"
"（vertex shading），以降低著色成本。"

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""
"在支援的硬體上，可利用 :ref:`doc_variable_rate_shading` 降低著色運算成本，同"
"時又不會影響最終影像的邊緣銳利度。"

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr "**針對行動裝置開發時，建議盡可能使用最簡單的著色器。**"

msgid "Reading textures"
msgstr "紋理讀取"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"片元著色器的另一個成本在於紋理讀取。讀取紋理本身就很耗效能，若在單一著色器中"
"讀取多張紋理則成本更高。另外，紋理過濾（如 mipmap 間的三線性過濾與平均）也會"
"進一步拖慢速度。對於行動裝置，紋理讀取除了效能外，也會顯著增加耗電。"

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"**如果你使用第三方著色器或自行撰寫著色器，請盡量選擇需要最少紋理讀取的演算"
"法。**"

msgid "Texture compression"
msgstr "紋理壓縮"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"Godot 預設在匯入 3D 紋理時會採用顯示記憶體（VRAM）壓縮。這種壓縮儲存體積雖然"
"不如 PNG 或 JPG 有效，但在繪製大型紋理時能大幅提升效能。"

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr "這是因為紋理壓縮的主要目標是減少記憶體與 GPU 間的頻寬消耗。"

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"在 3D 算繪中，物件的形狀主要取決於幾何形狀，因此壓縮對畫面影響較小；而在 2D，"
"紋理內的細節與形狀較重要，所以壓縮產生的失真與雜訊會更明顯。"

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"請注意，大多數 Android 裝置不支援帶透明度的紋理壓縮（僅支援不透明），請務必留"
"意。"

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"即使在 3D 場景下，「像素美術」紋理也應停用 VRAM 壓縮，因為壓縮會明顯影響畫面"
"品質，而低解析度本身並不會帶來顯著效能提升。"

msgid "Post-processing and shadows"
msgstr "後製處理與陰影"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"後製特效與陰影在片元著色階段同樣非常耗資源。務必在不同硬體上測試這些效果對效"
"能的影響。"

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
"**降低陰影貼圖（shadowmap）大小能明顯提升效能**，無論是寫入還是讀取都一樣。此"
"外，最佳化陰影效能最有效的方法，就是盡量減少有陰影的燈光與物件。對於較小或較"
"遠的全域光（OmniLight）/聚光燈（SpotLight），通常可以直接關閉陰影而對畫面影響"
"極小。"

msgid "Transparency and blending"
msgstr "透明與混合"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"透明物件對算繪效能有特殊挑戰。不透明物件（特別在 3D 裡）可以用任何順序算繪，"
"Z 緩衝區會自動保證最前面的物件被正確著色；但透明或混合物件則無法用 Z 緩衝排"
"序，必須改用「畫家演算法」（painter's order，從後往前繪製）才能正確顯示。"

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"透明物件對填充速率的影響也特別嚴重，因為每個圖層都要被算繪，即使後面還會被其"
"他透明物件覆蓋。"

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"不透明物件則不會有這個問題，因為可以利用 Z 緩衝區，先寫入 Z 值，再只對最前方"
"（勝出）的像素進行片元著色器運算。"

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"當多個透明物件重疊時，效能成本尤其高。通常，應盡量縮小透明區域以減低填充速率"
"需求，這點在行動裝置上尤其重要。許多情況下，直接算繪較複雜的不透明幾何體，反"
"而比用透明材質「取巧」來得有效率。"

msgid "Multi-platform advice"
msgstr "跨平台建議"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"如果你計畫跨平台發行，請務必 *及早* 、 *頻繁* 地在所有目標平台進行測試，特別"
"是行動裝置。只在桌面端開發，最後才臨時移植到行動裝置，幾乎注定會遇到災難。"

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"一般來說，應以最低通用規格設計遊戲，再針對高階平台額外加入進階特效。例如，若"
"同時支援桌面與行動平台，可考慮都採用「相容性算繪模式」來確保效能。"

msgid "Mobile/tiled renderers"
msgstr "行動裝置／圖塊式算繪器"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"如前所述，行動裝置的 GPU 運作機制與桌機大不相同。多數行動裝置採用圖塊式算繪器"
"（Tile Renderer），將螢幕劃分為固定大小的區塊並存入快取，以減少對主記憶體的讀"
"寫次數。"

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"但圖塊式算繪也有缺點，某些技術會變得更複雜且低效。若圖塊之間需要互相依賴（如"
"跨圖塊運算）或必須保留前一輪算繪結果，效能會大幅降低。因此，請務必仔細測試著"
"色器、視窗紋理與後製效果在行動裝置上的效能表現。"
