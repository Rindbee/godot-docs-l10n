#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimization using Servers"
msgstr "使用伺服器進行最佳化"

msgid ""
"Engines like Godot provide increased ease of use thanks to their high-level "
"constructs and features. Most of them are accessed and used via "
"the :ref:`Scene System<doc_scene_tree>`. Using nodes and resources "
"simplifies project organization and asset management in complex games."
msgstr ""
"像 Godot 這樣的引擎，因為高階的架構與功能，讓使用上更為方便。大多數功能都是透"
"過 :ref:`場景系統 <doc_scene_tree>` 來存取與使用。利用節點和資源可簡化大型遊"
"戲的專案結構與資產管理。"

msgid "There are, of course, always drawbacks:"
msgstr "當然，也有一些缺點："

msgid "There is an extra layer of complexity."
msgstr "會增加一層額外的複雜度。"

msgid "Performance is lower than when using simple APIs directly."
msgstr "效能會比直接使用底層 API 來得低。"

msgid "It is not possible to use multiple threads to control them."
msgstr "無法直接利用多執行緒來控制它們。"

msgid "More memory is needed."
msgstr "需要消耗更多記憶體。"

msgid ""
"In many cases, this is not really a problem (Godot is very optimized, and "
"most operations are handled with signals, so no polling is required). Still, "
"sometimes it can be. For example, dealing with tens of thousands of "
"instances for something that needs to be processed every frame can be a "
"bottleneck."
msgstr ""
"在多數情況下這不算太大問題（Godot 本身已高度最佳化，大部分操作也都是透過訊號"
"處理，無需反覆輪詢）。但在某些情境下就會成為瓶頸，例如同時需要在每一影格處理"
"數萬個實例時。"

msgid ""
"This type of situation makes programmers regret they are using a game engine "
"and wish they could go back to a more handcrafted, low-level implementation "
"of game code."
msgstr ""
"這種情況有時會讓開發者懷念手寫底層程式碼的時光，甚至後悔選擇了遊戲引擎，希望"
"能回到更手工、低階的遊戲實作方式。"

msgid "Still, Godot is designed to work around this problem."
msgstr "不過，Godot 的設計其實能解決這類問題。"

msgid ""
"You can see how using low-level servers works in action using the `Bullet "
"Shower demo project <https://github.com/godotengine/godot-demo-projects/tree/"
"master/2d/bullet_shower>`__"
msgstr ""
"你可以參考 `Bullet Shower 範例專案 <https://github.com/godotengine/godot-"
"demo-projects/tree/master/2d/bullet_shower>`__ 來觀察如何實際運用底層伺服器 "
"API"

msgid "Servers"
msgstr "伺服器"

msgid ""
"One of the most interesting design decisions for Godot is the fact that the "
"whole scene system is *optional*. While it is not currently possible to "
"compile it out, it can be completely bypassed."
msgstr ""
"Godot 最有趣的設計決策之一，就是整個場景系統其實是*可選*的。雖然目前沒辦法在"
"編譯時完全移除，但你完全可以選擇不使用它。"

msgid ""
"At the core, Godot uses the concept of Servers. They are very low-level APIs "
"to control rendering, physics, sound, etc. The scene system is built on top "
"of them and uses them directly. The most common servers are:"
msgstr ""
"Godot 核心採用『伺服器』的概念。這些伺服器提供非常底層的 API，負責控制算繪、"
"物理、音訊等功能。場景系統就是建立在這些伺服器之上。最常見的伺服器有："

msgid ""
":ref:`RenderingServer <class_RenderingServer>`: handles everything related "
"to graphics."
msgstr ""
":ref:`RenderingServer <class_RenderingServer>`：處理所有與圖形、算繪相關的功"
"能。"

msgid ""
":ref:`PhysicsServer3D <class_PhysicsServer3D>`: handles everything related "
"to 3D physics."
msgstr ""
":ref:`PhysicsServer3D <class_PhysicsServer3D>`：處理所有 3D 物理相關功能。"

msgid ""
":ref:`PhysicsServer2D <class_PhysicsServer2D>`: handles everything related "
"to 2D physics."
msgstr ""
":ref:`PhysicsServer2D <class_PhysicsServer2D>`：處理所有 2D 物理相關功能。"

msgid ""
":ref:`AudioServer <class_AudioServer>`: handles everything related to audio."
msgstr ":ref:`AudioServer <class_AudioServer>`：處理所有音訊相關功能。"

msgid ""
"Explore their APIs and you will realize that all the functions provided are "
"low-level implementations of everything Godot allows you to do."
msgstr ""
"你可以研究這些伺服器的 API，會發現它們所提供的功能，其實就是 Godot 所有高階操"
"作的底層實作。"

msgid "RIDs"
msgstr "RID"

msgid ""
"The key to using servers is understanding Resource ID (:ref:`RID "
"<class_RID>`) objects. These are opaque handles to the server "
"implementation. They are allocated and freed manually. Almost every function "
"in the servers requires RIDs to access the actual resource."
msgstr ""
"要使用伺服器，最重要的是理解『Resource ID』（:ref:`RID <class_RID>`）物件。這"
"些 RID 就是對伺服器內部資源的控制碼，需要手動分配與釋放。幾乎所有伺服器函式都"
"需要透過 RID 來存取實際資源。"

msgid ""
"Most Godot nodes and resources contain these RIDs from the servers "
"internally, and they can be obtained with different functions. In fact, "
"anything that inherits :ref:`Resource <class_Resource>` can be directly "
"casted to an RID. Not all resources contain an RID, though: in such cases, "
"the RID will be empty. The resource can then be passed to server APIs as an "
"RID."
msgstr ""
"大多數 Godot 節點與資源內部都持有來自伺服器的 RID，可以透過不同函式取得。其實"
"所有繼承自 :ref:`Resource <class_Resource>` 的物件，都可以直接轉換為 RID。但"
"並非所有資源都有 RID，這時 RID 會是空的。不過你仍然可以將這些資源作為 RID 傳"
"給伺服器 API。"

msgid ""
"Resources are reference-counted (see :ref:`RefCounted <class_RefCounted>`), "
"and references to a resource's RID are *not* counted when determining "
"whether the resource is still in use. Make sure to keep a reference to the "
"resource outside the server, or else both it and its RID will be erased."
msgstr ""
"資源是引用計數的（參見 :ref:`RefCounted <class_RefCounted>`），但指向資源 "
"RID 的引用*不會*被計入引用數。請務必在伺服器之外保留對資源本身的參考，否則資"
"源與其 RID 都會被釋放。"

msgid "For nodes, there are many functions available:"
msgstr "對於節點，有許多函式可以取得相關 RID："

msgid ""
"For CanvasItem, the :ref:`CanvasItem.get_canvas_item() "
"<class_CanvasItem_method_get_canvas_item>` method will return the canvas "
"item RID in the server."
msgstr ""
"對於 CanvasItem，可以使用 :ref:`CanvasItem.get_canvas_item() "
"<class_CanvasItem_method_get_canvas_item>` 方法，取得伺服器中該畫布項目的 "
"RID。"

msgid ""
"For CanvasLayer, the :ref:`CanvasLayer.get_canvas() "
"<class_CanvasLayer_method_get_canvas>` method will return the canvas RID in "
"the server."
msgstr ""
"對於 CanvasLayer，可使用 :ref:`CanvasLayer.get_canvas() "
"<class_CanvasLayer_method_get_canvas>` 方法取得伺服器中的 Canvas RID。"

msgid ""
"For Viewport, the :ref:`Viewport.get_viewport_rid() "
"<class_Viewport_method_get_viewport_rid>` method will return the viewport "
"RID in the server."
msgstr ""
"對於 Viewport，可用 :ref:`Viewport.get_viewport_rid() "
"<class_Viewport_method_get_viewport_rid>` 取得伺服器中的視口 RID。"

msgid ""
"For 3D, the :ref:`World3D <class_World3D>` resource (obtainable in "
"the :ref:`Viewport <class_Viewport>` and :ref:`Node3D <class_Node3D>` nodes) "
"contains functions to get the *RenderingServer Scenario*, and the "
"*PhysicsServer Space*. This allows creating 3D objects directly with the "
"server API and using them."
msgstr ""
"在 3D 中，:ref:`World3D <class_World3D>` 資源（可在 :ref:`Viewport "
"<class_Viewport>` 及 :ref:`Node3D <class_Node3D>` 節點取得）提供函式以取得 "
"*RenderingServer Scenario* 及 *PhysicsServer Space*。這讓你可以直接用伺服器 "
"API 建立 3D 物件並操作。"

msgid ""
"For 2D, the :ref:`World2D <class_World2D>` resource (obtainable in "
"the :ref:`Viewport <class_Viewport>` and :ref:`CanvasItem "
"<class_CanvasItem>` nodes) contains functions to get the *RenderingServer "
"Canvas*, and the *Physics2DServer Space*. This allows creating 2D objects "
"directly with the server API and using them."
msgstr ""
"在 2D 中，:ref:`World2D <class_World2D>` 資源（可於 :ref:`Viewport "
"<class_Viewport>` 及 :ref:`CanvasItem <class_CanvasItem>` 節點取得）提供函式"
"以取得 *RenderingServer Canvas* 及 *Physics2DServer Space*。這讓你可以直接用"
"伺服器 API 建立 2D 物件並操作。"

msgid ""
"The :ref:`VisualInstance3D<class_VisualInstance3D>` class, allows getting "
"the scenario *instance* and *instance base* via "
"the :ref:`VisualInstance3D.get_instance() "
"<class_VisualInstance3D_method_get_instance>` "
"and :ref:`VisualInstance3D.get_base() "
"<class_VisualInstance3D_method_get_base>` respectively."
msgstr ""
":ref:`VisualInstance3D<class_VisualInstance3D>` 類別，可分別透"
"過 :ref:`VisualInstance3D.get_instance() "
"<class_VisualInstance3D_method_get_instance>` "
"與 :ref:`VisualInstance3D.get_base() "
"<class_VisualInstance3D_method_get_base>` 取得場景 *instance* 與 *instance "
"base*。"

msgid ""
"Try exploring the nodes and resources you are familiar with and find the "
"functions to obtain the server *RIDs*."
msgstr ""
"建議你多嘗試探索熟悉的節點與資源，看看能從哪些函式取得對應的伺服器 *RID*。"

msgid ""
"It is not advised to control RIDs from objects that already have a node "
"associated. Instead, server functions should always be used for creating and "
"controlling new ones and interacting with the existing ones."
msgstr ""
"不建議直接操作已經關聯節點的物件的 RID。要建立或控制新的資源，或與現有資源互"
"動，應該都直接使用伺服器函式來處理。"

msgid "Creating a sprite"
msgstr "建立 Sprite"

msgid ""
"This is an example of how to create a sprite from code and move it using the "
"low-level :ref:`CanvasItem <class_CanvasItem>` API."
msgstr ""
"以下範例展示如何用程式碼建立一個精靈（Sprite），並透過底層 :ref:`CanvasItem "
"<class_CanvasItem>` API 來移動它。"

msgid ""
"The Canvas Item API in the server allows you to add draw primitives to it. "
"Once added, they can't be modified. The Item needs to be cleared and the "
"primitives re-added (this is not the case for setting the transform, which "
"can be done as many times as desired)."
msgstr ""
"伺服器中的 CanvasItem API 允許你向其新增繪圖基本圖元。一旦新增後無法修改，如"
"需變更必須先清除再重新新增（但設定 transform 則不受此限制，可任意次數變更）。"

msgid "Primitives are cleared this way:"
msgstr "清除圖元方式如下："

msgid "Instantiating a Mesh into 3D space"
msgstr "在 3D 空間中產生網格實體"

msgid ""
"The 3D APIs are different from the 2D ones, so the instantiation API must be "
"used."
msgstr "3D 的 API 與 2D 不同，因此必須使用專屬的產生實體 API。"

msgid "Creating a 2D RigidBody and moving a sprite with it"
msgstr "建立 2D 剛體並用它移動精靈"

msgid ""
"This creates a :ref:`RigidBody2D <class_RigidBody2D>` using "
"the :ref:`PhysicsServer2D <class_PhysicsServer2D>` API, and moves "
"a :ref:`CanvasItem <class_CanvasItem>` when the body moves."
msgstr ""
"這會透過 :ref:`PhysicsServer2D <class_PhysicsServer2D>` API 建立一"
"個 :ref:`RigidBody2D <class_RigidBody2D>`，並在剛體移動時同步移動一"
"個 :ref:`CanvasItem <class_CanvasItem>`。"

msgid ""
"The 3D version should be very similar, as 2D and 3D physics servers are "
"identical (using :ref:`RigidBody3D <class_RigidBody3D>` "
"and :ref:`PhysicsServer3D <class_PhysicsServer3D>` respectively)."
msgstr ""
"3D 版本也大同小異，因為 2D 與 3D 物理伺服器的用法幾乎一致（分別使"
"用 :ref:`RigidBody3D <class_RigidBody3D>` 與 :ref:`PhysicsServer3D "
"<class_PhysicsServer3D>`）。"

msgid "Getting data from the servers"
msgstr "從伺服器取得資料"

msgid ""
"Try to **never** request any information from ``RenderingServer``, "
"``PhysicsServer2D`` or ``PhysicsServer3D`` by calling functions unless you "
"know what you are doing. These servers will often run asynchronously for "
"performance and calling any function that returns a value will stall them "
"and force them to process anything pending until the function is actually "
"called. This will severely decrease performance if you call them every frame "
"(and it won't be obvious why)."
msgstr ""
"除非你非常確定自己在做什麼，否則**千萬不要**直接呼叫 ``RenderingServer``、"
"``PhysicsServer2D`` 或 ``PhysicsServer3D`` 來請求資料。這些伺服器通常為了效能"
"是非同步執行的，任何會回傳數值的函式呼叫都會造成伺服器暫停，強制等待所有待處"
"理事項完成再回傳結果。如果你每一幀都這樣呼叫，效能會大幅下降，而且原因可能不"
"明顯。"

msgid ""
"Because of this, most APIs in such servers are designed so it's not even "
"possible to request information back, until it's actual data that can be "
"saved."
msgstr ""
"因此，這類伺服器的大多數 API 設計時，通常根本不允許直接回傳資訊，除非是要取得"
"可儲存的實際資料。"
