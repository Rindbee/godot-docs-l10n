#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "CPU 最佳化"

msgid "Measuring performance"
msgstr "效能量測"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"想要加速程式，我們必須先找出「瓶頸」在哪裡。瓶頸是指限制整體進度的最慢區段。"
"專注於瓶頸可以讓我們集中精力優化最能帶來顯著效能提升的部分，而不是花大量時間"
"在只會帶來微小提升的功能上。"

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr "對於 CPU 而言，找出瓶頸最簡單的方法就是使用效能分析器（Profiler）。"

msgid "CPU profilers"
msgstr "CPU 剖析器"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr "剖析器會與你的程式同時執行，並量測每個函式所花費的時間比例。"

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"Godot 編輯器內建了方便的剖析器。它不會在每次啟動專案時自動執行，必須手動啟動"
"與停止。這是因為，和多數剖析器一樣，記錄這些時序資料會顯著拖慢你的專案速度。"

msgid "After profiling, you can look back at the results for a frame."
msgstr "剖析結束後，你可以回顧單一影格的結果。"

msgid "Screenshot of the Godot profiler"
msgstr "Godot 剖析器截圖"

msgid "Results of a profile of one of the demo projects."
msgstr "其中一個範例專案的剖析結果。"

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"我們可以看到內建流程（像是物理和音訊）的耗時，也能在下方看到自訂腳本函式的耗"
"時。"

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr "等候各種內建伺服器的時間可能不會被剖析器計算在內。這是已知的 bug。"

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"當專案執行緩慢時，通常會看到某個明顯的函式或流程用時遠高於其他部分。這就是你"
"的主要瓶頸，通常只要優化這個區段，就能明顯提升效能。"

msgid ""
"For more info about using Godot's built-in profiler, "
"see :ref:`doc_debugger_panel`."
msgstr "更多關於 Godot 內建剖析器的資訊，請參考 :ref:`doc_debugger_panel`。"

msgid "External profilers"
msgstr "外部剖析器"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"雖然 Godot 編輯器內建的剖析器非常方便實用，但有時候你可能需要更強大的功能，例"
"如針對 Godot 引擎本身的原始碼進行剖析。"

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"你可以 :ref:`使用多款第三方 C++ 剖析器 <doc_using_cpp_profilers>` 來達成這個"
"目的。"

msgid "Screenshot of Callgrind"
msgstr "Callgrind 截圖"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "這是 Valgrind 套件中 Callgrind 的剖析結果範例。"

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"從左至右，Callgrind 依序列出函式本身及其子函式執行時間比例（Inclusive），僅函"
"式本身執行時間比例（Self），呼叫次數，函式名稱，以及所在檔案或模組。"

msgid ""
"In this example, we can see nearly all time is spent under the "
"``Main::iteration()`` function. This is the master function in the Godot "
"source code that is called repeatedly. It causes frames to be drawn, physics "
"ticks to be simulated, and nodes and scripts to be updated. A large "
"proportion of the time is spent in the functions to render a canvas (66%), "
"because this example uses a 2D benchmark. Below this, we see that almost 50% "
"of the time is spent outside Godot code in ``libglapi`` and ``i965_dri`` "
"(the graphics driver). This tells us the a large proportion of CPU time is "
"being spent in the graphics driver."
msgstr ""
"在這個例子中，我們可以看到幾乎所有時間都耗在 ``Main::iteration()`` 這個函式"
"下。這是 Godot 原始碼裡會反覆呼叫的主迴圈函式，負責觸發影格繪製、物理模擬、節"
"點與腳本的更新。本例因為是 2D 基準測試，有 66% 的時間花在畫布算繪相關函式。再"
"往下看，近 50% 的時間花在 Godot 以外的 ``libglapi`` 與 ``i965_dri`` （顯示卡"
"驅動）。這顯示出大量 CPU 時間都消耗在圖形驅動上。"

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"這其實是很好的案例，因為理論上，圖形驅動理應占用極少比例的 CPU 時間。這表示圖"
"形 API 存在過多資料傳遞與工作負擔。這次剖析實驗促成 2D 批次處理技術的誕生，大"
"幅減少該區段瓶頸，進而提升 2D 算繪效能。"

msgid "Manually timing functions"
msgstr "手動量測函式效能"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"另一個實用技巧，尤其是在你用剖析器找出瓶頸後，就是手動量測特定函式或區段的執"
"行時間。做法會依語言而異，在 GDScript 中你可以這樣做："

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"手動量測函式時，建議將函式重複執行多次（例如 1,000 次以上），而非只測一次（除"
"非該函式極慢）。這是因為計時器精度有限，而且 CPU 行程排程具有隨機性。因此，取"
"多次平均值會比單次結果準確許多。"

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"試圖優化函式時，務必反覆進行剖析或量測，才能獲得關鍵回饋，了解優化是否真的奏"
"效。"

msgid "Caches"
msgstr "快取（Cache）"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"CPU 快取（Cache）是你在比較兩個函式版本效能時務必留意的重點。結果往往取決於資"
"料是否已經在快取中。雖然系統記憶體（RAM）比 CPU 快取大很多（以 GB 計而快取僅"
"數 MB），但 CPU 不會直接從 RAM 讀取，因為 RAM 存取速度很慢。CPU 會先從較小、"
"但更快的快取記憶體存取資料。如果資料已在快取，載入速度極快；但若載入位址不在"
"快取，就必須從主記憶體慢慢載入，造成 CPU 長時間閒置，這種狀況稱為「快取未命中"
"（cache miss）」。"

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"這代表第一次執行某個函式時，可能會很慢，因為資料還沒進入 CPU 快取。之後再執行"
"可能會快很多，因為資料已經在快取裡了。因此計時時務必取多次平均值，並注意快取"
"帶來的影響。"

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"理解快取機制對 CPU 效能最佳化也非常關鍵。如果你的演算法（或常式）會隨機從主記"
"憶體各處讀取零碎資料，很容易發生大量快取未命中，讓 CPU 大多時間都在等資料而無"
"法運作。若能讓資料存取更具在地性，或最好使用線性（連續）存取（像連續陣列），"
"快取效果就能發揮到最大，CPU 運作效率也會顯著提升。"

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"Godot 通常會自動幫你處理這些底層細節。例如伺服器 API 已針對算繪和物理等資料做"
"快取優化。不過，在撰寫 GDExtension 等原生擴充程式時，你還是要特別注意快取機"
"制。"

msgid "Languages"
msgstr "程式語言"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"Godot 支援多種語言，各有優缺點。有些語言為了易用性而犧牲速度，有些則速度快但"
"較難使用。"

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"無論你選擇哪種腳本語言，Godot 內建引擎函式的速度都一樣。但如果你的專案有大量"
"自訂運算，建議考慮用更快的語言來處理這些運算。"

msgid "GDScript"
msgstr "GDScript"

msgid "C#"
msgstr "C#"

msgid "Other languages"
msgstr "其他語言"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"社群也提供多種其他語言的支援，例如 `Rust <https://github.com/godot-rust/"
"gdext>`_。"

msgid "C++"
msgstr "C++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"Godot 是用 C++ 編寫的，使用 C++ 通常能帶來最快效能。但實務上，C++ 專案在跨平"
"台部署時最為困難。C++ 擴充方式有 GDExtension 及 :ref:`自訂模組 "
"<doc_custom_modules_in_cpp>`。"

msgid "Threads"
msgstr "執行緒"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"如果你的運算可平行處理，建議善用「執行緒」。現代 CPU 多為多核心，各核心可同時"
"處理不同工作。將運算分散到多執行緒，能更有效發揮 CPU 效率。"

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"執行緒的缺點是必須小心避免競爭狀態（Race Condition）。每個 CPU 核心獨立運作，"
"可能同時存取同一記憶體位置。一個執行緒可能正在讀取變數，另一個則在寫入，這就"
"是 *競爭狀態*。在使用多執行緒之前，請務必瞭解相關風險與預防方式，因為多執行緒"
"會讓除錯難度大幅提升。"

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr "更多關於執行緒的詳細資訊，請參閱 :ref:`doc_using_multiple_threads`。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"節點（Node）雖然非常強大且彈性高，但每個節點都會帶來效能負擔。像 "
"``_process()``、``_physics_process()`` 等內建函式會遍歷整個樹狀結構。當你的專"
"案包含大量節點時（數千至數萬，依平台而異），這些管理開銷會大幅影響效能。建議"
"開發時務必針對所有目標平台進行效能檢測與剖析。"

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"Godot 算繪器會逐一處理每個節點，因此減少節點數、將更多內容集中在單一節點，效"
"能表現會更佳。"

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later "
"using :ref:`Node.add_child(node) <class_Node_method_add_child>`. This can be "
"very useful for adding and removing areas from a game, for example."
msgstr ""
":ref:`SceneTree <class_SceneTree>` 有個特性：你可以將節點從場景樹移除（而非只"
"暫停或隱藏），這樣效能會更好。你不一定要刪除該節點——例如可以保留節點參考，"
"用 :ref:`Node.remove_child(node) <class_Node_method_remove_child>` 拆下，之後"
"再用 :ref:`Node.add_child(node) <class_Node_method_add_child>` 加回來。這對於"
"切換遊戲區域等場景非常實用。"

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"你也可以選擇完全不用 SceneTree，直接用 Server API 處理。詳情請參"
"見 :ref:`doc_using_servers`。"

msgid "Physics"
msgstr "物理"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"在某些情境下，物理運算會成為主要瓶頸。尤其是世界龐大或有大量物理物件時更是如"
"此。"

msgid "Here are some techniques to speed up physics:"
msgstr "以下是提升物理效能的幾個技巧："

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"碰撞形狀建議用簡化版幾何圖形。這通常對玩家來說感覺不到差異，但能大幅提升效"
"能。"

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"當物件離開畫面或當前區域時，可以暫時將它們從物理世界移除，或重複利用物理物件"
"（例如每個區域只需 8 隻怪物時就重用這 8 隻）。"

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"物理運算的另一個重點是「物理更新頻率」（tick rate）。某些遊戲可以將更新頻率從"
"每秒 60 次降到 30 次甚至 20 次，這能大幅減輕 CPU 負擔。"

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"調整物理更新頻率的缺點是，當更新頻率與算繪影格速率不一致時，容易出現卡頓或抖"
"動，而且降低更新頻率會增加輸入延遲。若遊戲需要即時玩家操作，建議維持預設 "
"60Hz 物理更新頻率。"
