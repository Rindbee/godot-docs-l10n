#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Reducing stutter from shader (pipeline) compilations"
msgstr "減少著色器（管線）編譯造成的卡頓"

msgid ""
"Pipeline compilation, also commonly known as shader compilation, is an "
"expensive operation required by the engine to be able to draw any kind of "
"content with the GPU."
msgstr ""
"管線編譯，也常被稱為著色器編譯，是引擎為了讓 GPU 能繪製各種內容所需的一個高成"
"本運算步驟。"

msgid ""
"Flowchart showing the entire compilation process for a shader: VisualShader "
"and Standard Material to Godot Shading Language to GLSL to Intermediate "
"Format (SPIR-V) to Pipeline. Shader Compilation is the GLSL to Intermediate "
"Format step. Pipeline Compilation is the Intermediate Format to Pipeline "
"step."
msgstr ""
"流程圖顯示著色器完整的編譯過程：由 VisualShader 和標準材質，經由 Godot 著色語"
"言轉為 GLSL，再轉為中介格式（如 SPIR-V），最後生成管線。著色器編譯是 GLSL 轉"
"為中介格式這一步，管線編譯則是中介格式轉為管線這一步。"

msgid ""
"Shaders and materials in Godot go through several steps before they can be "
"run by the GPU."
msgstr "Godot 中的著色器與材質，在能夠由 GPU 執行前，需要經過多個步驟處理。"

msgid ""
"In more precise terms, *shader compilation* involves the translation of the "
"GLSL code that Godot generates into an intermediate format that can be "
"shared across systems (such as SPIR-V when using Vulkan). However, this "
"format can't be used by the GPU directly."
msgstr ""
"更精確地說， *著色器編譯* 指的是將 Godot 產生的 GLSL 程式碼轉換為跨平台可共用"
"的中介格式（如 Vulkan 下的 SPIR-V）。然而，這個中介格式並不能直接由 GPU 使"
"用。"

msgid ""
"*Pipeline compilation* is the step where the GPU driver converts the "
"intermediate shader format (the result from shader compilation) to something "
"the GPU can actually use for rendering. Drivers usually keep a cache of "
"pipelines stored somewhere in the system to avoid repeating the process "
"every time a game is run. This cache is usually deleted when the driver is "
"updated."
msgstr ""
"*管線編譯* 則是 GPU 驅動程式將這個中介格式轉換成 GPU 真正可以用來繪製畫面的格"
"式。驅動程式通常會在系統中某處快取這些管線，以避免每次遊戲執行時都要重新編"
"譯。這個快取在驅動程式更新時通常會被刪除。"

msgid ""
"Pipelines contain more information than just the shader code, which means "
"that for each shader, there can be dozens of pipelines or more! This makes "
"it difficult for an engine to compile them ahead of time, both because it "
"would be very slow, and because it would take up a lot of memory. On top of "
"that, this step can only be performed on the user's system and it is very "
"tough to share the result between users unless they have the exact same "
"hardware and driver version."
msgstr ""
"管線所包含的資訊不僅只有著色器程式碼，因此每個著色器可能會對應數十種甚至更多"
"的管線！這讓引擎很難事先預編譯所有管線，因為這會非常耗時且佔用大量記憶體。此"
"外，這個步驟只能在使用者的系統上執行，除非硬體和驅動版本完全相同，否則結果也"
"難以在不同使用者間共用。"

msgid ""
"Before Godot 4.4, there was no solution to pipeline compilation other than "
"generating them when an object shows up inside the camera's view, leading to "
"the infamous *shader stutter* or hitches that only occur during the first "
"playthrough. **With Godot 4.4, new mechanisms have been introduced to "
"mitigate stutters from pipeline compilation.**"
msgstr ""
"在 Godot 4.4 之前，除了當物件首次進入攝影機視野時才產生管線外，沒有其他解決方"
"式，這導致著名的 *著色器卡頓* ，通常只會在第一次遊玩時發生。**自 Godot 4.4 "
"起，引擎加入了新的機制來降低管線編譯導致的卡頓。**"

msgid ""
"**Ubershaders**: Godot makes use of specialization constants, a feature that "
"allows the driver to optimize a pipeline's code around a set of parameters "
"such as lighting, shadow quality, etc. Specialization constants are used to "
"optimize a shader by limiting unnecessary features. Changing a "
"specialization constant requires recompiling the pipeline. Ubershaders are a "
"special version of the shader that are able to change these constants while "
"rendering, which means Godot can precompile just one pipeline ahead of time "
"and compile the more optimized versions on the background during gameplay. "
"This reduces the amount of pipelines that need to be created significantly."
msgstr ""
"**Ubershaders（超級著色器）**：Godot 利用 specialization constant（特化常數）"
"這個功能，讓驅動程式能以光照、陰影品質等一組參數來最佳化管線程式碼。特化常數"
"可用來限制不必要的功能，藉此最佳化著色器。每當更改特化常數時，就需要重新編譯"
"管線。Ubershaders 是一種特殊版本的著色器，能在渲染時動態變更這些常數，代表 "
"Godot 可以僅預先編譯一個通用管線，並在遊戲運作時於背景中編譯更優化的版本，大"
"幅減少需建立的管線數量。"

msgid ""
"**Pipeline precompilation**: By using ubershaders, the engine can precompile "
"pipelines ahead of time in multiple places such as when meshes are loaded or "
"when nodes are added to the scene. By being part of the resource loading "
"process, pipelines can even be precompiled in multiple background threads if "
"possible during loading screens or even gameplay."
msgstr ""
"**管線預編譯**：藉由使用超級著色器，引擎能在多個時機點預先編譯管線，例如載入"
"網格（Mesh）或新增節點到場景時。將其納入資源載入流程後，這些管線甚至可以在載"
"入畫面或遊戲進行時，由多個背景執行緒並行預編譯。"

msgid ""
"Starting in Godot 4.4, Godot will detect which pipelines are needed and "
"precompile them at load-time. This detection system is mostly automatic, but "
"it relies on the RenderingServer seeing evidence of all shaders, meshes, or "
"rendering features at load-time. For example, if you load a mesh and shader "
"while the game is running, the pipeline for that mesh/shader combination "
"won't be compiled until the mesh/shader is loaded. Similarly, things like "
"enabling MSAA, or instancing a VoxelGI node while the game is running will "
"trigger pipeline recompilations."
msgstr ""
"從 Godot 4.4 起，Godot 會自動偵測所需的管線並在載入時預編譯。這套偵測機制大多"
"是自動化的，但需要 RenderingServer 在載入階段能看到所有著色器、網格或渲染功"
"能。舉例來說，如果你在遊戲執行時才載入某個網格和著色器，那麼這組合的管線直到"
"載入時才會被編譯。同樣地，在遊戲運作時啟用 MSAA 或建立 VoxelGI 節點，也會觸發"
"管線的重新編譯。"

msgid "Pipeline precompilation monitors"
msgstr "管線預編譯監控工具"

msgid ""
"Compiling pipelines ahead of time is the main mechanism Godot uses to "
"mitigate shader stutters, but it's not a perfect solution. Being aware of "
"the situations that can lead to pipeline stutters can be very helpful, and "
"the workarounds are pretty straightforward compared to previous versions. "
"These workarounds may be less necessary over time with future versions of "
"Godot as more detection techniques are implemented."
msgstr ""
"預先編譯管線是 Godot 降低著色器卡頓的主要手段，但這並非萬全之策。瞭解可能導致"
"管線卡頓的情境會很有幫助，且比起舊版 Godot，現在的解決方法也更為直接。隨著 "
"Godot 未來版本導入更多偵測技術，這些臨時解法的重要性也會逐步降低。"

msgid ""
"The Godot debugger offers monitors for tracking the amount of pipelines "
"created by the game and the step that triggered their compilation. You can "
"keep an eye on these monitors as the game runs to identify potential sources "
"of shader stutters without having to wipe your driver cache every time you "
"wish to test. Sudden increases of these values outside of loading screens "
"can show up as hitches during gameplay the first time someone plays the game "
"on their system. **It is recommended you take a look at these monitors to "
"identify possible sources of stutter for your players**, as you might be "
"unable to experience them yourself without deleting your driver cache or "
"testing on a weaker system."
msgstr ""
"Godot 除錯器提供了監控工具，可追蹤遊戲所建立的管線數量，以及觸發編譯的步驟。"
"你可以在遊戲執行時觀察這些監控項目，無需每次都清除驅動快取就能找出潛在的著色"
"器卡頓來源。若這些數值在非載入畫面時突然增加，表示首次遊玩時可能會出現卡頓。"
"**建議你務必檢查這些監控數據，幫助玩家避免卡頓**，因為你自己若未刪除驅動快取"
"或未在較弱硬體上測試，可能無法發現這些問題。"

msgid "Screenshot of the Godot pipeline compilations monitor"
msgstr "Godot 管線編譯監控工具的截圖"

msgid "Pipeline compilations of one of the demo projects."
msgstr "其中一個範例專案的管線編譯結果。"

msgid ""
"We can see the pipelines compiled during gameplay and verify which steps "
"could possibly cause stuttters. Note that these values will only increase "
"and never go down, as deleted pipelines are not tracked by these monitors "
"and pipelines may be erased and recreated during gameplay."
msgstr ""
"我們可以看到遊戲進行時所編譯的管線，並確認哪些步驟可能會導致卡頓。請注意，這"
"些數值只會增加而不會減少，因為這些監控工具不會追蹤已刪除的管線，而管線也可能"
"在遊戲中被刪除並重新建立。"

msgid ""
"**Canvas**: Compiled when drawing a 2D node. The engine does not currently "
"feature precompilation for 2D elements and stutters will show up when the 2D "
"node is drawn for the first time."
msgstr ""
"**Canvas**：在繪製 2D 節點時編譯。目前引擎尚未支援 2D 元素的預編譯，因此首次"
"繪製 2D 節點時仍可能出現卡頓。"

msgid ""
"**Mesh**: Compiled as part of loading a 3D mesh and identifying what "
"pipelines can be precompiled from its properties. These can lead to stutters "
"if a mesh is loaded during gameplay, but they can be mitigated if the mesh "
"is loaded by using a background thread. **Modifiers that are part of nodes "
"such as material overrides can't be compiled on this step**."
msgstr ""
"**Mesh**：在載入 3D 網格時會編譯，並判斷哪些管線能根據其屬性預編譯。如果在遊"
"戲進行時載入網格，可能會導致卡頓，但若在背景執行緒載入則可減輕。**節點上的材"
"質覆蓋等修飾器無法在此步驟預編譯**。"

msgid ""
"**Surface**: Compiled when a frame is about to be drawn and 3D objects were "
"instanced on the scene tree for the first time. This can also include "
"compilation for nodes that aren't even visible on the scene tree. The "
"stutter will occur only on the first frame the node is added to the scene, "
"which won't result in an obvious stutter if it happens right after a loading "
"screen."
msgstr ""
"**Surface**：在準備繪製畫面時，首次將 3D 物件實體化到場景樹時編譯。這也可能包"
"括尚未顯示的節點。只有節點第一次加入場景的那一幀會發生卡頓，如果發生在載入畫"
"面後，通常不會造成明顯卡頓。"

msgid ""
"**Draw**: Compiled on demand when a 3D object needs to be drawn and an "
"ubershader was not precompiled ahead of time. The engine is unable to "
"precompile this pipeline due to triggering a case that hasn't been covered "
"yet or a modification that was done to the engine's code. Leads to stutters "
"during gameplay. This is identical to Godot versions before 4.4. If you see "
"compilations here, please `let the developers know <https://github.com/"
"godotengine/godot/issues>` as this should never happen with the Ubershader "
"system. Make sure to attach a minimal reproduction project when doing so."
msgstr ""
"**Draw**：當 3D 物件需要繪製且未事先預編譯超級著色器時，會隨需編譯。這代表引"
"擎遇到尚未涵蓋的特殊情境或程式碼遭修改，導致無法預編譯管線，進而在遊戲中造成"
"卡頓。這與 Godot 4.4 之前的版本相同。若你發現這裡有編譯發生，請 `回報給開發"
"者 <https://github.com/godotengine/godot/issues>` ，因為在有超級著色器系統下"
"不應出現這情況。回報時請附上最簡化的重現專案。"

msgid ""
"**Specialization**: Compiled in the background during gameplay to optimize "
"the framerate. Unable to cause stutters, but may result in reduced "
"framerates if there are many happening per frame."
msgstr ""
"**Specialization**：於遊戲進行時於背景編譯，以最佳化影格率。這不會造成卡頓，"
"但若每幀發生太多編譯，可能會降低 FPS。"

msgid "Pipeline precompilation features"
msgstr "管線預編譯功能"

msgid ""
"Godot offers a lot of rendering features that are not necessarily used by "
"every game. Unfortunately, pipeline precompilation can't know ahead of time "
"if a particular feature is used by a project. Some of these features can "
"only be detected when a user adds a node to the scene or toggles a "
"particular setting in the project or the environment. The pipeline "
"precompilation system will keep track of these features as they're "
"encountered for the first time and enable precompilation of them for any "
"meshes or surfaces that are created afterwards."
msgstr ""
"Godot 提供了許多渲染功能，但不一定每個遊戲都會用到。不過，管線預編譯無法預先"
"判斷某功能是否會被專案使用。有些功能必須在使用者將節點加入場景或切換專案或環"
"境設定時才會被偵測到。當這些功能首次被偵測到時，管線預編譯系統會記錄下來，往"
"後建立的網格或表面就能預編譯支援這些功能的管線。"

msgid ""
"If your game makes use of these features, **make sure to have an scene that "
"uses them as early as possible** before loading the majority of the assets. "
"This scene can be very simple and will do the job as long as it uses the "
"features the game plans to use. It can even be rendered off-screen for at "
"least one frame if necessary, e.g. by covering it with "
"a :ref:`class_ColorRect` node or using a :ref:`class_SubViewport` located "
"outside the window bounds."
msgstr ""
"如果你的遊戲會用到這些功能，**請務必在載入大部分資產之前，盡早有一個場景啟用"
"這些功能**。這個場景可以很簡單，只要涵蓋未來遊戲會用到的功能即可。如果需要，"
"也可以只讓它在螢幕外被渲染一幀，例如用 :ref:`class_ColorRect` 節點遮住，或用"
"置於視窗外的 :ref:`class_SubViewport`。"

msgid ""
"You should also keep in mind that changing any of these features during "
"gameplay will result in immediate stutters. Make sure to only change these "
"features from configuration screens if necessary and insert loading screens "
"and messages when the changes are applied."
msgstr ""
"此外，遊戲進行時若變更這些功能，將會立即產生卡頓。請確保僅在設定畫面等必要時"
"機才變更這些功能，並在套用變更時插入載入畫面與提示訊息。"

msgid ""
"**MSAA Level**: Enabled when the level of 3D MSAA is changed on the project "
"settings. Unfortunately, different MSAA levels being used on different "
"viewports will lead to stutters as the engine only keeps track of one level "
"at a time to perform precompilation."
msgstr ""
"**MSAA 等級**：當專案設定的 3D MSAA 等級變更時啟用。不幸的是，不同的視窗使用"
"不同 MSAA 等級時會造成卡頓，因為引擎一次只追蹤一個等級以進行預編譯。"

msgid ""
"**Reflection Probes**: Enabled when a ReflectionProbe node is placed on the "
"scene."
msgstr "**反射探針**：在場景中加入 ReflectionProbe 節點時啟用。"

msgid ""
"**Separate Specular**: Enabled when using effects like sub-surface "
"scattering or a compositor effect that relies on sampling the specularity "
"directly off the screen."
msgstr "**獨立高光**：當使用次表面散射或需直接從螢幕取樣高光的合成特效時啟用。"

msgid ""
"**Motion Vectors**: Enabled when using effects such as TAA, FSR2 or a "
"compositor effect that requires motion vectors (such as motion blur)."
msgstr ""
"**動態向量**：當使用 TAA、FSR2 或需要動態向量（如動態模糊）的合成特效時啟用。"

msgid ""
"**Normal and Roughness**: Enabled when using SDFGI, VoxelGI, screen-space "
"reflections, SSAO, SSIL, or using the ``normal_roughness_buffer`` in a "
"custom shader or :ref:`class_CompositorEffect`."
msgstr ""
"**法線與粗糙度**：當使用 SDFGI、VoxelGI、螢幕空間反射、SSAO、SSIL，或自訂著色"
"器 / :ref:`class_CompositorEffect` 使用 ``normal_roughness_buffer`` 時啟用。"

msgid ""
"**Lightmaps**: Enabled when a LightmapGI node is placed on the scene and a "
"node uses a baked lightmap."
msgstr ""
"**光照貼圖**：當場景中加入 LightmapGI 節點並有節點使用烘焙光照貼圖時啟用。"

msgid "**VoxelGI**: Enabled when a VoxelGI node is placed on the scene."
msgstr "**VoxelGI**：場景中加入 VoxelGI 節點時啟用。"

msgid "**SDFGI**: Enabled when the WorldEnvironment enables SDFGI."
msgstr "**SDFGI**：WorldEnvironment 啟用 SDFGI 時啟用。"

msgid "**Multiview**: Enabled for XR projects."
msgstr "**多重視角**：XR 專案時啟用。"

msgid ""
"**16/32-bit Shadows**: Enabled when the configuration of the depth precision "
"of shadowmaps is changed on the project settings."
msgstr "**16/32 位元陰影**：當專案設定更改陰影貼圖的深度精度時啟用。"

msgid ""
"**Omni Shadow Dual Paraboloid**: Enabled when an omni light casts shadows "
"and uses the dual paraboloid mode."
msgstr "**全向光雙拋物面陰影**：當全向光源啟用陰影並使用雙拋物面模式時啟用。"

msgid ""
"**Omni Shadow Cubemap**: Enabled when an omni light casts shadows and uses "
"the cubemap mode (which is the default)."
msgstr ""
"**全向光立方體陰影**：當全向光源啟用陰影並使用立方體貼圖模式（預設）時啟用。"

msgid ""
"If you witness stutters during gameplay and the monitors report a sudden "
"increase in compilations during the **Surface** step, it is very likely a "
"feature was not enabled ahead of time. Ensuring that this effect is enabled "
"while loading your game will likely mitigate the issue."
msgstr ""
"如果你在遊戲進行時遇到卡頓，且監控工具顯示 **Surface** 步驟的編譯數量突然增"
"加，很可能是某項功能在事前未啟用。請確保這些效果在遊戲載入時就被啟用，以減輕"
"相關問題。"

msgid "Pipeline precompilation instancing"
msgstr "管線預編譯與實體化"

msgid ""
"One common source of stutters in games is the fact that some effects are "
"only instanced on the scene because of interactions that only happen during "
"gameplay. For example, if you have a particle effect that is only added to "
"the scene through a script when a player does an action. Even if the scene "
"is preloaded, the engine might be unable to precompile the pipelines until "
"the effect is added to the scene at least once."
msgstr ""
"遊戲中常見的卡頓來源之一，是某些效果只有在特定互動發生時才會動態實體化到場"
"景。例如，若有一個粒子特效，只有玩家執行某個動作時才用腳本加到場景。即使該場"
"景已預先載入，若效果從未實體化過，引擎仍可能無法預先編譯對應的管線。"

msgid ""
"Luckily, it's possible for Godot 4.4 and later to precompile these pipelines "
"as long as the scene is instantiated at least once on the scene, even if "
"it's completely invisible or outside of the camera's view."
msgstr ""
"所幸，從 Godot 4.4 起，只要場景被實體化過一次（即使完全不可見或在攝影機外），"
"這些管線就能被預先編譯。"

msgid "Screenshot of an example of a hidden Node for an effect"
msgstr "特效隱藏節點實例的截圖"

msgid ""
"Hidden bullet node attached to the player in one of the demo projects. This "
"helps the engine precompile the effect's pipelines ahead of time."
msgstr ""
"在某範例專案中，將隱藏的子彈節點掛在玩家物件下。這樣有助於引擎預先編譯該特效"
"所需的管線。"

msgid ""
"If you're aware of any effects that are added to the scene dynamically "
"during gameplay and are seeing sudden increases on the compilations monitor "
"when these effects show up, a workaround is to attach a hidden version of "
"the effect somewhere that is guaranteed to show up."
msgstr ""
"如果你知道某些特效會在遊戲過程中動態加入場景，且發現這些特效出現時編譯數量會"
"突然增加，一個解決方法是將這些特效的隱藏版本掛載在場景內某處，確保它們一定會"
"被實體化一次。"

msgid ""
"For example, if the player character is able to cause some sort of "
"explosion, you can attach the effect as a child of the player as an "
"invisible node. Make sure to disable the script attached to the hidden node "
"or to hide any other nodes that could cause issues, which can be done by "
"enabling **Editable Children** on the node."
msgstr ""
"舉例來說，若玩家角色能引發爆炸效果，你可以將該特效作為隱藏節點掛載在玩家物件"
"下。請記得停用隱藏節點上的腳本，或隱藏可能造成問題的其他子節點，這可透過啟用"
"節點的 **可編輯子節點** 選項來達成。"
