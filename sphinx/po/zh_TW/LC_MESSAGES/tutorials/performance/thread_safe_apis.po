#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Thread-safe APIs"
msgstr "執行緒安全的 API"

msgid "Threads"
msgstr "執行緒"

msgid ""
"Threads are used to balance processing power across CPUs and cores. Godot "
"supports multithreading, but not in the whole engine."
msgstr ""
"執行緒用於平衡多核心 CPU 的運算效能。Godot 支援多執行緒，但不是整個引擎都支"
"援。"

msgid ""
"Below is a list of ways multithreading can be used in different areas of "
"Godot."
msgstr "以下列出 Godot 不同範疇中可用多執行緒的方式。"

msgid "Global scope"
msgstr "全域作用域"

msgid ""
":ref:`Global Scope<class_@GlobalScope>` singletons are all thread-safe. "
"Accessing servers from threads is supported (for RenderingServer and Physics "
"servers, ensure threaded or thread-safe operation is enabled in the project "
"settings!)."
msgstr ""
":ref:`Global Scope<class_@GlobalScope>` 單例皆為執行緒安全。支援從執行緒存取"
"伺服器（對於 RenderingServer 與 Physics 伺服器，請確認已在專案設定啟用執行緒"
"或執行緒安全操作！）。"

msgid ""
"This makes them ideal for code that creates dozens of thousands of instances "
"in servers and controls them from threads. Of course, it requires a bit more "
"code, as this is used directly and not within the scene tree."
msgstr ""
"這使其非常適合在伺服器內建立數萬個實體並由執行緒控制的程式碼。當然，這種作法"
"需要額外的程式碼，因為是直接操作，不是透過場景樹。"

msgid "Scene tree"
msgstr "場景樹"

msgid ""
"Interacting with the active scene tree is **NOT** thread-safe. Make sure to "
"use mutexes when sending data between threads. If you want to call functions "
"from a thread, the *call_deferred* function may be used:"
msgstr ""
"與目前活動場景樹互動**不是**執行緒安全的。在執行緒間傳送資料時，請務必使用互"
"斥鎖（mutex）。若要從執行緒呼叫函式，可使用 *call_deferred* 函式："

msgid ""
"However, creating scene chunks (nodes in tree arrangement) outside the "
"active tree is fine. This way, parts of a scene can be built or instantiated "
"in a thread, then added in the main thread:"
msgstr ""
"但在現有場景樹之外建立場景片段（以樹狀排列的節點）是沒問題的。如此一來，可以"
"在執行緒中建立或產生部份場景，再於主執行緒新增進場景樹："

msgid ""
"Still, this is only really useful if you have **one** thread loading data. "
"Attempting to load or create scene chunks from multiple threads may work, "
"but you risk resources (which are only loaded once in Godot) tweaked by the "
"multiple threads, resulting in unexpected behaviors or crashes."
msgstr ""
"但這僅在你只有**一個**執行緒載入資料時較有用。嘗試從多個執行緒同時載入或建立"
"場景片段雖然可行，但有可能因同一個資源（Godot 僅載入一次）被多個執行緒修改，"
"而導致非預期行為或當機。"

msgid ""
"Only use more than one thread to generate scene data if you *really* know "
"what you are doing and you are sure that a single resource is not being used "
"or set in multiple ones. Otherwise, you are safer just using the servers API "
"(which is fully thread-safe) directly and not touching scene or resources."
msgstr ""
"只有當你*非常*確定自己操作無誤，且能保證同一資源不會被多個執行緒同時存取或設"
"定時，才建議使用多個執行緒來產生場景資料。否則，直接用伺服器 API（完全執行緒"
"安全），避免直接操作場景或資源會更安全。"

msgid "Rendering"
msgstr "算繪"

msgid ""
"Instancing nodes that render anything in 2D or 3D (such as Sprite) is *not* "
"thread-safe by default. To make rendering thread-safe, set "
"the :ref:`Rendering > Driver > Thread "
"Model<class_ProjectSettings_property_rendering/driver/threads/thread_model>` "
"project setting to **Multi-Threaded**."
msgstr ""
"預設情況下，建立可在 2D 或 3D 算繪內容的節點（例如 Sprite）*不是*執行緒安全"
"的。如需讓算繪具備執行緒安全性，請將專案設定 :ref:`Rendering > Driver > "
"Thread Model<class_ProjectSettings_property_rendering/driver/threads/"
"thread_model>` 設為 **Multi-Threaded** 。"

msgid ""
"Note that the Multi-Threaded thread model has several known bugs, so it may "
"not be usable in all scenarios."
msgstr ""
"請注意，多執行緒（Multi-Threaded）執行緒模型有多個已知問題，因此不一定適用於"
"所有情境。"

msgid ""
"You should avoid calling functions involving direct interaction with the GPU "
"on other threads, such as creating new textures or modifying and retrieving "
"image data, these operations can lead to performance stalls because they "
"require synchronization with "
"the :ref:`RenderingServer<class_RenderingServer>`, as data needs to be "
"transmitted to or updated on the GPU."
msgstr ""
"你應避免在其他執行緒呼叫與 GPU 直接互動的函式，例如建立新材質、修改或讀取影像"
"資料等。這類操作會因需與 :ref:`RenderingServer<class_RenderingServer>` 同步，"
"導致效能延遲，因為資料必須傳送到 GPU 或在 GPU 上更新。"

msgid "GDScript arrays, dictionaries"
msgstr "GDScript 陣列、字典"

msgid ""
"In GDScript, reading and writing elements from multiple threads is OK, but "
"anything that changes the container size (resizing, adding or removing "
"elements) requires locking a mutex."
msgstr ""
"在 GDScript 中，從多個執行緒讀寫元素沒問題，但只要會改變容器大小的操作（如調"
"整大小、加入或移除元素）就必須鎖定互斥鎖。"

msgid "Resources"
msgstr "資源"

msgid ""
"Modifying a unique resource from multiple threads is not supported. However "
"handling references on multiple threads is supported, hence loading "
"resources on a thread is as well - scenes, textures, meshes, etc - can be "
"loaded and manipulated on a thread and then added to the active scene on the "
"main thread. The limitation here is as described above, one must be careful "
"not to load the same resource from multiple threads at once, therefore it is "
"easiest to use **one** thread for loading and modifying resources, and then "
"the main thread for adding them."
msgstr ""
"不支援從多個執行緒同時修改單一資源。但支援於多執行緒間處理引用，因此可在執行"
"緒中載入資源——如場景、材質、網格等——並進行操作，再於主執行緒加入至活動場景。"
"如前所述，需特別注意勿讓多執行緒同時載入同一資源，因此建議僅用**一個**執行緒"
"負責載入與修改資源，主執行緒負責加入。"
