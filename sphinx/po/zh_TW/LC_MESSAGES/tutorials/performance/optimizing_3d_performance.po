#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "最佳化"

msgid "Optimizing 3D performance"
msgstr "3D 效能最佳化"

msgid "Culling"
msgstr "剔除"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot 會自動執行視錐剔除，以避免繪製在視窗外的物件。這對於小型場景的遊戲效果"
"很好，但在大型關卡中可能很快就會遇到效能瓶頸。"

msgid "Occlusion culling"
msgstr "遮蔽剔除"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"舉例來說，當你在小鎮中走動時，實際上你只能看到你所在街道上的幾棟建築物，還有"
"天空與頭頂飛過的幾隻鳥。但對於單純的算繪器來說，它認為你能看到整個小鎮。它不"
"只會算繪你面前的建築，還會算繪後面的街道、街上的行人，以及再更後方的建築。你"
"很快就會遇到需要算繪比實際可見多 10 倍、甚至 100 倍物件的情況。"

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"情況並沒有看起來那麼糟，因為 Z 緩衝區通常會讓 GPU 只對前面的物件進行完整著"
"色。這稱為 *深度預先通過* （depth prepass），在 Godot 使用 Forward+ 或相容性"
"算繪模式時預設啟用。但不必要的物件仍然會降低效能。"

msgid ""
"One way we can potentially reduce the amount to be rendered is to **take "
"advantage of occlusion**. Godot 4.0 and later offers a new approach to "
"occlusion culling using occluder nodes. See :ref:`doc_occlusion_culling` for "
"instructions on setting up occlusion culling in your scene."
msgstr ""
"我們可以減少算繪量的一個方法是**善用遮擋**。Godot 4.0 及之後版本提供了使用遮"
"擋器節點（Occluder Node）進行遮擋剔除的新方式。請參"
"閱 :ref:`doc_occlusion_culling` 以瞭解如何在場景中設定遮擋剔除。"

msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"在某些情況下，你可能需要調整你的關卡設計以增加更多遮擋機會。例如，你可以增加"
"更多牆壁，避免玩家看到過遠的區域，否則因為遮擋剔除機會減少而導致效能下降。"

msgid "Transparent objects"
msgstr "透明物件"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot 會依據 :ref:`Material <class_Material>` 和 :ref:`Shader "
"<class_Shader>` 對物件排序以提升效能。然而，透明物件無法這麼做。透明物件需要"
"從遠到近繪製，以正確混合背景。因此，**請儘量減少透明物件的使用**。如果某個物"
"件只有一小部分需要透明，建議將該部分拆分成獨立的表面，給它專屬材質。"

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr "更多資訊請參考 :ref:`GPU 最佳化 <doc_gpu_optimization>` 文件。"

msgid "Level of detail (LOD)"
msgstr "細節層級（LOD）"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"在某些情境下，尤其是遠距離時， **以更簡化的模型取代複雜幾何體** 是個好方法。"
"最終使用者很可能分辨不出差異。想像一下遠方有大量樹木的情境，你可以採用多種策"
"略依照距離替換模型，例如使用較低面數（Low Poly）的模型，或利用透明度模擬更複"
"雜的幾何外觀。"

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 提供了多種控制細節層級（LOD）的方法："

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr "使用 :ref:`doc_mesh_lod` 於匯入網格時自動產生 LOD。"

msgid ""
"A manual approach configured in the 3D node "
"using :ref:`doc_visibility_ranges`."
msgstr "在 3D 節點中透過 :ref:`doc_visibility_ranges` 手動設定可見範圍。"

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""
":ref:`貼花 <doc_using_decals>` 與 :ref:`燈光 <doc_lights_and_shadows>` 也能透"
"過各自的 **距離淡出** 屬性受益於細節層級（LOD）。"

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""
"雖然這些方法可以單獨使用，但搭配在一起時效果最佳。例如，你可以設定可見範圍來"
"隱藏玩家無法注意到的遠距粒子特效，同時利用網格 LOD 讓粒子在遠處時以較低細節算"
"繪。"

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr "可見範圍也很適合為遠距幾何體設置「冒充物」（impostor）（見下文）。"

msgid "Billboards and imposters"
msgstr "看板物件與冒充物（Billboard 與 Impostor）"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, "
"see :ref:`doc_gpu_optimization`)."
msgstr ""
"利用透明度實現 LOD 最簡單的方式就是使用看板（Billboard）。例如，你可以用一個"
"透明四邊形來代表遠方的樹。這能大幅降低算繪成本，但如果有大量樹彼此重疊時，透"
"明度會消耗填充率（Fill Rate）。（更多關於填充率的資訊請"
"見 :ref:`doc_gpu_optimization` ）。"

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"另一種方式不是只用單一樹木，而是把多棵樹作為一個群組一次算繪。如果該區域玩家"
"只能遠觀，無法靠近，這種方法特別有效。"

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"你可以預先算繪物件在不同角度下的影像，製作成冒充物（Impostor）。甚至可以進一"
"步，定期把物件當前視角重新算繪到貼圖上作為冒充物。在遠處時，視角要有明顯變化"
"需要很大移動距離。雖然實作上較為複雜，但對某些專案來說非常值得。"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"如果需要在同一區域或附近繪製多個相同物件，請考慮使用 :ref:`MultiMesh "
"<class_MultiMesh>`。MultiMesh 可以用極低效能成本繪製成千上萬個物件，非常適合"
"用於大量群體、草地、粒子等場景。"

msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr "詳情請參閱 :ref:`使用 MultiMesh <doc_using_multimesh>` 文件。"

msgid "Bake lighting"
msgstr "烘焙光照"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"燈光運算是最吃資源的算繪操作之一，特別是即時光照、陰影（尤其是多盞燈），以"
"及 :ref:`全域照明 <doc_introduction_to_global_illumination>`。這些在低階裝置"
"上可能完全跑不動。"

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**建議使用烘焙光照**，尤其是在行動裝置上。這種方法畫面效果很棒，但缺點是光源"
"無法動態改變。有時這是值得的取捨。"

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""
"關於如何使用烘焙光照貼圖，請參考 :ref:`doc_using_lightmap_gi`。為了最佳效能，"
"請將燈光的烘焙模式設為 **靜態**（Static），而非預設的 **動態**，如此可略過已"
"烘焙網格的即時光照運算。"

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for "
"the :ref:`class_DirectionalLight3D` node, and use **Static** for most (if "
"not all) omni and spot lights."
msgstr ""
"**靜態**燈光的缺點是無法把陰影投射到已烘焙光照的網格上。這會讓戶外場景與動態"
"物件看起來比較單調。效能與畫質之間的折衷方案，是"
"讓 :ref:`class_DirectionalLight3D` 使用 **動態**，而大多數（甚至全部）點光源"
"與聚光燈則用 **靜態**。"

msgid "Animation and skinning"
msgstr "動畫與蒙皮（Skinning）"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"在某些平台上，動畫與頂點動畫（如蒙皮與變形）效能消耗非常大。你可能需要大幅降"
"低動畫模型的面數，或限制同時出現在畫面的數量。你也可以針對遠距或被遮擋的模型"
"減少動畫播放速率，甚至在玩家不會注意時直接暫停動畫。"

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` "
"and :ref:`class_VisibleOnScreenNotifier3D` nodes can be useful for this "
"purpose."
msgstr ""
"你可以利用 :ref:`class_VisibleOnScreenEnabler3D` "
"與 :ref:`class_VisibleOnScreenNotifier3D` 節點來達成上述控制。"

msgid "Large worlds"
msgstr "大型世界"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr "如果你要設計大型世界，會遇到跟小型遊戲完全不同的挑戰與考量。"

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大型世界通常需要分割為可隨需求載入的區塊（Tiles），你在世界中移動時再動態加"
"載。這可以避免記憶體暴增，並將運算集中在玩家所在區域。"

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved "
"using :ref:`doc_large_world_coordinates`. If using large world coordinates "
"is not an option, you may be able to use techniques such as orienting the "
"world around the player (rather than the other way around), or shifting the "
"origin periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"在大型世界中，由於浮點數誤差，可能會出現算繪或物理異常。你可以參"
"考 :ref:`doc_large_world_coordinates` 來解決這個問題。如果無法使用大型世界座"
"標系統，也可以考慮讓世界隨玩家移動、或定期平移原點來保持所有物件圍繞 "
"``Vector3(0, 0, 0)`` 為中心。"
