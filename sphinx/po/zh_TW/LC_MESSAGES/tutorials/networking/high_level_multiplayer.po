#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "高階多人連線"

msgid "High-level vs low-level API"
msgstr "高階 API 與 低階 API"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"以下說明 Godot 中高階和低階網路的差異及其基本原理。如果你想直接開始在節點中加"
"入網路功能，可直接跳到下方的 `初始化網路`_ 章節，但建議稍後還是回來閱讀其餘內"
"容！"

msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot 一直以來都支援標準的低階網路通訊協定，如 :abbr:`UDP（使用者資料包協定）"
"`、 :abbr:`TCP（傳輸控制協定）`，以及更高階的 :abbr:`HTTP（超文本傳輸協定）"
"`、 :abbr:`SSL（安全通訊層）` 等。這些協定非常彈性，幾乎可以用於任何場合。不"
"過，若要手動透過這些協定來同步遊戲狀態，會需要投入相當多的開發工作。有時這是"
"必要或值得的（例如你在後端使用自訂伺服器實作時）；但大多數情況下，建議優先考"
"慮 Godot 的高階網路 API，雖然會犧牲一些低階細節控制，但能大幅提升開發效率。"

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "這是因為低階協定本身的限制："

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP 能保證封包可靠且按順序到達，但因為要進行錯誤校正，通常會有較高延遲。它本"
"身也是個相當複雜的協定，會處理所謂的「連線」，並針對某些場景（通常不適用於多"
"人遊戲）進行最佳化。封包會被緩衝，等到累積足夠再一起發送，以減少每個封包的額"
"外負擔，但這也會增加延遲。這對 HTTP 等用途來說很有幫助，但對遊戲來說通常不是"
"好事。部分行為可透過設定關閉（如關閉 TCP 的「Nagle 演算法」）。"

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP 協定更簡單，只負責發送資料封包（且沒有「連線」概念）。它不做錯誤修正，所"
"以延遲很低、速度很快，但封包可能會在傳送過程中遺失或順序錯亂。此外，UDP 的 "
"MTU（最大封包大小）通常很小（只有數百位元組），所以傳送較大的資料時必須拆封包"
"並重組，若有部分失敗還需重新傳送。"

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"總結來說，TCP 屬於可靠、有序、但較慢；UDP 則是不可靠、無序且快速。兩者效能差"
"異很大，因此遊戲常常會自己實作只需要的 TCP 功能（如部分可靠性和排序），而避開"
"某些遊戲不需要的部分（像是壅塞/流量控制、Nagle 演算法等）。因此大多數遊戲引擎"
"都有這類專用網路實作，Godot 也不例外。"

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"總結來說，你可以選擇低階網路 API 來實現最大控制權、在底層協定之上自行打造一"
"切，也可以直接利用基於 :ref:`SceneTree <class_SceneTree>` 的高階 API，讓它自"
"動幫你處理大部分網路細節與優化。"

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Godot 支援的大多數平台都具備上述高階與低階網路功能。不過，網路功能往往依賴硬"
"體與作業系統，因此有些功能在特定平台上可能不同或不可用。尤其 HTML5 版目前只支"
"援 WebSocket 與 WebRTC，缺乏某些高階功能，也無法直接存取 TCP、UDP 這類低階協"
"定。"

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"更多關於 TCP/IP、UDP 及網路相關知識： https://gafferongames.com/post/"
"udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games 網站有許多實用的遊戲網路技術文章（`連結 <https://"
"gafferongames.com/categories/game-networking/>`__），例如這一篇超完整的《遊戲"
"網路架構簡介 <https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__》。"

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"在遊戲中加入網路功能也意味著更多責任。如果處理不當，應用程式可能會有安全漏"
"洞，導致被外掛、作弊、甚至被利用。更嚴重時，攻擊者可能入侵你的伺服器，拿來發"
"送垃圾信、攻擊他人，或竊取玩家資料。"

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"只要是網路應用都會面臨這些問題，這與 Godot 本身無關。你可以隨意測試、練習，但"
"只要要公開發佈網路遊戲，就務必重視安全性問題。"

msgid "Mid-level abstraction"
msgstr "中階抽象"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在了解如何跨網路同步遊戲之前，有必要先認識 Godot 用來同步的底層網路 API 怎麼"
"運作。"

msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot 採用了一個中階物件 :ref:`MultiplayerPeer <class_MultiplayerPeer>`。這個"
"物件並不是讓你直接建立，而是由多種 C++ 實作類別提供。"

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"此物件繼承自 :ref:`PacketPeer <class_PacketPeer>`，因此擁有序列化、發送與接收"
"資料的所有方便方法。此外，也有設定節點、傳輸模式等方法，還有用於偵測連線/斷線"
"的 signals。"

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet "
"(:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on "
"WebRTC (:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one "
"based on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this "
"could be used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or "
"custom device/console-specific networking APIs."
msgstr ""
"這個介面可用來抽象各式網路層、拓撲與函式庫。Godot 內建 ENet"
"（:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`）、WebRTC"
"（:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`）及 WebSocket"
"（:ref:`WebSocketPeer <class_WebSocketPeer>`）等實作，但也可以自行擴充，像是"
"行動裝置專用 WiFi、藍牙，或是特定主機 API。"

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"在大多數情況下，建議不要直接用這個物件，因為 Godot 還有更高階的網路 API。只有"
"當你真的需要低階控制時才用它。"

msgid "Hosting considerations"
msgstr "主機託管須知"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form "
"``192.168.*.*``. This internal IP address is **not** reachable by non-LAN/"
"Internet clients."
msgstr ""
"在主機託管伺服器時，同一 :abbr:`區域網路（LAN）` 內的用戶端可以用內部 IP（通"
"常是 ``192.168.*.*`` ）連線。但這個內部 IP 不能被外部網際網路上的玩家存取。"

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""
"在 Windows 上，可在命令提示字元輸入 ipconfig 查詢；macOS 請於終端機輸入 "
"ifconfig；Linux 則輸入 ip addr。"

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""
"如果你在自己電腦上架設伺服器，並希望讓外部（非區網）用戶端連線，通常必須在家"
"用路由器上「連接埠轉發」伺服器的埠號。這是因為大多數家用連線都用 NAT"
"（https://en.wikipedia.org/wiki/Network_address_translation）。Godot 高階多"
"人 API 只用 UDP，所以你必須設定 UDP 連接埠轉發，不只是 TCP。"

msgid ""
"After forwarding a UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""
"完成 UDP 連接埠轉發並確認伺服器使用該埠號後，可透過「https://icanhazip.com/」"
"查詢你的公開 IP，然後將此 IP 提供給想連線的網路玩家。"

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr "Godot 的高階多人 API 採用改寫版的 ENet，支援完整 IPv6。"

msgid "Initializing the network"
msgstr "初始化網路"

msgid ""
"High-level networking in Godot is managed by the :ref:`SceneTree "
"<class_SceneTree>`."
msgstr ""
"在 Godot 中，高階網路功能是由 :ref:`SceneTree <class_SceneTree>` 負責管理的。"

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""
"每個節點都有一個 ``multiplayer`` 屬性，這是一個由場景樹配置的 "
"``MultiplayerAPI`` 實例的參考。預設情況下，所有節點都指向同一個 "
"``MultiplayerAPI`` 物件。"

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""
"初始化網路時，需先建立 ``MultiplayerPeer`` 物件，將其初始化為伺服器或用戶端，"
"然後傳給 ``MultiplayerAPI``。"

msgid "To terminate networking:"
msgstr "停止網路："

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"匯出到 Android 時，請在匯出專案或一鍵部署前，於 Android 匯出設定啟用 "
"``INTERNET`` 權限，否則所有網路連線都會被 Android 阻擋。"

msgid "Managing connections"
msgstr "管理連線"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""
"每個連線節點（peer）都會被指定一個唯一 ID。伺服器的 ID 永遠是 1，客戶端會分配"
"隨機正整數 ID。"

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr "可以藉由連接 ``MultiplayerAPI`` 的 signals 來監聽連線與斷線事件："

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""
"``peer_connected(id: int)`` 這個 signal 會在所有已連線 peer 上觸發，參數是新"
"連線 peer 的 ID；新加入的 peer 則會收到一次所有其他 peer 的 ID。"

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""
"``peer_disconnected(id: int)`` 這個 signal 會在其他所有 peer 上觸發，參數是剛"
"剛斷線的 peer ID。"

msgid "The rest are only emitted on clients:"
msgstr "下列 signals 僅會在客戶端觸發："

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr "取得目前 peer 的唯一 ID："

msgid "To check whether the peer is server or client:"
msgstr "檢查目前 peer 是伺服器還是客戶端："

msgid "Remote procedure calls"
msgstr "遠端程序呼叫（RPC）"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""
"遠端程序呼叫（RPC）是可以在其他 peer 執行的函式。要定義 RPC，請在函式前加 "
"``@rpc`` 標註。呼叫 RPC 時，使用 ``rpc()`` 會在所有 peer 執行，使用 "
"``rpc_id()`` 則只會指定 peer 執行。"

msgid "RPCs will not serialize objects or callables."
msgstr "RPC 不會序列化物件或函式指標（callable）。"

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""
"要讓遠端呼叫成功，發送端與接收端節點的 ``NodePath`` 必須完全相同，也就是節點"
"名稱必須一致。若是使用 ``add_child()`` 加入會用到 RPC 的節點，建議將 "
"``force_readable_name`` 參數設為 ``true``。"

msgid ""
"If a function is annotated with ``@rpc`` on the client script (resp. server "
"script), then this function must also be declared on the server script "
"(resp. client script). Both RPCs must have the same signature which is "
"evaluated with a checksum of **all RPCs**. All RPCs in a script are checked "
"at once, and all RPCs must be declared on both the client scripts and the "
"server scripts, **even functions that are currently not in use**."
msgstr ""
"若某函式在客戶端（或伺服器端）腳本用 ``@rpc`` 標註，則必須在伺服器端（或客戶"
"端）腳本也宣告同名函式。所有 RPC 必須有相同簽名，這會以**所有 RPC** 計算檢查"
"碼。所有 RPC 會一次性檢查，且必須在客戶端與伺服器端腳本都宣告，**即使該函式當"
"下未被使用也一樣**。"

msgid ""
"The signature of the RPC includes the ``@rpc()`` declaration, the function, "
"return type, **and** the NodePath. If an RPC resides in a script attached to "
"``/root/Main/Node1``, then it must reside in precisely the same path and "
"node on both the client script and the server script. Function arguments are "
"not checked for matching between the server and client code (example: ``func "
"sendstuff():`` and ``func sendstuff(arg1, arg2):`` **will pass** signature "
"matching)."
msgstr ""
"RPC 的簽名包含 ``@rpc()`` 宣告、函式名稱、回傳型別，以及 NodePath。如果 RPC "
"函式是在 ``/root/Main/Node1`` 這個節點上，那無論在客戶端還是伺服器端，都必須"
"在相同路徑與節點上定義。參數內容不會影響簽名比對（例如 ``func sendstuff():`` "
"和 ``func sendstuff(arg1, arg2):`` 也算一致）。"

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""
"若未符合上述條件（RPC 簽名不一致），腳本可能會出現錯誤或產生非預期行為。錯誤"
"訊息有時甚至和你正在編寫的 RPC 無關。"

msgid ""
"See further explanation and troubleshooting on `this post <https://"
"github.com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""
"詳細說明與疑難排解可參考這篇討論：<https://github.com/godotengine/godot/"
"issues/57869#issuecomment-1034215138>。"

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr "@rpc 標註可帶入多個參數（皆有預設值）。``@rpc`` 等同於："

msgid "The parameters and their functions are as follows:"
msgstr "各參數說明如下："

msgid "``mode``:"
msgstr "``mode``："

msgid ""
"``\"authority\"``: Only the multiplayer authority can call remotely. The "
"authority is the server by default, but can be changed per-node "
"using :ref:`Node.set_multiplayer_authority "
"<class_Node_method_set_multiplayer_authority>`."
msgstr ""
"``\"authority\"``：只有 multiplayer authority 才能進行遠端呼叫。預設為伺服"
"器，但可用 :ref:`Node.set_multiplayer_authority "
"<class_Node_method_set_multiplayer_authority>` 更改每個節點的權限。"

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr ""
"``\"any_peer\"``：允許任何 peer（包含用戶端）進行遠端呼叫，通常用來傳送玩家輸"
"入等資料。"

msgid "``sync``:"
msgstr "``sync``："

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "``\"call_remote\"``：此函式不會在本地 peer 上被呼叫。"

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""
"``\"call_local\"``：此函式也會在本地 peer 執行。適用於伺服器同時也是玩家的情"
"境。"

msgid "``transfer_mode``:"
msgstr "``transfer_mode``："

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr "``\"unreliable\"``：資料封包不會被確認，可能遺失、亂序。"

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""
"``\"unreliable_ordered\"``：封包會按發送順序處理。如果較晚到達的封包已被後發"
"的封包覆蓋，則會被直接忽略。若使用不當會造成資料遺失。"

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""
"``\"reliable\"``：會持續重送直到封包被正確收到，且封包順序固定，但效能影響較"
"大。"

msgid "``transfer_channel`` is the channel index."
msgstr "``transfer_channel`` 為通道索引。"

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr "前 3 個參數可任意順序，``transfer_channel`` 必須最後寫。"

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""
"你可以在 RPC 執行的函式內，透過 ``multiplayer.get_remote_sender_id()`` 取得發"
"送端的唯一 ID。"

msgid "Channels"
msgstr "通道（Channels）"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""
"現代網路協定支援多通道（channels），即在同一連線下建立多個獨立子連線，讓多條"
"資料流互不干擾。"

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""
"例如聊天室訊息與核心遊戲資料都要可靠傳送，但遊戲資料不應該被聊天訊息延遲影"
"響。這時就應該用不同通道分開傳送。"

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""
"通道也很適合搭配不可靠有序傳輸模式。此模式下若傳遞不同大小的封包，後到的封包"
"可能會被直接丟棄，造成資料遺失。將不同功能資料分成多個相同型態封包的資料流，"
"就能在有序傳輸下減少資料遺失，也不用承擔可靠模式帶來的延遲。"

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr ""
"預設的 0 號通道（index 0）實際上有三個不同的通道——各自對應不同的傳輸模式。"

msgid "Example lobby implementation"
msgstr "大廳範例實作"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""
"這是一個能處理新玩家加入與離開、透過 signals 通知 UI 場景，並在所有玩家載入遊"
"戲場景後啟動遊戲的大廳範例。"

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr "遊戲場景的根節點應命名為 Game，其附加腳本如下："

msgid "Exporting for dedicated servers"
msgstr "匯出為專用伺服器"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. "
"See :ref:`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"當多人連線遊戲完成後，你可能會想匯出專用伺服器版本（通常不需要 GPU）。詳情請"
"見 :ref:`doc_exporting_for_dedicated_servers`。"

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"本頁範例程式碼並未針對專用伺服器設計。你需要自行修改，讓伺服器不被視為玩家，"
"也要調整遊戲啟動流程，讓第一個加入的玩家可以開始遊戲。"
