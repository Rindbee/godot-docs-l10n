#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "設定 XR"

msgid "Introduction to the XR system in Godot"
msgstr "Godot XR 系統簡介"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot 提供模組化的 XR 系統，將各種 XR 平台的細節抽象化，讓使用者不需直接面"
"對。核心元件為 :ref:`XRServer <class_xrserver>`，它作為 XR 系統的中央介面，讓"
"使用者可以探索介面並與 XR 系統的各元件互動。"

msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with "
"the :ref:`XRServer <class_xrserver>` and can be queried with the "
"``find_interface`` method on the :ref:`XRServer <class_xrserver>`. When the "
"desired interface is found it can be initialized by calling ``initialize`` "
"on the interface."
msgstr ""
"每個支援的 XR 平台皆以 :ref:`XRInterface <class_xrinterface>` 實作。支援的介"
"面會自行向 :ref:`XRServer <class_xrserver>` 註冊，並可透過 :ref:`XRServer "
"<class_xrserver>` 的 ``find_interface`` 方法查詢。找到所需介面後，可以呼叫該"
"介面的 ``initialize`` 進行初始化。"

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"已註冊的介面僅代表該介面可用；若主機系統不支援該介面，初始化可能會失敗並回傳 "
"``false``。這可能有多種原因，而且不同平台原因各異。可能是使用者尚未安裝所需軟"
"體，或者僅僅是沒有將頭戴式裝置插上。作為開發者，你必須正確處理介面初始化失敗"
"的情況。"

msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"由於 XR 輸出有特殊需求，尤其是頭戴裝置需為每隻眼睛提供不同影像，Godot "
"的 :ref:`XRServer <class_xrserver>` 會覆蓋算繪系統的多項功能。對於獨立裝置，"
"最終輸出會由 :ref:`XRInterface <class_xrinterface>` 處理，Godot 預設的輸出系"
"統會停用。對於作為第二螢幕的桌面 XR 裝置，可以指定獨立的 :ref:`Viewport "
"<class_viewport>` 負責 XR 輸出，讓主 Godot 視窗可用於顯示其他內容。"

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"請注意，僅有一個介面可以負責 XR 裝置的輸出，這稱為主要介面，預設會是第一個被"
"初始化的介面。因此 Godot 目前僅支援單一頭戴裝置的實作。雖然仍可設置次要介面"
"（例如為僅支援 3DOF 的裝置新增追蹤），但這種情況越來越罕見。"

msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr "幾乎所有 XR 應用程式中都會用到三種 XR 專用節點型別："

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` 代表你的遊戲空間中心點（雖然這樣說有點過"
"度簡化，但後面會詳細說明）。所有由 XR 平台在實體空間追蹤的物件，都是以這個點"
"為基準定位。"

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` 代表用於 XR 裝置算繪輸出的（立體）相機。"
"這個節點的位置會由 XR 系統自動根據平台提供的追蹤資訊進行更新。"

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` 代表玩家的控制器，通常有兩個"
"（左、右手各一）。這些節點可以存取控制器的各種狀態，並在玩家按下按鈕時發送訊"
"號。節點位置同樣會由 XR 系統根據平台追蹤資訊自動更新。"

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr "還有其他 XR 相關節點，這三個節點也有更多細節，之後會再詳細介紹。"

msgid "Which Renderer to use"
msgstr "建議採用哪種算繪器"

msgid ""
"Godot has 3 renderer options for projects: Compatibility, Mobile, and "
"Forward+. The current recommendation is to use the Mobile renderer for any "
"desktop VR project, and use the Compatibility renderer for any project "
"running on a standalone headset like the Meta Quest 3. XR projects will run "
"with the Forward+ renderer, but it isn't well optimized for XR right now "
"compared to the other two."
msgstr ""
"Godot 為專案提供三種算繪器選項：相容性、行動裝置與 Forward+。目前建議桌面 VR "
"專案使用行動裝置算繪器，而如 Meta Quest 3 這種獨立頭戴裝置則建議使用相容性算"
"繪器。XR 專案雖可使用 Forward+ 算繪器，但相較於前兩者，目前對 XR 的最佳化尚不"
"足。"

msgid "OpenXR"
msgstr "OpenXR"

msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR 是一項新興產業標準，能讓不同 XR 平台透過標準化 API 提供功能給 XR 應"
"用。此標準由 Khronos Group 維護，屬於開放標準，與 Godot 的目標高度契合。"

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR 的 Vulkan 實作與 Vulkan 引擎緊密整合，甚至接管部分 Vulkan 系統。這要求"
"在設定 XR 系統前，必須將某些核心圖形功能深度整合至 Vulkan 算繪器中。這也是將 "
"OpenXR 納入核心介面的一大主因。"

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. Check "
"the :ref:`Enabled<class_ProjectSettings_property_xr/openxr/enabled>` setting "
"in your project settings under **XR > OpenXR**."
msgstr ""
"這也表示，Godot 啟動時必須啟用 OpenXR 才能正確設定。請至專案設定的 **XR > "
"OpenXR**，確認 :ref:`Enabled<class_ProjectSettings_property_xr/openxr/"
"enabled>` 已勾選。"

msgid ""
"You can find several other settings related to OpenXR here as well. These "
"can't be changed while your application is running. The default settings "
"will get us started, but for more information on what's here "
"see :ref:`doc_openxr_settings`."
msgstr ""
"此處還有其他與 OpenXR 相關的設定。這些設定在應用程式執行時無法更改。預設值已"
"可正常啟用，如需詳細說明，請參閱 :ref:`doc_openxr_settings`。"

msgid ""
"You'll also need to go to **XR > Shaders** in the project settings and check "
"the :ref:`Enabled<class_ProjectSettings_property_xr/shaders/enabled>` box to "
"enable them. Once you've done that click the **Save & Restart** button."
msgstr ""
"另外，請到專案設定中的 **XR > Shaders**，勾"
"選 :ref:`Enabled<class_ProjectSettings_property_xr/shaders/enabled>`，以啟用"
"著色器。完成後，請點擊 **儲存並重啟** 按鈕。"

msgid ""
"Many post process effects have not yet been updated to support stereoscopic "
"rendering. Using these will have adverse effects."
msgstr ""
"許多後製（後處理）特效尚未更新以支援立體算繪。使用這些效果會造成顯示異常。"

msgid "Setting up the XR scene"
msgstr "建立 XR 場景"

msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have "
"two :ref:`XRController3D <class_xrcontroller3d>`, one for the left hand and "
"one for the right. Keep in mind that the camera and controller nodes should "
"be children of the origin node. Add these nodes to a new scene and rename "
"the controller nodes to ``LeftHand`` and ``RightHand``, your scene should "
"look something like this:"
msgstr ""
"每個 XR 應用程式至少需要 :ref:`XROrigin3D <class_xrorigin3d>` "
"與 :ref:`XRCamera3D <class_xrcamera3d>` 節點。大多數情況下還會有兩"
"個 :ref:`XRController3D <class_xrcontroller3d>`，分別代表左手與右手。請注意，"
"相機與控制器節點應為原點節點的子節點。請將這些節點加入新場景，並將控制器節點"
"分別命名為 ``LeftHand`` 與 ``RightHand``，場景結構大致如下："

msgid ""
"The warning icons are expected and should go away after you configure the "
"controllers. Select the left hand and set it up as follows:"
msgstr "警告圖示是預期的，設定控制器後即可消失。請選取左手節點並設定如下："

msgid "And the right hand:"
msgstr "右手設定如下："

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"目前這些節點都在地板上，執行時會自動定位。為方便開發，可將相機向上移動，令其 "
"``y`` 設為 ``1.7`` ，並將控制器節點分別移至 ``-0.5, 1.0, -0.5`` （左手）與 "
"``0.5, 1.0, -0.5`` （右手）。"

msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr "接著，請在根節點（root node）新增腳本，並加入以下程式碼："

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"這段程式碼假設你使用的是 OpenXR，如果要改用其他介面，請修改 "
"``find_interface`` 的參數即可。"

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"如上述程式碼所示，我們關閉了垂直同步（v-sync）。使用 OpenXR 時，渲染結果會輸"
"出到 HMD，通常需運作在 90Hz 或更高更新率。若你的螢幕是 60Hz 並啟用垂直同步，"
"則輸出會被限制為每秒 60 影格。"

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "像 OpenXR 這類 XR 介面會自行處理同步。"

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set "
"``Engine.physics_ticks_per_second`` to a higher value."
msgstr ""
"另請注意，物理引擎預設也是以 60Hz 執行，這可能導致物理表現不流暢。建議將 "
"``Engine.physics_ticks_per_second`` 設為更高的值。"

msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add "
"a :ref:`DirectionalLight3D <class_directionallight3d>` and "
"a :ref:`WorldEnvironment <class_worldenvironment>` node to your scene. You "
"may wish to also add a mesh instance as a child to each controller node just "
"to temporarily visualise them. Make sure you configure a sky in your world "
"environment."
msgstr ""
"若此時直接運作專案，雖然一切正常，但你會處於一個黑暗世界。因此，請在場景中加"
"入 :ref:`DirectionalLight3D <class_directionallight3d>` "
"與 :ref:`WorldEnvironment <class_worldenvironment>` 節點。你也可以暫時在每個"
"控制器節點下新增一個網格實例以方便可視化。請別忘了在世界環境中設定天空。"

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr "現在執行專案，你應該會漂浮在空間中，並能自由環顧四周。"

msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"雖然傳統的關卡切換方式可用於 XR 應用（即每個關卡都重複此場景結構），但多數開"
"發者會選擇僅建立一次 XR 場景，再以子場景方式載入各關卡。如果你確實在每個場景"
"都複製 XR 設定，務必避免重複執行 ``initialize``，否則依據 XR 介面不同，可能產"
"生不可預期的結果。"

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr "在本教學系列其餘部分，我們將以單一場景製作遊戲。"
