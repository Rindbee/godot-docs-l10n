#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR composition layers"
msgstr "OpenXR 合成圖層"

msgid "Introduction"
msgstr "前言"

msgid ""
"In XR games you generally want to create user interactions that happen in 3D "
"space and involve users touching objects as if they are touching them in "
"real life."
msgstr ""
"在 XR 遊戲中，通常希望建立發生於 3D 空間的使用者互動，讓玩家如同在現實生活中"
"一樣觸碰物件。"

msgid ""
"Sometimes however creating a more traditional 2D interface is unavoidable. "
"In XR however you can't just add 2D components to your scene. Godot needs "
"depth information to properly position these elements so they appear at a "
"comfortable place for the user. Even with depth information there are "
"headsets with slanted displays that make it impossible for the standard 2D "
"pipeline to correctly render the 2D elements."
msgstr ""
"然而有時仍無法避免要製作較傳統的 2D 介面。但在 XR 中，不能直接將 2D 元件加入"
"場景。Godot 需要深度資訊來正確地擺放這些元素，使它們顯示在適合使用者觀看的位"
"置。即使有深度資訊，有些頭戴式顯示器因為螢幕傾斜，標準 2D 管線仍無法正確渲染"
"這些 2D 元素。"

msgid ""
"The solution then is to render the UI to a :ref:`SubViewport "
"<class_subviewport>` and display the result of this using "
"a :ref:`ViewportTexture <class_viewporttexture>` on a 3D mesh. "
"The :ref:`QuadMesh <class_quadmesh>` is a suitable option for this."
msgstr ""
"因此解決方式是將 UI 繪製到 :ref:`SubViewport <class_subviewport>`，再"
"用 :ref:`ViewportTexture <class_viewporttexture>` 作為 3D 網格材質來顯示。這"
"裡推薦使用 :ref:`QuadMesh <class_quadmesh>` 作為承載。"

msgid ""
"See the `GUI in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/gui_in_3d>`_ example project for an example of this approach."
msgstr ""
"關於此作法的範例，請參考 `GUI in 3D <https://github.com/godotengine/godot-"
"demo-projects/tree/master/viewport/gui_in_3d>`_ 範例專案。"

msgid ""
"The problem with displaying the viewport in this way is that the rendered "
"result is sampled for lens distortion by the XR runtime and the resulting "
"quality loss can make UI text hard to read."
msgstr ""
"用這種方式顯示 Viewport 的問題在於，XR 執行階段會對渲染結果進行鏡頭畸變取樣，"
"導致品質降低，使 UI 文字變得難以閱讀。"

msgid ""
"OpenXR offers a solution to this problem through composition layers. With "
"composition layers it is possible for the contents of a viewport to be "
"projected on a surface after lens distortion resulting in a much higher "
"quality end result."
msgstr ""
"OpenXR 針對這個問題提供了「合成圖層」解決方案。透過合成圖層，可以在經過鏡頭畸"
"變之後再將 Viewport 內容投影到表面，讓最終呈現的畫質大幅提升。"

msgid ""
"As not all XR runtimes support all composition layer types, Godot implements "
"a fallback solution where we render the viewport as part of the normal scene "
"but with the aforementioned quality limitations."
msgstr ""
"由於並非所有 XR 執行環境都支援所有合成圖層類型，Godot 提供了備用方案：將 "
"Viewport 當作一般場景的一部分來渲染，但會有前述的畫質限制。"

msgid ""
"When the composition layer is supported, it is the XR runtime that presents "
"the subviewport. This means the UI is only visible in the headset, it will "
"not be accessible by Godot and will thus not be shown when you have a "
"spectator view on the desktop."
msgstr ""
"若 XR 執行環境支援合成圖層，則 SubViewport 會由 XR 執行階段負責顯示。這代表 "
"UI 僅會在頭戴式裝置中可見，Godot 本身無法存取，因此在桌面端的旁觀者模式下也不"
"會顯示。"

msgid "There are currently 3 nodes that expose this functionality:"
msgstr "目前有三種節點可用來實現這項功能："

msgid ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a cylinder (or "
"\"slice\" of a cylinder)."
msgstr ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"會將 SubViewport 的內容顯示於圓柱內部（或圓柱的一個「切片」）上。"

msgid ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a sphere (or "
"\"slice\" of a sphere)."
msgstr ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"會將 SubViewport 的內容顯示於球體內部（或球體的一個「切片」）上。"

msgid ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a flat rectangle."
msgstr ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` 會將 "
"SubViewport 的內容顯示於平面矩形上。"

msgid "Setting up the SubViewport"
msgstr "設定 SubViewport"

msgid ""
"The first step is adding a SubViewport for our 2D UI, this doesn't require "
"any specific steps. For our example we do mark the viewport as transparent."
msgstr ""
"第一步是替 2D UI 新增一個 SubViewport，這不需要特別設定。在此範例中，會將 "
"Viewport 標記為透明。"

msgid ""
"You can now create the 2D UI by adding child nodes to the SubViewport as you "
"normally would. It is advisable to save the 2D UI in a subscene, this makes "
"it easier to do your layout."
msgstr ""
"接下來可以像平常一樣，將 2D 介面的子節點加入 SubViewport。建議將 UI 製作成子"
"場景，這樣更方便排版與管理。"

msgid ""
"The update mode \"When Visible\" will not work as Godot can't determine "
"whether the viewport is visible to the user. When assigning our viewport to "
"a composition layer Godot will automatically adjust this."
msgstr ""
"「僅在可見時更新」這個更新模式在這裡無法運作，因為 Godot 無法判斷 Viewport 是"
"否對用戶可見。當將 Viewport 指派給合成圖層時，Godot 會自動調整這個設定。"

msgid "Adding a composition layer"
msgstr "新增合成圖層"

msgid ""
"The second step is adding our composition layer. We can add the correct "
"composition layer node as a child node of our :ref:`XROrigin3D "
"<class_xrorigin3d>` node. This is very important as the XR runtime positions "
"everything in relation to our origin."
msgstr ""
"第二步是新增合成圖層。請將正確的合成圖層節點作為 :ref:`XROrigin3D "
"<class_xrorigin3d>` 的子節點。這非常重要，因為 XR 執行環境會以原點為基準來定"
"位所有物件。"

msgid ""
"We want to position the composition layer so it is at eye height and roughly "
"1 to 1.5 meters away from the player."
msgstr "建議將合成圖層設置在視線高度，並離玩家約 1 至 1.5 公尺遠的位置。"

msgid ""
"We now assign the SubViewport to the ``Layer Viewport`` property and enable "
"Alpha Blend."
msgstr ""
"接著將 SubViewport 指定到「Layer Viewport」屬性，並啟用 Alpha Blend（透明混"
"合）。"

msgid ""
"As the player can walk away from the origin point, you will want to "
"reposition the composition layer when the player recenters the view. Using "
"the reference space ``Local Floor`` will apply this logic automatically."
msgstr ""
"由於玩家可能會離開原點，建議在玩家重設視角時重新定位合成圖層。若使用「參考空"
"間」為 ``Local Floor``，這個邏輯會自動處理。"

msgid "Making the interface work"
msgstr "讓介面可互動"

msgid ""
"So far we're only displaying our UI, to make it work we need to add some "
"code. For this example we're going to keep things simple and make one of the "
"controllers work as a pointer. We'll then simulate mouse actions with this "
"pointer."
msgstr ""
"目前我們只是顯示 UI，若要讓介面可互動，需要加入一些程式碼。本範例會簡化處理，"
"讓其中一隻控制器作為指標，並用此指標模擬滑鼠操作。"

msgid ""
"This code also requires a ``MeshInstance3D`` node called ``Pointer`` to be "
"added as a child to our ``OpenXRCompositionLayerQuad`` node. We configure a "
"``SphereMesh`` with a radius ``0.01`` meters. We'll be using this as a "
"helper to visualize where the user is pointing."
msgstr ""
"這段程式也需要在 ``OpenXRCompositionLayerQuad`` 節點下加入名為 ``Pointer`` "
"的 ``MeshInstance3D`` 節點。其 Mesh 使用 ``SphereMesh``，半徑設為 0.01 公尺。"
"這個指標用來幫助視覺化使用者指向的位置。"

msgid ""
"The main function that drives this functionality is the ``intersects_ray`` "
"function on our composition layer node. This function takes the global "
"position and orientation of our pointer and returns the UV where our ray "
"intersects our viewport. It returns ``Vector2(-1.0, -1.0)`` if we're not "
"pointing at our viewport."
msgstr ""
"這項功能的核心在於合成圖層節點的 ``intersects_ray`` 方法。該方法會傳入指標的"
"全域位置和方向，並回傳光線與 Viewport 相交的 UV 座標。如果沒有指向 Viewport，"
"則會回傳 ``Vector2(-1.0, -1.0)``。"

msgid ""
"We start with setting up some variables, important here are the export "
"variables which identify our controller node with which we point to our "
"screen."
msgstr ""
"首先，先設定一些變數，最重要的是 export 變數，用以指定將用來指向畫面的控制器"
"節點。"

msgid ""
"Next we define a helper function that takes the value returned from "
"``intersects_ray`` and gives us the global position for that intersection "
"point. This implementation only works for our ``OpenXRCompositionLayerQuad`` "
"node."
msgstr ""
"接著定義一個輔助函式，將 ``intersects_ray`` 回傳的值轉換成該交點的全域座標。"
"以下實作僅適用於 ``OpenXRCompositionLayerQuad`` 節點。"

msgid ""
"We also define a helper function that takes our ``intersect`` value and "
"returns our location in the viewports local coordinate system:"
msgstr ""
"我們也會定義另一個輔助函式，將 ``intersect`` 值轉換為 Viewport 的區域座標："

msgid ""
"The main logic happens in our ``_process`` function. Here we start by hiding "
"our pointer, we then check if we have a valid controller and viewport, and "
"we call ``intersects_ray`` with the position and orientation of our "
"controller:"
msgstr ""
"主要邏輯會寫在 ``_process`` 函式：先隱藏指標，然後確認控制器與 Viewport 有"
"效，接著用控制器的位置和方向呼叫 ``intersects_ray``："

msgid ""
"Next we check if we're intersecting with our viewport. If so, we check if "
"our button is pressed and place our pointer at our intersection point."
msgstr ""
"接著檢查是否與 Viewport 相交。若有，則判斷按鈕是否被按下，並將指標放到交點。"

msgid ""
"If we were intersecting in our previous process call and our pointer has "
"moved, we prepare a :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` object to simulate our mouse moving and send "
"that to our viewport for further processing."
msgstr ""
"如果上一幀有相交且指標位置有變動，則建立一個 :ref:`InputEventMouseMotion "
"<class_InputEventMouseMotion>` 事件，模擬滑鼠移動，並傳送給 Viewport 處理。"

msgid ""
"If we've just released our button we also prepare "
"a :ref:`InputEventMouseButton <class_InputEventMouseButton>` object to "
"simulate a button release and send that to our viewport for further "
"processing."
msgstr ""
"如果剛釋放按鈕，也會產生 :ref:`InputEventMouseButton "
"<class_InputEventMouseButton>` 事件，模擬滑鼠按鈕釋放，並傳送給 Viewport 處"
"理。"

msgid ""
"Or if we've just pressed our button we prepare a :ref:`InputEventMouseButton "
"<class_InputEventMouseButton>` object to simulate a button press and send "
"that to our viewport for further processing."
msgstr ""
"如果剛按下按鈕，則產生 :ref:`InputEventMouseButton "
"<class_InputEventMouseButton>` 事件，模擬滑鼠按下，並傳送給 Viewport 處理。"

msgid "Next we remember our state for next frame."
msgstr "然後記錄目前狀態，以便下個畫面更新時使用。"

msgid "Finally, if we aren't intersecting, we clear our state."
msgstr "最後，若沒有相交，將狀態清空。"

msgid "Hole punching"
msgstr "打洞 (Hole Punching)"

msgid ""
"As the composition layer is composited on top of the render result, it can "
"be rendered in front of objects that are actually forward of the viewport."
msgstr ""
"由於合成圖層疊加在渲染結果之上，有時會導致它出現在理論上應在 Viewport 前方的"
"物件之上。"

msgid ""
"By enabling hole punch you instruct Godot to render a transparent object "
"where our viewport is displayed. It does this in a way that fills the depth "
"buffer and clears the current rendering result. Anything behind our viewport "
"will now be cleared, while anything in front of our viewport will be "
"rendered as usual."
msgstr ""
"啟用 Hole Punching（打洞）功能後，Godot 會在 Viewport 顯示的位置渲染一個透明"
"物件，這個物件會填滿深度緩衝區並清除目前的渲染結果。如此一來，Viewport 後方的"
"物件會被清除，而前方的物件則正常渲染。"

msgid ""
"You also need to set ``Sort Order`` to a negative value, the XR compositor "
"will now draw the viewport first, and then overlay our rendering result."
msgstr ""
"同時需將 ``Sort Order`` 設為負值，這樣 XR 合成器會先繪製 Viewport，再疊加其他"
"渲染結果。"

msgid ""
"Use case showing how the users hand is incorrectly obscured by a composition "
"layer when hole punching is not used."
msgstr "若未啟用 Hole Punching，使用者的手可能會被合成圖層錯誤地遮蔽。"
