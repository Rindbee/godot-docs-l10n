#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR Render Models"
msgstr "OpenXR 算繪模型"

msgid ""
"A cornerstone of OpenXR's API design is being as platform agnostic as "
"possible. A great example of this is OpenXR's action map system where XR "
"runtimes have to support core interaction profiles to fall back on, if no "
"interaction profile exists for the hardware being used. This ensures that "
"OpenXR applications keep functioning even when used on hardware that didn't "
"exist when the application was released, or that the developers of the "
"application did not have access too."
msgstr ""
"OpenXR API 設計的一大基石，就是盡可能與平台無關。其典型例子是 OpenXR 的動作對"
"應系統：即使目前使用的硬體沒有對應的互動設定檔，XR 執行階段也必須支援核心互動"
"設定檔作為退回選項。這可確保 OpenXR 應用程式即便在發佈時尚不存在、或開發者無"
"法取得的硬體上使用時，仍能正常運作。"

msgid ""
"A consequence of this is that the application developer doesn't know with "
"any certainty what hardware is being used, as the XR runtime could be "
"mimicking other hardware. The application developer thus can't show anything "
"in relation to the actual hardware used, the most common use case being "
"showing the controllers the user is currently holding."
msgstr ""
"其結果之一，是應用程式開發者無法確定實際使用中的硬體，因為 XR 執行階段可能在"
"模擬其他硬體。於是，開發者無法展示與「實際硬體」相關的內容；最常見的需求就是"
"顯示使用者手上正在握持的控制器。"

msgid ""
"Showing the correct controller models and having these models correctly "
"positioned is important to a proper sense of immersion."
msgstr "顯示正確的控制器模型並正確定位，對維持良好的沉浸感至關重要。"

msgid ""
"This is where OpenXR's `render models API <https://registry.khronos.org/"
"OpenXR/specs/1.1/html/xrspec.html#XR_EXT_render_models>`_ comes in. This API "
"allows us to query the XR runtime for 3D assets that are correct for the "
"physical hardware being used. The API also allows us to query the position "
"of this hardware within the tracking volume and the correct positioning of "
"subcomponents of this hardware."
msgstr ""
"這正是 OpenXR 的 `Render Models API <https://registry.khronos.org/OpenXR/"
"specs/1.1/html/xrspec.html#XR_EXT_render_models>`_ 派上用場的地方。此 API 允"
"許我們向 XR 執行階段查詢與實際使用之硬體相符的 3D 資產。它也允許我們查詢該硬"
"體在追蹤空間中的位置，以及其子元件的正確定位。"

msgid ""
"For instance, we can correctly position and animate the trigger or show "
"buttons being pressed."
msgstr "例如，我們可以正確定位並驅動扳機的動畫，或顯示按鈕被按下的狀態。"

msgid ""
"For those runtimes that support the `controller data source for hand "
"tracking <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_tracking_data_source>`_ , we can also correctly "
"position the user's fingers and hand according to the shape of the "
"controller. Do note that this works in combination with the `hand joints "
"motion range extension <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_joints_motion_range>`_ to prevent clipping of the "
"fingers."
msgstr ""
"對於支援 `手部追蹤控制器資料來源 <https://registry.khronos.org/OpenXR/specs/"
"1.1/html/xrspec.html#XR_EXT_hand_tracking_data_source>`_ 的執行階段，我們也能"
"依控制器的形狀正確定位使用者的手指與手。請注意，這需要搭配 `手部關節活動範圍"
"擴充 <https://registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_hand_joints_motion_range>`_ 使用，以避免手指穿模。"

msgid "OpenXR Render models node"
msgstr "OpenXR 算繪模型節點"

msgid ""
"The :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node can "
"be used to automate most of the render models functionality. This node keeps "
"track of the active render models currently made available by the XR runtime."
msgstr ""
":ref:`OpenXRRenderModelManager <class_OpenXRRenderModelManager>` 節點可用來自"
"動化多數算繪模型的功能。此節點會追蹤 XR 執行階段目前提供的作用中算繪模型。"

msgid ""
"It will create child nodes for each active render model resulting in that "
"render model being displayed."
msgstr "它會為每個作用中的算繪模型建立子節點，並據此顯示對應的算繪模型。"

msgid ""
"This node must have an :ref:`XROrigin3D<class_XROrigin3D>` node as an "
"ancestor."
msgstr "此節點必須有一個 :ref:`XROrigin3D <class_XROrigin3D>` 節點作為其祖先。"

msgid ""
"If ``tracker`` is set to ``Any`` our node will show all render models "
"currently being tracked. In this scenario this node must be a direct child "
"of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"若將 ``tracker`` 設為 ``Any``，本節點會顯示目前所有被追蹤的算繪模型。此情況"
"下，本節點必須是 :ref:`XROrigin3D <class_XROrigin3D>` 的直接子節點。"

msgid ""
"If ``tracker`` is set to ``None set`` our node will only show render models "
"for which no tracker has been identified. In this scenario this node must "
"also be a direct child of our :ref:`XROrigin3D<class_XROrigin3D>` node."
msgstr ""
"若將 ``tracker`` 設為 ``None set``，本節點只會顯示尚未識別追蹤器的算繪模型。"
"此情況下，本節點同樣必須是 :ref:`XROrigin3D <class_XROrigin3D>` 的直接子節"
"點。"

msgid ""
"If ``tracker`` is set to ``Left Hand`` or ``Right Hand`` our node will only "
"show render models related to our left or right hand respectively. In this "
"scenario, our node can be placed deeper in the scene tree."
msgstr ""
"若將 ``tracker`` 設為 ``Left Hand`` 或 ``Right Hand``，本節點將分別只顯示與左"
"手或右手相關的算繪模型。此情況下，本節點可以放在場景樹更深的位置。"

msgid ""
"For most XR runtimes this means the render model represents a controller "
"that is actually being held by the user but this is not a guarantee. Some XR "
"runtimes will always set the tracker to either the left or right hand even "
"if the controller is not currently held but is being tracked. You should "
"always test this as this will lead to unwanted behavior."
msgstr ""
"對多數 XR 執行階段來說，這表示算繪模型代表使用者實際握持的控制器，但不保證一"
"定如此。有些 XR 執行階段即使控制器未被持握、只是在被追蹤，也會一律將追蹤器設"
"定為左手或右手。因此請務必測試，否則可能導致不期望的行為。"

msgid ""
"In this scenario we can also specify an action for a pose in the action map "
"by setting the ``make_local_to_pose`` property to the pose action. Use this "
"in combination with an :ref:`XRController3D<class_XRController3D>` node that "
"is using the same pose and you can now add a layer that allows you to "
"deviate from the tracked position of both your controller and the related "
"render model (see example below)."
msgstr ""
"在此情境中，我們也可以將 ``make_local_to_pose`` 屬性設定為某個姿勢的動作，來"
"指定動作對應表中的姿勢。配合同樣使用該姿勢的 :ref:`XRController3D "
"<class_XRController3D>` 節點，即可新增一個層級，讓控制器與其相關的算繪模型得"
"以偏離原先的追蹤位置（見下方範例）。"

msgid ""
"Combining the above with hand tracking does introduce the problem that hand "
"tracking is completely independent from the action map system. You will need "
"to combine the hand tracking and controller tracking poses to properly "
"offset the render models."
msgstr ""
"將上述方法與手部追蹤結合時，會遇到一個問題：手部追蹤與動作對應系統完全獨立。"
"你需要結合手部追蹤與控制器追蹤的姿勢，才能正確地對算繪模型做偏移。"

msgid "This falls beyond the scope of this documentation."
msgstr "這超出本文件的範圍。"

msgid "Render model manager example"
msgstr "算繪模型管理員範例"

msgid ""
"You can download `our render models demo <https://github.com/godotengine/"
"godot-demo-projects/tree/master/xr/openxr_render_models>`_ which implements "
"the setup described below."
msgstr ""
"你可以下載 `我們的算繪模型示範專案 <https://github.com/godotengine/godot-"
"demo-projects/tree/master/xr/openxr_render_models>`_，其中實作了下述的設定。"

msgid ""
"In this setup we find "
"an :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` node "
"directly underneath our :ref:`XROrigin3D<class_XROrigin3D>` node. On this "
"node our ``target`` property is set to ``None set`` and will handle showing "
"all render models that are currently not related to our left or right hand "
"controllers."
msgstr ""
"在此設定中，我們在 :ref:`XROrigin3D <class_XROrigin3D>` 節點底下放了一"
"個 :ref:`OpenXRRenderModelManager <class_OpenXRRenderModelManager>` 節點。其 "
"``target`` 屬性設為 ``None set``，用以顯示目前與左右手控制器無關的所有算繪模"
"型。"

msgid ""
"We then see the same setup for our left and right hand so we'll focus on "
"just the left hand."
msgstr "接著左右手使用相同的設定，因此以下只專注在左手。"

msgid ""
"We have an :ref:`XRController3D<class_XRController3D>` that will track the "
"location of our hand."
msgstr ""
"我們有一個 :ref:`XRController3D <class_XRController3D>` 節點用來追蹤手的位"
"置。"

msgid ""
"We are using the ``grip`` pose in this example. The ``palm`` pose is "
"arguably more suitable and predictable however it is not supported by all XR "
"runtimes. See the hand tracking demo project for a solution to switching "
"between these poses based on what is supported."
msgstr ""
"本例使用 ``grip`` 姿勢。嚴格來說 ``palm`` 姿勢更適合且更可預期，但並非所有 "
"XR 執行階段都支援。請參考手部追蹤示範專案，了解如何根據支援度在這些姿勢間切"
"換。"

msgid ""
"As a child of the node we have "
"an :ref:`AnimatableBody3D<class_AnimatableBody3D>` node that follows the "
"tracked location of the hand **but** will interact with physics objects to "
"stop the player's hand from going through walls etc. This node has a "
"collision shape that encapsulates the hand."
msgstr ""
"作為其子節點，我們加入了一個 :ref:`AnimatableBody3D "
"<class_AnimatableBody3D>`，它會跟隨手部的追蹤位置，**但** 同時會與物理物件互"
"動，避免玩家的手穿過牆面等。此節點具備包覆手部的碰撞形狀。"

msgid ""
"It is important to set the physics priority so that this logic runs after "
"any physics logic that moves the XROrigin3D node or the hand will lag a "
"frame behind."
msgstr ""
"務必設定物理優先順序，使這段邏輯在任何會移動 XROrigin3D 的物理邏輯之後執行，"
"否則手部會落後一個畫面幀。"

msgid ""
"The script below shows a basic implementation for this that you can build "
"upon."
msgstr "以下腳本展示了基本的實作，可在此基礎上擴充。"

msgid ""
"Finally we see "
"another :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` "
"node, this one with ``target`` set to the appropriate hand and "
"``make_local_to_pose`` set to the correct pose. This will ensure that the "
"render models related to this hand are properly shown and offset if our "
"collision handler has altered the location."
msgstr ""
"最後，還有另一個 :ref:`OpenXRRenderModelManager "
"<class_OpenXRRenderModelManager>` 節點，這次將 ``target`` 設為對應的手，並將 "
"``make_local_to_pose`` 設為正確的姿勢。如此可確保與該手相關的算繪模型能正確顯"
"示，且在碰撞處理改變位置時能正確做出偏移。"

msgid "Render model node"
msgstr "算繪模型節點"

msgid ""
"The :ref:`OpenXRRenderModel<class_OpenXRRenderModel>` node implements all "
"the logic to display and position a given render model provided by the "
"render models API."
msgstr ""
":ref:`OpenXRRenderModel <class_OpenXRRenderModel>` 節點實作了顯示與定位算繪模"
"型所需的全部邏輯，這些模型由 Render Models API 提供。"

msgid ""
"Instances of this node are added by the render model manager node we used up "
"above but you can interact with these directly if you wish."
msgstr ""
"此節點的實例由上文使用的算繪模型管理員節點新增，不過若需要，你也可以直接與這"
"些實例互動。"

msgid ""
"Whenever Godot obtains information about a new render model an RID is "
"created to reference that render model."
msgstr ""
"每當 Godot 取得一個新算繪模型的資訊時，會建立一個 RID 來參照該算繪模型。"

msgid ""
"By assigning that RID to the ``render_model`` property on this node, the "
"node will start displaying the render model and manage both the transform "
"that places the render model in the correct place and animates all the sub "
"objects."
msgstr ""
"將該 RID 指定給本節點的 ``render_model`` 屬性後，此節點就會開始顯示該算繪模"
"型，並同時管理將其放置在正確位置所需的轉換，以及所有子物件的動畫。"

msgid ""
"The ``get_top_level_path`` function will return the top level path "
"associated with this render model. This will point to either the left or "
"right hand. As the top level path can be set or cleared depending on whether "
"the user picks up, or puts down, the controller you can connect to the "
"``render_model_top_level_path_changes`` signal and react to these changes."
msgstr ""
"``get_top_level_path`` 函式會回傳與此算繪模型關聯的最高層路徑，指向左手或右"
"手。由於最高層路徑會隨使用者拾起或放下控制器而被設定或清除，你可以連接 "
"``render_model_top_level_path_changes`` 訊號以回應這些變化。"

msgid ""
"Depending on your setup of "
"the :ref:`OpenXRRenderModelManager<class_OpenXRRenderModelManager>` nodes, "
"render models will be removed or added as their top level path changes."
msgstr ""
"依據你設定的 :ref:`OpenXRRenderModelManager "
"<class_OpenXRRenderModelManager>` 節點，算繪模型會隨其最高層路徑的變化而被移"
"除或加入。"

msgid "Backend access"
msgstr "後端存取"

msgid ""
"The nodes we've detailed out above handle all the display logic for us but "
"it is possible to interact with the data that drives this directly and "
"create your own implementation."
msgstr ""
"上述節點已為我們處理所有顯示邏輯，但你也可以直接與其背後的資料互動，並自行實"
"作。"

msgid ""
"For this you can access "
"the :ref:`OpenXRRenderModelExtension<class_OpenXRRenderModelExtension>` "
"singleton."
msgstr ""
"為此，你可以存取 :ref:`OpenXRRenderModelExtension "
"<class_OpenXRRenderModelExtension>` 單例。"

msgid ""
"This object also lets you query whether render models are supported and "
"enabled on the device currently being used by calling the ``is_active`` "
"function on this object."
msgstr ""
"此物件也可用於查詢目前裝置是否支援並啟用了算繪模型，方法是呼叫此物件的 "
"``is_active`` 函式。"

msgid ""
"The built-in logic implements the `interaction render model API <https://"
"registry.khronos.org/OpenXR/specs/1.1/html/"
"xrspec.html#XR_EXT_interaction_render_model>`_ that lists all render models "
"related to controllers and similar devices that are present in the action "
"map. It will automatically create and remove render model entities that are "
"exposed through this API."
msgstr ""
"內建邏輯實作了 `Interaction Render Model API <https://registry.khronos.org/"
"OpenXR/specs/1.1/html/xrspec.html#XR_EXT_interaction_render_model>`_，會列出"
"動作對應表中與控制器及類似裝置相關的所有算繪模型，並自動建立與移除透過此 API "
"暴露的算繪模型實體。"

msgid ""
"As other extensions become available these can be implemented in a "
"GDExtension plugin. Such a plugin can call ``render_model_create`` and "
"``render_model_destroy`` to create the object that will provide access to "
"that render model through the core render models API."
msgstr ""
"未來若出現其他擴充功能，可透過 GDExtension 外掛來實作。此類外掛可呼叫 "
"``render_model_create`` 與 ``render_model_destroy``，建立可透過核心 Render "
"Models API 存取該算繪模型的物件。"

msgid "You should not destroy a render model outside of this logic."
msgstr "不應在此邏輯之外銷毀算繪模型。"

msgid ""
"You can connect to the ``render_model_added`` and ``render_model_removed`` "
"signals to be informed when new render models are added or removed."
msgstr ""
"你可以連接 ``render_model_added`` 與 ``render_model_removed`` 訊號，以得知何"
"時有新的算繪模型被加入或移除。"

msgid "The core methods for working with this API are listed below:"
msgstr "以下列出操作此 API 的核心方法："

msgid "Render modele extension functions"
msgstr "算繪模型擴充功能函式"

msgid "Function"
msgstr "函式"

msgid "Description"
msgstr "說明"

msgid "render_model_get_all"
msgstr "render_model_get_all"

msgid "Provides an array of RIDs for all render models that are being tracked."
msgstr "提供所有正在被追蹤之算繪模型的 RID 陣列。"

msgid "render_model_new_scene_instance"
msgstr "render_model_new_scene_instance"

msgid ""
"Provides a new scene that contains all meshes needed to display the render "
"model."
msgstr "提供一個新場景，包含顯示該算繪模型所需的所有網格。"

msgid "render_model_get_subaction_paths"
msgstr "render_model_get_subaction_paths"

msgid ""
"Provides a list of subaction paths from your action map related to this "
"render mode."
msgstr "提供動作對應表中與此算繪模型相關的子動作路徑列表。"

msgid "render_model_get_top_level_path"
msgstr "render_model_get_top_level_path"

msgid ""
"Returns the top level path associated with this render model (if any). Use "
"the ``render_model_top_level_path_changed`` signal to react to this changing."
msgstr ""
"回傳與此算繪模型關聯的最高層路徑（若有）。可透過 "
"``render_model_top_level_path_changed`` 訊號來回應此變更。"

msgid "render_model_get_confidence"
msgstr "render_model_get_confidence"

msgid ""
"Returns the tracking confidence for the tracking data for this render model."
msgstr "回傳此算繪模型追蹤資料的追蹤信心度。"

msgid "render_model_get_root_transform"
msgstr "render_model_get_root_transform"

msgid ""
"Returns the root transform for this render model within our current "
"reference space. This can be used to place the render model in space."
msgstr "回傳此算繪模型在目前參考空間中的根轉換，可用於將算繪模型放置到空間中。"

msgid "render_model_get_animatable_node_count"
msgstr "render_model_get_animatable_node_count"

msgid ""
"Returns the number of nodes in our render model scene that can be animated"
msgstr "回傳此算繪模型場景中可被驅動動畫的節點數量"

msgid "render_model_get_animatable_node_name"
msgstr "render_model_get_animatable_node_name"

msgid ""
"Returns the name of the node that we can animate. Note that this node can be "
"any number of levels deep within the scene."
msgstr ""
"回傳可被驅動動畫之節點的名稱。請注意，此節點可能位於場景中任意深度的階層。"

msgid "render_model_is_animatable_node_visible"
msgstr "render_model_is_animatable_node_visible"

msgid "Returns true if this animatable node should be visible"
msgstr "若此可動畫節點應可見則回傳 true"

msgid "render_model_get_animatable_node_transform"
msgstr "render_model_get_animatable_node_transform"

msgid ""
"Returns the transform for this animatable node. This is a local transform "
"that can be directly applied."
msgstr "回傳此可動畫節點的轉換。這是可直接套用的區域轉換。"
