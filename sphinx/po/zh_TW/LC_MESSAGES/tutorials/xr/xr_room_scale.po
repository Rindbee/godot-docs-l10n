#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Room scale in XR"
msgstr "XR 房間規模"

msgid ""
"One of the staples of XR projects is the ability to walk around freely in a "
"large space. This space is often constrained by the room the player is "
"physically in with tracking sensors placed within this space. With the "
"advent of inside out tracking however ever larger play spaces are possible."
msgstr ""
"XR 專案的一大特色是能夠在大空間中自由走動。這個空間通常受限於玩家實際所在的房"
"間，並在房間內設置追蹤感測器。然而，隨著「內向外」追蹤技術的出現，遊戲空間可"
"以大幅擴展。"

msgid ""
"As a developer this introduces a number of interesting challenges. In this "
"document we will look at a number of the challenges you may face and outline "
"some solutions. We'll discuss the issues and challenges for seated XR games "
"in another document."
msgstr ""
"對開發者來說，這帶來了許多有趣的挑戰。本文件將探討你可能遇到的各種挑戰並概述"
"一些解決方案。針對坐式 XR 遊戲的相關議題，會在另一份文件中說明。"

msgid ""
"Often developers sit behind their desk while building the foundation to "
"their game. In this mode the issues with developing for room scale don't "
"show themselves until it is too late. The advice here is to start testing "
"while standing up and walking around as early as possible. Once you are "
"happy your foundation is solid, you can develop in comfort while remaining "
"seated."
msgstr ""
"開發遊戲初期，開發者通常坐在桌前進行基礎開發。這種情況下，房間規模的相關問題"
"往往到了較晚階段才顯現。因此建議盡早站起來走動測試，確保基礎功能穩固後，再選"
"擇舒適地坐著開發。"

msgid ""
"In traditional first person games a player is represented by "
"a :ref:`CharacterBody3D <class_characterbody3d>` node. This node is moved by "
"processing traditional controller, mouse or keyboard input. A camera is "
"attached to this node at a location roughly where the player's head will be."
msgstr ""
"在傳統第一人稱遊戲中，玩家通常由 :ref:`CharacterBody3D "
"<class_characterbody3d>` 節點表示。這個節點透過控制器、滑鼠或鍵盤輸入來移動，"
"相機則安裝在該節點上、約略對應玩家的頭部位置。"

msgid ""
"Applying this model to the XR setup, we add an :ref:`XROrigin3D "
"<class_xrorigin3d>` node as a child of the character body, and add "
"an :ref:`XRCamera3D <class_xrcamera3d>` as a child of the origin node. At "
"face value this seems to work. However, upon closer examination this model "
"does not take into account that there are two forms of movement in XR. The "
"movement through controller input, and the physical movement of the player "
"in the real world."
msgstr ""
"將這種模型套用到 XR 設定時，我們會在角色本體下新增 :ref:`XROrigin3D "
"<class_xrorigin3d>` 節點作為子節點，再在原點節點下新增 :ref:`XRCamera3D "
"<class_xrcamera3d>` 作為其子節點。表面上這看起來可行，但實際上這個模型並未考"
"慮到 XR 裡有兩種移動方式：一種是控制器輸入造成的移動，另一種是玩家在現實空間"
"中的實體移動。"

msgid ""
"The first problem this causes is fairly obvious. When the player moves with "
"controller input, we can use the same approach in normal games and move the "
"player in a forward direction. However the player isn't where we think they "
"are and as we move forward we're checking collisions in the wrong location."
msgstr ""
"這會導致第一個很明顯的問題：當玩家透過控制器移動時，我們雖然用跟普通遊戲一樣"
"的方式讓玩家角色向前移動，但其實玩家實際在空間中的位置早就偏離預期，導致碰撞"
"檢查會判斷錯誤的位置。"

msgid ""
"The second problem really shows itself when the player walks further away "
"from the center of the tracking space and uses controller input to turn. If "
"we rotate our character body, the player will be moved around the room in a "
"circular fashion."
msgstr ""
"第二個問題在於玩家離開追蹤空間中心、並用控制器轉動時會出現。如果我們旋轉角色"
"本體，玩家會以圓周方式在房間內移動。"

msgid ""
"If we fix the above issues, we will find a third issue. When the path for "
"the player is blocked in the virtual world, the player can still physically "
"move forward."
msgstr ""
"即使我們解決了上述問題，還會遇到第三個問題：當虛擬世界中玩家路徑被擋住時，玩"
"家在現實中還是可以繼續往前走。"

msgid ""
"We will look at solving the first two problem with two separate solutions, "
"and then discuss dealing with the third."
msgstr "我們將用兩種不同的解法處理前兩個問題，再討論第三個問題的應對方式。"

msgid "Origin centric solution"
msgstr "以原點為中心的解決方案"

msgid ""
"Looking at the first approach for solving this we are going to change our "
"structure. This is the approach currently implemented in XR Tools."
msgstr "首先我們介紹結構調整的解法，這也是 XR Tools 目前採用的方法。"

msgid ""
"In this setup we mark the character body as top level so it does not move "
"with the origin."
msgstr "在這種架構下，將角色本體標記為頂層，讓它不會隨原點一起移動。"

msgid ""
"We also have a helper node that tells us where our neck joint is in relation "
"to our camera. We use this to determine where our body center is."
msgstr ""
"此外，我們會加入一個輔助節點，用於標示脖子關節相對於相機的位置，藉此推算身體"
"中心點。"

msgid "Processing our character movement is now done in three steps."
msgstr "角色移動現在分為三個步驟處理。"

msgid ""
"The `Origin centric movement demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/xr/openxr_origin_centric_movement>`__ contains a more "
"elaborate example of the technique described below."
msgstr ""
"`以原點為中心的移動範例 <https://github.com/godotengine/godot-demo-projects/"
"tree/master/xr/openxr_origin_centric_movement>`__ 提供了下述技術更詳細的實作"
"範例。"

msgid "Step 1"
msgstr "步驟 1"

msgid ""
"In the first step we're going to process the physical movement of the "
"player. We determine where the player is right now, and attempt to move our "
"character body there."
msgstr ""
"第一步是處理玩家的實體移動。我們會偵測玩家目前所在位置，並嘗試讓角色本體移動"
"到該處。"

msgid ""
"Note that we're returning ``true`` from our "
"``_process_on_physical_movement`` function when we couldn't move our player "
"all the way."
msgstr ""
"請注意，當我們無法讓玩家完全移動到目標位置時，"
"`_process_on_physical_movement` 函式會回傳 ``true``。"

msgid "Step 2"
msgstr "步驟 2"

msgid ""
"The second step is to handle rotation of the player as a result of user "
"input."
msgstr "第二步是根據使用者輸入處理玩家的旋轉。"

msgid ""
"As the input used can differ based on your needs we are simply calling the "
"function ``_get_rotational_input``. This function should obtain the "
"necessary input and return the rotational speed in radians per second."
msgstr ""
"由於專案需求不同，輸入方式也會不同，因此我們單純呼叫 `_get_rotational_input` "
"函式。這個函式應該取得必要的輸入，並回傳每秒弧度的旋轉速度。"

msgid ""
"For our example we are going to keep this simple and straight forward. We "
"are not going to worry about comfort features such as snap turning and "
"applying a vignette. We highly recommend implementing such comfort features."
msgstr ""
"在範例中，我們會以簡化方式示範，不會加入如「瞬間轉向」或「視角暈染」等舒適性"
"設計。建議正式開發時務必加入這類舒適性功能。"

msgid ""
"We've added the call for processing our rotation to our physics process but "
"we are only executing this if we were able to move our player fully. This "
"means that if the player moves somewhere they shouldn't, we don't process "
"further movement."
msgstr ""
"我們在物理流程中加入旋轉處理，但僅在玩家能完整移動時才執行。也就是說，若玩家"
"移動到不該去的位置，我們就不再處理進一步移動。"

msgid "Step 3"
msgstr "步驟 3"

msgid ""
"The third and final step is moving the player forwards, backwards or "
"sideways as a result of user input."
msgstr "第三步，也是最後一步，是根據玩家輸入讓角色前進、後退或側移。"

msgid ""
"Just like with the rotation the inputs differ from project to project so we "
"are simply calling the function ``_get_movement_input``. This function "
"should obtain the necessary input and return a directional vector scaled to "
"the required velocity."
msgstr ""
"和旋轉一樣，不同專案的移動輸入也會不同，因此我們只需呼叫 "
"`_get_movement_input` 函式，讓它取得輸入，並傳回經速度縮放的方向向量。"

msgid ""
"Just like with rotation we're keeping it simple. Here too it is advisable to "
"look at adding comfort settings."
msgstr "同樣地，這裡也只做簡單處理。實務上建議加上舒適性選項。"

msgid "Character body centric solution"
msgstr "以角色本體為中心的解決方案"

msgid ""
"In this setup we are going to keep our character body as our root node and "
"as such is easier to combine with traditional game mechanics."
msgstr "在這個架構下，我們將角色本體作為根節點，這樣更容易與傳統遊戲機制結合。"

msgid ""
"Here we have a standard character body with collision shape, and our XR "
"origin node and camera as normal children. We also have our neck helper node."
msgstr ""
"這裡我們有一個帶有碰撞形狀的標準角色本體，以及原點節點和相機作為普通子節點。"
"還有脖子輔助節點。"

msgid ""
"Processing our character movement is done in the same three steps but "
"implemented slightly differently."
msgstr "角色移動同樣以三步驟處理，但實作細節略有不同。"

msgid ""
"The `Character centric movement demo <https://github.com/godotengine/godot-"
"demo-projects/tree/master/xr/openxr_character_centric_movement>`__ contains "
"a more elaborate example of the technique described below."
msgstr ""
"`以角色本體為中心的移動範例 <https://github.com/godotengine/godot-demo-"
"projects/tree/master/xr/openxr_character_centric_movement>`__ 提供了下述技術"
"更完整的範例。"

msgid ""
"In this approach step 1 is where all the magic happens. Just like with our "
"previous approach we will be applying our physical movement to the character "
"body, but we will counter that movement on the origin node."
msgstr ""
"這種方法的精髓就在步驟 1。我們會像前一個方法一樣，將物理移動套用到角色本體，"
"但同時在原點節點上做反向抵消。"

msgid ""
"In essence the code above will move the character body to where the player "
"is, and then move the origin node back in equal amounts. The result is that "
"the player stays centered above the character body."
msgstr ""
"本質上，這種寫法會讓角色本體移動到玩家當前位置，再將原點節點等量向後移動，使"
"玩家始終位於角色本體上方的中心。"

msgid ""
"We start with applying the rotation. The character body should be facing "
"where the player was looking the previous frame. We calculate our camera "
"orientation in the space of the character body. We can now calculate the "
"angle by which the player has rotated their head. We rotate our character "
"body by the same amount so our character body faces the same direction as "
"the player. And then we reverse the rotation on the origin node so the "
"camera ends up aligned with the player again."
msgstr ""
"我們先處理旋轉。角色本體應該朝向玩家在前一幀看的方向，因此需先計算相機在角色"
"本體空間中的朝向，再計算玩家頭部旋轉的角度。然後以相同角度旋轉角色本體，使其"
"朝向與玩家一致，最後在原點節點上做反向旋轉，讓相機再次與玩家對齊。"

msgid ""
"For the movement we do much the same. The character body should be where the "
"player was standing the previous frame. We calculate by how much the player "
"has moved from this location. Then we attempt to move the character body to "
"this location."
msgstr ""
"移動也是同樣道理。角色本體應該出現在玩家前一幀所站位置，計算玩家從該處移動的"
"距離後，再嘗試將角色本體移動到這個新位置。"

msgid ""
"As the player may hit a collision body and be stopped, we only move the "
"origin point back by the amount we actually moved the character body. The "
"player may thus move away from this location but that will be reflected in "
"the positioning of the player."
msgstr ""
"由於玩家可能因碰撞體而被阻擋，我們只將原點節點往回移動角色本體實際移動的距"
"離。這樣即使玩家偏離原預期位置，仍可正確反映在定位上。"

msgid "As with our previous solution we return true if this is the case."
msgstr "如同前述解法，遇到這種情況時會回傳 true。"

msgid ""
"In this step we again apply the rotation based on controller input. However "
"in this case the code is nearly identical to how one would implement this in "
"a normal first person game."
msgstr "這一步中，會根據控制器輸入套用旋轉，基本寫法就跟一般第一人稱遊戲一樣。"

msgid ""
"For step three we again apply the movement based on controller input. "
"However just like at step 2, we can now implement this as we would in a "
"normal first person game."
msgstr "第三步同樣是根據控制器輸入執行移動，實作方式就和傳統第一人稱遊戲一樣。"

msgid "When the player walks to somewhere they shouldn't"
msgstr "當玩家走到不該去的地方"

msgid ""
"Think of a situation where the player is outside a locked room. You don't "
"want the player to go into that room until the door is unlocked. You also "
"don't want the player to see what is in this room."
msgstr ""
"想像玩家站在一間上鎖房間外面。你不希望玩家在門打開前就進房間，也不希望玩家看"
"到房間內的內容。"

msgid ""
"The logic for moving the player through controller input nicely prevents "
"this. The player encounters a static body, and the code prevents the player "
"from moving into the room."
msgstr ""
"透過控制器移動玩家時的邏輯能妥善阻止這種狀況。當玩家碰到靜態物件時，程式碼會"
"阻止玩家進入房間。"

msgid ""
"However with XR, nothing is preventing the player from taking a real step "
"forward."
msgstr "但在 XR 中，現實裡沒什麼能阻止玩家踏出真正的一步。"

msgid ""
"With both the approaches worked out up above we will prevent the character "
"body from moving where the player can't go. As the player has physically "
"moved to this location, the camera will now have moved into the room."
msgstr ""
"上述兩種方法都會阻止角色本體移動到玩家不可進入的位置。但如果玩家在現實中真的"
"走過去，相機還是會跑進房間裡。"

msgid ""
"The logical solution would be to prevent the movement altogether and adjust "
"the placement of the XR origin point so the player stays outside of the room."
msgstr "理論上可以完全禁止這種移動，並調整 XR 原點的位置，讓玩家待在房間外。"

msgid ""
"The problem with this approach is that physical movement is now not "
"replicated in the virtual space. This will cause nausea for the player."
msgstr ""
"但這麼做會讓物理移動無法在虛擬世界中如實反映，這可能導致玩家產生暈眩感。"

msgid ""
"Our solutions up above would allow us to add this logic into the code at the "
"end of step 1."
msgstr "上述解法可讓我們將這段判斷邏輯加入步驟 1 的程式碼最後。"

msgid "Further improvements to the code presented could be:"
msgstr "進一步改進程式碼的建議："

msgid "allowing controller input as long as this distance is still small,"
msgstr "只要這個距離尚小，仍允許控制器輸入動作，"

msgid ""
"still applying gravity to the player even when controller input is disabled."
msgstr "即便停用控制器輸入，也要讓玩家繼續受到重力影響。"

msgid ""
"The movement demos in our demo repository contain an example of blacking out "
"the screen when a user walks into restricted areas."
msgstr "我們的範例專案中有展示玩家走進限制區時畫面漸黑的實作範例。"

msgid "Further suggestions for improvements"
msgstr "更多改進建議"

msgid ""
"The above provides two good options as starting points for implementing room "
"scale XR games."
msgstr "以上兩種方法都很適合作為開發房間規模 XR 遊戲的起點。"

msgid ""
"A few more things that are worth pointing out that you will likely want to "
"implement:"
msgstr "還有幾項實作上值得注意的建議："

msgid ""
"The height of the camera can be used to detect whether the player is "
"standing up, crouching, jumping or lying down. You can adjust the size and "
"orientation of the collision shape accordingly. Extra bonus points for "
"adding multiple collision shapes so the head and body have their own, more "
"accurately sized, shapes."
msgstr ""
"可利用相機高度判斷玩家是站立、蹲下、跳躍還是躺下，並據此動態調整碰撞形狀的大"
"小與朝向。若能針對頭部和身體各自設置更精確的碰撞形狀，效果會更好。"

msgid ""
"When a scene first loads, the player may be far away from the center of the "
"tracking space. This could result in the player spawning into a different "
"room than our origin point. The game will now attempt, and fail, to move the "
"player body from the starting point to where the player is standing. You "
"should implement a reset function that moves the origin point so the player "
"is in the correct starting position."
msgstr ""
"場景剛載入時，玩家可能離追蹤空間中心很遠，導致一開始就出現在不同房間。此時遊"
"戲會嘗試讓角色本體從起始點移動到玩家實際所在處，但多半失敗。因此應設計重置功"
"能，主動調整原點，讓玩家從正確的起始位置開始。"

msgid ""
"Both of the above improvements require the player to be ready and standing "
"up straight. There is no guarantee as the player may still be putting their "
"headset on."
msgstr ""
"上述這些改進都假設玩家已經站好準備，但實際上玩家可能還在戴頭戴裝置，因此無法"
"保證隨時生效。"

msgid ""
"Many games, including XR Tools, solve this by introducing an intro screen or "
"loading screen where the player must press a button when they are ready. "
"This starting environment is often a large location where the positioning of "
"the player has little impact on what the player sees. When the player is "
"ready, and presses the button, this is the moment you record the position "
"and height of the camera."
msgstr ""
"許多遊戲（包含 XR Tools）會設計一個起始或載入畫面，讓玩家在準備好時按下按鈕。"
"通常這個起始區是一個很大的空間，玩家站在哪裡對所見畫面影響不大。當玩家按下按"
"鈕時，即記錄下相機的位置與高度。"
