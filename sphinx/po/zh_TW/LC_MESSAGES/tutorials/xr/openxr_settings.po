#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR Settings"
msgstr "OpenXR 設定"

msgid ""
"OpenXR has its own set of settings that are applied when OpenXR starts. "
"While it is possible for OpenXR extensions implemented through Godot plugins "
"to add additional settings, we will only discuss the settings in the core of "
"Godot here."
msgstr ""
"OpenXR 有其專屬的一組設定，會在 OpenXR 啟動時套用。雖然透過 Godot 外掛實作的 "
"OpenXR 擴充功能可以額外加入設定，本章僅說明 Godot 核心中的設定。"

msgid "Enabled"
msgstr "已啟用"

msgid ""
"This setting enables the OpenXR module when Godot starts. This is required "
"when the Vulkan backend is used. For other backends you can enable OpenXR at "
"any time by calling ``initialize`` on the :ref:`OpenXRInterface "
"<class_openxrinterface>`."
msgstr ""
"此設定會在 Godot 啟動時啟用 OpenXR 模組。若使用 Vulkan 後端，這是必要的。對於"
"其他後端，你可以隨時呼叫 :ref:`OpenXRInterface <class_openxrinterface>` 的 "
"``initialize`` 方法來啟用 OpenXR。"

msgid "This also needs to be enabled to get access to the action map editor."
msgstr "若要使用動作對應編輯器，也必須啟用此設定。"

msgid ""
"You can use the ``--xr-mode on`` command line switch to force this to on."
msgstr "你可以在啟動時加入 ``--xr-mode on`` 命令列參數來強制啟用此功能。"

msgid "Default Action Map"
msgstr "預設動作對應"

msgid ""
"This specifies the path of the action map file that OpenXR will load and "
"communicate to the XR Runtime."
msgstr "這裡設定 OpenXR 載入並傳遞給 XR 執行時（Runtime）的動作對應檔案路徑。"

msgid "Form Factor"
msgstr "裝置型態"

msgid "This specifies whether your game is designed for:"
msgstr "這裡指定你的遊戲是針對以下哪一種裝置設計："

msgid ""
"``Head Mounted`` devices such as a Meta Quest, Valve Index, or Magic Leap,"
msgstr "「頭戴式」裝置，例如 Meta Quest、Valve Index 或 Magic Leap，"

msgid "``Handheld`` devices such as phones."
msgstr "「手持式」裝置，例如智慧型手機。"

msgid ""
"If the device on which you run your game does not match the selection here, "
"OpenXR will fail to initialise."
msgstr "若執行遊戲的裝置與此處選擇的類型不符，OpenXR 將無法初始化。"

msgid "View Configuration"
msgstr "視圖配置"

msgid "This specifies the view configuration your game is designed for:"
msgstr "這裡設定你的遊戲設計所使用的視圖配置："

msgid ""
"``Mono``, your game provides a single image output. E.g. phone based AR;"
msgstr "「單眼」：遊戲僅提供單一畫面輸出。例如：基於手機的 AR;"

msgid ""
"``Stereo``, your game provides stereo image output. E.g. head mounted "
"devices."
msgstr "「立體」：遊戲提供立體畫面輸出。例如：頭戴式裝置。"

msgid ""
"OpenXR has additional view configurations for very specific devices that "
"Godot doesn't support yet. For instance, Varjo headsets have a quad view "
"configuration that outputs two sets of stereo images. These may be supported "
"in the near future."
msgstr ""
"OpenXR 還有其他專為特定裝置設計的視圖配置，目前 Godot 尚未支援。例如 Varjo 頭"
"戴裝置有四視圖（Quad View）配置，可輸出兩組立體畫面。未來可能會陸續支援。"

msgid "Reference Space"
msgstr "參考空間"

msgid ""
"Within XR all elements like the player's head and hands are tracked within a "
"tracking volume. At the base of this tracking volume is our origin point, "
"which maps our virtual space to the real space. There are however different "
"scenarios that place this point in different locations, depending on the XR "
"system used. In OpenXR these scenarios are well defined and selected by "
"setting a reference space."
msgstr ""
"在 XR 中，玩家的頭部、手部等所有元素都會在一個追蹤空間（tracking volume）內進"
"行追蹤。這個追蹤空間的基準點（origin）負責將虛擬空間對應到現實空間。根據不同 "
"XR 系統，這個基準點的位置會有所不同。在 OpenXR 中，這些情境有明確定義，並可透"
"過設定參考空間來選擇。"

msgid "Local"
msgstr "本地"

msgid ""
"The local reference space places our origin point at the player's head by "
"default. Some XR runtimes will do this each time your game starts, others "
"will make the position persist over sessions."
msgstr ""
"「本地」參考空間預設會將原點設在玩家的頭部。有些 XR 執行時會在每次遊戲啟動時"
"這麼做，其他則會讓此位置在多次遊玩期間持續保持。"

msgid ""
"This reference space however does not prevent the user from walking away so "
"you will need to detect if the user does so if you wish to prevent the user "
"from leaving the vehicle they are controlling, which could potentially be "
"game breaking."
msgstr ""
"此參考空間無法防止使用者離開原點，因此如果你希望玩家不要離開所控制的載具等，"
"必須自行偵測玩家是否已移動，否則可能會導致遊戲體驗破壞。"

msgid ""
"This reference space is the best option for games like flight simulators or "
"racing simulators where we want to place the :ref:`XROrigin3D "
"<class_xrorigin3d>` node where the player's head should be."
msgstr ""
"這種參考空間最適合像是飛行模擬或賽車模擬等遊戲，在這些遊戲中我們希望"
"將 :ref:`XROrigin3D <class_xrorigin3d>` 節點放在玩家頭部的位置。"

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will move "
"the :ref:`XRCamera3D <class_xrcamera3d>` to the :ref:`XROrigin3D "
"<class_xrorigin3d>` node. The :ref:`OpenXRInterface <class_openxrinterface>` "
"will also emit the ``pose_recentered`` signal so your game can react "
"accordingly."
msgstr ""
"當使用者在頭戴裝置上執行重新置中（recenter）操作時（不同 XR 執行時方式不"
"同），XR 執行時會將 :ref:`XRCamera3D <class_xrcamera3d>` 移動"
"到 :ref:`XROrigin3D <class_xrorigin3d>` 節點上。:ref:`OpenXRInterface "
"<class_openxrinterface>` 也會發出 ``pose_recentered`` 訊號，讓遊戲可以做出相"
"應反應。"

msgid ""
"Any other XR tracked elements such as controllers or anchors will also be "
"adjusted accordingly."
msgstr "其他所有受 XR 追蹤的元素，例如控制器或錨點，也會一併進行調整。"

msgid ""
"You should **not** call ``center_on_hmd`` when using this reference space."
msgstr "使用此參考空間時， **不應該** 呼叫 ``center_on_hmd`` 。"

msgid "Stage"
msgstr "舞台"

msgid ""
"The stage reference space is our default reference space and places our "
"origin point at the center of our play space. For XR runtimes that allow you "
"to draw out a guardian boundary this location and its orientation is often "
"set by the user. Other XR runtimes may decide on the placement of this point "
"by other means. It is however a stationary point in the real world."
msgstr ""
"舞台（Stage）參考空間是預設的參考空間，會將原點設置於遊玩區域的中心。對於允許"
"繪製防護邊界的 XR 執行時，這個位置及方向通常由使用者設定。其他 XR 執行時則可"
"能用不同方式決定基準點，但這個點在現實世界中通常是固定的。"

msgid ""
"This reference space is the best option for room scale games where the user "
"is expected to walk around a larger space, or for games where there is a "
"need to switch between game modes. See :ref:`Room Scale <doc_xr_room_scale>` "
"for more information."
msgstr ""
"這種參考空間最適合房間規模（Room Scale）遊戲，玩家預期會在較大的空間內移動，"
"或是需要切換不同遊戲模式的情境。詳見 :ref:`Room Scale <doc_xr_room_scale>`。"

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will not change the origin "
"point. The :ref:`OpenXRInterface <class_openxrinterface>` will emit the "
"``pose_recentered`` signal and it is up to the game to react appropriately. "
"Not doing so will prevent your game from being accepted on various stores."
msgstr ""
"當使用者在頭戴裝置上執行重新置中時（每種 XR 執行時方式不同），XR 執行時不會更"
"動原點位置。:ref:`OpenXRInterface <class_openxrinterface>` 會發出 "
"``pose_recentered`` 訊號，遊戲需自行做出正確反應。若未妥善處理，遊戲可能無法"
"在多個平台通過審核。"

msgid ""
"In Godot you can do this by calling the ``center_on_hmd`` function on "
"the :ref:`XRServer <class_xrserver>`:"
msgstr ""
"在 Godot 中，你可以呼叫 :ref:`XRServer <class_xrserver>` 的 "
"``center_on_hmd`` 方法來達成此目的："

msgid ""
"Calling ``XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)`` will "
"move the :ref:`XRCamera3D <class_xrcamera3d>` node above "
"the :ref:`XROrigin3D <class_xrorigin3d>` node keeping the player's height, "
"similar to the ``Local Floor`` reference space."
msgstr ""
"呼叫 ``XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)`` 會"
"將 :ref:`XRCamera3D <class_xrcamera3d>` 節點移動到 :ref:`XROrigin3D "
"<class_xrorigin3d>` 節點上方並保留玩家高度，類似於「本地地板」參考空間。"

msgid "Local Floor"
msgstr "本地地板"

msgid ""
"The local floor reference space is similar to the local reference space as "
"it positions the origin point where the player is. In this mode however the "
"height of the player is kept. Same as with the local reference space, some "
"XR runtimes will persist this location over sessions."
msgstr ""
"本地地板參考空間與本地參考空間類似，都是將原點設於玩家所在位置，但此模式會保"
"留玩家的高度。與本地參考空間一樣，有些 XR 執行時會讓這個位置於多次遊戲期間持"
"續存在。"

msgid ""
"It is thus not guaranteed the player will be standing on the origin point, "
"the only guarantee is that they were standing there when the user last "
"recentered. The player is thus also free to walk away."
msgstr ""
"因此無法保證玩家始終站在原點上，只能保證他們在上次重新置中時站在那裡。玩家之"
"後仍可自由離開原點。"

msgid ""
"This reference space is the best option of games where the user is expected "
"to stand in the same location or for AR type games where the user's "
"interface elements are bound to the origin node and are quickly placed at "
"the player's location on recenter."
msgstr ""
"這種參考空間最適合預期玩家會站在原地的遊戲，或是類 AR 遊戲，其 UI 元素綁定於"
"原點節點並可在重置時快速對齊玩家位置。"

msgid ""
"When the user enacts the recenter option on their headset, the method of "
"which is different per XR runtime, the XR runtime will move "
"the :ref:`XRCamera3D <class_xrcamera3d>` above the :ref:`XROrigin3D "
"<class_xrorigin3d>` node but keeping the player's height. "
"The :ref:`OpenXRInterface <class_openxrinterface>` will also emit the "
"``pose_recentered`` signal so your game can react accordingly."
msgstr ""
"當玩家在頭戴裝置上進行重新置中時（不同 XR 執行時方式不同），XR 執行時會"
"將 :ref:`XRCamera3D <class_xrcamera3d>` 移動到 :ref:`XROrigin3D "
"<class_xrorigin3d>` 上方並保留玩家高度。:ref:`OpenXRInterface "
"<class_openxrinterface>` 也會發出 ``pose_recentered`` 訊號，讓遊戲可以相應處"
"理。"

msgid ""
"Be careful using this mode in combination with virtual movement of the "
"player. The user recentering in this scenario can be unpredictable unless "
"you counter the move when handling the recenter signal. This can even be "
"game breaking as the effect in this scenario would be the player teleporting "
"to whatever abstract location the origin point was placed at during virtual "
"movement, including the ability for players teleporting into locations that "
"should be off limits. It is better to use the Stage mode in this scenario "
"and limit resetting to orientation only when a ``pose_recentered`` signal is "
"received."
msgstr ""
"若你讓玩家進行虛擬移動時使用此模式要特別小心。玩家在這種情境下執行重新置中會"
"產生不可預期的結果，除非你在處理重新置中訊號時自行修正移動，否則可能造成玩家"
"瞬間被傳送至虛擬移動時設定的原點座標，甚至進入不應進入的區域。這種情境建議改"
"用舞台（Stage）模式，並僅在收到 ``pose_recentered`` 訊號時重設方向。"

msgid "Environment Blend Mode"
msgstr "環境混合模式"

msgid ""
"The environment blend mode defines how our rendered output is blended into "
"\"the real world\" provided this is supported by the headset."
msgstr ""
"環境混合模式決定渲染結果如何與「真實世界」進行混合（前提是頭戴裝置有支援）。"

msgid "``Opaque`` means our output obscures the real world, we are in VR mode."
msgstr "「Opaque」（不透明）：渲染結果完全遮蔽現實世界，即 VR 模式。"

msgid ""
"``Additive`` means our output is added to the real world, this is an AR mode "
"where optics do not allow us to fully obscure the real world (e.g. Hololens),"
msgstr ""
"「Additive」（加法）：渲染結果以加法方式疊加於現實畫面，屬於光學無法完全遮蔽"
"現實的 AR 模式（如 Hololens），"

msgid ""
"``Alpha`` means our output is blended with the real world using the alpha "
"output (viewport should have transparent background enabled), this is an AR "
"mode where optics can fully obscure the real world (Magic Leap, all pass "
"through devices, etc.)."
msgstr ""
"「Alpha」：使用 Alpha 混合模式與現實畫面結合（檢視區需啟用透明背景），屬於光"
"學能完全遮蔽現實的 AR 模式（如 Magic Leap、各種穿透式設備等）。"

msgid ""
"If a mode is selected that is not supported by the headset, the first "
"available mode will be selected."
msgstr "若選擇的混合模式未被頭戴裝置支援，將自動選擇第一個可用的模式。"

msgid ""
"Some OpenXR devices have separate systems for enabling/disabling "
"passthrough. From Godot 4.3 onwards selecting the alpha blend mode will also "
"perform these extra steps. This does require the latest vendor plugin to be "
"installed."
msgstr ""
"部分 OpenXR 裝置有獨立的穿透啟用/關閉系統。從 Godot 4.3 起，選擇 Alpha 混合模"
"式時也會自動執行這些額外步驟。此功能需安裝最新的廠商外掛。"

msgid "Foveation Level"
msgstr "注視點最佳化等級"

msgid ""
"Sets the foveation level used when rendering provided this feature is "
"supported by the hardware used. Foveation is a technique where the further "
"away from the center of the viewport we render content, the lower resolution "
"we render at. Most XR runtimes only support fixed foveation, but some will "
"take eye tracking into account and use the focal point for this effect."
msgstr ""
"設定渲染時使用的注視點最佳化（Foveation）等級，前提是硬體有支援。注視點最佳化"
"是一種根據畫面中心距離動態降低解析度的技術。大多數 XR 執行時只支援固定注視"
"點，也有部分能配合眼動追蹤，以視覺焦點調整效果。"

msgid ""
"**Compatibility renderer only**, for Mobile and Forward+ renderer, set the "
"``vrs_mode`` property on :ref:`Viewport <class_viewport>` to ``VRS_XR``."
msgstr ""
"**僅限相容性渲染器**，若使用 Mobile 或 Forward+ 渲染器，請將 :ref:`Viewport "
"<class_viewport>` 的 ``vrs_mode`` 屬性設為 ``VRS_XR``。"

msgid ""
"This feature is disabled if post effects are used such as glow, bloom, or "
"DOF."
msgstr "若使用發光、泛光或景深等後製特效，則此功能會自動停用。"

msgid "Foveation Dynamic"
msgstr "動態注視點最佳化"

msgid ""
"When enabled the foveation level will be adjusted automatically depending on "
"current GPU load. It will be adjusted between low and the select foveation "
"level in the previous setting. It is therefore best to combine this setting "
"with foveation level set to high."
msgstr ""
"啟用後，注視點最佳化等級會根據 GPU 當前負載自動調整，變動範圍在低至你於前一設"
"定選擇的等級之間。建議將本設定與高等級注視點最佳化一同使用。"

msgid "**Compatibility renderer only**"
msgstr "**僅限相容性渲染器**"

msgid "Submit Depth Buffer"
msgstr "提交深度緩衝區"

msgid ""
"If enabled an OpenXR supplied depth buffer will be used while rendering "
"which is submitted alongside the rendered image. The XR runtime can use this "
"for improved reprojection."
msgstr ""
"啟用後，渲染時會使用由 OpenXR 提供的深度緩衝區，並於影像一同提交。XR 執行時可"
"以利用這項資訊提升重投影品質。"

msgid ""
"Enabling this feature will disable stencil support during rendering. Not "
"many XR runtimes make use of this, it is advised to leave this setting off "
"unless it provides noticeable benefits for your use case."
msgstr ""
"啟用此功能會關閉渲染時的遮罩（stencil）支援。大多數 XR 執行時不會用到此功能，"
"建議除非確實對你有幫助，否則保持關閉。"

msgid "Startup Alert"
msgstr "啟動警示"

msgid ""
"If enabled, this will result in an alert message presented to the user if "
"OpenXR fails to start. We don't always receive feedback from the XR system "
"as to why starting fails. If we do, we log this to the console. Common "
"failure reasons are:"
msgstr ""
"啟用後，若 OpenXR 啟動失敗，將會顯示警示訊息給使用者。我們不一定能從 XR 系統"
"取得失敗原因，若有資訊會記錄在主控台。常見失敗原因包括："

msgid "No OpenXR runtime is installed on the host system."
msgstr "主機系統尚未安裝 OpenXR 執行時環境。"

msgid ""
"Microsoft's WMR OpenXR runtime is currently active, this only supports "
"DirectX and will fail if OpenGL or Vulkan is used."
msgstr ""
"目前啟用的是 Microsoft 的 WMR OpenXR 執行時，僅支援 DirectX，若使用 OpenGL "
"或 Vulkan 將會失敗。"

msgid "SteamVR is used but no headset is connected/turned on."
msgstr "SteamVR 已啟動，但未連接或開啟頭戴裝置。"

msgid ""
"Disable this if you support a fallback mode in your game so it can be played "
"in desktop mode when no VR headset is connected, or if you're handling the "
"failure condition yourself by checking ``OpenXRInterface.is_initialized()``."
msgstr ""
"若你的遊戲有設計後備模式（例如未連接 VR 裝置時可用桌面模式遊玩），或你已透過 "
"``OpenXRInterface.is_initialized()`` 自行處理失敗情境，則可停用此選項。"

msgid "Extensions"
msgstr "擴充功能"

msgid "Hand Tracking"
msgstr "手部追蹤"

msgid ""
"This enables the hand tracking extension when supported by the device used. "
"This is on by default for legacy reasons. The hand tracking extension "
"provides access to data that allows you to visualise the user's hands with "
"correct finger positions. Depending on platform capabilities the hand "
"tracking data can be inferred from controller inputs, come from data gloves, "
"come from optical hand tracking sensors or any other applicable source."
msgstr ""
"啟用後會在裝置支援時開啟手部追蹤擴充功能（預設為開啟，為了相容舊專案）。此擴"
"充功能能取得資料，讓你能正確顯示用戶的手部與手指位置。依平台能力不同，手部追"
"蹤資料可從控制器、資料手套、光學手部追蹤感測器或其他來源推算取得。"

msgid "If your game only supports controllers this should be turned off."
msgstr "若你的遊戲僅支援控制器，建議關閉此功能。"

msgid "Eye Gaze Interaction"
msgstr "視線互動"

msgid ""
"This enables the eye gaze interaction extension when supported by the device "
"used. When enabled we will get feedback from eye tracking through a pose "
"situated between the user's eyes orientated in the direction the user is "
"looking. This will be a unified orientation."
msgstr ""
"啟用後，若裝置支援，會開啟視線互動擴充功能。啟用時，系統會根據眼動追蹤回傳一"
"個位於用戶雙眼之間、朝向用戶注視方向的姿態（Pose），此方向是統一的。"

msgid ""
"In order to use this functionality you need to edit your action map and add "
"a new pose action, say ``eye_pose``. Now add a new interaction profile for "
"the eye gaze interaction and map the ``eye_pose``:"
msgstr ""
"要使用此功能，請先編輯你的動作對應表，新增一個姿態（Pose）動作，例如取名為 "
"``eye_pose``。接著，為視線互動新增一個互動設定檔，並將 ``eye_pose`` 對應到該"
"設定："

msgid "Don't forget to save!"
msgstr "別忘了儲存設定！"

msgid ""
"Next add a new :ref:`XRController3D <class_xrcontroller3d>` node to your "
"origin node and set its ``tracker`` property to ``/user/eyes_ext`` and set "
"its ``pose`` property to ``eye_pose``."
msgstr ""
"然後，在你的原點（origin）節點下新增一個 :ref:`XRController3D "
"<class_xrcontroller3d>` 節點，將其 ``tracker`` 屬性設為 ``/user/eyes_ext``，"
"``pose`` 屬性設為 ``eye_pose``。"

msgid ""
"Now you can add things to this controller node such as a raycast, and "
"control things with your eyes."
msgstr ""
"現在你可以在這個控制器節點下新增射線（Raycast）等元件，實現以眼睛控制互動的功"
"能。"

msgid "Binding Modifiers"
msgstr "綁定修飾器"
