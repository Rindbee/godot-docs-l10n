#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The XR action map"
msgstr "XR 動作對應"

msgid ""
"Godot has an action map feature as part of the XR system. At this point in "
"time this system is part of the OpenXR module. There are plans to encompass "
"WebXR into this in the near future hence we call it the XR action map system "
"in this document. It implements the built-in action map system of OpenXR "
"mostly exactly as it is offered."
msgstr ""
"Godot 的 XR 系統中包含動作對應功能。目前此系統屬於 OpenXR 模組。未來預計也會"
"納入 WebXR，因此本文件統稱為 XR 動作對應系統。它幾乎完全依照 OpenXR 內建的動"
"作對應系統實作。"

msgid ""
"The XR action map system exposes input, positional data and output for XR "
"controllers to your game/application. It does this by exposing named actions "
"that can be tailored to your game/application and binding these to the "
"actual inputs and outputs on your XR devices."
msgstr ""
"XR 動作對應系統會將 XR 控制器的輸入、空間定位資料與輸出公開給您的遊戲/應用程"
"式。其原理是公開可自訂的命名動作，並將這些動作綁定到 XR 裝置上的實際輸入與輸"
"出。"

msgid ""
"As the XR action map is currently part of the OpenXR module, OpenXR needs to "
"be enabled in your project settings to expose it:"
msgstr ""
"由於 XR 動作對應目前屬於 OpenXR 模組，因此必須於專案設定中啟用 OpenXR 才能使"
"用本功能："

msgid ""
"You will then find the XR Action Map interface in the bottom of the screen:"
msgstr "接著您會在畫面下方看到 XR 動作對應介面："

msgid ""
"Godot's built-in input system has many things in common with the XR action "
"map system. In fact our original idea was to add functionality to the "
"existing input system and expose the data to the OpenXR action map system. "
"We may revisit that idea at some point but as it turns out there were just "
"too many problems to overcome. To name a few:"
msgstr ""
"Godot 的內建輸入系統與 XR 動作對應系統有許多共通之處。最初我們原本打算直接在"
"既有輸入系統上增擴功能，並將資料公開給 OpenXR 動作對應系統。雖然這想法不排除"
"未來重啟，但實際上障礙不少，例如："

msgid ""
"Godot's input system mainly centers around button inputs, XR adds triggers, "
"axis, poses and haptics (output) into the mix. This would greatly complicate "
"the input system with features that won't work for normal controllers or "
"contrast with the current approach. It was felt this would lead to confusion "
"for the majority of Godot users."
msgstr ""
"Godot 的輸入系統主要以按鍵輸入為核心，而 XR 則增加了扳機、軸向、姿勢與觸覺"
"（輸出）等概念。這會讓輸入系統變得過於複雜，且許多功能不適用於一般手把或會與"
"現有設計衝突，進而造成多數 Godot 使用者困惑。"

msgid ""
"Godot's input system works with raw input data that is parsed and triggers "
"emitting actions. This input data is made available to the end user. OpenXR "
"completely hides raw data and does all the parsing for us, we only get "
"access to already parsed action data. This inconsistency is likely to lead "
"to bugs when an unsuspecting user tries to use an XR device as a normal "
"input device."
msgstr ""
"Godot 的輸入系統是以原始資料為基礎，經解析後觸發動作，並將此類資料直接提供給"
"用戶端。而 OpenXR 則完全隱藏原始資料，所有解析都內部完成，僅提供已處理好的動"
"作資料。這樣的不一致，若開發者誤把 XR 裝置當作一般輸入裝置使用，容易發生錯"
"誤。"

msgid ""
"Godot's input system allows changes to what inputs are bound to actions in "
"runtime, OpenXR does not."
msgstr "Godot 的輸入系統允許在執行時動態更換輸入對應的動作，但 OpenXR 不支援。"

msgid ""
"Godot's input system is based on device ids which are meaningless in OpenXR."
msgstr "Godot 的輸入系統以裝置 ID 區分來源，但在 OpenXR 中並無此意義。"

msgid ""
"This does mean that a game/application that mixes traditional inputs with XR "
"controllers will have a separation. For most applications either one or the "
"other is used and this is not seen as a problem. In the end, it's a "
"limitation of the system."
msgstr ""
"這也意味著同時支援傳統輸入與 XR 控制器的遊戲/應用程式，這兩者會被系統分開處"
"理。對大多數應用來說只需選用其中一種，並不成問題。歸根究柢，這是系統的設計限"
"制。"

msgid "The default action map"
msgstr "預設動作對應"

msgid ""
"Godot will automatically create a default action map if no action map file "
"is found."
msgstr "若專案未偵測到動作對應檔，Godot 會自動建立一份預設動作對應。"

msgid ""
"This default map was designed to help developers port their XR games/"
"applications from Godot 3 to Godot 4. As a result this map essentially binds "
"all known inputs on all controllers supported by default, to actions one on "
"one. This is not a good example of setting up an action map. It does allow a "
"new developer to have a starting point when they want to become familiar "
"with Godot XR. It prevents having to design a proper action map for their "
"game/application first."
msgstr ""
"這份預設對應是為協助開發者將 XR 遊戲/應用從 Godot 3 移植到 Godot 4 而設計。它"
"基本上將所有已知的預設控制器輸入一對一綁定到動作上。這並非良好的對應設計範"
"例，但對初學者來說可直接上手 Godot XR，無須先行設計專屬動作對應。"

msgid ""
"For this walkthrough we're going to start with a blank action map. You can "
"delete the \"Godot action set\" entry at the top by pressing the trash can "
"icon. This will clear out all actions. You might also want to remove the "
"controllers that you do not wish to setup, more on this later."
msgstr ""
"本教學將從一張空白的動作對應開始。可點選頂端的垃圾桶圖示刪除「Godot 操作集」"
"條目，這會清空所有動作。你也可以移除不需要設定的控制器，後續會再說明。"

msgid "Action sets"
msgstr "動作集"

msgid ""
"Before we dive in, you will see the term XR runtime used throughout this "
"document. With XR runtime we mean the software that is controlling and "
"interacting with the AR or VR headset. The XR runtime then exposes this to "
"us through an API such as OpenXR. So:"
msgstr ""
"在開始之前，你會多次看到「XR 執行環境」這個詞。這裡指的是負責控制與管理 AR/"
"VR 頭戴裝置的軟體，並透過像 OpenXR 這類 API 對外提供服務。舉例來說："

msgid "for Steam this is SteamVR,"
msgstr "Steam 平台即為 SteamVR，"

msgid ""
"for Meta on desktop this is the Oculus Client (including when using Quest "
"link),"
msgstr "桌面端的 Meta 是 Oculus Client（包含使用 Quest Link 時），"

msgid "for Meta on Quest this is the Quest's native OpenXR client,"
msgstr "Quest 上的 Meta 則是 Quest 原生 OpenXR 客戶端，"

msgid "on Linux this could be Monado, etc."
msgstr "在 Linux 上則可能是 Monado 等。"

msgid ""
"The action map allows us to organize our actions in sets. Each set can be "
"enabled or disabled on its own."
msgstr "動作對應可以將動作分組為多個動作集，每組皆可獨立啟用或停用。"

msgid ""
"The concept here is that you could have different sets that provide bindings "
"in different scenarios. You could have:"
msgstr "可根據不同情境設計多組動作集，例如："

msgid "a ``Character control`` set for when you're walking around,"
msgstr "「角色控制」動作集，對應玩家自由移動時，"

msgid "a ``Vehicle control`` set for when you're operating a vehicle,"
msgstr "「載具控制」動作集，對應駕駛載具時，"

msgid "a ``Menu`` set for when a menu is open."
msgstr "「選單」動作集，對應開啟遊戲選單時。"

msgid ""
"Only the action set applicable to the current state of your game/application "
"can then be enabled."
msgstr "每次僅啟用適用於遊戲/應用目前狀態的動作集。"

msgid ""
"This is especially important if you wish to bind the same input on a "
"controller to a different action. For instance:"
msgstr "若需要將同一控制器的同一輸入綁定到不同動作時，這特別重要。例如："

msgid "in your ``Character control`` set you may have an action ``Jump``,"
msgstr "「角色控制」動作集中可能有「跳躍」動作，"

msgid "in your ``Vehicle control`` set you may have an action ``Accelerate``,"
msgstr "「載具控制」動作集中可能有「加速」動作，"

msgid "in your ``Menu`` set you may have an action ``Select``."
msgstr "「選單」動作集中可能有「選擇」動作。"

msgid "All are bound to the trigger on your controller."
msgstr "以上動作都綁定到你控制器的扳機鍵。"

msgid ""
"OpenXR will only bind an input or output to a single action. If the same "
"input or output is bound to multiple actions the one in the active action "
"set with the highest priority will be the one updated/used. So in our above "
"example it will thus be important that only one action set is active."
msgstr ""
"OpenXR 一次僅允許將某個輸入或輸出綁定到單一動作。如果多個動作集同時啟用且都有"
"綁定同一輸入/輸出，會以優先權最高的動作集為主。故如上述範例，務必確保僅啟用一"
"組動作集。"

msgid ""
"For your first XR game/application we highly recommend starting with just a "
"single action set and to not over-engineer things."
msgstr "建議您的第一個 XR 專案僅設計一組動作集，避免過度設計。"

msgid ""
"For our walkthrough in this document we will thus create a single action set "
"called ``my_first_action_set``. We do this by pressing the ``Add action "
"set`` button:"
msgstr ""
"本教學將建立一組名為 ``my_first_action_set`` 的動作集，請點選「新增動作集」按"
"鈕："

msgid "The columns in our table are as follows:"
msgstr "表格中的欄位意義如下："

msgid "Col"
msgstr "欄位"

msgid "Value"
msgstr "值"

msgid "Description"
msgstr "說明"

msgid "1"
msgstr "1"

msgid "my_first_action_set"
msgstr "my_first_action_set"

msgid ""
"This is the internal name of the action set. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"這是動作集的內部名稱。OpenXR 僅限制名稱長度，部分 XR 執行環境不接受空白或特殊"
"字元。"

msgid "2"
msgstr "2"

msgid "My first action set"
msgstr "我的第一組動作集"

msgid ""
"This is a human-readable name for the action set. Some XR runtimes will "
"display this name to the end user, for example in configuration dialogs."
msgstr ""
"這是人類可讀的動作集名稱。部分 XR 執行環境會在設定介面等地方顯示此名稱給使用"
"者。"

msgid "3"
msgstr "3"

msgid "0"
msgstr "0"

msgid "Actions"
msgstr "動作"

msgid ""
"In the XR action map, actions are the entities that your game/application "
"will interact with. For instance, we can define an action ``Shoot`` and the "
"input bound to that action will trigger the ``button_pressed`` signal on the "
"relevant :ref:`XRController3D <class_xrcontroller3d>` node in your scene "
"with ``Shoot`` as the ``name`` parameter of the signal."
msgstr ""
"在 XR 動作對應中，「動作」代表遊戲/應用程式可互動的行為。例如你可定義一個動"
"作 ``Shoot``，當對應輸入啟動時，將觸發場景中 :ref:`XRController3D "
"<class_xrcontroller3d>` 節點的 ``button_pressed`` 訊號，參數 ``name`` 會是 "
"``Shoot``。"

msgid ""
"You can also poll the current state of an action. :ref:`XRController3D "
"<class_xrcontroller3d>` for instance has an ``is_button_pressed`` method."
msgstr ""
"你也可以主動查詢動作目前狀態，例如 :ref:`XRController3D "
"<class_xrcontroller3d>` 節點中有 ``is_button_pressed`` 方法。"

msgid ""
"Actions can be used for both input and output and each action has a type "
"that defines its behavior."
msgstr "動作可對應輸入或輸出，每個動作有其型別，決定其行為。"

msgid "The ``Bool`` type is used for discrete input like buttons."
msgstr "``Bool`` 型別用於離散輸入（如按鍵）。"

msgid "The ``Float`` type is used for analogue input like triggers."
msgstr "``Float`` 型別用於類比輸入（如扳機）。"

msgid ""
"These two are special as they are the only ones that are interchangeable. "
"OpenXR will handle conversions between ``Bool`` and ``Float`` inputs and "
"actions. You can get the value of a ``Float`` type action by calling the "
"method ``get_float`` on your :ref:`XRController3D <class_xrcontroller3d>` "
"node. It emits the ``input_float_changed`` signal when changed."
msgstr ""
"這兩種型別可互換，OpenXR 會自動在 ``Bool`` 與 ``Float`` 之間做轉換。你可透"
"過 :ref:`XRController3D <class_xrcontroller3d>` 節點的 ``get_float`` 取得 "
"``Float`` 型別動作的數值，且當數值變動時會觸發 ``input_float_changed`` 訊號。"

msgid ""
"Where analogue inputs are queried as buttons a threshold is applied. This "
"threshold is currently managed exclusively by the XR runtime. There are "
"plans to extend Godot to provide some level of control over these thresholds "
"in the future."
msgstr ""
"當以按鍵方式查詢類比輸入時，會套用閾值。該閾值目前完全由 XR 執行環境管理，未"
"來 Godot 預計將開放部分調整權限。"

msgid ""
"The ``Vector2`` type defines the input as an axis input. Touchpads, "
"thumbsticks and similar inputs are exposed as vectors. You can get the value "
"of a ``Vector2`` type action by calling the method ``get_vector2`` on "
"your :ref:`XRController3D <class_xrcontroller3d>` node. It emits the "
"``input_vector2_changed`` signal when changed."
msgstr ""
"``Vector2`` 型別用於軸向輸入。例如觸控板、搖桿等會以向量輸出。你可經"
"由 :ref:`XRController3D <class_xrcontroller3d>` 節點的 ``get_vector2`` 取得"
"值，數值變動時會發送 ``input_vector2_changed`` 訊號。"

msgid ""
"The ``Pose`` type defines a spatially tracked input. Multiple \"pose\" "
"inputs are available in OpenXR: ``aim``, ``grip`` and ``palm``. "
"Your :ref:`XRController3D <class_xrcontroller3d>` node is automatically "
"positioned based on the pose action assigned to ``pose`` property of this "
"node. More about poses later."
msgstr ""
"``Pose`` 型別表示空間追蹤輸入。OpenXR 支援多種「姿勢」輸入：如 ``aim``、"
"``grip``、``palm``。你的 :ref:`XRController3D <class_xrcontroller3d>` 節點會"
"依照 ``pose`` 屬性綁定的動作自動定位。"

msgid ""
"The OpenXR implementation in Godot also exposes a special pose called "
"``Skeleton``. This is part of the hand tracking implementation. This pose is "
"exposed through the ``skeleton`` action that is supported outside of the "
"action map system. It is thus always present if hand tracking is supported. "
"You don't need to bind actions to this pose to use it."
msgstr ""
"Godot 的 OpenXR 實作也提供名為 ``Skeleton`` 的特殊姿勢，用於手部追蹤。這個姿"
"勢會由動作對應系統之外的 ``skeleton`` 動作自動提供，只要支援手部追蹤就會存"
"在，無需另外綁定動作即可使用。"

msgid ""
"Finally, the only output type is ``Haptic`` and it allows us to set the "
"intensity of haptic feedback, such as controller vibration. Controllers can "
"have multiple haptic outputs and support for haptic vests is coming to "
"OpenXR."
msgstr ""
"最後，唯一的輸出型別是 ``Haptic``，可設定觸覺回饋強度（如控制器震動）。控制器"
"可有多組觸覺輸出，OpenXR 也即將支援觸覺背心等裝置。"

msgid ""
"So lets add an action for our aim pose, we do this by clicking on the ``+`` "
"button for our action set:"
msgstr "現在我們來為瞄準姿勢新增動作。請在動作集下方點選「+」按鈕："

msgid "aim_pose"
msgstr "aim_pose"

msgid ""
"This is the internal name of the action. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"這是動作的內部名稱，OpenXR 僅限制長度，部分 XR 執行環境不接受空白或特殊符號。"

msgid "Aim pose"
msgstr "瞄準姿勢"

msgid ""
"This is a human-readable name for the action. Some XR runtimes will display "
"this name to the end user, for example in configuration dialogs."
msgstr "這是動作的顯示名稱，部分 XR 執行環境會於設定等介面顯示給使用者。"

msgid "Pose"
msgstr "姿勢"

msgid "The type of this action."
msgstr "此動作的型別。"

msgid ""
"OpenXR defines a number of bindable input poses that are commonly available "
"for controllers. There are no rules for which poses are supported for "
"different controllers. The poses OpenXR currently defines are:"
msgstr ""
"OpenXR 規範多種可綁定的輸入姿勢，實際支援的姿勢因控制器而異，目前 OpenXR 定義"
"的有："

msgid ""
"The aim pose on most controllers is positioned slightly in front of the "
"controller and aims forward. This is a great pose to use for laser pointers "
"or to align the muzzle of a weapon with."
msgstr ""
"大多數控制器的 aim 姿勢會對應到控制器前方微距位置，並朝向正前方。這很適合用於"
"雷射指標或武器槍口等對準應用。"

msgid ""
"The grip pose on most controllers is positioned where the grip button is "
"placed on the controller. The orientation of this pose differs between "
"controllers and can differ for the same controller on different XR runtimes."
msgstr ""
"大多數控制器的 grip 姿勢對應控制器握把按鈕處。不同控制器、甚至同型號於不同 "
"XR 執行環境下方向可能會不同。"

msgid ""
"The palm pose on most controllers is positioned in the center of the palm of "
"the hand holding the controller. This is a new pose that is not available on "
"all XR runtimes."
msgstr ""
"大多數控制器的 palm 姿勢對應手掌心握住控制器的位置。此為較新姿勢，並非所有 "
"XR 執行環境皆支援。"

msgid ""
"If hand tracking is used, there are currently big differences in "
"implementations between the different XR runtimes. As a result the action "
"map is currently not suitable for hand tracking. Work is being done on this "
"so stay tuned."
msgstr ""
"如需手部追蹤，目前各家 XR 執行環境實作差異極大，因此動作對應暫不適合用於手部"
"追蹤。相關改進正在推進中，請持續關注。"

msgid ""
"Let's complete our list of actions for a very simple shooting game/"
"application:"
msgstr "以下列舉一個簡單射擊遊戲/應用程式的動作清單："

msgid "The actions we have added are:"
msgstr "我們新增的動作有："

msgid ""
"movement, which allows the user to move around outside of normal room scale "
"tracking."
msgstr "movement：讓玩家能在房間規模追蹤以外移動。"

msgid "grab, which detects that the user wants to hold something."
msgstr "grab：偵測玩家想抓取物件。"

msgid ""
"shoot, which detects that the user wants to fire the weapon they are holding."
msgstr "shoot：偵測玩家想開槍。"

msgid "haptic, which allows us to output haptic feedback."
msgstr "haptic：輸出觸覺回饋。"

msgid ""
"Now note that we don't distinguish between the left and right hand. This is "
"something that is determined at the next stage. We've implemented the action "
"system in such a way that you can bind the same action to both hands. The "
"appropriate :ref:`XRController3D <class_xrcontroller3d>` node will emit the "
"signal."
msgstr ""
"請注意，這裡我們尚未區分左右手。實際上，動作系統允許同一動作同時綁定於雙手，"
"之後再決定左右手分工。對應的 :ref:`XRController3D <class_xrcontroller3d>` 節"
"點會自動發出訊號。"

msgid ""
"For both grab and shoot we've used the ``Bool`` type. As mentioned before, "
"OpenXR does automatic conversions from an analogue controls however not all "
"XR Runtimes currently apply sensible thresholds."
msgstr ""
"grab 與 shoot 動作都用 ``Bool`` 型別。雖然 OpenXR 會自動將類比控制轉為 Bool，"
"但不是所有 XR 執行環境都會應用合理的閾值。"

msgid ""
"We recommend as a workaround to use the ``Float`` type when interacting with "
"triggers and grip buttons and apply your own threshold."
msgstr "建議如需處理扳機與握把按鈕，請以 ``Float`` 型別並自行設定閾值。"

msgid ""
"For buttons like A/B/X/Y and similar where there is no analogue option, the "
"``Bool`` type works fine."
msgstr "對於 A/B/X/Y 等純數位按鍵，直接用 ``Bool`` 型別即可。"

msgid ""
"You can bind the same action to multiple inputs for the same controller on "
"the same profile. In this case the XR runtime will attempt to combine the "
"inputs."
msgstr ""
"同一控制器於同一設定檔，可將多組輸入綁定到同一動作，XR 執行環境會自動合併輸"
"入。"

msgid ""
"For ``Bool`` inputs, this will perform an ``OR`` operation between the "
"buttons."
msgstr "對於 ``Bool`` 輸入，會以「或（OR）」運算合併。"

msgid ""
"For ``Float`` inputs, this will take the highest value of the bound inputs."
msgstr "對於 ``Float`` 輸入，取所有綁定輸入中的最大值。"

msgid ""
"The behavior for ``Pose`` inputs is undefined, but the first bound input is "
"likely to be used."
msgstr "``Pose`` 輸入則未定義，通常僅採用第一個綁定輸入。"

msgid ""
"You shouldn't bind multiple actions of the same action set to the same "
"controller input. If you do this, or if actions are bound from multiple "
"action sets but they have overlapping priorities, the behavior is undefined. "
"The XR runtime may simply not accept your action map, or it may take this on "
"a first come first serve basis."
msgstr ""
"請勿將同一動作集的多個動作綁定到同一控制器輸入。若跨動作集且優先權重疊，行為"
"未定義，部分 XR 執行環境甚至可能拒絕載入你的動作對應，或只採用最先匹配的設"
"定。"

msgid ""
"We are still investigating the restrictions around binding multiple actions "
"to the same output as this scenario makes sense. The OpenXR specification "
"seems to not allow this."
msgstr ""
"我們仍在研究多個動作綁定到同一輸出的限制，雖然場景合理，但 OpenXR 規範目前似"
"乎不允許。"

msgid "Now that we have our basic actions defined, it's time to hook them up."
msgstr "基礎動作定義完成後，接下來要設定對應關聯。"

msgid "Profiles"
msgstr "設定檔"

msgid ""
"In OpenXR controller bindings are captured in so-called \"Interaction "
"Profiles\". We've shortened it to \"Profiles\" because it takes up less "
"space."
msgstr ""
"在 OpenXR 中，控制器綁定由「互動設定檔（Interaction Profile）」管理。為簡潔起"
"見以下皆簡稱「設定檔」。"

msgid ""
"This generic name is chosen because controllers don't cover the entire "
"system. Currently there are also profiles for trackers, remotes and tracked "
"pens. There are also provisions for devices such as treadmills, haptic vests "
"and such even though those are not part of the specification yet."
msgstr ""
"之所以用這種通用名稱，是因為設定檔不僅限於控制器，還包含追蹤器、遙控器、追蹤"
"筆，甚至未來可能支援跑步機、觸覺背心等。"

msgid ""
"It is important to know that OpenXR has strict checking on supported "
"devices. The core specification identifies a number of controllers and "
"similar devices with their supported inputs and outputs. Every XR runtime "
"must accept these interaction profiles even if they aren't applicable."
msgstr ""
"需注意，OpenXR 對已支援的硬體裝置有嚴格檢查。標準規範列明數種控制器與其所支援"
"的輸入/輸出，每種 XR 執行環境都必須接受這些設定檔（即使不一定有該硬體）。"

msgid ""
"New devices are added through extensions and XR runtimes must specify which "
"ones they support. XR runtimes that do not support a device added through "
"extensions will not accept these profiles. XR runtimes that do not support "
"added input or output types will often crash if supplied."
msgstr ""
"新裝置會經由擴充功能新增，XR 執行環境需明確告知支援清單。不支援的裝置設定檔會"
"被拒絕，若載入不支援的輸入/輸出型別甚至可能導致系統崩潰。"

msgid ""
"As such Godot keeps meta data of all available devices, their inputs and "
"outputs and which extension adds support for them. You can create "
"interaction profiles for all devices you wish to support. Godot will filter "
"out those not supported by the XR runtime the user is using."
msgstr ""
"因此 Godot 會保存所有可用裝置的 meta 資料、輸入/輸出列表，以及支援來源擴充。"
"你可為欲支援裝置建立設定檔，Godot 會自動排除使用者執行環境不支援的部分。"

msgid ""
"This does mean that in order to support new devices, you might need to "
"update to a more recent version of Godot."
msgstr "換言之，若要支援新裝置，可能需更新至較新版本的 Godot。"

msgid ""
"It is however also important to note that the action map has been designed "
"with this in mind. When new devices enter the market, or when your users use "
"devices that you do not have access to, the action map system relies on the "
"XR runtime. It is the XR runtime's job to choose the best fitting "
"interaction profile that has been specified and adapt it for the controller "
"the user is using."
msgstr ""
"設計上動作對應系統已考慮此狀況。新裝置推出，或用戶使用你無法測試的裝置時，最"
"終決定權在 XR 執行環境。它會自動選擇最合適的設定檔並做對應調整。"

msgid ""
"How the XR runtime does this is left to the implementation of the runtime "
"and there are thus vast differences between the runtimes. Some runtimes "
"might even permit users to edit the bindings themselves."
msgstr ""
"XR 執行環境如何翻配設定檔屬於實作細節，各家差異很大。有些甚至允許用戶端自行編"
"輯動作綁定。"

msgid ""
"A common approach for a runtime is to look for a matching interaction "
"profile first. If this is not found it will check the most common profiles "
"such as that of the \"Touch controller\" and do a conversion. If all else "
"fails, it will check the generic :ref:`\"Simple controller\" "
"<doc_xr_action_map_simple>`."
msgstr ""
"常見做法是先尋找完全匹配的設定檔，找不到則退而求其次使用如「Touch 控制器」等"
"常見檔案，最終再 fallback 到 :ref:`「簡單控制器」"
"<doc_xr_action_map_simple>`。"

msgid ""
"There is an important conclusion to be made here: When a controller is "
"found, and the action map is applied to it, the XR runtime is not limited to "
"the exact configurations you set up in Godot's action map editor. While the "
"runtime will generally choose a suitable mapping based on one of the "
"bindings you set up in the action map, it can deviate from it."
msgstr ""
"重點在於：當 XR 執行環境偵測到控制器並套用動作對應時，不會嚴格按照 Godot 動作"
"對應編輯器設定，通常會以你的設定為參考，必要時主動做出調整。"

msgid ""
"For example, when the Touch controller profile is used any of the following "
"scenarios could be true:"
msgstr "舉例來說，當使用 Touch 控制器設定檔時，可能出現下列任何一種狀況："

msgid "we could be using a Quest 1 controller,"
msgstr "可能是 Quest 1 控制器，"

msgid "we could be using a Quest 2 controller,"
msgstr "也可能是 Quest 2 控制器，"

msgid ""
"we could be using a Quest Pro controller but no Quest Pro profile was given "
"or the XR runtime being used does not support the Quest Pro controller,"
msgstr ""
"或可能是 Quest Pro 控制器，但沒提供 Quest Pro 設定檔，或當前 XR 執行環境尚未"
"支援 Quest Pro，"

msgid ""
"it could be a completely different controller for which no profile was given "
"but the XR runtime is using the touch bindings as a base."
msgstr "甚至可能是完全不同的控制器，但 XR 執行環境以 touch 綁定作為參考。"

msgid ""
"Ergo, there currently is no way to know with certainty, which controller the "
"user is actually using."
msgstr "因此，目前無法確定最終用戶到底使用哪一款控制器。"

msgid ""
"Finally, and this trips up a lot of people, the bindings aren't set in "
"stone. It is fully allowed, and even expected, that an XR runtime allows a "
"user to customise the bindings."
msgstr ""
"另外一點易被忽略的是，這些綁定並非固定不變。許多 XR 執行環境允許甚至預期用戶"
"自訂綁定。"

msgid ""
"At the moment none of the XR runtimes offer this functionality though "
"SteamVR has an existing UI from OpenVRs action map system that is still "
"accessible. This is actively being worked on however."
msgstr ""
"目前尚無 XR 執行環境正式開放這類自訂功能，不過 SteamVR 仍可透過 OpenVR 動作對"
"應系統的舊版 UI 進行部分編輯。相關功能正在開發中。"

msgid "Our first controller binding"
msgstr "第一個控制器綁定"

msgid ""
"Let's set up our first controller binding, using the Touch controller as an "
"example."
msgstr "以下以 Touch 控制器為例，示範如何設定第一個控制器綁定。"

msgid ""
"Press \"Add profile\", find the Touch controller, and add it. If it is not "
"in the list, then it may already have been added."
msgstr ""
"點選「新增設定檔」，搜尋 Touch 控制器並加入。若列表中未顯示，可能已經加入。"

msgid ""
"Our UI now shows panels for both the left and right controllers. The panels "
"contain all of the possible inputs and outputs for each controller. We can "
"use the ``+`` next to each entry to bind it to an action:"
msgstr ""
"此時 UI 上會顯示左右兩側控制器面板，列出所有可用的輸入與輸出。你可點選每個條"
"目旁的「+」將其綁定至動作："

msgid "Let's finish our configuration:"
msgstr "完成綁定設定："

msgid ""
"Each action is bound the given input or output for both controllers to "
"indicate that we support the action on either controller. The exception is "
"the movement action which is bound only to the right hand controller. It is "
"likely that we would want to use the left hand thumbstick for a different "
"purpose, say a teleport function."
msgstr ""
"每個動作都分別對應左右控制器的相關輸入/輸出，表示兩手皆支援該動作。僅移動動作"
"綁定於右手控制器，因左手搖桿通常另有用途（如傳送）。"

msgid ""
"In developing your game/application you have to account for the possibility "
"that the user changes the binding and binds the movement to the left hand "
"thumbstick."
msgstr "開發時需考慮使用者可能自行更改綁定，將移動功能設到左手搖桿等情境。"

msgid ""
"Also note that our shoot and grab boolean actions are linked to inputs of "
"type ``Float``. As mentioned before OpenXR will do conversions between the "
"two, but do read the warning given on that subject earlier in this document."
msgstr ""
"另外，shoot 與 grab 動作雖為布林型，實際綁定的卻是 ``Float`` 型輸入。雖然 "
"OpenXR 可自動轉換，但請詳閱前文有關閾值的注意事項。"

msgid "Some of the inputs seem to appear in our list multiple times."
msgstr "你可能會發現有些輸入在列表中重複出現。"

msgid ""
"For instance we can find the ``X`` button twice, once as ``X click`` and "
"then as ``X touch``. This is due to the Touch controller having a capacitive "
"sensor."
msgstr ""
"例如 ``X`` 按鈕會分別出現 ``X click`` 與 ``X touch``，這是因 Touch 控制器內建"
"電容式感應。"

msgid "``X touch`` will be true if the user is merely touching the X button."
msgstr "僅觸碰 X 按鈕時，``X touch`` 為 true。"

msgid ""
"``X click`` will be true when the user is actually pressing down on the "
"button."
msgstr "實際壓下按鈕時，``X click`` 才會變為 true。"

msgid "Similarly for the thumbstick we have:"
msgstr "搖桿（Thumbstick）也有類似情況："

msgid ""
"``Thumbstick touch`` which will be true if the user is touching the "
"thumbstick."
msgstr "僅觸摸搖桿時，``Thumbstick touch`` 為 true。"

msgid ""
"``Thumbstick`` which gives a value for the direction the thumbstick is "
"pushed to."
msgstr "``Thumbstick`` 會輸出搖桿目前推動方向的向量值。"

msgid ""
"``Thumbstick click`` which is true when the user is pressing down on the "
"thumbstick."
msgstr "搖桿被往下壓時，``Thumbstick click`` 為 true。"

msgid ""
"It is important to note that only a select number of XR controllers support "
"touch sensors or have click features on thumbsticks. Keep that in mind when "
"designing your game/application. Make sure these are used for optional "
"features of your game/application."
msgstr ""
"需注意，僅部分 XR 控制器支援觸控感應或搖桿點擊。設計遊戲/應用時，建議將這些功"
"能設定為選用項目。"

msgid "The simple controller"
msgstr "簡單控制器"

msgid ""
"The \"Simple controller\" is a generic controller that OpenXR offers as a "
"fallback. We'll apply our mapping:"
msgstr "「簡單控制器」是 OpenXR 提供的通用後備控制器。我們來對應設定："

msgid ""
"As becomes painfully clear, the simple controller is often far too simple "
"and falls short for anything but the simplest of VR games/applications."
msgstr "不難發現，簡單控制器功能極其有限，僅能應付最基本的 VR 遊戲/應用。"

msgid ""
"This is why many XR runtimes only use it as a last resort and will attempt "
"to use bindings from one of the more popular systems as a fallback first."
msgstr ""
"所以多數 XR 執行環境僅在萬不得已時才採用簡單控制器，通常會優先嘗試用較常見的"
"設定檔做對應。"

msgid ""
"Due to the simple controller likely not covering the needs of your game, it "
"is tempting to provide bindings for every controller supported by OpenXR. "
"The default action map seems to suggest this as a valid course of action. As "
"mentioned before, the default action map was designed for ease of migration "
"from Godot 3."
msgstr ""
"由於簡單控制器無法滿足大多數遊戲需求，許多開發者會想為 OpenXR 支援的所有控制"
"器都設綁定。預設動作對應看似如此，但正如前述，這主要是為了從 Godot 3 遷移方"
"便。"

msgid ""
"It is the recommendation from the OpenXR Working Group that only bindings "
"for controllers actually tested by the developer are setup. The XR runtimes "
"are designed with this in mind. They can perform a better job of rebinding a "
"provided binding than a developer can make educated guesses. Especially as "
"the developer can't test if this leads to a comfortable experience for the "
"end user."
msgstr ""
"OpenXR 工作小組建議：只設定你實際測過的控制器綁定。XR 執行環境設計時已考慮自"
"動重配，效果比開發者盲目設想更佳，且開發者無法保證所有硬體的適用性與體驗。"

msgid ""
"This is our advice as well: limit your action map to the interaction "
"profiles for devices you have actually tested your game with. The Oculus "
"Touch controller is widely used as a fallback controller by many runtimes. "
"If you are able to test your game using a Meta Rift or Quest and add this "
"profile there is a high probability your game will work with other headsets."
msgstr ""
"我們也建議：僅針對實際測試過的裝置建立動作對應。Oculus Touch 控制器現已成多數"
"平台常見後備選項，只要你能在 Meta Rift 或 Quest 上測試並加入設定檔，你的遊戲"
"很可能可相容其他頭盔。"

msgid "Binding Modifiers"
msgstr "綁定修飾器"

msgid ""
"One of the main goals of the action map is to remove the need for the "
"application to know the hardware used. However, sometimes the hardware has "
"physical differences that require inputs to be altered in ways other than "
"how they are bound to actions. This need ranges from setting thresholds, to "
"altering the inputs available on a controller."
msgstr ""
"動作對應的主要目標之一是讓應用程式無需關心具體硬體型號。但部分硬體因物理設計"
"差異，需對輸入做額外調整，而非僅僅改變綁定關聯，舉凡設定閾值或調整控制器可用"
"輸入等。"

msgid ""
"Binding modifiers are not enabled by default and require enabling in the "
"OpenXR project settings. Also there is no guarantee that these modifiers are "
"supported by every runtime. You will need to consult the support for the "
"runtimes you are targeting and decide whether to rely on the modifiers or "
"implement some form of fallback mechanism."
msgstr ""
"綁定修飾器預設為關閉，必須在 OpenXR 專案設定中手動啟用。此外，並非所有執行環"
"境都支援這些修飾器，你需查閱目標執行環境的支援情況，決定是否依賴這些修飾器，"
"或自行實作備援機制。"

msgid ""
"If you are targeting multiple runtimes that have support for the same "
"controllers, you may need to create separate action maps for each runtime. "
"You can control which action map Godot uses by using different export "
"templates for each runtime and using a custom :ref:`feature tag "
"<doc_feature_tags>` to set the action map."
msgstr ""
"若你的專案需同時支援多個執行環境且共用同一控制器，可能需針對不同執行環境各自"
"建立專屬動作對應。你可以透過針對不同執行環境匯出的模板，以及自訂 :ref:`功能標"
"籤 <doc_feature_tags>` 來指定要載入的動作對應檔案。"

msgid ""
"In Godot, binding modifiers are divided into two groups: modifiers that work "
"on the interaction profile level, and modifiers that work on individual "
"bindings."
msgstr ""
"Godot 的綁定修飾器分為兩種：一種作用於互動設定檔層級，另一種則僅針對單一綁定"
"調整。"

msgid "Binding modifiers on an interaction profile"
msgstr "互動設定檔層級的綁定修飾器"

msgid ""
"Binding modifiers that are applied to the whole interaction profile can be "
"accessed through the modifier button on the right side of the interaction "
"profile editor."
msgstr ""
"若要在整個互動設定檔套用修飾器，可於互動設定檔編輯器右側找到修飾器按鈕進行管"
"理。"

msgid ""
"You can add a new modifier by pressing the ``Add binding modifier`` button."
msgstr "點選「新增綁定修飾器」按鈕，即可加入新的修飾器。"

msgid ""
"As Godot doesn't know which controllers and runtimes support a modifier, "
"there is no restriction to adding modifiers. Unsupported modifiers will be "
"ignored."
msgstr ""
"由於 Godot 無法預先得知哪些控制器或執行環境支援哪些修飾器，因此不會限制你新增"
"修飾器。若該修飾器不被支援，則會自動忽略。"

msgid "Dpad Binding modifier"
msgstr "方向鍵綁定修飾器"

msgid ""
"The dpad binding modifier adds new inputs to an interaction profile for each "
"joystick and thumbpad input on this controller. It turns the input into a "
"dpad with separate up, down, left and right inputs that are exposed as "
"buttons:"
msgstr ""
"方向鍵綁定修飾器會針對控制器的每個搖桿或觸控板輸入，於互動設定檔中新增對應的"
"輸入，將其轉換為四個獨立的上、下、左、右按鍵輸入。"

msgid "Inputs related to extensions are denoted with an asterix."
msgstr "與擴充功能相關的輸入會以星號標記。"

msgid ""
"In order to use the dpad binding modifier you need to enable the dpad "
"binding modifier extension in project settings:"
msgstr ""
"要使用方向鍵綁定修飾器，需先於專案設定中啟用「方向鍵綁定修飾器」擴充功能："

msgid ""
"Enabling the extension is enough to make this functionality work using "
"default settings."
msgstr "僅需啟用此擴充功能，即可使用預設設定。"

msgid ""
"Adding the modifier is optional and allows you to fine tune the way the dpad "
"functionality behaves. You can add the modifier multiple times to set "
"different settings for different inputs."
msgstr ""
"新增修飾器為選用，可進一步微調方向鍵功能的行為。你可針對不同輸入多次新增修飾"
"器，各自調整參數。"

msgid "These settings are used as follows:"
msgstr "各設定意義如下："

msgid ""
"``Action Set`` defines the action set to which these settings are applied."
msgstr "``Action Set``：設定作用的動作集。"

msgid ""
"``Input Path`` defines the original input that is mapped to the new dpad "
"inputs."
msgstr "``Input Path``：原始輸入路徑，綁定到新方向鍵輸入。"

msgid ""
"``Threshold`` specifies the threshold value that will enable a dpad action, "
"e.g. a value of ``0.6`` means that if the distance from center goes above "
"``0.6`` the dpad action is pressed."
msgstr ""
"``Threshold``：觸發方向鍵動作所需的閾值。例如設為 ``0.6``，當搖桿離中心距離超"
"過 0.6 時即觸發該方向。"

msgid ""
"``Threshold Released`` specifies the threshold value that will disable a "
"dpad action, e.g. a value of ``0.4`` means that if the distance from center "
"goes below ``0.4`` the dpad action is released."
msgstr ""
"``Threshold Released``：解除方向鍵動作的閾值。例如設為 ``0.4``，當搖桿回到中"
"心小於 0.4 時即解除該方向狀態。"

msgid ""
"``Center Region`` specifies the distance from center that enabled the center "
"action, this is only supported for trackpads."
msgstr ""
"``Center Region``：定義觸控板中心區域的半徑，超過此值才視為偏離中心，僅支援觸"
"控板。"

msgid ""
"``Wedge Angle`` specifies the angle of each wedge. A value of ``90 degrees`` "
"or lower means that up, down, left and right each have a separate slice in "
"which they are in the pressed state. A value above ``90 degrees`` means that "
"the slices overlap and that multiple actions can be in the pressed state."
msgstr ""
"``Wedge Angle``：每個方向鍵的扇形角度。90 度或以下代表上下左右各自獨立，超過 "
"90 度則會重疊，可能多個方向同時觸發。"

msgid ""
"``Is Sticky``, when enabled means that an action stays in the pressed state "
"until the thumbstick or trackpad moves into another wedge even if it has "
"left the wedge for that action."
msgstr ""
"``Is Sticky``：啟用後，動作會持續保持按下狀態，直到搖桿或觸控板進入其他方向區"
"塊才解除。"

msgid ""
"``On Haptic`` lets us define a haptic output that is automatically activated "
"when an action becomes pressed."
msgstr "``On Haptic``：當動作觸發時自動啟動的觸覺回饋。"

msgid "Binding modifiers on individual bindings"
msgstr "單一綁定層級的綁定修飾器"

msgid ""
"Binding modifiers that are applied to individual bindings can be accessed "
"through the binding modifier button next to action attached to an input:"
msgstr ""
"若要針對單一綁定（某個動作對應某個輸入）套用修飾器，可點選輸入旁的修飾器按鈕"
"設定："

msgid ""
"As Godot doesn't know which inputs on each runtime support a modifier, there "
"is no restriction to adding modifiers. If the modifier extension is "
"unsupported, modifiers will be filtered out at runtime. Modifiers added to "
"the wrong input may result in a runtime error."
msgstr ""
"Godot 無法預知每個執行環境與輸入支援哪些修飾器，因此你可自由新增。若執行環境"
"不支援該修飾器，會在執行時自動過濾。若誤加到不支援的輸入，也可能導致執行時錯"
"誤。"

msgid ""
"You should test your action map on the actual hardware and runtime to verify "
"the proper setup."
msgstr "請務必在實際硬體及執行環境上測試你的動作對應，以確保設定正確。"

msgid "Analog threshold modifier"
msgstr "類比閾值修飾器"

msgid ""
"The analog threshold modifier allows you to specify the thresholds used for "
"any analog input, like the trigger, that has a boolean input. This controls "
"when the input is in the pressed state."
msgstr ""
"類比閾值修飾器可自訂任意類比輸入（如扳機鍵）觸發布林輸入時的閾值，決定何時算"
"作按下。"

msgid ""
"In order to use this modifier you must enable the analog threshold extension "
"in the project settings:"
msgstr "使用此修飾器前，須先於專案設定啟用「類比閾值」擴充功能："

msgid "The analog threshold modifier has the following settings:"
msgstr "類比閾值修飾器包含以下設定："

msgid "These are defined as follows:"
msgstr "各設定說明如下："

msgid ""
"``On Threshold`` specifies the threshold value that will enable the action, "
"e.g. a value of ``0.6`` means that when the analog value gets above ``0.6`` "
"the action is set to the pressed state."
msgstr ""
"``On Threshold``：啟動動作的閾值。例如設為 ``0.6``，當類比數值超過 0.6 時即視"
"為按下。"

msgid ""
"``Off Threshold`` specifies the threshold value that will disable the "
"action, e.g. a value of ``0.4`` means that when the analog value goes below "
"``0.4`` the action is set in to the released state."
msgstr ""
"``Off Threshold``：釋放動作的閾值。例如設為 ``0.4``，當類比數值低於 0.4 時即"
"視為釋放。"

msgid ""
"``On Haptic`` lets us define a haptic output that is automatically activated "
"when the input is pressed."
msgstr "``On Haptic``：當輸入觸發時自動啟動的觸覺回饋。"

msgid ""
"``Off Haptic`` lets us define a haptic output that is automatically "
"activated when the input is released."
msgstr "``Off Haptic``：當輸入釋放時自動啟動的觸覺回饋。"

msgid "Haptics on modifiers"
msgstr "修飾器的觸覺回饋設定"

msgid ""
"Modifiers can support automatic haptic output that is triggered when "
"thresholds are reached."
msgstr "部分修飾器可設定當閾值觸發時自動啟動的觸覺回饋。"

msgid ""
"Currently both available modifiers support this feature however there is no "
"rule future modifiers also have this capability. Only one type of haptic "
"feedback is supported but in the future other options may become available."
msgstr ""
"目前所有內建修飾器皆支援此功能，但未來修飾器未必都有此能力。現階段僅支援一種"
"基本觸覺回饋，未來有機會擴增更多類型。"

msgid "Haptic vibration"
msgstr "觸覺震動"

msgid "The haptic vibration allows us to specify a simple haptic pulse:"
msgstr "觸覺震動功能可設定簡單的震動脈衝："

msgid "It has the following options:"
msgstr "可自訂以下選項："

msgid ""
"``Duration`` is the duration of the pulse in nanoseconds. ``-1`` lets the "
"runtime choose an optimal value for a short pulse suitable for the current "
"hardware."
msgstr ""
"``Duration``：脈衝持續時間（單位：奈秒），設為 ``-1`` 則由執行環境自動選擇最"
"適合當前硬體的短脈衝時長。"

msgid ""
"``Frequency`` is the frequency of the pulse in Hz. ``0`` lets the runtime "
"choose an optimal frequency for a short pulse suitable for the current "
"hardware."
msgstr ""
"``Frequency``：脈衝頻率（Hz），設為 ``0`` 則由執行環境自動選擇最適合當前硬體"
"的短脈衝頻率。"

msgid "``Amplitude`` is the amplitude of the pulse."
msgstr "``Amplitude``：脈衝的振幅。"
