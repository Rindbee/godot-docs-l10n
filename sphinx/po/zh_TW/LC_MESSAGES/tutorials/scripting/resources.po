#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Resources"
msgstr "資源"

msgid "Nodes and resources"
msgstr "節點與資源"

msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as "
"important: :ref:`Resource <class_Resource>`."
msgstr ""
"在這個教學之前，我們都專注於 Godot 中的 :ref:`Node <class_Node>` 類別，因為你"
"會用節點來編寫行為，而大多數引擎功能也都依賴於此。但還有一種同樣重要的資料型"
"別：:ref:`Resource <class_Resource>`。"

msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*節點* 提供功能：例如繪製精靈（Sprite）、3D 模型、模擬物理、排列使用者介面"
"等；**資源** 則是 **資料容器**，它們本身不會執行任何動作，而是由節點來使用資"
"源中的資料。"

msgid ":ref:`Texture <class_Texture>`"
msgstr ":ref:`Texture <class_Texture>`"

msgid ":ref:`Script <class_Script>`"
msgstr ":ref:`Script <class_Script>`"

msgid ":ref:`Mesh <class_Mesh>`"
msgstr ":ref:`Mesh <class_Mesh>`"

msgid ":ref:`Animation <class_Animation>`"
msgstr ":ref:`Animation <class_Animation>`"

msgid ":ref:`AudioStream <class_AudioStream>`"
msgstr ":ref:`AudioStream <class_AudioStream>`"

msgid ":ref:`Font <class_Font>`"
msgstr ":ref:`Font <class_Font>`"

msgid ":ref:`Translation <class_Translation>`"
msgstr ":ref:`Translation <class_Translation>`"

msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"當引擎從硬碟載入資源時，**只會載入一次**。如果該資源的實體已經存在於記憶體"
"中，再次載入同一資源時都會回傳同一份拷貝。由於資源僅包含資料，因此不需要重複"
"複製。"

msgid ""
"Every object, be it a Node or a Resource, can export properties. There are "
"many types of Properties, like String, integer, Vector2, etc., and any of "
"these types can become a resource. This means that both nodes and resources "
"can contain resources as properties:"
msgstr ""
"每個物件，無論是節點還是資源，都可以匯出屬性。屬性有許多型別，例如字串、整"
"數、Vector2 等，而這些型別都可以成為資源。這代表節點和資源都可以將其他資源作"
"為屬性來包含："

msgid "External vs built-in"
msgstr "外部資源與內建資源"

msgid "There are two ways to save resources. They can be:"
msgstr "資源有兩種保存方式："

msgid "**External** to a scene, saved on the disk as individual files."
msgstr "**外部**，存放在場景之外，作為獨立檔案儲存於硬碟上。"

msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "**內建**，儲存在所屬的 ``.tscn`` 或 ``.scn`` 場景檔案之內。"

msgid ""
"To be more specific, here's a :ref:`Texture2D <class_Texture2D>` in "
"a :ref:`Sprite2D <class_Sprite2D>` node:"
msgstr ""
"更具體來說，以下範例是在 :ref:`Sprite2D <class_Sprite2D>` 節點中指派了一"
"個 :ref:`Texture2D <class_Texture2D>`："

msgid ""
"Clicking the resource preview allows us to view the resource's properties."
msgstr "點擊資源預覽圖可以查看該資源的屬性。"

msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"Path 屬性會顯示資源的來源。在這個例子中，來源是一個名為 ``robi.png`` 的 PNG "
"圖片。當資源來自這類檔案時，屬於外部資源；如果將 Path 清空或置空，該資源就變"
"成內建資源。"

msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"內建資源與外部資源的切換會在你儲存場景時發生。在上述例子中，如果你將 path 設"
"為空字串並儲存，Godot 會把圖片嵌入到 ``.tscn`` 場景檔案內。"

msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"即使你儲存的是內建資源，當多次實例化場景時，引擎也只會載入資源的一份拷貝。"

msgid "Loading resources from code"
msgstr "從程式碼載入資源"

msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr "要從程式碼中載入資源有兩種方式。第一種是隨時呼叫 ``load()`` 函式："

msgid ""
"You can also ``preload`` resources. Unlike ``load``, this function will read "
"the file from disk and load it at compile-time. As a result, you cannot call "
"``preload`` with a variable path: you need to use a constant string."
msgstr ""
"你也可以使用 ``preload`` 預載資源。和 ``load`` 不同，這個函式會在編譯階段就從"
"硬碟讀取檔案並載入。因此，``preload`` 不能使用變數路徑，只能用常數字串。"

msgid "Loading scenes"
msgstr "載入場景"

msgid ""
"Scenes are also resources, but there is a catch. Scenes saved to disk are "
"resources of type :ref:`PackedScene <class_PackedScene>`. The scene is "
"packed inside a :ref:`Resource <class_Resource>`."
msgstr ""
"場景也是一種資源，但有個地方要特別注意。儲存到硬碟上的場景"
"是 :ref:`PackedScene <class_PackedScene>` 型別的資源。也就是說，場景被包裝在"
"一個 :ref:`Resource <class_Resource>` 物件中。"

msgid ""
"To get an instance of the scene, you have to use "
"the :ref:`PackedScene.instantiate() <class_PackedScene_method_instantiate>` "
"method."
msgstr ""
"若要取得場景的實體，必須使用 :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` 方法。"

msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"這個方法會依照場景階層建立節點、設定好屬性，然後回傳場景的根節點。你可以將它"
"加入為任何其他節點的子節點。"

msgid ""
"The approach has several advantages. As the :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` function is fast, you can create new "
"enemies, bullets, effects, etc. without having to load them again from disk "
"each time. Remember that, as always, images, meshes, etc. are all shared "
"between the scene instances."
msgstr ""
"這種做法有不少優點。由於 :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>` 相當快速，你可以隨時建立新的敵人、子"
"彈、特效等，而不用每次都從硬碟重新載入。請記得，圖片、網格等資源在所有場景實"
"體之間都是共用的。"

msgid "Freeing resources"
msgstr "釋放資源"

msgid ""
"When a :ref:`Resource <class_Resource>` is no longer in use, it will "
"automatically free itself. Since, in most cases, Resources are contained in "
"Nodes, when you free a node, the engine frees all the resources it owns as "
"well if no other node uses them."
msgstr ""
"當 :ref:`Resource <class_Resource>` 不再被使用時，會自動釋放自身。在大多數情"
"況下，資源是被節點所持有的，因此當你釋放節點時，只要沒有其他節點正在使用該資"
"源，引擎也會一併釋放它。"

msgid "Creating your own resources"
msgstr "建立自訂資源"

msgid ""
"Like any Object in Godot, users can also script Resources. Resource scripts "
"inherit the ability to freely translate between object properties and "
"serialized text or binary data (\\*.tres, \\*.res). They also inherit the "
"reference-counting memory management from the RefCounted type."
msgstr ""
"如同 Godot 中的任何物件，使用者也能為資源撰寫腳本。資源腳本繼承了在物件屬性與"
"序列化文字或二進位資料（\\*.tres、\\*.res）間自由轉換的能力，也繼承自 "
"RefCounted 型別的引用計數記憶體管理。"

msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`FileAccess "
"<class_FileAccess>` to parse. What sets Resources apart is their inheritance "
"of :ref:`Object <class_Object>`, :ref:`RefCounted <class_RefCounted>`, "
"and :ref:`Resource <class_Resource>` features:"
msgstr ""
"這相較於其他資料結構（如 JSON、CSV 或自訂 TXT 檔案）有許多明顯優勢。使用者只"
"能將這些檔案匯入為 :ref:`Dictionary <class_Dictionary>`（如 JSON）或"
"由 :ref:`FileAccess <class_FileAccess>` 來解析。而 Resource 最大的不同點在於"
"它繼承了 :ref:`Object <class_Object>`、:ref:`RefCounted <class_RefCounted>`、"
"以及 :ref:`Resource <class_Resource>` 的特性："

msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr "可以定義常數，免去從其他資料欄位或物件取得常數的需求。"

msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"可以定義方法，包括為屬性設定 setter/getter。這能將底層資料抽象化並封裝起來，"
"即使資源腳本結構未來變動，使用該資源的遊戲內容不必跟著改動。"

msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr "可以定義訊號，讓資源在其資料變動時觸發對應的反應。"

msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr "可以明確定義屬性，讓使用者確信資料一定存在。"

msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"資源的自動序列化與反序列化是 Godot Engine 的內建功能，使用者不需要自訂實作資"
"源檔案資料的匯入／匯出。"

msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr "資源甚至可以遞迴序列化子資源，因此你可以設計更複雜的資料結構。"

msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files "
"(\\*.res) for increased speed and compression."
msgstr ""
"使用者可以將資源儲存為適合版本控制的文字檔格式（\\*.tres）。遊戲匯出時，"
"Godot 會將資源檔案序列化成二進位檔（\\*.res），提升速度與壓縮率。"

msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot Engine 的屬性檢查器（Inspector）可以直接顯示與編輯資源檔案，因此使用者"
"通常不需要自訂資料的視覺化或編輯邏輯。只要在檔案系統（FileSystem） Dock 中雙"
"擊資源檔，或在屬性檢查器裡點擊資料夾圖示並於對話框中開啟檔案即可。"

msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "除了基本 Resource 之外，也能擴充 **其他** 資源型別。"

msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr "Godot 讓你可以在屬性檢查器中輕鬆建立自訂資源。"

msgid "Set the ``script`` property in the Inspector to be your script."
msgstr "在屬性檢查器中將 ``script`` 屬性設為你的腳本。"

msgid ""
"If the script's language supports :ref:`script classes "
"<doc_gdscript_basics_class_name>`, then it streamlines the process. Defining "
"a name for your script alone will add it to the Inspector's creation dialog. "
"This will auto-add your script to the Resource object you create."
msgstr ""
"若腳本語言支援 :ref:`腳本類別 <doc_gdscript_basics_class_name>`，這個流程會更"
"簡潔。只要在腳本內定義類別名稱，該類別就會自動出現在屬性檢查器的建立對話框，"
"並自動將你的腳本加到你建立的資源物件上。"

msgid ""
"Let's see some examples. Create a :ref:`Resource <class_Resource>` and name "
"it ``bot_stats``. It should appear in your file tab with the full name "
"``bot_stats.tres``. Without a script, it's useless, so let's add some data "
"and logic! Attach a script to it named ``bot_stats.gd`` (or just create a "
"new script, and then drag it to it)."
msgstr ""
"讓我們看個例子。先建立一個 :ref:`Resource <class_Resource>` 並命名為 "
"``bot_stats``，它會以 ``bot_stats.tres`` 的全名出現在你的檔案列表中。沒有附加"
"腳本的話沒什麼用，所以我們來加點資料和邏輯吧！附加名為 ``bot_stats.gd`` 的腳"
"本（或新建一個腳本再拖曳進去）。"

msgid ""
"Now, create a :ref:`CharacterBody3D <class_CharacterBody3D>`, name it "
"``Bot``, and add the following script to it:"
msgstr ""
"現在，建立一個 :ref:`CharacterBody3D <class_CharacterBody3D>`，命名為 "
"``Bot``，然後加上下列腳本："

msgid ""
"Now, select the :ref:`CharacterBody3D <class_CharacterBody3D>` node which we "
"named ``bot``, and drag&drop the ``bot_stats.tres`` resource onto the "
"Inspector. It should print 10! Obviously, this setup can be used for more "
"advanced features than this, but as long you really understand *how* it all "
"worked, you should figure out everything else related to Resources."
msgstr ""
"現在，選擇我們命名為 ``bot`` 的 :ref:`CharacterBody3D "
"<class_CharacterBody3D>` 節點，然後將 ``bot_stats.tres`` 資源拖曳到屬性檢查器"
"上。應該會印出 10！當然，這個做法可以延伸到更高階的功能，只要你理解 *整個原理"
"*，資源系統的其他應用也就能迎刃而解。"

msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with "
"an :ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations "
"and editors for their data."
msgstr ""
"資源腳本很像 Unity 的 ScriptableObject。屬性檢查器本身就支援自訂資源。若有需"
"要，用戶也可以設計自己基於 Control 的工具腳本，並與 :ref:`EditorPlugin "
"<class_EditorPlugin>` 搭配，為資料打造自訂的視覺化介面與編輯器。"

msgid ""
"Unreal Engine's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"Unreal Engine 的 DataTable 和 CurveTable 也能很容易用資源腳本重現。DataTable "
"就是將字串對應到自訂結構，類似於 Dictionary 將字串對應到一個自訂資源腳本。"

msgid ""
"Instead of inlining the Dictionary values, one could also, alternatively:"
msgstr "除了直接在程式內寫死 Dictionary 值之外，你也可以："

msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs."
msgstr "從試算表匯入資料並產生鍵值對。"

msgid ""
"Design a visualization within the editor and create a plugin that adds it to "
"the Inspector when you open these types of Resources."
msgstr ""
"在編輯器內設計視覺化介面，並建立外掛程式，讓你在開啟這類資源時能將該視覺化介"
"面加到屬性檢查器中。"

msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTable 也是類似概念，只是把鍵對應到一組浮點數陣列或 :ref:`Curve "
"<class_Curve>` / :ref:`Curve2D <class_Curve2D>` 資源物件。"

msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"在下方例子中，Godot 會嘗試載入 ``Node`` 腳本，發現它沒有繼承 ``Resource``，因"
"型別不相容而導致資源物件載入腳本失敗。"
