#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "使用 SceneTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"在前面的教學中，一切都是圍繞「節點」這個概念。場景是由節點組成的集合，當它們"
"進入 *場景樹* 時就會變為啟用狀態。"

msgid "MainLoop"
msgstr "MainLoop"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot 的內部運作方式如下：一開始只有 :ref:`OS <class_OS>` 這個類別的唯一實例"
"在執行，之後才會載入所有驅動程式、伺服器、腳本語言、場景系統等。"

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"當初始化完成後，:ref:`OS <class_OS>` 需要提供一個 :ref:`MainLoop "
"<class_MainLoop>` 來執行。這部分都是屬於內部細節（如果有興趣了解這些內部運"
"作，可以參考原始碼中的 main/main.cpp 檔案）。"

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"使用者的程式或遊戲，會從 MainLoop 開始執行。這個類別有幾個方法，分別用於初始"
"化、閒置（影格同步回呼）、固定（物理同步回呼）與輸入。這些屬於較低階的操作，"
"在 Godot 裡開發遊戲時，通常不需要自己實作 MainLoop。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"One of the ways to explain how Godot works is that it's a high-level game "
"engine over a low-level middleware."
msgstr "可以這麼理解 Godot 的運作：它是建立在低階中介層之上的高階遊戲引擎。"

msgid ""
"The scene system is the game engine, while the :ref:`OS <class_OS>` and "
"servers are the low-level API."
msgstr ""
"場景系統就是遊戲引擎本身，而 :ref:`OS <class_OS>` 與伺服器則屬於低階 API。"

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"場景系統會提供自己的主迴圈給 OS，也就是 :ref:`SceneTree <class_SceneTree>`。"
"這個類別會在執行場景時自動實體化並設定，無需額外處理。"

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "必須注意這個類別的存在，因為它有幾個重要用途："

msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"它包含了根 :ref:`Viewport <class_Viewport>`，當場景第一次開啟時會被加為這個"
"根 Viewport 的子節點，成為 *場景樹* 的一部分（詳見下文）。"

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr "它包含有關群組的資訊，並可用來呼叫群組內所有節點或取得其清單。"

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "它也包含一些全域狀態的功能，例如設定暫停模式或結束處理程序。"

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by "
"calling :ref:`Node.get_tree() <class_Node_method_get_tree>`."
msgstr ""
"當節點成為場景樹的一部分時，可以透過呼叫 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 來取得 :ref:`SceneTree <class_SceneTree>` 單"
"例。"

msgid "Root viewport"
msgstr "根 Viewport"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 永遠位於場景最頂層。你可以在節點中用兩種"
"方式取得它："

msgid ""
"This node contains the main viewport. Anything that is a child of "
"a :ref:`Viewport <class_Viewport>` is drawn inside of it by default, so it "
"makes sense that the top of all nodes is always a node of this type "
"otherwise nothing would be seen."
msgstr ""
"這個節點就是主 Viewport。所有作為 :ref:`Viewport <class_Viewport>` 子節點的物"
"件都會預設繪製於其內，因此所有節點的最頂層一定是這種類型，否則將無法顯示。"

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"雖然可以在場景中建立其他 Viewport（例如分割畫面等效果），但這個根 Viewport 永"
"遠不是由使用者建立，而是在 SceneTree 內自動產生。"

msgid "Scene tree"
msgstr "場景樹"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "當節點直接或間接連接到根 Viewport 時，就成為 *場景樹* 的一部分。"

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"這表示，如同前面教學所述，該節點會收到 ``_enter_tree()`` 和 ``_ready()`` 回呼"
"（還有 ``_exit_tree()``）。"

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"當節點進入 *場景樹* 後，就會變成啟用狀態。它們可以存取所有處理流程所需的內"
"容，包含取得輸入、顯示 2D/3D 畫面、接收和發送通知、播放音效等。當節點從 *場景"
"樹* 移除時，這些能力也會隨之失效。"

msgid "Tree order"
msgstr "樹狀順序"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""
"Godot 中大多數的節點操作，例如 2D 繪製、處理流程或接收通知，都是依照 *樹狀順"
"序* 來進行，也就是在編輯器中由上而下的順序（又稱為前序遍歷）："

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""
"舉例來說，場景中最上層的節點會最先呼叫其 ``_process()`` 方法，然後依序呼叫下"
"一個節點的 ``_process()``，以此類推。"

msgid ""
"An important exception is the ``_ready()`` function: each parent node has "
"its ``_ready()`` function called only after all its child nodes have their "
"``_ready()`` functions called, so that the parent knows its children are "
"completely ready to be accessed. This is also known as post-order traversal. "
"In the above image, ``NameLabel`` would be notified first (but only after "
"its children, if it had any!), followed by ``Name``, etc., and ``Panel`` "
"would be notified last."
msgstr ""
"有個重要的例外是 ``_ready()`` 方法：每個父節點的 ``_ready()`` 只會在所有子節"
"點的 ``_ready()`` 都被呼叫後才會執行，確保父節點可以安全存取所有子節點。這稱"
"為後序遍歷。在上方的例子中，會先通知 `NameLabel`（但僅在它的子節點都已通知"
"後），然後依序是 `Name` 等，`Panel` 會最後收到通知。"

msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""
"你也可以透過節點的 ``process_priority`` 屬性來覆寫這個執行順序。數值較小的節"
"點會優先被呼叫。例如，優先序為「0、1、2、3」的節點會依序（由左到右）被呼叫。"

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "藉由進入 *場景樹* 來「啟用」"

msgid "A scene is loaded from disk or created by scripting."
msgstr "場景可以從硬碟載入，也可以透過腳本建立。"

msgid ""
"The root node of that scene (only one root, remember?) is added as either a "
"child of the \"root\" Viewport (from SceneTree), or to any of its "
"descendants."
msgstr ""
"該場景的根節點（僅有一個，記得嗎？）會被加到 SceneTree 的「root」 Viewport 或"
"其後代任一節點下。"

msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"新加入場景的每個節點都會依照由上到下（前序遍歷）的順序收到「enter_tree」通知"
"（GDScript 中為 ``_enter_tree()`` 回呼）。"

msgid ""
"Every node will receive the \"ready\" notification ( ``_ready()`` callback "
"in GDScript) for convenience, once all its children have received the "
"\"ready\" notification (post-order traversal)."
msgstr ""
"每個節點會在其所有子節點收到「ready」通知後，再收到自己的「ready」通知"
"（GDScript 中為 ``_ready()`` 回呼），這是為了方便管理（也就是後序遍歷）。"

msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"當一個場景（或其部分）被移除時，節點會依照自下而上的順序收到「exit scene」通"
"知（GDScript 中為 ``_exit_tree()`` 回呼），順序與加入時正好相反。"

msgid "Changing current scene"
msgstr "切換目前場景"

msgid ""
"After a scene is loaded, you may want to change this scene for another one. "
"One way to do this is to use the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` function:"
msgstr ""
"當場景載入後，你可能希望切換成另一個場景。可以使"
"用 :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 函式來達成："

msgid ""
"Rather than using file paths, one can also use ready-made :ref:`PackedScene "
"<class_PackedScene>` resources using the equivalent "
"function :ref:`SceneTree.change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>`:"
msgstr ""
"除了直接用檔案路徑，也可以傳入已載入的 :ref:`PackedScene "
"<class_PackedScene>` 資源，使用對應"
"的 :ref:`SceneTree.change_scene_to_packed(PackedScene scene) "
"<class_SceneTree_method_change_scene_to_packed>` 函式："

msgid ""
"These are quick and useful ways to switch scenes but have the drawback that "
"the game will stall until the new scene is loaded and running. At some point "
"in the development of your game, it may be preferable to create proper "
"loading screens with progress bar, animated indicators or threaded "
"(background) loading. This must be done manually "
"using :ref:`doc_singletons_autoload` and :ref:`doc_background_loading`."
msgstr ""
"這些方法讓你能快速切換場景，但缺點是遊戲會在新場景載入並啟動前暫停。當你的遊"
"戲開發到一定階段，建議製作一個合適的載入畫面，配上進度條、動畫指示器，或用多"
"執行緒（背景）載入。這些需要手動實作，相關做法請參"
"考 :ref:`doc_singletons_autoload` 與 :ref:`doc_background_loading`。"
