#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Nodes and scene instances"
msgstr "節點與場景實體"

msgid ""
"This guide explains how to get nodes, create nodes, add them as a child, and "
"instantiate scenes from code."
msgstr ""
"本指南將說明如何獲取節點、建立節點、將節點新增為子節點，以及如何用程式碼實體"
"化場景。"

msgid ""
"Check the :ref:`doc_instancing` tutorial to learn about Godot's approach to "
"scene instancing."
msgstr ""
"請參閱 :ref:`doc_instancing` 教學，進一步瞭解 Godot 處理場景實體化的方法。"

msgid "Getting nodes"
msgstr "取得節點"

msgid ""
"You can get a reference to a node by calling the :ref:`Node.get_node() "
"<class_Node_method_get_node>` method. For this to work, the child node must "
"be present in the scene tree. Getting it in the parent node's ``_ready()`` "
"function guarantees that."
msgstr ""
"你可以透過呼叫 :ref:`Node.get_node() <class_Node_method_get_node>` 方法來取得"
"節點的參考。要讓這個方法正常運作，該子節點必須已經存在於場景樹中。在父節點的 "
"``_ready()`` 函式中取得節點可以保證這一點。"

msgid ""
"If, for example,  you have a scene tree like this, and you want to get a "
"reference to the Sprite2D and Camera2D nodes to access them in your script."
msgstr ""
"舉例來說，如果你有如下的場景樹，並且想在腳本中取得 Sprite2D 和 Camera2D 節點"
"的參考。"

msgid "To do so, you can use the following code."
msgstr "你可以使用以下程式碼來達成。"

msgid ""
"Note that you get nodes using their name, not their type. Above, "
"\"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene."
msgstr ""
"請注意，取得節點時是使用節點名稱，而非型別。上述範例中的「Sprite2D」與"
"「Camera2D」都是該節點在場景中的名稱。"

msgid ""
"If you rename the Sprite2D node as Skin in the Scene dock, you have to "
"change the line that gets the node to ``get_node(\"Skin\")`` in the script."
msgstr ""
"如果你在「場景」面板中將 Sprite2D 節點重新命名為 Skin，那就必須在腳本中將取得"
"該節點的程式碼更改為 ``get_node(\"Skin\")``。"

msgid "Node paths"
msgstr "節點路徑"

msgid ""
"When getting a reference to a node, you're not limited to getting a direct "
"child. The ``get_node()`` function supports paths, a bit like when working "
"with a file browser. Add a slash to separate nodes."
msgstr ""
"在取得節點參考時，不只限於直接子節點。``get_node()`` 方法支援路徑，有點像是在"
"檔案總管中操作，使用斜線分隔各節點。"

msgid ""
"Take the following example scene, with the script attached to the "
"UserInterface node."
msgstr "以下列範例場景為例，腳本掛載在 UserInterface 節點上。"

msgid "To get the AnimationPlayer node, you would use the following code."
msgstr "要取得 AnimationPlayer 節點，可以使用以下程式碼。"

msgid ""
"As with file paths, you can use \"..\" to get a parent node. The best "
"practice is to avoid doing that though not to break encapsulation. You can "
"also start the path with a forward slash to make it absolute, in which case "
"your topmost node would be \"/root\", the application's predefined root "
"viewport."
msgstr ""
"和檔案路徑一樣，可以使用「..」取得父節點。不過，最佳實踐是避免這樣做，以維持"
"良好的封裝性。你也可以讓路徑以斜線開頭，代表這是絕對路徑，此時最上層節點會是"
"「/root」，也就是應用程式預設的根視窗。"

msgid "Syntactic sugar"
msgstr "語法糖"

msgid ""
"You can use two shorthands to shorten your code in GDScript. Firstly, "
"putting the ``@onready`` annotation before a member variable makes it "
"initialize right before the ``_ready()`` callback."
msgstr ""
"在 GDScript 中，你可以使用兩個速記法來簡化你的程式碼。第一個是在成員變數前加"
"上 ``@onready`` 標註，這樣變數會在 ``_ready()`` 回呼前自動初始化。"

msgid ""
"There is also a short notation for ``get_node()``: the dollar sign, \"$\". "
"You place it before the name or path of the node you want to get."
msgstr ""
"此外，也可以用美元符號「$」作為 ``get_node()`` 的簡寫。只要將「$」放在你想取"
"得的節點名稱或路徑前即可。"

msgid "Creating nodes"
msgstr "建立節點"

msgid ""
"To create a node from code, call its ``new()`` method like for any other "
"class-based datatype."
msgstr "要從程式碼建立節點，只需像其他類別型資料一樣呼叫 ``new()`` 方法即可。"

msgid ""
"You can store the newly created node's reference in a variable and call "
"``add_child()`` to add it as a child of the node to which you attached the "
"script."
msgstr ""
"你可以將新建立的節點參考存入變數，然後用 ``add_child()`` 把它加入為腳本掛載節"
"點的子節點。"

msgid ""
"To delete a node and free it from memory, you can call its ``queue_free()`` "
"method. Doing so queues the node for deletion at the end of the current "
"frame after it has finished processing. At that point, the engine removes "
"the node from the scene and frees the object in memory."
msgstr ""
"要刪除節點並釋放其記憶體，可以呼叫它的 ``queue_free()`` 方法。這會將節點排入"
"佇列，在本幀處理結束後刪除。屆時，Godot 會把該節點從場景移除並釋放記憶體資"
"源。"

msgid ""
"Before calling ``sprite2d.queue_free()``, the remote scene tree looks like "
"this."
msgstr "在呼叫 ``sprite2d.queue_free()`` 之前，遠端場景樹看起來如下。"

msgid ""
"After the engine freed the node, the remote scene tree doesn't display the "
"sprite anymore."
msgstr "當引擎釋放該節點後，遠端場景樹就不會再顯示這個精靈了。"

msgid ""
"You can alternatively call ``free()`` to immediately destroy the node. You "
"should do this with care as any reference to it will instantly become "
"``null``. We recommend using ``queue_free()`` unless you know what you're "
"doing."
msgstr ""
"你也可以呼叫 ``free()`` 立即銷毀節點，但需謹慎使用，因為所有對該節點的參考會"
"立即變成 ``null``。除非你確定這樣做沒問題，否則建議用 ``queue_free()``。"

msgid ""
"When you free a node, it also frees all its children. Thanks to this, to "
"delete an entire branch of the scene tree, you only have to free the topmost "
"parent node."
msgstr ""
"釋放節點時也會同時釋放其所有子節點。因此，若要刪除場景樹的整個分支，只需釋放"
"最上層的父節點即可。"

msgid "Instancing scenes"
msgstr "場景實體化"

msgid ""
"Scenes are templates from which you can create as many reproductions as "
"you'd like. This operation is called instancing, and doing it from code "
"happens in two steps:"
msgstr ""
"場景是可以重複產生多份副本的範本。這個動作稱為「實體化」，在程式碼中實體化場"
"景需分兩個步驟："

msgid "Loading the scene from the local drive."
msgstr "從本地磁碟載入場景。"

msgid ""
"Creating an instance of the loaded :ref:`PackedScene <class_PackedScene>` "
"resource."
msgstr "將載入的 :ref:`PackedScene <class_PackedScene>` 資源產生實體。"

msgid ""
"Preloading the scene can improve the user's experience as the load operation "
"happens when the compiler reads the script and not at runtime. This feature "
"is only available with GDScript."
msgstr ""
"預先載入場景可以提升使用者體驗，因為載入動作會在編譯器讀取腳本時發生，而不是"
"在執行階段才載入。這個功能僅支援 GDScript。"

msgid ""
"At that point, ``scene`` is a packed scene resource, not a node. To create "
"the actual node, you need to call :ref:`PackedScene.instantiate() "
"<class_PackedScene_method_instantiate>`. It returns a tree of nodes that you "
"can use as a child of your current node."
msgstr ""
"此時，``scene`` 仍是一個打包場景資源，而不是節點。要建立實際的節點，需呼"
"叫 :ref:`PackedScene.instantiate() <class_PackedScene_method_instantiate>`。"
"這個方法會回傳一個節點樹，可以作為目前節點的子節點使用。"

msgid ""
"The advantage of this two-step process is you can keep a packed scene loaded "
"and create new instances on the fly. For example, to quickly instance "
"several enemies or bullets."
msgstr ""
"這種兩步驟的方式好處是可以維持場景資源已載入的狀態，隨時快速產生新實體。例如"
"可用於即時生成多個敵人或子彈。"
