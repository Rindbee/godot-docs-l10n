#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDExtension C example"
msgstr "GDExtension C 範例"

msgid "Introduction"
msgstr "前言"

msgid ""
"This is a simple example on how to work with GDExtension directly with C "
"code. Note that the API is not meant to be used directly, so this will "
"definitely be quite verbose and require a lot of steps even for a small "
"example. However, it serves as a reference for creating bindings for a "
"different language. It is still possible to use the API directly if you "
"prefer, which might be convenient when only binding a third-party library."
msgstr ""
"這是一個如何直接使用 C 語言操作 GDExtension 的簡單範例。請注意，API 並非設計"
"給你直接使用，因此即使只是簡單範例，步驟也會相當繁瑣冗長。不過，這可以作為其"
"他語言繫結的參考。如果你只是要繫結第三方函式庫，直接用 API 其實也沒問題。"

msgid ""
"In this example we will create a custom node that moves a sprite on the "
"screen based on the user's parameters. While very simple, it serves to show "
"how to do some of the things with GDExtension, like registering custom "
"classes with methods, properties, and signals. It gives an insight on the "
"GDExtension API."
msgstr ""
"在這個範例中，我們將建立一個自訂節點，依使用者給定的參數在畫面上移動一個精靈"
"（Sprite）。雖然範例本身很簡單，但能展示 GDExtension 如何實作自訂類別、方法、"
"屬性與訊號，也能讓你更理解 GDExtension API 的運作方式。"

msgid "Setting up the project"
msgstr "設定專案"

msgid "There are a few prerequisites you'll need:"
msgstr "你需要先準備以下幾項："

msgid "a Godot 4.2 (or later) executable,"
msgstr "Godot 4.2（或更新版本）的可執行檔，"

msgid "a C compiler,"
msgstr "C 編譯器，"

msgid "SCons as a build tool."
msgstr "SCons 作為建置工具。"

msgid ""
"Since this is using the API directly, there's no need to use the `godot-cpp "
"repository <https://github.com/godotengine/godot-cpp>`__."
msgstr ""
"由於這是直接使用 API，因此不需要 `godot-cpp 儲存庫 <https://github.com/"
"godotengine/godot-cpp>`__。"

msgid "File structure"
msgstr "檔案結構"

msgid "To organize our files, we're gonna split into mainly two folders:"
msgstr "為了方便管理檔案，我們會主要分成兩個資料夾："

msgid ""
"We also need a copy of the ``gdextension_interface.h`` header from the Godot "
"source code, which can be obtained directly from the Godot executable by "
"running the following command:"
msgstr ""
"我們還需要從 Godot 原始碼中取得 ``gdextension_interface.h`` 標頭檔。你可以直"
"接從 Godot 執行檔使用以下指令取得："

msgid ""
"This creates the header in the current folder, so you can just copy it to "
"the ``src`` folder in the example project."
msgstr ""
"這會在目前資料夾產生該標頭檔，你可以將它複製到範例專案的 ``src`` 資料夾中。"

msgid ""
"Lastly, there's another source of information we need to refer to, which is "
"the JSON file with the Godot API reference. This file won't be used by the "
"code directly, we will only use it to extract some information manually."
msgstr ""
"最後，我們還需要一份 Godot API 參考的 JSON 檔案。這個檔案不會被程式直接引用，"
"而是讓我們手動查詢、取得一些必要資訊。"

msgid "To get this JSON file, just call the Godot executable:"
msgstr "要取得這個 JSON 檔，只要執行 Godot 執行檔即可："

msgid ""
"The resulting ``extension_api.json`` file will be created in the current "
"folder. You can copy this file to the example folder to have it handy."
msgstr ""
"產生出來的 ``extension_api.json`` 檔案會在目前資料夾。建議複製到範例資料夾以"
"方便使用。"

msgid ""
"This extension is targeting Godot 4.2, but it should work on later versions "
"as well. If you want to target a different minimal version, make sure to get "
"the header and the JSON from the version Godot version you are targeting."
msgstr ""
"本範例針對 Godot 4.2 製作，但應該也能在更新版本運作。如果你需要支援其他版本，"
"請務必從對應版本的 Godot 取得標頭檔及 JSON 檔。"

msgid "Buildsystem"
msgstr "建置系統"

msgid ""
"Using a buildsystem makes our life a lot easier when dealing with C code. "
"For the sake of convenience, we'll use SCons since it's the same as what "
"Godot itself uses."
msgstr ""
"使用建置系統（build system）可以讓我們在撰寫 C 程式碼時輕鬆許多。這裡我們選"
"擇 SCons，因為 Godot 本身也使用它。"

msgid ""
"The following ``SConstruct`` file is a simple one that will build your "
"extension to the current platform that you are using, be it Linux, macOS, or "
"Windows. This will be a non-optimized build for debugging purposes. It also "
"assumes a 64-bit build, which is relevant for some parts of the example "
"code. Making other build types and cross-compilation is out of the scope of "
"this tutorial. Save this file to the root folder."
msgstr ""
"以下的 ``SConstruct`` 範例是一個簡單的建置腳本，能自動針對你目前的作業系統"
"（Linux、macOS 或 Windows）編譯擴充。這裡預設是除錯用（未最佳化）版本，並假設"
"是 64 位元建置（某些範例程式碼會用到）。其他建置型態或跨平台編譯的說明就不在"
"本教學範圍之內。請將此檔案存放在專案根目錄。"

msgid ""
"This will include all C files in the ``src`` folder, so we don't need to "
"change this file when adding new source files."
msgstr ""
"這樣寫會自動包含 ``src`` 資料夾下的所有 C 檔案，因此新增原始碼時無需修改這個"
"建置腳本。"

msgid "Initializing the extension"
msgstr "初始化擴充元件"

msgid ""
"The first bit of code will be responsible for initializing the extension. "
"This is what makes Godot aware of what our GDExtension provides, such as "
"classes and plugins."
msgstr ""
"第一個要處理的程式碼片段就是初始化擴充元件。這部分讓 Godot 能正確辨識我們的 "
"GDExtension 提供哪些類別、外掛等內容。"

msgid ""
"Create the file ``init.h`` in the ``src`` folder, with the following "
"contents:"
msgstr "在 ``src`` 資料夾中建立 ``init.h`` 檔案，內容如下："

msgid ""
"The functions declared here have the signatures expected by the GDExtension "
"API."
msgstr "這裡宣告的函式其簽名都符合 GDExtension API 的要求。"

msgid ""
"Note the inclusion of the ``defs.h`` file. This is one of our helpers to "
"simplify writing the extension code. For now it will only contain the "
"definition of ``GDE_EXPORT``, a macro that makes the function public in the "
"shared library so Godot can properly call it. This macro helps abstracting "
"what each compiler expects."
msgstr ""
"請注意這裡有包含 ``defs.h``。這個檔案是我們自訂的輔助工具，用來簡化擴充元件的"
"程式碼。目前它只定義了 ``GDE_EXPORT``，這是一個巨集，用來讓這些函式能正確地在"
"動態連結庫中公開，以便 Godot 可以呼叫。這能幫助我們抽象掉不同編譯器的細節。"

msgid ""
"Create the ``defs.h`` file in the ``src`` folder with the following contents:"
msgstr "在 ``src`` 資料夾中建立 ``defs.h`` 檔案，內容如下："

msgid ""
"We also include some standard headers to make things easier. Now we only "
"have to include ``defs.h`` and those will come as a bonus."
msgstr ""
"這裡也一併包含了一些標準標頭檔，讓後續操作更方便。只要引入 ``defs.h``，這些標"
"頭檔也會自動包含進來。"

msgid ""
"Now, let's implement the functions we just declared. Create a file called "
"``init.c`` in the ``src`` folder and add this code:"
msgstr ""
"接下來，我們來實作剛剛宣告的那些函式。請在 ``src`` 資料夾中建立 ``init.c``，"
"並加入以下程式碼："

msgid ""
"What this does is set up the initialization data that Godot expects. The "
"functions to initialize and deinitialize are set so Godot will call then "
"when needed. It also sets the initialization level which varies per "
"extension. Since we plan to add a custom node, the ``SCENE`` level is enough."
msgstr ""
"這段程式碼是設定 Godot 所期望的初始化資料。初始化與反初始化的函式都在這裡註"
"冊，Godot 會在需要時呼叫。此外，還可以設定初始化等級（每個擴充元件可不同）。"
"因為我們要加自訂節點，所以 ``SCENE`` 等級就足夠了。"

msgid ""
"We will fill the ``initialize_gdexample_module()`` function later to "
"register our custom class."
msgstr ""
"我們稍後會補上 ``initialize_gdexample_module()`` 函式的內容，用於註冊自訂類"
"別。"

msgid "A basic class"
msgstr "基本類別"

msgid ""
"In order to make an actual node, first we'll create a C struct to hold data "
"and functions that will act as methods. The plan is to make this a custom "
"node that inherits from :ref:`Sprite2D <class_Sprite2D>`."
msgstr ""
"為了建立一個實際的節點，我們首先會建立一個 C 結構（struct）來儲存資料與函式，"
"這些函式將作為「方法」。我們打算讓這個自訂節點繼承自 :ref:`Sprite2D "
"<class_Sprite2D>`。"

msgid ""
"Create a file called ``gdexample.h`` in the ``src`` folder with the "
"following contents:"
msgstr "在 ``src`` 資料夾中建立 ``gdexample.h`` 檔案，內容如下："

msgid ""
"Noteworthy here is the ``object`` field, which holds a pointer to the Godot "
"object, and the ``gdexample_class_bind_methods()`` function, which will "
"register the metadata of our custom class (properties, methods, and "
"signals). The latter is not entirely necessary, as we can do it when "
"registering the class, but it makes clearer to separate the concerns and let "
"our class register its own metadata."
msgstr ""
"這裡要注意的是 ``object`` 欄位，它儲存一個指向 Godot 物件的指標，還有 "
"``gdexample_class_bind_methods()`` 函式，這個函式會註冊我們自訂類別的中繼資料"
"（屬性、方法、訊號）。後者其實可以直接在註冊類別時做，但分開會讓結構更清晰，"
"也方便讓每個類別自己註冊自己的中繼資料。"

msgid ""
"The ``object`` field is necessary because our class will inherit a Godot "
"class. Since we can't inherit it directly, as we are not interacting with "
"the source code (and C doesn't even have classes), we instead tell Godot to "
"create an object of a type it knows and attach our extension to it. We will "
"need the reference to such objects when calling methods on the parent class, "
"for instance."
msgstr ""
"``object`` 欄位之所以必要，是因為我們的類別要繼承自 Godot 內建的類別。由於我"
"們無法直接繼承（畢竟我們不是直接操作原始碼，而且 C 沒有類別），所以我們會請 "
"Godot 建立一個它已知型態的物件，然後掛上我們的擴充。這樣在呼叫父類別方法時就"
"能取得對應的物件指標。"

msgid ""
"Let's create the source counterpart of this header. Create the file "
"``gdexample.c`` in the ``src`` folder and add the following code to it:"
msgstr ""
"接著來建立這個標頭檔對應的原始碼檔案。在 ``src`` 資料夾中建立 "
"``gdexample.c``，並加入以下程式碼："

msgid ""
"As we don't have anything to do with those functions yet, they'll stay empty "
"for a while."
msgstr "目前這些函式還沒有要實作的內容，所以暫時先留空。"

msgid ""
"The next step is registering our class. However, in order to do so we need "
"to create a :ref:`StringName <class_StringName>` and for that we have to get "
"a function from the GDExtension API. Since we'll need this a few times and "
"we'll also need other things, let's create a wrapper API to facilitate this "
"kind of chore."
msgstr ""
"下一步是註冊我們的類別。不過要註冊時，我們需要建立一個 :ref:`StringName "
"<class_StringName>`，而這又需要從 GDExtension API 取得相關函式。因為這類動作"
"會重複多次，還會用到其他功能，讓我們來建立一個包裝 API 來簡化這些繁瑣的步驟。"

msgid "A wrapper API"
msgstr "包裝 API"

msgid "We'll start by creating an ``api.h`` file in the ``src`` folder:"
msgstr "我們先在 ``src`` 資料夾中建立一個 ``api.h`` 檔案："

msgid ""
"This file will include many other helpers as we fill our extension with "
"something useful. For now it only has a pointer to a function that creates a "
"StringName from a C string (in Latin-1 encoding) and another to destruct a "
"StringName, which we'll need to use to avoid leaking memory, as well as the "
"function to register a class, which is our initial goal."
msgstr ""
"之後我們會在這個檔案裡加入更多輔助功能。目前只定義了一個能用 C 字串（Latin-1 "
"編碼）建立 StringName 的函式指標，和一個負責釋放 StringName 記憶體的函式，這"
"樣才不會造成記憶體洩漏，以及註冊類別所需的函式，這是我們此階段的主要目標。"

msgid ""
"We also keep a reference to the ``class_library`` here. This is something "
"that Godot provides to us when initializing the extension and we'll need to "
"use it when registering the things we create so Godot can tell which "
"extension is making the call."
msgstr ""
"這裡也保留一個 ``class_library`` 的參考。這是在初始化擴充元件時 Godot 提供給"
"我們的，註冊自訂內容時要交給 Godot，如此 Godot 才知道是哪個擴充元件在呼叫相關"
"功能。"

msgid ""
"There's also a function to load those function pointers from the GDExtension "
"API."
msgstr "這裡還有一個函式專門從 GDExtension API 載入這些函式指標。"

msgid ""
"Let's work on the source counterpart of this header. Create the ``api.c`` "
"file in the ``src`` folder, adding the following code:"
msgstr ""
"接著來撰寫這個標頭檔對應的原始碼檔案。在 ``src`` 資料夾裡新增 ``api.c``，並加"
"入下列程式碼："

msgid ""
"The first important thing here is ``p_get_proc_address``. This a function "
"from the GDExtension API that is passed during initialization. You can use "
"this function to request specific functions from the API by their name. Here "
"we are caching the results so we don't have to keep a reference for "
"``p_get_proc_address`` everywhere and use our wrapper instead."
msgstr ""
"這裡最重要的是 ``p_get_proc_address``。這是 GDExtension API 在初始化時傳給我"
"們的一個函式，你可以用它來依名稱取得 API 上的特定函式。我們會把取得的結果快取"
"起來，這樣就不用在每個地方都保存 ``p_get_proc_address``，只要用我們的包裝器即"
"可。"

msgid ""
"At the start we request the ``variant_get_ptr_destructor()`` function. This "
"is not going to be used outside of this function, so we don't add to our "
"wrapper and only cache it locally. The cast is necessary to silence compiler "
"warnings."
msgstr ""
"一開始我們會請求 ``variant_get_ptr_destructor()`` 這個函式。這個函式只在這裡"
"用得到，所以不加到我們的包裝器，只在本地變數快取。這裡的型別轉換是為了消除編"
"譯器警告。"

msgid ""
"Then we get the function that creates a StringName from a C string, exactly "
"what we mentioned before as a needed function. We store that in our "
"``constructors`` struct."
msgstr ""
"接著取得建立 StringName 的函式，這正是我們前面提到需要的功能。這個函式會被存"
"放到 ``constructors`` 結構裡。"

msgid ""
"Next, we use the ``variant_get_ptr_destructor()`` function we just got to "
"query for the destructor for StringName, using the enum value from "
"``gdextension_interface.h`` API as a parameter. We could get destructors for "
"other types in a similar manner, but we'll limit ourselves to what is needed "
"for the example."
msgstr ""
"然後我們利用剛取得的 ``variant_get_ptr_destructor()`` 函式，搭配 "
"``gdextension_interface.h`` API 的列舉值，查詢 StringName 的解構（釋放）函"
"式。其他型態的解構函式也能用同樣方式取得，但這裡只拿我們範例會用到的部分。"

msgid ""
"Lastly, we get the ``classdb_register_extension_class2()`` function, which "
"we'll need in order to register our custom class."
msgstr ""
"最後，我們取得 ``classdb_register_extension_class2()`` 函式，這是註冊自訂類別"
"時會用到的。"

msgid ""
"You may wonder why the ``2`` is there in the function name. This means it's "
"the second version of this function. The old version is kept to ensure "
"backwards compatibility with older extensions, but since we have the second "
"version available, it's best to use the new one, because we don't intend to "
"support older Godot versions in this example."
msgstr ""
"你可能會好奇函式名稱中的 ``2``。這代表這是第二版的函式。舊版還保留是為了向下"
"相容，但既然我們有新版可用，建議直接用新的，因為本範例不打算支援舊版 Godot。"

msgid ""
"The ``gdextension_interface.h`` header documents in which Godot version each "
"function was introduced."
msgstr ""
"你可以從 ``gdextension_interface.h`` 標頭檔看到每個函式是在哪個 Godot 版本引"
"入的。"

msgid ""
"We also define the ``class_library`` variable here, which will be set during "
"initialization."
msgstr "這裡也定義了 ``class_library`` 變數，會在初始化時設定。"

msgid ""
"Speaking of initialization, now we have to change the ``init.c`` file in "
"order to fill the things we just added:"
msgstr "說到初始化，現在我們要修改 ``init.c`` 檔案，把剛剛新增的內容補齊："

msgid ""
"Here we set the ``class_library`` as needed and call our new ``load_api()`` "
"function. Don't forget to also include the new headers at the top of this "
"file:"
msgstr ""
"這裡我們設定所需的 ``class_library``，並呼叫剛加進來的 ``load_api()`` 函式。"
"也別忘了在檔案頂端引入新的標頭檔："

msgid ""
"Since we are here, we can register our new custom class. Let's fill the "
"``initialize_gdexample_module()`` function:"
msgstr ""
"既然都到這裡了，也順便註冊我們的新自訂類別。請將 "
"``initialize_gdexample_module()`` 函式內容補上："

msgid ""
"The struct with the class information is the biggest thing here. None of its "
"fields are required with the exception of ``create_instance_func`` and "
"``free_instance_func``. We haven't made those functions yet, so we'll have "
"to work on them soon. Note that we skip the initialization if it isn't at "
"the ``SCENE`` level. This function may be called multiple times, once for "
"each level, but we only want to register our class once."
msgstr ""
"類別資訊的 struct 這段是這裡最重要的內容。除了 ``create_instance_func`` 和 "
"``free_instance_func`` 之外，其他欄位都不是必填。這兩個函式我們還沒實作，等下"
"會補上。另外要注意，這個初始化函式會根據等級（level）重複呼叫，我們只在 "
"``SCENE`` 等級時進行類別註冊。"

msgid ""
"The other undefined thing here is ``StringName``. This will be an opaque "
"struct meant to hold the data of a Godot StringName in our extension. We'll "
"define it in the appropriately named ``defs.h`` file:"
msgstr ""
"另一個還沒定義的是 ``StringName``。這是一個不透明的 struct，用來在我們的擴充"
"元件裡存放 Godot 的 StringName 資料。我們會在 ``defs.h`` 裡正確定義它："

msgid ""
"As mentioned in the comment, the sizes can be found in the "
"``extension_api.json`` file that we generated earlier, under the "
"``builtin_class_sizes`` property. The ``BUILD_32`` is never defined, as we "
"assume we are working with a 64-bits build of Godot here, but if you need it "
"you can add ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` to your ``SConstruct`` "
"file."
msgstr ""
"如註解所述，這些型態的大小可以從我們先前生成的 ``extension_api.json`` 檔案裡"
"的 ``builtin_class_sizes`` 屬性找到。這裡預設沒定義 ``BUILD_32``，因為我們假"
"設都是用 64 位元 Godot。如果你需要 32 位元，記得可以在 ``SConstruct`` 裡加上 "
"``env.Append(CPPDEFINES=[\"BUILD_32\"])``。"

msgid ""
"The ``// Types.`` comment foreshadows that we'll be adding more types to "
"this file. Let's leave that for later."
msgstr "``// Types.`` 註解暗示我們之後會再加更多型態到這個檔案，這裡先不展開。"

msgid ""
"The ``StringName`` struct here is just to hold Godot data, so we don't "
"really care what is inside of it. Though, in this case, it is just a pointer "
"to the data in the heap. We'll use this struct when we need to allocate data "
"for a StringName ourselves, like we are doing when registering our class."
msgstr ""
"這裡的 ``StringName`` struct 只是用來存放 Godot 的資料，所以裡面的內容我們不"
"用太在意。實際上它只是個指向堆積資料的指標。當我們需要自行配置 StringName 的"
"記憶體時（例如註冊類別時），就會用到這個 struct。"

msgid ""
"Back to registering, we need to work on our create and free functions. Let's "
"include them in ``gdexample.h`` since they're specific to the custom class:"
msgstr ""
"回到類別註冊部分，我們需要實作建立與釋放物件的函式。這些是自訂類別專用的，所"
"以宣告在 ``gdexample.h``："

msgid ""
"Before we can implement those function, we'll need a few more things in our "
"API. We need a way to allocate and free memory. While we could do this with "
"good ol' ``malloc()``, we can instead make use of Godot's memory management "
"functions. We'll also need a way to create a Godot object and set it with "
"our custom instance."
msgstr ""
"在實作這些函式前，我們還需要幾個 API。我們需要記憶體配置與釋放的方式。雖然可"
"以用傳統的 ``malloc()``，但這裡改用 Godot 的記憶體管理函式。另外還必須有建立 "
"Godot 物件並與自訂實例綁定的方法。"

msgid "So let's change the ``api.h`` to include these new functions:"
msgstr "所以現在來修改 ``api.h``，加上這些新函式："

msgid ""
"Then we change the ``load_api()`` function in ``api.c`` to grab these new "
"functions:"
msgstr "然後在 ``api.c`` 裡修改 ``load_api()`` 函式，把這些新函式指標抓出來："

msgid ""
"Now we can go back to ``gdexample.c`` and define the new functions, without "
"forgetting to include the ``api.h`` header:"
msgstr ""
"現在可以回到 ``gdexample.c``，實作這些新函式，記得要引入 ``api.h`` 標頭檔："

msgid ""
"When instantiating an object, first we create a new Sprite2D object, since "
"that's the parent of our class. Then we allocate memory for our custom "
"struct and call its constructor. We save the pointer to the Godot object in "
"the struct as well like we mentioned earlier."
msgstr ""
"建立物件時，首先會建立一個新的 Sprite2D 物件（我們類別的父類別）。然後配置自"
"訂 struct 的記憶體，呼叫建構子，並將 Godot 物件指標存進 struct（如前所述）。"

msgid ""
"Then we set our custom struct as the instance data. This will make Godot "
"know that the object is an instance of our custom class and properly call "
"our custom methods for instance, as well as passing this data back."
msgstr ""
"接著將我們自訂 struct 綁定為實例資料。這樣 Godot 就能知道這個物件是自訂類別的"
"實例，才會正確呼叫我們的自訂方法，並且回傳這些資料。"

msgid "Note that we return the Godot object we created, not our custom struct."
msgstr "請注意，這裡回傳的是我們建立的 Godot 物件，而不是自訂 struct。"

msgid ""
"For the ``gdextension_free_instance()`` function, we only call the "
"destructor and free the memory we allocated for the custom data. It is not "
"necessary to destruct the Godot object since that will be taken care of by "
"the engine itself."
msgstr ""
"至於 ``gdextension_free_instance()``，只需呼叫解構子並釋放我們自訂資料配置的"
"記憶體。Godot 物件本身不需我們解構，這會由引擎自動處理。"

msgid "A demo project"
msgstr "範例專案"

msgid ""
"Now that we can create and free our custom object, we should be able to try "
"it out in an actual project. For this, you need to open Godot and create a "
"new project on the ``demo`` folder. The project manager may warn you the "
"folder isn't empty if you have compiled the extension before, you can safely "
"ignore this warning this time."
msgstr ""
"現在我們已經能建立和釋放自訂物件，該來實際測試了。請打開 Godot 並在 ``demo`` "
"資料夾中建立一個新專案。如果你之前已經編譯過擴充元件，專案管理員可能會警告資"
"料夾非空，這次可以放心無視這個警告。"

msgid ""
"If you didn't compile the extension yet, it is the time to do it now. To do "
"that, open a terminal or command prompt, navigate to the root folder of the "
"extension and run ``scons``. It should compile quickly since the extension "
"is very simple."
msgstr ""
"如果你還沒編譯這個擴充元件，現在就該編譯了。打開終端機（或命令提示字元），切"
"換到擴充元件的根目錄，執行 ``scons``。這個擴充很簡單，應該會很快編譯完畢。"

msgid ""
"Then, create a file called ``gdexample.gdextension`` inside the ``demo`` "
"folder. This is a Godot resource that describes the extension, allowing the "
"engine to properly load it. Put the following content in this file:"
msgstr ""
"然後，在 ``demo`` 資料夾中建立 ``gdexample.gdextension`` 檔案。這是一個 "
"Godot 資源檔，用來描述這個擴充元件，讓引擎能正確載入它。內容如下："

msgid ""
"As you can see, ``gdexample_library_init()`` is the same name of the "
"function we defined in our ``init.c`` file. It is important that the names "
"match because it is how Godot calls the entry point of the extension."
msgstr ""
"可以看到 ``gdexample_library_init()`` 就是我們在 ``init.c`` 定義的函式名稱。"
"這兩者必須完全相同，因為 Godot 就是靠這個名稱來呼叫擴充元件的進入點。"

msgid ""
"We also set the compatibility minimum to 4.2, since we are targeting this "
"version. It should still work on later versions. If you are using a later "
"Godot version and rely on the new features, you need to increase this value "
"to a version number that has everything you use. "
"See :ref:`doc_what_is_gdextension_version_compatibility` for more "
"information."
msgstr ""
"我們同時將相容性最低版本設為 4.2，因為本範例是以此版本為目標。之後的 Godot 版"
"本也應該能運作。如果你將來用到新版 Godot 的新功能，記得要把這個值設成相對應的"
"版本。更多資訊可參考 :ref:`doc_what_is_gdextension_version_compatibility`。"

msgid ""
"In the ``[libraries]`` section we set up the paths to the shared library on "
"different platforms. Here there's only the debug versions since that's what "
"we are working on for the example. Using :ref:`feature tags "
"<doc_feature_tags>` you can fine tune this to also provide release versions, "
"add more target operating systems, as well as providing 32-bit and 64-bit "
"binaries."
msgstr ""
"在 ``[libraries]`` 區段中，我們設定了不同平台下共用函式庫的路徑。這裡只有除錯"
"版本，因為本範例是針對除錯用途。你可以用 :ref:`feature tags "
"<doc_feature_tags>` 來細分設定，例如提供釋出版本、加入更多目標作業系統，或同"
"時提供 32 位元和 64 位元執行檔。"

msgid ""
"You can also add library dependencies and custom icons for your classes in "
"this file, but this is out of the scope for this tutorial."
msgstr ""
"你也可以在這個檔案中加入函式庫相依性和自訂類別圖示，不過這部分不屬於本教學範"
"圍。"

msgid ""
"After saving the file, go back to the editor. Godot should automatically "
"load the extension. Nothing will be seen because our extension only "
"registers a new class. To use this class add a ``Node2D`` as a root of the "
"scene. Move it to the middle of viewport for better visibility. Then add a "
"new child node to the root and in the **Create New Node** dialog search for "
"\"GDExample\", the name of our class, as it should be listed there. If it "
"isn't, it means that Godot didn't load the extension properly, so try "
"restarting the editor and retrace the steps to see if anything went missing."
msgstr ""
"存檔後回到 Godot 編輯器，擴充元件應會自動載入。目前不會看到什麼變化，因為擴充"
"元件只註冊了一個新類別。要使用這個類別，請在場景中加一個 ``Node2D`` 當根節點"
"（建議移到檢視區中央），再新增子節點。在「建立新節點」對話框搜尋 "
"\"GDExample\"（就是我們的類別名稱），應該會看到它出現在清單中。如果沒看到，代"
"表 Godot 沒有正確載入擴充元件，可以考慮重啟編輯器，並檢查前述步驟是否有遺漏。"

msgid ""
"Our custom class is derived from ``Sprite2D``, so it has a **Texture** "
"property in the Inspector. Set this to the ``icon.svg`` file that Godot "
"handily created for us when making the project. Save this scene as "
"``main.tscn`` and run it. You may want to set it as the main scene for "
"convenience."
msgstr ""
"我們的自訂類別是從 ``Sprite2D`` 繼承的，因此在屬性面板會有 **Texture** 屬性。"
"請把它指向專案建立時 Godot 自動產生的 ``icon.svg``。將這個場景存成 "
"``main.tscn``，然後執行。也可以順便設為主場景，方便測試。"

msgid ""
"Voilà! We have a custom node running in Godot. However, it does not do "
"anything and has nothing different than a regular ``Sprite2D`` node. We will "
"fix that next by adding custom methods and properties."
msgstr ""
"完成！我們已經讓自訂節點在 Godot 執行起來了。不過現在它還沒有任何行為，與一"
"般 ``Sprite2D`` 節點沒什麼差別。接下來我們會加入自訂方法與屬性，讓它能做些事"
"情。"

msgid "Custom methods"
msgstr "自訂方法"

msgid ""
"A common thing in extensions is creating methods for the custom classes and "
"exposing those to the Godot API. We are going to create a couple of getters "
"and setters which are need for binding the properties afterwards."
msgstr ""
"在擴充元件中很常見的事情就是為自訂類別建立方法，並將這些方法公開給 Godot "
"API。我們會先建立一組 getter 和 setter，這樣之後才能把屬性綁定到這些方法。"

msgid ""
"First, let's add the new fields in our struct to hold the values for "
"``amplitude`` and ``speed``, which we will use later on when creating the "
"behavior for the node. Add them to the ``gdexample.h`` file, changing the "
"``GDExample`` struct:"
msgstr ""
"首先，請在 struct 裡加上新的欄位來保存 ``amplitude`` 和 ``speed`` 的值，我們"
"之後要讓節點有行為時會用到。請修改 ``gdexample.h``，在 ``GDExample`` struct "
"裡加這些欄位："

msgid ""
"In the same file, add the declaration for the getters and setters, right "
"after the destructor."
msgstr "同一個檔案裡，在解構子之後，宣告這些 getter 和 setter。"

msgid ""
"To make those simple functions work when called by Godot, we will need some "
"wrappers to help us properly convert the data to and from the engine."
msgstr ""
"為了讓 Godot 呼叫這些簡單函式時能正常運作，我們還需要一些包裝器來協助我們正確"
"地和引擎之間轉換資料。"

msgid ""
"First, we will create wrappers for ``ptrcall``. This is what Godot uses when "
"the types of the values are known to be exact, which avoids using Variant. "
"We're gonna need two of those: one for the functions that take no arguments "
"and return a ``double`` (for the getters) and another for the functions that "
"take a single ``double`` argument and return nothing (for the setters)."
msgstr ""
"首先，我們要為 ``ptrcall`` 建立包裝器。Godot 在已知型別完全符合時會使用 "
"ptrcall（不需用 Variant）。我們會需要兩種包裝器：一種是沒參數、回傳 "
"``double``（給 getter 用），另一種是接收一個 ``double`` 參數且不回傳值（給 "
"setter 用）。"

msgid "Add the declarations to the ``api.h`` file:"
msgstr "請在 ``api.h`` 檔案中宣告這些包裝函式："

msgid ""
"Those two functions follow the ``GDExtensionClassMethodPtrCall`` type, as "
"defined in the ``gdextension_interface.h``. We use ``float`` as a name here "
"because in Godot the ``float`` type has double precision, so we keep this "
"convention."
msgstr ""
"這兩個函式都符合 ``gdextension_interface.h`` 裡定義的 "
"``GDExtensionClassMethodPtrCall`` 型別。這裡用 ``float`` 當名稱，是因為在 "
"Godot 中 float 實際上是 double 精度，所以我們沿用這個慣例。"

msgid "Then we implement those functions in the ``api.c`` file:"
msgstr "然後在 ``api.c`` 檔案中實作這些函式："

msgid ""
"The ``method_userdata`` argument is a custom value that we give to Godot, in "
"this case we will set as the function pointer for the one we want to call. "
"So first we convert it to the function type, then we just call it by passing "
"the arguments when needed, or setting the return value."
msgstr ""
"``method_userdata`` 參數是我們給 Godot 的自訂值，這裡我們會傳入要呼叫的函式指"
"標。因此會先轉型成正確函式型別，再傳入參數執行，最後設回傳值。"

msgid ""
"The ``p_instance`` argument contains the custom instance of our class, which "
"we gave with ``object_set_instance()`` when creating the object."
msgstr ""
"``p_instance`` 參數就是我們自訂類別的實例，是在建立物件時用 "
"``object_set_instance()`` 綁定進去的。"

msgid ""
"``p_args`` is an array of arguments. Note this contains **pointers** to the "
"values. That's why we dereference it when passing to our functions. The "
"number of arguments will be declared when binding the function (which we "
"will do soon) and it will always include default ones if those exist."
msgstr ""
"``p_args`` 是參數陣列。請注意它存的是「值的指標」。所以在傳給我們的函式時會解"
"參考。參數數量會在綁定方法時指定（我們很快會做），如果有預設參數也會包含在"
"內。"

msgid ""
"Finally, the ``r_ret`` is a pointer to the variable where the return value "
"needs to be set. Like the arguments, it will be the correct type as "
"declared. For the function that does not return, we have to avoid setting it."
msgstr ""
"最後，``r_ret`` 是回傳值的指標，跟參數一樣會是正確的型別。如果函式沒回傳值，"
"就不能設定它。"

msgid ""
"Note how the type and argument counts are exact, so if we needed different "
"types, for example, we would have to create more wrappers. This could be "
"automated using some code generation, but this is out of the scope for this "
"tutorial."
msgstr ""
"注意這裡型別和參數數量都是完全固定的。如果要支援其他型別或參數數量，還得建立"
"更多包裝器。這也可以用程式碼產生器自動化，不過這不在本教學範圍內。"

msgid ""
"While the ``ptrcall`` functions are used when types are exact, sometimes "
"Godot cannot know if that's the case (when the call comes from a dynamically "
"typed language, such as GDScript). In those situations it uses regular "
"``call`` functions, so we need to provide those as well when binding."
msgstr ""
"雖然 ``ptrcall`` 適用於型別完全精確的情境，但有時 Godot 不一定知道型別（比如"
"從 GDScript 等動態語言呼叫），這時就會用一般的 ``call``。所以綁定時我們還是必"
"須提供這類包裝器。"

msgid "Let's create two new wrappers in the ``api.h`` file:"
msgstr "請在 ``api.h`` 裡再宣告兩個包裝器："

msgid ""
"These follow the ``GDExtensionClassMethodCall`` type, which is a bit "
"different. First, you receive pointers to Variants instead of exact types. "
"There's also the amount of arguments and an error struct that you can set if "
"something goes wrong."
msgstr ""
"這兩個包裝器型別是 ``GDExtensionClassMethodCall``，跟前面略有不同。它接收的"
"是 Variant 指標（不是精確型別），還會收到參數數量與一個錯誤結構，讓你在有錯誤"
"時能設回去。"

msgid ""
"In order to check the type and also extract interact with Variant, we will "
"need a few more functions from the GDExtension API. So let's expand our "
"wrapper structs:"
msgstr ""
"為了檢查型別、與 Variant 互動，我們還需要幾個 GDExtension API 的函式。因此要"
"擴充我們的包裝 struct："

msgid ""
"The names say all about what those do. We have a couple of constructors to "
"create and extract a floating point value to and from a Variant. We also "
"have a couple of helpers to actually get those constructors, as well as a "
"function to find out the type of a Variant."
msgstr ""
"這些成員的名稱就說明了一切。有幾個是建立、取得浮點數 Variant 的建構子，還有一"
"些輔助函式能取得這些建構子，以及能查詢 Variant 型別的函式。"

msgid ""
"Let's get those from the API, like we did before, by changing the "
"``load_api()`` function in the ``api.c`` file:"
msgstr "跟之前一樣，請在 ``api.c`` 的 ``load_api()`` 裡把這些函式指標抓出來："

msgid ""
"Now that we have these set, we can implement our call wrappers in the same "
"file:"
msgstr "現在我們有了這些函式指標，就能在同一個檔案中實作 call 包裝器："

msgid ""
"These functions are a bit longer but easy to follow. First they check if the "
"argument count is as expected and if not they set the error struct and "
"return. For the one that has one parameter, it also checks if the argument "
"type is correct. This is important because mismatched types when extracting "
"from Variant can cause crashes."
msgstr ""
"這些包裝函式雖然比較長，但很容易理解。首先會檢查參數數量對不對，不對就設錯誤"
"結構然後 return。有一個參數的那個還會檢查型別對不對，這很重要，因為 Variant "
"型別不對時取值會導致崩潰。"

msgid ""
"Then it proceeds to extract the argument using the constructor we setup "
"before. The one with no arguments instead sets the return value after "
"calling the function. Note how they use a pointer to a ``double`` variable, "
"since this is what those constructors expect."
msgstr ""
"之後會用先前設好的建構子把參數取出來。沒參數的那個則是在呼叫函式後設回傳值。"
"注意他們用的是 ``double`` 指標，因為建構子就是吃這種型別。"

msgid ""
"Before we can actually bind our methods, we need a way to create "
"``GDExtensionPropertyInfo`` instances. While we could do them inside the "
"binding functions that we'll implement afterwards, it's easier to have a "
"helper for it since we'll need it multiple times, including for when we bind "
"properties."
msgstr ""
"在實際綁定方法前，我們需要一個能建立 ``GDExtensionPropertyInfo`` 物件的方法。"
"雖然可以直接在綁定函式裡寫，但我們會重複多次，還會用來綁定屬性，所以最好先做"
"一個輔助函式。"

msgid "Let's create these two functions in the ``api.h`` file:"
msgstr "請在 ``api.h`` 檔案中加入這兩個輔助函式："

msgid ""
"The first one is a simplified version of the second since we usually don't "
"need all the arguments for the property and are okay with the defaults. Then "
"we also have a function to destruct the PropertyInfo since we need to create "
"Strings and StringNames that need to be properly disposed of."
msgstr ""
"第一個函式是第二個的簡化版，通常我們不需要填所有屬性參數，用預設值就好。我們"
"還有個解構 PropertyInfo 的函式，因為我們要建立 String 和 StringName，這些都記"
"得要正確釋放。"

msgid ""
"Speaking of which, we also need a way to create and destruct Strings, so "
"we'll make an addition to existing structs in this same file. We'll also get "
"a new API function for actually binding our custom method."
msgstr ""
"說到這裡，我們還需要建立和釋放 String 的方式，所以會再擴充目前這個 struct，並"
"加入一個新的 API 函式來真正綁定我們的自訂方法。"

msgid ""
"Before implementing those, let's do a quick stop in the ``defs.h`` file and "
"include the size of the ``String`` type and a couple of enums:"
msgstr ""
"在實作前，我們先回頭到 ``defs.h``，把 ``String`` 型別的大小和幾個列舉值加進"
"去："

msgid ""
"While it's the same size as ``StringName``, it is more clear to use a "
"different name for it."
msgstr "雖然大小和 ``StringName`` 一樣，但用不同名稱更清楚。"

msgid ""
"The enums here are just helpers to give names to the numbers they represent. "
"The information about them is present in the ``extension_api.json`` file. "
"Here we just set up the ones we need for the tutorial, to keep it more "
"concise."
msgstr ""
"這裡的 enum 只是給數字一個有意義的名字。相關資訊可在 ``extension_api.json`` "
"找到。這裡只放本教學需要用到的值，讓內容精簡一點。"

msgid ""
"Going now to the ``api.c``, we need to load the pointers to the new "
"functions we added to the API."
msgstr "現在回到 ``api.c``，我們要載入剛剛加進去的新 API 函式指標。"

msgid ""
"Then we can also implement the functions to create the ``PropertyInfo`` "
"struct."
msgstr "接著我們可以實作建立 ``PropertyInfo`` struct 的函式。"

msgid ""
"The simple version of ``make_property()`` just calls the more complete one "
"with a some default arguments. What those values mean exactly is out of the "
"scope of this tutorial, check the page about the :ref:`Object class "
"<doc_object_class>` for more details about binding methods and properties."
msgstr ""
"簡易版的 ``make_property()`` 只是用一些預設值呼叫完整版本。這些值的意義超出本"
"教學範圍，詳細請見 :ref:`Object 類別 <doc_object_class>` 介紹方法與屬性綁定的"
"頁面。"

msgid ""
"The complete version is more involved. First, it creates ``String``'s and "
"``StringName``'s for the needed fields, by allocating memory and calling "
"their constructors. Then it creates a ``GDExtensionPropertyInfo`` struct and "
"sets all the fields with the arguments provided. Finally it returns this "
"created struct."
msgstr ""
"完整版本內容會多一點。首先會分別建立 ``String`` 和 ``StringName``，配置記憶體"
"並呼叫建構子。然後建立 ``GDExtensionPropertyInfo`` struct，設好所有欄位，最後"
"回傳這個 struct。"

msgid ""
"The ``destruct_property()`` function is straightforward, it simply calls the "
"destructors for the created objects and frees their allocated memory."
msgstr ""
"``destruct_property()`` 很單純，就是呼叫之前建立的物件解構子並釋放記憶體。"

msgid ""
"Let's go back again to the header ``api.h`` to create the functions that "
"will actually bind the methods:"
msgstr "現在再回到 ``api.h``，來加上實際綁定方法所需的函式："

msgid "Then switch back to the ``api.c`` file to implement these:"
msgstr "接著回到 ``api.c`` 檔案實作這些函式："

msgid ""
"Both functions are very similar. First, they create a ``StringName`` with "
"the method name. This is created in the stack since we don't need to keep it "
"after the function ends. Then they create local variables to hold the "
"``call_func`` and ``ptrcall_func``, pointing to the helper functions we "
"defined earlier."
msgstr ""
"這兩個函式很類似。首先會用方法名稱建立一個 ``StringName``（因為函式結束後不需"
"要保留，所以放在堆疊即可）。接著建立本地變數來保存 ``call_func`` 和 "
"``ptrcall_func``，指向我們剛剛定義的輔助函式。"

msgid ""
"In the next step they diverge a bit. The first one creates a property for "
"the return value, which has an empty name since it's not needed. The other "
"creates an array of properties for the arguments, which in this case has a "
"single element. This one also has an array of metadata, which can be used if "
"there's something special about the argument (e.g. if an ``int`` value is 32 "
"bits long instead of the default of 64 bits)."
msgstr ""
"接下來兩者稍有不同。第一個會為回傳值建立一個屬性（名稱留空，因為用不到）。另"
"一個則為參數建立屬性陣列（這裡只有一個元素）。這裡還有一個中繼資料陣列，如果"
"參數有特殊需求（例如 int 是 32 位元而不是預設的 64 位元）可以用到。"

msgid ""
"Afterwards, they create the ``GDExtensionClassMethodInfo`` with the required "
"fields for each case. Then they make a ``StringName`` for the class name, in "
"order to associate the method with the class. Next, they call the API "
"function to actually bind this method to the class. Finally, we destruct the "
"objects we created since they aren't needed anymore."
msgstr ""
"然後會根據每種情境建立 ``GDExtensionClassMethodInfo``，再建立類別名稱的 "
"``StringName``，將方法與類別關聯起來。接著用 API 函式把這個方法綁定到類別。最"
"後把所有建立的物件解構掉，避免記憶體洩漏。"

msgid ""
"The bind helpers here use the call helpers we created earlier, so do note "
"that those call helpers only accept the Godot ``FLOAT`` type (which is "
"equivalent to ``double`` in C). If you intend to use this for other types, "
"you would need to check the type of the arguments and return type and select "
"an appropriate function callback. This is avoided here only to keep the "
"example from becoming even longer."
msgstr ""
"這些綁定輔助函式用的是我們前面寫的 call 輔助函式，所以只能接受 Godot 的 "
"``FLOAT`` 型別（在 C 裡等於 double）。如果你要支援其他型別，必須檢查參數與回"
"傳型別再挑對應的 callback。這裡沒做只是為了讓範例不要太冗長。"

msgid ""
"Now that we have the means to bind methods, we can actually do so in our "
"custom class. Go to the ``gdexample.c`` file and fill up the "
"``gdexample_class_bind_methods()`` function:"
msgstr ""
"現在有了綁定方法的機制，我們可以在自訂類別中真正把方法綁定起來。請在 "
"``gdexample.c`` 裡把 ``gdexample_class_bind_methods()`` 函式補齊："

msgid ""
"Since this function is already being called by the initialization process, "
"we can stop here. This function is much more straightforward after we "
"created all the infrastructure to make this work. You can see that "
"implementing the binding functions inline here would take some space and "
"also be quite repetitive. This also makes it easier to add another method in "
"the future."
msgstr ""
"這個函式已經在初始化流程中被呼叫，所以這裡就可以先告一段落。有了前面的基礎建"
"設，這個函式就變得非常直覺。你可以發現如果直接在這裡寫所有綁定程式會很冗長，"
"也很難維護。用這種方式，未來要再加新方法也會方便許多。"

msgid ""
"If you compile the code and reopen the demo project, nothing will be "
"different at first, since we only added two new methods. To ensure those are "
"registered properly, you can search for ``GDExample`` in the editor help and "
"verify they are present in the documentation page."
msgstr ""
"現在編譯後重開範例專案，表面上看不出差異，因為只是多了兩個方法。你可以在編輯"
"器的說明搜尋 ``GDExample``，確認它們確實有被註冊到說明頁面裡。"

msgid "Custom properties"
msgstr "自訂屬性"

msgid ""
"Since we now have the getter and setter for our properties already bound, we "
"can move forward to create actual properties that will be displayed in the "
"Godot editor inspector."
msgstr ""
"現在我們已經有 getter 和 setter 綁定好，可以繼續建立真正的屬性，讓它們顯示在 "
"Godot 編輯器的屬性面板。"

msgid ""
"Given our extensive setup in the previous section, there are only a few "
"things needed to enable us to bind properties. First, let's get a new API "
"function in the ``api.h`` file:"
msgstr ""
"由於前面已經做了大量準備，現在只要做幾件小事就能綁定屬性了。首先，請在 "
"``api.h`` 加入一個新的 API 函式："

msgid "Let's also declare a function here to bind properties:"
msgstr "同時在這裡宣告一個綁定屬性的函式："

msgid "In the ``api.c`` file, we can load the new API function:"
msgstr "在 ``api.c`` 檔案中載入這個新的 API 函式指標："

msgid "Then we can implement our new helper function in this same file:"
msgstr "然後在同一個檔案裡實作我們的新輔助函式："

msgid ""
"This function is similar to the one for binding methods. The main difference "
"is that we don't need an extra struct since we can simply use the "
"``GDExtensionPropertyInfo`` that is created by our helper function, so it's "
"more straightforward. It only creates the ``StringName`` values from the C "
"strings, creates a property info struct using our helper, calls the API "
"function to register the property in the class and then destructs all the "
"objects we created."
msgstr ""
"這個函式和綁定方法的函式類似，主要差別是不用額外的 struct，只要直接用我們輔助"
"函式建立的 ``GDExtensionPropertyInfo`` 就好，非常直覺。它會用 C 字串建立 "
"``StringName``，用輔助函式產生屬性資訊 struct，再呼叫 API 函式將屬性註冊到類"
"別裡，最後把所有建立的物件都釋放掉。"

msgid ""
"With this done, we can extend the ``gdexample_class_bind_methods()`` "
"function in the ``gdexample.c`` file:"
msgstr ""
"完成這個步驟後，我們可以到 ``gdexample.c`` 檔案裡擴充 "
"``gdexample_class_bind_methods()`` 函式："

msgid ""
"If you build the extension with ``scons``, you'll see in the Godot editor "
"the new property shown not only on the documentation page for the custom "
"class but also in the Inspector dock when the ``GDExample`` node is selected."
msgstr ""
"用 ``scons`` 重新編譯擴充元件後，你會發現 Godot 編輯器除了說明文件頁有新屬性"
"外，只要選擇 ``GDExample`` 節點，Inspector 側邊欄裡也會出現對應的屬性。"

msgid "Binding virtual methods"
msgstr "綁定虛擬方法"

msgid ""
"Our custom node now has properties to influence how it operates, but it "
"still doesn't do anything. In this section, we will bind the virtual "
"method :ref:`_process() <class_Node_private_method__process>` and make our "
"custom sprite move a little bit."
msgstr ""
"我們的自訂節點現在有了可調整行為的屬性，但還沒實際做什麼事情。這一節我們要綁"
"定虛擬方法 :ref:`_process() <class_Node_private_method__process>`，讓自訂精靈"
"可以開始動起來。"

msgid ""
"In the ``gdexample.h`` file, let's add a function that represents the custom "
"``_process()`` method:"
msgstr ""
"請在 ``gdexample.h`` 檔案裡新增一個代表自訂 ``_process()`` 方法的函式宣告："

msgid ""
"We'll also add a \"private\" field to keep track of the time passed in our "
"custom struct. This is \"private\" only in the sense that it won't be bound "
"to the Godot API, even though it is public in the C side, given the language "
"lacks access modifiers."
msgstr ""
"我們也會在自訂 struct 裡加一個「private」欄位來記錄經過的時間。這裡所謂"
"「private」只是指它不會被綁定到 Godot API，實際上在 C 裡還是 public，因為 C "
"沒有存取修飾子。"

msgid ""
"On the counterpart source file ``gdexample.c`` we need to initialize the new "
"field in the constructor:"
msgstr "在 ``gdexample.c`` 裡的建構子要初始化這個新欄位："

msgid ""
"Then we can create the simplest implementation for the ``_process`` method:"
msgstr "然後可以先寫一個最簡單版的 ``_process`` 方法實作："

msgid ""
"For now it will do nothing but update the private field we created. We'll "
"come back to this after the method is properly bound."
msgstr ""
"這裡暫時只會更新剛剛那個記錄時間的欄位。等方法綁定好後再回來補上真正的行為。"

msgid ""
"Virtual methods are a bit different from the regular bindings. Instead of "
"explicitly registering the method itself, we'll register a special function "
"that Godot will call to ask if a particular virtual method is implemented in "
"our extension. The engine will pass a ``StringName`` as an argument so, "
"following the spirit of this tutorial, we'll create a helper function to "
"check if it is equal to a C string."
msgstr ""
"虛擬方法的綁定方式和一般方法有些不同。我們不是直接註冊這個方法本身，而是註冊"
"一個特殊函式，Godot 會呼叫它來詢問我們的擴充有沒有實作某個虛擬方法。引擎會傳"
"一個 ``StringName`` 進來，所以下面我們會寫一個輔助函式來判斷它和某個 C 字串是"
"否相等。"

msgid "Let's add the declaration to the ``api.h`` file:"
msgstr "請在 ``api.h`` 檔案中宣告這個輔助函式："

msgid ""
"We'll also add a new struct to this file, to hold function pointers for "
"custom operators:"
msgstr "同時在這個檔案裡加一個新 struct，用來保存自訂運算子的函式指標："

msgid ""
"Then in the ``api.c`` file we'll load the function pointer from the API:"
msgstr "然後在 ``api.c`` 裡從 API 載入這個函式指標："

msgid ""
"As you can see we need a new local helper here in order to grab the function "
"pointer for the operator."
msgstr "如你所見，這裡我們會需要一個新的本地輔助函式來抓這個運算子的函式指標。"

msgid ""
"With this handy, we can easily create our comparison function in the same "
"file:"
msgstr "有了這些準備，我們可以在同一個檔案裡實作這個比較用的輔助函式："

msgid ""
"This function creates a ``StringName`` from the argument, compares with the "
"other one using the operator function pointer, and returns the result. Note "
"that the return value for the operator is passed as an out reference, this "
"is a common thing in the API."
msgstr ""
"這個函式會用傳進來的字串建立一個 ``StringName``，然後用運算子函式指標和目標做"
"比較，最後回傳結果。注意這個運算子的回傳值是 out 參數，這在 API 很常見。"

msgid ""
"Let's go back to the ``gdexample.h`` file and add a couple of functions that "
"will be used as the callbacks for the Godot API:"
msgstr ""
"現在回到 ``gdexample.h``，加上兩個要給 Godot API 用的 callback 函式宣告："

msgid ""
"There are actually two ways of registering virtual methods. Only one has the "
"``get`` part, in which you give Godot a properly crafted function pointer "
"which will be called. For this we would need to create another helper for "
"each virtual method, something that is not very convenient. Instead, we use "
"the second method which allows us to return any data, and then Godot will "
"call a second callback and give us back this data along with the call "
"information. We can simply give our own function pointer as custom data and "
"then have a single callback for all virtual methods. Although in this "
"example we will only use it for one method, this way is simpler to expand."
msgstr ""
"其實註冊虛擬方法有兩種方式。只有一種有 ``get`` 部分，就是你直接給 Godot 一個"
"函式指標，Godot 會直接呼叫它。這樣每個虛擬方法都要一個輔助函式，不太方便。我"
"們這裡用第二種方式，可以回傳任意資料，Godot 會再呼叫另一個 callback 並回傳這"
"份資料與呼叫資訊。我們只要把自訂函式指標當作 custom data 傳進去，所有虛擬方法"
"都只要一個 callback 就能搞定。雖然這個範例只用到一個方法，但這種寫法未來要擴"
"充會輕鬆許多。"

msgid "So let's implement those two functions in the ``gdexample.c`` file:"
msgstr "所以現在就到 ``gdexample.c`` 裡實作這兩個函式："

msgid ""
"Those functions are also quite straightforward after making all the helpers "
"previously."
msgstr "有了前面的輔助函式，這兩個函式的實作就很直觀了。"

msgid ""
"For the first one, we simply check if the function name requested is "
"``_process`` and if it is we return a function pointer to our implementation "
"of it. Otherwise we return ``NULL``, signaling that the method is not being "
"overridden. We don't use the ``p_class_userdata`` here since this function "
"is meant only for one class and we don't have any data associated with it."
msgstr ""
"第一個 callback 只要檢查 function name 是不是 ``_process``，是的話就回傳我們"
"實作的函式指標，否則回傳 ``NULL``，代表這個方法沒被覆寫。這裡不會用到 "
"``p_class_userdata``，因為這個方法只針對一個類別，也沒有額外的資料。"

msgid ""
"The second one is similar. If it is the ``_process()`` method, it uses the "
"given function pointer to call the ``ptrcall`` helper, passing the call "
"arguments forward. Otherwise it simply does nothing, since we don't have any "
"other virtual methods being implemented."
msgstr ""
"第二個 callback 也很類似。如果是 ``_process()``，就用傳進來的函式指標呼叫 "
"``ptrcall`` 輔助函式並把參數傳下去，否則什麼都不做，因為我們沒實作其他虛擬方"
"法。"

msgid ""
"The only thing missing is using those callbacks when the class is "
"registered. Go to the ``init.c`` file and change the ``class_info`` "
"initialization to include those, replacing the ``NULL`` value used "
"previously:"
msgstr ""
"剩下唯一沒做的就是在註冊類別時把這些 callback 綁上。請到 ``init.c`` 裡，把 "
"``class_info`` 初始化時的 ``NULL`` 改成這些 callback："

msgid ""
"This is enough to bind the virtual method. If you build the extension and "
"run the demo project again, the ``_process()`` function will be called. You "
"just won't be able to tell since the function itself does nothing visible. "
"We will solve this now by making the custom node move following a pattern."
msgstr ""
"這樣就已經綁定好虛擬方法了。重新編譯並執行範例專案，``_process()`` 就會被呼"
"叫。雖然目前還看不出變化，因為這個函式什麼都沒做，接下來我們會讓自訂節點依一"
"定規律移動，讓效果看得見。"

msgid ""
"In order to make our node do stuff, we'll need to call Godot methods. Not "
"only the GDExtension API functions as we've being doing so far, but actual "
"engine methods, as we would do with scripting. This naturally requires some "
"extra setup."
msgstr ""
"要讓節點開始有動作，我們需要呼叫 Godot 的方法。不只是呼叫 GDExtension API，而"
"是像腳本一樣呼叫引擎內建的方法。這就需要額外做些準備。"

msgid ""
"First, let's add :ref:`class_Vector2` to our ``defs.h`` file, so we can use "
"it in our method:"
msgstr ""
"首先，請在 ``defs.h`` 檔案中加入 :ref:`class_Vector2` 的型別，這樣我們在方法"
"裡才能用它："

msgid ""
"The ``REAL_T_IS_DOUBLE`` define is only needed if your Godot version was "
"built with double precision support, which is not the default."
msgstr ""
"``REAL_T_IS_DOUBLE`` 這個 define 只有你用雙精度編譯 Godot 時才需要，一般預設"
"不需要。"

msgid ""
"Now, in the ``api.h`` file, we'll add few things to the API structs, "
"including a new one for holding engine methods to call."
msgstr ""
"現在請到 ``api.h`` 檔案，在 API struct 裡加一些欄位，包括一個新的 struct 來保"
"存要呼叫的引擎方法。"

msgid ""
"Then in the ``api.c`` file we can grab the function pointers from Godot:"
msgstr "然後在 ``api.c`` 裡抓取這些 Godot 的函式指標："

msgid ""
"The only noteworthy part here is the ``Vector2`` constructor, for which we "
"request the index ``3``. Since there are multiple constructors with "
"different kinds of arguments, we need to specify which one we want. In this "
"case we're getting the one that takes two float numbers as the ``x`` and "
"``y`` coordinates, hence the name. This index can be retrieved from the "
"``extension_api.json`` file. Note we also need a new local helper to get it."
msgstr ""
"這裡值得注意的是 ``Vector2`` 的建構子，我們請求 index ``3``。因為有多個不同參"
"數的建構子，必須指定要哪一個。這個 index 代表吃兩個 float（x,y）參數的建構"
"子。這個 index 可以從 ``extension_api.json`` 找到。也別忘了要寫一個新的本地輔"
"助函式來抓取。"

msgid ""
"Be aware that we don't get anything for the methods struct here. This is "
"because this function is called too early in the initialization process, so "
"classes won't be properly registered yet."
msgstr ""
"請注意這裡我們還沒取得 methods struct，因為這個函式在初始化流程太早呼叫，這時"
"類別還沒註冊完成。"

msgid ""
"Instead, we're gonna use the initialization level callback to grab those "
"when we are registering our custom class. Add this to the ``init.c`` file:"
msgstr ""
"因此我們會利用初始化等級的 callback，在註冊自訂類別時再抓這些資料。請在 "
"``init.c`` 加入這段："

msgid ""
"Here we create ``StringName``'s for the class and method we want to get, "
"then use the GDExtension API to retrieve their ``MethodBind``, which is an "
"object that represents the bound method. We get the ``set_position`` method "
"from ``Node2D`` since this is where it was registered, even though we're "
"going to use it in a ``Sprite2D``, a derived class."
msgstr ""
"這裡我們會分別為想要取得的類別和方法建立 ``StringName``，然後用 GDExtension "
"API 取得他們的 ``MethodBind``，這個物件代表一個已綁定的方法。我們要取得的是 "
"``Node2D`` 的 ``set_position`` 方法，雖然我們用的是 ``Sprite2D``，但它繼承自 "
"``Node2D``。"

msgid ""
"The seemingly random number for getting the bind is actually a hash of the "
"method signature. This allows Godot to match the method you're requesting "
"even if in a future Godot version this signature changes, by providing a "
"compatibility method that matches what you're asking for. This is one of the "
"systems that allow the engine to load extensions made for previous versions. "
"You can get the value of this hash from the ``extension_api.json`` file."
msgstr ""
"看起來很隨機的那個數字其實是方法簽名的雜湊值。這樣即使未來 Godot 版本方法簽名"
"有變化，引擎還是能用相容性機制找到對應的方法。這也是 Godot 能載入舊版擴充元件"
"的原因之一。這個雜湊值可以從 ``extension_api.json`` 找到。"

msgid ""
"With all that, we can finally implement our custom ``_process()`` method in "
"the ``gdexample.c`` file:"
msgstr ""
"做好這些準備後，我們終於可以在 ``gdexample.c`` 裡實作自訂的 ``_process()`` 方"
"法："

msgid ""
"After updating the time passed scaled by the ``speed`` property, it creates "
"``x`` and ``y`` values based on that, also modulated by the ``amplitude`` "
"property. This is what will give the pattern effect. The ``math.h`` header "
"is needed for the ``sin()`` and ``cos()`` functions used here."
msgstr ""
"這裡會先用 ``speed`` 屬性更新累積時間，再用這個值算出 ``x`` 和 ``y``，同時根"
"據 ``amplitude`` 屬性調整，這樣就能產生移動路徑的效果。這裡會用到 ``sin()`` "
"和 ``cos()``，所以要引入 ``math.h`` 標頭檔。"

msgid ""
"Then it sets up an array of arguments to construct a ``Vector2``, followed "
"by calling the constructor. It sets up another array of arguments and use it "
"to call the ``set_position()`` method via the bind we acquired previously."
msgstr ""
"接著會先設一個參數陣列用來建立 ``Vector2``，呼叫建構子產生位置向量。然後再設"
"一個參數陣列，把這個向量傳進 ``set_position()``，透過先前取得的 bind 呼叫。"

msgid "Since nothing here allocates any memory, there's not a need to cleanup."
msgstr "這裡沒有配置任何記憶體，所以不用額外釋放。"

msgid ""
"Now we can build the extension again and reopen Godot. Even in the editor "
"you'll see the custom sprite moving."
msgstr "現在重新編譯擴充元件並重開 Godot，你會在編輯器裡看到自訂精靈一直在動。"

msgid ""
"Try changing the **Speed** and **Amplitude** properties and see how the "
"sprite react."
msgstr ""
"你可以試著調整 **Speed** 和 **Amplitude** 屬性，看看精靈的移動會有什麼變化。"

msgid "Registering and emitting a signal"
msgstr "註冊與發送訊號"

msgid ""
"To complete this tutorial, let's see how you can register a custom signal "
"and emit it when appropriate. As you might have guessed, we'll need a few "
"more function pointers from the API and more helper functions."
msgstr ""
"為了讓這份教學完整，我們來看看如何註冊自訂訊號並在適當時機發送它。如你所想，"
"這會需要 API 裡幾個新的函式指標，以及更多輔助函式。"

msgid ""
"In the ``api.h`` file we're adding two things. One is a an API function to "
"register a signal, the other is a helper function to wrap the signal binding."
msgstr ""
"在 ``api.h`` 檔案中要加兩樣東西：一個 API 函式用來註冊訊號，另一個輔助函式用"
"來包裝訊號綁定。"

msgid ""
"In this case we only have a version for one argument, since it's what we're "
"going to use."
msgstr "這裡我們只寫一個帶有一個參數的版本，因為這就是本範例需要用到的。"

msgid ""
"Moving to the ``api.c`` file, we can load this new function pointer and "
"implement the helper:"
msgstr "接著到 ``api.c``，載入這個新函式指標並實作輔助函式："

msgid ""
"This one is very similar to the function to bind methods. The main "
"difference is that we don't need to fill another struct, we just pass the "
"needed names and the array of arguments. The ``1`` at the end means the "
"amount of arguments the signal provides."
msgstr ""
"這個函式和綁定方法的輔助函式很像，主要差別是不用另外填 struct，只要傳入需要的"
"名稱和參數陣列即可。最後的 ``1`` 代表這個訊號有一個參數。"

msgid "With this we can bind the signal in ``gdexample.c``:"
msgstr "有了這個，就可以在 ``gdexample.c`` 綁定訊號："

msgid ""
"In order to emit a signal, we need to call the :ref:`emit_signal() "
"<class_Object_method_emit_signal>` method on our custom node. Since this is "
"a ``vararg`` function (meaning it takes any amount of arguments), we cannot "
"use ``ptrcall``. To do a regular call, we have to create Variants, which "
"require a few more steps of plumbing to get done."
msgstr ""
"要發送訊號時，需要在自訂節點上呼叫 :ref:`emit_signal() "
"<class_Object_method_emit_signal>` 方法。這個方法是 ``vararg``（可變參數），"
"所以不能用 ``ptrcall``。必須用一般 call，這就需要建立 Variant，而這又需要再做"
"幾個額外步驟。"

msgid "First, in the ``defs.h`` file we create a definition for Variant:"
msgstr "首先，在 ``defs.h`` 檔案裡加上 Variant 的定義："

msgid ""
"We first set the size of Variant together with the size of Vector2 that we "
"added before. Then we use it to create an opaque struct that is enough to "
"hold the Variant data. Again, we set the size for double precision builds as "
"a fallback, since by the official Godot builds use single precision."
msgstr ""
"我們會和 Vector2 一起設定 Variant 的大小，然後用它來建立一個足以儲存 Variant "
"資料的不透明 struct。同樣地，萬一是雙精度 Godot 也有設 fallback，但官方 "
"Godot 編譯預設都是單精度。"

msgid ""
"The ``emit_signal()`` function will be called with two arguments. The first "
"is the name of the signal to be emitted and the second is the argument we're "
"passing to the signal connections, which is a Vector2 as we declared when "
"binding it. So we're gonna create a helper function that can call a "
"MethodBind with these types. Even though it does return something (an error "
"code), we don't need to deal with it, so for now we're just going to ignore "
"it."
msgstr ""
"``emit_signal()`` 這邊會傳兩個參數：第一個是要發送的訊號名稱，第二個是訊號要"
"傳給連接者的參數（我們綁定時設的是 Vector2）。我們會寫一個輔助函式，可以用這"
"些型別呼叫 MethodBind。它其實有回傳值（錯誤碼），但這裡不需要處理，所以就先略"
"過。"

msgid ""
"In the ``api.h``, we're adding a few things to the existing structs, plus a "
"new helper function for the call:"
msgstr ""
"在 ``api.h``，我們要在現有的 struct 裡再加幾個欄位，並新增一個 call 用的輔助"
"函式："

msgid ""
"Now let's switch to the ``api.c`` file to load these new function pointers "
"and implement the helper function."
msgstr "現在到 ``api.c``，把這些新函式指標載入，然後實作輔助函式。"

msgid ""
"This helper function has some boilerplate code but is quite straightforward. "
"It sets up the two arguments inside stack allocated Variants, then creates "
"an array with pointers to those. It also sets up another Variant to keep the "
"return value, which we don't need to construct since the call expects it to "
"be uninitialized."
msgstr ""
"這個輔助函式有一些樣板程式碼，但很直覺。它會用堆疊記憶體建立兩個 Variant 存參"
"數，然後放進指標陣列。接著再設一個用來存回傳值的 Variant，這個不用初始化，因"
"為 call 會直接寫進去。"

msgid ""
"Then it actually calls the MethodBind using the instance we provided and the "
"arguments. The ``NULL`` at the end would be a pointer to a "
"``GDExtensionCallError`` struct. This can be used to treat potential errors "
"when calling the functions (such as wrong arguments). For the sake of "
"simplicity we're not gonna handle that here."
msgstr ""
"然後就用我們的 instance 和參數呼叫 MethodBind。最後的 ``NULL`` 本來應該給一"
"個 ``GDExtensionCallError`` 結構指標，可以用來處理呼叫錯誤（例如參數型別錯"
"誤）。但這裡為了簡單起見就不處理了。"

msgid ""
"At the end we need to destruct the Variants we created. While technically "
"the Vector2 one does not require destructing, it is clearer to cleanup "
"everything."
msgstr ""
"最後要把建立的 Variant 都釋放掉。嚴格說 Vector2 那個不需要釋放，但全部釋放會"
"比較清楚。"

msgid ""
"We also need to load the MethodBind, which we'll do in the ``init.c`` file, "
"right after loading the one for the ``set_position`` method we did before:"
msgstr ""
"還有要記得抓取 emit_signal 的 MethodBind，這個動作要寫在 ``init.c``，就在前面"
"抓 set_position 的 MethodBind 之後："

msgid ""
"Note that we reuse the ``native_class_name`` and ``method_name`` variables "
"here, so we don't need to declare new ones."
msgstr ""
"這裡我們重用 ``native_class_name`` 和 ``method_name`` 變數，不用再多宣告新"
"的。"

msgid ""
"Now go to the ``gdexample.h`` file where we're going to add a couple of "
"fields:"
msgstr "現在到 ``gdexample.h``，我們要加兩個欄位："

msgid ""
"The first one will store the time passed since the last signal was emitted, "
"since we'll be doing so at regular intervals. The other is just to cache the "
"signal name so we don't need to create a new StringName every time."
msgstr ""
"第一個欄位用來記錄自上次發送訊號以來經過的時間，因為我們會定期發送訊號。另一"
"個欄位則用來快取訊號名稱，避免每次都要新建 StringName。"

msgid ""
"In the source ``gdexample.c`` file we can change the constructor and "
"destructor to deal with the new fields:"
msgstr "在 ``gdexample.c`` 裡，請修改建構子和解構子，處理這兩個新欄位："

msgid "It is important to destruct the StringName to avoid memory leaks."
msgstr "要記得釋放 StringName，這樣才不會有記憶體洩漏。"

msgid ""
"Now we can add to the ``gdexample_class_process()`` function to actually "
"emit the signal:"
msgstr "現在可以在 ``gdexample_class_process()`` 裡真正發送訊號了："

msgid ""
"This updates the time passed for the signal emission and, if it is over one "
"second it calls the ``emit_signal()`` function on the current instance, "
"passing the name of the signal and the new position as arguments."
msgstr ""
"這段會更新發送訊號的計時，如果超過一秒就呼叫目前 instance 的 "
"``emit_signal()``，傳入訊號名稱和新位置。"

msgid ""
"Now we're done with our C GDExtension. Build it once more and reopen the "
"demo project in the editor."
msgstr ""
"到這裡我們的 C GDExtension 已經完成了。請再編譯一次，然後在 Godot 編輯器裡重"
"開專案。"

msgid ""
"In the documentation page for ``GDExample`` you can see the new signal we "
"bound:"
msgstr "你可以在 ``GDExample`` 的說明文件頁看到剛綁上的新訊號："

msgid ""
"To check it's working, let's add a small script to the root node, parent of "
"our custom one, that prints the position to the output every time it "
"receives the signal:"
msgstr ""
"要確認訊號有作用，可以在自訂節點的父節點（場景根節點）加一個小腳本，每次收到"
"訊號時就把位置印出來："

msgid ""
"Run the project and you can observe the values being printed in the Output "
"dock in the editor:"
msgstr "執行專案後，你可以在編輯器的 Output 側邊欄看到印出的數值："

msgid "Conclusion"
msgstr "結論"

msgid ""
"This tutorial shows a basic extension with custom methods, properties, and "
"signals. While it does require a good amount of boilerplate, it can scale "
"well by creating helper functions to handle the tedious tasks."
msgstr ""
"這份教學展示了一個具備自訂方法、屬性與訊號的基本擴充元件。雖然寫起來樣板程式"
"碼不少，但只要把瑣碎的事都包裝成輔助函式，整體架構就很容易擴充。"

msgid ""
"This should serve as a good basis to understand the GDExtension API and as a "
"starting point to create custom binding generators. In fact, it would be "
"possible to create bindings for C using such type of generator, making the "
"actual coding look more like the ``gdexample.c`` file in this example, which "
"is quite straightforward and not very verbose."
msgstr ""
"這可以作為理解 GDExtension API 的良好基礎，也很適合用來實作自己的繫結產生器。"
"實際上你也可以用這類產生器來寫出更像這個範例 ``gdexample.c`` 那樣直覺、簡潔"
"的 C 語言繫結。"

msgid ""
"If you want to create actual extensions, it is preferred to use the C++ "
"bindings instead, as it takes away all of the boilerplate from your code. "
"Check the :ref:`GDExtension C++ example <doc_gdextension_cpp_example>` to "
"see how you can do this."
msgstr ""
"如果你想要開發真正的擴充元件，建議還是用 C++ 繫結，這樣就不需要自己處理一堆樣"
"板程式碼。參考 :ref:`GDExtension C++ 範例 <doc_gdextension_cpp_example>`，看"
"看該怎麼做會更有效率。"
