#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Change scenes manually"
msgstr "手動切換場景"

msgid ""
"Sometimes it helps to have more control over how you swap scenes around. "
"A :ref:`Viewport <class_Viewport>`'s child nodes will render to the image it "
"generates. This holds true even for nodes outside of the \"current\" scene. "
"Autoloads fall into this category, and also scenes which you instantiate and "
"add to the tree at runtime:"
msgstr ""
"有時候你會需要更細緻地控制場景的切換方式。:ref:`Viewport <class_Viewport>` 的"
"子節點會算繪到它所產生的影像中，即使這些節點並不屬於「目前」場景也一樣。自動"
"載入（Autoload）的節點屬於這一類，同時在執行時動態實例化並加入樹狀結構的場景"
"也是："

msgid ""
"To complete the cycle and swap out the new scene with the old one, you have "
"a choice to make. Many strategies exist for removing a scene from view of "
"the :ref:`Viewport <class_Viewport>`. The tradeoffs involve balancing "
"operation speed and memory consumption, as well as balancing data access and "
"integrity."
msgstr ""
"要完成流程，將新場景與舊場景交換時，你有多種選擇。從 :ref:`Viewport "
"<class_Viewport>` 視圖中移除場景的方法有很多，這些方法在操作速度、記憶體消"
"耗，以及資料存取與完整性等方面都各有取捨。"

msgid ""
"**Delete the existing scene.** :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` "
"and :ref:`SceneTree.change_scene_to_packed() "
"<class_SceneTree_method_change_scene_to_packed>` will delete the current "
"scene immediately. You can also delete the main scene. Assuming the root "
"node's name is \"Main\", you could do ``get_node(\"/root/Main\").free()`` to "
"delete the whole scene."
msgstr ""
"**刪除現有場景。** :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` "
"與 :ref:`SceneTree.change_scene_to_packed() "
"<class_SceneTree_method_change_scene_to_packed>` 會立即刪除目前場景。你也可以"
"手動刪除主場景，假設根節點名稱為「Main」，可以執行 ``get_node(\"/root/"
"Main\").free()`` 來刪除整個場景。"

msgid "Unloads memory."
msgstr "釋放記憶體。"

msgid "Pro: RAM is no longer dragging the dead weight."
msgstr "優點：記憶體不再被佔用。"

msgid ""
"Con: Returning to that scene is now more expensive since it must be loaded "
"back into memory again (takes time AND memory). Not a problem if returning "
"soon is unnecessary."
msgstr ""
"缺點：若要再次回到該場景，必須重新載入到記憶體，這會消耗更多時間與記憶體。如"
"果不需要很快切回原場景，這通常不是問題。"

msgid ""
"Con: No longer have access to that scene's data. Not a problem if using that "
"data soon is unnecessary."
msgstr "缺點：無法再存取該場景的資料。如果短期內不需要用到這些資料，問題不大。"

msgid ""
"Note: It can be useful to preserve the data in a soon-to-be-deleted scene by "
"re-attaching one or more of its nodes to a different scene, or even directly "
"to the :ref:`SceneTree <class_SceneTree>`."
msgstr ""
"注意：如果需要保留即將被刪除場景中的資料，可以將其中一個或多個節點重新掛載到"
"其他場景，甚至直接掛載到 :ref:`SceneTree <class_SceneTree>` 上。"

msgid "Processing stops."
msgstr "處理停止。"

msgid ""
"Pro: No nodes means no processing, physics processing, or input handling. "
"The CPU is available to work on the new scene's contents."
msgstr ""
"優點：沒有節點就沒有運算、物理運算或輸入處理，CPU 可專注處理新場景內容。"

msgid ""
"Con: Those nodes' processing and input handling no longer operate. Not a "
"problem if using the updated data is unnecessary."
msgstr ""
"缺點：這些節點的運算與輸入處理都不再進行。如果不需要即時的資料更新，問題不"
"大。"

msgid ""
"**Hide the existing scene.** By changing the visibility or collision "
"detection of the nodes, you can hide the entire node sub-tree from the "
"player's perspective."
msgstr ""
"**隱藏現有場景。** 你可以透過更改節點的可見性或碰撞屬性，將整個節點子樹從玩家"
"視角隱藏。"

msgid "Memory still exists."
msgstr "記憶體仍被佔用。"

msgid "Pro: You can still access the data if needed."
msgstr "優點：如有需要，仍可存取資料。"

msgid "Pro: There's no need to move any more nodes around to save data."
msgstr "優點：不必再移動任何節點即可保留資料。"

msgid ""
"Con: More data is being kept in memory, which will be become a problem on "
"memory-sensitive platforms like web or mobile."
msgstr ""
"缺點：更多資料會繼續佔用記憶體，對於像網頁或手機這種對記憶體敏感的平台可能會"
"造成問題。"

msgid "Processing continues."
msgstr "仍然持續處理。"

msgid ""
"Pro: Data continues to receive processing updates, so the scene will keep "
"any data within it that relies on delta time or frame data updated."
msgstr ""
"優點：資料會持續接收處理更新，因此場景內依賴 delta time 或影格資料的內容會持"
"續更新。"

msgid ""
"Pro: Nodes are still members of groups (since groups belong to "
"the :ref:`SceneTree <class_SceneTree>`)."
msgstr ""
"優點：節點仍然會是群組的成員（因為群組屬於 :ref:`SceneTree "
"<class_SceneTree>`）。"

msgid ""
"Con: The CPU's attention is now divided between both scenes. Too much load "
"could result in low frame rates. You should be sure to test performance as "
"you go to ensure the target platform can support the load from this approach."
msgstr ""
"缺點：CPU 的運算量會分散到多個場景，如果負載過大可能導致畫面更新率降低。建議"
"隨時測試效能，確保目標平台能承受這種負載。"

msgid ""
"**Remove the existing scene from the tree.** Assign a variable to the "
"existing scene's root node. Then use :ref:`Node.remove_child(Node) "
"<class_Node_method_remove_child>` to detach the entire scene from the tree."
msgstr ""
"**從樹狀結構中移除現有場景。** 先將現有場景的根節點指定給一個變數，然後使"
"用 :ref:`Node.remove_child(Node) <class_Node_method_remove_child>` 將整個場景"
"從樹中分離。"

msgid "Memory still exists (similar pros/cons as hiding it from view)."
msgstr "記憶體仍被佔用（優缺點與隱藏場景方式相似）。"

msgid "Processing stops (similar pros/cons as deleting it completely)."
msgstr "停止處理（優缺點與完全刪除場景相似）。"

msgid ""
"Pro: This variation of \"hiding\" it is much easier to show/hide. Rather "
"than potentially keeping track of multiple changes to the scene, you only "
"need to call the add/remove_child methods. This is similar to disabling game "
"objects in other engines."
msgstr ""
"優點：這種「隱藏」變體更容易顯示/隱藏場景，只需呼叫 add_child 或 "
"remove_child 方法，而不必追蹤場景的多次變動。這類似於其他引擎裡的遊戲物件啟"
"用/停用功能。"

msgid ""
"Con: Unlike with hiding it from view only, the data contained within the "
"scene will become stale if it relies on delta time, input, groups, or other "
"data that is derived from :ref:`SceneTree <class_SceneTree>` access."
msgstr ""
"缺點：與單純隱藏場景不同，如果場景內的資料依賴 delta time、輸入、群組或其他來"
"自 :ref:`SceneTree <class_SceneTree>` 的資料，這些內容會變得過時。"

msgid ""
"There are also cases where you may wish to have many scenes present at the "
"same time, such as adding your own singleton at runtime, or preserving a "
"scene's data between scene changes (adding the scene to the root node)."
msgstr ""
"有時你可能需要同時存在多個場景，例如在執行時新增自訂單例，或在切換場景時保留"
"資料（將場景加到根節點下）。"

msgid ""
"Another case may be displaying multiple scenes at the same time "
"using :ref:`SubViewportContainers <class_SubViewportContainer>`. This is "
"optimal for rendering different content in different parts of the screen "
"(e.g. minimaps, split-screen multiplayer)."
msgstr ""
"另一種情境是使用 :ref:`SubViewportContainers <class_SubViewportContainer>` 同"
"時顯示多個場景。這非常適合在螢幕不同區域算繪不同內容（如小地圖或分割畫面的多"
"人遊戲）。"

msgid ""
"Each option will have cases where it is best appropriate, so you must "
"examine the effects of each approach, and determine what path best fits your "
"unique situation."
msgstr ""
"每種選項都有其最合適的應用時機，因此你必須評估每種方式的效果，選擇最適合自己"
"專案需求的做法。"
