#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "C# signals"
msgstr "C# 訊號"

msgid ""
"For a detailed explanation of signals in general, see the :ref:`doc_signals` "
"section in the step by step tutorial."
msgstr "關於訊號的詳細說明，請參考按部就班教學中的 :ref:`doc_signals` 章節。"

msgid ""
"Signals are implemented using C# events, the idiomatic way to "
"represent :ref:`the observer pattern<doc_key_concepts_signals>` in C#. This "
"is the recommended way to use signals in C# and the focus of this page."
msgstr ""
"訊號在 C# 中是以事件（events）來實作的，這是 C# 中實現 :ref:`觀察者模式"
"<doc_key_concepts_signals>` 的慣用方式。這也是本頁面推薦的使用方式與重點。"

msgid ""
"In some cases it's necessary to use the "
"older :ref:`Connect()<class_object_method_connect>` "
"and :ref:`Disconnect()<class_object_method_disconnect>` APIs. "
"See :ref:`using_connect_and_disconnect` for more details."
msgstr ""
"在某些情況下，需要使用較舊的 :ref:`Connect()<class_object_method_connect>` "
"與 :ref:`Disconnect()<class_object_method_disconnect>` API。詳情請參"
"閱 :ref:`using_connect_and_disconnect`。"

msgid ""
"If you encounter a ``System.ObjectDisposedException`` while handling a "
"signal, you might be missing a signal disconnection. "
"See :ref:`disconnecting_automatically_when_the_receiver_is_freed` for more "
"details."
msgstr ""
"如果你在處理訊號時遇到 ``System.ObjectDisposedException``，可能是漏掉了訊號的"
"斷線。請參閱 :ref:`disconnecting_automatically_when_the_receiver_is_freed` 以"
"取得更多資訊。"

msgid "Signals as C# events"
msgstr "訊號作為 C# 事件"

msgid ""
"To provide more type-safety, Godot signals are also all available through "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"You can handle these events, as any other event, with the ``+=`` and ``-=`` "
"operators."
msgstr ""
"為了提供更強的型別安全性，Godot 的所有訊號也都能以 `事件 <https://"
"learn.microsoft.com/zh-tw/dotnet/csharp/events-overview>`_ 的形式取得。你可以"
"如同處理其他事件一樣，使用 ``+=`` 與 ``-=`` 運算子來連接或斷開事件。"

msgid ""
"In addition, you can always access signal names associated with a node type "
"through its nested ``SignalName`` class. This is useful when, for example, "
"you want to await on a signal (see :ref:`doc_c_sharp_differences_await`)."
msgstr ""
"此外，你也可以透過各節點型別所屬的巢狀 ``SignalName`` 類別來存取訊號名稱。例"
"如，當你想要等待某個訊號時，這非常有用（請參"
"閱 :ref:`doc_c_sharp_differences_await`）。"

msgid "Custom signals as C# events"
msgstr "自訂訊號作為 C# 事件"

msgid ""
"To declare a custom event in your C# script, use the ``[Signal]`` attribute "
"on a public delegate type. Note that the name of this delegate needs to end "
"with ``EventHandler``."
msgstr ""
"要在 C# 腳本中宣告自訂事件，請在公開的委派型別上加上 ``[Signal]`` 屬性。請注"
"意，委派的名稱必須以 ``EventHandler`` 結尾。"

msgid ""
"Once this is done, Godot will create the appropriate events automatically "
"behind the scenes. You can then use said events as you'd do for any other "
"Godot signal. Note that events are named using your delegate's name minus "
"the final ``EventHandler`` part."
msgstr ""
"完成上述步驟後，Godot 會在背後自動建立相應的事件。之後你就可以如同其他 Godot "
"訊號一樣使用這些事件。請注意，事件名稱會以你的委派名稱去除最後的 "
"``EventHandler`` 部分命名。"

msgid ""
"If you want to connect to these signals in the editor, you will need to "
"(re)build the project to see them appear."
msgstr ""
"如果你想在編輯器中連接這些訊號，需要（重新）建置專案，訊號才會顯示出來。"

msgid ""
"You can click the **Build** button in the upper-right corner of the editor "
"to do so."
msgstr "你可以點擊編輯器右上角的 **建置** 按鈕來進行。"

msgid "Signal emission"
msgstr "訊號發送"

msgid ""
"To emit signals, use the ``EmitSignal`` method. Note that, as for signals "
"defined by the engine, your custom signal names are listed under the nested "
"``SignalName`` class."
msgstr ""
"要發送訊號，請使用 ``EmitSignal`` 方法。請注意，與引擎預設訊號一樣，你的自訂"
"訊號名稱也會列在巢狀的 ``SignalName`` 類別下。"

msgid ""
"In contrast with other C# events, you cannot use ``Invoke`` to raise events "
"tied to Godot signals."
msgstr ""
"與其他 C# 事件不同，你不能使用 ``Invoke`` 來觸發與 Godot 訊號綁定的事件。"

msgid ""
"Signals support arguments of any :ref:`Variant-compatible type "
"<c_sharp_variant_compatible_types>`."
msgstr ""
"訊號支援任何 :ref:`與 Variant 相容的型別 <c_sharp_variant_compatible_types>` "
"作為參數。"

msgid ""
"Consequently, any ``Node`` or ``RefCounted`` will be compatible "
"automatically, but custom data objects will need to inherit from "
"``GodotObject`` or one of its subclasses."
msgstr ""
"因此，任何 ``Node`` 或 ``RefCounted`` 物件都會自動相容，但自訂資料物件必須繼"
"承自 ``GodotObject`` 或其子類別。"

msgid "Bound values"
msgstr "繫結值"

msgid ""
"Sometimes you'll want to bind values to a signal when the connection is "
"established, rather than (or in addition to) when the signal is emitted. To "
"do so, you can use an anonymous function like in the following example."
msgstr ""
"有時你會希望在建立連線時就將值綁定到訊號（而不是在訊號發送時，或是兩者皆"
"有）。這時可以使用匿名函式（Lambda），如下例所示。"

msgid ""
"Here, the :ref:`Button.Pressed <class_BaseButton_signal_pressed>` signal "
"does not take any argument. But we want to use the same ``ModifyValue`` for "
"both the \"plus\" and \"minus\" buttons. So we bind the modifier value at "
"the time we're connecting the signals."
msgstr ""
"這裡，:ref:`Button.Pressed <class_BaseButton_signal_pressed>` 訊號沒有參數。"
"但我們希望讓「加號」與「減號」按鈕都使用同一個 ``ModifyValue`` 方法，因此在連"
"接訊號時就綁定修飾值。"

msgid "Signal creation at runtime"
msgstr "執行時建立訊號"

msgid ""
"Finally, you can create custom signals directly while your game is running. "
"Use the ``AddUserSignal`` method for that. Be aware that it should be "
"executed before any use of said signals (either connecting to them or "
"emitting them). Also, note that signals created this way won't be visible "
"through the ``SignalName`` nested class."
msgstr ""
"最後，你也可以在遊戲運作時直接建立自訂訊號，請使用 ``AddUserSignal`` 方法。請"
"注意，必須在使用該訊號（無論是連接或發送）前先呼叫此方法。另外，這種方式建立"
"的訊號不會顯示在 ``SignalName`` 巢狀類別中。"

msgid "Using Connect and Disconnect"
msgstr "使用 Connect 與 Disconnect"

msgid ""
"In general, it isn't recommended to "
"use :ref:`Connect()<class_object_method_connect>` "
"and :ref:`Disconnect()<class_object_method_disconnect>`. These APIs don't "
"provide as much type safety as the events. However, they're necessary "
"for :ref:`connecting to signals defined by GDScript "
"<connecting_to_signals_cross_language>` and "
"passing :ref:`ConnectFlags<enum_Object_ConnectFlags>`."
msgstr ""
"一般來說，不建議使用 :ref:`Connect()<class_object_method_connect>` "
"及 :ref:`Disconnect()<class_object_method_disconnect>` 這些 API，因為它們不像"
"事件那樣提供型別安全。但在 :ref:`跨語言連接 GDScript 訊號 "
"<connecting_to_signals_cross_language>` 或需傳"
"遞 :ref:`ConnectFlags<enum_Object_ConnectFlags>` 時，這些 API 就會很有用。"

msgid ""
"In the following example, pressing the button for the first time prints "
"``Greetings!``. ``OneShot`` disconnects the signal, so pressing the button "
"again does nothing."
msgstr ""
"在下例中，第一次按下按鈕會顯示 ``Greetings!``。由於使用了 ``OneShot``，訊號會"
"在觸發後自動斷開，因此再次按下按鈕不會有任何反應。"

msgid "Disconnecting automatically when the receiver is freed"
msgstr "當接收端被釋放時自動斷線"

msgid ""
"Normally, when any ``GodotObject`` is freed (such as any ``Node``), Godot "
"automatically disconnects all connections associated with that object. This "
"happens for both signal emitters and signal receivers."
msgstr ""
"通常當任何 ``GodotObject``（例如任何 ``Node``）被釋放時，Godot 會自動斷開與該"
"物件相關的所有訊號連線，無論是作為發送端還是接收端。"

msgid ""
"For example, a node with this code will print \"Hello!\" when the button is "
"pressed, then free itself. Freeing the node disconnects the signal, so "
"pressing the button again doesn't do anything:"
msgstr ""
"例如，一個節點如果寫了下列程式碼，按下按鈕時會印出「Hello!」，然後自我釋放。"
"釋放該節點時訊號會自動斷開，因此再次按下按鈕不會有任何效果："

msgid ""
"When a signal receiver is freed while the signal emitter is still alive, in "
"some cases automatic disconnection won't happen:"
msgstr "當訊號接收端被釋放而發送端仍存在時，有些情況下自動斷線不會發生："

msgid ""
"The signal is connected to a lambda expression that captures a variable."
msgstr "該訊號連接到一個捕捉變數的 Lambda 匿名函式。"

msgid "The signal is a custom signal."
msgstr "該訊號為自訂訊號。"

msgid ""
"The following sections explain these cases in more detail and include "
"suggestions for how to disconnect manually."
msgstr "以下章節將更詳細解釋這些情況，並提供如何手動斷線的建議。"

msgid ""
"Automatic disconnection is totally reliable if a signal emitter is freed "
"before any of its receivers are freed. With a project style that prefers "
"this pattern, the above limits may not be a concern."
msgstr ""
"如果訊號發送端在所有接收端被釋放前就被釋放，自動斷線是完全可靠的。若你的專案"
"風格偏好這種模式，上述限制可能就不會造成困擾。"

msgid ""
"No automatic disconnection: a lambda expression that captures a variable"
msgstr "無法自動斷線：捕捉變數的 Lambda 匿名函式"

msgid ""
"If you connect to a lambda expression that captures variables, Godot can't "
"tell that the lambda is associated with the instance that created it. This "
"causes this example to have potentially unexpected behavior:"
msgstr ""
"如果你連接到一個捕捉變數的 Lambda 匿名函式，Godot 無法辨識該 Lambda 屬於哪個"
"實例，可能導致下例這樣的非預期行為："

msgid ""
"On tick 4, the lambda expression tries to access the ``Name`` property of "
"the node, but the node has already been freed. This causes the exception."
msgstr ""
"在第 4 次 tick 時，Lambda 嘗試存取該節點的 ``Name`` 屬性，但該節點已經被釋"
"放，這會導致例外。"

msgid ""
"To disconnect, keep a reference to the delegate created by the lambda "
"expression and pass that to ``-=``. For example, this node connects and "
"disconnects using the ``_EnterTree`` and ``_ExitTree`` lifecycle methods:"
msgstr ""
"為了正確斷線，請保留 Lambda 產生的委派參考，並在適當時機用 ``-=`` 斷開。如下"
"例所示，該節點於 ``_EnterTree`` 連線，於 ``_ExitTree`` 斷線："

msgid ""
"In this example, ``Free`` causes the node to leave the tree, which calls "
"``_ExitTree``. ``_ExitTree`` disconnects the signal, so ``_tick`` is never "
"called again."
msgstr ""
"在此例中，呼叫 ``Free`` 會讓節點離開場景樹，進而觸發 ``_ExitTree``。在 "
"``_ExitTree`` 會將訊號斷線，因此 ``_tick`` 不會再被呼叫。"

msgid ""
"The lifecycle methods to use depend on what the node does. Another option is "
"to connect to signals in ``_Ready`` and disconnect in ``Dispose``."
msgstr ""
"實際應使用哪個生命週期方法，取決於節點的用途。另一種作法是在 ``_Ready`` 連"
"線，在 ``Dispose`` 斷線。"

msgid ""
"Godot uses `Delegate.Target <https://learn.microsoft.com/en-us/dotnet/api/"
"system.delegate.target>`_ to determine what instance a delegate is "
"associated with. When a lambda expression doesn't capture a variable, the "
"generated delegate's ``Target`` is the instance that created the delegate. "
"When a variable is captured, the ``Target`` instead points at a generated "
"type that stores the captured variable. This is what breaks the association. "
"If you want to see if a delegate will be automatically cleaned up, try "
"checking its ``Target``."
msgstr ""
"Godot 會使用 `Delegate.Target <https://learn.microsoft.com/zh-tw/dotnet/api/"
"system.delegate.target>`_ 判斷委派關聯的實例。當 Lambda 沒有捕捉變數時，委派"
"的 ``Target`` 會指向建立它的實例；但如果有捕捉變數，``Target`` 會指向存放該變"
"數的產生型別，這就會導致關聯失效。想要確認委派會否自動清理，可檢查其 "
"``Target``。"

msgid ""
"``Callable.From`` doesn't affect the ``Delegate.Target``, so connecting a "
"lambda that captures variables using ``Connect`` doesn't work any better "
"than ``+=``."
msgstr ""
"``Callable.From`` 並不會影響 ``Delegate.Target``。因此，使用 ``Connect`` 連接"
"捕捉變數的 Lambda，效果與 ``+=`` 相同，不會有更好的自動清理。"

msgid "No automatic disconnection: a custom signal"
msgstr "無法自動斷線：自訂訊號"

msgid ""
"Connecting to a custom signal using ``+=`` doesn't disconnect automatically "
"when the receiving node is freed."
msgstr "如果用 ``+=`` 連接自訂訊號，當接收端節點被釋放時並不會自動斷線。"

msgid "To disconnect, use ``-=`` at an appropriate time. For example:"
msgstr "要斷開連線，請在適當時機使用 ``-=``。例如："

msgid ""
"Another solution is to use ``Connect``, which does disconnect automatically "
"with custom signals:"
msgstr "另一個解決方式是使用 ``Connect``，這樣自訂訊號也能自動斷線："
