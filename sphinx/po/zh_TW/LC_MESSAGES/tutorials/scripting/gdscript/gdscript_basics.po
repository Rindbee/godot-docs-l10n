#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDScript reference"
msgstr "資料偏好"

msgid ""
":ref:`GDScript<doc_gdscript>` is a high-level, `object-oriented <https://"
"en.wikipedia.org/wiki/Object-oriented_programming>`_, `imperative <https://"
"en.wikipedia.org/wiki/Imperative_programming>`_, and `gradually typed "
"<https://en.wikipedia.org/wiki/Gradual_typing>`_ programming language built "
"for Godot. It uses an indentation-based syntax similar to languages like "
"`Python <https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_. "
"Its goal is to be optimized for and tightly integrated with Godot Engine, "
"allowing great flexibility for content creation and integration."
msgstr ""
":ref:`GDScript<doc_gdscript>` 是為 Godot 打造的高階、`物件導向 <https://"
"zh.wikipedia.org/zh-tw/Object-oriented_programming>`_、`命令式 <https://"
"zh.wikipedia.org/zh-tw/Imperative_programming>`_，並支援 `漸進式型別 "
"<https://zh.wikipedia.org/wiki/Gradual_typing>`_ 的程式語言。它使用和 "
"`Python <https://zh.wikipedia.org/zh-tw/"
"Python_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)>`_ 類似的縮排語法。設計目的是最"
"佳化 Godot 引擎的整合度，讓內容創作與整合更加彈性。"

msgid "GDScript is entirely independent from Python and is not based on it."
msgstr "GDScript 是完全獨立於 Python 存在的，沒有繼承或擴充關係。"

msgid "History"
msgstr "歷史記錄"

msgid ""
"Documentation about GDScript's history has been moved to "
"the :ref:`Frequently Asked Questions <doc_faq_what_is_gdscript>`."
msgstr ""
"關於 GDScript 歷史的文件移到了 :ref:`常見問題 <doc_faq_what_is_gdscript>` 。"

msgid "Example of GDScript"
msgstr "GDScript 範例"

msgid ""
"Some people can learn better by taking a look at the syntax, so here's an "
"example of how GDScript looks."
msgstr "有些人瞭解語法後可以學得更好，所以以下是簡單的 GDScript 例子。"

msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"如果你曾經有使用如 C、C++、或 C# 等靜態型別語言的經驗卻沒用過動態型別的話，建"
"議你閱讀這個教學： :ref:`doc_gdscript_more_efficiently` 。"

msgid "Identifiers"
msgstr "識別項"

msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"所有只包含英文字元（ ``a`` 到 ``z`` 與 ``A`` 到 ``Z`` ）、數字（ ``0`` 到 "
"``9`` ）、與 ``_`` 的字串都算是一個識別項。另外，識別項不可以以數字開頭。識別"
"項的大小寫有別（ ``foo`` 與 ``FOO`` 是不同的）。"

msgid ""
"Identifiers may also contain most Unicode characters part of `UAX#31 "
"<https://www.unicode.org/reports/tr31/>`__. This allows you to use "
"identifier names written in languages other than English. Unicode characters "
"that are considered \"confusable\" for ASCII characters and emoji are not "
"allowed in identifiers."
msgstr ""
"識別碼也可能包含 `UAX#31 <https://www.unicode.org/reports/tr31/>`__ 的大多數 "
"Unicode 字元部分。這允許您使用以英語以外的語言編寫的識別符名稱。標識符中不允"
"許使用被視為與 ASCII 字元和表情符號「混淆」的 Unicode 字元。"

msgid "Keywords"
msgstr "關鍵字"

msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"下面是 GDScript 所支援的關鍵字列表。這些單字是保留字（符記，Token），所以不能"
"當作識別項來用。有些運算子（如 ``in`` 、 ``not`` 、 ``and`` 、或是 ``or`` ）"
"與下一個章節會提到的內建型別的名稱也是保留字。"

msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"如果你想瞭解一下的話，關鍵字定義在 `GDScript Tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ 裡。"

msgid "Keyword"
msgstr "關鍵字"

msgid "Description"
msgstr "說明"

msgid "if"
msgstr "if"

msgid "See `if/else/elif`_."
msgstr "請參考 `if/else/elif`_ 。"

msgid "elif"
msgstr "elif"

msgid "else"
msgstr "else"

msgid "for"
msgstr "for"

msgid "See for_."
msgstr "請參考 for_ 。"

msgid "while"
msgstr "while"

msgid "See while_."
msgstr "請參考 while 。"

msgid "match"
msgstr "match"

msgid "See match_."
msgstr "請參考 match 。"

msgid "when"
msgstr "when"

msgid "Used by `pattern guards <Pattern guards_>`_ in ``match`` statements."
msgstr "於 ``match`` 陳述式中由 `模式守衛<Pattern guards_>`_ 使用。"

msgid "break"
msgstr "break"

msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "跳出目前的 ``for`` 或是 ``while`` 迴圈。"

msgid "continue"
msgstr "continue"

msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "馬上跳至 ``for`` 或 ``while`` 迴圈的下一個迭代。"

msgid "pass"
msgstr "階段"

msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr "當語法上需要有敘述句但不需要執行任何東西的時候可以使用。如：空函式。"

msgid "return"
msgstr "return"

msgid "Returns a value from a function."
msgstr "從函式裡回傳數值。"

msgid "class"
msgstr "類別"

msgid "Defines an inner class. See `Inner classes`_."
msgstr "定義一個內部類別。詳見 `內部類別`_ 。"

msgid "class_name"
msgstr "class_name"

msgid ""
"Defines the script as a globally accessible class with the specified name. "
"See `Registering named classes`_."
msgstr "將腳本定義為具有指定名稱的全域可存取類別。詳見 `註冊命名類別`_ 。"

msgid "extends"
msgstr "extends"

msgid "Defines what class to extend with the current class."
msgstr "定義目前類別所要繼承的類別。"

msgid "is"
msgstr "is"

msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr "測試一個變數是否為繼承自給定的類別，或判斷其是否為指定的內建型別。"

msgid "in"
msgstr "in"

msgid ""
"Tests whether a value is within a string, array, range, dictionary, or node. "
"When used with ``for``, it iterates through them instead of testing."
msgstr ""
"檢查某個值是否包含在字串、陣列、範圍、字典或節點中。搭配 ``for`` 使用時，會遍"
"歷其中的項目。"

msgid "as"
msgstr "as"

msgid "Cast the value to a given type if possible."
msgstr "嘗試轉換為指定型別。"

msgid "self"
msgstr "self"

msgid "Refers to current class instance. See `self`_."
msgstr "參照目前的類別實體。詳見 `self`_。"

msgid "super"
msgstr "super"

msgid "Resolves the scope of the parent method. See `Inheritance`_."
msgstr "呼叫父類別的方法。詳見 `繼承`_。"

msgid "signal"
msgstr "signal"

msgid "Defines a signal. See `Signals`_."
msgstr "定義一個訊號。詳見 `訊號`_。"

msgid "func"
msgstr "func"

msgid "Defines a function.  See `Functions`_."
msgstr "定義一個函式。詳見 `函式`_。"

msgid "static"
msgstr "static"

msgid "Defines a static function or a static member variable."
msgstr "定義一個靜態函式。不能用來定義靜態成員變數。"

msgid "const"
msgstr "const"

msgid "Defines a constant. See `Constants`_."
msgstr "定義一個常數。詳見 `常數`_。"

msgid "enum"
msgstr "enum"

msgid "Defines an enum. See `Enums`_."
msgstr "定義一個列舉型別（enum）。詳見 `列舉型別`_。"

msgid "var"
msgstr "var"

msgid "Defines a variable. See `Variables`_."
msgstr "定義一個變數。詳見 `變數`_。"

msgid "breakpoint"
msgstr "breakpoint"

msgid ""
"Editor helper for debugger breakpoints. Unlike breakpoints created by "
"clicking in the gutter, ``breakpoint`` is stored in the script itself. This "
"makes it persistent across different machines when using version control."
msgstr ""
"除錯器斷點的編輯器助手。與透過點擊裝訂線建立的斷點不同，「斷點」會儲存在腳本"
"本身中。這使得在使用版本控制時它可以在不同的機器上保持不變。"

msgid "preload"
msgstr "preload"

msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr "預先載入一個類別或變數。請參閱 `以類別作為資源`_ 。"

msgid "await"
msgstr "await"

msgid ""
"Waits for a signal or a coroutine to finish. See `Awaiting signals or "
"coroutines`_."
msgstr "等待訊號或協程完成。詳見 `等待訊號或協程`_。"

msgid "yield"
msgstr "yield"

msgid "Previously used for coroutines. Kept as keyword for transition."
msgstr "以前用於協程。保留為關鍵字，方便遷移。"

msgid "assert"
msgstr "assert"

msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"判定一個條件，當判定失敗的時候記錄錯誤。在非除錯用建置中會忽略。請參考 "
"`Assert 關鍵字`_ 。"

msgid "void"
msgstr "void"

msgid "Used to represent that a function does not return any value."
msgstr "用於代表函式不返回任何值。"

msgid "PI"
msgstr "PI"

msgid "PI constant."
msgstr "PI（圓周率）常數。"

msgid "TAU"
msgstr "TAU"

msgid "TAU constant."
msgstr "TAU 常數。"

msgid "INF"
msgstr "INF"

msgid "Infinity constant. Used for comparisons and as result of calculations."
msgstr "無窮大常數。用於比較。"

msgid "NAN"
msgstr "NAN"

msgid ""
"NAN (not a number) constant. Used as impossible result from calculations."
msgstr "NAN（Not a Number，不是數字）常數。用於比較。"

msgid "Operators"
msgstr "運算子"

msgid ""
"The following is the list of supported operators and their precedence. All "
"binary operators are `left-associative <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_, including the ``**`` operator. This means that "
"``2 ** 2 ** 3`` is equal to ``(2 ** 2) ** 3``. Use parentheses to explicitly "
"specify precedence you need, for example ``2 ** (2 ** 3)``. The ternary ``if/"
"else`` operator is right-associative."
msgstr ""
"以下是支援的運算子列表及其優先順序。所有二元運算子皆為 `左結合 <https://"
"en.wikipedia.org/wiki/Operator_associativity>`_ ，包括 ``**`` 運算子。這代表 "
"``2 ** 2 ** 3`` 等同於 ``(2 ** 2) ** 3``。如需明確指定優先順序，請使用括號，"
"例如 ``2 ** (2 ** 3)``。三元 ``if/else`` 運算子則為右結合。"

msgid "**Operator**"
msgstr "**運算子**"

msgid "**Description**"
msgstr "**說明**"

msgid "``(`` ``)``"
msgstr "``<<`` ``>>``"

msgid "Grouping (highest priority)"
msgstr "陣列索引（最高優先度）"

msgid ""
"Parentheses are not really an operator, but allow you to explicitly specify "
"the precedence of an operation."
msgstr "括弧其實不是運算子，但是能夠讓你明確的指定運算的優先順序。"

msgid "``x[index]``"
msgstr "``x[index]``"

msgid "Subscription"
msgstr "說明"

msgid "``x.attribute``"
msgstr "``x.attribute``"

msgid "Attribute reference"
msgstr "屬性參照"

msgid "``foo()``"
msgstr "``foo()``"

msgid "Function call"
msgstr "呼叫函式"

msgid "``await x``"
msgstr "``await x``"

msgid "`Awaiting signals or coroutines`_"
msgstr "`等待訊號或協程`_"

msgid "``x is Node``"
msgstr "``x is Node``"

msgid "``x is not Node``"
msgstr "``x 不是 Node``"

msgid "Type checking"
msgstr "型別轉換"

msgid ""
"See also :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` "
"function."
msgstr ""
"另見 :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` 函式。"

msgid "``x ** y``"
msgstr "``x ** y``"

msgid "Power"
msgstr "力度"

msgid ""
"Multiplies ``x`` by itself ``y`` times, similar to calling :ref:`pow() "
"<class_@GlobalScope_method_pow>` function."
msgstr ""
"將 ``x`` 與其自身相乘 ``y`` 次，類似於呼叫 :ref:`pow() "
"<class_@GlobalScope_method_pow>` 函式。"

msgid "``~x``"
msgstr "``~x``"

msgid "Bitwise NOT"
msgstr "按位元 (Bitwise) NOT（非）"

msgid "``+x``"
msgstr "``+x``"

msgid "``-x``"
msgstr "``-x``"

msgid "Identity / Negation"
msgstr "縮 排"

msgid "``x * y``"
msgstr "``x * 2^exp``"

msgid "``x / y``"
msgstr "``x / y``"

msgid "``x % y``"
msgstr "``x % y``"

msgid "Multiplication / Division / Remainder"
msgstr "乘法／除法／餘數"

msgid ""
"The ``%`` operator is additionally used for :ref:`format strings "
"<doc_gdscript_printf>`."
msgstr "``%`` 運算子也用於 :ref:`字串的格式化 <doc_gdscript_printf>`。"

msgid ""
"**Note:** These operators have the same behavior as C++, which may be "
"unexpected for users coming from Python, JavaScript, etc. See a detailed "
"note after the table."
msgstr ""
"**注意：** 這些運算子的行為與 C++ 一致，對於來自 Python、JavaScript 等語言的"
"使用者可能存在意外的行為。詳情見表後。"

msgid "``x + y``"
msgstr "``x + y``"

msgid "``x - y``"
msgstr "``x - y``"

msgid "Addition (or Concatenation) / Subtraction"
msgstr "加法／陣列的串聯"

msgid "``x << y``"
msgstr "``x << y``"

msgid "``x >> y``"
msgstr "``x >> y``"

msgid "Bit shifting"
msgstr "位元移位"

msgid "``x & y``"
msgstr "``x & y``"

msgid "Bitwise AND"
msgstr "按位元 AND（與）"

msgid "``x ^ y``"
msgstr "``x ^ y``"

msgid "Bitwise XOR"
msgstr "按位元 XOR （互斥或）"

msgid "``x | y``"
msgstr "``x | y``"

msgid "Bitwise OR"
msgstr "按位元 OR（或）"

msgid "``x == y``"
msgstr "``x == y``"

msgid "``x != y``"
msgstr "``x != y``"

msgid "``x < y``"
msgstr "``x < y``"

msgid "``x > y``"
msgstr "``x > y``"

msgid "``x <= y``"
msgstr "``x <= y``"

msgid "``x >= y``"
msgstr "``x >= y``"

msgid "Comparison"
msgstr "比較"

msgid "See a detailed note after the table."
msgstr "詳情見表後。"

msgid "``x in y``"
msgstr "``x in y``"

msgid "``x not in y``"
msgstr "``x not in y``"

msgid "Inclusion checking"
msgstr "遮擋模式"

msgid "``in`` is also used with the for_ keyword as part of the syntax."
msgstr "``in`` 也在 for_ 關鍵字的語法中使用。"

msgid "``not x``"
msgstr "``not x``"

msgid "``!x``"
msgstr "``!x``"

msgid "Boolean NOT and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布林“非”，以及 :ref:`不推薦使用 <boolean_operators>` 的別名"

msgid "``x and y``"
msgstr "``x and y``"

msgid "``x && y``"
msgstr "``x && y``"

msgid "Boolean AND and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布林“與”，以及 :ref:`不推薦使用 <boolean_operators>` 的別名"

msgid "``x or y``"
msgstr "``x or y``"

msgid "``x || y``"
msgstr "``x || y``"

msgid "Boolean OR and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布林“或”，以及 :ref:`不推薦使用 <boolean_operators>` 的別名"

msgid "``true_expr if cond else false_expr``"
msgstr "``真運算式 if 條件 else 假運算式``"

msgid "Ternary if/else"
msgstr "三元 if/else"

msgid "``x as Node``"
msgstr "``x as Node``"

msgid "`Type casting <casting_>`_"
msgstr "`型別轉換 <casting_>`_"

msgid "``x = y``"
msgstr "``x = y``"

msgid "``x += y``"
msgstr "``x += y``"

msgid "``x -= y``"
msgstr "``x -= y``"

msgid "``x *= y``"
msgstr "``x *= y``"

msgid "``x /= y``"
msgstr "``x /= y``"

msgid "``x **= y``"
msgstr "``x **= y``"

msgid "``x %= y``"
msgstr "``x %= y``"

msgid "``x &= y``"
msgstr "``x &= y``"

msgid "``x |= y``"
msgstr "``x |= y``"

msgid "``x ^= y``"
msgstr "``x ^= y``"

msgid "``x <<= y``"
msgstr "``x <<= y``"

msgid "``x >>= y``"
msgstr "``x >>= y``"

msgid "Assignment (lowest priority)"
msgstr "賦值（最低優先度）"

msgid "You cannot use an assignment operator inside an expression."
msgstr "運算式中不能使用設定運算子。"

msgid "The behavior of some operators may differ from what you expect:"
msgstr "某些運算符的行為可能與您的預期不同："

msgid ""
"If both operands of the ``/`` operator are :ref:`int <class_int>`, then "
"integer division is performed instead of fractional. For example ``5 / 2 == "
"2``, not ``2.5``. If this is not desired, use at least one :ref:`float "
"<class_float>` literal (``x / 2.0``), cast (``float(x) / y``), or multiply "
"by ``1.0`` (``x * 1.0 / y``)."
msgstr ""
"如果 ``/`` 運算子的兩個運算元都是 :ref:`整數 <class_int>`，就會執行整數除法而"
"非浮點數除法。例如 ``5 / 2 == 2``，而非 ``2.5``。如果不希望這樣，請至少使用一"
"個 :ref:`浮點數 <class_float>` 字面值 (``x / 2.0``)、轉型 (``float(x) / "
"y``)，或乘以 ``1.0`` (``x * 1.0 / y``)。"

msgid ""
"The ``%`` operator is only available for ints, for floats use "
"the :ref:`fmod() <class_@GlobalScope_method_fmod>` function."
msgstr ""
"``%`` 運算子僅可用於整數，對於浮點數請使用 :ref:`fmod() "
"<class_@GlobalScope_method_fmod>` 函式。"

msgid ""
"For negative values, the ``%`` operator and ``fmod()`` use `truncation "
"<https://en.wikipedia.org/wiki/Truncation>`_ instead of rounding towards "
"negative infinity. This means that the remainder has a sign. If you need the "
"remainder in a mathematical sense, use the :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` and :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` functions instead."
msgstr ""
"對於負值，``%`` 運算子和 ``fmod()`` 使用 `截斷 <https://en.wikipedia.org/"
"wiki/Truncation>`_ 而非向負無限大捨去。這表示餘數會帶有正負號。如果您需要數學"
"意義上的餘數，請改用 :ref:`posmod() <class_@GlobalScope_method_posmod>` "
"和 :ref:`fposmod() <class_@GlobalScope_method_fposmod>` 函數。"

msgid ""
"The ``==`` and ``!=`` operators sometimes allow you to compare values of "
"different types (for example, ``1 == 1.0`` is true), but in other cases it "
"can cause a runtime error. If you're not sure about the types of the "
"operands, you can safely use the :ref:`is_same() "
"<class_@GlobalScope_method_is_same>` function (but note that it is more "
"strict about types and references). To compare floats, use "
"the :ref:`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` "
"and :ref:`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` "
"functions instead."
msgstr ""
"``==`` 和 ``!=`` 運算子有時允許您比較不同型別的值 (例如，``1 == 1.0`` 為真)，"
"但在其他情況下它可能會導致執行階段錯誤。如果您不確定運算元的型別，您可以安全"
"地使用 :ref:`is_same() <class_@GlobalScope_method_is_same>` 函式 (但請注意，"
"它對型別和參照更嚴格)。若要比較浮點數，請改用 :ref:`is_equal_approx() "
"<class_@GlobalScope_method_is_equal_approx>` 和 :ref:`is_zero_approx() "
"<class_@GlobalScope_method_is_zero_approx>` 函式。"

msgid "Literals"
msgstr "字面值"

msgid "**Example(s)**"
msgstr "**範例**"

msgid "``null``"
msgstr "``null``"

msgid "Null value"
msgstr "空值"

msgid "``false``, ``true``"
msgstr "``false``、``true``"

msgid "Boolean values"
msgstr "布林值"

msgid "``45``"
msgstr "``45``"

msgid "Base 10 integer"
msgstr "10 進位整數"

msgid "``0x8f51``"
msgstr "``0x8f51``"

msgid "Base 16 (hexadecimal) integer"
msgstr "16 進位整數"

msgid "``0b101010``"
msgstr "``0b101010``"

msgid "Base 2 (binary) integer"
msgstr "2 進位整數"

msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14`` 、 ``58.1e-10``"

msgid "Floating-point number (real)"
msgstr "浮點數（實數）"

msgid "``\"Hello\"``, ``'Hi'``"
msgstr "``\"Hello\"`` 、 ``\"Hi\"``"

msgid "Regular strings"
msgstr "一般字串"

msgid "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"
msgstr "``\"\"\"Hello\"\"\"``、``'''Hi'''``"

msgid "Triple-quoted regular strings"
msgstr "三重引號一般字串"

msgid "``r\"Hello\"``, ``r'Hi'``"
msgstr "``r\"Hello\"``、``r'Hi'``"

msgid "Raw strings"
msgstr "原始字串"

msgid "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"
msgstr "``r\"\"\"Hello\"\"\"``、``r'''Hi'''``"

msgid "Triple-quoted raw strings"
msgstr "三重引號原始字串"

msgid "``&\"name\"``"
msgstr "``&\"name\"``"

msgid ":ref:`StringName <class_StringName>`"
msgstr ":ref:`StringName <class_StringName>`"

msgid "``^\"Node/Label\"``"
msgstr "``@\"Node/Label\"``"

msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

msgid ""
"There are also two constructs that look like literals, but actually are not:"
msgstr "另外還有兩種寫法看起來像字面值，但其實不是："

msgid "**Example**"
msgstr "**範例**"

msgid "``$NodePath``"
msgstr "``$NodePath``"

msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "``get_node(\"NodePath\")`` 的簡寫"

msgid "``%UniqueNode``"
msgstr "``%UniqueNode``"

msgid "Shorthand for ``get_node(\"%UniqueNode\")``"
msgstr "``get_node(\"NodePath\")`` 的簡寫"

msgid ""
"Integers and floats can have their numbers separated with ``_`` to make them "
"more readable. The following ways to write numbers are all valid:"
msgstr "整數與浮點數可以用 ``_`` 分隔以提升可讀性。以下數字寫法皆有效："

msgid "**Regular string literals** can contain the following escape sequences:"
msgstr "**一般字串常值** 可以包含以下逸出序列："

msgid "**Escape sequence**"
msgstr "**逸出序列**"

msgid "**Expands to**"
msgstr "**會被解析為**"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Newline (line feed)"
msgstr "換行 (LF)"

msgid "``\\t``"
msgstr "``\\t``"

msgid "Horizontal tab character"
msgstr "水平 TAB 字元"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage return"
msgstr "歸位字元"

msgid "``\\a``"
msgstr "``\\a``"

msgid "Alert (beep/bell)"
msgstr "警告 (警示嗶聲/鈴聲)"

msgid "``\\b``"
msgstr "``\\b``"

msgid "Backspace"
msgstr "倒退鍵"

msgid "``\\f``"
msgstr "``\\f``"

msgid "Formfeed page break"
msgstr "Formfeed 分頁字元"

msgid "``\\v``"
msgstr "``\\v``"

msgid "Vertical tab character"
msgstr "縱向 TAB 字元"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote"
msgstr "雙引號"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote"
msgstr "單引號"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash"
msgstr "反斜線"

msgid "``\\uXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-16 Unicode codepoint ``XXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode 字碼指標 ``XXXX`` (16進位，不區分大小寫)"

msgid "``\\UXXXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-32 Unicode codepoint ``XXXXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode 字碼指標 ``XXXX`` (16進位，不區分大小寫)"

msgid ""
"There are two ways to represent an escaped Unicode character above "
"``0xFFFF``:"
msgstr "對於高於 ``0xFFFF`` 的 Unicode 字元，有兩種逸出方式："

msgid ""
"as a `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."
msgstr ""
"以 `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."

msgid "as a single UTF-32 codepoint ``\\UXXXXXX``."
msgstr "以 single UTF-32 碼位 ``\\UXXXXXX``."

msgid ""
"Also, using ``\\`` followed by a newline inside a string will allow you to "
"continue it in the next line, without inserting a newline character in the "
"string itself."
msgstr ""
"此外，在字串中使用“\\”後跟換行符將允許您在下一行中繼續它，而無需在字串本身中"
"插入換行符。"

msgid ""
"A string enclosed in quotes of one type (for example ``\"``) can contain "
"quotes of another type (for example ``'``) without escaping. Triple-quoted "
"strings allow you to avoid escaping up to two consecutive quotes of the same "
"type (unless they are adjacent to the string edges)."
msgstr ""
"被一種引號包住的字串（例如 ``\"``）可以直接包含另一種引號（例如 ``'``）而無須"
"逸出。三重引號字串允許你避免逸出至多兩個連續同型的引號（除非這些引號位於字串"
"開頭或結尾）。"

msgid ""
"**Raw string literals** always encode the string as it appears in the source "
"code. This is especially useful for regular expressions. A raw string "
"literal doesn't process escape sequences, however it does recognize ``\\\\`` "
"and ``\\\"`` (``\\'``) and replaces them with themselves. Thus, a string can "
"have a quote that matches the opening one, but only if it's preceded by a "
"backslash."
msgstr ""
"**原始字串** 會如原始碼寫法完整編碼，不處理逸出序列，非常適合正則表達式使用。"
"原始字串只會對 ``\\\\`` 及 ``\\\"``（或 ``\\'``）做逸出處理，也就是說，字串內"
"可以有一個跟起始相同的引號，只要前面有加反斜線即可。"

msgid ""
"Some strings cannot be represented using raw string literals: you cannot "
"have an odd number of backslashes at the end of a string or have an "
"unescaped opening quote inside the string. However, in practice this doesn't "
"matter since you can use a different quote type or use concatenation with a "
"regular string literal."
msgstr ""
"有些字串無法用原始字串表示：例如字串結尾不能有奇數個反斜線，也不能在字串內直"
"接出現未逸出的起始引號。不過實務上可以改用另一種引號或與一般字串串接即可解"
"決。"

msgid "GDScript also supports :ref:`format strings <doc_gdscript_printf>`."
msgstr "GDScript 亦支援 :ref:`doc_gdscript_printf` 。"

msgid "Annotations"
msgstr "註釋"

msgid ""
"Annotations are special tokens in GDScript that act as modifiers to a script "
"or its code and may affect how the script is treated by the Godot engine or "
"editor."
msgstr ""
"註解（annotation）是 GDScript 的特殊標記，用於修飾腳本或程式碼，可能會影響 "
"Godot 引擎或編輯器對腳本的處理方式。"

msgid ""
"Every annotation starts with the ``@`` character and is specified by a name. "
"A detailed description and example for each annotation can be found inside "
"the :ref:`GDScript class reference <class_@GDScript>`."
msgstr ""
"每個註解（Annotation）都以 ``@`` 字元開頭，並以名稱指定。每個註解的詳細說明與"
"範例，請參閱 :ref:`GDScript 類別參考 <class_@GDScript>`。"

msgid "For instance, you can use it to export a value to the editor:"
msgstr "例如，你可以使用它將值匯出到編輯器："

msgid ""
"For more information about exporting properties, read the :ref:`GDScript "
"exports <doc_gdscript_exports>` article."
msgstr "有關匯出的說明文件已移至 :ref:`doc_gdscript_exports` 。"

msgid ""
"Any constant expression compatible with the required argument type can be "
"passed as an annotation argument value:"
msgstr "任何與所需參數型別相容的常數運算式，都可以作為註解的參數值傳入："

msgid ""
"Annotations can be specified one per line or all in the same line. They "
"affect the next statement that isn't an annotation. Annotations can have "
"arguments sent between parentheses and separated by commas."
msgstr ""
"可以在每行指定一個註釋，也可以在同一行中指定所有註釋。它們影響下一個不是註釋"
"的敘述。註釋可以將參數傳送到括號之間並用逗號分隔。"

msgid "Both of these are the same:"
msgstr "兩者相同："

msgid "``@onready`` annotation"
msgstr "“@onready”註釋"

msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to ``Node._ready()`` is made."
msgstr ""
"使用節點時，我們通常會想以變數來參照到場景的某個部分。由於場景只有在進入有效"
"場景樹後才能保證有正確配置，所以在 ``Node._ready()`` 呼叫後才能取得子節點。"

msgid ""
"This can get a little cumbersome, especially when nodes and external "
"references pile up. For this, GDScript has the ``@onready`` annotation, that "
"defers initialization of a member variable until ``_ready()`` is called. It "
"can replace the above code with a single line:"
msgstr ""
"這麼做會有些繁瑣，尤其當節點與外部參照愈來愈多時。為此，GDScript 提供 "
"``@onready`` 註解，會將成員變數的初始化延後到 ``_ready()`` 被呼叫時再進行。它"
"可以用一行程式碼取代上述寫法："

msgid ""
"Applying ``@onready`` and any ``@export`` annotation to the same variable "
"doesn't work as you might expect. The ``@onready`` annotation will cause the "
"default value to be set after the ``@export`` takes effect and will override "
"it:"
msgstr ""
"將 ``@onready`` 與任何 ``@export`` 同時套用到同一個變數，結果可能不如預期。"
"``@onready`` 會在 ``@export`` 生效之後才設定預設值，進而覆蓋它："

msgid ""
"Therefore, the ``ONREADY_WITH_EXPORT`` warning is generated, which is "
"treated as an error by default. We do not recommend disabling or ignoring it."
msgstr ""
"因此，會產生“ONREADY_WITH_EXPORT”警告，預設將其視為錯誤。我們不建議禁用或忽略"
"它。"

msgid "Comments"
msgstr "注釋"

msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr "從 ``#`` 開始到行未的所有東西都會被忽略並當作註解。"

msgid ""
"In the Godot script editor, special keywords are highlighted within comments "
"to bring the user's attention to specific comments:"
msgstr ""
"在 Godot 腳本編輯器內，特定註解關鍵字會被高亮顯示，以提醒使用者注意特定註解："

msgid ""
"**Critical** *(appears in red)*: ``ALERT``, ``ATTENTION``, ``CAUTION``, "
"``CRITICAL``, ``DANGER``, ``SECURITY``"
msgstr ""
"**重大** *(紅色顯示)*：``ALERT``、``ATTENTION``、``CAUTION``、``CRITICAL``、"
"``DANGER``、``SECURITY``"

msgid ""
"**Warning** *(appears in yellow)*: ``BUG``, ``DEPRECATED``, ``FIXME``, "
"``HACK``, ``TASK``, ``TBD``, ``TODO``, ``WARNING``"
msgstr ""
"**警告** *(黃色顯示)*：``BUG``、``DEPRECATED``、``FIXME``、``HACK``、"
"``TASK``、``TBD``、``TODO``、``WARNING``"

msgid ""
"**Notice** *(appears in green)*: ``INFO``, ``NOTE``, ``NOTICE``, ``TEST``, "
"``TESTING``"
msgstr ""
"**通知** *(綠色顯示)*：``INFO``、``NOTE``、``NOTICE``、``TEST``、``TESTING``"

msgid ""
"These keywords are case-sensitive, so they must be written in uppercase for "
"them to be recognized:"
msgstr "這些關鍵字區分大小寫，必須以全大寫才能被辨識："

msgid ""
"The list of highlighted keywords and their colors can be changed in the "
"**Text Editor > Theme > Comment Markers** section of the Editor Settings."
msgstr ""
"這些高亮關鍵字及其顏色可以在「**文字編輯器 > 主題 > 註解標記**」裡自訂。"

msgid ""
"Use two hash symbols (``##``) instead of one (``#``) to add a *documentation "
"comment*, which will appear in the script documentation and in the inspector "
"description of an exported variable. Documentation comments must be placed "
"directly *above* a documentable item (such as a member variable), or at the "
"top of a file. Dedicated formatting options are also available. "
"See :ref:`doc_gdscript_documentation_comments` for details."
msgstr ""
"使用兩個井字號（``##``）而非一個（``#``）可以新增 *說明註解*，這類註解會顯示"
"於腳本說明檔與 Inspector 的說明欄位。說明註解必須直接放在可文件化項目（如成員"
"變數）上方，或檔案最前面。也有專用的格式化功能，詳"
"見 :ref:`doc_gdscript_documentation_comments`。"

msgid "Code regions"
msgstr "程式碼區段"

msgid ""
"Code regions are special types of comments that the script editor "
"understands as *foldable regions*. This means that after writing code region "
"comments, you can collapse and expand the region by clicking the arrow that "
"appears at the left of the comment. This arrow appears within a purple "
"square to be distinguishable from standard code folding."
msgstr ""
"程式碼區段是一種特殊註解，讓腳本編輯器可辨識為 *可摺疊區塊*。寫下這類註解後，"
"可透過點擊註解左側的箭頭摺疊或展開區段。這個箭頭會顯示在紫色方框中，與一般程"
"式碼摺疊做區別。"

msgid "The syntax is as follows:"
msgstr "語法如下："

msgid ""
"To create a code region quickly, select several lines in the script editor, "
"right-click the selection then choose **Create Code Region**. The region "
"description will be selected automatically for editing."
msgstr ""
"若要快速建立程式區塊，可在腳本編輯器中選取多行，右鍵點擊後選擇 **建立程式區塊"
"**。區塊描述會自動選取以便編輯。"

msgid "It is possible to nest code regions within other code regions."
msgstr "程式區塊可相互巢狀。"

msgid "Here's a concrete usage example of code regions:"
msgstr "以下是一個程式碼區塊的具體使用範例："

msgid ""
"This can be useful to organize large chunks of code into easier to "
"understand sections. However, remember that external editors generally don't "
"support this feature, so make sure your code is easy to follow even when not "
"relying on folding code regions."
msgstr ""
"這功能可幫助你將大量程式碼整理成較易理解的區段。不過請注意，外部編輯器通常不"
"支援這個功能，因此請確保你的程式碼在未使用這功能時也能易於閱讀。"

msgid ""
"Individual functions and indented sections (such as ``if`` and ``for``) can "
"*always* be collapsed in the script editor. This means you should avoid "
"using a code region to contain a single function or indented section, as it "
"won't bring much of a benefit. Code regions work best when they're used to "
"group multiple elements together."
msgstr ""
"個別函式與縮排區塊（如 ``if``、``for``）在腳本編輯器中本來就可以摺疊。因此不"
"建議用程式碼區段包住單一函式或縮排區塊，這樣效果有限。程式碼區段最適合用來群"
"組多個相關區塊。"

msgid "Line continuation"
msgstr "程式碼樣式設定"

msgid ""
"A line of code in GDScript can be continued on the next line by using a "
"backslash (``\\``). Add one at the end of a line and the code on the next "
"line will act like it's where the backslash is. Here is an example:"
msgstr ""
"GDScript 中的一行代碼可以使用反斜杠 （''\\'） 在下一行繼續。在一行末尾添加一"
"個，下一行上的程式碼將像反斜杠一樣。下面是一個示例："

msgid "A line can be continued multiple times like this:"
msgstr "一行可以連續多次，如下圖所示："

msgid "Built-in types"
msgstr "內建型別"

msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The exceptions are ``Object``, ``Array``, ``Dictionary``, and "
"packed arrays (such as ``PackedByteArray``), which are passed by reference "
"so they are shared. All arrays, ``Dictionary``, and some objects (``Node``, "
"``Resource``) have a ``duplicate()`` method that allows you to make a copy."
msgstr ""
"內建型別為堆疊配置（stack-allocated），傳遞時以值傳遞。也就是每次賦值或作為參"
"數傳給函式時都會建立一份副本。例外的是 ``Object``、``Array``、``Dictionary`` "
"與 Packed 陣列（如 ``PackedByteArray``），這些是以參考傳遞，所以內容會共用。"
"所有陣列、``Dictionary`` 以及某些物件（如 ``Node``、``Resource``）皆有 "
"``duplicate()`` 方法可用來複製。"

msgid "Basic built-in types"
msgstr "基礎內建型別"

msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "GDScript 的變數可以被指派為多種內建型別。"

msgid "null"
msgstr "null"

msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr "``null`` 是一個沒有包含任何資訊的空資料型別，不能指派為其他任何的值。"

msgid ""
"Only types that inherit from Object can have a ``null`` value (Object is "
"therefore called a \"nullable\" type). :ref:`Variant types "
"<doc_variant_class>` must have a valid value at all times, and therefore "
"cannot have a ``null`` value."
msgstr ""
"只有繼承自 Object 的型別才能有 ``null`` 值（Object 因此稱為「可為 null」型"
"別）。:ref:`Variant 型別 <doc_variant_class>` 必須始終有有效值，因此不可為 "
"``null``。"

msgid ":ref:`bool <class_bool>`"
msgstr ":ref:`bool <class_bool>`"

msgid "Short for \"boolean\", it can only contain ``true`` or ``false``."
msgstr "「布林 (Boolean)」的縮寫，只會是 ``true`` 或 ``false`` 。"

msgid ":ref:`int <class_int>`"
msgstr ":ref:`int <class_int>`"

msgid ""
"Short for \"integer\", it stores whole numbers (positive and negative). It "
"is stored as a 64-bit value, equivalent to ``int64_t`` in C++."
msgstr ""
"「整數 (Interger)」的縮寫。可以保存整數（正數與負數）。可以儲存 64 位元的值，"
"相當於 C++ 的「int64_t」。"

msgid ":ref:`float <class_float>`"
msgstr ":ref:`float <class_float>`"

msgid ""
"Stores real numbers, including decimals, using floating-point values. It is "
"stored as a 64-bit value, equivalent to ``double`` in C++. Note: Currently, "
"data structures such as ``Vector2``, ``Vector3``, and ``PackedFloat32Array`` "
"store 32-bit single-precision ``float`` values."
msgstr ""
"使用浮點數值，儲存包含小數的實數。保存為 64 位元的數值，相當於 C++ 中的「倍精"
"確 (double)」型別。注意：目前，如 Vector2、Vector3、與 PoolRealArray 資料結構"
"都儲存 32 位元的單精確「float（浮點）」值。"

msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

msgid ""
"A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/"
"Unicode>`_."
msgstr ""
"一串 `Unicode 格式 <https://zh.wikipedia.org/zh-tw/Unicode>`_ 的字元序列。"

msgid ""
"An immutable string that allows only one instance of each name. They are "
"slower to create and may result in waiting for locks when multithreading. In "
"exchange, they're very fast to compare, which makes them good candidates for "
"dictionary keys."
msgstr ""
"一個不可變的字串，僅允許每個名稱有一個實例。它們的建立速度較慢，並且可能會導"
"致在多執行緒時等待鎖。作為交換，它們的比較速度非常快，這使得它們成為字典鍵的"
"良好候選者。"

msgid ""
"A pre-parsed path to a node or a node property.  It can be easily assigned "
"to, and from, a String. They are useful to interact with the tree to get a "
"node, or affecting properties like with :ref:`Tweens <class_Tween>`."
msgstr ""
"節點或節點屬性的預先解析路徑，可以輕鬆地與 String 互相轉換。常用於在場景樹中"
"取得節點，或操作 :ref:`Tween <class_Tween>` 等需要指定路徑的功能。"

msgid "Vector built-in types"
msgstr "內建向量型別"

msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as an "
"array."
msgstr "2D 向量包含 ``x`` 與 ``y`` 欄位。也能用與陣列一樣的方式存取。"

msgid ":ref:`Vector2i <class_Vector2i>`"
msgstr ":ref:`Vector2i <class_Vector2i>`"

msgid ""
"Same as a Vector2 but the components are integers. Useful for representing "
"items in a 2D grid."
msgstr "與 Vector2 相同，但分量是整數。對於表示 2D 網格中的專案很有用。"

msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Also contains an ``end`` field which is ``position + size``."
msgstr ""
"2D 矩形包含兩個向量欄位 ``position`` （位置）與 ``size`` （大小）。也包含了一"
"個 ``end`` 欄位，為 ``position + size`` 。"

msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr ""
"3D 向量包含 ``x`` 、 ``y`` 、與 ``z`` 欄位。也能用與陣列一樣的方式存取。"

msgid ":ref:`Vector3i <class_Vector3i>`"
msgstr ":ref:`Vector3i <class_Vector3i>`"

msgid ""
"Same as Vector3 but the components are integers. Can be use for indexing "
"items in a 3D grid."
msgstr "與 Vector3 相同，但分量是整數。可用於對 3D 網格中的專案進行索引。"

msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

msgid "3×2 matrix used for 2D transforms."
msgstr "用於 2D 幾何變換的 3×2 矩陣。"

msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr "包含 ``normal`` 向量欄位與 ``d`` 常數距離的標準形式的 3D 平面型別。"

msgid ":ref:`Quaternion <class_Quaternion>`"
msgstr ":ref:`Quaternion <class_Quaternion>`"

msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr ""
"四元數 (Quaternion) 是一種用於表示 3D 旋轉的資料型別。進行內插旋轉時很有用。"

msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Also contains an ``end`` field which is "
"``position + size``."
msgstr ""
"座標軸對齊定界框 (AABB, Axis-aligned Bounding Box)，或稱為 3D 框 (3D Box)，包"
"含了兩個向量欄位： ``position`` （位置）與 ``size`` （大小）。也包含了一個 "
"``end`` 欄位，即為 ``position + size`` 。"

msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"用於 3D 旋轉與縮放的 3x3 矩陣。包含了三個向量欄位（ ``x`` 、 ``y`` 、與 "
"``z`` ），一樣可以視為 3D 向量的陣列的來存取。"

msgid ":ref:`Transform3D <class_Transform3D>`"
msgstr ":ref:`Transform3D <class_Transform3D>`"

msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr ""
"3D 變換包含了一個 Basis 欄位 ``basis`` 以及一個 Vector3 欄位 ``origin`` 。"

msgid "Engine built-in types"
msgstr "引擎內建型別"

msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"色彩資料型別包含 ``r`` 、 ``g`` 、 ``b`` 、與 ``a`` 欄位。也可以存取 "
"``h`` 、 ``s`` 、與 ``v`` ，代表色相 (Hue) ／飽和度 (Saturation)／明度 "
"(Value)。"

msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr "資源 ID (RID, Resource ID)。伺服器使用通用 RID 來參照不透明資料。"

msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

msgid "Base class for anything that is not a built-in type."
msgstr "所有非內建型別的基礎類別。"

msgid "Container built-in types"
msgstr "內建容器型別"

msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Negative indices count from the end."
msgstr ""
"可包含任意物件型別，也包含其他陣列或字典型別（詳見下方）。陣列的大小可以動態"
"調整。陣列的索引從 ``0`` 開始。若使用負數索引則自尾端開始。"

msgid "Typed arrays"
msgstr "切線陣列"

msgid ""
"Godot 4.0 added support for typed arrays. On write operations, Godot checks "
"that element values match the specified type, so the array cannot contain "
"invalid values. The GDScript static analyzer takes typed arrays into "
"account, however array methods like ``front()`` and ``back()`` still have "
"the ``Variant`` return type."
msgstr ""
"Godot 4.0 新增了對型別陣列的支援。在寫入操作中，Godot 檢查元素值是否與指定型"
"別配對，因此陣列不能包含無效值。 GDScript 靜態分析器考慮型別化陣列，但像"
"「front()」和「back()」這樣的陣列方法仍然具有「Variant」回傳型別。"

msgid ""
"Typed arrays have the syntax ``Array[Type]``, where ``Type`` can be any "
"``Variant`` type, native or user class, or enum. Nested array types (like "
"``Array[Array[int]]``) are not supported."
msgstr ""
"型別化陣列的語法為“Array[Type]”，其中“Type”可以是任何“Variant”型別、本機類"
"別、使用者類別或列舉。不支援巢狀陣列型別（如“Array[Array[int]]”）。"

msgid "``Array`` and ``Array[Variant]`` are the same thing."
msgstr "``Array`` 和 ``Array[Variant]`` 是同一件事。"

msgid ""
"Arrays are passed by reference, so the array element type is also an "
"attribute of the in-memory structure referenced by a variable in runtime. "
"The static type of a variable restricts the structures that it can reference "
"to. Therefore, you **cannot** assign an array with a different element type, "
"even if the type is a subtype of the required type."
msgstr ""
"陣列是透過引用傳遞的，因此陣列元素型別也是運作時變數引用的記憶體結構的屬性。"
"變數的靜態型別限制了它可以引用的結構。因此，您**不能**為陣列指派不同的元素型"
"別，即使該型別是所需型別的子型別。"

msgid ""
"If you want to *convert* a typed array, you can create a new array and use "
"the :ref:`Array.assign() <class_Array_method_assign>` method:"
msgstr ""
"如果你想要 *轉換* 具型別陣列, 可以建立一個新陣列並使用 :ref:`Array.assign() "
"<class_Array_method_assign>` 方法:"

msgid ""
"The only exception was made for the ``Array`` (``Array[Variant]``) type, for "
"user convenience and compatibility with old code. However, operations on "
"untyped arrays are considered unsafe."
msgstr ""
"唯一的例外是“Array”（“Array[Variant]”）型別，以方便使用者並與舊程式碼相容。但"
"是，對無型別陣列的操作被認為是不安全的。"

msgid "Packed arrays"
msgstr "本地坐標"

msgid ""
"PackedArrays are generally faster to iterate on and modify compared to a "
"typed Array of the same type (e.g. PackedInt64Array versus Array[int]) and "
"consume less memory. In the worst case, they are expected to be as fast as "
"an untyped Array. Conversely, non-Packed Arrays (typed or not) have extra "
"convenience methods such as :ref:`Array.map <class_Array_method_map>` that "
"PackedArrays lack. Consult the :ref:`class reference "
"<class_PackedFloat32Array>` for details on the methods available. Typed "
"Arrays are generally faster to iterate on and modify than untyped Arrays."
msgstr ""
"Packed 陣列通常比同型別的型別化 Array（如 PackedInt64Array 對 Array[int]）更"
"快，且佔用更少記憶體。最差情況下，其速度也應與未型別化 Array 相當。相對地，"
"非 Packed 陣列（不論是否型別化）則有更多方便的方法（如 :ref:`Array.map "
"<class_Array_method_map>`），而 Packed 陣列沒有。詳細可查閱 :ref:`class "
"reference <class_PackedFloat32Array>`。型別化 Array 通常也比未型別化 Array 有"
"更佳的操作效能。"

msgid ""
"While all Arrays can cause memory fragmentation when they become large "
"enough, if memory usage and performance (iteration and modification speed) "
"is a concern and the type of data you're storing is compatible with one of "
"the ``Packed`` Array types, then using those may yield improvements. "
"However, if you do not have such concerns (e.g. the size of your array does "
"not reach the tens of thousands of elements) it is likely more helpful to "
"use regular or typed Arrays, as they provide convenience methods that can "
"make your code easier to write and maintain (and potentially faster if your "
"data requires such operations a lot). If the data you will store is of a "
"known type (including your own defined classes), prefer to use a typed Array "
"as it may yield better performance in iteration and modification compared to "
"an untyped Array."
msgstr ""
"所有 Array 若足夠大都可能造成記憶體碎裂。若你在意記憶體用量與效能（特別是遍歷"
"與修改速度），且資料型別能對應到 Packed Array，建議優先使用 Packed Array。若"
"沒有這些需求（例如你的陣列不超過數萬筆），可以直接用一般 Array 或型別化 "
"Array，因為它們有更多方便的方法讓程式更好寫、更易維護（若常用這些操作也可能較"
"快）。若資料型別已知（包含自訂類別），建議使用型別化 Array，通常遍歷與修改效"
"能會優於未型別化 Array。"

msgid ""
":ref:`PackedByteArray <class_PackedByteArray>`: An array of bytes (integers "
"from 0 to 255)."
msgstr ""
":ref:`PackedByteArray <class_PackedByteArray>` ：位元組的陣列（0 至 255 的整"
"數）。"

msgid ""
":ref:`PackedInt32Array <class_PackedInt32Array>`: An array of 32-bit "
"integers."
msgstr ":ref:`PackedInt32Array <class_PackedInt32Array>` : 32 位元整數的陣列。"

msgid ""
":ref:`PackedInt64Array <class_PackedInt64Array>`: An array of 64-bit "
"integers."
msgstr ""
":ref:`壓縮 64 位元整數陣列 <class_PackedInt64Array>` ： 64 位元整數的陣列。"

msgid ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: An array of 32-bit "
"floats."
msgstr ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: 32 位元浮點數的陣列。"

msgid ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`: An array of 64-bit "
"floats."
msgstr ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>` : 64 位元浮點數的陣列。"

msgid ""
":ref:`PackedStringArray <class_PackedStringArray>`: An array of strings."
msgstr ":ref:`PackedStringArray <class_PackedStringArray>` ： 字串陣列。"

msgid ""
":ref:`PackedVector2Array <class_PackedVector2Array>`: An array "
"of :ref:`Vector2 <class_Vector2>` values."
msgstr ""
":ref:`PackedVector2Array <class_PackedVector2Array>` ： :ref:`Vector2 "
"<class_Vector2>` 的陣列。"

msgid ""
":ref:`PackedVector3Array <class_PackedVector3Array>`: An array "
"of :ref:`Vector3 <class_Vector3>` values."
msgstr ""
":ref:`PackedVector3Array <class_PackedVector3Array>` ： :ref:`Vector3 "
"<class_Vector3>` 的陣列。"

msgid ""
":ref:`PackedVector4Array <class_PackedVector4Array>`: An array "
"of :ref:`Vector4 <class_Vector4>` values."
msgstr ""
":ref:`PackedVector4Array <class_PackedVector4Array>` ： :ref:`Vector4 "
"<class_Vector4>` 值的陣列。"

msgid ""
":ref:`PackedColorArray <class_PackedColorArray>`: An array of :ref:`Color "
"<class_Color>` values."
msgstr ""
":ref:`PackedColorArray <class_PackedColorArray>` ： :ref:`Color "
"<class_Color>` 值的陣列。"

msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

msgid "Associative container which contains values referenced by unique keys."
msgstr "可以包含以獨立 Key 參照數值的關聯式容器。"

msgid ""
"Lua-style table syntax is also supported. Lua-style uses ``=`` instead of "
"``:`` and doesn't use quotes to mark string keys (making for slightly less "
"to write). However, keys written in this form can't start with a digit (like "
"any GDScript identifier), and must be string literals."
msgstr ""
"也支援 Lua 風格的表格語法。Lua 風格用 ``=`` 取代 ``:``，且字串鍵不需加引號"
"（可少寫一點）。不過這種寫法的鍵不能以數字開頭（如同 GDScript 識別字），且必"
"須是字串常值。"

msgid ""
"To add a key to an existing dictionary, access it like an existing key and "
"assign to it:"
msgstr "要為現有的字典新增鍵，像存取既有鍵一樣存取並賦值即可："

msgid ""
"The bracket syntax can be used to access properties of "
"any :ref:`class_Object`, not just Dictionaries. Keep in mind it will cause a "
"script error when attempting to index a non-existing property. To avoid "
"this, use the :ref:`Object.get() <class_Object_method_get>` "
"and :ref:`Object.set() <class_Object_method_set>` methods instead."
msgstr ""
"方括號語法不僅可用於 Dictionary，也可用來存取任何 :ref:`class_Object` 的屬"
"性。請記得當嘗試存取不存在的屬性時會導致腳本錯誤。要避免錯誤，請使"
"用 :ref:`Object.get() <class_Object_method_get>` 與 :ref:`Object.set() "
"<class_Object_method_set>` 替代。"

msgid "Typed dictionaries"
msgstr "具型別字典"

msgid ""
"Godot 4.4 added support for typed dictionaries. On write operations, Godot "
"checks that element keys and values match the specified type, so the "
"dictionary cannot contain invalid keys or values. The GDScript static "
"analyzer takes typed dictionaries into account. However, dictionary methods "
"that return values still have the ``Variant`` return type."
msgstr ""
"Godot 4.4 新增對具型別字典的支援。在寫入操作時，Godot 會檢查元素的鍵與值是否"
"符合指定型別，因此字典不會包含無效的鍵或值。GDScript 的靜態分析器也會考慮具型"
"別字典。不過，回傳值的字典方法其回傳型別仍然是 ``Variant``。"

msgid ""
"Typed dictionaries have the syntax ``Dictionary[KeyType, ValueType]``, where "
"``KeyType`` and ``ValueType`` can be any ``Variant`` type, native or user "
"class, or enum. Both the key and value type **must** be specified, but you "
"can use ``Variant`` to make either of them untyped. Nested typed collections "
"(like ``Dictionary[String, Dictionary[String, int]]``) are not supported."
msgstr ""
"具型別字典的語法為 ``Dictionary[KeyType, ValueType]`` , 其中 ``KeyType`` 與 "
"``ValueType`` 可以是任何 ``Variant`` 型別、內建或使用者類別, 或列舉。鍵與值的"
"型別都 **必須** 指定, 但你可以使用 ``Variant`` 讓其中之一不指定型別。目前不支"
"援巢狀的具型別集合 (例如 ``Dictionary[String, Dictionary[String, int]]``)。"

msgid "``Dictionary`` and ``Dictionary[Variant, Variant]`` are the same thing."
msgstr "``Dictionary`` 與 ``Dictionary[Variant, Variant]`` 是同一回事。"

msgid ":ref:`Signal <class_Signal>`"
msgstr ":ref:`Signal <class_Signal>`"

msgid ""
"A signal is a message that can be emitted by an object to those who want to "
"listen to it. The Signal type can be used for passing the emitter around."
msgstr "訊號是物件可以向想要收聽它的人發出的訊息。訊號型別可用於傳遞發射器。"

msgid ""
"Signals are better used by getting them from actual objects, e.g. "
"``$Button.button_up``."
msgstr "透過從實際物件獲取訊號可以更好地使用它們，例如“$Button.button_up”。"

msgid ":ref:`Callable <class_Callable>`"
msgstr ":ref:`Callable <class_Callable>`"

msgid ""
"Contains an object and a function, which is useful for passing functions as "
"values (e.g. when connecting to signals)."
msgstr ""
"包含一個物件和一個函式，這對於將函式作為值傳遞非常有用（例如，連接到訊號"
"時）。"

msgid ""
"Getting a method as a member returns a callable. ``var x = "
"$Sprite2D.rotate`` will set the value of ``x`` to a callable with "
"``$Sprite2D`` as the object and ``rotate`` as the method."
msgstr ""
"取得一個方法作為成員會傳回一個可呼叫物件。 ``var x = $Sprite2D.rotate`` 會將"
"``x`` 的值設為可呼叫的對象，其中``$Sprite2D`` 作為對象，``rotate`` 作為方法。"

msgid "You can call it using the ``call`` method: ``x.call(PI)``."
msgstr "您可以使用“call”方法來呼叫它：“x.call(PI)”。"

msgid "Variables"
msgstr "變數"

msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"變數可以作為類別成員或函式的區域變數存在。變數使用 ``var`` 關鍵字建立，並且可"
"選擇性地在初始化時賦值。"

msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"變數也可選擇性地指定型別。當指定型別，變數將強制必須維持相同型別，當試著指派"
"不相容的型別會造成錯誤。"

msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr "在變數宣告時在變數名稱後使用 ``:`` （冒號）接上型別來執行型別。"

msgid ""
"If the variable is initialized within the declaration, the type can be "
"inferred, so it's possible to omit the type name:"
msgstr "若變數在宣告時就初始化，型別可以被推斷，因此可以省略型別名稱："

msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr "型別推定僅可於指派的值有定義型別時發生，否則將發生錯誤。"

msgid "Valid types are:"
msgstr "有效的型別為："

msgid "Built-in types (Array, Vector2, int, String, etc.)."
msgstr "內建型別（Array、Vector2、int、String…等）。"

msgid "Engine classes (Node, Resource, RefCounted, etc.)."
msgstr "引擎類別（Node、Resource、RefCounted 等）。"

msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"常數名稱，若該常數包含腳本資源（若宣告 ``const MyScript = preload(\"res://"
"my_script.gd\")`` 則可使用 ``MyScript`` ）。"

msgid ""
"Other classes in the same script, respecting scope "
"(``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the "
"``class InnerClass`` in the same scope)."
msgstr ""
"在相同腳本內的其他類別，尊重作用域（ ``InnerClass.NestedClass`` 若在 ``class "
"InnerClass`` 內宣告 ``class NextedClass`` 則為相同作用域）。"

msgid "Script classes declared with the ``class_name`` keyword."
msgstr "使用 ``class_name`` 關鍵字宣告的腳本類別。"

msgid "Autoloads registered as singletons."
msgstr "自動加載註冊為單例。"

msgid ""
"While ``Variant`` is a valid type specification, it's not an actual type. It "
"only means there's no set type and is equivalent to not having a static type "
"at all. Therefore, inference is not allowed by default for ``Variant``, "
"since it's likely a mistake."
msgstr ""
"雖然「Variant」是有效的型別規範，但它不是實際的型別。它僅意味著沒有設定型別，"
"相當於根本沒有靜態型別。因此，預設情況下不允許對“Variant”進行推理，因為這可能"
"是錯誤。"

msgid ""
"You can turn off this check, or make it only a warning, by changing it in "
"the project settings. See :ref:`doc_gdscript_warning_system` for details."
msgstr ""
"您可以透過在專案設定中變更它來關閉此檢查，或將其僅作為警告。有關詳細信息，請"
"參閱 :ref:`doc_gdscript_warning_system` 。"

msgid "Initialization order"
msgstr "初始化順序"

msgid "Member variables are initialized in the following order:"
msgstr "成員變數會依下列順序初始化："

msgid ""
"Depending on the variable's static type, the variable is either ``null`` "
"(untyped variables and objects) or has a default value of the type (``0`` "
"for ``int``, ``false`` for ``bool``, etc.)."
msgstr ""
"根據變數的靜態型別，變數會是 ``null``（未型別化變數與物件）或型別預設值（如 "
"``int`` 為 ``0``，``bool`` 為 ``false`` 等）。"

msgid ""
"The specified values are assigned in the order of the variables in the "
"script, from top to bottom."
msgstr "依腳本內變數宣告順序（由上到下）指派指定的值。"

msgid ""
"(Only for ``Node``-derived classes) If the ``@onready`` annotation is "
"applied to a variable, its initialization is deferred to step 5."
msgstr ""
"（僅適用於 ``Node`` 衍生類別）若變數有 ``@onready`` 註解，其初始化會延後至步"
"驟 5。"

msgid "If defined, the ``_init()`` method is called."
msgstr "如有定義，會呼叫 ``_init()`` 方法。"

msgid ""
"When instantiating scenes and resources, the exported values are assigned."
msgstr "場景與資源實體化時會指派匯出的屬性值。"

msgid ""
"(Only for ``Node``-derived classes) ``@onready`` variables are initialized."
msgstr "（僅適用於 ``Node`` 衍生類別）初始化 ``@onready`` 變數。"

msgid ""
"(Only for ``Node``-derived classes) If defined, the ``_ready()`` method is "
"called."
msgstr "（僅適用於 ``Node`` 衍生類別）如有定義，會呼叫 ``_ready()`` 方法。"

msgid ""
"You can specify a complex expression as a variable initializer, including "
"function calls. Make sure the variables are initialized in the correct "
"order, otherwise your values may be overwritten. For example:"
msgstr ""
"你可以使用複雜運算式作為變數初始值，包含函式呼叫。請確保變數以正確順序初始"
"化，否則值可能被覆蓋。例如："

msgid "Will print:"
msgstr "輸出："

msgid ""
"To fix this, move the ``_data`` variable definition above the ``a`` "
"definition or remove the empty dictionary assignment (``= {}``)."
msgstr ""
"若要修正，請將 ``_data`` 變數定義移到 ``a`` 上方，或移除空字典指定（``= {}"
"``）。"

msgid "Static variables"
msgstr "本地坐標"

msgid "A class member variable can be declared static:"
msgstr "類別成員變數可以宣告為 static："

msgid ""
"Static variables belong to the class, not instances. This means that static "
"variables share values between multiple instances, unlike regular member "
"variables."
msgstr ""
"靜態變數屬於類，而不屬於實例。這意味著靜態變數在多個實例之間共享值，這與常規"
"成員變數不同。"

msgid ""
"From inside a class, you can access static variables from any function, both "
"static and non-static. From outside the class, you can access static "
"variables using the class or an instance (the second is not recommended as "
"it is less readable)."
msgstr ""
"在類別內部，您可以從任何函式（靜態和非靜態）存取靜態變數。從類別外部，您可以"
"使用類別或實例存取靜態變數（不建議使用第二種，因為它的可讀性較差）。"

msgid ""
"The ``@export`` and ``@onready`` annotations cannot be applied to a static "
"variable. Local variables cannot be static."
msgstr "“@export” 和 “@onready” 註解不能應用於靜態變數。局部變數不能是靜態的。"

msgid ""
"The following example defines a ``Person`` class with a static variable "
"named ``max_id``. We increment the ``max_id`` in the ``_init()`` function. "
"This makes it easy to keep track of the number of ``Person`` instances in "
"our game."
msgstr ""
"以下範例定義了一個具有名為“max_id”的靜態變數的“Person”類別。我們在“_init()”函"
"式中增加“max_id”。這使得我們可以輕鬆追蹤遊戲中「Person」實例的數量。"

msgid ""
"In this code, we create two instances of our ``Person`` class and check that "
"the class and every instance have the same ``max_id`` value, because the "
"variable is static and accessible to every instance."
msgstr ""
"在這段程式碼中，我們建立了「Person」類別的兩個實例，並檢查該類別和每個實例是"
"否具有相同的「max_id」值，因為該變數是靜態的並且每個實例都可以存取。"

msgid "Static variables can have type hints, setters and getters:"
msgstr "靜態變數可以有型別提示、setter 與 getter："

msgid "A base class static variable can also be accessed via a child class:"
msgstr "基底類別的靜態變數也可以透過子類別存取："

msgid ""
"When referencing a static variable from a tool script, the other script "
"containing the static variable **must** also be a tool script. "
"See :ref:`Running code in the editor "
"<doc_running_code_in_the_editor_important_information>` for details."
msgstr ""
"當你在工具腳本中參照某個靜態變數時, 包含該靜態變數的另一個腳本也 **必須** 是"
"工具腳本。詳情請參閱 :ref:`Running code in the editor "
"<doc_running_code_in_the_editor_important_information>` 。"

msgid "``@static_unload`` annotation"
msgstr "“@static_unload”註釋"

msgid ""
"Since GDScript classes are resources, having static variables in a script "
"prevents it from being unloaded even if there are no more instances of that "
"class and no other references left. This can be important if static "
"variables store large amounts of data or hold references to other project "
"resources, such as scenes. You should clean up this data manually, or use "
"the :ref:`@static_unload <class_@GDScript_annotation_@static_unload>` "
"annotation if static variables don't store important data and can be reset."
msgstr ""
"由於 GDScript 類別是資源，腳本中的靜態變數會防止它被卸載，即使該類別沒有更多"
"實例且沒有其他參考剩餘。如果靜態變數儲存大量資料或持有對其他專案資源 (例如場"
"景) 的參考，這會很重要。您應該手動清理這些資料，或如果靜態變數沒有儲存重要資"
"料且可以被重設，則使用 :ref:`@static_unload 標記 "
"<class_@GDScript_annotation_@static_unload>`。"

msgid ""
"Currently, due to a bug, scripts are never freed, even if ``@static_unload`` "
"annotation is used."
msgstr "目前，由於錯誤，即使使用“@static_unload”註釋，腳本也永遠不會被釋放。"

msgid ""
"Note that ``@static_unload`` applies to the entire script (including inner "
"classes) and must be placed at the top of the script, before ``class_name`` "
"and ``extends``:"
msgstr ""
"請注意，``@static_unload`` 會套用到整個腳本（包含內部類別），並且必須放在腳本"
"最前面、位於 ``class_name`` 與 ``extends`` 之前："

msgid "See also `Static functions`_ and `Static constructor`_."
msgstr "另請參閱 `靜態函式`_ 與 `靜態建構子`_ 。"

msgid "Casting"
msgstr "型別轉換"

msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"當指派值給有型別的變數時，該值必須有相容的型別。若有需要強制轉換值為特定型"
"別，特別是物件型別時，可以使用型別轉換運算子 ``as`` 。"

msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"在物件型別間進行型別轉換時，若值為相同型別或該轉換型別的子型別時，取得的結果"
"將為相同型別。"

msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr "若該值非子型別，則轉換操作會導致 ``null`` 值。"

msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr "對於內建型別，若可能的話將強制轉換，否則引擎將產生錯誤。"

msgid ""
"Casting is also useful to have better type-safe variables when interacting "
"with the scene tree:"
msgstr "在與場景樹互動時，透過轉型也能讓變數更具型別安全性："

msgid "Constants"
msgstr "常數"

msgid ""
"Constants are values you cannot change when the game is running. Their value "
"must be known at compile-time. Using the ``const`` keyword allows you to "
"give a constant value a name. Trying to assign a value to a constant after "
"it's declared will give you an error."
msgstr ""
"常數是一種無法在遊戲執行時更改的數值。常數的值必須在編譯時期就已定好。使用 "
"``const`` 關鍵字即可為常數設定名稱。若在常數定義後試圖為常數賦值會回傳錯誤。"

msgid "We recommend using constants whenever a value is not meant to change."
msgstr "我們建議，當有不會更改的值時，一概使用常數。"

msgid ""
"Although the type of constants is inferred from the assigned value, it's "
"also possible to add explicit type specification:"
msgstr "雖然常數的型別會從指定的值推斷，但也可以加入明確的型別指定："

msgid "Assigning a value of an incompatible type will raise an error."
msgstr "當指派的值的型別不相容時將產生錯誤。"

msgid ""
"You can also create constants inside a function, which is useful to name "
"local magic values."
msgstr "您也可以在函式內建立常數，這對於命名局部魔術值很有用。"

msgid "Enums"
msgstr "Enum 列舉型別"

msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr "Enum 基本上是常數的簡寫，當需要給一些常數指派連續的整數時滿有用的。"

msgid ""
"If you pass a name to the enum, it will put all the keys inside a "
"constant :ref:`Dictionary <class_Dictionary>` of that name. This means all "
"constant methods of a dictionary can also be used with a named enum."
msgstr ""
"如果您為 enum 指定一個名稱，它會將所有鍵放入一個以該名稱命名的常數 :ref:`字"
"典 <class_Dictionary>` 中。這表示字典的所有常數方法也可用於已命名的 enum。"

msgid ""
"Keys in a named enum are not registered as global constants. They should be "
"accessed prefixed by the enum's name (``Name.KEY``)."
msgstr ""
"在 Godot 3.1 與之後的版本中，在有名稱的 Enum 中的鍵並不會註冊為全域常數。存取"
"時必須要在前面加上 Enum 的名稱（ ``Name.KEY`` ）。請參考下方範例。"

msgid ""
"If not assigning a value to a key of an enum it will be assigned the "
"previous value plus one, or ``0`` if it is the first entry in the enum. "
"Multiple keys with the same value are allowed."
msgstr ""
"若沒有給 enum 的鍵賦值，則該鍵會自動設為前一個值加一，若是第一個則為 ``0``。"
"允許多個鍵對應同一個值。"

msgid "Functions"
msgstr "函式"

msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members "
"(see `self`_), but is not always required (and should *not* be sent as the "
"function's first argument, unlike Python)."
msgstr ""
"所有函式都屬於某個 `class <Classes>`_ 。變數查找順序為：區域 → 類別成員 → 全"
"域。``self`` 變數總是可用的，可用來存取類別成員（詳見 `self`_），但不是必需"
"（也*不*應該像 Python 那樣當作第一個參數傳入）。"

msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr "函式可以於任何時機 ``return`` 。預設的回傳值為 ``null`` 。"

msgid ""
"If a function contains only one line of code, it can be written on one line:"
msgstr "如果函式只包含一行程式碼，可以寫在同一行："

msgid ""
"Functions can also have type specification for the arguments and for the "
"return value. Types for arguments can be added in a similar way to variables:"
msgstr "函式也可以替參數與回傳值指定型別。參數型別可用與變數類似的方式來指定："

msgid ""
"If a function argument has a default value, it's possible to infer the type:"
msgstr "若函式參數有預設值，就可以透過該值推斷型別："

msgid ""
"The return type of the function can be specified after the arguments list "
"using the arrow token (``->``):"
msgstr "函式的回傳型別可以在參數列表後使用箭頭符號（``->``）來指定："

msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"有回傳型別的函式 **必須** 回傳適當的值。將型別設為 ``void`` 則表示函式不回傳"
"任何東西。Void 函式可以使用 ``return`` 關鍵字來提早回傳，但無法回傳任何值。"

msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"非 Void 函式必須 **總是** 回傳一個值。若程式碼中有分歧陳述式（如 ``if``/"
"``else`` 結構），則所有可能的路徑都必須要有 return。如，若在 ``if`` 內有 "
"``return`` 但 ``if`` 後卻沒有，則編輯器會產生錯誤，因為若區塊程式碼未被執行，"
"則該函式將不會有有效的回傳值。"

msgid "Referencing functions"
msgstr "函式參照"

msgid ""
"Functions are first-class values in terms of the :ref:`Callable "
"<class_Callable>` object. Referencing a function by name without calling it "
"will automatically generate the proper callable. This can be used to pass "
"functions as arguments."
msgstr ""
"在 :ref:`Callable <class_Callable>` 的語意下，函式屬於第一級公民。以名稱參照"
"函式但不呼叫時，會自動產生對應的 Callable 物件，可用於將函式作為參數傳遞。"

msgid ""
"Callables **must** be called with the :ref:`call() "
"<class_Callable_method_call>` method. You cannot use the ``()`` operator "
"directly. This behavior is implemented to avoid performance issues on direct "
"function calls."
msgstr ""
"Callable 物件**必須**使用 :ref:`call() <class_Callable_method_call>` 方法來呼"
"叫，不能直接用 ``()`` 運算子。這麼設計是為了避免直接呼叫函式造成的效能問題。"

msgid "Lambda functions"
msgstr "隨機數函式"

msgid ""
"Lambda functions allow you to declare functions that do not belong to a "
"class. Instead, a :ref:`Callable <class_Callable>` object is created and "
"assigned to a variable directly. This can be useful to create callables to "
"pass around without polluting the class scope."
msgstr ""
"Lambda 函式可以宣告不隸屬於任何類別的函式，而是直接建立一個 :ref:`Callable "
"<class_Callable>` 物件並指定給變數。這很適合建立可傳遞的 Callable，不會污染類"
"別作用域。"

msgid ""
"To call the created lambda you can use the :ref:`call() "
"<class_Callable_method_call>` method:"
msgstr ""
"要呼叫建立好的 lambda，可以使用 :ref:`call() <class_Callable_method_call>` 方"
"法："

msgid ""
"Lambda functions can be named for debugging purposes (the name is displayed "
"in the Debugger):"
msgstr "Lambda 函式可以命名以利除錯（名稱會顯示在除錯器中）："

msgid ""
"You can specify type hints for lambda functions in the same way as for "
"regular ones:"
msgstr "你可以像一般函式一樣，替 lambda 函式指定型別提示："

msgid ""
"Note that if you want to return a value from a lambda function, an explicit "
"``return`` is required (you can't omit ``return``):"
msgstr ""
"注意: 若要從 lambda 函式回傳值, 必須明確撰寫 ``return`` , 不可省略 "
"``return``:"

msgid "Lambda functions capture the local environment:"
msgstr "Lambda 函式會捕捉區域環境："

msgid ""
"Local variables are captured by value once, when the lambda is created. So "
"they won't be updated in the lambda if reassigned in the outer function:"
msgstr ""
"區域變數在建立 lambda 當下會以值的方式捕捉一次。之後即使在外部函式改變了該變"
"數，lambda 內部也不會更新："

msgid ""
"Also, a lambda cannot reassign an outer local variable. After exiting the "
"lambda, the variable will be unchanged, because the lambda capture "
"implicitly shadows it:"
msgstr ""
"另外，lambda 不能重新賦值給外部的區域變數。離開 lambda 後，該變數仍不會改變，"
"因為被捕捉的是一份遮蔽原變數的副本："

msgid ""
"However, if you use pass-by-reference data types (arrays, dictionaries, and "
"objects), then the content changes are shared until you reassign the "
"variable:"
msgstr ""
"不過，如果捕捉的是以參照傳遞的資料型別（陣列、字典與物件），那麼在你重新賦值"
"之前，內容的變更會被共享："

msgid "Static functions"
msgstr "靜態函式"

msgid ""
"A function can be declared static. When a function is static, it has no "
"access to the instance member variables or ``self``. A static function has "
"access to static variables. Also static functions are useful to make "
"libraries of helper functions:"
msgstr ""
"函式可以宣告為 static。當函式是 static 時，無法存取實例成員變數或 ``self``，"
"但可以存取靜態變數。static 函式也很適合用來製作工具函式的函式庫："

msgid "Lambda functions cannot be declared static."
msgstr "Lambda 函式無法宣告為 static。"

msgid "See also `Static variables`_ and `Static constructor`_."
msgstr "另請參閱 `靜態變數`_ 和 `靜態建構函式`_。"

msgid "Variadic functions"
msgstr "可變參數函式"

msgid ""
"A variadic function is a function that can take a variable number of "
"arguments. Since Godot 4.5, GDScript supports variadic functions. To declare "
"a variadic function, you need to use the *rest parameter*, which collects "
"all the excess arguments into an array."
msgstr ""
"可變參數函式是指能接受可變數量參數的函式。自 Godot 4.5 起, GDScript 支援可變"
"參數函式。要宣告可變參數函式, 需使用 *剩餘參數 (rest parameter)* , 它會把多出"
"的所有參數收集成一個陣列。"

msgid ""
"A function can have at most one rest parameter, which must be the last one "
"in the parameter list. The rest parameter cannot have a default value. "
"Static and lambda functions can also be variadic."
msgstr ""
"函式至多只能有一個剩餘參數，且必須位於參數列表的最後。剩餘參數不能有預設值。"
"靜態函式與 lambda 函式也可以是可變參數的。"

msgid ""
"Static typing works for variadic functions too. However, typed arrays are "
"currently not supported as a static type of the rest parameter:"
msgstr ""
"靜態型別同樣適用於可變參數函式。不過，目前不支援使用具型別陣列作為剩餘參數的"
"靜態型別："

msgid ""
"Although you can declare functions as variadic using the rest parameter, "
"unpacking parameters when calling a function using *spread syntax* that "
"exists in some languages ​​(JavaScript, PHP) is currently not supported in "
"GDScript. However, you can use ``callv()`` to call a function with an array "
"of arguments:"
msgstr ""
"雖然你可以使用剩餘參數來宣告可變參數函式, 但 GDScript 目前不支援像某些語言 "
"(JavaScript、PHP) 那樣在呼叫時使用 *展開語法* 來解包參數。不過, 你可以使用 "
"``callv()`` 以陣列的形式傳入參數來呼叫函式:"

msgid "Abstract functions"
msgstr "抽象函式"

msgid "See `Abstract classes and methods`_."
msgstr "請參閱 `抽象類別與方法`_。"

msgid "Statements and control flow"
msgstr "稱述句與流程控制"

msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"稱述句為標準，可以為複製、函式呼叫、流程結構…等（相見下方）。 作為稱述句分隔"
"字元的 ``;`` 是完全可選的。"

msgid "Expressions"
msgstr "Expression Node 運算式節點"

msgid ""
"Expressions are sequences of operators and their operands in orderly "
"fashion. An expression by itself can be a statement too, though only calls "
"are reasonable to use as statements since other expressions don't have side "
"effects."
msgstr ""
"表達式是依序排列的運算子及其運算元的序列。表達式本身也可以是敘述，但只有呼叫"
"才可以合理地用作敘述，因為其他表達式沒有副作用。"

msgid ""
"Expressions return values that can be assigned to valid targets. Operands to "
"some operator can be another expression. An assignment is not an expression "
"and thus does not return any value."
msgstr ""
"表達式傳回可指派給有效目標的值。某些運算符的操作數可以是另一個表達式。賦值不"
"是表達式，因此不傳回任何值。"

msgid "Here are some examples of expressions:"
msgstr "以下是一些運算式範例："

msgid ""
"Identifiers, attributes, and subscripts are valid assignment targets. Other "
"expressions cannot be on the left side of an assignment."
msgstr "標識符、屬性和下標是有效的賦值目標。其他表達式不能位於賦值的左側。"

msgid ""
"``self`` can be used to refer to the current instance and is often "
"equivalent to directly referring to symbols available in the current script. "
"However, ``self`` also allows you to access properties, methods, and other "
"names that are defined dynamically (i.e. are expected to exist in subtypes "
"of the current class, or are provided using :ref:`_set() "
"<class_Object_private_method__set>` and/or :ref:`_get() "
"<class_Object_private_method__get>`)."
msgstr ""
"``self`` 可用來參照當前實體，通常等同於直接存取目前腳本可用的符號。不過，"
"``self`` 也能用來存取動態定義的屬性、方法與其他名稱（例如預期存在於目前類別子"
"類中的名稱，或是透過 :ref:`_set() <class_Object_private_method__set>` 和/"
"或 :ref:`_get() <class_Object_private_method__get>` 提供的名稱）。"

msgid ""
"Beware that accessing members of child classes in the base class is often "
"considered a bad practice, because this blurs the area of responsibility of "
"any given piece of code, making the overall relationship between parts of "
"your game harder to reason about. Besides that, one can simply forget that "
"the parent class had some expectations about it's descendants."
msgstr ""
"請注意，在基底類別中存取子類別成員通常被視為不良習慣，這會模糊程式碼的責任範"
"圍，讓遊戲各部分間的關係變得難以理解。此外，也很容易忘記父類別對其子類有特定"
"預期。"

msgid "if/else/elif"
msgstr "if/else/elif"

msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"簡單的條件判斷可以使用 ``if``/``else``/``elif`` 語法來建立。可以在條件周圍加"
"上括號，但並非必要。由於基於 Tab 排版的性質，可以使用 ``elif`` 代替 ``else``/"
"``if`` 來維持縮排的等級。"

msgid "Short statements can be written on the same line as the condition:"
msgstr "較短的敘述可以與條件寫在同一行："

msgid ""
"Sometimes, you might want to assign a different initial value based on a "
"boolean expression. In this case, ternary-if expressions come in handy:"
msgstr ""
"有時你會想依據布林運算式來指派不同的初始值。此時三元條件運算式就派上用場了："

msgid ""
"Ternary-if expressions can be nested to handle more than 2 cases. When "
"nesting ternary-if expressions, it is recommended to wrap the complete "
"expression over multiple lines to preserve readability:"
msgstr ""
"三元條件運算式可以巢狀使用來處理多於兩種情況。當巢狀三元條件運算式時，建議將"
"完整運算式分成多行以維持可讀性："

msgid ""
"You may also wish to check if a value is contained within something. You can "
"use an ``if`` statement combined with the ``in`` operator to accomplish this:"
msgstr ""
"你也可能需要檢查某個值是否包含於某集合中。可以透過 ``if`` 敘述搭配 ``in`` 運"
"算子來完成："

msgid ""
"Simple loops are created by using ``while`` syntax. Loops can be broken "
"using ``break`` or continued using ``continue`` (which skips to the next "
"iteration of the loop without executing any further code in the current "
"iteration):"
msgstr ""
"可以使用 ``while`` 語法來建立簡單的迴圈。迴圈可以使用 ``break`` 來中斷或是使"
"用 ``continue`` 來繼續："

msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *key* is stored in the "
"loop variable."
msgstr ""
"要在如陣列或表格中的一段範圍內迭代，可以使用 **for** 迴圈。當在陣列中迭代時，"
"目前的陣列元素會儲存於迴圈變數中。當於字典中迭代時，保存在迴圈變數內的則會是 "
"**索引** 。"

msgid ""
"If you want to assign values on an array as it is being iterated through, it "
"is best to use ``for i in array.size()``."
msgstr "如果要在迭代陣列時為其賦值，最好使用「for i in array.size()」。"

msgid ""
"The loop variable is local to the for-loop and assigning to it will not "
"change the value on the array. Objects passed by reference (such as nodes) "
"can still be manipulated by calling methods on the loop variable."
msgstr ""
"迴圈變數是 for 迴圈的局部變量，為其賦值不會改變陣列上的值。透過引用傳遞的物件"
"（例如節點）仍然可以透過呼叫循環變數上的方法來操作。"

msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"``match`` 陳述式用於在程式內分歧執行。與其他許多語言內的 ``switch`` 表達式相"
"同，但有些額外的功能。"

msgid ""
"``match`` is more type strict than the ``==`` operator. For example ``1`` "
"will **not** match ``1.0``. The only exception is ``String`` vs "
"``StringName`` matching: for example, the String ``\"hello\"`` is considered "
"equal to the StringName ``&\"hello\"``."
msgstr ""
"“match” 比“==” 運算符的型別更嚴格。例如“1”將**不**配對“1.0”。唯一的例外是 "
"``String`` 與 ``StringName`` 配對：例如，字串 ``\"hello\"`` 被認為等於 "
"StringName ``&\"hello\"``。"

msgid "Basic syntax"
msgstr "基本語法"

msgid "Crash-course for people who are familiar with switch statements"
msgstr "給熟悉 switch 陳述式的人的速成說明"

msgid "Replace ``switch`` with ``match``."
msgstr "將 ``switch`` 取代為 ``match`` 。"

msgid "Remove ``case``."
msgstr "移除 ``case`` 。"

msgid "Remove any ``break``\\ s."
msgstr "移除 ``case`` 。"

msgid "Change ``default`` to a single underscore."
msgstr "將 ``default`` 改為底線。"

msgid "Control flow"
msgstr "流程控制"

msgid ""
"The patterns are matched from top to bottom. If a pattern matches, the first "
"corresponding block will be executed. After that, the execution continues "
"below the ``match`` statement."
msgstr ""
"搜尋模式會按照由上到下的順序來配對。若與搜尋模式相符，則會執行第一個對應的區"
"塊。之後會繼續執行 ``match`` 陳述式下方的程式。若想往下執行，可以使用 "
"``continue`` 來停止執行目前的區塊，並往下搜尋其他符合的搜尋模式。"

msgid ""
"The special ``continue`` behavior in ``match`` supported in 3.x was removed "
"in Godot 4.0."
msgstr "3.x 中支援的「match」中特殊的「繼續」行為在 Godot 4.0 中被刪除。"

msgid "The following pattern types are available:"
msgstr "可使用下列樣式類型："

msgid "Literal pattern"
msgstr "常值樣式"

msgid "Matches a `literal <Literals_>`_:"
msgstr "比對一個 `literal <Literals_>`_:"

msgid "Expression pattern"
msgstr "運算式樣式"

msgid ""
"Matches a constant expression, an identifier, or an attribute access "
"(``A.B``):"
msgstr "比對常數運算式、識別字或屬性存取（``A.B``）："

msgid "Wildcard pattern"
msgstr "萬用字元"

msgid "This pattern matches everything. It's written as a single underscore."
msgstr "尋找所有東西。寫成一個底線。"

msgid ""
"It can be used as the equivalent of the ``default`` in a ``switch`` "
"statement in other languages:"
msgstr "其用法相當於其他語言中 ``switch`` 敘述的 ``default``："

msgid "Binding pattern"
msgstr "繫結"

msgid ""
"A binding pattern introduces a new variable. Like the wildcard pattern, it "
"matches everything - and also gives that value a name. It's especially "
"useful in array and dictionary patterns:"
msgstr ""
"繫結樣式會引入一個新變數。就像萬用字元樣式一樣，它能比對所有東西，並且替該值"
"命名。這在陣列與字典樣式中特別實用："

msgid "Array pattern"
msgstr "陣列"

msgid ""
"Matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr "搜尋陣列。陣列中的每一個元素也都是搜尋模式，可以巢狀使用。"

msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr "會先檢查陣列的長度，長度必須與搜尋模式相同，否則將不會視為相符。"

msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``."
msgstr ""
"**開放結尾陣列** ：通過將最後一個子搜尋模式設為 ``..`` 可配對大於模式的陣列。"

msgid "Every subpattern has to be comma-separated."
msgstr "所有子搜尋模式都以逗號分隔。"

msgid "Dictionary pattern"
msgstr "字典"

msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr "與陣列模式相同。所有索引鍵都必須為常數搜尋模式。"

msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr "會先檢查字典的大小，必須與搜尋模式相同，否則將不會視為相符。"

msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``."
msgstr ""
"**開放結尾字典** ：通過將最後一個子搜尋模式設為 ``..`` 可允許配對大於搜尋模式"
"的字典。"

msgid "Every subpattern has to be comma separated."
msgstr "所有子模式都必須以逗號分隔。"

msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "若不指定值，則只會檢查索引鍵是否存在。"

msgid "A value pattern is separated from the key pattern with a ``:``."
msgstr "值搜尋模式使用 ``:`` 來與索引值搜尋模式區分。"

msgid "Multiple patterns"
msgstr "多重搜尋模式"

msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them."
msgstr "也可以逗號區分來指定多個搜尋模式。這些搜尋模式中不允許有任何繫結。"

msgid "Pattern guards"
msgstr "模式守衛"

msgid ""
"A *pattern guard* is an optional condition that follows the pattern list and "
"allows you to make additional checks before choosing a ``match`` branch. "
"Unlike a pattern, a pattern guard can be an arbitrary expression."
msgstr ""
"*模式守衛* 是跟在模式列表之後的可選條件，讓你在選擇 ``match`` 分支前額外做判"
"斷。與模式不同，模式守衛可以是任意運算式。"

msgid ""
"Only one branch can be executed per ``match``. Once a branch is chosen, the "
"rest are not checked. If you want to use the same pattern for multiple "
"branches or to prevent choosing a branch with too general pattern, you can "
"specify a pattern guard after the list of patterns with the ``when`` keyword:"
msgstr ""
"每個 ``match`` 最多只能執行一個分支。一旦選定分支，其餘分支便不再檢查。若你想"
"對同一樣式制定多個分支，或避免選到過於寬鬆的一般性樣式，可以在樣式列表後使用 "
"``when`` 關鍵字加上樣式守衛："

msgid ""
"If there is no matching pattern for the current branch, the pattern guard is "
"**not** evaluated and the patterns of the next branch are checked."
msgstr ""
"若目前分支的模式不符合，則不會檢查該分支的模式守衛，會直接檢查下一個分支的模"
"式。"

msgid "If a matching pattern is found, the pattern guard is evaluated."
msgstr "若模式符合，則會檢查該分支的模式守衛。"

msgid ""
"If it's true, then the body of the branch is executed and ``match`` ends."
msgstr "若為 true，則執行該分支內容，並結束 ``match``。"

msgid "If it's false, then the patterns of the next branch are checked."
msgstr "若為 false，則繼續檢查下一個分支的模式。"

msgid "Classes"
msgstr "類別"

msgid ""
"By default, all script files are unnamed classes. In this case, you can only "
"reference them using the file's path, using either a relative or an absolute "
"path. For example, if you name a script file ``character.gd``:"
msgstr ""
"預設情況下，所有腳本檔案都是未命名類別。此時只能透過檔案路徑（相對或絕對路"
"徑）來參照它們。例如，若腳本檔案名為 ``character.gd``："

msgid "Registering named classes"
msgstr "將腳本註冊為類別"

msgid ""
"You can give your class a name to register it as a new type in Godot's "
"editor. For that, you use the ``class_name`` keyword. You can optionally use "
"the ``@icon`` annotation with a path to an image, to use it as an icon. Your "
"class will then appear with its new icon in the editor:"
msgstr ""
"你可以替類別命名，將其註冊為 Godot 編輯器中的新型別。做法是使用 "
"``class_name`` 關鍵字。你也可以選擇使用 ``@icon`` 註解並指定一張圖片路徑作為"
"圖示。之後，該類別會在編輯器中以新圖示顯示："

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor "
"Theme** :ref:`import options <doc_importing_images_editor_import_options>` "
"enabled. This allows icons to follow the editor's scale and theming settings "
"if the icons are designed with the same color palette as Godot's own icons."
msgstr ""
"作為自訂節點圖示的 SVG 圖檔，建議啟用 **編輯器 > 隨編輯器縮放** 以及 **編輯"
"器 > 按編輯器主題轉換圖示** 這兩個 :ref:`匯入選項 "
"<doc_importing_images_editor_import_options>`。如此可讓圖示隨 Godot 編輯器縮"
"放和主題設定自動調整（前提是你的圖示配色與 Godot 官方圖示一致）。"

msgid "Here's a class file example:"
msgstr "下列為類別檔案範例："

msgid "If you want to use ``extends`` too, you can keep both on the same line:"
msgstr "如果也要使用 ``extends``，可以把兩者放在同一行："

msgid ""
"Named classes are globally registered, which means they become available to "
"use in other scripts without the need to ``load`` or ``preload`` them:"
msgstr ""
"具名類別會全域註冊，這表示在其他腳本中可直接使用，無需先 ``load`` 或 "
"``preload``："

msgid ""
"Godot initializes non-static variables every time you create an instance, "
"and this includes arrays and dictionaries. This is in the spirit of thread "
"safety, since scripts can be initialized in separate threads without the "
"user knowing."
msgstr ""
"Godot 的類別語法很簡短，類別中只有成員變數與成員函式。函式可以為靜態函式，但"
"變數則不可定義為靜態。同樣地，Godot 會在每次實體化時都初始化變數，包含陣列與"
"字典。這樣一來能讓腳本在使用者不知情的情況下於不同的執行續中初始化，這正是執"
"行緒安全的精神。"

msgid ""
"The Godot editor will hide these custom classes with names that begin with "
"the prefix \"Editor\" in the 'Create New Node' or 'Create New Scene' dialog "
"windows. The classes are available for instantiation at runtime via their "
"class names, but are automatically hidden by the editor windows along with "
"the built-in editor nodes used by the Godot editor."
msgstr ""
"Godot 編輯器會將名稱以 \"Editor\" 為開頭的自訂類別，在「建立新節點」或「建立"
"新場景」等對話框中隱藏起來。這些類別仍可在執行時用類別名稱建立實例，但在編輯"
"器介面上會自動隱藏，與 Godot 內建編輯器節點一同不顯示。"

msgid "Abstract classes and methods"
msgstr "抽象類別與方法"

msgid ""
"Since Godot 4.5, you can define abstract classes and methods using the "
"``@abstract`` annotation."
msgstr ""
"自 Godot 4.5 起，你可以使用 ``@abstract`` 註解來定義抽象類別與抽象方法。"

msgid ""
"An abstract class is a class that cannot be instantiated directly. Instead, "
"it is meant to be inherited by other classes. Attempting to instantiate an "
"abstract class will result in an error."
msgstr ""
"抽象類別無法被直接實例化，它的用途是讓其他類別繼承。嘗試實例化抽象類別會導致"
"錯誤。"

msgid ""
"An abstract method is a method that has no implementation. Therefore, a "
"newline or a semicolon is expected after the function header. This defines a "
"contract that inheriting classes must conform to, because the method "
"signature must be compatible when overriding."
msgstr ""
"抽象方法是不包含實作的函式。因此在函式宣告後應以換行或分號結束。這相當於定義"
"了一個契約，要求繼承的類別在覆寫時必須提供相容的方法簽章。"

msgid ""
"Inheriting classes must either provide implementations for all abstract "
"methods, or the inheriting class must be marked as abstract. If a class has "
"at least one abstract method (either its own or an unimplemented inherited "
"one), then it must also be marked as abstract. However, the reverse is not "
"true: an abstract class is allowed to have no abstract methods."
msgstr ""
"繼承的類別必須為所有抽象方法提供實作，否則就必須將該類別標記為抽象。若某個類"
"別擁有至少一個抽象方法（無論是自身的，或是繼承而未實作的），則它也必須被標記"
"為抽象。不過反過來並不成立：抽象類別可以完全沒有抽象方法。"

msgid ""
"If you want to declare a method as optional to be overridden, you should use "
"a non-abstract method and provide a default implementation."
msgstr ""
"如果你想將某方法設為可選擇性覆寫，應將其定義為非抽象方法，並提供預設實作。"

msgid ""
"For example, you could have an abstract class called ``Shape`` that defines "
"an abstract method called ``draw()``. You can then create subclasses like "
"``Circle`` and ``Square`` that implement the ``draw()`` method in their own "
"way. This allows you to define a common *interface* for all shapes without "
"having to implement all the details in the abstract class itself:"
msgstr ""
"例如, 你可以有一個名為 ``Shape`` 的抽象類別, 並在其中定義抽象方法 "
"``draw()``。接著建立像 ``Circle`` 、 ``Square`` 等子類別, 以各自的方式實作 "
"``draw()``。這讓你能為所有形狀定義共同的 *介面* , 而不必在抽象類別中實作所有"
"細節:"

msgid ""
"Both inner classes and classes created using ``class_name`` can be abstract. "
"This example creates two abstract classes, one of which is a subclass of "
"another abstract class:"
msgstr ""
"內部類別與使用 ``class_name`` 建立的類別都可以是抽象的。以下範例建立了兩個抽"
"象類別，其中一個是另一個抽象類別的子類別："

msgid ""
"Since an abstract class cannot be instantiated, it is not possible to attach "
"an abstract class to a node. If you attempt to do so, the engine will print "
"an error when running the scene:"
msgstr ""
"由於抽象類別無法實例化，因此不能將抽象類別掛在節點上。若你嘗試這麼做，引擎會"
"在執行場景時輸出錯誤訊息："

msgid ""
"Unnamed classes can also be defined as abstract, the ``@abstract`` "
"annotation must precede ``extends``:"
msgstr ""
"未命名類別也可以定義為抽象類別，此時 ``@abstract`` 註解必須寫在 ``extends`` "
"之前："

msgid "Inheritance"
msgstr "繼承"

msgid "A class (stored as a file) can inherit from:"
msgstr "類別 (儲存為檔案) 可以繼承自:"

msgid "A global class."
msgstr "全域類別。"

msgid "Another class file."
msgstr "另一個類別檔案。"

msgid "An inner class inside another class file."
msgstr "在另一個類別檔案中的內部類別。"

msgid "Multiple inheritance is not allowed."
msgstr "無法多重繼承。"

msgid "Inheritance uses the ``extends`` keyword:"
msgstr "繼承使用 ``extends`` 關鍵字："

msgid ""
"If inheritance is not explicitly defined, the class will default to "
"inheriting :ref:`class_RefCounted`."
msgstr "如果沒有明確定義繼承，則該類別將預設繼承 :ref:`class_RefCounted` 。"

msgid ""
"To check if a given instance inherits from a given class, the ``is`` keyword "
"can be used:"
msgstr "要檢查某個實例是否繼承自特定類別，可以使用 ``is`` 關鍵字："

msgid ""
"To call a function in a *super class* (i.e. one ``extend``-ed in your "
"current class), use the ``super`` keyword:"
msgstr ""
"要呼叫 *超類別* (也就是目前類別所 ``extends`` 的那個類別) 中的函式, 請使用 "
"``super`` 關鍵字:"

msgid ""
"This is especially useful because functions in extending classes replace "
"functions with the same name in their super classes. If you still want to "
"call them, you can use ``super``:"
msgstr ""
"這特別有用，因為延伸類別中的函式會取代超類別裡相同名稱的函式。若仍想呼叫超類"
"別版本，可以使用 ``super``："

msgid ""
"If you need to call a different function from the super class, you can "
"specify the function name with the attribute operator:"
msgstr "如果需要呼叫超類別中其他函式，你可以用屬性運算子指定函式名稱："

msgid ""
"One of the common misconceptions is trying to override *non-virtual* engine "
"methods such as ``get_class()``, ``queue_free()``, etc. This is not "
"supported for technical reasons."
msgstr ""
"常見的誤解之一是試圖覆寫*非虛擬*引擎方法，例如「get_class()」、"
"「queue_free()」等。由於技術原因，不支援此方法。"

msgid ""
"In Godot 3, you can *shadow* engine methods in GDScript, and it will work if "
"you call this method in GDScript. However, the engine will **not** execute "
"your code if the method is called inside the engine on some event."
msgstr ""
"在Godot 3中，您可以在GDScript中「隱藏」引擎方法，如果您在GDScript中呼叫此方"
"法，它將起作用。但是，如果在某些事件中在引擎內部呼叫該方法，引擎將**不會**執"
"行您的程式碼。"

msgid ""
"In Godot 4, even shadowing may not always work, as GDScript optimizes native "
"method calls. Therefore, we added the ``NATIVE_METHOD_OVERRIDE`` warning, "
"which is treated as an error by default. We strongly advise against "
"disabling or ignoring the warning."
msgstr ""
"在 Godot 4 中，即使是陰影也可能不總是有效，因為 GDScript 優化了本機方法呼叫。"
"因此，我們新增了“NATIVE_METHOD_OVERRIDE”警告，預設將其視為錯誤。我們強烈建議"
"不要禁用或忽略該警告。"

msgid ""
"Note that this does not apply to virtual methods such as ``_ready()``, "
"``_process()`` and others (marked with the ``virtual`` qualifier in the "
"documentation and the names start with an underscore). These methods are "
"specifically for customizing engine behavior and can be overridden in "
"GDScript. Signals and notifications can also be useful for these purposes."
msgstr ""
"請注意，這不適用於諸如“_ready()”、“_process()”等虛擬方法（在檔案中"
"以“virtual”限定符標記，並且名稱以下劃線開頭）。這些方法專門用於自訂引擎行為，"
"並且可以在 GDScript 中覆寫。訊號和通知也可用於這些目的。"

msgid "Class constructor"
msgstr "類別建置函式"

msgid ""
"The class constructor, called on class instantiation, is named ``_init``. If "
"you want to call the base class constructor, you can also use the ``super`` "
"syntax. Note that every class has an implicit constructor that is always "
"called (defining the default values of class variables). ``super`` is used "
"to call the explicit constructor:"
msgstr ""
"在類別實例化時被呼叫的建構函式名為 ``_init``。若要呼叫基底類別的建構函式，也"
"可以使用 ``super`` 語法。請注意，每個類別都有一個一定會被呼叫的隱式建構函式"
"（用來定義類別變數的預設值）。``super`` 則是用來呼叫顯式建構函式："

msgid "This is better explained through examples. Consider this scenario:"
msgstr "以下透過範例說明，請看這個情境："

msgid "There are a few things to keep in mind here:"
msgstr "還有幾件事需要注意："

msgid ""
"If the inherited class (``state.gd``) defines an ``_init`` constructor that "
"takes arguments (``e`` in this case), then the inheriting class "
"(``idle.gd``) *must* define ``_init`` as well and pass appropriate "
"parameters to ``_init`` from ``state.gd``."
msgstr ""
"如果被繼承的類別 (``state.gd``) 定義了需要參數的 ``_init`` 建構函式 (此例為 "
"``e``), 那麼繼承的類別 (``idle.gd``) 也 *必須* 定義 ``_init`` , 並將適當的參"
"數傳遞給 ``state.gd`` 的 ``_init``."

msgid ""
"``idle.gd`` can have a different number of arguments than the base class "
"``state.gd``."
msgstr "``Idle.gd`` 的參數數量可與母類別 ``State.gd`` 不同。"

msgid ""
"In the example above, ``e`` passed to the ``state.gd`` constructor is the "
"same ``e`` passed in to ``idle.gd``."
msgstr ""
"在上方的例子中，傳遞給 ``State.gd`` 建置函式的 ``e`` 與傳遞給 ``Idle.gd`` 之 "
"``e`` 相同。"

msgid ""
"If ``idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to "
"pass some value to the ``state.gd`` base class, even if it does nothing. "
"This brings us to the fact that you can pass expressions to the base "
"constructor as well, not just variables, e.g.:"
msgstr ""
"即使 ``idle.gd`` 的 ``_init`` 建構函式不接受參數，也仍需要傳遞某個值給 "
"``state.gd`` 的基底類別，即使該值不做任何事。這也表示不只能傳變數給基底建構函"
"式，你也可以直接傳遞運算式，例如："

msgid "func _init():"
msgstr "func _init():"

msgid "super(5)"
msgstr "super(5)"

msgid "Static constructor"
msgstr "類別建置函式"

msgid ""
"A static constructor is a static function ``_static_init`` that is called "
"automatically when the class is loaded, after the static variables have been "
"initialized:"
msgstr ""
"靜態建構子是一個名為 ``_static_init`` 的靜態函式，會在類別載入、並完成靜態變"
"數初始化後自動被呼叫："

msgid ""
"A static constructor cannot take arguments and must not return any value."
msgstr "靜態建構函式不能接受參數，也不能傳回任何值。"

msgid "Inner classes"
msgstr "內類別"

msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"類別檔可以再包含內類別。內類別使用 ``class`` 關鍵字來定義。這些內部類別使用 "
"``類別名稱.new()`` 函式來實體化。"

msgid "Classes as resources"
msgstr "以類別當作資源"

msgid ""
"Classes stored as files are treated as :ref:`GDScripts <class_GDScript>`. "
"They must be loaded from disk to access them in other classes. This is done "
"using either the ``load`` or ``preload`` functions (see below). Instancing "
"of a loaded class resource is done by calling the ``new`` function on the "
"class object:"
msgstr ""
"以檔案形式儲存的類別會被視為 :ref:`GDScripts <class_GDScript>` 。若要在其他類"
"別中使用, 必須先從磁碟載入, 可透過 ``load`` 或 ``preload`` (見下文)。而要將載"
"入的類別資源實例化, 則呼叫類別物件的 ``new`` 函式即可:"

msgid "Exports"
msgstr "匯出"

msgid ""
"Documentation about exports has been moved to :ref:`doc_gdscript_exports`."
msgstr "有關匯出的說明文件已移至 :ref:`doc_gdscript_exports` 。"

msgid "Properties (setters and getters)"
msgstr "屬性 (Set/Get)"

msgid ""
"Sometimes, you want a class' member variable to do more than just hold data "
"and actually perform some validation or computation whenever its value "
"changes. It may also be desired to encapsulate its access in some way."
msgstr ""
"若能知道類別成員變數何時更改與為何更改可能很有用，我們也可能會希望以某種方法"
"來封裝成員變數的存取。"

msgid ""
"For this, GDScript provides a special syntax to define properties using the "
"``set`` and ``get`` keywords after a variable declaration. Then you can "
"define a code block that will be executed when the variable is accessed or "
"assigned."
msgstr ""
"為此，GDScript 提供了一個特殊的語法，可以在變數宣告後使用「set」和「get」關鍵"
"字來定義屬性。然後，您可以定義一個程式碼區塊，該程式碼區塊將在存取或指派變數"
"時執行。"

msgid "Example:"
msgstr "範例："

msgid ""
"Unlike ``setget`` in previous Godot versions, ``set`` and ``get`` methods "
"are **always** called (except as noted below), even when accessed inside the "
"same class (with or without prefixing with ``self.``). This makes the "
"behavior consistent. If you need direct access to the value, use another "
"variable for direct access and make the property code use that name."
msgstr ""
"與舊版 Godot 的 ``setget`` 不同，現在的 ``set``/``get`` 方法**永遠**會被呼叫"
"（除非下述例外），即使在同一個類別內（不論有無 ``self.`` 前綴）也一樣。這讓行"
"為更一致。如果你需要直接存取該值，請另外設一個變數存放，然後讓屬性方法去用那"
"個變數。"

msgid "Alternative syntax"
msgstr "替代語法"

msgid ""
"Also there is another notation to use existing class functions if you want "
"to split the code from the variable declaration or you need to reuse the "
"code across multiple properties (but you can't distinguish which property "
"the setter/getter is being called for):"
msgstr ""
"另外還有一種寫法，適合想要把屬性方法與變數宣告分開，或在多個屬性間重用同一段 "
"setter/getter 程式碼（但無法分辨究竟是哪個屬性觸發）時使用："

msgid "This can also be done in the same line:"
msgstr "也可以在同一行完成："

msgid ""
"The setter and getter must use the same notation, mixing styles for the same "
"variable is not allowed."
msgstr "setter 和 getter 必須用相同語法，不允許同一變數混用不同寫法。"

msgid ""
"You cannot specify type hints for *inline* setters and getters. This is done "
"on purpose to reduce the boilerplate. If the variable is typed, then the "
"setter's argument is automatically of the same type, and the getter's return "
"value must match it. Separated setter/getter functions can have type hints, "
"and the type must match the variable's type or be a wider type."
msgstr ""
"**內嵌** 寫法的 setter/getter 無法指定型別提示，這是刻意設計為減少重複樣板。"
"如果變數有型別，setter 的參數會自動用同型別，getter 的回傳值也必須符合。若用"
"獨立函式寫 setter/getter，可以加型別提示，但型別必須與變數相符或更寬泛。"

msgid "When setter/getter is not called"
msgstr "何時不會呼叫 setter/getter"

msgid ""
"When a variable is initialized, the value of the initializer will be written "
"directly to the variable. Including if the ``@onready`` annotation is "
"applied to the variable."
msgstr ""
"變數初始化時，初始值會直接寫入變數本身（即使有 ``@onready`` 註記也一樣）。"

msgid ""
"Using the variable's name to set it inside its own setter or to get it "
"inside its own getter will directly access the underlying member, so it "
"won't generate infinite recursion and saves you from explicitly declaring "
"another variable:"
msgstr ""
"在 setter 或 getter 內直接用變數名稱來設定/取得值，會直接存取底層成員，因此不"
"會產生無限遞迴，也不用另外宣告變數："

msgid "This also applies to the alternative syntax:"
msgstr "這也同樣適用於替代語法："

msgid ""
"The exception does **not** propagate to other functions called in the setter/"
"getter. For example, the following code **will** cause an infinite recursion:"
msgstr ""
"但這個例外情況 **不會** 延伸到 setter/getter 內部呼叫的其他函式。例如以下程式"
"碼 **會** 造成無限遞迴:"

msgid "Tool mode"
msgstr "工具模式"

msgid ""
"By default, scripts don't run inside the editor and only the exported "
"properties can be changed. In some cases, it is desired that they do run "
"inside the editor (as long as they don't execute game code or manually avoid "
"doing so). For this, the ``@tool`` annotation exists and must be placed at "
"the top of the file:"
msgstr ""
"預設情況下，腳本不會在編輯器內執行，且僅能修改匯出的屬性。但有時會希望腳本能"
"在編輯器內執行（前提是不要執行遊戲邏輯，或自行避免）。為此可以使用 ``@tool`` "
"註解，並將其放在檔案最上方："

msgid "See :ref:`doc_running_code_in_the_editor` for more information."
msgstr "請參考 :ref:`doc_running_code_in_the_editor` 以瞭解詳情。"

msgid ""
"Be cautious when freeing nodes with ``queue_free()`` or ``free()`` in a tool "
"script (especially the script's owner itself). As tool scripts run their "
"code in the editor, misusing them may lead to crashing the editor."
msgstr ""
"在工具腳本中以 ``queue_free()`` 或 ``free()`` 釋放節點時請特別謹慎（特別是該"
"節點為腳本擁有者時）。由於工具腳本會在編輯器中執行程式碼，若錯誤使用這些方法"
"可能會使編輯器當掉。"

msgid "Memory management"
msgstr "記憶體管理"

msgid ""
"Godot implements reference counting to free certain instances that are no "
"longer used, instead of a garbage collector, or requiring purely manual "
"management. Any instance of the :ref:`class_RefCounted` class (or any class "
"that inherits it, such as :ref:`class_Resource`) will be freed automatically "
"when no longer in use. For an instance of any class that is not "
"a :ref:`class_RefCounted` (such as :ref:`class_Node` or the "
"base :ref:`class_Object` type), it will remain in memory until it is deleted "
"with ``free()`` (or ``queue_free()`` for Nodes)."
msgstr ""
"Godot 實作了參考計數，用來釋放某些不再使用的實例，而非垃圾回收器或要求純粹的"
"手動管理。任何 :ref:`class_RefCounted` 類別 (或任何繼承它的類別，例"
"如 :ref:`class_Resource`) 的實例，當不再使用時將會被自動釋放。對於任何不"
"是 :ref:`class_RefCounted` 的類別的實例 (例如 :ref:`class_Node` 或基"
"底 :ref:`class_Object` 型別)，它將會保留在記憶體中，直到使用 ``free()`` (對"
"於 Node 而言是 ``queue_free()``) 刪除為止。"

msgid ""
"If a :ref:`class_Node` is deleted via ``free()`` or ``queue_free()``, all of "
"its children will also recursively be deleted."
msgstr ""
"如果透過 free() 或queue_free() 刪除 :ref:`class_Node`，它的所有子節點也會被遞"
"歸刪除。"

msgid ""
"To avoid reference cycles that can't be freed, a :ref:`class_WeakRef` "
"function is provided for creating weak references, which allow access to the "
"object without preventing a :ref:`class_RefCounted` from freeing. Here is an "
"example:"
msgstr ""
"為了避免無法釋放的參考循環，提供了一個 :ref:`class_WeakRef` 函式來建立弱引"
"用，它允許存取物件而不阻止 :ref:`class_RefCounted` 釋放。這是一個例子："

msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"或者，不適用參照時，亦可使用 ``is_instance_valid(實體)`` 來判斷一個物件是否已"
"被釋放。"

msgid "Signals"
msgstr "訊號"

msgid ""
"Signals are a tool to emit messages from an object that other objects can "
"react to. To create custom signals for a class, use the ``signal`` keyword."
msgstr ""
"訊號是用來從物件發送可讓其他物件做出反應的一項工具。若要為類別建立自定訊號，"
"請使用 ``signal`` 關鍵字。"

msgid ""
"Signals are a `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ mechanism. They also fill the role of "
"Observers, a common programming pattern. For more information, read the "
"`Observer tutorial <https://gameprogrammingpatterns.com/observer.html>`_ in "
"the Game Programming Patterns ebook."
msgstr ""
"訊號是一種 `回呼 <https://zh.wikipedia.org/zh-tw/"
"%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0>`_ 機制。訊號也充當了 Observer 角色 (一"
"種常見的程式設計模式)。更多資訊請參考 Game Programming Patterns 電子書中的 "
"`Observer tutorial (英語) <https://gameprogrammingpatterns.com/"
"observer.html>`_ 。"

msgid ""
"You can connect these signals to methods the same way you connect built-in "
"signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody3D`."
msgstr ""
"可通過與內建節點訊號 (如 :ref:`class_Button` 或 :ref:`class_RigidBody3D` ) 相"
"同的方法來將自定訊號連接至方法。"

msgid ""
"In the example below, we connect the ``health_depleted`` signal from a "
"``Character`` node to a ``Game`` node. When the ``Character`` node emits the "
"signal, the game node's ``_on_character_health_depleted`` is called:"
msgstr ""
"在以下範例中，我們把 ``Character`` 節點的 ``health_depleted`` 訊號連接到 "
"``Game`` 節點。當 ``Character`` 節點送出該訊號時，會呼叫 Game 節點的 "
"``_on_character_health_depleted``："

msgid "You can emit as many arguments as you want along with a signal."
msgstr "也可以與訊號一起送出任意數量的參數。"

msgid ""
"Here is an example where this is useful. Let's say we want a life bar on "
"screen to react to health changes with an animation, but we want to keep the "
"user interface separate from the player in our scene tree."
msgstr ""
"下列範例說明了如何有效使用這個功能。假設螢幕上有一個血槽，可以動畫顯示生命值"
"的改變，但同時我們也想在場景樹中將使用者界面與玩家分開來。"

msgid ""
"In our ``character.gd`` script, we define a ``health_changed`` signal and "
"emit it with :ref:`Signal.emit() <class_Signal_method_emit>`, and from a "
"``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` "
"using the :ref:`Signal.connect() <class_Signal_method_connect>` method:"
msgstr ""
"在 ``character.gd`` 腳本中，我們定義了 ``health_changed`` 訊號，並透"
"過 :ref:`Signal.emit() <class_Signal_method_emit>` 送出。在場景樹較上層的 "
"``Game`` 節點，我們再使用 :ref:`Signal.connect() "
"<class_Signal_method_connect>` 方法，將該訊號連接到 ``Lifebar``："

msgid ""
"In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, "
"then connect the character, that emits the signal, to the receiver, the "
"``Lifebar`` node in this case."
msgstr ""
"我們在 ``Game`` 中同時取得了 ``Character`` 與 ``Lifebar`` 節點，然後將送出訊"
"號的 Characeter 連接到接收器，也就使本例中的 ``Lifebar`` 節點。"

msgid ""
"This allows the ``Lifebar`` to react to health changes without coupling it "
"to the ``Character`` node."
msgstr ""
"這樣一來便能讓 ``Lifebar`` 對生命值的更改做出反應而無需與 ``Character`` 節點"
"耦合。"

msgid ""
"You can write optional argument names in parentheses after the signal's "
"definition:"
msgstr "你可以在訊號定義後的括號中寫上可選參數名稱："

msgid ""
"These arguments show up in the editor's node dock, and Godot can use them to "
"generate callback functions for you. However, you can still emit any number "
"of arguments when you emit signals; it's up to you to emit the correct "
"values."
msgstr ""
"這些參數會在編輯器的節點 Dock 中顯示，Godot 會使用這些參數來產生回呼函式。"
"但，送出訊號時還是可以送出任意數量的參數，可自行決定是否要送出正確數量的引"
"數。"

msgid ""
"You can also create copies of GDScript Callable objects which accept "
"additional arguments using :ref:`Callable.bind() "
"<class_Callable_method_bind>`. This allows you to add extra information to "
"the connection if the emitted signal itself doesn't give you access to all "
"the data that you need."
msgstr ""
"你也可以使用 :ref:`Callable.bind() <class_Callable_method_bind>` 建立能接受額"
"外參數的 Callable 物件複本。當訊號本身未提供你需要的所有資料時，這能讓你在連"
"接中附加額外資訊。"

msgid ""
"When the signal is emitted, the callback method receives the bound values, "
"in addition to those provided by the signal."
msgstr ""
"當訊號送出時，除了訊號原本提供的參數外，回呼方法也會一併接收到先前繫結的值。"

msgid ""
"Building on the example above, let's say we want to display a log of the "
"damage taken by each character on the screen, like ``Player1 took 22 "
"damage.``. The ``health_changed`` signal doesn't give us the name of the "
"character that took damage. So when we connect the signal to the in-game "
"console, we can add the character's name using the bind method:"
msgstr ""
"延續上面的範例，假設我們想在螢幕上顯示每個角色受到的傷害紀錄，例如 ``Player1 "
"took 22 damage.``。``health_changed`` 訊號並不會提供受到傷害的角色名稱，因此"
"在把訊號連到遊戲內主控台時，我們可以用 bind 方法加上角色名稱："

msgid ""
"Our ``BattleLog`` node receives each bound element as an extra argument:"
msgstr "``BattleLog`` 節點會把每個繫結的元素當作額外參數接收："

msgid "Awaiting signals or coroutines"
msgstr "等待訊號或協程"

msgid ""
"The ``await`` keyword can be used to create `coroutines <https://"
"en.wikipedia.org/wiki/Coroutine>`_ which wait until a signal is emitted "
"before continuing execution. Using the ``await`` keyword with a signal or a "
"call to a function that is also a coroutine will immediately return the "
"control to the caller. When the signal is emitted (or the called coroutine "
"finishes), it will resume execution from the point on where it stopped."
msgstr ""
"``await`` 關鍵字可以用來建立 `共常式 <https://en.wikipedia.org/wiki/"
"Coroutine>`_ ，會等待某個訊號發出之後再繼續執行。對訊號或者對同為協程的函式呼"
"叫使用 ``await`` 關鍵字會立即將控制權返回給呼叫方。發出訊號時（或者呼叫的協程"
"完成時），就會從停止的地方繼續執行。"

msgid ""
"For example, to stop execution until the user presses a button, you can do "
"something like this:"
msgstr "例如，若要暫停執行直到使用者按下按鈕，可以這樣做："

msgid ""
"In this case, the ``wait_confirmation`` becomes a coroutine, which means "
"that the caller also needs to await it:"
msgstr ""
"在此情況下，``wait_confirmation`` 會變成協程，呼叫端也需要對其進行 await："

msgid ""
"Note that requesting a coroutine's return value without ``await`` will "
"trigger an error:"
msgstr "注意：若不使用 ``await`` 卻直接要求協程的回傳值，會觸發錯誤："

msgid ""
"However, if you don't depend on the result, you can just call it "
"asynchronously, which won't stop execution and won't make the current "
"function a coroutine:"
msgstr ""
"不過，如果你不需要結果，也可以直接非同步呼叫。這不會阻斷執行流程，也不會讓目"
"前函式成為協程："

msgid ""
"If you use await with an expression that isn't a signal nor a coroutine, the "
"value will be returned immediately and the function won't give the control "
"back to the caller:"
msgstr ""
"如果對一個既不是訊號、也不是協程的運算式使用 await，會立即回傳其值，而且函式"
"不會把控制權交還給呼叫端："

msgid ""
"This also means that returning a signal from a function that isn't a "
"coroutine will make the caller await that signal:"
msgstr "這也表示，若在非協程的函式中回傳一個訊號，呼叫端就會對該訊號進行等待："

msgid ""
"Unlike ``yield`` in previous Godot versions, you cannot obtain the function "
"state object. This is done to ensure type safety. With this type safety in "
"place, a function cannot say that it returns an ``int`` while it actually "
"returns a function state object during runtime."
msgstr ""
"與之前版本 Godot 中的 ``yield`` 不同，你無法獲取函式狀態物件。這是出於型別安"
"全的考慮。要實作型別安全，函式就沒法說自己在返回 ``int`` 的同時還可能在運作時"
"返回函式狀態物件。"

msgid "Assert keyword"
msgstr "Assert 關鍵字"

msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds. This means that the "
"expression passed as argument won't be evaluated in a project exported in "
"release mode. Due to this, assertions must **not** contain expressions that "
"have side effects. Otherwise, the behavior of the script would vary "
"depending on whether the project is run in a debug build."
msgstr ""
"``assert`` 關鍵字可以用來在除錯建置中檢查條件。這些判斷提示會在非除錯建置中忽"
"略。這表示作為參數傳遞的運算式在以發行模式匯出的專案中將不會被計算。因此，判"
"斷提示 **不可** 包含有副作用的運算式。否則，腳本會因為專案是否於除錯建置中而"
"有不同的行為。"

msgid ""
"When running a project from the editor, the project will be paused if an "
"assertion error occurs."
msgstr "若從編輯器中執行專案，則專案會在判斷提示發生錯誤時暫停。"

msgid ""
"You can optionally pass a custom error message to be shown if the assertion "
"fails:"
msgstr "你也可以傳入自訂錯誤訊息，當斷言失敗時會顯示該訊息："
