#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Static typing in GDScript"
msgstr "GDScript 的靜態型別"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你將學到："

msgid "how to use static typing in GDScript;"
msgstr "如何在 GDScript 中使用靜態型別;"

msgid "that static types can help you avoid bugs;"
msgstr "靜態型別可以幫助你避免錯誤;"

msgid "that static typing improves your experience with the editor."
msgstr "靜態型別可以提升你在編輯器中的使用體驗。"

msgid ""
"Where and how you use this language feature is entirely up to you: you can "
"use it only in some sensitive GDScript files, use it everywhere, or don't "
"use it at all."
msgstr ""
"你可以完全自由決定在哪裡以及如何使用這個語言特性：你可以只在某些關鍵的 "
"GDScript 檔案使用、全專案都使用，或完全不使用。"

msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr "你可以在變數、常數、函式、參數及回傳型別上使用靜態型別。"

msgid "A brief look at static typing"
msgstr "靜態型別簡介"

msgid ""
"With static typing, GDScript can detect more errors without even running the "
"code. Also type hints give you and your teammates more information as you're "
"working, as the arguments' types show up when you call a method. Static "
"typing improves editor autocompletion and :ref:`documentation "
"<doc_gdscript_documentation_comments>` of your scripts."
msgstr ""
"有了靜態型別，GDScript 可以在不執行程式碼的情況下偵測出更多錯誤。型別提示也能"
"在你或團隊成員撰寫程式時，於方法呼叫時顯示參數型別，讓大家獲得更多資訊。靜態"
"型別還能提升編輯器的自動補全與 :ref:`腳本註解文件 "
"<doc_gdscript_documentation_comments>` 的效果。"

msgid ""
"Imagine you're programming an inventory system. You code an ``Item`` class, "
"then an ``Inventory``. To add items to the inventory, the people who work "
"with your code should always pass an ``Item`` to the ``Inventory.add()`` "
"method. With types, you can enforce this::"
msgstr ""
"假設你正在實作一個物品欄系統，寫了一個 ``Item`` 類別，接著有個 "
"``Inventory`` 。為了讓團隊成員只能將 ``Item`` 加入到 ``Inventory.add()`` 方法"
"中，可以透過型別來強制規範："

msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options."
msgstr ""
"靜態型別也能帶來更優秀的程式碼自動補全體驗。下面可以看到動態型別與靜態型別的"
"補全選項差異。"

msgid ""
"You've probably encountered a lack of autocomplete suggestions after a dot:"
msgstr "你也許遇過在輸入「.」後沒有自動補全建議："

msgid "Completion options for dynamic typed code."
msgstr "動態型別程式碼的補全選項。"

msgid ""
"This is due to dynamic code. Godot cannot know what value type you're "
"passing to the function. If you write the type explicitly however, you will "
"get all methods, properties, constants, etc. from the value:"
msgstr ""
"這是因為動態程式碼下，Godot 無法知道你傳遞給函式的值是什麼型別。如果你明確寫"
"出型別，補全就會顯示該型別的所有方法、屬性、常數等："

msgid "Completion options for static typed code."
msgstr "靜態型別程式碼的補全選項。"

msgid ""
"If you prefer static typing, we recommend enabling the **Text Editor > "
"Completion > Add Type Hints** editor setting. Also consider enabling `some "
"warnings <Warning system_>`_ that are disabled by default."
msgstr ""
"如果你偏好靜態型別，建議啟用 **文字編輯器 > 自動完成 > 新增型別提示** 編輯器"
"設定，也可考慮啟用預設停用的 `部分警告 <Warning system>`_ 。"

msgid ""
"Also, typed GDScript improves performance by using optimized opcodes when "
"operand/argument types are known at compile time. More GDScript "
"optimizations are planned in the future, such as JIT/AOT compilation."
msgstr ""
"此外，使用靜態型別的 GDScript 在編譯時若已知運算元／參數型別，會自動使用最佳"
"化的位元碼，提升執行效能。未來還會加入更多最佳化，例如 JIT/AOT 編譯。"

msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you're working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people's code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"總體來說，靜態型別讓你的程式架構更明確，有助於防止錯誤，也讓腳本更容易自我說"
"明。在團隊協作或長期專案中特別實用：研究顯示，多數開發者花最多的時間在閱讀他"
"人或自己過去寫但早已忘記的程式碼。程式碼越清晰、結構越明確，理解就越快，也能"
"讓開發更順暢。"

msgid "How to use static typing"
msgstr "如何使用靜態型別"

msgid ""
"To define the type of a variable, parameter, or constant, write a colon "
"after the name, followed by its type. E.g. ``var health: int``. This forces "
"the variable's type to always stay the same::"
msgstr ""
"要定義變數、參數或常數的型別，只需在名稱後加上冒號，並寫上型別。例如： ``var "
"health: int`` 。如此一來，該變數型別就會被固定："

msgid ""
"Godot will try to infer types if you write a colon, but you omit the type::"
msgstr "如果只寫冒號但省略型別，Godot 會自動推斷型別："

msgid "There is no difference between ``=`` and ``:=`` for constants."
msgstr "對於常數來說，``=`` 與 ``:=`` 沒有差別。"

msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer. Also, this is useful for typed arrays (like "
"``const A: Array[int] = [1, 2, 3]``), since untyped arrays are used by "
"default."
msgstr ""
"常數不一定要寫型別提示，Godot 會自動根據賦值推斷型別。不過，如果你要讓程式碼"
"意圖更明確，還是可以寫上型別。特別是陣列，如果需要使用有型別的陣列（如 "
"``const A: Array[int] = [1, 2, 3]``），就很有幫助，因為預設是無型別陣列。"

msgid "What can be a type hint"
msgstr "哪些內容可以作為型別提示"

msgid "Here is a complete list of what can be used as a type hint:"
msgstr "以下是所有可以用來當作型別提示的項目："

msgid ""
"``Variant``. Any type. In most cases this is not much different from an "
"untyped declaration, but increases readability. As a return type, forces the "
"function to explicitly return some value."
msgstr ""
"``Variant``。代表任何型別。通常和未指定型別差異不大，但能提升可讀性。若指定為"
"回傳型別，則強制函式必須有回傳值。"

msgid ""
"*(Only return type)* ``void``. Indicates that the function does not return "
"any value."
msgstr "（僅用於回傳型別） ``void``。代表函式不會有回傳值。"

msgid ":ref:`Built-in types <doc_gdscript_builtin_types>`."
msgstr ":ref:`內建型別 <doc_gdscript_builtin_types>`。"

msgid "Native classes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)."
msgstr "原生類別（如 ``Object``、``Node``、``Area2D``、``Camera2D`` 等）。"

msgid ":ref:`Global classes <doc_gdscript_basics_class_name>`."
msgstr ":ref:`全域類別 <doc_gdscript_basics_class_name>`。"

msgid ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."
msgstr ":ref:`內部類別 <doc_gdscript_basics_inner_classes>`。"

msgid ""
"Global, native and custom named enums. Note that an enum type is just an "
"``int``, there is no guarantee that the value belongs to the set of enum "
"values."
msgstr ""
"全域、核心與自訂命名的 enum。請注意 enum 實際上是 ``int`` 型別，無法保證它的"
"值一定來自 enum 列舉值集合。"

msgid ""
"Constants (including local ones) if they contain a preloaded class or enum."
msgstr "常數（包含區域常數），只要內容是預載入的類別或 enum。"

msgid ""
"You can use any class, including your custom classes, as types. There are "
"two ways to use them in scripts. The first method is to preload the script "
"you want to use as a type in a constant::"
msgstr ""
"你可以用任何類別（包含自訂類別）作為型別。腳本中指定自訂類別有兩種方式，第一"
"種是在常數中預先載入要當型別用的腳本："

msgid ""
"The second method is to use the ``class_name`` keyword when you create. For "
"the example above, your ``rifle.gd`` would look like this::"
msgstr ""
"第二種方法是在類別腳本中使用 ``class_name`` 關鍵字。以上述範例來說， "
"``rifle.gd`` 會像這樣："

msgid ""
"If you use ``class_name``, Godot registers the ``Rifle`` type globally in "
"the editor, and you can use it anywhere, without having to preload it into a "
"constant::"
msgstr ""
"如果使用 ``class_name``，Godot 會把 Rifle 型別註冊到編輯器全域，你就可以在任"
"何地方直接使用，不用再預載到常數："

msgid "Specify the return type of a function with the arrow ``->``"
msgstr "用箭頭 ``->`` 指定函式的回傳型別"

msgid ""
"To define the return type of a function, write a dash and a right angle "
"bracket ``->`` after its declaration, followed by the return type::"
msgstr "若要定義函式回傳型別，可以在函式宣告後加上 ``->``，再寫回傳型別："

msgid ""
"The type ``void`` means the function does not return anything. You can use "
"any type, as with variables::"
msgstr "型別 ``void`` 代表此函式沒有回傳值。你也可以像變數一樣用其他型別："

msgid "You can also use your own classes as return types::"
msgstr "也可以用自訂類別當作回傳型別："

msgid "Covariance and contravariance"
msgstr "協變與逆變"

msgid ""
"When inheriting base class methods, you should follow the `Liskov "
"substitution principle <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__."
msgstr ""
"繼承基底類別方法時，應遵循 `Liskov 替換原則 <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__。"

msgid ""
"**Covariance:** When you inherit a method, you can specify a return type "
"that is more specific (**subtype**) than the parent method."
msgstr ""
"**協變(Covariance)：** 當你覆寫繼承的方法時，可以指定比父類別更具體（**子型別"
"**）的回傳型別。"

msgid ""
"**Contravariance:** When you inherit a method, you can specify a parameter "
"type that is less specific (**supertype**) than the parent method."
msgstr ""
"**逆變(Contravariance)：** 當你覆寫繼承的方法時，可以指定比父類別更寬泛（**父"
"型別**）的參數型別。"

msgid "Example::"
msgstr "範例："

msgid "Specify the element type of an ``Array``"
msgstr "指定 ``Array`` 元素的型別"

msgid "To define the type of an ``Array``, enclose the type name in ``[]``."
msgstr "要定義 ``Array`` 的型別，請把型別名稱放在 ``[]`` 內。"

msgid ""
"An array's type applies to ``for`` loop variables, as well as some operators "
"like ``[]``, ``[]=``, and ``+``. Array methods (such as ``push_back``) and "
"other operators (such as ``==``) are still untyped. Built-in types, native "
"and custom classes, and enums may be used as element types. Nested array "
"types (like ``Array[Array[int]]``) are not supported."
msgstr ""
"陣列型別會套用到 for 迴圈變數，以及某些運算子（如 ``[]``、``[]=``、``+``）。"
"而陣列方法（如 ``push_back``）與其他運算子（如 ``==``）仍不支援型別。你可以用"
"內建型別、核心類別、自訂類別、enum 當作元素型別。不支援巢狀陣列型別（如 "
"``Array[Array[int]]``）。"

msgid ""
"Since Godot 4.2, you can also specify a type for the loop variable in a "
"``for`` loop. For instance, you can write::"
msgstr ""
"自 Godot 4.2 起，你也可以在 ``for`` 迴圈裡直接指定循環變數的型別。例如："

msgid ""
"The array will remain untyped, but the ``name`` variable within the ``for`` "
"loop will always be of ``String`` type."
msgstr ""
"陣列本身仍然是無型別，但 ``for`` 內的 ``name`` 變數會被固定為 ``String`` 型"
"別。"

msgid "Type casting"
msgstr "型別轉換"

msgid ""
"Type casting is an important concept in typed languages. Casting is the "
"conversion of a value from one type to another."
msgstr ""
"型別轉換是有型別語言很重要的觀念，意思是將一個值從一種型別轉成另一種型別。"

msgid ""
"Imagine an ``Enemy`` in your game, that ``extends Area2D``. You want it to "
"collide with the ``Player``, a ``CharacterBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``body_entered`` signal to "
"detect the collision. With typed code, the body you detect is going to be a "
"generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"假設你的遊戲中有一個繼承自 ``Area2D`` 的 ``Enemy``，你希望它能和附有 "
"``PlayerController`` 腳本的 ``CharacterBody2D`` 玩家碰撞，並用 "
"``body_entered`` 訊號來偵測。這時，型別化的程式碼中你取得到的 body 其實是通用"
"的 ``PhysicsBody2D``，而不是你自訂的 ``PlayerController``。"

msgid ""
"You can check if this ``PhysicsBody2D`` is your ``Player`` with the ``as`` "
"keyword, and using the colon ``:`` again to force the variable to use this "
"type. This forces the variable to stick to the ``PlayerController`` type::"
msgstr ""
"你可以用 ``as`` 關鍵字來檢查這個 ``PhysicsBody2D`` 是否是你的 ``Player``，再"
"用冒號 ``:`` 強制變數成為這個型別。這樣變數就會被固定成 ``PlayerController`` "
"型別："

msgid ""
"As we're dealing with a custom type, if the ``body`` doesn't extend "
"``PlayerController``, the ``player`` variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"因為這裡處理的是自訂型別，如果 ``body`` 不是 ``PlayerController`` 的子類，"
"``player`` 變數就會是 ``null``。你可以用這個特性來判斷 body 是否為玩家。轉型"
"之後，player 變數也會有完整的自動補全。"

msgid ""
"The ``as`` keyword silently casts the variable to ``null`` in case of a type "
"mismatch at runtime, without an error/warning. While this may be convenient "
"in some cases, it can also lead to bugs. Use the ``as`` keyword only if this "
"behavior is intended. A safer alternative is to use the ``is`` keyword::"
msgstr ""
"如果型別不符，``as`` 關鍵字會直接把變數轉成 ``null``，不會報錯也不會警告。這"
"種行為有時很方便，但也可能導致 bug。除非你確定這是你要的行為，否則建議用更安"
"全的 ``is`` 關鍵字："

msgid "You can also simplify the code by using the ``is not`` operator::"
msgstr "你也可以用 ``is not`` 運算子讓程式更簡潔："

msgid "Alternatively, you can use the ``assert()`` statement::"
msgstr "你也可以用 ``assert()`` 敘述："

msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr "如果你嘗試轉型成內建型別但失敗，Godot 會直接拋出錯誤。"

msgid "Safe lines"
msgstr "安全行"

msgid ""
"You can also use casting to ensure safe lines. Safe lines are a tool to tell "
"you when ambiguous lines of code are type-safe. As you can mix and match "
"typed and dynamic code, at times, Godot doesn't have enough information to "
"know if an instruction will trigger an error or not at runtime."
msgstr ""
"你也可以用型別轉換來確保安全行。安全行是 Godot 的一種輔助工具，用來告訴你某行"
"有歧義的程式碼在型別上是否安全。因為你可以混用有型別和動態程式碼，有時 Godot "
"無法判斷某行指令在執行時會不會錯。"

msgid ""
"This happens when you get a child node. Let's take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don't care about the "
"node's type as long as it has the methods you need to call."
msgstr ""
"這種情況通常發生在你取得子節點時。以 Timer 為例，動態寫法可以用 ``$Timer`` 直"
"接取得節點。GDScript 支援 `鴨子型別 <https://stackoverflow.com/a/"
"4205163/8125343>`__，所以即使 Timer 是 ``Timer`` 型別，它同時也是 ``Node`` "
"和 ``Object``。用動態 GDScript，只要該節點有你要呼叫的方法，型別不是重點。"

msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as CharacterBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"你可以用型別轉換讓 Godot 知道你預期取得什麼型別的節點，例如 ``($Timer as "
"Timer)``、``($Player as CharacterBody2D)`` 等。Godot 會檢查型別是否正確，如果"
"正確，腳本編輯器左側的行號會變綠色。"

msgid "Unsafe vs Safe Line"
msgstr "不安全 v.s. 安全行"

msgid "Unsafe line (line 7) vs Safe Lines (line 6 and 8)"
msgstr "不安全行（第 7 行）v.s. 安全行（第 6、8 行）"

msgid ""
"Safe lines do not always mean better or more reliable code. See the note "
"above about the ``as`` keyword. For example::"
msgstr ""
"安全行並不代表程式碼一定較好或較可靠，請參考上面關於 ``as`` 關鍵字的說明。例"
"如："

msgid ""
"Even though ``node_2`` declaration is marked as an unsafe line, it is more "
"reliable than ``node_1`` declaration. Because if you change the node type in "
"the scene and accidentally forget to change it in the script, the error will "
"be detected immediately when the scene is loaded. Unlike ``node_1``, which "
"will be silently cast to ``null`` and the error will be detected later."
msgstr ""
"即使 ``node_2`` 宣告被標記為不安全，但其實比 ``node_1`` 更可靠。因為如果你在"
"場景裡變更節點型別，在腳本裡沒同步更新，載入場景時會立刻報錯。反之，"
"``node_1`` 會靜默被轉成 ``null``，錯誤會延後發現。"

msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr "你可以在編輯器設定中關閉安全行功能，或改變其顏色。"

msgid "Typed or dynamic: stick to one style"
msgstr "靜態型別或動態型別：建議統一風格"

msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But "
"it's recommended to stick to either style for consistency in your codebase, "
"and for your peers. It's easier for everyone to work together if you follow "
"the same guidelines, and faster to read and understand other people's code."
msgstr ""
"靜態型別和動態型別的 GDScript 可以在同一個專案共存，但建議你選擇一種風格統一"
"使用，有助於團隊協作和維護。大家遵循同一套規範，彼此閱讀、理解程式碼會更有效"
"率。"

msgid ""
"Typed code takes a little more writing, but you get the benefits we "
"discussed above. Here's an example of the same, empty script, in a dynamic "
"style::"
msgstr ""
"靜態型別寫法稍微多一些，但你可以得到上述所有好處。以下是相同功能的空白腳本，"
"動態型別寫法："

msgid "And with static typing::"
msgstr "如果用靜態型別則如下："

msgid ""
"As you can see, you can also use types with the engine's virtual methods. "
"Signal callbacks, like any methods, can also use types. Here's a "
"``body_entered`` signal in a dynamic style::"
msgstr ""
"你可以在引擎虛擬方法中指定型別，訊號回呼也一樣。以下是動態風格的 "
"``body_entered`` 訊號範例："

msgid "And the same callback, with type hints::"
msgstr "同樣的回呼，加上型別提示："

msgid "Warning system"
msgstr "警告系統"

msgid ""
"Detailed documentation about the GDScript warning system has been moved "
"to :ref:`doc_gdscript_warning_system`."
msgstr ""
"關於 GDScript 警告系統的詳細說明請參見 :ref:`doc_gdscript_warning_system`。"

msgid ""
"Godot gives you warnings about your code as you write it. The engine "
"identifies sections of your code that may lead to issues at runtime, but "
"lets you decide whether or not you want to leave the code as it is."
msgstr ""
"Godot 會在你寫程式時即時顯示警告。引擎會標示出可能在執行時發生問題的程式碼區"
"段，但最終是否要修改還是保留原樣，由你自己決定。"

msgid ""
"We have a number of warnings aimed specifically at users of typed GDScript. "
"By default, these warnings are disabled, you can enable them in Project "
"Settings (**Debug > GDScript**, make sure **Advanced Settings** is enabled)."
msgstr ""
"系統中有不少警告特別針對使用靜態型別 GDScript 的用戶。這些警告預設是關閉的，"
"你可以在專案設定（**偵錯 > GDScript**，記得先開啟 **進階設定**）裡啟用。"

msgid ""
"You can enable the ``UNTYPED_DECLARATION`` warning if you want to always use "
"static types. Additionally, you can enable the ``INFERRED_DECLARATION`` "
"warning if you prefer a more readable and reliable, but more verbose syntax."
msgstr ""
"如果你想要強制全程使用靜態型別，可以啟用 ``UNTYPED_DECLARATION`` 警告。若你偏"
"好更可讀、更可靠但較冗長的語法，也可以啟用 ``INFERRED_DECLARATION`` 警告。"

msgid ""
"``UNSAFE_*`` warnings make unsafe operations more noticeable, than unsafe "
"lines. Currently, ``UNSAFE_*`` warnings do not cover all cases that unsafe "
"lines cover."
msgstr ""
"``UNSAFE_*`` 警告會讓不安全的操作比安全行標記更顯眼。目前 ``UNSAFE_*`` 警告還"
"沒有涵蓋所有安全行會標示的狀況。"

msgid "Common unsafe operations and their safe counterparts"
msgstr "常見的不安全操作與對應的安全寫法"

msgid "``UNSAFE_PROPERTY_ACCESS`` and ``UNSAFE_METHOD_ACCESS`` warnings"
msgstr "``UNSAFE_PROPERTY_ACCESS`` 和 ``UNSAFE_METHOD_ACCESS`` 警告"

msgid ""
"In this example, we aim to set a property and call a method on an object "
"that has a script attached with ``class_name MyScript`` and that ``extends "
"Node2D``. If we have a reference to the object as a ``Node2D`` (for "
"instance, as it was passed to us by the physics system), we can first check "
"if the property and method exist and then set and call them if they do::"
msgstr ""
"假設有一個物件掛有 ``class_name MyScript``、繼承自 ``Node2D`` 的腳本。我們手"
"上只有 ``Node2D`` 型別的參考（例如物理系統傳給我們），可以先檢查屬性和方法是"
"否存在，再來設定或呼叫："

msgid ""
"However, this code will produce ``UNSAFE_PROPERTY_ACCESS`` and "
"``UNSAFE_METHOD_ACCESS`` warnings as the property and method are not present "
"in the referenced type - in this case a ``Node2D``. To make these operations "
"safe, you can first check if the object is of type ``MyScript`` using the "
"``is`` keyword and then declare a variable with the type ``MyScript`` on "
"which you can set its properties and call its methods::"
msgstr ""
"但這段程式會出現 ``UNSAFE_PROPERTY_ACCESS`` 和 ``UNSAFE_METHOD_ACCESS`` 警"
"告，因為這些屬性和方法並不存在於 ``Node2D``。安全做法是先用 ``is`` 關鍵字檢查"
"型別，再宣告一個 ``MyScript`` 型別的變數，這樣就能安全存取："

msgid ""
"Alternatively, you can declare a variable and use the ``as`` operator to try "
"to cast the object. You'll then want to check whether the cast was "
"successful by confirming that the variable was assigned::"
msgstr ""
"你也可以先宣告一個變數，用 ``as`` 嘗試轉型，然後檢查變數是否有值來判斷是否轉"
"型成功："

msgid "``UNSAFE_CAST`` warning"
msgstr "``UNSAFE_CAST`` 警告"

msgid ""
"In this example, we would like the label connected to an object entering our "
"collision area to show the area's name. Once the object enters the collision "
"area, the physics system sends a signal with a ``Node2D`` object, and the "
"most straightforward (but not statically typed) solution to do what we want "
"could be achieved like this::"
msgstr ""
"在下例中，我們想讓一個碰撞區域內的 label 顯示區域名稱。當有物件進入碰撞區時，"
"物理系統會傳給我們一個 ``Node2D`` 物件。最直接（但沒用靜態型別）的寫法如下："

msgid ""
"This piece of code produces an ``UNSAFE_PROPERTY_ACCESS`` warning because "
"``label`` is not defined in ``Node2D``. To solve this, we could first check "
"if the ``label`` property exist and cast it to type ``Label`` before "
"settings its text property like so::"
msgstr ""
"這段程式會出現 ``UNSAFE_PROPERTY_ACCESS`` 警告，因為 ``Node2D`` 沒有 "
"``label`` 屬性。你可以先檢查 ``label`` 是否存在，再轉型成 ``Label`` 再設定其"
"文字屬性："

msgid ""
"However, this produces an ``UNSAFE_CAST`` warning because ``body.label`` is "
"of a ``Variant`` type. To safely get the property in the type you want, you "
"can use the ``Object.get()`` method which returns the object as a "
"``Variant`` value or returns ``null`` if the property doesn't exist. You can "
"then determine whether the property contains an object of the right type "
"using the ``is`` keyword, and finally declare a statically typed variable "
"with the object::"
msgstr ""
"但這樣會產生 ``UNSAFE_CAST`` 警告，因為 ``body.label`` 是 ``Variant`` 型別。"
"安全的方式是用 ``Object.get()`` 方法取得屬性，它會回傳 ``Variant`` 或 "
"``null``。再用 ``is`` 關鍵字檢查型別，最後宣告一個靜態型別變數："

msgid "Cases where you can't specify types"
msgstr "無法指定型別的情境"

msgid ""
"To wrap up this introduction, let's mention cases where you can't use type "
"hints. This will trigger a **syntax error**."
msgstr "最後補充無法使用型別提示的情況。以下做法都會造成 **語法錯誤** 。"

msgid ""
"You can't specify the type of individual elements in an array or a "
"dictionary::"
msgstr "你不能對陣列或字典的個別元素指定型別："

msgid "Nested types are not currently supported::"
msgstr "目前不支援巢狀型別："

msgid "Summary"
msgstr "總結"

msgid ""
"Typed GDScript is a powerful tool. It helps you write more structured code, "
"avoid common errors, and create scalable and reliable systems. Static types "
"improve GDScript performance and more optimizations are planned for the "
"future."
msgstr ""
"靜態型別的 GDScript 是一項強大的工具。它能幫助你寫出結構更清晰的程式、減少常"
"見錯誤，並建立更具擴充性與可靠性的系統。靜態型別也能提升 GDScript 效能，未來"
"還會有更多最佳化。"
