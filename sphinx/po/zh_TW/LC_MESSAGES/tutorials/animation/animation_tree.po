#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using AnimationTree"
msgstr "使用 AnimationTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"With :ref:`AnimationPlayer <class_AnimationPlayer>`, Godot has one of the "
"most flexible animation systems that you can find in any game engine. It is "
"pretty much unique in its ability to animate almost any property in any node "
"or resource, and its dedicated transform, bezier, function calling, audio, "
"and sub-animation tracks."
msgstr ""
"透過 :ref:`AnimationPlayer <class_AnimationPlayer>`，Godot 擁有遊戲引擎中相當"
"靈活的動畫系統之一。它幾乎可以為任何節點或資源上的任意屬性建立動畫，並具備專"
"用的 Transform、Bezier、函式呼叫、音訊與子動畫軌道等能力，十分獨特。"

msgid ""
"However, the support for blending those animations via ``AnimationPlayer`` "
"is limited, as you can only set a fixed cross-fade transition time."
msgstr ""
"不過，透過 ``AnimationPlayer`` 混合動畫的能力較為有限，只能設定固定的交叉淡化"
"過場時間。"

msgid ""
":ref:`AnimationTree <class_AnimationTree>` is a new node introduced in Godot "
"3.1 to deal with advanced transitions. It replaces the ancient "
"``AnimationTreePlayer``, while adding a huge amount of features and "
"flexibility."
msgstr ""
":ref:`AnimationTree <class_AnimationTree>` 是 Godot 3.1 引入用於處理進階轉場"
"的節點。它取代了舊的 ``AnimationTreePlayer``，並帶來大量功能與更高的彈性。"

msgid "AnimationTree and AnimationPlayer"
msgstr "AnimationTree 與 AnimationPlayer"

msgid ""
"Before starting, know that an ``AnimationTree`` node does not contain its "
"own animations. Instead, it uses animations contained in an "
"``AnimationPlayer`` node. You create, edit, or import your animations in an "
"``AnimationPlayer`` and then use an ``AnimationTree`` to control the "
"playback."
msgstr ""
"開始之前，請先了解 ``AnimationTree`` 節點本身不包含動畫，它會使用 "
"``AnimationPlayer`` 節點中的動畫。你在 ``AnimationPlayer`` 中建立、編輯或匯入"
"動畫，再用 ``AnimationTree`` 來控制播放。"

msgid ""
"``AnimationPlayer`` and ``AnimationTree`` can be used in both 2D and 3D "
"scenes. When importing 3D scenes and their animations, you can use `name "
"suffixes <https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/"
"importing_3d_scenes/node_type_customization.html#animation-loop-loop-"
"cycle>`_ to simplify the process and import with the correct properties. At "
"the end, the imported Godot scene will contain the animations in an "
"``AnimationPlayer`` node. Since you rarely use imported scenes directly in "
"Godot (they are either instantiated or inherited from), you can place the "
"``AnimationTree`` node in your new scene which contains the imported one. "
"Afterwards, point the ``AnimationTree`` node to the ``AnimationPlayer`` that "
"was created in the imported scene."
msgstr ""
"``AnimationPlayer`` 與 ``AnimationTree`` 可用於 2D 與 3D 場景。匯入 3D 場景及"
"其動畫時，你可以使用 `名稱後綴 <https://docs.godotengine.org/en/stable/"
"tutorials/assets_pipeline/importing_3d_scenes/"
"node_type_customization.html#animation-loop-loop-cycle>`_ 來簡化流程並以正確"
"屬性匯入。最後，匯入的 Godot 場景會在一個 ``AnimationPlayer`` 節點中包含這些"
"動畫。由於在 Godot 中很少直接使用匯入場景（通常會實例化或繼承），你可以在包含"
"該匯入場景的新場景中放置一個 ``AnimationTree`` 節點。之後，將該 "
"``AnimationTree`` 指向匯入場景中所建立的 ``AnimationPlayer`` 。"

msgid ""
"This is how it's done in the `Third Person Shooter demo <https://"
"godotengine.org/asset-library/asset/678>`_, for reference:"
msgstr ""
"作為參考，`第三人稱射擊範例 <https://godotengine.org/asset-library/asset/"
"678>`_ 就是這樣配置的："

msgid ""
"A new scene was created for the player with a ``CharacterBody3D`` as root. "
"Inside this scene, the original ``.dae`` (Collada) file was instantiated and "
"an ``AnimationTree`` node was created."
msgstr ""
"這裡為玩家建立了一個以 ``CharacterBody3D`` 為根節點的新場景。場景中產生實體原"
"本的 ``.dae``（Collada）檔案，並新增一個 ``AnimationTree`` 節點。"

msgid "Creating a tree"
msgstr "建立樹狀結構"

msgid ""
"To use an ``AnimationTree``, you have to set a root node. An animation root "
"node is a class that contains and evaluates sub-nodes and outputs an "
"animation. There are 3 types of sub-nodes:"
msgstr ""
"要使用 ``AnimationTree``，你需要設定一個根節點。動畫根節點是一種用來包含並評"
"估子節點、輸出動畫的類別。子節點有三種類型："

msgid ""
"Animation nodes, which reference an animation from the linked "
"``AnimationPlayer``."
msgstr "動畫節點，會從已連結的 ``AnimationPlayer`` 取得動畫來使用。"

msgid ""
"Animation Root nodes, which are used to blend sub-nodes and can be nested."
msgstr "動畫根節點：用於混合子節點，且可以巢狀。"

msgid ""
"Animation Blend nodes, which are used in an ``AnimationNodeBlendTree``, a 2D "
"graph of nodes. Blend nodes take multiple input ports and give one output "
"port."
msgstr ""
"動畫混合節點：用於 ``AnimationNodeBlendTree`` (一個 2D 節點圖) 中。混合節點具"
"有多個輸入端子，並輸出單一端子。"

msgid "A few types of root nodes are available:"
msgstr "可用的根節點類型有："

msgid ""
"``AnimationNodeAnimation``: Selects an animation from the list and plays it. "
"This is the simplest root node, and generally not used as a root."
msgstr ""
"``AnimationNodeAnimation``：從列表中選擇並播放一段動畫。這是最簡單的節點，通"
"常不會直接用作根節點。"

msgid ""
"``AnimationNodeBlendTree``: Contains multiple nodes as children in a graph. "
"Many blend nodes are available, such as mix, blend2, blend3, one shot, etc."
msgstr ""
"``AnimationNodeBlendTree``：在圖表中包含多個子節點。提供許多混合節點，例如 "
"mix、blend2、blend3、one shot 等。"

msgid ""
"``AnimationNodeBlendSpace1D``: Allows linear blending between two animation "
"nodes. Control the blend position in a 1D blend space to mix between "
"animations."
msgstr ""
"``AnimationNodeBlendSpace1D``：允許在一維空間中於多個動畫節點間做線性混合。你"
"可在 1D 混合空間中控制位置來混合動畫。"

msgid ""
"``AnimationNodeBlendSpace2D``: Allows linear blending between three "
"animation nodes. Control the blend position in a 2D blend space to mix "
"between animations."
msgstr ""
"``AnimationNodeBlendSpace2D``：允許在二維空間中於三個或以上的動畫節點間做線性"
"混合。你可在 2D 混合空間中控制位置來混合動畫。"

msgid ""
"``AnimationNodeStateMachine``: Contains multiple nodes as children in a "
"graph. Each node is used as a state, with multiple functions used to "
"alternate between states."
msgstr ""
"``AnimationNodeStateMachine``：在圖表中包含多個子節點。每個節點代表一個狀態，"
"並提供多種在狀態間切換的機制。"

msgid "Blend tree"
msgstr "混合樹"

msgid ""
"When you make an ``AnimationNodeBlendTree``, you get an empty 2d graph in "
"the bottom panel, under the AnimationTree tab. It contains only an "
"``Output`` node by default."
msgstr ""
"建立 ``AnimationNodeBlendTree`` 後，會在下方面板的 AnimationTree 分頁中得到一"
"個空的 2D 圖表，預設只包含一個 ``Output`` 節點。"

msgid ""
"In order for animations to play, a node has to be connected to the output. "
"You can add nodes from the **Add Node..** menu or by right clicking an empty "
"space:"
msgstr ""
"要讓動畫播放，必須有節點連到輸出端。你可以透過 **Add Node..** 功能表或在空白"
"處按右鍵來加入節點："

msgid ""
"The simplest connection to make is to connect an ``Animation`` node to the "
"output directly, which will just play back the animation."
msgstr ""
"最簡單的做法是直接把一個 ``Animation`` 節點連到輸出，這樣就會播放該動畫。"

msgid "Following is a description of the other available nodes:"
msgstr "以下是其他可用節點的說明："

msgid "Blend2 / Blend3"
msgstr "混合2/混合3"

msgid ""
"These nodes will blend between two or three inputs by a user-specified blend "
"value:"
msgstr "這些節點將通過使用者指定輸入的兩個或三個混合值之間進行混合:"

msgid ""
"Blending can use **filters** to control individually which tracks get "
"blended and which do not. This can be useful for layering animations on top "
"of each other."
msgstr ""
"混合可使用 **濾鏡** 來個別控制哪些軌道要被混合、哪些不混合。這對於做動畫分層"
"非常有用。"

msgid ""
"For more complex blending, it is recommended to use blend spaces instead."
msgstr "若需要更複雜的混合，建議改用混合空間（Blend Space）。"

msgid "OneShot"
msgstr "OneShot"

msgid ""
"This node will execute an animation once and return when it finishes. You "
"can customize blend times for fading in and out, as well as filters."
msgstr "此節點會執行一次動畫並在結束時返回。你可以自訂淡入淡出時間與濾鏡。"

msgid "TimeSeek"
msgstr "時間縮放"

msgid ""
"This node allows you to seek to a time in the animation connected to its "
"`in` input. Use this node to play an ``Animation`` starting from a certain "
"playback position. Note that the seek request value is measured in seconds, "
"so if you would like to play an animation from the beginning, set the value "
"to ``0.0``, or if you would like to play an animation from 3 seconds in, set "
"the value to ``3.0``."
msgstr ""
"此節點可在連到其 `in` 輸入的動畫中尋址到特定時間點。用它可以從某個播放位置開"
"始播放一段 ``Animation``。注意尋址的值以秒為單位，若要從開頭播放請設為 "
"``0.0``，若要從第 3 秒開始播放請設為 ``3.0``。"

msgid "TimeScale"
msgstr "時間縮放"

msgid ""
"This node allows you to scale the speed of the animation connected to its "
"`in` input. The speed of the animation will be multiplied by the number in "
"the `scale` parameter. Setting the scale to 0 will pause the animation. "
"Setting the scale to a negative number will play the animation backwards."
msgstr ""
"此節點可調整連到其 `in` 輸入的動畫速度。動畫速度會乘上 `scale` 參數的數值；設"
"為 0 會暫停動畫；設為負值則會反向播放。"

msgid "Transition"
msgstr "轉場效果"

msgid ""
"This node is a simplified version of a StateMachine. You connect animations "
"to the inputs, and the current state index determines which animation to "
"play. You may specify a crossfade transition time. In the Inspector, you may "
"change the number of input ports, rearrange inputs, or delete inputs."
msgstr ""
"此節點是狀態機的簡化版。你將動畫連到各個輸入端，當前狀態索引決定要播放哪個動"
"畫。你可以指定交叉淡化的過場時間。於屬性檢視器中也可更改輸入端數量、重新排列"
"或刪除輸入端。"

msgid "StateMachine"
msgstr "狀態機"

msgid ""
"When you make an ``AnimationNodeStateMachine``, you get an empty 2d graph in "
"the bottom panel, under the AnimationTree tab. It contains a ``Start`` and "
"``End`` state by default."
msgstr ""
"建立 ``AnimationNodeStateMachine`` 後，會在下方面板的 AnimationTree 分頁得到"
"一個空的 2D 圖表，預設包含 ``Start`` 與 ``End`` 兩個狀態。"

msgid ""
"To add states, right click or use the **create new nodes** button, whose "
"icon is a plus in a box. You can add animations, blendspaces, blendtrees, or "
"even another StateMachine. To edit one of these more complex sub-nodes, "
"click on the pencil icon on the right of the state. To return to the "
"original StateMachine, click **Root** on the top left of the panel."
msgstr ""
"要新增狀態，請按右鍵或使用 **建立新節點** 按鈕 (方框內加號圖示) 。你可以加入"
"動畫、混合空間、混合樹，甚至是另一個狀態機。要編輯這些較複雜的子節點，點選該"
"狀態右側的鉛筆圖示。要回到最上層狀態機，點選面板左上角的 **Root**。"

msgid ""
"Before the StateMachine can do anything useful, the states must be connected "
"with transitions. To add a transition, click the **connect nodes** button, "
"which is a line with a right-facing arrow, and drag between two states. You "
"can create 2 transitions between states, one going in each direction."
msgstr ""
"在狀態機能發揮作用前，必須以轉場把各個狀態連起來。要新增轉場，按下 **連結節點"
"** 按鈕 (右向箭頭的線條圖示) ，然後在兩個狀態間拖曳建立。你可以在兩個狀態間建"
"立兩條轉場，分別對應兩個方向。"

msgid "There are 3 types of transitions:"
msgstr "轉場類型有三種："

msgid "*Immediate*: Will switch to the next state immediately."
msgstr "*立即* ：會立刻切換到下一個狀態。"

msgid ""
"*Sync*: Will switch to the next state immediately, but will seek the new "
"state to the playback position of the old state."
msgstr ""
"*Sync* （同步）：立即切換到下一個狀態，但會將新狀態快進並到舊狀態的播放位置。"

msgid ""
"*At End*: Will wait for the current state playback to end, then switch to "
"the beginning of the next state animation."
msgstr ""
"*At End* （末尾）：將等待目前狀態播放結束，然後切換到下一個狀態動畫的開頭。"

msgid ""
"Transitions also have a few properties. Click a transition and it will be "
"displayed in the inspector:"
msgstr "轉場也有一些屬性。點選任一轉場後，可在屬性檢視器中看到其設定："

msgid "*Xfade Time* is the time to cross-fade between this state and the next."
msgstr "*Xfade Time* （疊化時間）是在這個狀態和下一個狀態之間交叉漸變的時間。"

msgid ""
"*Xfade Curve* is a cross-fade following a curve rather than a linear blend."
msgstr "*Xfade Curve*：以曲線而非線性方式進行交叉淡化。"

msgid ""
"*Reset* determines whether the state you are switching into plays from the "
"beginning (true) or not (false)."
msgstr ""
"*Reset*：決定切換進入的狀態是否從頭開始播放（true）或保持當前進度（false）。"

msgid ""
"*Priority* is used together with the ``travel()`` function from code (more "
"on this later). Lower priority transitions are preferred when travelling "
"through the tree."
msgstr ""
"*Priority* （優先順序）與程式碼中的 ``travel()`` 函式一起使用（後述）。當從一"
"個狀態到另一個狀態時，會優先使用優先順序較低的過渡。"

msgid ""
"*Switch Mode* is the transition type (see above). It can be changed after "
"creation here."
msgstr "*Switch Mode*：即轉場類型（見上）。建立後仍可於此更改。"

msgid ""
"*Advance Mode* determines the advance mode. If ``Disabled``, the transition "
"will not be used. If ``Enabled``, the transition will only be used during "
"``travel()``. If ``Auto``, the transition will be used if the advance "
"condition and expression are true, or if there are no advance conditions/"
"expressions."
msgstr ""
"*Advance Mode*：決定推進模式。若為 ``Disabled``，則不使用該轉場；若為 "
"``Enabled``，則只會在 ``travel()`` 期間使用；若為 ``Auto``，則在推進條件與推"
"進運算式成立，或沒有設定任何條件/運算式時使用。"

msgid "Advance Condition and Advance Expression"
msgstr "Advance Condition 與 Advance Expression"

msgid ""
"The last 2 properties in a StateMachine transition are ``Advance Condition`` "
"and ``Advance Expression.`` When the Advance Mode is set to *Auto*, these "
"determine if the transition will advance or not."
msgstr ""
"狀態機轉場的最後兩個屬性是 ``Advance Condition`` 與 ``Advance Expression``。"
"當 Advance Mode 設為 *Auto* 時，這兩者決定轉場是否會推進。"

msgid ""
"Advance Condition is a true/false check. You may put a custom variable name "
"in the text field, and when the StateMachine reaches this transition, it "
"will check if your variable is *true*. If so, the transition continues. Note "
"that the advance condition **only** checks if a variable is *true*, and it "
"cannot check for falseness."
msgstr ""
"Advance Condition 是布林檢查。你可在文字欄位填入自訂變數名稱，當狀態機到達此"
"轉場時，會檢查該變數是否為 *true*。若為 true，則進行轉場。請注意，Advance "
"Condition **只會** 檢查變數是否為 *true*，無法檢查為 false 的情況。"

msgid ""
"This gives the Advance Condition a very limited capability. If you wanted to "
"make a transition back and forth based on one property, you would need to "
"make 2 variables that have opposite values, and check if either of them are "
"true. This is why, in Godot 4, the Advance Expression was added."
msgstr ""
"這使得 Advance Condition 的能力相當受限。若你想基於同一個屬性在兩個狀態間來回"
"切換，就得建立兩個互為相反值的變數，並檢查其中任一是否為 true。這也是為什麼"
"在 Godot 4 中加入了 Advance Expression。"

msgid ""
"The Advance Expression works similar to the Advance Condition, but instead "
"of checking if one variable is true, it evaluates any expression. An "
"expression is anything you could put in an ``if`` statement. These are all "
"examples of expressions that would work in the Advance Expression:"
msgstr ""
"Advance Expression 與 Advance Condition 類似，但它不是檢查單一變數為 true，而"
"是評估任意運算式。運算式可以是你會放在 ``if`` 敘述中的任何條件。以下是可用於 "
"Advance Expression 的範例："

msgid "``is_walking``"
msgstr "``is_walking``"

msgid "``is_walking`` == true"
msgstr "``is_walking`` == true"

msgid "``is_walking && !is_idle``"
msgstr "``is_walking && !is_idle``"

msgid "``velocity > 0``"
msgstr "``velocity > 0``"

msgid "``player.is_on_floor()``"
msgstr "``player.is_on_floor()``"

msgid ""
"Here is an example of an improperly-set-up StateMachine transition using "
"Advance Condition:"
msgstr "以下是使用 Advance Condition 設定不當的狀態機轉場範例："

msgid ""
"This is not working because there is a ``!`` variable in the Advance "
"Condition, which cannot be checked."
msgstr ""
"這樣無法運作，因為 Advance Condition 中包含了 ``!`` 的變數，無法被檢查。"

msgid ""
"Here is the same example, set up properly, using two opposite variables:"
msgstr "以下是同一個情境的正確作法，使用兩個相反值的變數："

msgid ""
"Here is the same example, but using Advance Expression rather than Advance "
"Condition, which eliminates the need for two variables:"
msgstr "以下是同一個情境改用 Advance Expression 的作法，就不需要兩個變數了："

msgid ""
"In order to use Advance Expressions, the Advance Expression Base Node has to "
"be set from the Inspector of the AnimationTree node. By default, it is set "
"to the AnimationTree node itself, but it needs to point to whatever node "
"contains the script with your animation variables."
msgstr ""
"要使用 Advance Expression，必須在 AnimationTree 節點的屬性檢視器中設定 "
"Advance Expression Base Node。預設為 AnimationTree 節點本身，但應指向實際持有"
"動畫變數腳本的那個節點。"

msgid "StateMachine travel"
msgstr "狀態機 travel"

msgid ""
"One of the nice features in Godot's ``StateMachine`` implementation is the "
"ability to travel. You can instruct the graph to go from the current state "
"to another one, while visiting all the intermediate ones. This is done via "
"the A\\* algorithm. If there is no path of transitions starting at the "
"current state and finishing at the destination state, the graph teleports to "
"the destination state."
msgstr ""
"Godot 的 ``StateMachine`` 有個相當方便的能力：travel。你可以指示圖表從目前狀"
"態前往另一個狀態，並依序經過所有中間狀態。這是透過 A\\* 演算法完成的。若從目"
"前狀態到目標狀態之間不存在轉場路徑，圖表就會直接傳送到目標狀態。"

msgid ""
"To use the travel ability, you should first retrieve "
"the :ref:`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` object from the ``AnimationTree`` "
"node (it is exported as a property), and then call one of its many functions:"
msgstr ""
"要使用 travel 能力，應先自 ``AnimationTree`` 節點取"
"得 :ref:`AnimationNodeStateMachinePlayback "
"<class_AnimationNodeStateMachinePlayback>` 物件（它以屬性形式匯出），接著呼叫"
"其中的相關方法："

msgid ""
"The StateMachine must be running before you can travel. Make sure to either "
"call ``start()`` or connect a node to **Start**."
msgstr ""
"在使用 travel 前，狀態機必須已開始運作。請確保你已呼叫 ``start()``，或已連結"
"某節點到 **Start**。"

msgid "BlendSpace2D and BlendSpace1D"
msgstr "BlendSpace2D 與 BlendSpace1D"

msgid ""
"``BlendSpace2D`` is a node to do advanced blending in two dimensions. Points "
"representing animations are added to a 2D space and then a position between "
"them is controlled to determine the blending:"
msgstr ""
"``BlendSpace2D`` 是在二維空間進行進階混合的節點。你會將代表各動畫的點加入 2D "
"空間中，並控制空間中的位置來決定混合結果："

msgid ""
"You may place these points anywhere on the graph by right clicking or using "
"the **add point** button, whose icon is a pen and point. Wherever you place "
"the points, the triangle between them will be generated automatically using "
"Delaunay. You may also control and label the ranges in X and Y."
msgstr ""
"你可以在圖表上按右鍵或使用 **新增點** 按鈕 (鋼筆與點的圖示) 把點放在任意位"
"置。無論你把點放在哪裡，兩兩之間的三角形都會以 Delaunay 自動生成。你也可以設"
"定並標示 X 與 Y 的範圍。"

msgid ""
"Finally, you may also change the blend mode. By default, blending happens by "
"interpolating points inside the closest triangle. When dealing with 2D "
"animations (frame by frame), you may want to switch to *Discrete* mode. "
"Alternatively, if you want to keep the current play position when switching "
"between discrete animations, there is a *Carry* mode. This mode can be "
"changed in the *Blend* menu:"
msgstr ""
"最後，你也可以更改混合模式。預設情況下，混合會在最近的三角形內進行插值。處理"
"逐格的 2D 動畫時，你可能會想切換到 *Discrete* 模式。或者，若你希望在離散動畫"
"間切換時保留目前的播放進度，可使用 *Carry* 模式。以上模式可在 *Blend* 功能表"
"中更改："

msgid ""
"BlendSpace1D works just like BlendSpace2D, but in one dimension (a line). "
"Triangles are not used."
msgstr ""
"BlendSpace1D 的概念與 BlendSpace2D 相同，但在一維空間（線段）上運作，且不涉及"
"三角形。"

msgid "For better blending"
msgstr "為了更好的混合"

msgid ""
"In Godot 4.0+, in order for the blending results to be deterministic "
"(reproducible and always consistent), the blended property values must have "
"a specific initial value. For example, in the case of two animations to be "
"blended, if one animation has a property track and the other does not, the "
"blended animation is calculated as if the latter animation had a property "
"track with the initial value."
msgstr ""
"在 Godot 4.0+ 中，為了使混合結果具有確定性（可重現且始終一致），混合屬性值必"
"須具有特定的初始值。例如，在要混合兩個動畫的情況下，如果一個動畫具有屬性軌跡"
"而另一個動畫沒有，則計算混合動畫時就好像後一個動畫具有具有初始值的屬性軌跡一"
"樣。"

msgid ""
"When using Position/Rotation/Scale 3D tracks for Skeleton3D bones, the "
"initial value is Bone Rest. For other properties, the initial value is ``0`` "
"and if the track is present in the ``RESET`` animation, the value of its "
"first keyframe is used instead."
msgstr ""
"當對 Skeleton3D 骨骼使用位置/旋轉/縮放 3D 軌跡時，初始值為 Bone Rest。對於其"
"他屬性，初始值為“0”，如果軌道存在於“RESET”動畫中，則使用其第一個關鍵影格的"
"值。"

msgid ""
"For example, the following AnimationPlayer has two animations, but one of "
"them lacks a Property track for Position."
msgstr ""
"例如，下面的AnimationPlayer有兩個動畫，但其中一個缺少Position的Property軌道。"

msgid ""
"This means that the animation lacking that will treat those Positions as "
"``Vector2(0, 0)``."
msgstr "這意味著缺少的動畫會將這些位置視為「Vector2(0, 0)」。"

msgid ""
"This problem can be solved by adding a Property track for Position as an "
"initial value to the ``RESET`` animation."
msgstr "這個問題可以透過加入一個位置屬性軌跡作為「RESET」動畫的初始值來解決。"

msgid ""
"Be aware that the ``RESET`` animation exists to define the default pose when "
"loading an object originally. It is assumed to have only one frame and is "
"not expected to be played back using the timeline."
msgstr ""
"請注意，「RESET」動畫的存在是為了定義最初載入物件時的預設姿勢。假設它只有一影"
"格，並且預計不會使用時間軸進行播放。"

msgid ""
"Also keep in mind that the Rotation 3D tracks and the Property tracks for 2D "
"rotation with Interpolation Type set to Linear Angle or Cubic Angle will "
"prevent rotations greater than 180 degrees from the initial value as blended "
"animation."
msgstr ""
"此外請留意：若 3D 旋轉軌道與 2D 旋轉的屬性軌道的插值型態設為 Linear Angle 或 "
"Cubic Angle，混合動畫將會避免從初始值出現超過 180 度的旋轉。"

msgid ""
"This can be useful for Skeleton3Ds to prevent the bones penetrating the body "
"when blending animations. Therefore, Skeleton3D's Bone Rest values should be "
"as close to the midpoint of the movable range as possible. **This means that "
"for humanoid models, it is preferable to import them in a T-pose**."
msgstr ""
"這對於 Skeleton3D 很有用，可以在混合動畫時防止骨頭穿透身體。因此，Skeleton3D "
"的 Bone Rest 值應盡可能接近可移動範圍的中點。 **這意味著對於人形模型，最好以 "
"T 形姿勢匯入它們**。"

msgid ""
"You can see that the shortest rotation path from Bone Rests is prioritized "
"rather than the shortest rotation path between animations."
msgstr ""
"您可以看到，優先考慮骨骼休息的最短旋轉路徑，而不是動畫之間的最短旋轉路徑。"

msgid ""
"If you need to rotate Skeleton3D itself more than 180 degrees by blend "
"animations for movement, you can use Root Motion."
msgstr ""
"如果您需要透過混合動畫進行運動來將 Skeleton3D 本身旋轉超過 180 度，則可以使"
"用 Root Motion。"

msgid "Root motion"
msgstr "根骨骼運動"

msgid ""
"When working with 3D animations, a popular technique is for animators to use "
"the root skeleton bone to give motion to the rest of the skeleton. This "
"allows animating characters in a way where steps actually match the floor "
"below. It also allows precise interaction with objects during cinematics."
msgstr ""
"處理 3D 動畫時，一種流行的技術是動畫師利用根骨骼為其餘部分骨骼製作運動動畫。"
"這使得動畫角色的腳步與下面的地板相配對。並且允許在電影拍攝期間與物體進行精確"
"的互動。"

msgid ""
"When playing back the animation in Godot, it is possible to select this bone "
"as the *root motion track*. Doing so will cancel the bone transformation "
"visually (the animation will stay in place)."
msgstr ""
"在 Godot 中重播動畫時，可以選擇這根骨骼作為*根運動軌跡*。這會在視覺上取消這根"
"骨骼的變換（動畫將保持原狀）。"

msgid ""
"Afterwards, the actual motion can be retrieved via the :ref:`AnimationTree "
"<class_AnimationTree>` API as a transform:"
msgstr ""
"然後, 實際運動可以通過 :ref:`AnimationTree <class_AnimationTree>` API 作為轉"
"換:"

msgid ""
"This can be fed to functions such as :ref:`CharacterBody3D.move_and_slide "
"<class_CharacterBody3D_method_move_and_slide>` to control the character "
"movement."
msgstr ""
"可以提供給 :ref:`CharacterBody3D.move_and_slide "
"<class_CharacterBody3D_method_move_and_slide>` 等函式，用來控制角色移動。"

msgid ""
"There is also a tool node, ``RootMotionView``, you can place a scene that "
"will act as a custom floor for your character and animations (this node is "
"disabled by default during the game)."
msgstr ""
"另外還有一個工具節點 ``RootMotionView``，你可以把它放在場景中，作為角色與動畫"
"的自訂地面（此節點在遊戲執行時預設為停用）。"

msgid "Controlling from code"
msgstr "使用程式碼控制"

msgid ""
"After building the tree and previewing it, the only question remaining is "
"\"How is all this controlled from code?\"."
msgstr "建立樹和預覽之後，只剩下一個問題：“如何使用程式碼控制所有的節點？”。"

msgid ""
"Keep in mind that the animation nodes are just resources, so they are shared "
"between all instances using them. Setting values in the nodes directly will "
"affect all instances of the scene that uses this ``AnimationTree``. This is "
"generally undesirable, but does have some cool use cases, e.g. you can copy "
"and paste parts of your animation tree, or reuse nodes with a complex layout "
"(such as a StateMachine or blend space) in different animation trees."
msgstr ""
"請記住動畫節點只是資源，因此會在所有使用它們的實例之間共享。直接修改節點中的"
"值會影響所有使用該 ``AnimationTree`` 的場景實例。這通常不是你想要的，但也有一"
"些不錯的應用，例如可以複製/貼上動畫樹的部分結構，或在不同的動畫樹中重複使用複"
"雜的節點（如狀態機或混合空間）。"

msgid ""
"The actual animation data is contained in the ``AnimationTree`` node and is "
"accessed via properties. Check the \"Parameters\" section of the "
"``AnimationTree`` node to see all the parameters that can be modified in "
"real-time:"
msgstr ""
"實際的動畫封包含在 ``AnimationTree`` 節點中, 並通過屬性存取. 檢查 "
"``AnimationTree`` 節點的 \"參數\" 部分, 查看所有可以即時修改的參數:"

msgid ""
"This is handy because it makes it possible to animate them from an "
"``AnimationPlayer``, or even the ``AnimationTree`` itself, allowing very "
"complex animation logic."
msgstr ""
"這很方便，因為你可以從 ``AnimationPlayer`` 甚至 ``AnimationTree`` 本身來為它"
"們建立動畫，從而實現非常複雜的動畫邏輯。"

msgid ""
"To modify these values from code, you must obtain the property path. You can "
"find them by hovering your mouse over any of the parameters:"
msgstr ""
"若要在程式碼中修改這些數值，你必須取得屬性路徑。將滑鼠游標懸停在任一參數上即"
"可查看："

msgid "Then you can set or read them:"
msgstr "接著你就能讀寫它們："

msgid ""
"Advance Expressions from a StateMachine will not be found under the "
"parameters. This is because they are held in another script rather than the "
"AnimationTree itself. Advance `Conditions` will be found under parameters."
msgstr ""
"狀態機的 Advance Expression 不會出現在參數底下，因為它們儲存在 AnimationTree "
"之外的腳本中；而 Advance `Conditions` 則會出現在參數中。"
