#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Multiple resolutions"
msgstr "多重解析度"

msgid "The problem of multiple resolutions"
msgstr "多重解析度的問題"

msgid ""
"Developers often have trouble understanding how to best support multiple "
"resolutions in their games. For desktop and console games, this is more or "
"less straightforward, as most screen aspect ratios are 16:9 and resolutions "
"are standard (720p, 1080p, 1440p, 4K, …)."
msgstr ""
"開發者常常對於如何在遊戲中最佳化支援多種解析度感到困擾。對於桌面和主機遊戲來"
"說，這較為單純，因為大多數螢幕的長寬比為 16:9，且解析度多為標準規格（720p、"
"1080p、1440p、4K……）。"

msgid ""
"For mobile games, at first, it was easy. For many years, the iPhone and iPad "
"used the same resolution. When *Retina* was implemented, they just doubled "
"the pixel density; most developers had to supply assets in default and "
"double resolutions."
msgstr ""
"行動遊戲一開始也很單純。多年來 iPhone 和 iPad 都使用相同的解析度。引入 "
"*Retina* 後，他們只提高了像素密度，大多數開發者只需要提供預設和雙倍解析度的美"
"術素材。"

msgid ""
"Nowadays, this is no longer the case, as there are plenty of different "
"screen sizes, densities, and aspect ratios. Non-conventional sizes are also "
"becoming increasingly popular, such as ultrawide displays."
msgstr ""
"現在情況已經不同，市面上有許多不同的螢幕尺寸、密度與長寬比。非傳統尺寸（如超"
"寬螢幕）也越來越普及。"

msgid ""
"For 3D games, there is not much of a need to support multiple resolutions "
"(from the aesthetic point of view). The 3D geometry will just fill the "
"screen based on the field of view, disregarding the aspect ratio. The main "
"reason one may want to support this, in this case, is for *performance* "
"reasons (running in lower resolution to increase frames per second)."
msgstr ""
"對於 3D 遊戲來說，從視覺美學的角度並不太需要特別支援多種解析度。3D 幾何會依照"
"視野自動填滿畫面，並不在意螢幕長寬比。唯一可能需要支援多重解析度的情境，是出"
"於 *效能* 考量（以低解析度運作以提升每秒顯示張數）。"

msgid ""
"For 2D and game UIs, this is a different matter, as art needs to be created "
"using specific pixel sizes in software such as Photoshop, GIMP or Krita."
msgstr ""
"但對於 2D 及遊戲 UI 來說情況不同，因為美術素材需要用像 Photoshop、GIMP 或 "
"Krita 這類軟體，以特定像素尺寸繪製。"

msgid ""
"Since layouts, aspect ratios, resolutions, and pixel densities can change so "
"much, it is no longer possible to design UIs for every specific screen. "
"Another method must be used."
msgstr ""
"由於版面配置、長寬比、解析度和像素密度變動幅度大，已經不可能為每一種螢幕設計"
"專屬的 UI，因此必須採用其他方法。"

msgid "One size fits all"
msgstr "統一尺寸適配"

msgid ""
"The most common approach is to use a single *base* resolution and then fit "
"it to everything else. This resolution is how most players are expected to "
"play the game (given their hardware). For mobile, Google has useful `stats "
"<https://developer.android.com/about/dashboards>`_ online, and for desktop, "
"Steam `also does <https://store.steampowered.com/hwsurvey/>`_."
msgstr ""
"最常見的做法是先設定一個 *基準* 解析度，之後再讓其他解析度自動適配。這個基準"
"解析度通常是多數玩家在其硬體上遊玩遊戲時的常見設定。針對行動裝置，Google 提供"
"了 `統計資料 <https://developer.android.com/about/dashboards>`_，而桌面平台則"
"可參考 Steam 的 `硬體調查 <https://store.steampowered.com/hwsurvey/>`_。"

msgid ""
"As an example, Steam shows that the most common *primary display resolution* "
"is 1920×1080, so a sensible approach is to develop a game for this "
"resolution, then handle scaling for different sizes and aspect ratios."
msgstr ""
"舉例來說，Steam 顯示最常見的 *主要顯示解析度* 為 1920×1080，因此明智的做法是"
"以這個解析度開發遊戲，然後再針對不同尺寸與長寬比進行縮放處理。"

msgid "Godot provides several useful tools to do this easily."
msgstr "Godot 提供多種實用工具來簡化這項工作。"

msgid ""
"You can see how Godot's support for multiple resolutions works in action "
"using the `Multiple Resolutions and Aspect Ratios demo project <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__."
msgstr ""
"你可以參考 `Multiple Resolutions and Aspect Ratios 範例專案 <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__，實際體驗 Godot 多解析度支援的運作方式。"

msgid "Base size"
msgstr "基礎尺寸"

msgid ""
"A base size for the window can be specified in the Project Settings under "
"**Display → Window**."
msgstr "你可以在專案設定的 **Display → Window** 項目下指定視窗的基礎尺寸。"

msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"但這項設定的作用並非將螢幕解析度切換為此數值。你可以把這個數值視為「設計尺"
"寸」，也就是你在編輯器中工作的區域大小。這個設定對應 2D 編輯器中藍色矩形的尺"
"寸。"

msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"你經常需要支援螢幕或視窗尺寸與基礎尺寸不同的裝置。Godot 提供多種方法，讓你可"
"以控制視口（viewport）如何縮放或拉伸以適應不同的螢幕尺寸。"

msgid ""
"On this page, *window* refers to the screen area allotted to your game by "
"the system, while *viewport* refers to the root object (accessible from "
"``get_tree().root``) which the game controls to fill this screen area. This "
"viewport is a :ref:`Window <class_Window>` instance. Recall from "
"the :ref:`introduction <doc_viewports>` that *all* Window objects are "
"viewports."
msgstr ""
"在本頁中，*window* 指的是系統分配給遊戲的螢幕區域，而 *viewport* 指的是遊戲控"
"制以填滿螢幕區域的根物件（可透過 ``get_tree().root`` 存取）。這個 viewport 實"
"際上是一個 :ref:`Window <class_Window>` 實例。請回憶 :ref:`介紹 "
"<doc_viewports>` 章節中提到，*所有* Window 物件本質上都是 viewports。"

msgid ""
"To configure the stretch base size at runtime from a script, use the "
"``get_tree().root.content_scale_size`` property "
"(see :ref:`Window.content_scale_size "
"<class_Window_property_content_scale_size>`). Changing this value can "
"indirectly change the size of 2D elements. However, to provide a user-"
"accessible scaling option, "
"using :ref:`doc_multiple_resolutions_stretch_scale` is recommended as it's "
"easier to adjust."
msgstr ""
"若要在執行期間以腳本設定拉伸基礎尺寸，請使用 "
"``get_tree().root.content_scale_size`` 屬性（參"
"見 :ref:`Window.content_scale_size "
"<class_Window_property_content_scale_size>`）。更改此值會間接改變 2D 元素的大"
"小。不過，若要提供給使用者自訂縮放選項，建議使"
"用 :ref:`doc_multiple_resolutions_stretch_scale`，這樣更容易調整。"

msgid ""
"Godot follows a modern approach to multiple resolutions. The engine will "
"never change the monitor's resolution on its own. While changing the "
"monitor's resolution is the most efficient approach, it's also the least "
"reliable approach as it can leave the monitor stuck on a low resolution if "
"the game crashes. This is especially common on macOS or Linux which don't "
"handle resolution changes as well as Windows."
msgstr ""
"Godot 採用現代化的多重解析度處理方式。引擎本身**不會**主動變更螢幕解析度。雖"
"然直接更動螢幕解析度效率最高，但這卻是最不可靠的做法，因為如果遊戲閃退，顯示"
"器可能會卡在低解析度。這種情況在 macOS 或 Linux 上尤其常見，因為它們對於動態"
"解析度切換的處理不如 Windows。"

msgid ""
"Changing the monitor's resolution also removes any control from the game "
"developer over filtering and aspect ratio stretching, which can be important "
"to ensure correct display for pixel art games."
msgstr ""
"更改螢幕解析度也會讓開發者喪失對濾鏡和長寬比拉伸的掌控，這對像素美術遊戲來說"
"尤其重要，否則畫面容易失真。"

msgid ""
"On top of that, changing the monitor's resolution makes alt-tabbing in and "
"out of a game much slower since the monitor has to change resolutions every "
"time this is done."
msgstr ""
"此外，切換螢幕解析度會讓 Alt-Tab 切換遊戲的速度變得很慢，因為每次切換都會重設"
"解析度。"

msgid "Resizing"
msgstr "縮放處理"

msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().root`` or ``get_node(\"/root\")``)."
msgstr ""
"市面上的裝置類型繁多，螢幕種類、像素密度和解析度都不一樣。要全部兼容非常費"
"工，因此 Godot 提供許多工具協助開發者。:ref:`Viewport <class_Viewport>` 節點"
"具備各種縮放處理功能，場景樹的根節點永遠是一個 viewport（載入的場景會被實例化"
"為其子節點，可透過 ``get_tree().root`` 或 ``get_node(\"/root\")`` 取得）。"

msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a set of parameters in the project settings to "
"handle multiple resolutions."
msgstr ""
"雖然直接修改根 Viewport 參數是最彈性的解法，但這會帶來更多工作量、程式碼與推"
"測，因此 Godot 在專案設定中提供了一套參數，讓你輕鬆處理多重解析度。"

msgid "Stretch settings"
msgstr "拉伸設定"

msgid ""
"Stretch settings are located in the project settings and provide several "
"options:"
msgstr "拉伸設定可在專案設定中找到，包含以下選項："

msgid "Stretch Mode"
msgstr "拉伸模式"

msgid ""
"The **Stretch Mode** setting defines how the base size is stretched to fit "
"the resolution of the window or screen. The animations below use a \"base "
"size\" of just 16×9 pixels to demonstrate the effect of different stretch "
"modes. A single sprite, also 16×9 pixels in size, covers the entire "
"viewport, and a diagonal :ref:`Line2D <class_Line2D>` is added on top of it:"
msgstr ""
"**Stretch Mode** （拉伸模式）決定基礎尺寸如何被拉伸來適應螢幕或視窗解析度。以"
"下動畫以 16×9 像素的「基礎尺寸」示範不同拉伸模式的效果。單一精靈（同樣 16×9 "
"像素）覆蓋整個視口，並在上方加上一條對角線 :ref:`Line2D <class_Line2D>` ："

msgid ""
"**Stretch Mode = Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"**Stretch Aspect** setting has no effect."
msgstr ""
"**Stretch Mode = Disabled** （預設）：不進行拉伸。場景中的一單位對應螢幕上一"
"像素。在這種模式下， **Stretch Aspect** （拉伸比例）設定無效。"

msgid ""
"**Stretch Mode = Canvas Items**: In this mode, the base size specified in "
"width and height in the project settings is stretched to cover the whole "
"screen (taking the **Stretch Aspect** setting into account). This means that "
"everything is rendered directly at the target resolution. 3D is unaffected, "
"while in 2D, there is no longer a 1:1 correspondence between sprite pixels "
"and screen pixels, which may result in scaling artifacts."
msgstr ""
"**Stretch Mode = Canvas Items**：在此模式下，專案設定中所指定的寬度與高度（基"
"礎尺寸）會被拉伸以覆蓋整個螢幕（會考慮 **Stretch Aspect** 設定）。這代表所有"
"物件都直接以目標解析度進行算繪。3D 畫面不受影響；而 2D 則不再有精靈像素與螢幕"
"像素的 1:1 對應，可能導致縮放失真。"

msgid ""
"**Stretch Mode = Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the Project Settings' **Display** section. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the **Stretch Aspect** setting into account)."
msgstr ""
"**Stretch Mode = Viewport**：視口拉伸代表根 :ref:`Viewport <class_Viewport>` "
"的尺寸會被精確設為專案設定 **Display** 區段中指定的基礎尺寸，場景會先算繪到這"
"個 viewport，再將這個 viewport 拉伸至螢幕大小（會考慮 **Stretch Aspect** 設"
"定）。"

msgid ""
"To configure the stretch mode at runtime from a script, use the "
"``get_tree().root.content_scale_mode`` property "
"(see :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` and the :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` enum)."
msgstr ""
"若要於執行期間以腳本設定拉伸模式，請使用 "
"``get_tree().root.content_scale_mode`` 屬性（參"
"考 :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` 和 :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` 列舉）。"

msgid "Stretch Aspect"
msgstr "拉伸比例"

msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if **Stretch Mode** is set to something other than **Disabled**."
msgstr ""
"第二個設定是拉伸比例（Stretch Aspect）。僅在 **Stretch Mode** 設為 "
"**Disabled** 以外時才有效。"

msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"在下方動畫中，你會看到灰色與黑色區域。黑色區域由引擎自動產生，無法繪製內容；"
"灰色區域則屬於你的場景，可以繪製。這些灰色區域對應 2D 編輯器中藍色框線外的部"
"分。"

msgid ""
"**Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"**Stretch Aspect = Ignore**：拉伸時忽略長寬比。這表示畫面會被強制拉伸以完全填"
"滿螢幕，不論螢幕比例是否比設計時寬或窄。這可能導致畫面變形，例如物件看起來比"
"原設計更寬或更高。"

msgid ""
"**Stretch Aspect = Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"**Stretch Aspect = Keep**：拉伸時保持長寬比。這表示無論螢幕解析度為何，視口都"
"維持原本尺寸，必要時會在上下（黑邊：Letterbox）或左右（黑邊：Pillarbox）加上"
"黑條。"

msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr "如果你已知目標裝置的長寬比，或不打算處理多種長寬比，這是一個好選擇。"

msgid ""
"**Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"**Stretch Aspect = Keep Width**：拉伸時保持長寬比。如果螢幕比基礎尺寸寬，則左"
"右會加上黑條（Pillarbox）；如果螢幕比基礎尺寸高，視口會往垂直方向擴增（底部會"
"顯示更多內容）。你也可以把這看成「垂直擴充」。"

msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"這通常是設計可縮放 GUI 或 HUD 最佳選擇，你可以將某些控制元件錨定在底部（參"
"考 :ref:`doc_size_and_anchors`）。"

msgid ""
"**Stretch Aspect = Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"**Stretch Aspect = Keep Height**：拉伸時保持長寬比。如果螢幕比基礎尺寸高，則"
"上下會加上黑條（Letterbox）；若螢幕比基礎尺寸寬，則視口會往水平方向擴增（右邊"
"會顯示更多內容）。你也可以把這看成「水平擴充」。"

msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr "這通常適合水平捲動的 2D 遊戲（如跑酷或橫向卷軸平台遊戲）。"

msgid ""
"**Stretch Aspect = Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"**Stretch Aspect = Expand**：拉伸時保持長寬比，但不固定基礎寬度或高度。視口會"
"依據螢幕長寬比，往水平方向（若螢幕比基礎尺寸寬）或垂直方向（若螢幕比基礎尺寸"
"高）擴增。"

msgid ""
"To support both portrait and landscape mode with a similar automatically "
"determined scale factor, set your project's base resolution to be a *square* "
"(1:1 aspect ratio) instead of a rectangle. For instance, if you wish to "
"design for 1280×720 as the base resolution but wish to support both portrait "
"and landscape mode, use 720×720 as the project's base window size in the "
"Project Settings."
msgstr ""
"若要以自動縮放因子同時支援橫向與直向顯示，請將專案的基礎解析度設為 *正方形* "
"（1:1 長寬比）而非矩形。例如你原本想用 1280×720 作為基礎解析度，但想同時支援"
"直向與橫向，則可將專案的基礎視窗尺寸設成 720×720。"

msgid ""
"To allow the user to choose their preferred screen orientation at runtime, "
"remember to set **Display > Window > Handheld > Orientation** to ``sensor``."
msgstr ""
"若要讓玩家能於執行時自由選擇螢幕方向，記得將 **Display > Window > Handheld > "
"Orientation** 設為 ``sensor``。"

msgid ""
"To configure the stretch aspect at runtime from a script, use the "
"``get_tree().root.content_scale_aspect`` property "
"(see :ref:`Window.content_scale_aspect "
"<class_Window_property_content_scale_aspect>` and "
"the :ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` enum)."
msgstr ""
"若要於執行期間以腳本設定拉伸比例，請使用 "
"``get_tree().root.content_scale_aspect`` 屬性（參"
"考 :ref:`Window.content_scale_aspect "
"<class_Window_property_content_scale_aspect>` 和 :ref:`ContentScaleAspect "
"<enum_Window_ContentScaleAspect>` 列舉）。"

msgid "Stretch Scale"
msgstr "縮放比例"

msgid ""
"The **Scale** setting allows you to add an extra scaling factor on top of "
"what the **Stretch** options above already provide. The default value of "
"``1.0`` means that no additional scaling occurs."
msgstr ""
"**Scale**（縮放比例）設定可讓你在上述 **Stretch** 選項的基礎上再額外加上一個"
"縮放因子。預設值 ``1.0`` 代表不額外縮放。"

msgid ""
"For example, if you set **Scale** to ``2.0`` and leave **Stretch Mode** on "
"**Disabled**, each unit in your scene will correspond to 2×2 pixels on the "
"screen. This is a good way to provide scaling options for non-game "
"applications."
msgstr ""
"例如，若設定 **Scale** 為 ``2.0`` 且 **Stretch Mode** 維持 **Disabled**，則場"
"景中每個單位會對應螢幕上的 2×2 像素。這在非遊戲應用中是提供縮放選項的好方式。"

msgid ""
"If **Stretch Mode** is set to **canvas_items**, 2D elements will be scaled "
"relative to the base window size, then multiplied by the **Scale** setting. "
"This can be exposed to players to allow them to adjust the automatically "
"determined scale to their liking, for better accessibility."
msgstr ""
"若 **Stretch Mode** 設為 **canvas_items**，2D 元素會依基礎視窗大小縮放，然後"
"再乘上 **Scale** 設定。這個參數也可以讓玩家自由調整，以符合不同需求。"

msgid ""
"If **Stretch Mode** is set to **viewport**, the viewport's resolution is "
"divided by **Scale**. This makes pixels look larger and reduces rendering "
"resolution (with a given window size), which can improve performance."
msgstr ""
"若 **Stretch Mode** 設為 **viewport**，則視口解析度會除以 **Scale**。這會讓像"
"素看起來更大，並降低算繪解析度（在相同視窗大小下），可提升效能。"

msgid ""
"To configure the stretch scale at runtime from a script, use the "
"``get_tree().root.content_scale_factor`` property "
"(see :ref:`Window.content_scale_factor "
"<class_Window_property_content_scale_factor>`)."
msgstr ""
"若要於執行期間以腳本設定縮放比例，請使用 "
"``get_tree().root.content_scale_factor`` 屬性（參"
"考 :ref:`Window.content_scale_factor "
"<class_Window_property_content_scale_factor>`）。"

msgid "Stretch Scale Mode"
msgstr "縮放模式"

msgid ""
"Since Godot 4.2, the **Stretch Scale Mode** setting allows you to constrain "
"the automatically determined scale factor (as well as the manually specified "
"**Stretch Scale** setting) to integer values. By default, this setting is "
"set to ``fractional``, which allows any scale factor to be applied "
"(including fractional values such as ``2.5``). When set to ``integer``, the "
"value is rounded down to the nearest integer. For example, instead of using "
"a scale factor of ``2.5``, it would be rounded down to ``2.0``. This is "
"useful to prevent distortion when displaying pixel art."
msgstr ""
"從 Godot 4.2 開始，**Stretch Scale Mode**（縮放模式）可以把自動判斷的縮放因子"
"（以及手動指定的 **Stretch Scale** 設定）限制為整數。預設值為 "
"``fractional``，代表可以套用任何縮放倍數（包含像 ``2.5`` 這種小數）。若設為 "
"``integer``，則會自動向下取整數。例如原本縮放因子是 ``2.5``，會被取為 "
"``2.0``。這對顯示像素美術時避免失真非常有幫助。"

msgid ""
"Compare this pixel art which is displayed with the ``viewport`` stretch "
"mode, with the stretch scale mode set to ``fractional``:"
msgstr ""
"請比較下列以 ``viewport`` 拉伸模式搭配 ``fractional`` 縮放模式顯示的像素美"
"術："

msgid "Fractional scaling example (incorrect pixel art appearance)"
msgstr "小數縮放範例（像素美術顯示異常）"

msgid ""
"Checkerboard doesn't look \"even\". Line widths in the logo and text varies "
"wildly."
msgstr "棋盤格顯示不均勻，Logo 與文字線條寬度變化很大。"

msgid ""
"This pixel art is also displayed with the ``viewport`` stretch mode, but the "
"stretch scale mode is set to ``integer`` this time:"
msgstr ""
"同一張像素美術改用 ``viewport`` 拉伸模式且縮放模式設為 ``integer`` 時："

msgid "Integer scaling example (correct pixel art appearance)"
msgstr "整數縮放範例（像素美術正確顯示）"

msgid "Checkerboard looks perfectly even. Line widths are consistent."
msgstr "棋盤格顯示均勻，線條寬度一致。"

msgid ""
"For example, if your viewport base size is 640×360 and the window size is "
"1366×768:"
msgstr "舉例來說，若你的視口基礎尺寸為 640×360，視窗尺寸為 1366×768："

msgid ""
"When using ``fractional``, the viewport is displayed at a resolution of "
"1366×768 (scale factor is roughly 2.133×). The entire window space is used. "
"Each pixel in the viewport corresponds to 2.133×2.133 pixels in the "
"displayed area. However, since displays can only display \"whole\" pixels, "
"this will lead to uneven pixel scaling which results in incorrect appearance "
"of pixel art."
msgstr ""
"使用 ``fractional`` 時，視口會以 1366×768 解析度顯示（縮放約為 2.133×），整個"
"視窗空間都會被利用。每個視口像素對應約 2.133×2.133 螢幕像素。但由於螢幕僅能顯"
"示「整數」像素，這會導致縮放不均勻，進而讓像素美術顯示失真。"

msgid ""
"When using ``integer``, the viewport is displayed at a resolution of "
"1280×720 (scale factor is 2×). The remaining space is filled with black bars "
"on all four sides, so that each pixel in the viewport corresponds to 2×2 "
"pixels in the displayed area."
msgstr ""
"使用 ``integer`` 時，視口以 1280×720 解析度顯示（縮放為 2×），剩餘區域會自動"
"以黑邊填滿。此時每個視口像素都對應 2×2 螢幕像素。"

msgid ""
"This setting is effective with any stretch mode. However, when using the "
"``disabled`` stretch mode, it will only affect the **Stretch Scale** setting "
"by rounding it *down* to the nearest integer value. This can be used for 3D "
"games that have a pixel art UI, so that the visible area in the 3D viewport "
"doesn't reduce in size (which occurs when using ``canvas_items`` or "
"``viewport`` stretch mode with the ``integer`` scale mode)."
msgstr ""
"此設定適用於任何拉伸模式。不過，若拉伸模式為 ``disabled``，它只會對 "
"**Stretch Scale** 設定進行向下取整數。這對 3D 遊戲但 UI 採像素美術時很有用，"
"能避免 3D 視口可見區域因縮放而縮小（這問題常發生於 ``canvas_items`` 或 "
"``viewport`` 拉伸模式配合 ``integer`` 縮放模式時）。"

msgid ""
"Games should use the **Exclusive Fullscreen** window mode, as opposed to "
"**Fullscreen** which is designed to prevent Windows from automatically "
"treating the window as if it was exclusive fullscreen."
msgstr ""
"遊戲建議使用 **Exclusive Fullscreen**（獨佔全螢幕）視窗模式，而非 "
"**Fullscreen**，因為後者設計目的是避免 Windows 將視窗誤判為獨佔全螢幕。"

msgid ""
"**Fullscreen** is meant to be used by GUI applications that want to use per-"
"pixel transparency without a risk of having it disabled by the OS. It "
"achieves this by leaving a 1-pixel line at the bottom of the screen. By "
"contrast, **Exclusive Fullscreen** uses the actual screen size and allows "
"Windows to reduce jitter and input lag for fullscreen games."
msgstr ""
"**Fullscreen** 主要用於需要每像素透明度且不希望被作業系統關閉這功能的 GUI 應"
"用程式。它會在螢幕底部保留 1 像素的線條。而 **Exclusive Fullscreen** 則會真正"
"以螢幕實際尺寸運作，讓 Windows 能降低全螢幕遊戲的抖動與輸入延遲。"

msgid ""
"When using integer scaling, this is particularly important as the 1-pixel "
"height reduction from the **Fullscreen** mode can cause integer scaling to "
"use a smaller scale factor than expected."
msgstr ""
"對於整數縮放來說，這尤其重要，因為 **Fullscreen** 模式會讓畫面高度少 1 像素，"
"導致整數縮放時縮放倍率較預期還小。"

msgid "Common use case scenarios"
msgstr "常見應用場景"

msgid ""
"The following settings are recommended to support multiple resolutions and "
"aspect ratios well."
msgstr "建議使用下列設定以妥善支援多重解析度與長寬比。"

msgid "Desktop game"
msgstr "桌面遊戲"

msgid "**Non-pixel art:**"
msgstr "**非像素美術：**"

msgid ""
"Set the base window width to ``1920`` and window height to ``1080``. If you "
"have a display smaller than 1920×1080, set **Window Width Override** and "
"**Window Height Override** to lower values to make the window smaller when "
"the project starts."
msgstr ""
"建議將基礎視窗寬度設為 ``1920``、高度設為 ``1080``。如果你的顯示器比 "
"1920×1080 小，可以將 **Window Width Override** 和 **Window Height Override** "
"設為較小的數值，讓專案啟動時視窗自動縮小。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``3840`` and window height to ``2160``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described "
"in :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"若你的目標族群以高階裝置為主，也可以將基礎視窗寬度設為 ``3840``，高度設為 "
"``2160``。這樣你就能提供更高解析度的 2D 素材，畫面會更細緻，但會增加記憶體用"
"量與檔案大小。請注意，這會讓未開啟 mipmap 的貼圖在低解析度裝置上產生顆粒感，"
"建議參考 :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 說"
"明。"

msgid "Set the stretch mode to ``canvas_items``."
msgstr "將拉伸模式（Stretch Mode）設定為 ``canvas_items`` （2D 元素）。"

msgid ""
"Set the stretch aspect to ``expand``. This allows for supporting multiple "
"aspect ratios and makes better use of tall smartphone displays (such as 18:9 "
"or 19:9 aspect ratios)."
msgstr ""
"將拉伸比例設為 ``expand`` （擴充），可同時支援多種長寬比，也能善用高比例的手"
"機螢幕（如 18:9、19:9）。"

msgid ""
"Configure Control nodes' anchors to snap to the correct corners using the "
"**Layout** menu."
msgstr "使用 **佈局** 選單將 Control 節點的錨點設定到正確的角落。"

msgid "**Pixel art:**"
msgstr "**像素美術：**"

msgid ""
"Set the base window size to the viewport size you intend to use. Most pixel "
"art games use viewport sizes between 256×224 and 640×480. 640×360 is a good "
"baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 "
"without any black bars when using integer scaling. Higher viewport sizes "
"will require using higher resolution artwork, unless you intend to show more "
"of the game world at a given time."
msgstr ""
"把基礎視窗大小設為你預期要用的視口尺寸。大多數像素美術遊戲會使用 256×224 到 "
"640×480 之間的視口尺寸。640×360 是不錯的基準，因為用整數縮放時能剛好對應 "
"1280×720、1920×1080、2560×1440、3840×2160，而不會出現黑邊。視口尺寸越大，所需"
"美術解析度越高，除非你想同時顯示更多遊戲世界內容。"

msgid "Set the stretch mode to ``viewport``."
msgstr "將拉伸模式設定為 ``viewport`` （視口）。"

msgid ""
"Set the stretch aspect to ``keep`` to enforce a single aspect ratio (with "
"black bars). As an alternative, you can set the stretch aspect to ``expand`` "
"to support multiple aspect ratios."
msgstr ""
"將拉伸比例設定為 ``keep`` （保持）以強制採用單一長寬比（會有黑邊）；若想同時"
"支援多種長寬比，也可設為 ``expand`` （擴充）。"

msgid ""
"If using the ``expand`` stretch aspect, Configure Control nodes' anchors to "
"snap to the correct corners using the **Layout** menu."
msgstr ""
"若選用 ``expand`` 拉伸比例，請用 **佈局** 選單將 Control 節點的錨點對齊到正確"
"的角落。"

msgid ""
"Set the stretch scale mode to ``integer``. This prevents uneven pixel "
"scaling from occurring, which makes pixel art not display as intended."
msgstr ""
"將縮放模式（Stretch Scale Mode）設為 ``integer`` （整數縮放）。這可避免像素美"
"術出現縮放不均勻導致的顯示問題。"

msgid ""
"The ``viewport`` stretch mode provides low-resolution rendering that is then "
"stretched to the final window size. If you are OK with sprites being able to "
"move or rotate in \"sub-pixel\" positions or wish to have a high resolution "
"3D viewport, you should use the ``canvas_items`` stretch mode instead of the "
"``viewport`` stretch mode."
msgstr ""
"``viewport`` 拉伸模式會先以低解析度算繪，最後再拉伸到目標視窗尺寸。如果你可以"
"接受精靈移動或旋轉到「次像素」位置，或想要高解析度的 3D 視口，也可以改用 "
"``canvas_items`` 拉伸模式。"

msgid "Mobile game in landscape mode"
msgstr "橫向手機遊戲"

msgid ""
"Godot is configured to use landscape mode by default. This means you don't "
"need to change the display orientation project setting."
msgstr "Godot 預設為橫向顯示，因此通常不需調整顯示方向設定。"

msgid "Set the base window width to ``1280`` and window height to ``720``."
msgstr "建議基礎視窗寬度設為 ``1280``，高度設為 ``720``。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1920`` and window height to ``1080``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described "
"in :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"若主要針對高階裝置，也可將基礎視窗寬度設為 ``1920``，高度設為 ``1080``。這樣"
"可提供更高解析度 2D 素材，畫面更清晰，但會增加記憶體用量與檔案大小。許多裝置"
"甚至有更高解析度（如 1440p），但由於手機螢幕較小，1080p 與 1440p 差異其實很難"
"分辨。請注意，未開啟 mipmap 的貼圖在低解析度裝置上會變得有顆粒感，建議參"
"考 :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 4:3 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``1280`` and the "
"base window height to ``960``."
msgstr ""
"若要更好支援平板電腦與摺疊機（這類裝置常見 4:3 長寬比），可考慮使用 4:3 為基"
"礎解析度，並參照本章剩餘建議。例如，可將基礎視窗寬度設為 ``1280``，高度設為 "
"``960``。"

msgid "Mobile game in portrait mode"
msgstr "直向手機遊戲"

msgid "Set the base window width to ``720`` and window height to ``1280``."
msgstr "建議基礎視窗寬度設為 ``720``，高度設為 ``1280``。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1080`` and window height to ``1920``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described "
"in :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"若主要針對高階裝置，可將基礎視窗寬度設為 ``1080``，高度設為 ``1920``。這樣可"
"提供更高解析度 2D 素材，畫面更清晰，但會增加記憶體用量與檔案大小。許多裝置甚"
"至有更高解析度（如 1440p），但由於手機螢幕較小，1080p 與 1440p 差異其實很難分"
"辨。請注意，未開啟 mipmap 的貼圖在低解析度裝置上會變得有顆粒感，建議參"
"考 :ref:`doc_multiple_resolutions_reducing_aliasing_on_downsampling`。"

msgid "Set **Display > Window > Handheld > Orientation** to ``portrait``."
msgstr ""
"將 **Display > Window > Handheld > Orientation** 設定為 ``portrait`` （直"
"向）。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 3:4 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``960`` and the "
"base window height to ``1280``."
msgstr ""
"若要更好支援平板電腦與摺疊機（這類裝置常見 4:3 長寬比），可考慮使用 3:4 為基"
"礎解析度，並參照本章剩餘建議。例如，可將基礎視窗寬度設為 ``960``，高度設為 "
"``1280``。"

msgid "Non-game application"
msgstr "非遊戲應用"

msgid ""
"Set the base window width and height to the smallest window size that you "
"intend to target. This is not required, but this ensures that you design "
"your UI with small window sizes in mind."
msgstr ""
"將基礎視窗寬高設為你想支援的最小視窗尺寸。這不是強制規定，但可確保你設計 UI "
"時會考慮小型視窗。"

msgid "Keep the stretch mode to its default value, ``disabled``."
msgstr "保持拉伸模式為預設值 ``disabled`` （停用）。"

msgid ""
"Keep the stretch aspect to its default value, ``ignore`` (its value won't be "
"used since the stretch mode is ``disabled``)."
msgstr ""
"拉伸比例保持預設 ``ignore``（忽略）（因拉伸模式為 ``disabled``，此設定不會生"
"效）。"

msgid ""
"You can define a minimum window size by calling "
"``get_window().set_min_size()`` in a script's ``_ready()`` function. This "
"prevents the user from resizing the application below a certain size, which "
"could break the UI layout."
msgstr ""
"你可以在腳本的 ``_ready()`` 函式中呼叫 ``get_window().set_min_size()`` 來設定"
"視窗最小尺寸。這樣使用者就無法將應用程式視窗縮得過小，避免破壞 UI 版面。"

msgid ""
"Godot doesn't support manually overriding the 2D scale factor yet, so it is "
"not possible to have hiDPI support in non-game applications. Due to this, it "
"is recommended to leave **Allow Hidpi** disabled in non-game applications to "
"allow for the OS to use its low-DPI fallback."
msgstr ""
"Godot 目前尚未支援手動設定 2D 縮放比例，因此無法在非遊戲應用中支援 hiDPI。建"
"議在非遊戲應用中關閉 **Allow Hidpi**，讓作業系統自動退回低 DPI 模式。"

msgid "hiDPI support"
msgstr "hiDPI 支援"

msgid ""
"By default, Godot projects are considered DPI-aware by the operating system. "
"This is controlled by the **Display > Window > Dpi > Allow Hidpi** project "
"setting, which should be left enabled whenever possible. Disabling DPI "
"awareness can break fullscreen behavior on Windows."
msgstr ""
"預設情況下，Godot 專案會被作業系統視為具 DPI 感知能力。這由 **Display > "
"Window > Dpi > Allow Hidpi** 專案設定控制，建議在可能的情況下保持啟用。若關"
"閉 DPI 感知，可能會導致 Windows 上的全螢幕行為異常。"

msgid ""
"Since Godot projects are DPI-aware, they may appear at a very small window "
"size when launching on an hiDPI display (proportionally to the screen "
"resolution). For a game, the most common way to work around this issue is to "
"make them fullscreen by default. Alternatively, you could set the window "
"size in an :ref:`autoload <doc_singletons_autoload>`'s ``_ready()`` function "
"according to the screen size."
msgstr ""
"由於 Godot 專案具備 DPI 感知能力，在 hiDPI 顯示器上啟動時，視窗可能會非常小"
"（比例取決於螢幕解析度）。對於遊戲來說，最常見的解法是預設全螢幕。你也可以"
"在 :ref:`autoload <doc_singletons_autoload>` 的 ``_ready()`` 函式中根據螢幕尺"
"寸調整視窗大小。"

msgid "To ensure 2D elements don't appear too small on hiDPI displays:"
msgstr "若要避免 hiDPI 顯示器上 2D 元素太小："

msgid ""
"For games, use the ``canvas_items`` or ``viewport`` stretch modes so that 2D "
"elements are automatically resized according to the current window size."
msgstr ""
"對於遊戲，請使用 ``canvas_items`` 或 ``viewport`` 拉伸模式，讓 2D 元素自動根"
"據目前視窗大小縮放。"

msgid ""
"For non-game applications, use the ``disabled`` stretch mode and set the "
"stretch scale to a value corresponding to the display scale factor in "
"an :ref:`autoload <doc_singletons_autoload>`'s ``_ready()`` function. The "
"display scale factor is set in the operating system's settings and can be "
"queried "
"using :ref:`screen_get_scale<class_DisplayServer_method_screen_get_scale>`. "
"This method is currently only implemented on macOS. On other operating "
"systems, you will need to implement a method to guess the display scale "
"factor based on the screen resolution (with a setting to let the user "
"override this if needed). This is the approach currently used by the Godot "
"editor."
msgstr ""
"對於非遊戲應用，請使用 ``disabled`` 拉伸模式，並在 :ref:`autoload "
"<doc_singletons_autoload>` 的 ``_ready()`` 函式中設定縮放比例，使其對應顯示器"
"縮放因子。顯示縮放因子可在作業系統設定中查詢，或透"
"過 :ref:`screen_get_scale<class_DisplayServer_method_screen_get_scale>` 方法"
"取得（目前僅 macOS 實作）。其他作業系統需自行實作判斷縮放因子的邏輯，或提供設"
"定讓使用者手動調整。Godot 編輯器目前即採用此策略。"

msgid ""
"The **Allow Hidpi** setting is only effective on Windows and macOS. It's "
"ignored on all other platforms."
msgstr "**Allow Hidpi** 設定僅於 Windows 與 macOS 有效，其他平台會忽略此設定。"

msgid ""
"The Godot editor itself is always marked as DPI-aware. Running the project "
"from the editor will only be DPI-aware if **Allow Hidpi** is enabled in the "
"Project Settings."
msgstr ""
"Godot 編輯器本身一律標記為具備 DPI 感知能力。從編輯器中執行專案時，只有啟用 "
"**Allow Hidpi** 時才會具備 DPI 感知。"

msgid "Reducing aliasing on downsampling"
msgstr "降低縮小取樣時的鋸齒"

msgid ""
"If the game has a very high base resolution (e.g. 3840×2160), aliasing might "
"appear when downsampling to something considerably lower like 1280×720."
msgstr ""
"若遊戲採用非常高的基礎解析度（如 3840×2160），將畫面縮小到較低解析度（如 "
"1280×720）時，可能會產生鋸齒。"

msgid ""
"To resolve this, you can :ref:`enable mipmaps "
"<doc_importing_images_mipmaps>` on all your 2D textures. However, enabling "
"mipmaps will increase memory usage which can be an issue on low-end mobile "
"devices."
msgstr ""
"解決方法是：你可以為所有 2D 紋理 :ref:`啟用 mipmaps "
"<doc_importing_images_mipmaps>`。不過，啟用 mipmaps 會增加記憶體用量，在低階"
"行動裝置上可能成為問題。"

msgid "Handling aspect ratios"
msgstr "處理長寬比"

msgid ""
"Once scaling for different resolutions is accounted for, make sure that your "
"*user interface* also scales for different aspect ratios. This can be done "
"using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers "
"<doc_gui_containers>`."
msgstr ""
"調整好各種解析度的縮放後，也要確保你的 *使用者介面* 能針對不同長寬比做自動縮"
"放。這可以藉由 :ref:`anchors <doc_size_and_anchors>` 及／或 :ref:`containers "
"<doc_gui_containers>` 實現。"

msgid "Field of view scaling"
msgstr "視野縮放"

msgid ""
"The 3D Camera node's **Keep Aspect** property defaults to the **Keep "
"Height** scaling mode (also called *Hor+*). This is usually the best value "
"for desktop games and mobile games in landscape mode, as widescreen displays "
"will automatically use a wider field of view."
msgstr ""
"3D 相機節點的 **Keep Aspect** （保持長寬比）屬性預設為 **Keep Height** （保持"
"高度）縮放模式（又稱 *Hor+* ）。這通常適用於桌面遊戲或橫向手機遊戲，因為寬螢"
"幕會自動採用更寬的視野。"

msgid ""
"However, if your 3D game is intended to be played in portrait mode, it may "
"make more sense to use **Keep Width** instead (also called *Vert-*). This "
"way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use "
"a *taller* field of view, which is more logical here."
msgstr ""
"但若你的 3D 遊戲打算以直向模式進行，建議改用 **Keep Width** （保持寬度）（又"
"稱 *Vert-* ）。這樣長寬比高於 16:9（如 19:9）的手機就會自動採用 *更高* 的視"
"野，這樣才更合理。"

msgid "Scaling 2D and 3D elements differently using Viewports"
msgstr "使用多個 Viewport 區分縮放 2D 與 3D 元素"

msgid ""
"Using multiple Viewport nodes, you can have different scales for various "
"elements. For instance, you can use this to render the 3D world at a low "
"resolution while keeping 2D elements at the native resolution. This can "
"improve performance significantly while keeping the HUD and other 2D "
"elements crisp."
msgstr ""
"你可以利用多個 Viewport 節點，針對不同元素分別使用不同的縮放設定。例如，你可"
"以讓 3D 世界以低解析度算繪，同時讓 2D 元素維持原生解析度。這樣可以大幅提升效"
"能，同時讓 HUD 與其他 2D 介面保持清晰。"

msgid ""
"This is done by using the root Viewport node only for 2D elements, then "
"creating a Viewport node to display the 3D world and displaying it using a "
"SubViewportContainer or TextureRect node. There will effectively be two "
"viewports in the final project. One upside of using TextureRect over "
"SubViewportContainer is that it allows enable linear filtering. This makes "
"scaled 3D viewports look better in many cases."
msgstr ""
"做法是：把根 Viewport 節點僅用於 2D 元素，再建立一個 Viewport 節點來顯示 3D "
"世界，並用 SubViewportContainer 或 TextureRect 節點呈現。最終專案中就有兩個視"
"口。若用 TextureRect 而非 SubViewportContainer，可以啟用線性濾鏡，讓縮放後的 "
"3D 畫面更平滑。"

msgid ""
"See the `3D viewport scaling demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ for examples."
msgstr ""
"示範專案請參考 `3D viewport scaling demo <https://github.com/godotengine/"
"godot-demo-projects/tree/master/viewport/3d_scaling>`__。"
