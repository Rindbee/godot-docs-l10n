#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "使用視口"

msgid "Introduction"
msgstr "前言"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"可以將 :ref:`Viewport <class_Viewport>` 想像成一個投影遊戲內容的螢幕。為了能"
"看到遊戲畫面，我們需要有一個用來繪製的表面，而這個表面就是根視口（Root "
"Viewport）。"

msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`子視口 <class_SubViewport>` 是一種可以加入場景的視口，讓你能有多個可用"
"來繪製的表面。當我們繪製到子視口時，這個視口就被稱為算繪目標。你可以透過取得"
"其對應的 :ref:`紋理 <class_Viewport_method_get_texture>` 來存取算繪目標的內"
"容。透過將子視口作為算繪目標，可以同時算繪多個場景，或是將畫面輸出"
"到 :ref:`ViewportTexture <class_ViewportTexture>`，並將其套用到場景內的物件"
"上，例如動態天空盒等情境。"

msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ":ref:`子視口 <class_SubViewport>` 有多種用途，例如："

msgid "Rendering 3D objects within a 2D game"
msgstr "在 2D 遊戲中算繪 3D 物件"

msgid "Rendering 2D elements in a 3D game"
msgstr "在 3D 遊戲中算繪 2D 元素"

msgid "Rendering dynamic textures"
msgstr "算繪動態紋理"

msgid "Generating procedural textures at runtime"
msgstr "於執行時動態產生程式化紋理"

msgid "Rendering multiple cameras in the same scene"
msgstr "在同一場景中算繪多個相機畫面"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"這些用法的共通點在於，你可以像在另一個螢幕上一樣，將物件繪製到某個紋理上，接"
"著可以自由決定如何使用這個產生出來的紋理。"

msgid ""
"Another kind of Viewports in Godot are :ref:`Windows <class_Window>`. They "
"allow their content to be projected onto a window. While the Root Viewport "
"is a Window, they are less flexible. If you want to use the texture of a "
"Viewport, you'll be working with :ref:`SubViewports <class_SubViewport>` "
"most of the time."
msgstr ""
"Godot 另一種視口是 :ref:`視窗 <class_Window>`。它們可以將內容投影到一個視窗"
"上。雖然根視口本身就是一個視窗，但它的彈性有限。如果你想要使用某個視口的紋"
"理，多數情況下會使用 :ref:`子視口 <class_SubViewport>`。"

msgid "Input"
msgstr "輸入"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewport <class_Viewport>` 也負責將適當調整和縮放過的輸入事件傳遞給其子"
"節點。預設情況下，:ref:`子視口 <class_SubViewport>` 不會自動接收輸入，除非它"
"們從其直接的 :ref:`SubViewportContainer <class_SubViewportContainer>` 父節點"
"接收到輸入。在這種情況下，可以透過 :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` 屬性來停用輸入。"

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"更多關於 Godot 如何處理輸入事件的資訊，請參閱 :ref:`輸入事件教學 "
"<doc_inputevent>`。"

msgid "Listener"
msgstr "監聽器"

msgid ""
"Godot supports 3D sound (in both 2D and 3D nodes). More on this can be found "
"in the :ref:`Audio Streams Tutorial <doc_audio_streams>`. For this type of "
"sound to be audible, the :ref:`Viewport <class_Viewport>` needs to be "
"enabled as a listener (for 2D or 3D). If you are using a :ref:`SubViewport "
"<class_SubViewport>` to display your :ref:`World3D <class_World3D>` "
"or :ref:`World2D <class_World2D>`, don't forget to enable this!"
msgstr ""
"Godot 支援 3D 音效（無論是在 2D 或 3D 節點中）。詳細內容請參閱 :ref:`音訊串流"
"教學 <doc_audio_streams>`。若要讓這類型的音效能夠被聽見，必須"
"將 :ref:`Viewport <class_Viewport>` 啟用為監聽器（2D 或 3D 皆可）。如果你使"
"用 :ref:`子視口 <class_SubViewport>` 來顯示你的 :ref:`World3D "
"<class_World3D>` 或 :ref:`World2D <class_World2D>`，請務必記得啟用這個功能！"

msgid "Cameras (2D & 3D)"
msgstr "相機（2D 與 3D）"

msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest "
"parent :ref:`Viewport <class_Viewport>` (going towards the root). For "
"example, in the following hierarchy:"
msgstr ""
"當你在場景中使用 :ref:`Camera3D <class_Camera3D>` 或 :ref:`Camera2D "
"<class_Camera2D>` 時，該相機畫面會顯示在自下而上最近的父 :ref:`Viewport "
"<class_Viewport>` 上。例如，以下層級結構："

msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"``CameraA`` 會顯示在根節點的 :ref:`Viewport <class_Viewport>` 上，並繪製 "
"``MeshA``。``CameraB`` 則會被 :ref:`子視口 <class_SubViewport>` 及其下的 "
"``MeshB`` 捕獲。即使 ``MeshB`` 在場景樹中，依然不會被繪製到根視口。反之，"
"``MeshA`` 也不會出現在子視口，因為子視口只會抓取層級結構中自己底下的節點。"

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has "
"the :ref:`current <class_Camera3D_property_current>` property set, or make "
"it the current camera by calling:"
msgstr ""
"每個 :ref:`Viewport <class_Viewport>` 僅能有一個啟用中的相機。如果有多個相"
"機，請確保目標相機已將 :ref:`current <class_Camera3D_property_current>` 屬性"
"設為啟用，或用以下方式設為目前相機："

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's "
"<class_VisualInstance3D>` :ref:`layer "
"<class_VisualInstance3D_property_layers>` property to restrict which objects "
"are rendered."
msgstr ""
"預設情況下，所有相機會算繪其所屬世界中的所有物件。在 3D 場景下，相機可以透"
"過 :ref:`cull_mask <class_Camera3D_property_cull_mask>` 屬性搭"
"配 :ref:`VisualInstance3D <class_VisualInstance3D>` 的 :ref:`layer "
"<class_VisualInstance3D_property_layers>` 屬性，來限制哪些物件需要被算繪。"

msgid "Scale & stretching"
msgstr "縮放與拉伸"

msgid ""
":ref:`SubViewports <class_SubViewport>` have "
"a :ref:`size<class_SubViewport_property_size>` property, which represents "
"the size of the SubViewport in pixels. For SubViewports which are children "
"of :ref:`SubViewportContainers <class_SubViewportContainer>`, these values "
"are overridden, but for all others, this sets their resolution."
msgstr ""
":ref:`子視口 <class_SubViewport>` 擁有 :ref:`size "
"<class_SubViewport_property_size>` 屬性，代表該子視口的像素尺寸。若該子視口"
"是 :ref:`SubViewportContainer <class_SubViewportContainer>` 子節點，這個值會"
"被覆蓋；否則則會直接決定其解析度。"

msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"你也可以透過呼叫以下方法，將 :ref:`子視口 <class_SubViewport>` 的 2D 內容縮"
"放，讓解析度與其尺寸設定不同："

msgid ""
"For information on scaling and stretching with the Root Viewport visit "
"the :ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"關於根視口（Root Viewport）縮放與拉伸的相關資訊，請參考 :ref:`多解析度教學 "
"<doc_multiple_resolutions>`"

msgid "Worlds"
msgstr "世界"

msgid ""
"For 3D, a :ref:`Viewport <class_Viewport>` will contain a :ref:`World3D "
"<class_World3D>`. This is basically the universe that links physics and "
"rendering together. Node3D-based nodes will register using the World3D of "
"the closest Viewport. By default, newly created Viewports do not contain a "
"World3D but use the same as their parent Viewport. The Root Viewport always "
"contains a World3D, which is the one objects are rendered to by default."
msgstr ""
"在 3D 場景中，每個 :ref:`Viewport <class_Viewport>` 會擁有一個 :ref:`World3D "
"<class_World3D>`。這個 World3D 就像一個結合物理與算繪的宇宙。所有基於 Node3D "
"的節點都會註冊到最近的父視口所屬的 World3D。預設情況下，新增的視口本身不包含 "
"World3D，而是沿用其父視口的 World3D。根視口（Root Viewport）則一定有自己的 "
"World3D，也是預設物件算繪到的地方。"

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""
"你可以透過設定 :ref:`Viewport <class_Viewport>` 的 :ref:`World 3D "
"<class_Viewport_property_world_3d>` 屬性，指定一個專屬的 :ref:`World3D "
"<class_World3D>`。這將使該 :ref:`Viewport <class_Viewport>` 下所有子節點都與"
"父視口的 World3D 隔離，彼此不互動。這在有些情境下非常實用，例如你想在遊戲畫面"
"上額外顯示一個獨立的 3D 角色（類似星海爭霸的頭像）。"

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create "
"a :ref:`World3D <class_World3D>`, Viewport has the option to use "
"its :ref:`Own World3D <class_Viewport_property_own_world_3d>`. This is "
"useful when you want to instance 3D characters or objects in :ref:`World2D "
"<class_World2D>`."
msgstr ""
"若你只想讓 :ref:`Viewport <class_Viewport>` 顯示單一物件，又不想手動建"
"立 :ref:`World3D <class_World3D>` ，可以啟用該視口的 :ref:`Own World3D "
"<class_Viewport_property_own_world_3d>` 屬性。這在你想在 :ref:`World2D "
"<class_World2D>` 場景中動態生成 3D 角色或物件時會很有用。"

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its "
"own :ref:`World2D <class_World2D>`. This suffices in most cases, but in case "
"sharing them may be desired, it is possible to do so by "
"setting :ref:`world_2d<class_Viewport_property_world_2d>` on the Viewport "
"through code."
msgstr ""
"在 2D 中，每個 :ref:`Viewport <class_Viewport>` 都會有自己的 :ref:`World2D "
"<class_World2D>`。大部分情況下這樣就足夠了，如果你有共用需求，可以透過程式碼"
"手動設定該視口的 :ref:`world_2d <class_Viewport_property_world_2d>` 屬性來達"
"成。"

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"有關這種用法的範例，請參考範例專案： [`3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_] 及 [`2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"2d_in_3d>`_]。"

msgid "Capture"
msgstr "擷取"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"你可以取得 :ref:`Viewport <class_Viewport>` 畫面的擷取結果。對於根視口來說，"
"這就等同於截圖。方法如下："

msgid ""
"But if you use this in ``_ready()`` or from the first frame of "
"the :ref:`Viewport's <class_Viewport>` initialization, you will get an empty "
"texture because there is nothing to get as texture. You can deal with it "
"using (for example):"
msgstr ""
"但如果你在 ``_ready()`` 或 :ref:`Viewport <class_Viewport>` 初始化的第一幀呼"
"叫這段程式碼，會因為畫面還沒渲染好而取得空白紋理。你可以這樣處理（例如）："

msgid "Viewport Container"
msgstr "視口容器"

msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of "
"a :ref:`SubViewportContainer <class_SubViewportContainer>`, it will become "
"active and display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`子視口 <class_SubViewport>` 是 :ref:`SubViewportContainer "
"<class_SubViewportContainer>` 的子節點，該子視口就會自動啟用並顯示其內容。整"
"體結構如下："

msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
"如果父節點 :ref:`SubViewportContainer <class_SubViewportContainer>` "
"的 :ref:`Stretch <class_SubViewportContainer_property_stretch>` 屬性設為 "
"``true``，那麼 :ref:`子視口 <class_SubViewport>` 就會完全覆蓋其父容器的範圍。"

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
":ref:`SubViewportContainer <class_SubViewportContainer>` 的大小不能小於其底"
"下 :ref:`SubViewport <class_SubViewport>` 的尺寸。"

msgid "Rendering"
msgstr "算繪"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"由於 :ref:`Viewport <class_Viewport>` 是另一個算繪表面的入口，因此它提供了一"
"些可與專案設定不同的算繪屬性。你可以為每個視口選擇不同層級的 :ref:`MSAA "
"<class_Viewport_property_msaa_2d>`。預設為「停用」。"

msgid ""
"If you know that the :ref:`Viewport <class_Viewport>` is only going to be "
"used for 2D, you can :ref:`Disable 3D<class_Viewport_property_disable_3d>`. "
"Godot will then restrict how the Viewport is drawn. Disabling 3D is slightly "
"faster and uses less memory compared to enabled 3D. It's a good idea to "
"disable 3D if your viewport doesn't render anything in 3D."
msgstr ""
"如果你確定這個 :ref:`Viewport <class_Viewport>` 只會用於 2D，可以 :ref:`停用 "
"3D <class_Viewport_property_disable_3d>`。這樣 Godot 會限制該視口的繪製方式。"
"相較於啟用 3D，停用 3D 會稍微快一些且佔用更少記憶體。如果你的視口不需要 3D 算"
"繪，建議關閉這個選項。"

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"若你需要在視口中算繪 3D 陰影，請將該視口"
"的 :ref:`positional_shadow_atlas_size "
"<class_Viewport_property_positional_shadow_atlas_size>` 屬性設為大於 ``0`` 的"
"值，否則陰影將不會被算繪。預設情況下，專案設定在桌面平台為 ``4096``，行動裝置"
"則為 ``2048``。"

msgid ""
"Godot also provides a way of customizing how everything is drawn "
"inside :ref:`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot 也提供 :ref:`Debug Draw <class_Viewport_property_debug_draw>` 功能，可"
"自訂各種 :ref:`Viewport <class_Viewport>` 內部的繪製方式。Debug Draw 預設為"
"「停用」。你可從多種模式中選擇，例如 ``Unshaded`` （無陰影）、 ``Overdraw`` "
"（疊加）、 ``Wireframe`` （線框）等。完整列表請參閱 :ref:`Viewport 屬性說明 "
"<class_Viewport_property_debug_draw>` 。"

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr "**Debug Draw = Disabled** （預設）：以一般方式顯示場景內容。"

msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"**Debug Draw = Unshaded**：無陰影會讓場景不受光照影響，所有物件都以其原始色"
"（Albedo）呈現為純色。"

msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr ""
"**Debug Draw = Overdraw**：疊加模式會將網格以半透明加法方式繪製，可讓你觀察網"
"格重疊情形。"

msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr "**Debug Draw = Wireframe**：線框模式僅以網格的三角形邊線來描繪場景。"

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""
"目前在使用「相容性」算繪模式時，Debug Draw 各模式**無法使用**，畫面會顯示為一"
"般模式。"

msgid "Render target"
msgstr "算繪目標"

msgid ""
"When rendering to a :ref:`SubViewport <class_SubViewport>`, whatever is "
"inside will not be visible in the scene editor. To display the contents, you "
"have to draw the SubViewport's :ref:`ViewportTexture "
"<class_ViewportTexture>` somewhere. This can be requested via code using "
"(for example):"
msgstr ""
"當算繪至 :ref:`子視口 <class_SubViewport>` 時，其內容在場景編輯器中將不會顯"
"示。若要顯示內容，必須將該子視口的 :ref:`ViewportTexture "
"<class_ViewportTexture>` 繪製到某個地方。例如可以用程式碼這樣取得："

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者也可以在編輯器內指定為 \"New ViewportTexture\""

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然後選擇你想要使用的 :ref:`Viewport <class_Viewport>`。"

msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"每一幀，:ref:`Viewport <class_Viewport>` 的紋理會用預設清除色（或"
"若 :ref:`Transparent BG <class_Viewport_property_transparent_bg>` 設為 "
"``true`` 時則用透明色）來清除。你可以將 :ref:`Clear Mode "
"<class_SubViewport_property_render_target_clear_mode>` 設為 ``Never`` 或 "
"``Next Frame``，來改變這個行為。Never 表示永遠不會清除，Next Frame 則會在下一"
"幀清除並自動切回 Never。"

msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"預設情況下，當 :ref:`SubViewport <class_SubViewport>` "
"的 :ref:`ViewportTexture <class_ViewportTexture>` 在某幀被繪製時，才會重新算"
"繪；若不可見則不算繪。你可以將 :ref:`更新模式 "
"<class_SubViewport_property_render_target_update_mode>` 設定為 ``Never`` （永"
"不）、 ``Once`` （一次）、 ``Always`` （總是）或 ``When Parent Visible`` （當"
"父節點可見時）來調整這個行為。Never 及 Always 會分別永不或總是重新算繪；Once "
"則在下一幀重新算繪後自動切回 Never。這種彈性可讓你只算繪一次影像、重複使用紋"
"理，而不用每幀都消耗算繪資源。"

msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"建議參考 Viewport 相關範例，這些專案可以在範例集的 viewport 資料夾找到，或直"
"接前往 https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport。"
