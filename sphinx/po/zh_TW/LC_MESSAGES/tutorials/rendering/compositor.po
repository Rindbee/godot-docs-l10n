#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The Compositor"
msgstr "合成器（Compositor）"

msgid ""
"The compositor is a new feature in Godot 4 that allows control over the "
"rendering pipeline when rendering the contents of a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"合成器是 Godot 4 的新功能，可讓你在渲染 :ref:`檢視區 <class_Viewport>` 內容"
"時，控制渲染管線。"

msgid ""
"It can be configured on a :ref:`WorldEnvironment <class_WorldEnvironment>` "
"node where it applies to all Viewports, or it can be configured on "
"a :ref:`Camera3D <class_Camera3D>` and apply only to the Viewport using that "
"camera."
msgstr ""
"你可以在 :ref:`世界環境 <class_WorldEnvironment>` 節點上設定合成器，使其套用"
"於所有檢視區，或是在 :ref:`3D 攝影機 <class_Camera3D>` 上設定，僅套用於該攝影"
"機所屬的檢視區。"

msgid ""
"The :ref:`Compositor <class_Compositor>` resource is used to configure the "
"compositor. To get started, create a new compositor on the appropriate node:"
msgstr ""
":ref:`合成器 <class_Compositor>` 資源用於設定合成器。首先，請在對應的節點上建"
"立新的合成器："

msgid ""
"The compositor is currently a feature that is only supported by the Mobile "
"and Forward+ renderers."
msgstr "目前合成器僅支援 Mobile（行動裝置）與 Forward+（前向加強）渲染器。"

msgid "Compositor effects"
msgstr "合成器特效"

msgid ""
"Compositor effects allow you to insert additional logic into the rendering "
"pipeline at various stages. This is an advanced feature that requires a high "
"level of understanding of the rendering pipeline to use to its best "
"advantage."
msgstr ""
"合成器特效讓你能在渲染管線的不同階段插入自訂邏輯。這是一項進階功能，使用時需"
"要對渲染管線有高度的理解，才能發揮其最大效益。"

msgid ""
"As the core logic of the compositor effect is called from the rendering "
"pipeline it is important to note that this logic will thus run within the "
"thread on which rendering takes place. Care needs to be taken to ensure we "
"don't run into threading issues."
msgstr ""
"由於合成器特效的核心邏輯會由渲染管線呼叫，因此會在執行渲染的執行緒中運作。請"
"務必小心，避免產生執行緒相關問題。"

msgid ""
"To illustrate how to use compositor effects we'll create a simple post "
"processing effect that allows you to write your own shader code and apply "
"this full screen through a compute shader. You can find the finished demo "
"project `here <https://github.com/godotengine/godot-demo-projects/tree/"
"master/compute/post_shader>`_."
msgstr ""
"為了說明如何使用合成器特效，我們將建立一個簡單的後處理特效，讓你可以撰寫自己"
"的著色器程式，並透過運算著色器套用到全螢幕。你可以在這裡找到完成的展示專案：`"
"這裡 <https://github.com/godotengine/godot-demo-projects/tree/master/compute/"
"post_shader>`_。"

msgid ""
"We start by creating a new script called ``post_process_shader.gd``. We'll "
"make this a tool script so we can see the compositor effect work in the "
"editor. We need to extend our node from :ref:`CompositorEffect "
"<class_CompositorEffect>`. We must also give our script a class name."
msgstr ""
"首先，建立一個名為 ``post_process_shader.gd`` 的新腳本。將其設為 tool 腳本，"
"這樣就可以在編輯器中即時看到合成器特效的效果。這個腳本需要繼承"
"自 :ref:`CompositorEffect <class_CompositorEffect>`，並為其指定一個類別名稱。"

msgid "post_process_shader.gd"
msgstr "post_process_shader.gd"

msgid ""
"Next we're going to define a constant for our shader template code. This is "
"the boilerplate code that makes our compute shader work."
msgstr ""
"接著，我們要定義一個常數來存放著色器範本程式碼。這段程式碼是讓我們的運算著色"
"器能夠運作的基礎。"

msgid ""
"For more information on how compute shaders work, please check :ref:`Using "
"compute shaders <doc_compute_shaders>`."
msgstr ""
"如需更多有關運算著色器運作方式的資訊，請參考 :ref:`使用運算著色器 "
"<doc_compute_shaders>`。"

msgid ""
"The important bit here is that for every pixel on our screen, our ``main`` "
"function is executed and inside of this we load the current color value of "
"our pixel, execute our user code, and write our modified color back to our "
"color image."
msgstr ""
"這裡最重要的是，螢幕上的每一個像素都會執行一次 ``main`` 函式，過程中會讀取該"
"像素目前的顏色值、執行自訂程式碼，並將修改後的顏色寫回影像。"

msgid "``#COMPUTE_CODE`` gets replaced by our user code."
msgstr "``#COMPUTE_CODE`` 會被替換為我們撰寫的自訂程式碼。"

msgid ""
"In order to set our user code, we need an export variable. We'll also define "
"a few script variables we'll be using:"
msgstr ""
"為了設定自訂程式碼，我們需要一個 export 變數。同時，也會定義一些腳本變數以供"
"使用："

msgid ""
"Note the use of a :ref:`Mutex <class_Mutex>` in our code. Most of our "
"implementation gets called from the rendering engine and thus runs within "
"our rendering thread."
msgstr ""
"請注意，我們在程式中使用了 :ref:`Mutex <class_Mutex>`。大部分的實作都會由渲染"
"引擎呼叫，因此會在渲染執行緒中執行。"

msgid ""
"We need to ensure that we set our new shader code, and mark our shader code "
"as dirty, without our render thread accessing this data at the same time."
msgstr ""
"我們必須確保在設定新的著色器程式碼並標記為已變更時，渲染執行緒不會同時存取這"
"些資料。"

msgid "Next we initialize our effect."
msgstr "接著初始化我們的特效。"

msgid ""
"The main thing here is setting our ``effect_callback_type`` which tells the "
"rendering engine at what stage of the render pipeline to call our code."
msgstr ""
"這裡的重點是設定 ``effect_callback_type``，告訴渲染引擎要在渲染管線的哪個階段"
"呼叫我們的程式碼。"

msgid ""
"Currently we only have access to the stages of the 3D rendering pipeline!"
msgstr "目前僅能存取 3D 渲染管線的各個階段！"

msgid ""
"We also get a reference to our rendering device, which will come in very "
"handy."
msgstr "我們同時也會取得渲染裝置的參考，這在後續會很實用。"

msgid ""
"We also need to clean up after ourselves, for this we react to the "
"``NOTIFICATION_PREDELETE`` notification:"
msgstr ""
"我們還需要進行資源清理，這可以透過監聽 ``NOTIFICATION_PREDELETE`` 通知來完"
"成："

msgid ""
"Note that we do not use our mutex here even though we create our shader "
"inside of our render thread. The methods on our rendering server are thread "
"safe and ``free_rid`` will be postponed cleaning up the shader until after "
"any frames currently being rendered are finished."
msgstr ""
"請注意，雖然我們在渲染執行緒中建立著色器，但這裡並未使用 mutex。渲染伺服器的"
"方法是執行緒安全的，``free_rid`` 會等到目前正在渲染的所有畫面結束後，才會釋放"
"著色器資源。"

msgid ""
"Also note that we are not freeing our pipeline. The rendering device does "
"dependency tracking and as the pipeline is dependent on the shader, it will "
"be automatically freed when the shader is destructed."
msgstr ""
"同時也請注意，這邊沒有手動釋放 pipeline。渲染裝置會自動追蹤相依性，pipeline "
"依賴著色器，因此當著色器被銷毀時 pipeline 也會自動釋放。"

msgid "From this point onwards our code will run on the rendering thread."
msgstr "從這裡開始，我們的程式碼都會在渲染執行緒上執行。"

msgid ""
"Our next step is a helper function that will recompile the shader if the "
"user code was changed."
msgstr "接下來要實作一個輔助函式，當使用者的程式碼更動時，重新編譯著色器。"

msgid ""
"At the top of this method we again use our mutex to protect accessing our "
"user shader code and our is dirty flag. We make a local copy of the user "
"shader code if our user shader code is dirty."
msgstr ""
"在這個方法的一開始，我們會再次使用 mutex 來保護對使用者著色器程式碼及已變更標"
"記的存取。如果使用者著色器程式碼已變更，就複製一份本地副本。"

msgid ""
"If we don't have a new code fragment, we return true if we already have a "
"valid pipeline."
msgstr "如果沒有新的程式碼片段，且已經有有效的 pipeline，就回傳 true。"

msgid ""
"If we do have a new code fragment we embed it in our template code and then "
"compile it."
msgstr "如果有新的程式碼片段，則將其嵌入範本程式碼後進行編譯。"

msgid ""
"The code shown here compiles our new code in runtime. This is great for "
"prototyping as we can immediately see the effect of the changed shader."
msgstr ""
"這裡的程式碼會在執行時即時編譯新的程式碼。這對於原型設計很有幫助，因為可以立"
"刻看到著色器變更的效果。"

msgid ""
"This prevents precompiling and caching this shader which may be an issues on "
"some platforms such as consoles. Note that the demo project comes with an "
"alternative example where a ``glsl`` file contains the entire compute shader "
"and this is used. Godot is able to precompile and cache the shader with this "
"approach."
msgstr ""
"這樣做會導致無法預先編譯和快取著色器，這在某些平台（如遊戲主機）上可能會造成"
"問題。請注意，展示專案中也有另一種做法：將完整運算著色器寫在 ``.glsl`` 檔案"
"中，然後載入。Godot 可以透過這種方式來預先編譯並快取著色器。"

msgid ""
"Finally we need to implement our effect callback, the rendering engine will "
"call this at the right stage of rendering."
msgstr "最後要實作特效的回呼函式，渲染引擎會在正確的渲染階段呼叫它。"

msgid ""
"At the start of this method we check if we have a rendering device, if our "
"callback type is the correct one, and check if we have our shader."
msgstr ""
"在此方法開始時，會檢查是否有渲染裝置、回呼類型是否正確，以及是否已經有著色"
"器。"

msgid ""
"The check for the effect type is only a safety mechanism. We've set this in "
"our ``_init`` function, however it is possible for the user to change this "
"in the UI."
msgstr ""
"檢查特效類型只是安全機制。我們已經在 ``_init`` 函式中設定，但使用者也有可能"
"在 UI 中修改這個設定。"

msgid ""
"Our ``p_render_data`` parameter gives us access to an object that holds data "
"specific to the frame we're currently rendering. We're currently only "
"interested in our render scene buffers, which provide us access to all the "
"internal buffers used by the rendering engine. Note that we cast this "
"to :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>` to expose the "
"full API to this data."
msgstr ""
"``p_render_data`` 參數讓我們可以存取目前渲染畫面所用的資料物件。目前我們只需"
"要用到場景渲染緩衝區，這會提供對渲染引擎所有內部緩衝區的存取權限。請注意，這"
"裡我們會將其轉型為 :ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>` "
"以使用完整 API。"

msgid ""
"Next we obtain our ``internal size`` which is the resolution of our 3D "
"render buffers before they are upscaled (if applicable), upscaling happens "
"after our post processes have run."
msgstr ""
"接下來取得 ``internal size``，也就是 3D 渲染緩衝區在升頻（如果有的話）前的解"
"析度。升頻會在所有後處理效果結束後才執行。"

msgid ""
"From our internal size we calculate our group size, see our local size in "
"our template shader."
msgstr "根據 internal size 計算群組大小，詳見著色器範本程式碼中的 local size。"

msgid ""
"We also populate our push constant so our shader knows our size. Godot does "
"not support structs here **yet** so we use a ``PackedFloat32Array`` to store "
"this data into. Note that we have to pad this array with a 16 byte "
"alignment. In other words, the length of our array needs to be a multiple of "
"4."
msgstr ""
"我們也會設定 push constant，讓著色器知道目前的大小。Godot 目前 **尚未** 支援 "
"struct，因此我們用 ``PackedFloat32Array`` 來存放這些資料。請注意，這個陣列必"
"須以 16 位元組對齊，也就是說長度必須是 4 的倍數。"

msgid ""
"Now we loop through our views, this is in case we're using multiview "
"rendering which is applicable for stereo rendering (XR). In most cases we "
"will only have one view."
msgstr ""
"現在我們要遍歷所有 view，這是為了支援多視圖渲染（例如 XR 立體渲染）。大多數情"
"況下只會有一個 view。"

msgid ""
"There is no performance benefit to use multiview for post processing here, "
"handling the views separately like this will still enable the GPU to use "
"parallelism if beneficial."
msgstr ""
"在這裡使用多視圖對後處理沒有效能上的好處，但分別處理各個 view 的方式，仍能讓 "
"GPU 視需要使用平行運算。"

msgid ""
"Next we obtain the color buffer for this view. This is the buffer into which "
"our 3D scene has been rendered."
msgstr "接下來取得該 view 的顏色緩衝區，也就是 3D 場景渲染結果所儲存的緩衝區。"

msgid ""
"We then prepare a uniform set so we can communicate the color buffer to our "
"shader."
msgstr "然後準備一組 uniform set，用來將顏色緩衝區傳遞給著色器。"

msgid ""
"Note the use of our :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` cache "
"which ensures we can check for our uniform set each frame. As our color "
"buffer can change from frame to frame and our uniform cache will "
"automatically clean up uniform sets when buffers are freed, this is the safe "
"way to ensure we do not leak memory or use an outdated set."
msgstr ""
"請注意，我們使用 :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` 快取，這"
"樣每一幀都可以檢查目前的 uniform set。由於顏色緩衝區每幀都可能不同，uniform "
"快取也會在緩衝區被釋放時自動清理，這樣才能確保不會有記憶體洩漏或用到過期的 "
"set。"

msgid ""
"Finally we build our compute list by binding our pipeline, binding our "
"uniform set, pushing our push constant data, and calling dispatch for our "
"groups."
msgstr ""
"最後，綁定 pipeline 與 uniform set，推送 push constant 資料，並對所有群組呼"
"叫 dispatch，來組建運算清單。"

msgid ""
"With our compositor effect completed, we now need to add it to our "
"compositor."
msgstr "完成合成器特效後，現在要將它加入合成器。"

msgid ""
"On our compositor we expand the compositor effects property and press ``Add "
"Element``."
msgstr "在合成器中展開「合成器特效」屬性，然後按下「新增元素」。"

msgid "Now we can add our compositor effect:"
msgstr "現在就可以新增我們的合成器特效："

msgid ""
"After selecting our ``PostProcessShader`` we need to set our user shader "
"code:"
msgstr "選取 ``PostProcessShader`` 後，請輸入自訂著色器程式碼："

msgid "With that all done, our output is in grayscale."
msgstr "完成以上步驟後，畫面輸出就會變成灰階。"

msgid ""
"For a more advanced example of post effects, check out the `Radial blur "
"based sky rays <https://github.com/BastiaanOlij/RERadialSunRays>`_ example "
"project created by Bastiaan Olij."
msgstr ""
"若想參考更進階的後處理特效範例，可以看看 Bastiaan Olij 製作的 `基於徑向模糊的"
"天空光暈 <https://github.com/BastiaanOlij/RERadialSunRays>`_ 範例專案。"
