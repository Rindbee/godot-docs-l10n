#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Background loading"
msgstr "後臺載入"

msgid ""
"Commonly, games need to load resources asynchronously. When switching the "
"main scene of your game (e.g. going to a new level), you might want to show "
"a loading screen with some indication that progress is being made, or you "
"may want to load additional resources during gameplay."
msgstr ""
"通常，遊戲需要非同步載入資源。當切換遊戲的主場景時（例如，進入新的關卡），您"
"可能想要顯示一個載入畫面，其中包含一些正在進行的指示，或者您可能希望在遊戲過"
"程中載入其他資源。"

msgid ""
"The standard load method (:ref:`ResourceLoader.load "
"<class_ResourceLoader_method_load>` or GDScript's simpler :ref:`load "
"<class_@GDScript_method_load>`) blocks your thread, making your game appear "
"unresponsive while the resource is being loaded."
msgstr ""
"標準的載入方法（:ref:`ResourceLoader.load "
"<class_ResourceLoader_method_load>` 或 GDScript 中較簡單的 :ref:`load "
"<class_@GDScript_method_load>`）會阻塞您的執行緒，導致您的遊戲在載入資源時看"
"起來沒有回應。"

msgid ""
"One way around this is using ``ResourceLoader`` to load resources "
"asynchronously in background threads."
msgstr ""
"其中一種解決方式是使用 ``ResourceLoader`` 在背景執行緒中非同步載入資源。"

msgid "Using ResourceLoader"
msgstr "使用 ResourceLoader"

msgid ""
"Generally, you queue requests to load resources for a path "
"using :ref:`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>`, which will then be "
"loaded in threads in the background."
msgstr ""
"通常，你可以使用 :ref:`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>` 來將指定路徑的資源載入請"
"求排入佇列，這些資源會在背景執行緒中載入。"

msgid ""
"You can check the status with :ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>`. Progress can be "
"obtained by passing an array variable via progress which will return a one "
"element array containing the percentage."
msgstr ""
"你可以透過 :ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>` 來檢查狀態。進度可以"
"透過 progress 參數傳入一個陣列變數，該變數會回傳一個包含百分比的單元素陣列。"

msgid ""
"Finally, you retrieve loaded resources by "
"calling :ref:`ResourceLoader.load_threaded_get "
"<class_ResourceLoader_method_load_threaded_get>`."
msgstr ""
"最後，你可以呼叫 :ref:`ResourceLoader.load_threaded_get "
"<class_ResourceLoader_method_load_threaded_get>` 來取得已載入的資源。"

msgid ""
"Once you call ``load_threaded_get()``, either the resource finished loading "
"in the background and will be returned instantly or the load will block at "
"this point like ``load()`` would. If you want to guarantee this does not "
"block, you either need to ensure there is enough time between requesting the "
"load and retrieving the resource or you need to check the status manually."
msgstr ""
"當你呼叫 ``load_threaded_get()`` 時，若資源已在背景載入完成，將會立即回傳；否"
"則會像 ``load()`` 一樣在這裡阻塞等待載入完成。如果你要保證不會阻塞，請確保從"
"發出載入請求到取用資源之間有足夠時間，或是手動檢查載入狀態。"

msgid "Example"
msgstr "範例"

msgid ""
"This example demonstrates how to load a scene in the background. We will "
"have a button spawn an enemy when pressed. The enemy will be ``Enemy.tscn`` "
"which we will load on ``_ready`` and instantiate when pressed. The path will "
"be ``\"Enemy.tscn\"`` which is located at ``res://Enemy.tscn``."
msgstr ""
"這個範例展示如何在背景載入一個場景。我們會設計一個按鈕，在按下時產生一個敵"
"人。這個敵人會用 ``Enemy.tscn``，我們會在 ``_ready`` 時載入它，並在按下按鈕時"
"實例化。資源路徑為 ``\"Enemy.tscn\"``，實際位置是 ``res://Enemy.tscn``。"

msgid ""
"First, we will start a request to load the resource and connect the button:"
msgstr "首先，我們會啟動資源載入請求並連接按鈕："

msgid ""
"Now ``_on_button_pressed`` will be called when the button is pressed. This "
"method will be used to spawn an enemy."
msgstr ""
"現在，當按鈕被按下時會呼叫 ``_on_button_pressed``。這個方法將用來產生敵人。"
