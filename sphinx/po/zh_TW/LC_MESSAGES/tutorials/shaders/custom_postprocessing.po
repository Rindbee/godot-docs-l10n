#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom post-processing"
msgstr "自訂後期處理"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot provides many post-processing effects out of the box, including Bloom, "
"DOF, and SSAO, which are described "
"in :ref:`doc_environment_and_post_processing`. However, advanced use cases "
"may require custom effects. This article explains how to write your own "
"custom effects."
msgstr ""
"Godot 提供許多內建的後期處理效果，包括泛光（Bloom）、景深（DOF）與螢幕空間環"
"境光遮蔽（SSAO），詳見 :ref:`doc_environment_and_post_processing`。然而，進階"
"應用可能需要自訂效果。本文將說明如何撰寫自訂的後期處理效果。"

msgid ""
"The easiest way to implement a custom post-processing shader is to use "
"Godot's built-in ability to read from the screen texture. If you're not "
"familiar with this, you should read the :ref:`Screen Reading Shaders "
"Tutorial <doc_screen-reading_shaders>` first."
msgstr ""
"實作自訂後期處理著色器最簡單的方法，是利用 Godot 內建的螢幕紋理讀取功能。如果"
"你還不熟悉，建議先閱讀 :ref:`螢幕讀取著色器教學 <doc_screen-"
"reading_shaders>`。"

msgid "Single pass post-processing"
msgstr "單通道後期處理"

msgid "Your scene tree will look something like this:"
msgstr "你的場景樹大致會長這樣："

msgid ""
"Another more efficient method is to use a :ref:`BackBufferCopy "
"<class_BackBufferCopy>` to copy a region of the screen to a buffer and to "
"access it in a shader script through a ``sampler2D`` using "
"``hint_screen_texture``."
msgstr ""
"另一種更有效率的方法，是使用 :ref:`BackBufferCopy <class_BackBufferCopy>` 將"
"螢幕區域複製到緩衝區，然後透過帶有 ``hint_screen_texture`` 的 ``sampler2D`` "
"在著色器腳本中存取。"

msgid ""
"As of the time of writing, Godot does not support rendering to multiple "
"buffers at the same time. Your post-processing shader will not have access "
"to other render passes and buffers not exposed by Godot (such as depth or "
"normal/roughness). You only have access to the rendered frame and buffers "
"exposed by Godot as samplers."
msgstr ""
"截至撰寫本文時，Godot 尚未支援同時渲染到多個緩衝區。你的後期處理著色器無法存"
"取 Godot 未公開的其他渲染通道與緩衝區（如深度或法線／粗糙度）。你僅能存取經 "
"Godot 以取樣器形式公開的已渲染畫面及緩衝區。"

msgid ""
"For this demo, we will use this :ref:`Sprite <class_Sprite2D>` of a sheep."
msgstr "本範例將使用這張小羊的 :ref:`Sprite <class_Sprite2D>`。"

msgid ""
"Assign a new :ref:`Shader <class_Shader>` to the ``ColorRect``'s "
"``ShaderMaterial``. You can access the frame's texture and UV with a "
"``sampler2D`` using ``hint_screen_texture`` and the built-in ``SCREEN_UV`` "
"uniforms."
msgstr ""
"將新的 :ref:`Shader <class_Shader>` 指定給 ``ColorRect`` 的 "
"``ShaderMaterial``。你可以透過帶有 ``hint_screen_texture`` 的 ``sampler2D`` "
"以及內建的 ``SCREEN_UV`` uniform 來存取該影格的紋理與 UV。"

msgid ""
"Copy the following code to your shader. The code below is a hex pixelization "
"shader by `arlez80 <https://bitbucket.org/arlez80/hex-mosaic/src/master/>`_,"
msgstr ""
"將以下程式碼複製到你的著色器。下方範例是來自 `arlez80 <https://bitbucket.org/"
"arlez80/hex-mosaic/src/master/>`_ 的六角像素化著色器，"

msgid "The sheep will look something like this:"
msgstr "小羊會呈現出下圖的效果："

msgid "Multi-pass post-processing"
msgstr "多通道後期處理"

msgid ""
"Some post-processing effects like blurs are resource intensive. You can make "
"them run a lot faster if you break them down in multiple passes. In a "
"multipass material, each pass takes the result from the previous pass as an "
"input and processes it."
msgstr ""
"某些後期處理效果（如模糊）相當消耗資源。如果將這些效果拆成多個階段處理，可以"
"大幅提升效能。在多通道材質中，每一次通道會接收前一階段的結果進行處理。"

msgid ""
"To produce a multi-pass post-processing shader, you stack ``CanvasLayer`` "
"and ``ColorRect`` nodes. In the example above, you use a ``CanvasLayer`` "
"object to render a shader using the frame on the layer below. Apart from the "
"node structure, the steps are the same as with the single-pass post-"
"processing shader."
msgstr ""
"要製作多通道後期處理著色器，可以堆疊多個 ``CanvasLayer`` 與 ``ColorRect`` 節"
"點。在上述範例中，你利用 ``CanvasLayer`` 來以下層的畫面作為著色器輸入。除了節"
"點結構不同外，其餘步驟與單通道後期處理著色器相同。"

msgid ""
"As an example, you could write a full screen Gaussian blur effect by "
"attaching the following pieces of code to each of the ``ColorRect`` nodes. "
"The order in which you apply the shaders depends on the position of the "
"``CanvasLayer`` in the scene tree, higher means sooner. For this blur "
"shader, the order does not matter."
msgstr ""
"舉例來說，你可以將下列程式碼片段分別掛載在各個 ``ColorRect`` 上，實作全螢幕高"
"斯模糊效果。著色器的執行順序取決於場景樹中 ``CanvasLayer`` 的排序，越上層的會"
"先執行。對於這個模糊著色器來說，順序並不影響結果。"

msgid ""
"Using the above code, you should end up with a full screen blur effect like "
"below."
msgstr "執行上述程式碼後，你將會得到如下的全螢幕模糊效果。"
