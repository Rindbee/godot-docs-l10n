#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "螢幕取樣著色器"

msgid "Introduction"
msgstr "前言"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"我們常常希望著色器能同時從正在寫入的螢幕讀取資料。像 OpenGL 或 DirectX 這類 "
"3D API，由於硬體本身的限制，這件事非常困難。GPU 是高度平行運作的，因此同時進"
"行讀寫會造成快取與一致性等各種問題。因此，即使是最新的硬體也無法完全正確支援"
"這一需求。"

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"解決方式是將螢幕或螢幕的一部分複製到後臺緩衝區（back-buffer），然後在繪製時從"
"該緩衝區讀取。Godot 提供了一些工具，可以簡化這個流程。"

msgid "Screen texture"
msgstr "螢幕紋理"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"Godot :ref:`doc_shading_language` 提供一種特殊紋理，能夠存取已繪製到螢幕上的"
"內容。宣告 ``sampler2D`` uniform 時，指定 ``hint_screen_texture`` 提示即可使"
"用。內建變數 ``SCREEN_UV`` 則可取得螢幕相對座標的 UV。舉例來說，下方這個 "
"canvas_item 片段著色器會讓物件隱形，因為它只顯示背後的內容："

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"這裡使用 ``textureLod``，因為我們只想讀取底層的 mipmap。如果你想讀取紋理的模"
"糊版本，只要增加 ``textureLod`` 的第三個參數，並將提示從 ``filter_nearest`` "
"改為 ``filter_nearest_mipmap`` （或其他啟用了 mipmap 的篩選器）。若使用啟用 "
"mipmap 的篩選，Godot 會自動計算出模糊紋理。"

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with an LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""
"如果濾鏡模式沒有設為名稱中含有 ``mipmap`` 的類型，則 ``textureLod`` 的 LOD 參"
"數大於 ``0.0`` 時，效果會與 LOD 為 ``0.0`` 相同。"

msgid "Screen texture example"
msgstr "螢幕紋理範例"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"螢幕紋理用途廣泛。有一個專門針對*螢幕空間著色器*的示範專案，歡迎下載學習。舉"
"例來說，可以用簡單著色器調整畫面的亮度、對比度與飽和度："

msgid "Behind the scenes"
msgstr "運作原理"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"這聽起來像是魔法，但其實不是。在 2D 中，當 Godot 首次在將要繪製的節點找到 "
"``hint_screen_texture`` 時，會將整個螢幕複製到後臺緩衝區。之後再有節點著色器"
"使用它，就不會再次複製，避免效能浪費。在 3D 中，螢幕是在不透明幾何體階段結束"
"後、透明幾何體開始前被複製，所以螢幕紋理不會包含透明物件。"

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"因此，在 2D 中，若多個使用 ``hint_screen_texture`` 的著色器重疊時，後面的著色"
"器無法取得前一個著色器的結果，可能產生意外的視覺效果："

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"在上圖中，第二個球體（右上）與第一個球體（下方）取樣自相同的螢幕紋理來源，因"
"此第一個球體會「消失」或不可見。"

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"在 2D 中，可以在兩個球體之間插入 :ref:`BackBufferCopy "
"<class_BackBufferCopy>` 節點來修正此問題。BackBufferCopy 可以複製整個螢幕，也"
"可指定螢幕區域："

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "正確處理後臺緩衝複製後，兩個球體就能正常混合顯示："

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""
"在 3D 中，使用 ``hint_screen_texture`` 的材質本身會被視為透明，且不會出現在其"
"他材質取得的螢幕紋理中。如果你要實例化一個使用 ``hint_screen_texture`` 材質的"
"場景，則必須搭配 BackBufferCopy 節點。"

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"在 3D 中，這類問題較難解決，因為螢幕紋理只會複製一次。在 3D 場景使用螢幕紋理"
"時要特別注意：它不會捕捉透明物件，反而可能捕捉到位於螢幕紋理物件前方的不透明"
"物件。"

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"你可以在 3D 中透過建立 :ref:`Viewport <class_Viewport>`，並將相機放在與物件相"
"同位置，之後直接取用 :ref:`Viewport <class_Viewport>` 的紋理來取代螢幕紋理，"
"達到類似後臺緩衝的效果。"

msgid "Back-buffer logic"
msgstr "後臺緩衝區機制"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr "以下更詳細說明 Godot 2D 後臺緩衝複製的機制："

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"如果某個節點使用了 ``hint_screen_texture``，在繪製該節點前會先將整個螢幕複製"
"到後臺緩衝區。這只會在首次出現時發生，後續節點不會重複複製。"

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"如果在上述情境前已經處理過 BackBufferCopy 節點（即使當時還沒用過 "
"``hint_screen_texture``），那麼就不會自動複製螢幕。換句話說，只有在節點樹順序"
"上首次遇到 ``hint_screen_texture``，且前面沒有啟用的 BackBufferCopy 節點時，"
"才會自動複製整個螢幕。"

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"BackBufferCopy 可以選擇複製整個螢幕，也可只複製特定區域。如果只複製了區域，但"
"著色器卻取樣到未被複製的像素，讀取結果就是未定義（通常是前一幀的垃圾資料）。"
"換言之，雖然技術上可以只複製一區再取樣另一區，但請避免這樣做！"

msgid "Depth texture"
msgstr "深度紋理"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"3D 著色器也能存取螢幕的深度緩衝，只需加上 ``hint_depth_texture`` 提示即可。這"
"個紋理不是線性的，必須用逆投影矩陣進行轉換。"

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "以下程式碼可取得目前繪製像素對應的 3D 位置："

msgid "Normal-roughness texture"
msgstr "法線-粗糙度紋理"

msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr "法線-粗糙度紋理僅支援於 Forward+ 算繪管線，不支援行動或相容模式。"

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"同理，法線-粗糙度紋理可用於讀取深度預算繪階段的物件之法線與粗糙度。法線資訊儲"
"存在 ``.xyz`` 通道（範圍映射到 0-1），粗糙度則存於 ``.w`` 通道。"

msgid "Redefining screen textures"
msgstr "自訂螢幕紋理"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"螢幕紋理的提示（``hint_screen_texture``、``hint_depth_texture``、"
"``hint_normal_roughness_texture``）可以套用在多個 uniform 上。例如，你可能會"
"想用不同的重複旗標或篩選旗標，對同一紋理重複取樣。"

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"以下範例展示一個著色器：它以線性篩選讀取螢幕空間法線，卻以最近點篩選讀取螢幕"
"空間粗糙度。"
