#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a SubViewport as a texture"
msgstr "使用 SubViewport 作為紋理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial will introduce you to using the :ref:`SubViewport "
"<class_SubViewport>` as a texture that can be applied to 3D objects. In "
"order to do so, it will walk you through the process of making a procedural "
"planet like the one below:"
msgstr ""
"本教學將介紹如何使用 :ref:`SubViewport <class_SubViewport>` 作為可應用於 3D "
"物件的紋理。為此，我們將帶你一步步製作下方這種程式化行星："

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr "本教學不會介紹如何編寫如圖中星球那樣的動態大氣。"

msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with "
"a :ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The "
"focus will be on using the :ref:`SubViewport <class_SubViewport>` to "
"dynamically create textures that can be applied to the mesh."
msgstr ""
"本教學假設你已熟悉如何建立基本場景，包括：一個 :ref:`Camera3D "
"<class_Camera3D>` 、一個 :ref:`光源 <class_OmniLight3D>`、一個帶"
"有 :ref:`Primitive Mesh <class_PrimitiveMesh>` 的 :ref:`MeshInstance3D "
"<class_MeshInstance3D>` ，並將 :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` 應用於該網格。本篇重點在於如何使"
"用 :ref:`SubViewport <class_SubViewport>` 動態產生可套用於網格的紋理。"

msgid "In this tutorial, we'll cover the following topics:"
msgstr "在本教學中，我們將介紹以下主題："

msgid "How to use a :ref:`SubViewport <class_SubViewport>` as a render texture"
msgstr "如何使用 :ref:`SubViewport <class_SubViewport>` 作為算繪紋理"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "使用等距矩形投影（equirectangular mapping）將紋理貼到球體"

msgid "Fragment shader techniques for procedural planets"
msgstr "程式化行星的片段著色器技術"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr "從 :ref:`Viewport 紋理 <class_ViewportTexture>` 設定粗糙度貼圖"

msgid "Setting up the scene"
msgstr "設定場景"

msgid "Create a new scene and add the following nodes exactly as shown below."
msgstr "建立新場景並依下方範例新增以下節點。"

msgid "Go into the the MeshInstance3D and make the mesh a SphereMesh"
msgstr "進入 MeshInstance3D，將其網格設為 SphereMesh"

msgid "Setting up the SubViewport"
msgstr "設定 SubViewport"

msgid ""
"Click on the :ref:`SubViewport <class_SubViewport>` node and set its size to "
"``(1024, 512)``. The :ref:`SubViewport <class_SubViewport>` can actually be "
"any size so long as the width is double the height. The width needs to be "
"double the height so that the image will accurately map onto the sphere, as "
"we will be using equirectangular projection, but more on that later."
msgstr ""
"點選 :ref:`SubViewport <class_SubViewport>` 節點，並將其尺寸設為 ``(1024, "
"512)``。:ref:`SubViewport <class_SubViewport>` 其實可以是任何尺寸，只要寬度為"
"高度的兩倍即可。寬度需要是高度的兩倍，這樣圖像才能正確對應到球體上，因為我們"
"將使用等距矩形投影（equirectangular projection）。後續會進一步說明。"

msgid ""
"Next disable 3D. We will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"接著關閉 3D 功能。我們將使用 :ref:`ColorRect <class_ColorRect>` 來繪製表面，"
"因此不需要啟用 3D。"

msgid ""
"Select the :ref:`ColorRect <class_ColorRect>` and in the inspector set the "
"anchors preset to ``Full Rect``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
"選取 :ref:`ColorRect <class_ColorRect>`，於屬性面板（Inspector）將 Anchors 預"
"設值設為 ``Full Rect``，這樣可以確保 :ref:`ColorRect <class_ColorRect>` 會填"
"滿整個 :ref:`SubViewport <class_SubViewport>`。"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to "
"the :ref:`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > "
"Material > ``New ShaderMaterial``)."
msgstr ""
"接著，為 :ref:`ColorRect <class_ColorRect>` 新增 :ref:`Shader Material "
"<class_ShaderMaterial>`（ColorRect > CanvasItem > Material > Material > "
"``New ShaderMaterial``）。"

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"建議對著色器有基本認識再學習本教學。不過即使你是新手，所有程式碼都會提供，跟"
"著操作應該沒有問題。"

msgid ""
"Click the dropdown menu button for the shader material and click / Edit. "
"From here go to Shader > ``New Shader``. give it a name and click "
"\"Create\". click the shader in the inspector to open the shader editor. "
"Delete the default code and add the following:"
msgstr ""
"點擊 ShaderMaterial 的下拉選單按鈕並選擇 Edit。然後前往 Shader > ``New "
"Shader``，命名後點選「Create」。在屬性面板中點擊該著色器以開啟著色器編輯器，"
"刪除預設程式碼並輸入下方內容："

msgid ""
"save the shader code, you'll see in the inspector that the above code "
"renders a gradient like the one below."
msgstr "儲存著色器程式碼後，你會在屬性面板看到上述程式碼呈現出如下圖的漸層。"

msgid ""
"Now we have the basics of a :ref:`SubViewport <class_SubViewport>` that we "
"render to and we have a unique image that we can apply to the sphere."
msgstr ""
"現在，我們已經完成一個可算繪內容的 :ref:`SubViewport <class_SubViewport>`，並"
"且擁有可以套用到球體的專屬圖像。"

msgid "Applying the texture"
msgstr "套用紋理"

msgid ""
"Now go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"現在進入 :ref:`MeshInstance3D <class_MeshInstance3D>` ，並新增一"
"個 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 給它。不需要特別"
"的 :ref:`Shader Material <class_ShaderMaterial>` （不過若要實作更進階效果，如"
"前述範例的大氣，則可以考慮）。"

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``"
msgstr ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``"

msgid "Then click the dropdown for the StandardMaterial3D and click \"Edit\""
msgstr "接著點擊 StandardMaterial3D 的下拉選單並選擇「Edit」"

msgid ""
"Go to the \"Resource\" section and check the ``Local to scene`` box. Then, "
"go to the \"Albedo\" section and click beside the \"Texture\" property to "
"add an Albedo Texture. Here we will apply the texture we made. Choose \"New "
"ViewportTexture\""
msgstr ""
"到「Resource」區塊勾選 ``Local to scene`` ，然後到「Albedo」區塊，點選"
"「Texture」屬性旁的按鈕以新增 Albedo 紋理。這裡請選擇「New "
"ViewportTexture」，將我們剛做的紋理套用上去"

msgid ""
"Click on the ViewportTexture you just created in the inspector, then click "
"\"Assign\". Then, from the menu that pops up, select the Viewport that we "
"rendered to earlier."
msgstr ""
"點選剛建立的 ViewportTexture，然後點擊「Assign」。在跳出的選單中選擇我們前面"
"算繪內容的 SubViewport。"

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "現在，你的球體應該已經套用上我們算繪進 Viewport 的顏色。"

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"你有注意到在紋理環繞時產生的醜陋縫隙嗎？這是因為我們根據 UV 座標取色，但 UV "
"座標本身不會環繞紋理，這是 2D 地圖投影時的經典問題。遊戲開發時經常需要將 2D "
"紋理投射到球體，而這種投影方式會產生明顯的接縫。這個問題其實有個優雅的解法，"
"我們會在下一節介紹。"

msgid "Making the planet texture"
msgstr "製作行星紋理"

msgid ""
"So now, when we render to our :ref:`SubViewport <class_SubViewport>`, it "
"appears magically on the sphere. But there is an ugly seam created by our "
"texture coordinates. So how do we get a range of coordinates that wrap "
"around the sphere in a nice way? One solution is to use a function that "
"repeats on the domain of our texture. ``sin`` and ``cos`` are two such "
"functions. Let's apply them to the texture and see what happens. Replace the "
"existing color code in the shader with the following:"
msgstr ""
"現在，當我們將內容算繪到 :ref:`SubViewport <class_SubViewport>` 時，它就會神"
"奇地顯示在球體上。不過目前因為紋理座標的關係產生了醜陋的接縫。那要怎麼讓座標"
"在球體上自然環繞呢？一種作法是使用會重複的數學函式，例如 ``sin`` 和 ``cos``。"
"我們來將這些函式套用到紋理上，看看會發生什麼事。請將著色器中的原有色彩程式碼"
"換成下方內容："

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in "
"its :ref:`StandardMaterial3D <class_StandardMaterial3D>`. It uses a "
"projection technique called equirectangular projection, which translates a "
"spherical map onto a 2D plane."
msgstr ""
"還不錯。你會發現接縫已經消失，但兩極出現了夾點。這是因為 Godot "
"的 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 將紋理貼到球體時採用"
"了一種稱為等距矩形投影（equirectangular projection）的技術，它會將球面座標轉"
"換成 2D 平面，因此極點會被擠壓。"

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"如果你想了解更多技術細節，我們其實會將球面座標轉換為直角座標。球面座標描述的"
"是球體的經度與緯度，而直角座標則是從球心指向該點的向量。"

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"對於每個像素，我們會計算其在球體上的 3D 位置，然後用 3D 噪聲來決定顏色。透過"
"在 3D 空間計算噪聲，就能解決極點夾點的問題。原因在於：如果噪聲是在球面上計"
"算，你永遠不會撞到邊界，因此不會產生接縫或極點夾點。以下程式碼會將 UV 轉換成"
"直角座標。"

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "如果我們將 ``unit`` 作為輸出的 ``COLOR`` 值，會得到："

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"既然我們能計算球體表面的 3D 位置，就能用 3D 雜訊來製作星球表面。這裡直接套用"
"來自 `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_ 的 noise 函式："

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr "所有功勞歸於作者 Inigo Quilez。這段程式碼以 ``MIT`` 授權釋出。"

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "現在要使用 ``noise``，請在 ``fragment`` 函式中加入以下內容："

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "為了凸顯紋理效果，我們將材質設為無陰影（unshaded）。"

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"你可以看到噪聲現在已經無縫環繞整個球體，雖然目前看起來還不像行星，所以我們接"
"下來要讓它更有色彩。"

msgid "Coloring the planet"
msgstr "星球著色"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"接下來要為行星上色。雖然有很多種方式，這裡我們先做一個水域與陸地的顏色漸層。"

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"要在 GLSL 裡做漸層，我們使用 ``mix`` 函式。``mix`` 需要兩個數值進行插值，第三"
"個參數決定插值比例；本質上，就是 *混合* 這兩個值。在其他 API 裡這個功能通常稱"
"作 ``lerp``。但 ``lerp`` 多用於混合兩個浮點數，而 ``mix`` 可以混合浮點數或向"
"量類型。"

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"第一個顏色是海洋的藍色，第二個顏色是偏紅的顏色（畢竟外星行星都要紅色地表）。"
"最後我們用 ``n * 0.5 + 0.5`` 混合它們。``n`` 在 ``-1`` 到 ``1`` 之間平滑變"
"化，因此我們將它轉換到 ``0-1`` 的範圍給 ``mix`` 使用。你會發現顏色會在藍色與"
"紅色之間變化。"

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"這樣的效果比我們想像中還模糊。行星通常陸地與海洋的分界清楚。要達到這樣的效"
"果，我們將最後的參數換成 ``smoothstep(-0.1, 0.0, n)``。這樣整行程式碼就會變"
"成："

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"``smoothstep`` 的作用是：當第三個參數比第一個還小時回傳 ``0``，比第二個還大時"
"回傳 ``1``，如果第三個值介於前兩者之間，則在 ``0`` 與 ``1`` 間平滑混合。所以"
"在這一行，當 ``n`` 小於 ``-0.1`` 時回傳 ``0``，大於 ``0`` 時回傳 ``1``。"

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"再來讓行星看起來更像行星一點。陸地不應該是圓滑的塊狀，我們要讓邊緣更粗糙。著"
"色器中常用的技巧是用不同頻率的雜訊疊加，一層決定大陸的主體形狀，再用額外幾層"
"破壞邊緣，如此類推。我們會用四行程式碼來計算 ``n``，而不是只有一行，如下所"
"示："

msgid "And now the planet looks like:"
msgstr "現在，行星看起來像這樣："

msgid "Making an ocean"
msgstr "製作海洋"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"最後一點，讓它更像一顆行星。海洋與陸地反光程度不同，我們希望海洋比陸地更閃"
"亮。可以把第四個值傳給輸出的 ``COLOR`` 的 ``alpha`` 通道，並將它作為粗糙度"
"（Roughness）貼圖使用。"

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"這一行對水域回傳 ``0.3``，對陸地回傳 ``1.0``。這代表陸地會非常粗糙，水域會很"
"光滑。"

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"然後在材質的「Metallic」區塊，將 ``Metallic`` 設為 ``0``，``Specular`` 設為 "
"``1``。這是因為水域會大量反射光線但不是金屬。這些數值雖不完全符合物理現實，但"
"對這個展示來說已經足夠。"

msgid ""
"Next, under the \"Roughness\" section set the roughness texture to "
"a :ref:`Viewport Texture <class_ViewportTexture>` pointing to our planet "
"texture :ref:`SubViewport <class_SubViewport>`. Finally, set the ``Texture "
"Channel`` to ``Alpha``. This instructs the renderer to use the ``alpha`` "
"channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"接著，在「Roughness」區塊，將粗糙度貼圖（Roughness Texture）設為指向我們行星"
"紋理的 :ref:`Viewport Texture <class_ViewportTexture>`，也就是指到我們"
"的 :ref:`SubViewport <class_SubViewport>`。最後將 ``Texture Channel`` 設為 "
"``Alpha``，這樣算繪器就會使用我們輸出 ``COLOR`` 的 ``alpha`` 通道作為 "
"``Roughness`` 的值。"

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`SubViewport "
"<class_SubViewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`SubViewport "
"<class_SubViewport>` and enable the \"Transparent Bg\" property. Since we "
"are now rendering one transparent object on top of another, we want to "
"enable ``blend_premul_alpha``:"
msgstr ""
"你會發現除了星球不再反射天空外，幾乎沒有其他變化。這是因為預設情況下，具有 "
"alpha 值的物件會以透明方式繪製在背景上，而 :ref:`SubViewport "
"<class_SubViewport>` 的預設背景是不透明的，導致 :ref:`Viewport Texture "
"<class_ViewportTexture>` 的 ``alpha`` 通道都是 ``1``，所以行星紋理顏色會較"
"淡，且 ``Roughness`` 值到處都是 1。為了解決這個問題，請切換"
"到 :ref:`SubViewport <class_SubViewport>`，啟用「Transparent Bg」屬性。由於現"
"在是在另一個透明物件上繪製，我們還要啟用 ``blend_premul_alpha``："

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"這會將顏色預先與 ``alpha`` 相乘，再正確混合。通常，當你在另一個透明顏色上疊加"
"時，即使背景的 ``alpha`` 為 ``0``（就像這裡），也可能出現奇怪的顏色滲出現象。"
"設定 ``blend_premul_alpha`` 就能解決這個問題。"

msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. move around the :ref:`OmniLight3D <class_OmniLight3D>` in the "
"scene so you can see the effect of the reflections on the ocean."
msgstr ""
"現在星球應該只會在海洋區域反射光線，陸地則不會。你可以移動場景中"
"的 :ref:`OmniLight3D <class_OmniLight3D>`，觀察海洋反射效果。"

msgid ""
"And there you have it. A procedural planet generated using "
"a :ref:`SubViewport <class_SubViewport>`."
msgstr ""
"就是這樣！你現在已經用 :ref:`SubViewport <class_SubViewport>` 產生了程式化行"
"星。"
