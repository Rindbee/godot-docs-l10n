#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CanvasItem shaders"
msgstr "CanvasItem 著色器"

msgid ""
"CanvasItem shaders are used to draw all 2D elements in Godot. These include "
"all nodes that inherit from CanvasItems, and all GUI elements."
msgstr ""
"畫布組件著色器用於繪製Godot中的所有二維元素. 這包括從畫布組件繼承的所有節點, "
"以及所有圖形化使用者介面元素."

msgid ""
"CanvasItem shaders contain fewer built-in variables and functionality "
"than :ref:`Spatial shaders<doc_spatial_shader>`, but they maintain the same "
"basic structure with vertex, fragment, and light processor functions."
msgstr ""
"畫布元件著色器比 :ref:`空間著色器<doc_spatial_shader>` 包含更少的內建變數和功"
"能, 但它們與頂點, 片段和光處理器功能保持相同的基本結構."

msgid "Render modes"
msgstr "算繪模式"

msgid "Render mode"
msgstr "算繪模式"

msgid "Description"
msgstr "說明"

msgid "**blend_mix**"
msgstr "**blend_mix**"

msgid "Mix blend mode (alpha is transparency), default."
msgstr "混合混合模式（Alpha 為透明度），預設。"

msgid "**blend_add**"
msgstr "**blend_add**"

msgid "Additive blend mode."
msgstr "加法混合模式。"

msgid "**blend_sub**"
msgstr "**blend_sub**"

msgid "Subtractive blend mode."
msgstr "減法混合模式。"

msgid "**blend_mul**"
msgstr "**blend_mul**"

msgid "Multiplicative blend mode."
msgstr "乘法混合模式。"

msgid "**blend_premul_alpha**"
msgstr "**blend_premul_alpha**"

msgid "Pre-multiplied alpha blend mode."
msgstr "預乘 Alpha 混合模式。"

msgid "**blend_disabled**"
msgstr "**blend_disabled**"

msgid "Disable blending, values (including alpha) are written as-is."
msgstr "禁用混合，值（包括 Alpha）會按原樣寫入。"

msgid "**unshaded**"
msgstr "**unshaded**"

msgid "Result is just albedo. No lighting/shading happens in material."
msgstr "結果只使用反照率。材質中不會發生照明/陰影。"

msgid "**light_only**"
msgstr "**light_only**"

msgid "Only draw on light pass."
msgstr "僅在光通過時繪製."

msgid "**skip_vertex_transform**"
msgstr "**skip_vertex_transform**"

msgid ""
"``VERTEX`` needs to be transformed manually in the ``vertex()`` function."
msgstr "VERTEX/NORMAL/等需要在頂點函式中手動轉換."

msgid "**world_vertex_coords**"
msgstr "**world_vertex_coords**"

msgid "``VERTEX`` is modified in world coordinates instead of local."
msgstr "VERTEX/NORMAL 等是以世界座標而不是局部座標修改的。"

msgid "Built-ins"
msgstr "內建變數"

msgid ""
"Values marked as ``in`` are read-only. Values marked as ``out`` can "
"optionally be written to and will not necessarily contain sensible values. "
"Values marked as ``inout`` provide a sensible default value, and can "
"optionally be written to. Samplers cannot be written to so they are not "
"marked."
msgstr ""
"標記為 ``in`` 的值為唯讀。標記為 ``out`` 的值可以選擇寫入，且不一定包含合理的"
"預設值。標記為 ``inout`` 的值則有預設值，可以選擇寫入。取樣器（sampler）無法"
"寫入，因此未標註。"

msgid ""
"Not all built-ins are available in all processing functions. To access a "
"vertex built-in from the ``fragment()`` function, you can use "
"a :ref:`varying <doc_shading_language_varyings>`. The same applies for "
"accessing fragment built-ins from the ``light()`` function."
msgstr ""
"並非所有內建變數都能在所有處理函式中使用。若要在 ``fragment()`` 函式中存取頂"
"點階段內建變數，可以利用 :ref:`varying <doc_shading_language_varyings>`。同"
"理，若需在 ``light()`` 函式中存取片段階段的內建變數，也請使用 varying。"

msgid "Global built-ins"
msgstr "全域內建變數"

msgid "Global built-ins are available everywhere, including custom functions."
msgstr "全域內建變數可於任何地方使用，包括自訂函式。"

msgid "Built-in"
msgstr "內建變數"

msgid "in float **TIME**"
msgstr "in float **TIME**"

msgid ""
"Global time since the engine has started, in seconds. It repeats after every "
"``3,600`` seconds (which can  be changed with "
"the :ref:`rollover<class_ProjectSettings_property_rendering/limits/time/"
"time_rollover_secs>` setting). It's affected "
"by :ref:`time_scale<class_Engine_property_time_scale>` but not by pausing. "
"If you need a ``TIME`` variable that is not affected by time scale, add your "
"own :ref:`global shader uniform<doc_shading_language_global_uniforms>` and "
"update it each frame."
msgstr ""
"自引擎啟動以來的全域時間（秒）。每 3,600 秒會重設（可透"
"過 :ref:`rollover<class_ProjectSettings_property_rendering/limits/time/"
"time_rollover_secs>` 設定變更）。該值會受"
"到 :ref:`time_scale<class_Engine_property_time_scale>` 影響，但不受暫停影響。"
"如果你需要不受 time_scale 影響的 ``TIME``，請自訂 :ref:`全域著色器 "
"uniform<doc_shading_language_global_uniforms>` 並於每幀更新。"

msgid "in float **PI**"
msgstr "in float **PI**"

msgid ""
"A ``PI`` constant (``3.141592``). A ratio of a circle's circumference to its "
"diameter and amount of radians in half turn."
msgstr "常數 PI（3.141592），為圓周長與直徑的比值，也是一半圈的弧度數。"

msgid "in float **TAU**"
msgstr "in float **TAU**"

msgid ""
"A ``TAU`` constant (``6.283185``). An equivalent of ``PI * 2`` and amount of "
"radians in full turn."
msgstr "常數 TAU（6.283185），等於 PI * 2，也是一整圈的弧度數。"

msgid "in float **E**"
msgstr "in float **E**"

msgid ""
"An ``E`` constant (``2.718281``). Euler's number and a base of the natural "
"logarithm."
msgstr "常數 E（2.718281），歐拉數，也是自然對數的底數。"

msgid "Vertex built-ins"
msgstr "頂點階段內建變數"

msgid ""
"Vertex data (``VERTEX``) is presented in local space (pixel coordinates, "
"relative to the Node2D's origin). If not written to, these values will not "
"be modified and be passed through as they came."
msgstr ""
"頂點資料( ``VERTEX`` )是以局部空間(像素座標, 相對於相機)呈現. 如果不寫入, 這"
"些值將不會被修改, 並按其來時的樣子傳遞."

msgid ""
"The user can disable the built-in model to world transform (world to screen "
"and projection will still happen later) and do it manually with the "
"following code:"
msgstr ""
"使用者可以禁用內建的modelview變換(以後仍然會發生投影), 並通過以下程式碼手動完"
"成:"

msgid ""
"Other built-ins, such as ``UV`` and ``COLOR``, are also passed through to "
"the ``fragment()`` function if not modified."
msgstr "其他內建程式, 如UV和COLOR, 如果沒有修改, 也會傳遞給片段函式."

msgid ""
"For instancing, the ``INSTANCE_CUSTOM`` variable contains the instance "
"custom data. When using particles, this information is usually:"
msgstr ""
"在產生實體（instancing）時，``INSTANCE_CUSTOM`` 變數包含自訂實例資料。用於粒"
"子時內容通常如下："

msgid "**x**: Rotation angle in radians."
msgstr "**x**：旋轉角度，單位為弧度。"

msgid "**y**: Phase during lifetime (``0.0`` to ``1.0``)."
msgstr "**y**：生命週期進度階段（0.0 ~ 1.0）。"

msgid "**z**: Animation frame."
msgstr "**z**：動畫影格索引。"

msgid "in mat4 **MODEL_MATRIX**"
msgstr "in mat4 **MODEL_MATRIX**"

msgid ""
"Local space to world space transform. World space is the coordinates you "
"normally use in the editor."
msgstr "局部空間到世界空間的變換。世界空間是您通常在編輯器中使用的座標。"

msgid "in mat4 **CANVAS_MATRIX**"
msgstr "in mat4 **CANVAS_MATRIX**"

msgid ""
"World space to canvas space transform. In canvas space the origin is the "
"upper-left corner of the screen and coordinates ranging from ``(0.0, 0.0)`` "
"to viewport size."
msgstr ""
"世界空間到畫布空間的變換。在畫布空間中，原點是螢幕的左上角，座標範圍從 (0, "
"0) 到視窗大小。"

msgid "in mat4 **SCREEN_MATRIX**"
msgstr "in mat4 **SCREEN_MATRIX**"

msgid ""
"Canvas space to clip space. In clip space coordinates ranging from ``(-1.0, "
"-1.0)`` to ``(1.0, 1.0).``"
msgstr ""
"畫布空間到剪輯空間。在剪輯空間中，座標範圍從 ``(-1.0, -1.0)`` 到 ``(1.0, "
"1.0)``"

msgid "in int  **INSTANCE_ID**"
msgstr "in int **INSTANCE_ID**"

msgid "Instance ID for instancing."
msgstr "產生實體（instancing）時的實例 ID。"

msgid "in vec4 **INSTANCE_CUSTOM**"
msgstr "in vec4 **INSTANCE_CUSTOM**"

msgid "Instance custom data."
msgstr "實例自訂資料."

msgid "in bool **AT_LIGHT_PASS**"
msgstr "in bool **AT_LIGHT_PASS**"

msgid "Always ``false``."
msgstr "總是 ``false``."

msgid "in vec2 **TEXTURE_PIXEL_SIZE**"
msgstr "in vec2 **TEXTURE_PIXEL_SIZE**"

msgid ""
"Normalized pixel size of default 2D texture. For a Sprite2D with a texture "
"of size 64x32px, **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"
msgstr ""
"預設 2D 紋理的標準化像素大小。對於紋理大小為 64x32px 的 Sprite，"
"**TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"

msgid "inout vec2 **VERTEX**"
msgstr "inout vec2 **VERTEX**"

msgid "Vertex position, in local space."
msgstr "頂點, 在圖像空間."

msgid "in int **VERTEX_ID**"
msgstr "in int **VERTEX_ID**"

msgid "The index of the current vertex in the vertex buffer."
msgstr "目前頂點在頂點緩衝區中的索引。"

msgid "inout vec2 **UV**"
msgstr "inout vec2 **UV**"

msgid "Normalized texture coordinates. Range from ``0.0`` to ``1.0``."
msgstr "標準化紋理座標。範圍從 0 到 1。"

msgid "inout vec4 **COLOR**"
msgstr "inout vec4 **COLOR**"

msgid ""
"Color from vertex primitive multiplied by "
"CanvasItem's :ref:`modulate<class_CanvasItem_property_modulate>` multiplied "
"by "
"CanvasItem's :ref:`self_modulate<class_CanvasItem_property_self_modulate>`."
msgstr ""
"頂點圖元的顏色乘以 CanvasItem "
"的 :ref:`modulate<class_CanvasItem_property_modulate>`，再乘以 CanvasItem "
"的 :ref:`self_modulate<class_CanvasItem_property_self_modulate>`。"

msgid "inout float **POINT_SIZE**"
msgstr "inout float **POINT_SIZE**"

msgid "Point size for point drawing."
msgstr "點繪圖的點大小."

msgid "in vec4 **CUSTOM0**"
msgstr "in vec4 **CUSTOM0**"

msgid "Custom value from vertex primitive."
msgstr "來自頂點原始資料的自訂值。"

msgid "in vec4 **CUSTOM1**"
msgstr "in vec4 **CUSTOM1**"

msgid "Fragment built-ins"
msgstr "片段階段內建變數"

msgid "COLOR and TEXTURE"
msgstr "COLOR 與 TEXTURE"

msgid "The built-in variable ``COLOR`` is used for a few things:"
msgstr "內建變數 ``COLOR`` 有以下幾種用途："

msgid ""
"In the ``vertex()`` function, ``COLOR`` contains the color from the vertex "
"primitive multiplied by the "
"CanvasItem's :ref:`modulate<class_CanvasItem_property_modulate>` multiplied "
"by the "
"CanvasItem's :ref:`self_modulate<class_CanvasItem_property_self_modulate>`."
msgstr ""
"在 ``vertex()`` 函式中，``COLOR`` 包含來自頂點圖元的顏色，乘以 CanvasItem "
"的 :ref:`modulate<class_CanvasItem_property_modulate>`，再乘以 CanvasItem "
"的 :ref:`self_modulate<class_CanvasItem_property_self_modulate>`。"

msgid ""
"In the ``fragment()`` function, the input value ``COLOR`` is that same value "
"multiplied by the color from the default ``TEXTURE`` (if present)."
msgstr ""
"在 ``fragment()`` 函式中，輸入值 ``COLOR`` 為上述顏色再乘以預設 ``TEXTURE`` "
"的顏色（若有設定）。"

msgid "In the ``fragment()`` function, ``COLOR`` is also the final output."
msgstr "在 ``fragment()`` 函式中，``COLOR`` 也是最終的輸出值。"

msgid ""
"Certain nodes (for example, :ref:`Sprite2D <class_Sprite2D>`) display a "
"texture by default, for example :ref:`texture "
"<class_Sprite2D_property_texture>`. When using a custom ``fragment()`` "
"function, you have a few options on how to sample this texture."
msgstr ""
"某些節點（如 :ref:`Sprite2D <class_Sprite2D>`）預設會顯示一張材質，例"
"如 :ref:`texture <class_Sprite2D_property_texture>`。使用自訂的 "
"``fragment()`` 函式時，您有數種方式可以取樣該材質。"

msgid ""
"To read only the contents of the default texture, ignoring the vertex "
"``COLOR``:"
msgstr "若只需讀取預設材質的內容，忽略頂點 ``COLOR``："

msgid ""
"To read the contents of the default texture multiplied by vertex ``COLOR``:"
msgstr "若需讀取預設材質內容並乘以頂點 ``COLOR``："

msgid ""
"To read only the vertex ``COLOR`` in ``fragment()``, ignoring the main "
"texture, you must pass ``COLOR`` as a varying, then read it in "
"``fragment()``:"
msgstr ""
"若需在 ``fragment()`` 中只讀取頂點 ``COLOR`` 而忽略主材質，必須將 ``COLOR`` "
"作為 varying 傳遞，然後在 ``fragment()`` 內讀取："

msgid "NORMAL"
msgstr "NORMAL"

msgid ""
"Similarly, if a normal map is used in the :ref:`CanvasTexture "
"<class_CanvasTexture>`, Godot uses it by default and assigns its value to "
"the built-in ``NORMAL`` variable. If you are using a normal map meant for "
"use in 3D, it will appear inverted. In order to use it in your shader, you "
"must assign it to the ``NORMAL_MAP`` property. Godot will handle converting "
"it for use in 2D and overwriting ``NORMAL``."
msgstr ""
"同樣地，若在 :ref:`CanvasTexture <class_CanvasTexture>` 使用法線貼圖，Godot "
"會預設將其值指派給內建的 ``NORMAL`` 變數。如果你使用的是 3D 專用的法線貼圖，"
"顯示時會顛倒。要在你的著色器中使用，必須將其指派給 ``NORMAL_MAP`` 屬性，"
"Godot 會自動轉換成 2D 專用並覆寫 ``NORMAL``。"

msgid "in vec4 **FRAGCOORD**"
msgstr "in vec4 **FRAGCOORD**"

msgid ""
"Coordinate of pixel center. In screen space. ``xy`` specifies position in "
"viewport. Upper-left of the viewport is the origin, ``(0.0, 0.0)``."
msgstr ""
"像素中心的座標。在螢幕空間中，``xy`` 表示視窗中的位置，如果沒有用 ``DEPTH``，"
"則 ``z`` 表示片段深度。原點位於左下角。"

msgid "in vec2 **SCREEN_PIXEL_SIZE**"
msgstr "in vec2 **SCREEN_PIXEL_SIZE**"

msgid "Size of individual pixels. Equal to inverse of resolution."
msgstr "單個像素的大小. 等於解析度的倒數."

msgid "in vec2 **POINT_COORD**"
msgstr "in vec2 **POINT_COORD**"

msgid "Coordinate for drawing points."
msgstr "所繪製點的座標。"

msgid "sampler2D **TEXTURE**"
msgstr "sampler2D **TEXTURE**"

msgid "Default 2D texture."
msgstr "預設的2D紋理."

msgid ""
"Normalized pixel size of default 2D texture. For a Sprite2D with a texture "
"of size 64x32px, ``TEXTURE_PIXEL_SIZE`` = ``vec2(1/64, 1/32)``"
msgstr ""
"預設 2D 紋理的標準化像素大小。對於紋理大小為 64x32px 的 Sprite，"
"**TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"

msgid "sampler2D **SPECULAR_SHININESS_TEXTURE**"
msgstr "sampler2D **SPECULAR_SHININESS_TEXTURE**"

msgid "Specular shininess texture of this object."
msgstr "該物件的鏡面光澤紋理。"

msgid "in vec4 **SPECULAR_SHININESS**"
msgstr "in vec4 **SPECULAR_SHININESS**"

msgid "Specular shininess color, as sampled from the texture."
msgstr "鏡面光澤顏色，從紋理取樣。"

msgid "in vec2 **UV**"
msgstr "in vec2 **UV**"

msgid "in vec2 **SCREEN_UV**"
msgstr "in vec2 **SCREEN_UV**"

msgid "Screen UV coordinate for current pixel."
msgstr "當前像素的螢幕 UV 座標。"

msgid "sampler2D **SCREEN_TEXTURE**"
msgstr "sampler2D **SCREEN_TEXTURE**"

msgid ""
"Removed in Godot 4. Use a ``sampler2D`` with ``hint_screen_texture`` instead."
msgstr ""
"已於 Godot 4 移除。請改用帶有 ``hint_screen_texture`` 的 ``sampler2D``。"

msgid "inout vec3 **NORMAL**"
msgstr "inout vec3 **NORMAL**"

msgid "Normal read from ``NORMAL_TEXTURE``. Writable."
msgstr "從 ** NORMAL_TEXTURE ** 中正常讀取. 可寫的."

msgid "sampler2D **NORMAL_TEXTURE**"
msgstr "輸入sampler2D **NORMAL_TEXTURE**"

msgid "Default 2D normal texture."
msgstr "預設 2D 法線紋理。"

msgid "out vec3 **NORMAL_MAP**"
msgstr "out vec3 **NORMAL_MAP**"

msgid ""
"Configures normal maps meant for 3D for use in 2D. If used, overrides "
"``NORMAL``."
msgstr "配置用於三維的法線貼圖, 以便在二維中使用. 如果使用, 則覆蓋 **法線** ."

msgid "out float **NORMAL_MAP_DEPTH**"
msgstr "out float **NORMAL_MAP_DEPTH**"

msgid "Normal map depth for scaling."
msgstr "用於縮放的法線貼圖深度."

msgid "Pixel position in screen space."
msgstr "法向量, 在視圖空間中."

msgid "inout vec2 **SHADOW_VERTEX**"
msgstr "inout vec2 **SHADOW_VERTEX**"

msgid "Same as ``VERTEX`` but can be written to alter shadows."
msgstr "與 VERTEX 相同，但可以寫入來改變陰影。"

msgid "inout vec3 **LIGHT_VERTEX**"
msgstr "inout vec3 **LIGHT_VERTEX**"

msgid ""
"Same as ``VERTEX`` but can be written to alter lighting. Z component "
"represents height."
msgstr "與“VERTEX”相同，但可以寫入來改變照明。 Z 分量代表高度。"

msgid ""
"``COLOR`` from the ``vertex()`` function multiplied by the ``TEXTURE`` "
"color. Also output color value."
msgstr "從頂點函式和輸出片段顏色. 如果未使用, 將設定為 **紋理** 顏色."

msgid "Light built-ins"
msgstr "燈光階段內建變數"

msgid ""
"Light processor functions work differently in Godot 4.x than they did in "
"Godot 3.x. In Godot 4.x all lighting is done during the regular draw pass. "
"In other words, Godot no longer draws the object again for each light."
msgstr ""
"光處理器函式在 Godot 4.x 中的運作方式與在 Godot 3.x 中的工作方式不同。在 "
"Godot 4.x 中，所有照明都是在常規繪製過程中完成的。換句話說，Godot 不再為每個"
"光重新繪製物體。"

msgid ""
"Use the ``unshaded`` render mode if you do not want the ``light()`` function "
"to run. Use the ``light_only`` render mode if you only want to see the "
"impact of lighting on an object; this can be useful when you only want the "
"object visible where it is covered by light."
msgstr ""
"光照處理器功能在 2D 中與在 3D 中工作不同。在 CanvasItem 著色器中，這個著色器"
"會為被繪製的物件呼叫一次，然後再為每一束接觸場景中該物體的光呼叫一次。如果您"
"不希望該物件發生任何光傳遞，請使用 render_mode ``unshaded``。如果您只想讓光通"
"過該物件，使用 render_mode ``light_only``；當您只想讓被光覆蓋的物件可見時，這"
"是非常有用的。"

msgid ""
"If you define a ``light()`` function it will replace the built-in light "
"function, even if your light function is empty."
msgstr ""
"如果你定義了 ``light()`` 函式，即使該函式是空的，也會取代內建的光照函式。"

msgid ""
"Below is an example of a light shader that takes a CanvasItem's normal map "
"into account:"
msgstr "以下是考慮 CanvasItem 法線貼圖的燈光著色器範例："

msgid "in vec3 **NORMAL**"
msgstr "in vec3 **NORMAL**"

msgid "Input normal."
msgstr "輸入法線。"

msgid "in vec4 **COLOR**"
msgstr "in vec4 **COLOR**"

msgid "Input color. This is the output of the ``fragment()`` function."
msgstr ""
"輸入顏色. 這是片段函式的輸出(如果在著色器的任何函式中沒有使用 **MODULATE** , "
"則應用最終調變)."

msgid ""
"UV from the ``vertex()`` function, equivalent to the UV in the "
"``fragment()`` function."
msgstr "來自頂點函式的UV, 相當於片段函式中的UV."

msgid "Current texture in use for CanvasItem."
msgstr "CanvasItem使用的目前紋理."

msgid ""
"Normalized pixel size of ``TEXTURE``. For a Sprite2D with a ``TEXTURE`` of "
"size ``64x32`` pixels, **TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"
msgstr ""
"預設 2D 紋理的標準化像素大小。對於紋理大小為 64x32px 的 Sprite，"
"**TEXTURE_PIXEL_SIZE** = ``vec2(1/64, 1/32)``"

msgid "UV for Point Sprite."
msgstr "點精靈的UV."

msgid "in vec4 **LIGHT_COLOR**"
msgstr "in vec4 **LIGHT_COLOR**"

msgid ""
":ref:`Color<class_Light2D_property_color>` of the :ref:`class_Light2D`. If "
"the light is a :ref:`class_PointLight2D`, multiplied by the "
"light's :ref:`texture<class_PointLight2D_property_texture>`."
msgstr ""
":ref:`class_Light2D` 的 :ref:`Color<class_Light2D_property_color>`。若"
"為 :ref:`class_PointLight2D`，則再乘以該光源"
"的 :ref:`texture<class_PointLight2D_property_texture>`。"

msgid "in float **LIGHT_ENERGY**"
msgstr "in float **LIGHT_ENERGY**"

msgid ""
":ref:`Energy multiplier<class_Light2D_property_energy>` of "
"the :ref:`class_Light2D`."
msgstr ""
":ref:`class_Light2D` 的 :ref:`Energy "
"multiplier<class_Light2D_property_energy>`。"

msgid "in vec3 **LIGHT_POSITION**"
msgstr "in vec3 **LIGHT_POSITION**"

msgid ""
"Position of the :ref:`class_Light2D` in screen space. If using "
"a :ref:`class_DirectionalLight2D` this is always ``(0.0, 0.0, 0.0)``."
msgstr ""
"燈光在螢幕空間中 :ref:`class_Light2D` 的位置。如果使用的"
"是 :ref:`class_DirectionalLight2D` ，則始終為 ``(0.0, 0.0, 0.0)``。"

msgid "in vec3 **LIGHT_DIRECTION**"
msgstr "in vec3 **LIGHT_DIRECTION**"

msgid "Direction of the :ref:`class_Light2D` in screen space."
msgstr ":ref:`class_Light2D` 在螢幕空間中的方向。"

msgid "in bool **LIGHT_IS_DIRECTIONAL**"
msgstr "in bool **LIGHT_IS_DIRECTIONAL**"

msgid "``true`` if this pass is a :ref:`class_DirectionalLight2D`."
msgstr "如果 ``true`` 代表是 :ref:`class_DirectionalLight2D` ."

msgid "in vec3 **LIGHT_VERTEX**"
msgstr "in vec3 **LIGHT_VERTEX**"

msgid ""
"Pixel position, in screen space as modified in the ``fragment()`` function."
msgstr "``world_position`` 可用於頂點函式或片段函式."

msgid "inout vec4 **LIGHT**"
msgstr "inout vec4 **LIGHT**"

msgid "Output color for this :ref:`class_Light2D`."
msgstr "此 :ref:`class_Light2D` 的輸出顏色."

msgid "Specular shininess, as set in the object's texture."
msgstr "鏡面光澤度，在物件紋理中設定。"

msgid "out vec4 **SHADOW_MODULATE**"
msgstr "out vec4 **SHADOW_MODULATE**"

msgid "Multiply shadows cast at this point by this color."
msgstr "將此時投射的陰影乘以該顏色。"

msgid "SDF functions"
msgstr "函式"

msgid ""
"There are a few additional functions implemented to sample an automatically "
"generated Signed Distance Field texture. These functions available for the "
"``fragment()`` and ``light()`` functions of CanvasItem shaders. Custom "
"functions may also use them as long as they called from supported functions."
msgstr ""
"也實作了一些附加函式來對自動產生的有符號距離場紋理進行取樣。這些函式可用於 "
"CanvasItem 著色器的片段和燈光函式。"

msgid ""
"The signed distance field is generated from :ref:`class_LightOccluder2D` "
"nodes present in the scene with the **SDF Collision** property enabled "
"(which is the default). See the :ref:`2D lights and shadows "
"<doc_2d_lights_and_shadows_setting_up_shadows>` documentation for more "
"information."
msgstr ""
"帶符號的距離場是從場景中存在的 :ref:`class_LightOccluder2D` 節點產生的，並且"
"啟用了 **SDF Collision** 屬性（這是預設）。有關更多信息，請參閱 :ref:`2D 燈光"
"和陰影 <doc_2d_lights_and_shadows_setting_up_shadows>` 說明文件。"

msgid "Function"
msgstr "函式"

msgid "float **texture_sdf** (vec2 sdf_pos)"
msgstr "float **texture_sdf** (vec2 sdf_pos)"

msgid "Performs an SDF texture lookup."
msgstr "執行2D紋理讀取。"

msgid "vec2 **texture_sdf_normal** (vec2 sdf_pos)"
msgstr "vec2 **texture_sdf_normal** (vec2 sdf_pos)"

msgid "Calculates a normal from the SDF texture."
msgstr "預設 2D 法線紋理。"

msgid "vec2 **sdf_to_screen_uv** (vec2 sdf_pos)"
msgstr "vec2 **sdf_to_screen_uv** (vec2 sdf_pos)"

msgid "Converts an SDF to screen UV."
msgstr "將 SDF 轉換為螢幕 UV。"

msgid "vec2 **screen_uv_to_sdf** (vec2 uv)"
msgstr "vec2 **screen_uv_to_sdf** (vec2 uv)"

msgid "Converts screen UV to an SDF."
msgstr "轉換螢幕UV為SDF。"
