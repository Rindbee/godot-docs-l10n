#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shader preprocessor"
msgstr "著色器預處理器"

msgid "Why use a shader preprocessor?"
msgstr "為什麼要使用著色器預處理器？"

msgid ""
"In programming languages, a *preprocessor* allows changing the code before "
"the compiler reads it. Unlike the compiler, the preprocessor does not care "
"about whether the syntax of the preprocessed code is valid. The preprocessor "
"always performs what the *directives* tell it to do. A directive is a "
"statement starting with a hash symbol (``#``). It is not a *keyword* of the "
"shader language (such as ``if`` or ``for``), but a special kind of token "
"within the language."
msgstr ""
"在程式語言中， *預處理器* 允許在編譯器讀取程式碼之前對其進行更改。與編譯器不"
"同，預處理器不會檢查預處理後程式碼的語法是否正確。預處理器只會執行 *指令* 所"
"指定的動作。指令是以井字號（ ``#`` ）開頭的敘述，它不是著色器語言的 *關鍵字* "
"（如 ``if`` 或 ``for`` ），而是一種類型特殊的語言標記。"

msgid ""
"From Godot 4.0 onwards, you can use a shader preprocessor within text-based "
"shaders. The syntax is similar to what most GLSL shader compilers support "
"(which in turn is similar to the C/C++ preprocessor)."
msgstr ""
"自 Godot 4.0 起，你可以在文字式著色器內使用著色器預處理器。其語法與大多數 "
"GLSL 著色器編譯器所支援的語法類似（又與 C/C++ 的預處理器相近）。"

msgid ""
"The shader preprocessor is not available in :ref:`visual shaders "
"<doc_visual_shaders>`. If you need to introduce preprocessor statements to a "
"visual shader, you can convert it to a text-based shader using the **Convert "
"to Shader** option in the VisualShader inspector resource dropdown. This "
"conversion is a one-way operation; text shaders cannot be converted back to "
"visual shaders."
msgstr ""
"著色器預處理器無法在 :ref:`視覺化著色器 <doc_visual_shaders>` 中使用。如果你"
"需要在視覺化著色器中加入預處理器指令，可以在 VisualShader 屬性檢視器的資源下"
"拉選單中使用 **轉換為著色器** 選項，將其轉換為文字式著色器。此轉換僅為單向操"
"作，無法將文字式著色器再轉回視覺化著色器。"

msgid "Directives"
msgstr "指令"

msgid "General syntax"
msgstr "一般語法"

msgid ""
"Preprocessor directives do not use brackets (``{}``), but can use "
"parentheses."
msgstr "預處理器指令不使用大括號（``{}``），但可以使用小括號。"

msgid ""
"Preprocessor directives **never** end with semicolons (with the exception of "
"``#define``, where this is allowed but potentially dangerous)."
msgstr ""
"預處理器指令**絕不**以分號結尾（除了 ``#define``，雖然允許但有潛在風險）。"

msgid ""
"Preprocessor directives can span several lines by ending each line with a "
"backslash (``\\``). The first line break *not* featuring a backslash will "
"end the preprocessor statement."
msgstr ""
"預處理器指令可以透過在每行末尾加上反斜線（``\\``）來換行，直到遇到沒有反斜線"
"的換行符才會結束該指令。"

msgid "#define"
msgstr "#define"

msgid "**Syntax:** ``#define <identifier> [replacement_code]``."
msgstr "**語法：** ``#define <識別字> [替換程式碼]``。"

msgid ""
"Defines the identifier after that directive as a macro, and replaces all "
"successive occurrences of it with the replacement code given in the shader. "
"Replacement is performed on a \"whole words\" basis, which means no "
"replacement is performed if the string is part of another string (without "
"any spaces or operators separating it)."
msgstr ""
"這個指令會將後面的識別字定義為巨集，並用指定的替換程式碼取代後續出現的所有同"
"名識別字。替換只針對「完整單字」進行，也就是說，如果該字串是其他字串的一部分"
"（未被空白或運算子分隔），就不會取代。"

msgid ""
"Defines with replacements may also have one or more *arguments*, which can "
"then be passed when referencing the define (similar to a function call)."
msgstr ""
"帶有替換程式碼的巨集定義，也可以有一個或多個*參數*，在使用時像函式一樣傳入參"
"數。"

msgid ""
"If the replacement code is not defined, the identifier may only be used with "
"``#ifdef`` or ``#ifndef`` directives."
msgstr ""
"若未指定替換程式碼，該識別字只能搭配 ``#ifdef`` 或 ``#ifndef`` 指令使用。"

msgid ""
"If the *concatenation* symbol (``##``) is present in the replacement code "
"then it will be removed upon macro insertion, together with any space "
"surrounding it, and join the surrounding words and arguments into a new "
"token."
msgstr ""
"如果替換程式碼中出現*串接*符號（``##``），在巨集展開時會一併移除該符號及其兩"
"側的空白，並將相鄰的字或參數合併成新的標記。"

msgid ""
"Compared to constants (``const CONSTANT = value;``), ``#define`` can be used "
"anywhere within the shader (including in uniform hints). ``#define`` can "
"also be used to insert arbitrary shader code at any location, while "
"constants can't do that."
msgstr ""
"與常數（``const CONSTANT = value;``）相比，``#define`` 可以在著色器中的任何位"
"置使用（包括 uniform 提示中）。``#define`` 也能在任意位置插入自訂程式碼，而常"
"數無法做到這一點。"

msgid ""
"Defining a ``#define`` for an identifier that is already defined results in "
"an error. To prevent this, use ``#undef <identifier>``."
msgstr ""
"若對已定義過的識別字再次 ``#define`` 會導致錯誤。要避免這種情形，請先使用 "
"``#undef <識別字>``。"

msgid "#undef"
msgstr "#undef"

msgid "**Syntax:** ``#undef identifier``"
msgstr "**語法：** ``#undef 識別字``"

msgid ""
"The ``#undef`` directive may be used to cancel a previously defined "
"``#define`` directive:"
msgstr "``#undef`` 指令可用來取消先前定義的 ``#define`` 指令："

msgid ""
"Without ``#undef`` in the above example, there would be a macro redefinition "
"error."
msgstr "上例若沒有 ``#undef``，會出現巨集重複定義錯誤。"

msgid "#if"
msgstr "#if"

msgid "**Syntax:** ``#if <condition>``"
msgstr "**語法：** ``#if <條件>``"

msgid ""
"The ``#if`` directive checks whether the ``condition`` passed. If it "
"evaluates to a non-zero value, the code block is included, otherwise it is "
"skipped."
msgstr ""
"``#if`` 指令會檢查指定的 ``條件``，若結果為非零，則包含該程式碼區塊，否則跳"
"過。"

msgid ""
"To evaluate correctly, the condition must be an expression giving a simple "
"floating-point, integer or boolean result. There may be multiple condition "
"blocks connected by ``&&`` (AND) or ``||`` (OR) operators. It may be "
"continued by a ``#else`` block, but **must** be ended with the ``#endif`` "
"directive."
msgstr ""
"條件必須是能得到浮點數、整數或布林值結果的簡單運算式，才能正確判斷。可以用 "
"``&&``（AND）或 ``||``（OR）運算子串聯多個條件區塊。可以接續 ``#else`` 區塊，"
"但**必須**以 ``#endif`` 指令結束。"

msgid ""
"Using the ``defined()`` *preprocessor function*, you can check whether the "
"passed identifier is defined a by ``#define`` placed above that directive. "
"This is useful for creating multiple shader versions in the same file. It "
"may be continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"利用 ``defined()`` *預處理器函式*，你可以檢查指定的識別字是否已由上方的 "
"``#define`` 定義。這對在同一檔案內建立多個著色器版本很實用。可以接續 "
"``#else`` 區塊，但必須以 ``#endif`` 指令結束。"

msgid ""
"The ``defined()`` function's result can be negated by using the ``!`` "
"(boolean NOT) symbol in front of it. This can be used to check whether a "
"define is *not* set."
msgstr ""
"你可在 ``defined()`` 前加上 ``!`` （布林 NOT）符號，反向判斷是否 *未* 設定該"
"定義。"

msgid ""
"Be careful, as ``defined()`` must only wrap a single identifier within "
"parentheses, never more:"
msgstr "請注意，``defined()`` 小括號內只能包住一個識別字，不能有多個："

msgid ""
"In the shader editor, preprocessor branches that evaluate to ``false`` (and "
"are therefore excluded from the final compiled shader) will appear grayed "
"out. This does not apply to runtime ``if`` statements."
msgstr ""
"在著色器編輯器中，經預處理判斷為 ``false``（因此未編譯進最終著色器）的分支，"
"會顯示為灰色。這不適用於執行階段的 ``if`` 敘述。"

msgid "**#if preprocessor versus if statement: Performance caveats**"
msgstr "**#if 預處理器與 if 敘述：效能注意事項**"

msgid ""
"The :ref:`shading language <doc_shading_language>` supports runtime ``if`` "
"statements:"
msgstr ":ref:`著色語言 <doc_shading_language>` 支援執行時期的 ``if`` 敘述："

msgid ""
"If the uniform is never changed, this behaves identical to the following "
"usage of the ``#if`` preprocessor statement:"
msgstr ""
"如果 uniform 變數不會被更動，其效果就等同於下方這種 ``#if`` 預處理器語法："

msgid ""
"However, the ``#if`` variant can be faster in certain scenarios. This is "
"because all runtime branches in a shader are still compiled and variables "
"within those branches may still take up register space, even if they are "
"never run in practice."
msgstr ""
"不過，在某些情況下，使用 ``#if`` 預處理器版本會更快。因為著色器的所有執行時分"
"支都會被編譯，即使從未實際執行過，其中的變數仍可能佔用暫存器空間。"

msgid ""
"Modern GPUs are `quite effective <https://medium.com/@jasonbooth_86226/"
"branching-on-a-gpu-18bfc83694f2>`__ at performing \"static\" branching. "
"\"Static\" branching refers to ``if`` statements where *all* pixels/vertices "
"evaluate to the same result in a given shader invocation. However, high "
"amounts of :abbr:`VGPRs (Vector General-Purpose Register)` (which can be "
"caused by having too many branches) can still slow down shader execution "
"significantly."
msgstr ""
"現代 GPU 在處理「靜態」分支時 `效率相當高 <https://medium.com/"
"@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2>`__。「靜態」分支指的是同一"
"次著色器執行時，*所有* 像素或頂點都會得到相同結果的 ``if`` 敘述。不過，如果分"
"支太多，會導致 :abbr:`VGPRs (向量通用暫存器)` 占用過多，還是會大幅影響著色器"
"效能。"

msgid "#elif"
msgstr "#elif"

msgid ""
"The ``#elif`` directive stands for \"else if\" and checks the condition "
"passed if the above ``#if`` evaluated to ``false``. ``#elif`` can only be "
"used within an ``#if`` block. It is possible to use several ``#elif`` "
"statements after an ``#if`` statement."
msgstr ""
"``#elif`` 指令代表「else if」，僅當前一個 ``#if`` 條件為 ``false`` 時才檢查其"
"條件。``#elif`` 只能用在 ``#if`` 區塊內，並且可以連續使用多個 ``#elif``。"

msgid "Like with ``#if``, the ``defined()`` preprocessor function can be used:"
msgstr "同樣地，也可在 ``#elif`` 中使用 ``defined()`` 預處理器函式："

msgid "#ifdef"
msgstr "#ifdef"

msgid "**Syntax:** ``#ifdef <identifier>``"
msgstr "**語法：** ``#ifdef <識別字>``"

msgid ""
"This is a shorthand for ``#if defined(...)``. Checks whether the passed "
"identifier is defined by ``#define`` placed above that directive. This is "
"useful for creating multiple shader versions in the same file. It may be "
"continued by a ``#else`` block, but must be ended with the ``#endif`` "
"directive."
msgstr ""
"這是 ``#if defined(...)`` 的簡寫。會檢查指定的識別字是否已由前面 ``#define`` "
"定義。這在同一檔案內設計多種著色器版本時非常實用。可接續 ``#else`` 區塊，但必"
"須以 ``#endif`` 指令結束。"

msgid ""
"The processor does *not* support ``#elifdef`` as a shortcut for ``#elif "
"defined(...)``. Instead, use the following series of ``#ifdef`` and "
"``#else`` when you need more than two branches:"
msgstr ""
"處理器*不*支援 ``#elifdef`` 作為 ``#elif defined(...)`` 的簡寫。如果需要超過"
"兩個分支，請依下方範例使用多個 ``#ifdef`` 和 ``#else``："

msgid "#ifndef"
msgstr "#ifndef"

msgid "**Syntax:** ``#ifndef <identifier>``"
msgstr "**語法：** ``#ifndef <識別字>``"

msgid ""
"This is a shorthand for ``#if !defined(...)``. Similar to ``#ifdef``, but "
"checks whether the passed identifier is **not** defined by ``#define`` "
"before that directive."
msgstr ""
"這是 ``#if !defined(...)`` 的簡寫。和 ``#ifdef`` 類似，但會檢查指定的識別字在"
"該指令前**沒有**被 ``#define`` 定義。"

msgid ""
"This is the exact opposite of ``#ifdef``; it will always match in situations "
"where ``#ifdef`` would never match, and vice versa."
msgstr ""
"這與 ``#ifdef`` 完全相反；凡是 ``#ifdef`` 不成立的情況，``#ifndef`` 就會成"
"立，反之亦然。"

msgid "#else"
msgstr "#else"

msgid "**Syntax:** ``#else``"
msgstr "**語法：** ``#else``"

msgid ""
"Defines the optional block which is included when the previously defined "
"``#if``, ``#elif``, ``#ifdef`` or ``#ifndef`` directive evaluates to false."
msgstr ""
"定義可選區塊，僅當上一個 ``#if``、``#elif``、``#ifdef`` 或 ``#ifndef`` 條件"
"為 false 時才包含之。"

msgid "#endif"
msgstr "#endif"

msgid "**Syntax:** ``#endif``"
msgstr "**語法：** ``#endif``"

msgid ""
"Used as terminator for the ``#if``, ``#ifdef``, ``#ifndef`` or subsequent "
"``#else`` directives."
msgstr "用於結束 ``#if``、``#ifdef``、``#ifndef`` 或後續 ``#else`` 指令。"

msgid "#error"
msgstr "#error"

msgid "**Syntax:** ``#error <message>``"
msgstr "**語法：** ``#error <訊息>``"

msgid ""
"The ``#error`` directive forces the preprocessor to emit an error with "
"optional message. For example, it's useful when used within ``#if`` block to "
"provide a strict limitation of the defined value."
msgstr ""
"``#error`` 指令會強制預處理器產生錯誤，可選擇輸出訊息。例如，可以在 ``#if`` "
"區塊中使用，對定義值設下嚴格限制時給予提示。"

msgid "#include"
msgstr "#include"

msgid "**Syntax:** ``#include \"path\"``"
msgstr "**語法：** ``#include \"路徑\"``"

msgid ""
"The ``#include`` directive includes the *entire* content of a shader include "
"file in a shader. ``\"path\"`` can be an absolute ``res://`` path or "
"relative to the current shader file. Relative paths are only allowed in "
"shaders that are saved to ``.gdshader`` or ``.gdshaderinc`` files, while "
"absolute paths can be used in shaders that are built into a scene/resource "
"file."
msgstr ""
"``#include`` 指令會把指定著色器包含檔案的*全部內容*插入著色器中。``\"路徑"
"\"`` 可以是絕對的 ``res://`` 路徑，或相對於目前著色器檔的路徑。相對路徑僅能用"
"在儲存為 ``.gdshader`` 或 ``.gdshaderinc`` 檔案的著色器中；內嵌於場景/資源檔"
"案的著色器則必須使用絕對路徑。"

msgid ""
"You can create new shader includes by using the **File > Create Shader "
"Include** menu option of the shader editor, or by creating a "
"new :ref:`ShaderInclude<class_ShaderInclude>` resource in the FileSystem "
"dock."
msgstr ""
"你可以透過著色器編輯器的 **檔案 > 建立著色器包含** 選單，或在檔案系統面板中建"
"立新的 :ref:`ShaderInclude<class_ShaderInclude>` 資源，來新增著色器包含檔案。"

msgid ""
"Shader includes can be included from within any shader, or other shader "
"include, at any point in the file."
msgstr "著色器包含檔可以在任何著色器或其他包含檔的任何位置被引用。"

msgid ""
"When including shader includes in the global scope of a shader, it is "
"recommended to do this after the initial ``shader_type`` statement."
msgstr "當在著色器全域範圍內引用包含檔時，建議放在 ``shader_type`` 敘述之後。"

msgid ""
"You can also include shader includes from within the body a function. Please "
"note that the shader editor is likely going to report errors for your shader "
"include's code, as it may not be valid outside of the context that it was "
"written for. You can either choose to ignore these errors (the shader will "
"still compile fine), or you can wrap the include in an ``#ifdef`` block that "
"checks for a define from your shader."
msgstr ""
"你也可以在函式內部引用著色器包含檔。不過請注意，著色器編輯器可能會對包含檔中"
"的程式碼顯示錯誤，因為該程式碼在原本的上下文以外可能不合法。你可以選擇忽略這"
"些錯誤（著色器仍然能正常編譯），或是將引用包在 ``#ifdef`` 區塊內，只在需要時"
"才導入。"

msgid ""
"``#include`` is useful for creating libraries of helper functions (or "
"macros) and reducing code duplication. When using ``#include``, be careful "
"about naming collisions, as redefining functions or macros is not allowed."
msgstr ""
"``#include`` 適合用來建立輔助函式（或巨集）庫並減少重複程式碼。使用時要小心命"
"名衝突，因為不允許重複定義函式或巨集。"

msgid "``#include`` is subject to several restrictions:"
msgstr "``#include`` 有幾項限制："

msgid ""
"Only shader include resources (ending with ``.gdshaderinc``) can be "
"included. ``.gdshader`` files cannot be included by another shader, but a "
"``.gdshaderinc`` file can include other ``.gdshaderinc`` files."
msgstr ""
"只能引用以 ``.gdshaderinc`` 結尾的著色器包含資源。``.gdshader`` 檔案不能被其"
"他著色器引用，但 ``.gdshaderinc`` 可以包含其他 ``.gdshaderinc`` 檔案。"

msgid "Cyclic dependencies are **not** allowed and will result in an error."
msgstr "不允許循環依賴，否則會導致錯誤。"

msgid "To avoid infinite recursion, include depth is limited to 25 steps."
msgstr "為避免無限遞迴，包含層數上限為 25。"

msgid "Example shader include file:"
msgstr "範例著色器包含檔："

msgid "Example base shader (using the include file we created above):"
msgstr "範例基礎著色器（引用了上方建立的包含檔）："

msgid "#pragma"
msgstr "#pragma"

msgid "**Syntax:** ``#pragma value``"
msgstr "**語法：** ``#pragma 值``"

msgid ""
"The ``#pragma`` directive provides additional information to the "
"preprocessor or compiler."
msgstr "``#pragma`` 指令可提供額外資訊給預處理器或編譯器。"

msgid ""
"Currently, it may have only one value: ``disable_preprocessor``. If you "
"don't need the preprocessor, use that directive to speed up shader "
"compilation by excluding the preprocessor step."
msgstr ""
"目前僅支援一個值：``disable_preprocessor``。如果你不需要預處理器，可加上該指"
"令來略過預處理步驟，加快著色器編譯。"

msgid "Built-in defines"
msgstr "內建定義"

msgid "Current renderer"
msgstr "目前使用的繪圖引擎"

msgid ""
"Since Godot 4.4, you can check which renderer is currently used with the "
"built-in defines ``CURRENT_RENDERER``, ``RENDERER_COMPATIBILITY``, "
"``RENDERER_MOBILE``, and ``RENDERER_FORWARD_PLUS``:"
msgstr ""
"自 Godot 4.4 起，你可以透過內建的 ``CURRENT_RENDERER``、"
"``RENDERER_COMPATIBILITY``、``RENDERER_MOBILE`` 與 ``RENDERER_FORWARD_PLUS`` "
"定義判斷目前使用的繪圖引擎："

msgid ""
"``CURRENT_RENDERER`` is set to either ``0``, ``1``, or ``2`` depending on "
"the current renderer."
msgstr "``CURRENT_RENDERER`` 會根據目前的渲染器設為 ``0``、``1`` 或 ``2``。"

msgid "``RENDERER_COMPATIBILITY`` is always ``0``."
msgstr "``RENDERER_COMPATIBILITY`` 永遠是 ``0``。"

msgid "``RENDERER_MOBILE`` is always ``1``."
msgstr "``RENDERER_MOBILE`` 永遠是 ``1``。"

msgid "``RENDERER_FORWARD_PLUS`` is always ``2``."
msgstr "``RENDERER_FORWARD_PLUS`` 永遠是 ``2``。"

msgid ""
"As an example, this shader sets ``ALBEDO`` to a different color in each "
"renderer:"
msgstr "舉例來說，這個著色器會根據不同繪圖引擎設定不同的 ``ALBEDO`` 顏色："
