#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shading language"
msgstr "著色語言"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godot 使用類似 GLSL ES 3.0 的著色語言。大多數資料型別與函式皆已支援，剩餘未支"
"援的型別和函式也有可能隨時間加入。"

msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""
"如果你已熟悉 GLSL，可以參考 :ref:`Godot 著色器遷移指南"
"<doc_converting_glsl_to_godot_shaders>`，協助你從標準 GLSL 轉換到 Godot 的著"
"色語言。"

msgid "Data types"
msgstr "資料型別"

msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "支援大多數 GLSL ES 3.0 資料型別："

msgid "Type"
msgstr "型別"

msgid "Description"
msgstr "說明"

msgid "**void**"
msgstr "**void**"

msgid "Void datatype, useful only for functions that return nothing."
msgstr "Void 資料型別，僅用於不回傳任何值的函式。"

msgid "**bool**"
msgstr "**bool**"

msgid "Boolean datatype, can only contain ``true`` or ``false``."
msgstr "布林資料型別，只能包含 ``true`` 或 ``false``。"

msgid "**bvec2**"
msgstr "**bvec2**"

msgid "Two-component vector of booleans."
msgstr "布林值的雙分量向量。"

msgid "**bvec3**"
msgstr "**bvec3**"

msgid "Three-component vector of booleans."
msgstr "布林值的三分量向量。"

msgid "**bvec4**"
msgstr "**bvec4**"

msgid "Four-component vector of booleans."
msgstr "布林值的四分量向量。"

msgid "**int**"
msgstr "**int**"

msgid "32 bit signed scalar integer."
msgstr "32 位元有符號標量整數。"

msgid "**ivec2**"
msgstr "**ivec2**"

msgid "Two-component vector of signed integers."
msgstr "有符號整數的雙分量向量。"

msgid "**ivec3**"
msgstr "**ivec3**"

msgid "Three-component vector of signed integers."
msgstr "有符號整數的三分量向量。"

msgid "**ivec4**"
msgstr "**ivec4**"

msgid "Four-component vector of signed integers."
msgstr "有符號整數的四分量向量。"

msgid "**uint**"
msgstr "**uint**"

msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr "無符號標量整數，不能包含負數。"

msgid "**uvec2**"
msgstr "**uvec2**"

msgid "Two-component vector of unsigned integers."
msgstr "無符號整數的雙分量向量。"

msgid "**uvec3**"
msgstr "**uvec3**"

msgid "Three-component vector of unsigned integers."
msgstr "無符號整數的三分量向量。"

msgid "**uvec4**"
msgstr "**uvec4**"

msgid "Four-component vector of unsigned integers."
msgstr "無符號整數的四分量向量。"

msgid "**float**"
msgstr "**float**"

msgid "32 bit floating-point scalar."
msgstr "32 位元浮點標量。"

msgid "**vec2**"
msgstr "**vec2**"

msgid "Two-component vector of floating-point values."
msgstr "浮點值的雙分量向量。"

msgid "**vec3**"
msgstr "**vec3**"

msgid "Three-component vector of floating-point values."
msgstr "浮點值的三分量向量。"

msgid "**vec4**"
msgstr "**vec4**"

msgid "Four-component vector of floating-point values."
msgstr "浮點值的四分量向量。"

msgid "**mat2**"
msgstr "**mat2**"

msgid "2x2 matrix, in column major order."
msgstr "2x2 矩陣，以 column-major（欄主序）排列。"

msgid "**mat3**"
msgstr "**mat3**"

msgid "3x3 matrix, in column major order."
msgstr "3x3 矩陣，以 column-major（欄主序）排列。"

msgid "**mat4**"
msgstr "**mat4**"

msgid "4x4 matrix, in column major order."
msgstr "4x4 矩陣，以 column-major（欄主序）排列。"

msgid "**sampler2D**"
msgstr "**sampler2D**"

msgid "Sampler type for binding 2D textures, which are read as float."
msgstr "用於綁定 2D 紋理的取樣器型別，以 float 讀取。"

msgid "**isampler2D**"
msgstr "**isampler2D**"

msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr "用於綁定 2D 紋理的取樣器型別，以有符號整數讀取。"

msgid "**usampler2D**"
msgstr "**usampler2D**"

msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr "用於綁定 2D 紋理的取樣器型別，以無符號整數讀取。"

msgid "**sampler2DArray**"
msgstr "**sampler2DArray**"

msgid "Sampler type for binding 2D texture arrays, which are read as float."
msgstr "用於綁定 2D 紋理陣列的取樣器型別，以 float 讀取。"

msgid "**isampler2DArray**"
msgstr "**isampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as signed integer."
msgstr "用於綁定 2D 紋理陣列的取樣器型別，以有符號整數讀取。"

msgid "**usampler2DArray**"
msgstr "**usampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as unsigned "
"integer."
msgstr "用於綁定 2D 紋理陣列的取樣器型別，以無符號整數讀取。"

msgid "**sampler3D**"
msgstr "**sampler3D**"

msgid "Sampler type for binding 3D textures, which are read as float."
msgstr "用於綁定 3D 紋理的取樣器型別，以 float 讀取。"

msgid "**isampler3D**"
msgstr "**isampler3D**"

msgid "Sampler type for binding 3D textures, which are read as signed integer."
msgstr "用於綁定 3D 紋理的取樣器型別，以有符號整數讀取。"

msgid "**usampler3D**"
msgstr "**usampler3D**"

msgid ""
"Sampler type for binding 3D textures, which are read as unsigned integer."
msgstr "用於綁定 3D 紋理的取樣器型別，以無符號整數讀取。"

msgid "**samplerCube**"
msgstr "**samplerCube**"

msgid "Sampler type for binding Cubemaps, which are read as float."
msgstr "用於綁定立方體貼圖的取樣器型別，以 float 讀取。"

msgid "**samplerCubeArray**"
msgstr "**samplerCubeArray**"

msgid ""
"Sampler type for binding Cubemap arrays, which are read as float. Only "
"supported in Forward+ and Mobile, not Compatibility."
msgstr ""
"用於綁定立方體貼圖陣列的取樣器型別，以 float 讀取。僅 Forward+ 與 Mobile 支"
"援，不相容於 Compatibility。"

msgid "**samplerExternalOES**"
msgstr "**samplerExternalOES**"

msgid ""
"External sampler type. Only supported in Compatibility/Android platform."
msgstr "外部取樣器型別。僅支援於 Compatibility/Android 平台。"

msgid ""
"Local variables are not initialized to a default value such as ``0.0``. If "
"you use a variable without assigning it first, it will contain whatever "
"value was already present at that memory location, and unpredictable visual "
"glitches will appear. However, uniforms and varyings are initialized to a "
"default value."
msgstr ""
"區域變數不會自動初始化為像是 ``0.0`` 這種預設值。如果你在賦值前就使用變數，它"
"將包含記憶體中原本的隨機值，這會導致不可預期的視覺異常。然而，uniform 與 "
"varying 會自動初始化為預設值。"

msgid "Comments"
msgstr "注釋"

msgid ""
"The shading language supports the same comment syntax as used in C# and C++, "
"using ``//`` for single-line comments and ``/* */`` for multi-line comments:"
msgstr ""
"著色語言支援與 C# 和 C++ 相同的註解語法，單行註解使用 ``//``，多行註解則使用 "
"``/* */``："

msgid ""
"Additionally, you can use documentation comments that are displayed in the "
"inspector when hovering a shader parameter. Documentation comments are "
"currently only supported when placed immediately above a ``uniform`` "
"declaration. These documentation comments only support the **multiline** "
"comment syntax and must use **two** leading asterisks (``/**``) instead of "
"just one (``/*``):"
msgstr ""
"此外，你可以使用說明註解，當游標懸停在著色器參數上時會顯示於屬性檢視器中。說"
"明註解目前僅支援放在 ``uniform`` 宣告的正上方。這些註解僅支援**多行**註解語"
"法，且必須以**兩個**星號（``/**``）開頭，而不是一個（``/*``）："

msgid ""
"The asterisks on the follow-up lines are not required, but are recommended "
"as per the :ref:`doc_shaders_style_guide`. These asterisks are automatically "
"stripped by the inspector, so they won't appear in the tooltip."
msgstr ""
"根據 :ref:`doc_shaders_style_guide`，後續行的星號不是必要的，但建議加上。這些"
"星號會自動被屬性檢視器去除，因此不會出現在提示中。"

msgid "Casting"
msgstr "型別轉換"

msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""
"就像 GLSL ES 3.0 一樣，不允許在相同大小但不同型別的標量與向量間進行隱式轉型，"
"也不允許不同大小的型別之間轉型。必須透過建構子明確進行型別轉換。"

msgid "Example:"
msgstr "範例："

msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr "預設的整數常數為有符號，因此轉換成無符號時必須進行型別轉換："

msgid "Members"
msgstr "成員"

msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""
"向量型別的每個標量成員可以透過 \"x\"、\"y\"、\"z\" 和 \"w\" 存取。也可以用 "
"\"r\"、\"g\"、\"b\"、\"a\"，效果相同。請依需求選用。"

msgid ""
"For matrices, use the ``m[column][row]`` indexing syntax to access each "
"scalar, or ``m[column]`` to access a vector by column index. For example, "
"for accessing the y-component of the translation from a mat4 transform "
"matrix (4th column, 2nd line) you use ``m[3][1]`` or ``m[3].y``."
msgstr ""
"對於矩陣，請使用 ``m[欄][列]`` 索引語法來存取每個標量，或用 ``m[欄]`` 來取得"
"對應欄的向量。例如，要取得 mat4 轉換矩陣的平移 y 分量（第 4 欄，第 2 行），可"
"以寫 ``m[3][1]`` 或 ``m[3].y``。"

msgid "Constructing"
msgstr "建構"

msgid "Construction of vector types must always pass:"
msgstr "建構向量型別時必須傳入："

msgid ""
"Construction of matrix types requires vectors of the same dimension as the "
"matrix, interpreted as columns. You can also build a diagonal matrix using "
"``matx(float)`` syntax. Accordingly, ``mat4(1.0)`` is an identity matrix."
msgstr ""
"建構矩陣型別時，必須傳入與矩陣維度相同的向量（視為欄）。也可用 "
"``matx(float)`` 語法建立對角矩陣。例如 ``mat4(1.0)`` 就是單位矩陣（identity "
"matrix）。"

msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules:"
msgstr "矩陣也可以由其他維度的矩陣建構。有兩個規則："

msgid ""
"1. If a larger matrix is constructed from a smaller matrix, the additional "
"rows and columns are set to the values they would have in an identity "
"matrix. 2. If a smaller matrix is constructed from a larger matrix, the top, "
"left submatrix of the larger matrix is used."
msgstr ""
"1. 若從較小矩陣建構較大矩陣，新增的行列會以單位矩陣的值補齊。2. 若從較大矩陣"
"建構較小矩陣，則取用原始矩陣左上角對應的子矩陣。"

msgid "Swizzling"
msgstr "分量混寫（Swizzling）"

msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""
"你可以用任何順序組合向量的分量，只要結果也是向量型別（或標量）即可。範例如"
"下："

msgid "Precision"
msgstr "精度"

msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr "可以為資料型別加上精度修飾詞，適用於 uniform、變數、參數和 varying："

msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""
"部分運算若使用較低精度，能提升效能（但精度會下降）。頂點處理器通常需高精度，"
"比較少用低精度，但片段處理器則經常可以這樣做。"

msgid ""
"Some architectures (mainly mobile) can benefit significantly from this, but "
"there are downsides such as the additional overhead of conversion between "
"precisions. Refer to the documentation of the target architecture for "
"further information. In many cases, mobile drivers cause inconsistent or "
"unexpected behavior and it is best to avoid specifying precision unless "
"necessary."
msgstr ""
"某些架構（主要是行動平台）這樣做能有明顯效益，但不同精度之間轉換會有額外負"
"擔。請參閱目標平台的文件以獲取詳情。許多行動平台驅動可能會導致不一致或不可預"
"期的行為，除非有必要，否則建議避免額外指定精度。"

msgid "Arrays"
msgstr "陣列"

msgid "Arrays are containers for multiple variables of a similar type."
msgstr "陣列是用於儲存多個相同型別變數的容器。"

msgid "Local arrays"
msgstr "區域陣列"

msgid ""
"Local arrays are declared in functions. They can use all of the allowed "
"datatypes, except samplers. The array declaration follows a C-style syntax: "
"``[const] + [precision] + typename + identifier + [array size]``."
msgstr ""
"區域陣列需在函式內宣告。可使用所有允許的資料型別（取樣器除外）。陣列宣告語法"
"類似 C 語言：``[const] + [precision] + typename + identifier + [array "
"size]``。"

msgid "They can be initialized at the beginning like:"
msgstr "可以在宣告時直接初始化，例如："

msgid ""
"You can declare multiple arrays (even with different sizes) in one "
"expression:"
msgstr "也可以在一行宣告多個（不同大小也可以）："

msgid "To access an array element, use the indexing syntax:"
msgstr "要存取陣列元素，請使用索引語法："

msgid ""
"Arrays also have a built-in function ``.length()`` (not to be confused with "
"the built-in ``length()`` function). It doesn't accept any parameters and "
"will return the array's size."
msgstr ""
"陣列有一個內建函式 ``.length()``（請勿與全域 ``length()`` 函式混淆）。它不接"
"受參數，會回傳陣列大小。"

msgid ""
"If you use an index either below 0 or greater than array size - the shader "
"will crash and break rendering. To prevent this, use ``length()``, ``if``, "
"or ``clamp()`` functions to ensure the index is between 0 and the array's "
"length. Always carefully test and check your code. If you pass a constant "
"expression or a number, the editor will check its bounds to prevent this "
"crash."
msgstr ""
"如果你使用小於 0 或超過陣列大小的索引，著色器將當機並導致渲染失敗。請使用 "
"``length()``、``if`` 或 ``clamp()`` 來保證索引合法。務必仔細測試和檢查你的程"
"式碼。若索引是常數，編輯器會自動檢查界限避免當機。"

msgid "Global arrays"
msgstr "全域陣列"

msgid ""
"You can declare arrays in global space as either ``const`` or ``uniform``:"
msgstr "你可以在全域範圍宣告陣列為 ``const`` 或 ``uniform``："

msgid ""
"Global arrays use the same syntax as local arrays, except with a ``const`` "
"or ``uniform`` added to their declaration. Note that uniform arrays can't "
"have a default value."
msgstr ""
"全域陣列語法與區域陣列相同，只是在前面加上 ``const`` 或 ``uniform``。注意 "
"uniform 陣列不能有預設值。"

msgid "Constants"
msgstr "常數"

msgid ""
"Use the ``const`` keyword before the variable declaration to make that "
"variable immutable, which means that it cannot be modified. All basic types, "
"except samplers can be declared as constants. Accessing and using a constant "
"value is slightly faster than using a uniform. Constants must be initialized "
"at their declaration."
msgstr ""
"在變數宣告前加上 ``const`` 關鍵字，該變數就會成為不可變（immutable），也就是"
"無法被修改。所有基本型別（取樣器除外）都可以宣告為常數。存取常數比 uniform 略"
"快。常數必須在宣告時初始化。"

msgid ""
"Constants cannot be modified and additionally cannot have hints, but "
"multiple of them (if they have the same type) can be declared in a single "
"expression e.g"
msgstr ""
"常數不可修改，也不能加提示，但相同型別的多個常數可以在同一行宣告，例如："

msgid "Similar to variables, arrays can also be declared with ``const``."
msgstr "陣列也可以像變數一樣用 ``const`` 宣告為常數。"

msgid ""
"Constants can be declared both globally (outside of any function) or locally "
"(inside a function). Global constants are useful when you want to have "
"access to a value throughout your shader that does not need to be modified. "
"Like uniforms, global constants are shared between all shader stages, but "
"they are not accessible outside of the shader."
msgstr ""
"常數既可在全域（任何函式外）也可在區域（函式內）宣告。當你需要在整個著色器中"
"使用且不需更動的值時，全域常數很實用。與 uniform 類似，全域常數會在所有著色器"
"階段共用，但無法在著色器外部存取。"

msgid ""
"Constants of the ``float`` type must be initialized using ``.`` notation "
"after the decimal part or by using the scientific notation. The optional "
"``f`` post-suffix is also supported."
msgstr ""
"``float`` 型別的常數必須以小數點（如 1.0）或科學記號初始化，也支援可選的 "
"``f`` 後綴。"

msgid ""
"Constants of the ``uint`` (unsigned int) type must have a ``u`` suffix to "
"differentiate them from signed integers. Alternatively, this can be done by "
"using the ``uint(x)`` built-in conversion function."
msgstr ""
"``uint``（無符號整數）型別的常數必須加上 ``u`` 後綴以區分有符號整數。也可以"
"用 ``uint(x)`` 內建轉換函式。"

msgid "Structs"
msgstr "結構（Structs）"

msgid ""
"Structs are compound types which can be used for better abstraction of "
"shader code. You can declare them at the global scope like:"
msgstr ""
"結構（struct）是一種複合型別，可用來讓著色器程式碼更具抽象性。你可以在全域範"
"圍宣告結構："

msgid "After declaration, you can instantiate and initialize them like:"
msgstr "宣告後，你可以這樣初始化實體："

msgid "Or use struct constructor for same purpose:"
msgstr "也可以直接用結構建構子來初始化："

msgid ""
"Structs may contain other struct or array, you can also instance them as "
"global constant:"
msgstr "結構可以包含其他結構或陣列，也可以宣告為全域常數："

msgid "You can also pass them to functions:"
msgstr "也可以將結構作為參數傳入函式："

msgid "Operators"
msgstr "運算子"

msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""
"Godot 著色語言支援與 GLSL ES 3.0 相同的運算子。以下為運算子優先順序列表："

msgid "Precedence"
msgstr "優先順序"

msgid "Class"
msgstr "類別"

msgid "Operator"
msgstr "運算子"

msgid "1 (highest)"
msgstr "1（最高）"

msgid "parenthetical grouping"
msgstr "括號分組"

msgid "**()**"
msgstr "**()**"

msgid "2"
msgstr "2"

msgid "unary"
msgstr "單元運算"

msgid "**+, -, !, ~**"
msgstr "**+, -, !, ~**"

msgid "3"
msgstr "3"

msgid "multiplicative"
msgstr "乘除法"

msgid "**/, \\*, %**"
msgstr "**/, *, %**"

msgid "4"
msgstr "4"

msgid "additive"
msgstr "加減法"

msgid "**+, -**"
msgstr "**+, -**"

msgid "5"
msgstr "5"

msgid "bit-wise shift"
msgstr "位元移位"

msgid "**<<, >>**"
msgstr "**<<, >>**"

msgid "6"
msgstr "6"

msgid "relational"
msgstr "關係運算"

msgid "**<, >, <=, >=**"
msgstr "**<, >, <=, >=**"

msgid "7"
msgstr "7"

msgid "equality"
msgstr "等值比較"

msgid "**==, !=**"
msgstr "**==, !=**"

msgid "8"
msgstr "8"

msgid "bit-wise AND"
msgstr "位元 AND"

msgid "**&**"
msgstr "**&**"

msgid "9"
msgstr "9"

msgid "bit-wise exclusive OR"
msgstr "位元 XOR（異或）"

msgid "**^**"
msgstr "**^**"

msgid "10"
msgstr "10"

msgid "bit-wise inclusive OR"
msgstr "位元 OR（或）"

msgid "**|**"
msgstr "**|**"

msgid "11"
msgstr "11"

msgid "logical AND"
msgstr "邏輯 AND"

msgid "**&&**"
msgstr "**&&**"

msgid "12 (lowest)"
msgstr "12（最低）"

msgid "logical inclusive OR"
msgstr "邏輯 OR"

msgid "**||**"
msgstr "**||**"

msgid ""
"Most operators that accept vectors or matrices (multiplication, division, "
"etc) operate component-wise, meaning the function is applied to the first "
"value of each vector and then on the second value of each vector, etc. Some "
"examples:"
msgstr ""
"大多數接受向量或矩陣的運算子（如乘法、除法等）都會對各分量分別運算，即對每個"
"分量獨立執行該運算。舉例如下："

msgid "Operation"
msgstr "運算"

msgid "Equivalent Scalar Operation"
msgstr "等價標量運算"

msgid "``vec3(4, 5, 6) + 2``"
msgstr "``vec3(4, 5, 6) + 2``"

msgid "``vec3(4 + 2, 5 + 2, 6 + 2)``"
msgstr "``vec3(4 + 2, 5 + 2, 6 + 2)``"

msgid "``vec2(3, 4) * vec2(10, 20)``"
msgstr "``vec2(3, 4) * vec2(10, 20)``"

msgid "``vec2(3 * 10, 4 * 20)``"
msgstr "``vec2(3 * 10, 4 * 20)``"

msgid "``mat2(vec2(1, 2), vec2(3, 4)) + 10``"
msgstr "``mat2(vec2(1, 2), vec2(3, 4)) + 10``"

msgid "``mat2(vec2(1 + 10, 2 + 10), vec2(3 + 10, 4 + 10))``"
msgstr "``mat2(vec2(1 + 10, 2 + 10), vec2(3 + 10, 4 + 10))``"

msgid ""
"The `GLSL Language Specification <http://www.opengl.org/registry/doc/"
"GLSLangSpec.4.30.6.pdf>`_ says under section 5.10 Vector and Matrix "
"Operations:"
msgstr ""
"依據 `GLSL 語言規範 <http://www.opengl.org/registry/doc/"
"GLSLangSpec.4.30.6.pdf>`_ 第 5.10 節（向量與矩陣運算）說明："

msgid ""
"With a few exceptions, operations are component-wise. Usually, when an "
"operator operates on a vector or matrix, it is operating independently on "
"each component of the vector or matrix, in a component-wise fashion. [...] "
"The exceptions are matrix multiplied by vector, vector multiplied by matrix, "
"and matrix multiplied by matrix. These do not operate component-wise, but "
"rather perform the correct linear algebraic multiply."
msgstr ""
"除少數例外，運算皆以分量為單位執行。通常，當運算子用於向量或矩陣時，會對每個"
"分量分別運算。[...] 例外情況為：矩陣乘以向量、向量乘以矩陣、及矩陣乘以矩陣。"
"這些情況不按分量運算，而是進行正確的線性代數乘法。"

msgid "Flow control"
msgstr "流程控制"

msgid "Godot Shading language supports the most common types of flow control:"
msgstr "Godot 著色語言支援常用的流程控制語句："

msgid ""
"Keep in mind that in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""
"請注意，在現代 GPU 上，無窮迴圈可能導致應用程式（包含編輯器）當機。Godot 無法"
"保護你不受此影響，請務必避免這種錯誤！"

msgid ""
"Also, when comparing floating-point values against a number, make sure to "
"compare them against a *range* instead of an exact number."
msgstr "此外，比較浮點數時，請務必與「*範圍*」做比較，而非直接比對精確數值。"

msgid ""
"A comparison like ``if (value == 0.3)`` may not evaluate to ``true``. "
"Floating-point math is often approximate and can defy expectations. It can "
"also behave differently depending on the hardware."
msgstr ""
"像 ``if (value == 0.3)`` 這樣的比較可能不會等於 ``true``。浮點運算常有誤差，"
"結果可能不如你預期，不同硬體上的表現也可能不同。"

msgid "**Don't** do this."
msgstr "**切勿** 這樣寫。"

msgid ""
"Instead, always perform a range comparison with an epsilon value. The larger "
"the floating-point number (and the less precise the floating-point number), "
"the larger the epsilon value should be."
msgstr ""
"請改用 epsilon（誤差容許值）進行範圍比較。數字越大，或浮點精度越低，epsilon "
"應設得越大。"

msgid ""
"See `floating-point-gui.de <https://floating-point-gui.de/>`__ for more "
"information."
msgstr ""
"如需更多資訊，請參考：`floating-point-gui.de <https://floating-point-gui.de/"
">`__ 。"

msgid "Discarding"
msgstr "丟棄（Discard）"

msgid ""
"Fragment, light, and custom functions (called from fragment or light) can "
"use the ``discard`` keyword. If used, the fragment is discarded and nothing "
"is written."
msgstr ""
"片段（fragment）、光源（light）以及由 fragment 或 light 呼叫的自訂函式中，可"
"以使用 ``discard`` 關鍵字。使用時，該片段會被丟棄，不會寫入任何資料。"

msgid ""
"Beware that ``discard`` has a performance cost when used, as it will prevent "
"the depth prepass from being effective on any surfaces using the shader. "
"Also, a discarded pixel still needs to be rendered in the vertex shader, "
"which means a shader that uses ``discard`` on all of its pixels is still "
"more expensive to render compared to not rendering any object in the first "
"place."
msgstr ""
"請注意，使用 ``discard`` 會有效能損耗，因為這會讓使用此著色器的表面無法執行深"
"度預處理。被丟棄的像素頂點仍需經過頂點著色器運算，因此如果所有像素都用 "
"``discard``，其渲染成本仍然高於完全不渲染。"

msgid "Functions"
msgstr "函式"

msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr "你可以在 Godot 著色器中自訂函式。語法如下："

msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them. Redefining a function "
"that has already been defined above (or is a built-in function name) will "
"cause an error."
msgstr ""
"只能呼叫已在前面（編輯器中較上方）定義過的函式。若重複定義同名函式（或與內建"
"函式同名），將會發生錯誤。"

msgid "Function arguments can have special qualifiers:"
msgstr "函式參數可以有特殊修飾詞："

msgid "**in**: Means the argument is only for reading (default)."
msgstr "**in**：參數僅供讀取（預設）。"

msgid "**out**: Means the argument is only for writing."
msgstr "**out**：參數僅供寫入。"

msgid "**inout**: Means the argument is fully passed via reference."
msgstr "**inout**：參數以參考（reference）方式傳遞，可讀可寫。"

msgid ""
"**const**: Means the argument is a constant and cannot be changed, may be "
"combined with **in** qualifier."
msgstr "**const**：參數為常數，無法修改，可與 **in** 一起使用。"

msgid "Example below:"
msgstr "範例如下："

msgid ""
"Function overloading is supported. You can define multiple functions with "
"the same name, but different arguments. Note that `implicit casting "
"<Casting_>`_ in overloaded function calls is not allowed, such as from "
"``int`` to ``float`` (``1`` to ``1.0``)."
msgstr ""
"支援函式多載（overloading）。你可以定義多個同名但參數不同的函式。注意，多載呼"
"叫時不支援 `隱式型別轉換 <Casting>`_ ，例如 ``int`` 轉 ``float`` （ ``1`` 不"
"能自動變成 ``1.0`` ）。"

msgid "Varyings"
msgstr "Varying（變量）"

msgid ""
"To send data from the vertex to the fragment (or light) processor function, "
"*varyings* are used. They are set for every primitive vertex in the *vertex "
"processor*, and the value is interpolated for every pixel in the *fragment "
"processor*."
msgstr ""
"若要將資料從頂點處理器傳遞到片段（或光源）處理器，請使用 *varying*。在頂點處"
"理器中，每個基本頂點都設定了 varying，然後在片段處理器中針對每個像素進行插"
"值。"

msgid "Varying can also be an array:"
msgstr "Varying 也可以宣告為陣列："

msgid ""
"It's also possible to send data from *fragment* to *light* processors using "
"*varying* keyword. To do so you can assign it in the *fragment* and later "
"use it in the *light* function."
msgstr ""
"你也可以用 *varying* 關鍵字，將資料從 *fragment* 傳到 *light* 處理器。在 "
"*fragment* 中賦值，之後在 *light* 函式中使用即可。"

msgid ""
"Note that varying may not be assigned in custom functions or a *light "
"processor* function like:"
msgstr "注意，varying 不能在自訂函式或 *light* 處理器中直接賦值，例如："

msgid ""
"This limitation was introduced to prevent incorrect usage before "
"initialization."
msgstr "這項限制是為了避免初始化前的不正確用法。"

msgid "Interpolation qualifiers"
msgstr "插值修飾詞"

msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr "著色管線中某些值會被插值。你可以用 *插值修飾詞* 來調整插值方式。"

msgid "There are two possible interpolation qualifiers:"
msgstr "目前有兩種插值修飾詞："

msgid "Qualifier"
msgstr "修飾詞"

msgid "**flat**"
msgstr "**flat**"

msgid "The value is not interpolated."
msgstr "該值不進行插值。"

msgid "**smooth**"
msgstr "**smooth**"

msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr "該值以透視修正的方式進行插值（預設）。"

msgid "Uniforms"
msgstr "Uniform（統一變數）"

msgid ""
"Passing values to shaders is possible with *uniforms*, which are defined in "
"the global scope of the shader, outside of functions. When a shader is later "
"assigned to a material, the uniforms will appear as editable parameters in "
"the material's inspector. Uniforms can't be written from within the shader. "
"Any :ref:`data type <doc_shading_language_data_types>` except for ``void`` "
"can be a uniform."
msgstr ""
"你可以用 *uniform* （統一變量）將資料傳入著色器，uniform 必須在著色器全域範圍"
"（函式外）宣告。當著色器指派給材質時，uniform 會出現在材質屬性視窗中，可供編"
"輯。uniform 不能在著色器內部寫入。除了 ``void`` 以外，任何 :ref:`資料型別 "
"<doc_shading_language_data_types>` 都可宣告為 uniform。"

msgid ""
"You can set uniforms in the editor in the material's inspector. Alternately, "
"you can set them :ref:`from code "
"<doc_shading_language_setting_uniforms_from_code>`."
msgstr ""
"你可以在編輯器的材質屬性檢視器中設定 uniform，或是 :ref:`透過程式碼 "
"<doc_shading_language_setting_uniforms_from_code>` 設定。"

msgid "Uniform hints"
msgstr "Uniform 提示"

msgid ""
"Godot provides optional uniform hints to make the compiler understand what "
"the uniform is used for, and how the editor should allow users to modify it."
msgstr ""
"Godot 提供可選的 uniform 提示，有助於編譯器了解 uniform 的用途，並讓編輯器決"
"定如何讓使用者調整其值。"

msgid "Uniforms can also be assigned default values:"
msgstr "Uniform 也可以設定預設值："

msgid ""
"Note that when adding a default value and a hint, the default value goes "
"after the hint."
msgstr "注意：當同時有預設值與提示時，預設值必須寫在提示之後。"

msgid "Full list of uniform hints below:"
msgstr "完整的 uniform 提示如下："

msgid "Hint"
msgstr "提示"

msgid "**vec3, vec4**"
msgstr "**vec3, vec4**"

msgid "source_color"
msgstr "source_color"

msgid "Used as color."
msgstr "作為顏色使用。"

msgid "hint_enum(\"String1\", \"String2\")"
msgstr "hint_enum(\"String1\", \"String2\")"

msgid "Displays int input as a dropdown widget in the editor."
msgstr "將 int 輸入顯示為下拉選單。"

msgid "**int, float**"
msgstr "**int, float**"

msgid "hint_range(min, max[, step])"
msgstr "hint_range(min, max[, step])"

msgid "Restricted to values in a range (with min/max/step)."
msgstr "限制為指定範圍內的值（最小/最大/步進）。"

msgid "Used as albedo color."
msgstr "作為反照率顏色使用。"

msgid "hint_normal"
msgstr "hint_normal"

msgid "Used as normalmap."
msgstr "作為法線貼圖使用。"

msgid "hint_default_white"
msgstr "hint_default_white"

msgid "As value or albedo color, default to opaque white."
msgstr "作為數值或反照率顏色時，預設為不透明白色。"

msgid "hint_default_black"
msgstr "hint_default_black"

msgid "As value or albedo color, default to opaque black."
msgstr "作為數值或反照率顏色時，預設為不透明黑色。"

msgid "hint_default_transparent"
msgstr "hint_default_transparent"

msgid "As value or albedo color, default to transparent black."
msgstr "作為數值或反照率顏色時，預設為透明黑色。"

msgid "hint_anisotropy"
msgstr "hint_anisotropy"

msgid "As flowmap, default to right."
msgstr "作為 flowmap 使用，預設朝右。"

msgid "hint_roughness[_r, _g, _b, _a, _normal, _gray]"
msgstr "hint_roughness[_r, _g, _b, _a, _normal, _gray]"

msgid ""
"Used for roughness limiter on import (attempts reducing specular aliasing). "
"``_normal`` is a normal map that guides the roughness limiter, with "
"roughness increasing in areas that have high-frequency detail."
msgstr ""
"用於匯入時的粗糙度限制器（用於減少高光鋸齒）。``_normal`` 代表法線貼圖，可導"
"引粗糙度限制器，在高頻細節區域增加粗糙度。"

msgid "filter[_nearest, _linear][_mipmap][_anisotropic]"
msgstr "filter[_nearest, _linear][_mipmap][_anisotropic]"

msgid "Enabled specified texture filtering."
msgstr "啟用指定的紋理過濾模式。"

msgid "repeat[_enable, _disable]"
msgstr "repeat[_enable, _disable]"

msgid "Enabled texture repeating."
msgstr "啟用紋理重複。"

msgid "hint_screen_texture"
msgstr "hint_screen_texture"

msgid "Texture is the screen texture."
msgstr "這個紋理為螢幕紋理。"

msgid "hint_depth_texture"
msgstr "hint_depth_texture"

msgid "Texture is the depth texture."
msgstr "這個紋理為深度紋理。"

msgid "hint_normal_roughness_texture"
msgstr "hint_normal_roughness_texture"

msgid "Texture is the normal roughness texture (only supported in Forward+)."
msgstr "這個紋理為 normal roughness 紋理（僅 Forward+ 支援）。"

msgid "Using ``hint_enum``"
msgstr "使用 ``hint_enum``"

msgid ""
"You can access ``int`` values as a readable dropdown widget using the "
"``hint_enum`` uniform:"
msgstr "你可以利用 ``hint_enum`` 讓 int 變數在編輯器中以可讀的下拉選單顯示："

msgid ""
"You can assign explicit values to the ``hint_enum`` uniform using colon "
"syntax similar to GDScript:"
msgstr ""
"你也可以用類似 GDScript 的冒號語法，為 ``hint_enum`` uniform 指定明確的數值："

msgid ""
"The value will be stored as an integer, corresponding to the index of the "
"selected option (i.e. ``0``, ``1``, or ``2``) or the value assigned by colon "
"syntax (i.e. ``30``, ``60``, or ``200``). When setting the value with "
"``set_shader_parameter()``, you must use the integer value, not the "
"``String`` name."
msgstr ""
"這個值會以整數形式儲存，對應到選項的索引（如 ``0``、``1``、``2``）或用冒號語"
"法指定的值（如 ``30``、``60``、``200``）。用 ``set_shader_parameter()`` 設定"
"時必須用整數值，不能用字串名稱。"

msgid "Using ``source_color``"
msgstr "使用 ``source_color``"

msgid ""
"Any texture which contains *sRGB color data* requires a ``source_color`` "
"hint in order to be correctly sampled. This is because Godot renders in "
"linear color space, but some textures contain sRGB color data. If this hint "
"is not used, the texture will appear washed out."
msgstr ""
"任何包含 *sRGB 色彩資料* 的紋理都必須加上 ``source_color`` 提示，才能正確取"
"樣。因為 Godot 採用線性色彩空間算繪，但有些紋理本身為 sRGB 色彩資料。如果沒有"
"這個提示，紋理顏色會看起來偏灰、失真。"

msgid ""
"Albedo and color textures should typically have a ``source_color`` hint. "
"Normal, roughness, metallic, and height textures typically do not need a "
"``source_color`` hint."
msgstr ""
"albedo 與色彩紋理通常應加上 ``source_color`` 提示。法線、粗糙度、金屬度與高度"
"紋理通常不需 ``source_color``。"

msgid ""
"Using ``source_color`` hint is required in the Forward+ and Mobile "
"renderers, and in ``canvas_item`` shaders when :ref:`HDR "
"2D<class_ProjectSettings_property_rendering/viewport/hdr_2d>` is enabled. "
"The ``source_color`` hint is optional for the Compatibility renderer, and "
"for ``canvas_item`` shaders if ``HDR 2D`` is disabled. However, it is "
"recommended to always use the ``source_color`` hint, because it works even "
"if you change renderers or disable ``HDR 2D``."
msgstr ""
"在 Forward+ 與 Mobile 渲染器下，以及 ``canvas_item`` 著色器啟用 :ref:`HDR "
"2D<class_ProjectSettings_property_rendering/viewport/hdr_2d>` 時，必須加上 "
"``source_color``。如果是 Compatibility 渲染器，或 ``canvas_item`` 未啟用 HDR "
"2D 則為選擇性。但建議一律使用 ``source_color``，即使未來切換渲染器或 HDR 2D "
"狀態都不會有色彩問題。"

msgid "Uniform groups"
msgstr "Uniform 分組"

msgid ""
"To group multiple uniforms in a section in the inspector, you can use a "
"``group_uniform`` keyword like this:"
msgstr ""
"如果你想要在屬性檢視器將多個 uniform 分組顯示，可以用 ``group_uniform`` 關鍵"
"字，例如："

msgid "You can close the group by using:"
msgstr "你可以用如下語法結束該分組："

msgid ""
"The syntax also supports subgroups (it's not mandatory to declare the base "
"group before this):"
msgstr "這個語法也支援子分組（不必先宣告父分組）："

msgid "Global uniforms"
msgstr "全域 uniform"

msgid ""
"Sometimes, you want to modify a parameter in many different shaders at once. "
"With a regular uniform, this takes a lot of work as all these shaders need "
"to be tracked and the uniform needs to be set for each of them. Global "
"uniforms allow you to create and update uniforms that will be available in "
"all shaders, in every shader type (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` and ``fog``)."
msgstr ""
"有時你會想要一次修改多個著色器的參數。如果用一般 uniform，必須逐一設定所有著"
"色器，非常麻煩。全域 uniform 可讓你建立可在所有著色器、所有型別（如 "
"``canvas_item``、``spatial``、``particles``、``sky``、``fog``）共用的 "
"uniform 變數。"

msgid ""
"Global uniforms are especially useful for environmental effects that affect "
"many objects in a scene, like having foliage bend when the player is nearby, "
"or having objects move with the wind."
msgstr ""
"全域 uniform 特別適合需要同時影響場景多個物件的環境特效，例如玩家靠近時所有樹"
"葉彎曲，或物件隨風搖曳等。"

msgid ""
"*Global uniforms* are not the same as *global scope* for an individual "
"shader. While regular uniforms are defined outside of shader functions and "
"are therefore the global scope of the shader, global uniforms are global to "
"all shaders in the entire project (but within each shader, are also in the "
"global scope)."
msgstr ""
"*全域 uniform* 與單一著色器的 *全域範圍* 不同。一般 uniform 只是在著色器內的"
"全域範圍，而全域 uniform 則是整個專案所有著色器都能取得的全域變數。"

msgid ""
"To create a global uniform, open the **Project Settings** then go to the "
"**Shader Globals** tab. Specify a name for the uniform (case-sensitive) and "
"a type, then click **Add** in the top-right corner of the dialog. You can "
"then edit the value assigned to the uniform by clicking the value in the "
"list of uniforms:"
msgstr ""
"要建立全域 uniform，請開啟 **專案設定**，切換到 **Shader Globals** 標籤。輸"
"入 uniform 名稱（區分大小寫）及型別，然後點選對話框右上角的 **新增**。接著即"
"可在 uniform 列表點擊並編輯其值："

msgid ""
"Adding a global uniform in the Shader Globals tab of the Project Settings"
msgstr "在專案設定的 Shader Globals 標籤新增全域 uniform"

msgid "After creating a global uniform, you can use it in a shader as follows:"
msgstr "建立全域 uniform 後，可以在著色器中這樣使用："

msgid ""
"Note that the global uniform *must* exist in the Project Settings at the "
"time the shader is saved, or compilation will fail. While you can assign a "
"default value using ``global uniform vec4 my_color = ...`` in the shader "
"code, it will be ignored as the global uniform must always be defined in the "
"Project Settings anyway."
msgstr ""
"請注意，全域 uniform *必須* 在儲存著色器時已存在於專案設定內，否則編譯會失"
"敗。雖然你可以在著色器程式碼裡寫 ``global uniform vec4 my_color = ...`` 指定"
"預設值，但這個值會被忽略，因為全域 uniform 必須始終於專案設定中定義。"

msgid ""
"To change the value of a global uniform at runtime, use "
"the :ref:`RenderingServer.global_shader_parameter_set "
"<class_RenderingServer_method_global_shader_parameter_set>` method in a "
"script:"
msgstr ""
"若要在執行時更改全域 uniform 的值，請於腳本中使"
"用 :ref:`RenderingServer.global_shader_parameter_set<class_RenderingServer_method_global_shader_parameter_set>` "
"方法："

msgid ""
"Assigning global uniform values can be done as many times as desired without "
"impacting performance, as setting data doesn't require synchronization "
"between the CPU and GPU."
msgstr ""
"你可以不限次數地設定全域 uniform 值，而不會影響效能，因為這不需 CPU 與 GPU 的"
"同步。"

msgid "You can also add or remove global uniforms at runtime:"
msgstr "你也可以在執行時新增或移除全域 uniform："

msgid ""
"Adding or removing global uniforms at runtime has a performance cost, "
"although it's not as pronounced compared to getting global uniform values "
"from a script (see the warning below)."
msgstr ""
"於執行時新增或刪除全域 uniform 會有效能損耗，雖然比從腳本讀取全域 uniform 值"
"小，但仍需注意（詳見下方警示）。"

msgid ""
"While you *can* query the value of a global uniform at runtime in a script "
"using ``RenderingServer.global_shader_parameter_get(\"uniform_name\")``, "
"this has a large performance penalty as the rendering thread needs to "
"synchronize with the calling thread."
msgstr ""
"雖然你 *可以* 在腳本中用 "
"``RenderingServer.global_shader_parameter_get(\"uniform_name\")`` 於執行時查"
"詢全域 uniform 的值，但這會嚴重拖慢效能，因為渲染執行緒需與呼叫執行緒同步。"

msgid ""
"Therefore, it's not recommended to read global shader uniform values "
"continuously in a script. If you need to read values in a script after "
"setting them, consider creating an :ref:`autoload <doc_singletons_autoload>` "
"where you store the values you need to query at the same time you're setting "
"them as global uniforms."
msgstr ""
"因此，不建議在腳本中頻繁讀取全域 uniform 值。如果你需要在腳本設定後讀取該值，"
"請考慮建立 :ref:`autoload <doc_singletons_autoload>` 來同步儲存並查詢這些值。"

msgid "Per-instance uniforms"
msgstr "每個實例的 uniform"

msgid ""
"Sometimes, you want to modify a parameter on each node using the material. "
"As an example, in a forest full of trees, when you want each tree to have a "
"slightly different color that is editable by hand. Without per-instance "
"uniforms, this requires creating a unique material for each tree (each with "
"a slightly different hue). This makes material management more complex, and "
"also has a performance overhead due to the scene requiring more unique "
"material instances. Vertex colors could also be used here, but they'd "
"require creating unique copies of the mesh for each different color, which "
"also has a performance overhead."
msgstr ""
"有時你會想要讓每個節點使用材質時都能調整參數。舉例來說，如果你想讓森林裡每棵"
"樹的顏色都可個別調整，若無 per-instance uniform，就必須為每棵樹建立一個專屬材"
"質（色調略有不同）。這不僅讓材質管理變複雜，場景也會因為產生更多材質實體而拖"
"慢效能。雖然也能用頂點色實現，但每種顏色都要複製一份網格，效能負擔同樣很重。"

msgid ""
"Per-instance uniforms are set on each GeometryInstance3D, rather than on "
"each Material instance. Take this into account when working with meshes that "
"have multiple materials assigned to them, or MultiMesh setups."
msgstr ""
"per-instance uniform 是設在每個 GeometryInstance3D（幾何實例）上，不是設在每"
"個材質上。當你的網格有多個材質或採用 MultiMesh 時，請特別留意這點。"

msgid ""
"After saving the shader, you can change the per-instance uniform's value "
"using the inspector:"
msgstr "儲存著色器後，可以在屬性檢視器中調整每個實例 uniform 的值："

msgid ""
"Setting a per-instance uniform's value in the GeometryInstance3D section of "
"the inspector"
msgstr "在屬性檢視器的 GeometryInstance3D 區塊設定 per-instance uniform 的值"

msgid ""
"Per-instance uniform values can also be set at runtime "
"using :ref:`set_instance_shader_parameter "
"<class_GeometryInstance3D_method_set_instance_shader_parameter>` method on a "
"node that inherits from :ref:`class_GeometryInstance3D`:"
msgstr ""
"你也可以於執行時，在繼承自 :ref:`class_GeometryInstance3D` 的節點上"
"用 :ref:`set_instance_shader_parameter<class_GeometryInstance3D_method_set_instance_shader_parameter>` "
"方法設定 per-instance uniform 的值："

msgid ""
"When using per-instance uniforms, there are some restrictions you should be "
"aware of:"
msgstr "使用 per-instance uniform 時，請注意以下限制："

msgid ""
"**Per-instance uniforms do not support textures**, only regular scalar and "
"vector types. As a workaround, you can pass a texture array as a regular "
"uniform, then pass the index of the texture to be drawn using a per-instance "
"uniform."
msgstr ""
"**per-instance uniform 不支援紋理貼圖**，僅支援標量與向量型別。若需為每個實例"
"指定不同紋理，可將紋理陣列作為一般 uniform，然後用 per-instance uniform 傳遞"
"要顯示的紋理索引。"

msgid "There is a practical maximum limit of 16 instance uniforms per shader."
msgstr "每個著色器最多允許 16 個 per-instance uniform。"

msgid ""
"If your mesh uses multiple materials, the parameters for the first mesh "
"material found will \"win\" over the subsequent ones, unless they have the "
"same name, index *and* type. In this case, all parameters are affected "
"correctly."
msgstr ""
"如果網格使用多個材質，找到的第一個材質的 per-instance uniform 會「覆蓋」後續"
"材質，除非名稱、索引與型別都相同，此時所有參數才會正確套用。"

msgid ""
"If you run into the above situation, you can avoid clashes by manually "
"specifying the index (0-15) of the instance uniform by using the "
"``instance_index`` hint:"
msgstr ""
"若遇到上述情形，可以用 ``instance_index`` 提示手動指定 per-instance uniform "
"的索引（0-15），以避免衝突："

msgid "Setting uniforms from code"
msgstr "從程式碼設定 uniform"

msgid ""
"You can set uniforms from GDScript using the :ref:`set_shader_parameter() "
"<class_ShaderMaterial_method_set_shader_parameter>` method:"
msgstr ""
"你可以在 GDScript 中"
"用 :ref:`set_shader_parameter()<class_ShaderMaterial_method_set_shader_parameter>` "
"設定 uniform："

msgid ""
"The first argument to ``set_shader_parameter()`` is the name of the uniform "
"in the shader. It must match *exactly* to the name of the uniform in the "
"shader or else it will not be recognized."
msgstr ""
"``set_shader_parameter()`` 第一個參數是著色器內 uniform 的名稱。這個名稱必須*"
"完全*相符，否則將無法辨識。"

msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""
"GDScript 的變數型別與 GLSL 不同，因此從 GDScript 傳值給著色器時，Godot 會自動"
"轉換型別。以下為型別對應表："

msgid "GLSL type"
msgstr "GLSL 型別"

msgid "GDScript type"
msgstr "GDScript 型別"

msgid "Notes"
msgstr "說明"

msgid "Bitwise packed int where bit 0 (LSB) corresponds to x."
msgstr "位元封裝整數，其中第 0 位（最低位）對應 x 分量。"

msgid "For example, a bvec2 of (bx, by) could be created in the following way:"
msgstr "例如，(bx, by) 的 bvec2 可以這樣建立："

msgid "**Vector2i**"
msgstr "**Vector2i**"

msgid "**Vector3i**"
msgstr "**Vector3i**"

msgid "**Vector4i**"
msgstr "**Vector4i**"

msgid "**Vector2**"
msgstr "**Vector2**"

msgid "**Vector3**, **Color**"
msgstr "**Vector3**、**Color**"

msgid "When Color is used, it will be interpreted as (r, g, b)."
msgstr "若型別為 Color，將會被解讀為 (r, g, b)。"

msgid "**Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"
msgstr "**Vector4**、**Color**、**Rect2**、**Plane**、**Quaternion**"

msgid "When Color is used, it will be interpreted as (r, g, b, a)."
msgstr "若型別為 Color，將會被解讀為 (r, g, b, a)。"

msgid ""
"When Rect2 is used, it will be interpreted as (position.x, position.y, "
"size.x, size.y)."
msgstr ""
"若型別為 Rect2，將會被解讀為 (position.x, position.y, size.x, size.y)。"

msgid ""
"When Plane is used it will be interpreted as (normal.x, normal.y, normal.z, "
"d)."
msgstr "若型別為 Plane，將會被解讀為 (normal.x, normal.y, normal.z, d)。"

msgid "**Transform2D**"
msgstr "**Transform2D**"

msgid "**Basis**"
msgstr "**Basis**"

msgid "**Projection**, **Transform3D**"
msgstr "**Projection**、**Transform3D**"

msgid "When a Transform3D is used, the w Vector is set to the identity."
msgstr "若型別為 Transform3D，w 向量會自動設為單位（identity）。"

msgid "**Texture2D**"
msgstr "**Texture2D**"

msgid "**Texture2DArray**"
msgstr "**Texture2DArray**"

msgid "**Texture3D**"
msgstr "**Texture3D**"

msgid "**Cubemap**"
msgstr "**Cubemap**"

msgid ""
"See :ref:`doc_importing_images_changing_import_type` for instructions on "
"importing cubemaps for use in Godot."
msgstr ""
"關於在 Godot 匯入 cubemap 貼圖的說明，請參"
"閱 :ref:`doc_importing_images_changing_import_type`。"

msgid "**CubemapArray**"
msgstr "**CubemapArray**"

msgid "Only supported in Forward+ and Mobile, not Compatibility."
msgstr "僅 Forward+ 與 Mobile 渲染支援，Compatibility 模式不支援。"

msgid "**ExternalTexture**"
msgstr "**ExternalTexture**"

msgid "Only supported in Compatibility/Android platform."
msgstr "僅支援於 Compatibility/Android 平台。"

msgid ""
"Be careful when setting shader uniforms from GDScript, since no error will "
"be thrown if the type does not match. Your shader will just exhibit "
"undefined behavior. Specifically, this includes setting a GDScript int/float "
"(64 bit) into a Godot shader language int/float (32 bit). This may lead to "
"unintended consequences in cases where high precision is required."
msgstr ""
"從 GDScript 設定 shader uniform 時請特別小心，若型別不符並不會報錯，而是產生"
"未定義行為。特別是將 GDScript 的 int/float（64 位元）設給 Godot shader 的 "
"int/float（32 位元）時，若需高精度時可能導致不可預期的結果。"

msgid "Uniform limits"
msgstr "Uniform 限制"

msgid ""
"There is a limit to the total size of shader uniforms that you can use in a "
"single shader. On most desktop platforms, this limit is ``65536`` bytes, or "
"4096 ``vec4`` uniforms. On mobile platforms, the limit is typically "
"``16384`` bytes, or 1024 ``vec4`` uniforms. Vector uniforms smaller than a "
"``vec4``, such as ``vec2`` or ``vec3``, are padded to the size of a "
"``vec4``. Scalar uniforms such as ``int`` or ``float`` are not padded, and "
"``bool`` is padded to the size of an ``int``."
msgstr ""
"每個著色器的 uniform 數量有上限。在大部分桌面平台上，限制為 ``65536`` 位元組"
"（4096 個 ``vec4``）；在行動裝置上則為 ``16384`` 位元組（1024 個 ``vec4``）。"
"比 ``vec4`` 小的向量 uniform（如 ``vec2``、``vec3``）會自動補齊成 ``vec4`` 大"
"小。標量 uniform（如 ``int``、``float``）不做補齊，而 ``bool`` 會補齊為 "
"``int`` 大小。"

msgid ""
"Arrays count as the total size of their contents. If you need a uniform "
"array that is larger than this limit, consider packing the data into a "
"texture instead, since the *contents* of a texture do not count towards this "
"limit, only the size of the sampler uniform."
msgstr ""
"陣列 uniform 會以內容總大小計算。如果你需要的 uniform 陣列超過此上限，建議將"
"資料包進紋理貼圖，因為紋理內容不計入 uniform 限制，只計取樣器（sampler "
"uniform）本身。"

msgid "Built-in variables"
msgstr "內建變數"

msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr ":ref:`空間著色器 <doc_spatial_shader>`"

msgid ":ref:`Canvas item shaders <doc_canvas_item_shader>`"
msgstr ":ref:`Canvas item 著色器 <doc_canvas_item_shader>`"

msgid ":ref:`Particle shaders <doc_particle_shader>`"
msgstr ":ref:`粒子著色器 <doc_particle_shader>`"

msgid ":ref:`Sky shaders <doc_sky_shader>`"
msgstr ":ref:`天空著色器 <doc_sky_shader>`"

msgid ":ref:`Fog shaders <doc_fog_shader>`"
msgstr ":ref:`霧著色器 <doc_fog_shader>`"

msgid "Built-in functions"
msgstr "內建函式"

msgid ""
"A large number of built-in functions are supported, conforming to GLSL ES "
"3.0. See the :ref:`Built-in functions <doc_shader_functions>` page for "
"details."
msgstr ""
"Godot 支援大量內建函式，遵循 GLSL ES 3.0 標準。詳情請見 :ref:`內建函式 "
"<doc_shader_functions>` 頁面。"
