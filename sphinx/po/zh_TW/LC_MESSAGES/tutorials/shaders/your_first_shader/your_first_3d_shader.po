#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "第一個遊戲"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你已經決定開始編寫一個自訂 Spatial 著色器。或許你在網上看到一個很酷的著色器技"
"巧，或許你發現 :ref:`SpatialMaterial <class_SpatialMaterial>` 並不能完全滿足"
"你的需求。總之，你決定寫一個自己的，你想弄清楚從哪裡開始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"這個教學將說明如何編寫空間著色器, 並將涵蓋比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 更多的主題."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"空間著色器比CanvasItem著色器有更多的內建功能. 對空間著色器的期望是:Godot為常"
"見的用例提供了功能, 使用者僅需在著色器中設定適當的參數. 這對於PBR(基於物理的"
"算繪)工作流來說尤其如此."

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In the :ref:"
"`second part <doc_your_second_spatial_shader>` we will take the concepts "
"from this tutorial and set up custom materials in a fragment shader by "
"writing an ocean water shader."
msgstr ""
"這是一個兩部分的教學. 在第一部分中, 我們將學習如何在頂點函式中使用高度圖的頂"
"點位移來製作一個簡單的地形. 在 :ref:`第二部分 "
"<doc_your_second_spatial_shader>` 中, 我們將採用本教學中的概念, 通過編寫一個"
"海洋水著色器, 講解如何在片段著色器中設定自訂材質."

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"這個教學假定你對著色器有一些基本的瞭解, 例如型別( ``vec2`` , ``float`` , "
"``sampler2D`` ), 和函式. 如果你對這些概念摸不著頭腦, 那麼你在完成這個教學之"
"前, 最好先從 `著色器之書 <https://thebookofshaders.com/?lan=ch>` 獲取一些基本"
"知識."

msgid "Where to assign my material"
msgstr "在何處設定材質"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a few :ref:"
"`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic geometry "
"to a scene without importing Meshes."
msgstr ""
"在3D中, 物件是使用 :ref:`Meshes <class_Mesh>` 繪製的.Mesh是一種資源型別, 它"
"以 \"表面(surface)\" 為單位儲存幾何體(物件的形狀)和材質(對象的顏色和對光線的"
"反應). 一個Mesh可以有多個表面, 也可以只有一個. 通常情況下, 你會從另一個程式"
"(如Blender)匯入一個Mesh. 但是Godot也有一些 :ref:`PrimitiveMeshes "
"<class_primitivemesh>` 允許你在不匯入Mesh的情況下為場景新增基本幾何體."

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also use :ref:"
"`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"你可以使用多種節點型別可以用來繪製Mesh. 主要的是 :ref:`MeshInstance "
"<class_meshinstance>`, 但你也可以使用 :ref:`Particles <class_particles>`, :"
"ref:`MultiMeshes <class_MultiMesh>` (與 :ref:`MultiMeshInstance "
"<class_multimeshinstance>` 一起使用), 或其他."

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常情況下, 一個材質是與Mesh中的一個給定表面相關聯的, 但有些節點, 如"
"MeshInstance, 允許你覆蓋一個特定的表面或所有表面的材質."

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或Mesh本身上設定了材質, 那麼所有共用該Mesh的MeshInstance都共用該"
"材質. 但是, 如果你想在多個Mesh實例中重用同一個Mesh, 但每個實例具有不同的材"
"質, 那麼你應該在Meshinstance上設定材質."

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"在本教學中, 我們將材質設定在Mesh自身上, 不使用MeshInstance覆蓋材質的功能."

msgid "Setting up"
msgstr "設定"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "向場景新增一個新的 :ref:`MeshInstance <class_meshinstance>` 節點."

msgid "This will allow you to see the triangles making up the plane."
msgstr "這將允許您查看構成平面的三角形."

msgid ""
"You can see that there are now many more triangles in the :ref:"
"`MeshInstance3D<class_MeshInstance3D>`. This will give us more vertices to "
"work with and thus allow us to add more detail."
msgstr ""
"可以看到現在 :ref:`Mesh<class_MeshInstance>` 中有了更多的三角形. 這將為我們提"
"供更多頂點, 便於新增更多細節."

msgid "Shader magic"
msgstr "著色器魔術"

msgid "Adding this line, you should get an image like the one below."
msgstr "新增此行後, 你應該會得到類似下方的圖像."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "看起來效果好了一些, 但它仍然過於尖銳和重複, 讓我們把它變得更有趣一點."

msgid "Noise heightmap"
msgstr "雜訊高度圖"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"雜訊是一種非常流行的偽造地形的工具. 可以認為它和餘弦函式一樣生成重複的小山, "
"只是在雜訊的影響下每個小山都擁有不同的高度."

msgid ""
"Godot provides the :ref:`NoiseTexture2D <class_noisetexture2D>` resource for "
"generating a noise texture that can be accessed from a shader."
msgstr ""
"Godot提供了 :ref:`雜訊紋理 <class_noisetexture>` 資源, 可以生成從著色器存取的"
"雜訊紋理."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"要在著色器中存取紋理，請在著色器頂部附近、``vertex()`` 函式外部新增以下程式"
"碼。"

msgid "Once you set it up and should look like this."
msgstr "設定好後, 看起來應該像這樣."

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用此程式碼後, 你可以看到紋理建立了隨機外觀的山峰."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前它還很尖銳, 我們需要稍微柔化一下山峰. 這將用到uniform值. 你在之前已經使用"
"了uniform 值來傳遞雜訊紋理, 現在讓我們來學習一下其中的工作原理."

msgid "Uniforms"
msgstr "Uniform"

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "讓我們做一個改變地形高度的uniform."

msgid ""
"Changing uniforms in Spatial-based nodes is different from CanvasItem-based "
"nodes. Here, we set the material inside the PlaneMesh resource. In other "
"mesh resources you may need to first access the material by calling "
"``surface_get_material()``. While in the MeshInstance3D you would access the "
"material using ``get_surface_material()`` or ``material_override``."
msgstr ""
"更改uniform值時, 基於空間的節點與基於CanvasItem的節點使用的方法不同. 在這裡, "
"我們在PlaneMesh資源內設定材質. 在其他mesh資源中, 你可能要先呼叫 "
"``surface_get_material()`` 來獲取材質. 而在MeshInstance中, 則是用 "
"``get_surface_material()`` 或 ``material_override`` 獲取材質."

msgid "Now it looks much better."
msgstr "現在它看起來好多了."

msgid ""
"Using uniforms, we can even change the value every frame to animate the "
"height of the terrain. Combined with :ref:`Tweens <class_Tween>`, this can "
"be especially useful for animations."
msgstr ""
"使用 uniform，我們甚至可以在每一影格改變數值，以動畫化地形的高度。結合 :ref:"
"`Tween <class_Tween>`，這對簡單的動畫特別有用。"

msgid "Interacting with light"
msgstr "與光互動"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"注意網格顏色是如何變得平滑的. 這是因為它的光線是平滑的. 讓我們加一盞燈吧!"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你會看到光線影響了地形, 但這看起來很奇怪. 問題是光線對地形的影響就像在平面上"
"一樣. 這是因為光著色器使用 :ref:`網格 <class_mesh>` 中的法線來計算光."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法線儲存在網格中, 但是我們在著色器中改變網格的形狀, 所以法線不再正確. 為了解"
"決這個問題, 我們可以在著色器中重新計算法線, 或者使用與我們的雜訊相對應的法線"
"紋理.Godot讓這一切變得很簡單."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"您可以在頂點函式中手動計算新的法線，然後只需設定法線 ``NORMAL``。設定好 "
"``NORMAL`` 後，Godot 將為我們完成所有困難的光照計算。我們將在本教學的下一部分"
"介紹這種方法，現在我們將從紋理中讀取法線。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"相反, 我們將再次依靠雜訊來計算法線. 我們通過傳入第二個雜訊紋理來做到這一點."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "現在我們可以從 ``fragment()`` 函式中存取 ``tex_position`` ."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法線就位後, 光線就會對網格的高度做出動態反應."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "我們甚至可以把燈拖來拖去, 燈光會自動更新."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教學的完整程式碼. 您可以看到,Godot會為您處理大多數繁瑣的事情, 本教學"
"篇幅不會太長."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"這就是這部分的全部內容. 希望您現在已瞭解Godot中頂點著色器的基本知識. 在本教學"
"的下一部分中, 我們將編寫一個片段函式來配合這個頂點函式, 並且我們將介紹一種更"
"高級的技術來將這個地形轉換成一個移動的波浪海洋."
