#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your second 3D shader"
msgstr "你的第二個 3D 著色器"

msgid ""
"From a high-level, what Godot does is give the user a bunch of parameters "
"that can be optionally set (``AO``, ``SSS_Strength``, ``RIM``, etc.). These "
"parameters correspond to different complex effects (Ambient Occlusion, "
"SubSurface Scattering, Rim Lighting, etc.). When not written to, the code is "
"thrown out before it is compiled and so the shader does not incur the cost "
"of the extra feature. This makes it easy for users to have complex PBR-"
"correct shading, without writing complex shaders. Of course, Godot also "
"allows you to ignore all these parameters and write a fully customized "
"shader."
msgstr ""
"從高階來看，Godot 提供給使用者一組可以選擇設定的參數（如 ``AO``、"
"``SSS_Strength``、``RIM`` 等）。這些參數對應到不同的複雜效果（環境光遮蔽，次"
"表面散射，邊緣光等）。如果沒有對這些參數賦值，對應的程式碼會在編譯前被移除，"
"因此著色器不會產生額外的效能負擔。這讓使用者能夠輕鬆享有複雜且正確的 PBR 著色"
"效果，而無需撰寫複雜的著色器。當然，Godot 也允許你完全忽略這些參數，直接撰寫"
"完全自訂的著色器。"

msgid ""
"For a full list of these parameters see the :ref:`spatial shader "
"<doc_spatial_shader>` reference doc."
msgstr "完整參數列表請參考 :ref:`空間著色器 <doc_spatial_shader>` 文件。"

msgid ""
"A difference between the vertex function and a fragment function is that the "
"vertex function runs per vertex and sets properties such as ``VERTEX`` "
"(position) and ``NORMAL``, while the fragment shader runs per pixel and, "
"most importantly, sets the ``ALBEDO`` color of "
"the :ref:`MeshInstance3D<class_MeshInstance3D>`."
msgstr ""
"頂點函式和片段函式的差異在於，頂點函式是針對每個頂點運作並設定像是 ``VERTEX``"
"（位置）和 ``NORMAL`` 等屬性，而片段著色器則是針對每個像素運作，最重要的是設"
"定 :ref:`MeshInstance3D<class_MeshInstance3D>` 的 ``ALBEDO`` 顏色。"

msgid "Your first spatial fragment function"
msgstr "你的第一個空間片段函式"

msgid ""
"As mentioned in the previous part of this tutorial. The standard use of the "
"fragment function in Godot is to set up different material properties and "
"let Godot handle the rest. In order to provide even more flexibility, Godot "
"also provides things called render modes. Render modes are set at the top of "
"the shader, directly below ``shader_type``, and they specify what sort of "
"functionality you want the built-in aspects of the shader to have."
msgstr ""
"如同本教學前面所提到，在 Godot 中片段函式的標準用法是設定不同的材質屬性，剩下"
"的則交由 Godot 處理。為了提供更大的彈性，Godot 也提供了所謂的算繪模式"
"（render modes）。算繪模式設定在著色器最上方，緊接在 ``shader_type`` 下面，用"
"來指定你希望著色器內建有哪些功能。"

msgid ""
"For example, if you do not want to have lights affect an object, set the "
"render mode to ``unshaded``:"
msgstr "例如，如果你不希望燈光影響物件，可以將算繪模式設為 ``unshaded``："

msgid ""
"You can also stack multiple render modes together. For example, if you want "
"to use toon shading instead of more-realistic PBR shading, set the diffuse "
"mode and specular mode to toon:"
msgstr ""
"你也可以同時套用多個算繪模式。例如，如果你想要用卡通著色而非寫實的 PBR 著色，"
"可以把漫反射模式和高光模式都設為 toon："

msgid ""
"This model of built-in functionality allows you to write complex custom "
"shaders by changing only a few parameters."
msgstr "這種內建功能模型讓你只需調整幾個參數，就能寫出複雜的自訂著色器。"

msgid ""
"For a full list of render modes see the :ref:`Spatial shader reference "
"<doc_spatial_shader>`."
msgstr ""
"完整的算繪模式列表請參考 :ref:`空間著色器參考 <doc_spatial_shader>` 文件。"

msgid ""
"In this part of the tutorial, we will walk through how to take the bumpy "
"terrain from the previous part and turn it into an ocean."
msgstr "在本教學這一部分，我們會說明如何把前一部分的崎嶇地形變成海洋。"

msgid ""
"First let's set the color of the water. We do that by setting ``ALBEDO``."
msgstr "首先，來設定水的顏色。我們可以直接設定 ``ALBEDO``。"

msgid "``ALBEDO`` is a ``vec3`` that contains the color of the object."
msgstr "``ALBEDO`` 是一個 ``vec3``，用來表示物件的顏色。"

msgid "Let's set it to a nice shade of blue."
msgstr "我們來把它設成好看的藍色。"

msgid ""
"We set it to a very dark shade of blue because most of the blueness of the "
"water will come from reflections from the sky."
msgstr "我們把它設為非常深的藍色，因為水的藍色多半來自天空的反射。"

msgid ""
"The PBR model that Godot uses relies on two main parameters: ``METALLIC`` "
"and ``ROUGHNESS``."
msgstr ""
"Godot 使用的 PBR 模型主要依賴兩個參數：「金屬度」（``METALLIC``）與「粗糙度」"
"（``ROUGHNESS``）。"

msgid ""
"``ROUGHNESS`` specifies how smooth/rough the surface of a material is. A low "
"``ROUGHNESS`` will make a material appear like a shiny plastic, while a high "
"roughness makes the material appear more solid in color."
msgstr ""
"``ROUGHNESS`` 決定材質表面的平滑或粗糙程度。較低的 ``ROUGHNESS`` 會讓材質看起"
"來像閃亮的塑膠，較高的 ``ROUGHNESS`` 則會讓顏色更為沉穩不反光。"

msgid ""
"``METALLIC`` specifies how much like a metal the object is. It is better set "
"close to ``0`` or ``1``. Think of ``METALLIC`` as changing the balance "
"between the reflection and the ``ALBEDO`` color. A high ``METALLIC`` almost "
"ignores ``ALBEDO`` altogether, and looks like a mirror of the sky. While a "
"low ``METALLIC`` has a more equal representation of sky color and ``ALBEDO`` "
"color."
msgstr ""
"``METALLIC`` 指定物體的金屬感強度，建議設為接近 ``0`` 或 ``1``。你可以把 "
"``METALLIC`` 想成是在反射與 ``ALBEDO`` 顏色間做平衡。高 ``METALLIC`` 幾乎完全"
"忽略 ``ALBEDO``，看起來就像天空的鏡子；低 ``METALLIC`` 則讓天空色與 "
"``ALBEDO`` 顏色都能表現出來。"

msgid ""
"``ROUGHNESS`` increases from ``0`` to ``1`` from left to right while "
"``METALLIC`` increase from ``0`` to ``1`` from top to bottom."
msgstr ""
"``ROUGHNESS`` （粗糙度）從左到右由 ``0`` 增加到 ``1`` ， ``METALLIC`` （金屬"
"度）則從上到下由 ``0`` 增加到 ``1`` 。"

msgid ""
"``METALLIC`` should be close to ``0`` or ``1`` for proper PBR shading. Only "
"set it between them for blending between materials."
msgstr ""
"正確的 PBR 著色時，``METALLIC`` 應接近 ``0`` 或 ``1``，只有在材質混合時才設在"
"兩者之間。"

msgid ""
"Water is not a metal, so we will set its ``METALLIC`` property to ``0.0``. "
"Water is also highly reflective, so we will set its ``ROUGHNESS`` property "
"to be quite low as well."
msgstr ""
"水不是金屬，所以我們把 ``METALLIC`` 設為 ``0.0``。水的反射性很高，因此 "
"``ROUGHNESS`` 也要設得很低。"

msgid ""
"Now we have a smooth plastic looking surface. It is time to think about some "
"particular properties of water that we want to emulate. There are two main "
"ones that will take this from a weird plastic surface to nice stylized "
"water. The first is specular reflections. Specular reflections are those "
"bright spots you see from where the sun reflects directly into your eye. The "
"second is fresnel reflectance. Fresnel reflectance is the property of "
"objects to become more reflective at shallow angles. It is the reason why "
"you can see into water below you, but farther away it reflects the sky."
msgstr ""
"現在我們得到的是一個光滑的塑膠表面。接著，我們要思考想要模擬哪些水的特殊屬"
"性。有兩個主要特性能讓這個表面從奇怪的塑膠感變成漂亮的水面：第一是鏡面反射"
"（Specular Reflection），也就是你看到太陽直射時水面出現的亮點；第二是菲涅耳反"
"射（Fresnel Reflectance），也就是物體在較淺的觀察角度時反射性會變強。這就是為"
"什麼你可以看清楚腳下的水，但遠一點就只能看到天空反射。"

msgid ""
"In order to increase the specular reflections, we will do two things. First, "
"we will change the render mode for specular to toon because the toon render "
"mode has larger specular highlights."
msgstr ""
"為了加強鏡面反射，我們會做兩件事。首先，把鏡面反射的算繪模式設為 toon，因為 "
"toon 模式會有更明顯的高光區。"

msgid ""
"Second we will add rim lighting. Rim lighting increases the effect of light "
"at glancing angles. Usually it is used to emulate the way light passes "
"through fabric on the edges of an object, but we will use it here to help "
"achieve a nice watery effect."
msgstr ""
"再來，我們會加上邊緣光（rim lighting）。邊緣光會讓物件邊緣在掠射角度下更明"
"亮。一般常用來模擬布料邊緣的透光，但在這裡能幫助我們做出漂亮的水面質感。"

msgid ""
"In order to add fresnel reflectance, we will compute a fresnel term in our "
"fragment shader. Here, we aren't going to use a real fresnel term for "
"performance reasons. Instead, we'll approximate it using the dot product of "
"the ``NORMAL`` and ``VIEW`` vectors. The ``NORMAL`` vector points away from "
"the mesh's surface, while the ``VIEW`` vector is the direction between your "
"eye and that point on the surface. The dot product between them is a handy "
"way to tell when you are looking at the surface head-on or at a glancing "
"angle."
msgstr ""
"為了加入菲涅耳反射，我們會在片段著色器裡計算一個簡化版的菲涅耳項。這裡為了效"
"能不採用完整公式，而是用 ``NORMAL`` 和 ``VIEW`` 向量的點積來近似。``NORMAL`` "
"向量是指向網格表面外側，而 ``VIEW`` 向量則是從該點指向觀察者的方向。這兩個向"
"量的點積可以幫我們判斷是正面看還是斜著看表面。"

msgid ""
"And mix it into both ``ROUGHNESS`` and ``ALBEDO``. This is the benefit of "
"ShaderMaterials over StandardMaterial3Ds. With StandardMaterial3D, we could "
"set these properties with a texture, or to a flat number. But with shaders "
"we can set them based on any mathematical function that we can dream up."
msgstr ""
"然後把它混合進 ``ROUGHNESS`` 和 ``ALBEDO``。這也是 ShaderMaterial 相較於 "
"StandardMaterial3D 的優勢。StandardMaterial3D 只能用紋理或單一數值來設定這些"
"屬性，但有了著色器就能用任何你想得到的數學公式來設定。"

msgid ""
"And now, with only 5 lines of code, you can have complex looking water. Now "
"that we have lighting, this water is looking too bright. Let's darken it. "
"This is done easily by decreasing the values of the ``vec3`` we pass into "
"``ALBEDO``. Let's set them to ``vec3(0.01, 0.03, 0.05)``."
msgstr ""
"現在只需要五行程式碼，你就能做出複雜的水面。既然有了打光，這個水面看起來太亮"
"了。我們把它調暗一點，只要把傳給 ``ALBEDO`` 的 ``vec3`` 數值調小就行。設成 "
"``vec3(0.01, 0.03, 0.05)`` 吧。"

msgid "Animating with ``TIME``"
msgstr "使用 ``TIME`` 製作動畫"

msgid ""
"Going back to the vertex function, we can animate the waves using the built-"
"in variable ``TIME``."
msgstr "回到頂點函式，我們可以用內建變數 ``TIME`` 來讓波浪動起來。"

msgid ""
"``TIME`` is a built-in variable that is accessible from the vertex and "
"fragment functions."
msgstr "``TIME`` 是內建變數，頂點和片段函式都能用。"

msgid ""
"In the last tutorial we calculated height by reading from a heightmap. For "
"this tutorial, we will do the same. Put the heightmap code in a function "
"called ``height()``."
msgstr ""
"上一個教學我們是用高度圖來計算高度。這次我們也一樣，只是把高度圖的程式碼寫在"
"一個叫 ``height()`` 的函式裡。"

msgid ""
"In order to use ``TIME`` in the ``height()`` function, we need to pass it in."
msgstr "如果要在 ``height()`` 函式裡用 ``TIME``，就必須把它傳進去。"

msgid "And make sure to correctly pass it in inside the vertex function."
msgstr "記得在頂點函式裡正確傳遞這個參數。"

msgid ""
"Instead of using a normalmap to calculate normals. We are going to compute "
"them manually in the ``vertex()`` function. To do so use the following line "
"of code."
msgstr ""
"這次我們不是用法線貼圖來計算法線，而是在 ``vertex()`` 函式裡手動計算。請用下"
"列程式碼。"

msgid ""
"We need to compute ``NORMAL`` manually because in the next section we will "
"be using math to create complex-looking waves."
msgstr "我們要手動計算 ``NORMAL``，因為下一節會用數學方式做出更複雜的波浪。"

msgid ""
"Now, we are going to make the ``height()`` function a little more "
"complicated by offsetting ``position`` by the cosine of ``TIME``."
msgstr ""
"現在，我們要讓 ``height()`` 函式更複雜一點，將 ``position`` 用 ``TIME`` 的餘"
"弦做偏移。"

msgid ""
"This results in waves that move slowly, but not in a very natural way. The "
"next section will dig deeper into using shaders to create more complex "
"effects, in this case realistic waves, by adding a few more mathematical "
"functions."
msgstr ""
"這樣做出來的波浪會慢慢移動，但還不太自然。下一節會再深入一點，用更多數學函式"
"讓波浪更真實。"

msgid "Advanced effects: waves"
msgstr "進階效果：波浪"

msgid ""
"What makes shaders so powerful is that you can achieve complex effects by "
"using math. To illustrate this, we are going to take our waves to the next "
"level by modifying the ``height()`` function and by introducing a new "
"function called ``wave()``."
msgstr ""
"著色器的強大就在於你可以用數學實現各種複雜效果。為了說明這點，接下來我們會修"
"改 ``height()`` 並加入一個新的 ``wave()`` 函式，讓波浪效果更上一層樓。"

msgid ""
"``wave()`` has one parameter, ``position``, which is the same as it is in "
"``height()``."
msgstr "``wave()`` 只有一個參數 ``position``，和 ``height()`` 裡的一樣。"

msgid ""
"We are going to call ``wave()`` multiple times in ``height()`` in order to "
"fake the way waves look."
msgstr "我們會在 ``height()`` 裡多次呼叫 ``wave()``，來組合出各種波浪外觀。"

msgid "At first this looks complicated. So let's go through it line-by-line."
msgstr "一開始看起來很複雜，我們就一行一行來解釋。"

msgid ""
"Offset the position by the ``noise`` texture. This will make the waves "
"curve, so they won't be straight lines completely aligned with the grid."
msgstr ""
"用 ``noise`` 紋理把位置做偏移，這樣波浪會彎曲，不會完全沿著網格變成直線。"

msgid ""
"Define a wave-like function using ``sin()`` and ``position``. Normally "
"``sin()`` waves are very round. We use ``abs()`` to absolute to give them a "
"sharp ridge and constrain them to the 0-1 range. And then we subtract it "
"from ``1.0`` to put the peak on top."
msgstr ""
"用 ``sin()`` 和 ``position`` 定義一個波浪函式。一般 ``sin()`` 波都是圓弧狀，"
"我們用 ``abs()`` 絕對值讓它有明顯波峰，並限制在 0 到 1 的範圍，再用 ``1.0`` "
"減去它，把波峰推到上方。"

msgid ""
"Multiply the x-directional wave by the y-directional wave and raise it to a "
"power to sharpen the peaks. Then subtract that from ``1.0`` so that the "
"ridges become peaks and raise that to a power to sharpen the ridges."
msgstr ""
"將 x 方向的波和 y 方向的波相乘，並做冪次運算讓波峰更尖銳。再從 ``1.0`` 減去"
"它，讓山脊變成波峰，並再次做冪次運算加強效果。"

msgid ""
"We can now replace the contents of our ``height()`` function with ``wave()``."
msgstr "現在我們可以直接用 ``wave()`` 取代 ``height()`` 函式的內容。"

msgid "Using this, you get:"
msgstr "這樣你會得到："

msgid ""
"The shape of the sin wave is too obvious. So let's spread the waves out a "
"bit. We do this by scaling ``position``."
msgstr "正弦波的形狀太明顯了，我們把波形拉開一點，用縮放 ``position`` 來做到。"

msgid "Now it looks much better."
msgstr "現在看起來好多了。"

msgid ""
"We can do even better if we layer multiple waves on top of each other at "
"varying frequencies and amplitudes. What this means is that we are going to "
"scale position for each one to make the waves thinner or wider (frequency). "
"And we are going to multiply the output of the wave to make them shorter or "
"taller (amplitude)."
msgstr ""
"如果我們把多個波浪用不同頻率和振幅疊加在一起，效果會更自然。意思就是針對每個"
"波浪調整位置的縮放（頻率），再用不同倍數調整波的高度（振幅）。"

msgid ""
"Here is an example for how you could layer the four waves to achieve nicer "
"looking waves."
msgstr "這裡有個例子：如何用四層波浪混合出更漂亮的波形。"

msgid ""
"Note that we add time to two and subtract it from the other two. This makes "
"the waves move in different directions creating a complex effect. Also note "
"that the amplitudes (the number the result is multiplied by) all add up to "
"``1.0``. This keeps the wave in the 0-1 range."
msgstr ""
"注意：我們把時間加在兩個波浪上，另外兩個則減去時間，這樣波浪就會往不同方向移"
"動產生複雜的效果。另外，所有振幅（也就是乘上的數字）加起來要等於 ``1.0``，這"
"樣波浪才會維持在 0-1 範圍內。"

msgid ""
"With this code you should end up with more complex looking waves and all you "
"had to do was add a bit of math!"
msgstr "有了這段程式碼，你就能做出更複雜的波浪效果，只需加點數學運算！"

msgid ""
"For more information about Spatial shaders read the :ref:`Shading Language "
"<doc_shading_language>` doc and the :ref:`Spatial Shaders "
"<doc_spatial_shader>` doc. Also look at more advanced tutorials in "
"the :ref:`Shading section <toc-learn-features-shading>` and the :ref:`3D "
"<toc-learn-features-3d>` sections."
msgstr ""
"更多關於空間著色器的資訊，請參閱 :ref:`Shading Language "
"<doc_shading_language>` 文件與 :ref:`Spatial Shaders <doc_spatial_shader>` 文"
"件。你也可以參考 :ref:`著色 <toc-learn-features-shading>` 以及 :ref:`3D <toc-"
"learn-features-3d>` 章節中的進階教學。"
