#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "進階後期處理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"本教學說明在 Godot 中進行進階後期處理的方法，特別是如何編寫會使用深度緩衝區的"
"後期處理著色器。您應該已經熟悉後期處理的基本概念，尤其是 :ref:`自訂後期處理教"
"學 <doc_custom_postprocessing>` 中介紹的方法。"

msgid "Full screen quad"
msgstr "全螢幕四邊形"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"製作自訂後期處理特效的一種方式是使用 Viewport。然而，使用 Viewport 有兩個主要"
"缺點："

msgid "The depth buffer cannot be accessed"
msgstr "無法存取深度緩衝區"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "在編輯器中看不到後期處理著色器的效果"

msgid ""
"To get around the limitation on using the depth buffer, use "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"為了繞過無法使用深度緩衝區的限制，請使用 :ref:`MeshInstance3D "
"<class_MeshInstance3D>` 並搭配 :ref:`QuadMesh <class_QuadMesh>` 基元。這樣我"
"們就可以使用著色器來存取場景的深度紋理。接下來，請利用頂點著色器讓這個四邊形"
"始終覆蓋螢幕，讓後期處理效果隨時生效，包含在編輯器內。"

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"首先，新建一個 MeshInstance3D，並把它的網格設為 QuadMesh。這會建立一個以座標 "
"``(0, 0, 0)`` 為中心，寬高為 ``1`` 的四邊形。請將寬度和高度都設為 ``2``，並勾"
"選 **Flip Faces**。目前這個四邊形位於世界座標原點，但我們希望它能隨著相機移"
"動，讓它始終覆蓋整個畫面。為達到這個目的，我們要繞過一般會將頂點位置轉換到不"
"同座標空間的轉換流程，直接將頂點視為已在裁剪空間中。"

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position in clip space directly."
msgstr ""
"頂點著色器預期的輸出座標應為裁剪空間座標，螢幕左下為 ``-1``，右上為 ``1``。這"
"也是為什麼 QuadMesh 的寬高要設為 ``2``。Godot 會自動處理從模型空間到視圖空間"
"再到裁剪空間的轉換，因此我們需要消除這些自動轉換的影響，方法就是直接設定內建"
"的 ``POSITION`` 變數。設定 ``POSITION`` 會略過內建的轉換流程，讓頂點座標直接"
"呈現於裁剪空間。"

msgid ""
"In versions of Godot earlier than 4.3, this code recommended using "
"``POSITION = vec4(VERTEX, 1.0);`` which implicitly assumed the clip-space "
"near plane was at ``0.0``. That code is now incorrect and will not work in "
"versions 4.3+ as we use a \"reversed-z\" depth buffer now where the near "
"plane is at ``1.0``."
msgstr ""
"在 4.3 以前的 Godot 版本，這段程式碼建議使用 ``POSITION = vec4(VERTEX, "
"1.0);``，這隱含假設裁剪空間的近裁剪面在 ``0.0``。但在 4.3 之後，Godot 採用"
"「反向 Z」深度緩衝區，近裁剪面為 ``1.0``，因此這種寫法已不正確，無法在 4.3 以"
"上版本運作。"

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"即使有這樣的頂點著色器，四邊形還是會消失。這是因為視錐剔除是由 CPU 執行的。視"
"錐剔除會使用相機矩陣和 Mesh 的 AABB 來判斷該 Mesh 是否可見，再決定是否傳送到 "
"GPU。CPU 不知道我們如何處理頂點，所以它認為你指定的座標是世界座標，而不是裁剪"
"空間，導致當視角偏離場景中心時 Godot 會剔除這個四邊形。為了避免這個問題，有幾"
"種作法："

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr "將 QuadMesh 加為相機的子節點，讓相機始終指向它"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr "將 QuadMesh 的幾何屬性 ``extra_cull_margin`` 設為盡量大"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"第二種方式可確保四邊形在編輯器中可見，第一種方式則能讓它即使相機離開剔除邊界"
"也仍然可見。你也可以同時採用這兩種方式。"

msgid "Depth texture"
msgstr "深度紋理"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"要讀取深度紋理，需先建立一個使用 ``hint_depth_texture`` 的紋理 uniform 來指向"
"深度緩衝區。"

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr "定義後，即可用 ``texture()`` 函式讀取深度紋理。"

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"類似於讀取螢幕紋理，只有從目前視口讀取時才能取得深度紋理。你無法從已渲染的其"
"他視口取得深度紋理。"

msgid ""
"The values returned by ``depth_texture`` are between ``1.0`` and ``0.0`` "
"(corresponding to the near and far plane, respectively, because of using a "
"\"reverse-z\" depth buffer) and are nonlinear. When displaying depth "
"directly from the ``depth_texture``, everything will look almost black "
"unless it is very close due to that nonlinearity. In order to make the depth "
"value align with world or model coordinates, we need to linearize the value. "
"When we apply the projection matrix to the vertex position, the z value is "
"made nonlinear, so to linearize it, we multiply it by the inverse of the "
"projection matrix, which in Godot, is accessible with the variable "
"``INV_PROJECTION_MATRIX``."
msgstr ""
"``depth_texture`` 回傳的數值範圍為 ``1.0`` 到 ``0.0``（分別對應近裁剪面和遠裁"
"剪面，因為採用「反向 Z」深度緩衝區），且這些值是非線性的。若直接顯示 "
"``depth_texture`` 的數值，除了極靠近相機的區域，其餘畫面幾乎全黑。若要讓深度"
"值能對應到世界或模型座標，需要將其線性化。當投影矩陣套用到頂點時，z 值會變為"
"非線性，因此要線性化時，我們需乘上投影矩陣的逆矩陣，這在 Godot 中可以用 "
"``INV_PROJECTION_MATRIX`` 取得。"

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"首先，取得螢幕空間座標，並將其轉換為正規化裝置座標（NDC）。在 Vulkan 後端下，"
"NDC 的 x 與 y 軸範圍為 ``-1.0`` 到 ``1.0``，z 軸則為 ``0.0`` 到 ``1.0``。可"
"用 ``SCREEN_UV`` 重建 x、y 軸，z 軸則用深度值來重建。"

msgid ""
"This tutorial assumes the use of the Forward+ or Mobile renderers, which "
"both use Vulkan NDCs with a Z-range of ``[0.0, 1.0]``. In contrast, the "
"Compatibility renderer uses OpenGL NDCs with a Z-range of ``[-1.0, 1.0]``. "
"For the Compatibility renderer, replace the NDC calculation with this "
"instead:"
msgstr ""
"本教學假設你使用 Forward+ 或 Mobile 渲染器，這兩者都採用 Z 範圍為 ``[0.0, "
"1.0]`` 的 Vulkan NDC。相較之下，Compatibility 渲染器則採用 Z 範圍為 ``[-1.0, "
"1.0]`` 的 OpenGL NDC。若使用 Compatibility 渲染器，請改用以下的 NDC 計算方"
"式："

msgid ""
"You can also use the ``CURRENT_RENDERER`` and ``RENDERER_COMPATIBILITY`` "
"built-in defines for a shader that will work in all renderers:"
msgstr ""
"你也可以使用內建的 ``CURRENT_RENDERER`` 及 ``RENDERER_COMPATIBILITY`` 常數，"
"在著色器內支援所有渲染器："

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"將 NDC 乘上 ``INV_PROJECTION_MATRIX`` 可轉換到視圖空間。回顧一下，視圖空間的"
"座標是相對於相機的，因此 ``z`` 值就是該點到相機的距離。"

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"由於相機朝向負 ``z`` 軸，因此座標的 ``z`` 值會是負數。為了取得可用的深度值，"
"需要把 ``view.z`` 取負號。"

msgid ""
"The world position can be constructed from the depth buffer using the "
"following code, using the ``INV_VIEW_MATRIX`` to transform the position from "
"view space into world space."
msgstr ""
"要從深度緩衝區重建世界座標，可使用下述程式碼，並以 ``INV_VIEW_MATRIX`` 將座標"
"從視圖空間轉換到世界空間。"

msgid "Example shader"
msgstr "範例著色器"

msgid ""
"Once we add a line to output to ``ALBEDO``, we have a complete shader that "
"looks something like this. This shader lets you visualize the linear depth "
"or world space coordinates, depending on which line is commented out."
msgstr ""
"只要加上一行輸出到 ``ALBEDO``，就成為完整的著色器。根據你註解哪一行，這個著色"
"器可以用來視覺化線性深度或世界座標。"

msgid "An optimization"
msgstr "最佳化"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"However, the benefit is quite small and only beneficial when running "
"especially complex fragment shaders."
msgstr ""
"你可以改用一個大三角形來取代全螢幕四邊形。原因可以參考 `這裡 <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_。"
"不過這樣的優勢其實很小，只有在片段著色器非常複雜時才較有幫助。"

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"將 MeshInstance3D 的 Mesh 設為 :ref:`ArrayMesh <class_ArrayMesh>`。ArrayMesh "
"可以讓你用頂點、法線、顏色等陣列輕鬆建構網格。"

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr "接著，將腳本掛載到 MeshInstance3D，並使用以下程式碼："

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"三角形的頂點座標是用正規化裝置座標（NDC）指定的。NDC 的 x、y 軸都是從 "
"``-1.0`` 到 ``1.0``，也就是螢幕寬高各 2。為了用單一三角形覆蓋整個螢幕，需用一"
"個寬高都是 4 的三角形（也就是寬高都加倍）。"

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr "套用上面相同的頂點著色器，畫面效果就會一樣。"

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"用 ArrayMesh 取代 QuadMesh 的一個缺點是 ArrayMesh 在編輯器裡不會顯示，因為三"
"角形要等到場景執行時才建立。若要解決這個問題，可以在 3D 建模軟體中建立一個三"
"角形網格，然後在 MeshInstance3D 裡使用它。"
