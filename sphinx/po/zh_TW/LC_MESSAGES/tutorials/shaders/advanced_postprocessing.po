#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "高級後期處理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"本教學描述了一種在 Godot 中進行後期處理的高級方法。值得注意的是，它將解釋如何"
"編寫使用深度緩衝區的後期處理著色器。您應該已經熟悉後期處理，特別是使用:ref:`"
"自訂後期處理教學 <doc_custom_postprocessing>`中介紹的方法。"

msgid "Full screen quad"
msgstr "全屏四邊形"

msgid "The depth buffer cannot be accessed"
msgstr "無法存取深度緩衝區"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "在編輯器中看不到後期處理著色器的效果"

msgid ""
"To get around the limitation on using the depth buffer, use a :ref:"
"`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"要解決使用深度緩衝區的限制，請使用 :ref:`MeshInstance <class_MeshInstance>` "
"並設定 :ref:`QuadMesh <class_QuadMesh>` 像素。這樣我們就可以使用空間著色器，"
"並且可以存取該場景的深度紋理。接下來，請使用頂點著色器讓這個四邊形始終覆蓋螢"
"幕，以便始終應用後期處理效果，包括在編輯器中。"

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"首先，新建一個 MeshInstance，並將其網格設定為 QuadMesh。這將建立一個以座標 "
"``(0, 0, 0)`` 為中心的四邊形，寬度和高度均為 ``1``。請將其寬度和高度設定為 "
"``2``。現在，這個四邊形在世界空間中佔據了原點的位置；但是，我們希望它能隨著相"
"機的移動而移動，這樣它就能始終覆蓋整個螢幕。為此，我們將繞過座標轉換，該轉換"
"通過不同的座標空間轉換頂點位置，並將頂點視為已位於裁剪空間中。"

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"即使有了這樣的頂點著色器，這個四邊形仍會消失。這是因為視錐剔除的緣故，是在 "
"CPU 上完成的。視錐剔除使用相機矩陣和 Mesh 的 AABB 來確定 Mesh 是否可見，然後"
"再傳遞給 GPU。CPU 不知道我們對頂點做了什麼，所以它認為指定的座標指的是世界座"
"標，而不是裁剪空間的座標，這就導致了 Godot 在我們旋轉、離開場景中心時對四邊形"
"進行剔除。為了防止四邊形被剔除，有這麼幾個選項："

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr "將 QuadMesh 作為子節點新增到相機，這樣相機就會始終指向它"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr "在 QuadMesh 中將幾何屬性 ``extra_cull_margin`` 設定得盡可能大"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"第二個選項會確保四邊形在編輯器中可見，而第一個選項能夠保證即使相機移出剔除邊"
"緣也它仍可見。您也可以同時使用這兩個選項。"

msgid "Depth texture"
msgstr "深度紋理"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"要讀取深度紋理，我們首先需要使用「hint_depth_texture」來建立一個設定為深度緩"
"衝區的均勻紋理。"

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr "定義後，可以使用“texture()”函式讀取深度紋理。"

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"與存取螢幕紋理類似，存取深度紋理只有在從目前視口讀取時才能進行。深度紋理不能"
"從你已經算繪的另一個視口中存取。"

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"首先, 取螢幕空間座標並將其轉換為正規化裝置座標(NDC).NDC從 ``-1`` 到 ``1`` , "
"類似於裁剪空間座標. 使用 ``SCREEN_UV`` 來重建NDC的 ``x`` 和 ``y`` 軸, 以及 "
"``z`` 的深度值."

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"通過將NDC乘以 ``INV_PROJECTION_MATRIX`` , 將NDC轉換成視圖空間. 回顧一下, 視圖"
"空間給出了相對於相機的位置, 所以 ``z`` 值將給我們提供到該點的距離."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"因為相機是朝向負的 ``z`` 方向的, 所以座標會有一個負的 ``z`` 值. 為了得到一個"
"可用的深度值, 我們必須否定 ``view.z`` ."

msgid "An optimization"
msgstr "優化"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://michaldrobot."
"com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. However, the "
"benefit is quite small and only beneficial when running especially complex "
"fragment shaders."
msgstr ""
"您可以使用單個大三角形而不是使用全屏四邊形. 解釋的原因在 `這裡 <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-"
"passes>`_ . 但是, 這種好處非常小, 只有在運作特別複雜的片段著色器時才有用."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"將MeshInstance中的Mesh設定為 :ref:`ArrayMesh <class_ArrayMesh>`. ArrayMesh是"
"一個工具, 允許您從頂點, 法線, 顏色等方便地從陣列建構網格."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr "現在, 將腳本附加到MeshInstance並使用以下程式碼:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"三角形在標準化裝置座標中指定. 回想一下,NDC在 ``x`` 和 ``y`` 方向都從 ``-1`` "
"到 ``1`` 運作. 這使得螢幕 ``2`` 單位寬, ``2`` 單位高. 為了用一個三角形覆蓋整"
"個螢幕, 使用一個 ``4`` 單位寬和 ``4`` 單位高的三角形, 高度和寬度加倍."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr "從上面分配相同的頂點著色器, 所有內容應該看起來完全相同."
