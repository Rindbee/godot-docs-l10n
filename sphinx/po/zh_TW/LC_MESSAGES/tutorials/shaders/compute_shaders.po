#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "使用計算著色器"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"本教學將帶您一步步建立一個簡單的計算著色器。在開始之前，先簡介計算著色器的背"
"景及它如何與 Godot 配合運作。"

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"本教學假設您已大致熟悉著色器。如果您是新手，請在繼續本教學前先閱"
"讀 :ref:`doc_introduction_to_shaders` 及 :ref:`您的第一個著色器 <toc-your-"
"first-shader>`。"

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"計算著色器是一種特殊類型的著色器程式，主要用於通用運算。換句話說，它比頂點著"
"色器和片段著色器更有彈性，因為它沒有固定用途（例如轉換頂點或寫入顏色到影"
"像）。不同於片段或頂點著色器，計算著色器的幕後運作極少。您寫的程式碼就是 GPU "
"執行的內容，沒有多餘處理。這讓它非常適合將大量運算交由 GPU 處理。"

msgid "Now let's get started by creating a short compute shader."
msgstr "現在讓我們開始建立一個簡單的計算著色器。"

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"首先，請在您喜愛的**外部**文字編輯器中，在專案資料夾內建立一個名為 "
"``compute_example.glsl`` 的新檔案。在 Godot 中編寫計算著色器時，須直接撰寫 "
"GLSL。Godot 的著色器語言是以 GLSL 為基礎。如果您熟悉 Godot 的一般著色器，下面"
"的語法應該會很眼熟。"

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"計算著色器僅能在基於 RenderingDevice 的算繪器（Forward+ 或 Mobile 算繪器）中"
"使用。請確認您已設定為 Forward+ 或 Mobile 算繪器（可在編輯器右上角調整）才能"
"依照本教學操作。"

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"請注意，即使行動裝置在技術上支援計算著色器，實際支援度通常很差（多因驅動程式"
"問題）。"

msgid "Let's take a look at this compute shader code:"
msgstr "來看看這個計算著色器的範例程式碼："

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"這段程式碼會將一個浮點陣列的每個元素都乘以 2，然後把結果存回緩衝區陣列。現在"
"讓我們逐行說明。"

msgid "These two lines communicate two things:"
msgstr "這兩行代表了兩個重點："

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"下列程式碼是一個計算著色器。這是 Godot 專用的提示，讓編輯器能正確匯入該著色器"
"檔案。"

msgid "The code is using GLSL version 450."
msgstr "這段程式碼採用 GLSL 版本 450。"

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr "自訂計算著色器時，這兩行一般都不必修改。"

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"接下來，我們要定義每個工作群組內的呼叫（invocation）數量。呼叫代表在同一工作"
"群組中執行的著色器實例。當我們從 CPU 啟動計算著色器時，需要指定要執行多少個工"
"作群組。各個工作群組之間是平行運作的，彼此無法互相存取資料；但同一群組內的呼"
"叫彼此之間則有部分有限的存取權。"

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr "可以把工作群組和呼叫想像成一個巨大的巢狀 ``for`` 迴圈。"

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"工作群組與呼叫屬於進階主題。現在只需記得：我們將在每個工作群組中執行 2 次呼"
"叫。"

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"這裡我們說明計算著色器可存取的記憶體資訊。 ``layout`` 屬性讓我們指定著色器要"
"從哪個緩衝區讀寫，稍後在 CPU 端也要以相同的 ``set``、``binding`` 位置對應。"

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"``restrict`` 關鍵字用來告知著色器這個緩衝區只會在這個著色器的單一地方存取。換"
"句話說，不會在別的 ``set`` 或 ``binding`` 索引中再次綁定這個緩衝區。這有助於"
"著色器編譯器最佳化程式碼。只要能用 ``restrict``，就盡量使用。"

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"這是一個*未定大小*的緩衝區，也就是說它可以是任意長度。所以必須小心不要存取超"
"過緩衝區大小的索引。"

msgid ""
"Finally, we write the ``main`` function which is where all the logic "
"happens. We access a position in the storage buffer using the "
"``gl_GlobalInvocationID`` built-in variables. ``gl_GlobalInvocationID`` "
"gives you the global unique ID for the current invocation."
msgstr ""
"最後，我們撰寫 ``main`` 函式，所有邏輯都在這裡執行。可利用內建變數 "
"``gl_GlobalInvocationID`` 存取儲存緩衝區的指定位置。"
"``gl_GlobalInvocationID`` 會提供目前呼叫的全域唯一 ID。"

msgid ""
"To continue, write the code above into your newly created "
"``compute_example.glsl`` file."
msgstr ""
"接下來，請將上述程式碼寫入你剛剛建立的 ``compute_example.glsl`` 檔案中。"

msgid "Create a local RenderingDevice"
msgstr "建立本地 RenderingDevice"

msgid ""
"To interact with and execute a compute shader, we need a script. Create a "
"new script in the language of your choice and attach it to any Node in your "
"scene."
msgstr ""
"為了操作並執行計算著色器，我們需要寫一份腳本。請用你慣用的語言新增一支腳本，"
"並掛載到場景裡任一個節點。"

msgid ""
"Now to execute our shader we need a local :ref:`class_RenderingDevice` which "
"can be created using the :ref:`class_RenderingServer`:"
msgstr ""
"現在要執行剛剛的著色器，必須建立一個本地 :ref:`class_RenderingDevice`，可以透"
"過 :ref:`class_RenderingServer` 來產生："

msgid ""
"After that, we can load the newly created shader file "
"``compute_example.glsl`` and create a precompiled version of it using this:"
msgstr ""
"完成後，可以載入新建立的著色器檔案 ``compute_example.glsl``，並依下列方式建立"
"它的預編譯版本："

msgid ""
"Local RenderingDevices cannot be debugged using tools such as `RenderDoc "
"<https://renderdoc.org/>`__."
msgstr ""
"本地 RenderingDevice 無法用如 `RenderDoc <https://renderdoc.org/>`__ 等工具偵"
"錯。"

msgid "Provide input data"
msgstr "提供輸入資料"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"如前所述，我們希望將一個陣列作為輸入，讓著色器把每個元素乘以 2，取得運算結"
"果。"

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"我們需要建立一個緩衝區，把資料傳給計算著色器。這裡我們要處理的是浮點數陣列，"
"因此會使用儲存緩衝區（storage buffer）。儲存緩衝區允許 CPU 與 GPU 間以位元組"
"陣列方式傳輸資料。"

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr "現在我們來初始化一個浮點數陣列並建立對應的儲存緩衝區："

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"緩衝區準備就緒後，還需告知算繪裝置使用這個緩衝區。為此我們要建立一個 uniform"
"（就像在一般著色器裡做的），再把它加入 uniform set，之後就能傳遞給著色器。"

msgid "Defining a compute pipeline"
msgstr "定義計算管線"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr ""
"下一步，要建立一組 GPU 能執行的指令。我們需要準備一個管線（pipeline）及一個計"
"算清單（compute list）。"

msgid "The steps we need to do to compute our result are:"
msgstr "計算結果所需的步驟如下："

msgid "Create a new pipeline."
msgstr "建立新的管線。"

msgid "Begin a list of instructions for our GPU to execute."
msgstr "開始一組 GPU 要執行的指令清單。"

msgid "Bind our compute list to our pipeline"
msgstr "將計算清單綁定到管線"

msgid "Bind our buffer uniform to our pipeline"
msgstr "將緩衝區 uniform 綁定到管線"

msgid "Specify how many workgroups to use"
msgstr "指定要使用的工作群組數量"

msgid "End the list of instructions"
msgstr "結束指令清單"

msgid ""
"Note that we are dispatching the compute shader with 5 work groups in the X "
"axis, and one in the others. Since we have 2 local invocations in the X axis "
"(specified in our shader), 10 compute shader invocations will be launched in "
"total. If you read or write to indices outside of the range of your buffer, "
"you may access memory outside of your shaders control or parts of other "
"variables which may cause issues on some hardware."
msgstr ""
"請注意，我們在 X 軸分派了 5 個工作群組，其餘軸各 1 個。由於著色器設定 X 軸有 "
"2 次本地呼叫，總共會執行 10 次計算著色器呼叫。若你讀寫的索引超過緩衝區範圍，"
"可能會誤存取到著色器以外的記憶體或其他變數，可能導致某些硬體出現問題。"

msgid "Execute a compute shader"
msgstr "執行計算著色器"

msgid ""
"After all of this we are almost done, but we still need to execute our "
"pipeline. So far we have only recorded what we would like the GPU to do; we "
"have not actually run the shader program."
msgstr ""
"經過上述步驟，我們已經快完成了，但還需執行剛剛建立的管線。到目前為止，我們只"
"是記錄 GPU 要執行的內容，尚未真正啟動著色器程式。"

msgid ""
"To execute our compute shader we need to submit the pipeline to the GPU and "
"wait for the execution to finish:"
msgstr "要執行計算著色器，必須將管線提交給 GPU，並等待執行完成："

msgid ""
"Ideally, you would not call ``sync()`` to synchronize the RenderingDevice "
"right away as it will cause the CPU to wait for the GPU to finish working. "
"In our example, we synchronize right away because we want our data available "
"for reading right away. In general, you will want to wait *at least* 2 or 3 "
"frames before synchronizing so that the GPU is able to run in parallel with "
"the CPU."
msgstr ""
"理想情況下，不要立刻呼叫 ``sync()`` 同步 RenderingDevice，因為這會讓 CPU 停"
"等 GPU 完成。這裡為了立即取得資料方便教學才馬上同步。通常建議至少等 2~3 幀後"
"再同步，這樣 GPU 才能與 CPU 平行運作，提升效率。"

msgid ""
"Long computations can cause Windows graphics drivers to \"crash\" due "
"to :abbr:`TDR (Timeout Detection and Recovery)` being triggered by Windows. "
"This is a mechanism that reinitializes the graphics driver after a certain "
"amount of time has passed without any activity from the graphics driver "
"(usually 5 to 10 seconds)."
msgstr ""
"長時間運算可能會因 Windows 觸發 :abbr:`TDR (Timeout Detection and Recovery，"
"逾時偵測與復原)` 而讓圖形驅動程式「當機」。這是 Windows 在圖形驅動無回應一段"
"時間（通常 5~10 秒）後，會自動重新初始化驅動程式的機制。"

msgid ""
"Depending on the duration your compute shader takes to execute, you may need "
"to split it into multiple dispatches to reduce the time each dispatch takes "
"and reduce the chances of triggering a TDR. Given TDR is time-dependent, "
"slower GPUs may be more prone to TDRs when running a given compute shader "
"compared to a faster GPU."
msgstr ""
"依據計算著色器執行所需時間，可能需要拆成多次調度，以縮短每次執行時間、降低觸"
"發 TDR 的風險。由於 TDR 與執行時間有關，較慢的 GPU 執行同樣著色器時比高速 "
"GPU 更容易遇到 TDR 問題。"

msgid "Retrieving results"
msgstr "取得運算結果"

msgid ""
"You may have noticed that, in the example shader, we modified the contents "
"of the storage buffer. In other words, the shader read from our array and "
"stored the data in the same array again so our results are already there. "
"Let's retrieve the data and print the results to our console."
msgstr ""
"您可能注意到，在範例著色器中，我們直接修改了儲存緩衝區內容。換言之，著色器從"
"原本的陣列讀取資料後，再把結果寫回同一陣列。因此結果已經在那裡。現在我們來取"
"出資料，並將結果印在控制台上。"

msgid ""
"With that, you have everything you need to get started working with compute "
"shaders."
msgstr "至此，您已具備開始操作計算著色器的一切基礎知識。"

msgid ""
"The demo projects repository contains a `Compute Shader Heightmap demo "
"<https://github.com/godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__ This project performs heightmap image "
"generation on the CPU and GPU separately, which lets you compare how a "
"similar algorithm can be implemented in two different ways (with the GPU "
"implementation being faster in most cases)."
msgstr ""
"示範專案倉庫中有一個 `Compute Shader Heightmap demo <https://github.com/"
"godotengine/godot-demo-projects/tree/master/misc/"
"compute_shader_heightmap>`__，這個專案會分別在 CPU 和 GPU 上產生高度圖，讓您"
"比較同一演算法在兩種方式下的實作（大多數情況下 GPU 會更快）。"
