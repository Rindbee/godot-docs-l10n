#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "矩陣與轉換"

msgid "Introduction"
msgstr "前言"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"在閱讀本教學之前，建議你先完整閱讀並理解 :ref:`doc_vector_math` 教學，因為本"
"教學需要具備向量的基礎知識。"

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"本教學介紹*轉換*（transformation），以及我們如何在 Godot 中利用矩陣來表示這些"
"轉換。這並不是一份完整的矩陣深入指南。轉換大多用於平移、旋轉與縮放，因此我們"
"會著重於如何用矩陣來表達這些操作。"

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` "
"and :ref:`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"本指南主要聚焦在 2D，使用 :ref:`class_Transform2D` 和 :ref:`class_Vector2`，"
"但其實 3D 的運作方式也非常類似。"

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"如同前一篇教學提到，請記得在 Godot 中，2D 的 Y 軸是*向下*的。這與多數學校裡學"
"的線性代數（Y 軸向上）正好相反。"

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"慣例上，X 軸為紅色，Y 軸為綠色，Z 軸為藍色。本教學的配色遵循這個慣例，不過我"
"們也會用藍色來標示原點向量。"

msgid "Matrix components and the Identity matrix"
msgstr "矩陣分量與單位矩陣"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"單位矩陣代表一個沒有平移、沒有旋轉、沒有縮放的轉換。讓我們先看看單位矩陣，以"
"及它的各個分量與畫面上呈現的樣子之間的關係。"

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr "矩陣有行和列，而轉換矩陣對各自的意義有特定的約定。"

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"如上圖所示，紅色的 X 向量對應到矩陣的第一欄，綠色的 Y 向量對應到第二欄。更動"
"這些欄位會改變這些向量。接下來的例子會說明如何操作它們。"

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"你通常不需要直接操作行，因為我們大多處理的是列。不過，你也可以把矩陣的行看作"
"是用來表現哪些向量會對特定方向的移動產生影響。"

msgid ""
"When we refer to a value such as ``t.x.y``, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, "
"``t.x.x`` is top-left, ``t.y.x`` is top-right, and ``t.y.y`` is bottom-"
"right, where ``t`` is the Transform2D."
msgstr ""
"當我們提到像是 ``t.x.y`` 這種寫法時，指的是 X 列向量的 Y 分量，也就是矩陣的左"
"下角。同理，``t.x.x`` 是左上角，``t.y.x`` 是右上角，``t.y.y`` 是右下角，這裡"
"的 t 是 Transform2D。"

msgid "Scaling the transformation matrix"
msgstr "縮放轉換矩陣"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"縮放是最容易理解的操作之一。讓我們先把 Godot 標誌放在向量下方，這樣可以直觀看"
"到縮放對物件的效果："

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"要縮放這個矩陣，只需要將每個分量乘上想要的縮放比例。假設我們要放大為 2 倍，1 "
"乘以 2 變成 2，0 乘以 2 還是 0，結果是這樣："

msgid "To do this in code, we multiply each of the vectors:"
msgstr "在程式碼中，只要把每個向量乘上縮放值就可以了："

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"如果想恢復原本的大小，只需要將每個分量乘上 0.5。這就是縮放轉換矩陣的全部重"
"點。"

msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use ``length()`` on each of the column vectors."
msgstr ""
"如果想從現有的轉換矩陣計算物件的縮放比例，可以對每個列向量使用 ``length()`` "
"方法。"

msgid ""
"In actual projects, you can use the ``scaled()`` method to perform scaling."
msgstr "在實際專案中，可以直接用 ``scaled()`` 方法來進行縮放。"

msgid "Rotating the transformation matrix"
msgstr "旋轉轉換矩陣"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr "和剛才一樣，先用 Godot 標誌在單位矩陣下方作為起點："

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"舉個例子，假設我們想將 Godot 標誌順時針旋轉 90 度。目前 X 軸向右，Y 軸向下。"
"如果我們腦中旋轉這些向量，可以想像新的 X 軸會指向下方，新的 Y 軸會指向左方。"

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"你可以想像同時抓住 Godot 標誌和它的向量，然後繞中心旋轉。轉完後，向量的方向就"
"是此時矩陣的內容。"

msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"``Vector2.DOWN`` and ``Vector2.LEFT``. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"我們需要用標準座標來表示「下」和「左」，所以 X 設為 (0, 1)，Y 設為 (-1, 0)。"
"這正好就是 ``Vector2.DOWN`` 和 ``Vector2.LEFT`` 的值。這麼做就能達到我們想要"
"的旋轉效果："

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"如果你還是不太理解上面說明，可以試著：剪一張正方形紙，在上面畫上 X、Y 向量，"
"放在格子紙上，然後旋轉，觀察端點位置的變化。"

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"要用程式碼實作旋轉，我們需要用公式計算矩陣分量。這張圖展示了如何用旋轉角度計"
"算轉換矩陣的公式。如果這部分看起來很難，不用擔心，這已經是你需要學的最難部"
"分。"

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or `PI/"
"2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"Godot 以弧度（radian）表示所有旋轉，不使用角度。一圈是 `TAU` 或 `PI*2` 弧度，"
"四分之一圈（90 度）是 `TAU/4` 或 `PI/2` 弧度。用 `TAU` 的話，程式碼通常更直覺"
"易懂。"

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"有趣的小知識：Godot 裡不只 Y 軸向下，旋轉也是以順時針為正。這些差異和 Y 向"
"上、逆時針為正的數學系統正好「互相抵消」，所以所有的數學與三角函數行為都一"
"樣。你可以把兩個系統的旋轉都想成「從 X 指向 Y」。"

msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug "
"in a value of 0.5 to the formula above and evaluate to find what the actual "
"values should be:"
msgstr ""
"如果要旋轉 0.5 弧度（約 28.65 度），只要將 0.5 代入上面的公式，就能計算出實際"
"的矩陣分量："

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr "在程式碼中這樣實作（把腳本掛在 Node2D）："

msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use ``atan2(t.x.y, t.x.x)``, where t is the Transform2D."
msgstr ""
"若要從現有的轉換矩陣計算物件的旋轉角度，可以用 ``atan2(t.x.y, t.x.x)``，其中 "
"t 為 Transform2D。"

msgid ""
"In actual projects, you can use the ``rotated()`` method to perform "
"rotations."
msgstr "在實際專案中，建議用 ``rotated()`` 方法來旋轉。"

msgid "Basis of the transformation matrix"
msgstr "轉換矩陣的基底"

msgid ""
"So far we have only been working with the ``x`` and ``y``, vectors, which "
"are in charge of representing rotation, scale, and/or shearing (advanced, "
"covered at the end). The X and Y vectors are together called the *basis* of "
"the transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"到目前為止，我們只操作了 ``x`` 和 ``y`` 兩個向量，這兩個向量負責表現旋轉、縮"
"放和/或剪切（進階內容後面會提到）。X 和 Y 向量合稱為轉換矩陣的*基底*"
"（basis）。「基底」和「基底向量」這兩個術語很重要，務必記住。"

msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has "
"three :ref:`class_Vector2` values: ``x``, ``y``, and ``origin``. The "
"``origin`` value is not part of the basis, but it is part of the transform, "
"and we need it to represent position. From now on we'll keep track of the "
"origin vector in all examples. You can think of origin as another column, "
"but it's often better to think of it as completely separate."
msgstr ""
"你可能注意到 :ref:`class_Transform2D` 其實有三個 :ref:`class_Vector2` 欄位："
"``x``、``y`` 和 ``origin``。其中 ``origin`` 不是基底的一部分，但它屬於轉換本"
"身，用來表示位置。從這裡開始，所有例子都會標記 origin 向量。你可以把 origin "
"當作另一欄，但通常把它當作完全獨立的成分會比較好理解。"

msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it "
"from :ref:`class_Transform3D` (which is composed of one :ref:`class_Basis` "
"and one extra :ref:`class_Vector3` for the origin)."
msgstr ""
"請注意，在 3D 裡，Godot 有獨立的 :ref:`class_Basis` 結構，專門用來存放三個基"
"底的 :ref:`class_Vector3`。這是因為程式邏輯會變得複雜，將它"
"和 :ref:`class_Transform3D` （由一個 :ref:`class_Basis` 和一"
"個 :ref:`class_Vector3` 原點組成）分開設計會更好。"

msgid "Translating the transformation matrix"
msgstr "平移轉換矩陣"

msgid ""
"Changing the ``origin`` vector is called *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"更改 ``origin`` 向量稱為*平移*（translate）轉換矩陣。平移其實就是把物件「移"
"動」到新位置，但不會有任何旋轉。"

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"我們來看個例子更好理解。這次還是從單位轉換開始，不過我們這次會標示出 origin "
"向量的位置。"

msgid ""
"If we want to move the object to a position of (1, 2), we need to set its "
"``origin`` vector to (1, 2):"
msgstr "如果要把物件移到 (1, 2)，只要將它的 ``origin`` 向量設為 (1, 2)："

msgid ""
"There is also a ``translated_local()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The "
"``translated_local()`` method will translate the object *relative to its own "
"rotation*. For example, an object rotated 90 degrees clockwise will move to "
"the right when ``translated_local()`` with ``Vector2.UP``. To translate "
"*relative to the global/parent frame* use ``translated()`` instead."
msgstr ""
"另外還有一個 ``translated_local()`` 方法，它和直接更改 `origin` 的方式不同。"
"``translated_local()`` 會讓物件依照*自身旋轉座標*進行平移。例如，一個已經順時"
"針旋轉 90 度的物件，如果用 ``translated_local(Vector2.UP)``，會向右平移。若要"
"*依照全域/父節點座標系*來平移，則應使用 ``translated()``。"

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"Godot 的 2D 採用像素為單位的座標系，所以在實際專案中，平移通常會用到數百這種"
"等級的數值。"

msgid "Putting it all together"
msgstr "總結與實作"

msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a project with a Sprite2D node and use the Godot logo "
"for the texture resource."
msgstr ""
"現在我們要把前面學到的全都用在同一個轉換上。你可以建立一個專案，新增 "
"Sprite2D 節點，並使用 Godot 標誌當作紋理。"

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"設定平移為 (350, 150)、旋轉 -0.5 弧度、縮放為 3。我貼了截圖和完整程式碼，不過"
"建議你不要看答案自己試著重現一次！"

msgid "Shearing the transformation matrix (advanced)"
msgstr "剪切轉換矩陣（進階）"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"如果你只想知道怎麼*用*轉換矩陣，可以跳過這一節。本節會討論轉換矩陣較少用到的"
"一個特性，幫助你更深入理解其原理。"

msgid "Node2D provides a shearing property out of the box."
msgstr "Node2D 內建支援剪切屬性。"

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"你可能發現，轉換的自由度比上述操作加總還多。2D 轉換矩陣的基底（兩"
"個 :ref:`class_Vector2`）總共有四個數值，但只用旋轉和縮放（用一個角度和一個 "
"Vector2）僅有三個數值。這個「多出來」的自由度就稱為*剪切*（shearing）。"

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"通常，基底向量都是互相垂直的。不過在某些時候，剪切也會有用，而且理解剪切有助"
"於更深入掌握轉換矩陣的本質。"

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr "為了更直觀，讓我們把一個格線疊加在 Godot 標誌上："

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"這個格線上的每個點都是基底向量加總得來。右下角是 X+Y，右上角是 X-Y。只要你改"
"變基底向量，整個格線也會跟著變形，因為格線就是由基底向量組成。格線上現在彼此"
"平行的線，無論怎麼改變基底，都還是會保持平行。"

msgid "As an example, let's set Y to (1, 1):"
msgstr "例如，現在將 Y 設為 (1, 1)："

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr ""
"你不能在編輯器直接設定 Transform2D 的原始值，因此如果想要剪切物件，*一定* 要"
"用程式碼來達成。"

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"由於基底向量不再垂直，物件就產生了剪切。格線下方中間（對自身為 (0, 1)）現在在"
"世界座標的 (1, 1)。"

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"物件內部的座標在紋理中稱為 UV 座標，這裡我們也借用這個術語。若要從相對座標算"
"出世界位置，用 U * X + V * Y 這個公式。U、V 為數值，X、Y 為基底向量。"

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"格線右下角（UV 座標為 (1, 1)）在世界座標是 (2, 1)，計算方式是 X*1 + Y*1，也就"
"是 (1, 0) + (1, 1)，結果為 (2, 1)。這和我們觀察到的圖像右下角位置一致。"

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"同樣地，格線右上角（UV 座標是 (1, -1)）在世界座標是 (0, -1)，計算方式是 X*1 "
"+ Y*(-1)，也就是 (1, 0) - (1, 1) = (0, -1)。這和我們觀察到的圖像右上角相符。"

msgid ""
"Hopefully you now fully understand how a transformation matrix affects the "
"object, and the relationship between the basis vectors and how the object's "
"\"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"希望你現在已經完全理解轉換矩陣如何影響物件，以及基底向量和物件「UV」或「內部"
"座標」之間的關係，以及它們如何被映射到世界座標。"

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"在 Godot 裡，所有轉換運算都是相對於父節點進行。當我們提到「世界座標」時，其實"
"是相對於節點的父節點（如果有的話）。"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"如果想要進一步解釋，可以參考 3Blue1Brown 的線性轉換精采影片：https://"
"www.youtube.com/watch?v=kYB8IZa5AuE"

msgid "Practical applications of transforms"
msgstr "轉換的實用應用"

msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Node3D` "
"nodes parented to each other."
msgstr ""
"在實際專案中，你經常會在多層轉換下運作，也就是多個 :ref:`class_Node2D` "
"或 :ref:`class_Node3D` 互為父子節點。"

msgid ""
"However, it's useful to understand how to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` "
"or :ref:`class_Transform3D` to manually calculate transforms of nodes."
msgstr ""
"不過，理解如何手動計算所需的轉換值非常有用。我們會介紹如何"
"用 :ref:`class_Transform2D` 或 :ref:`class_Transform3D` 來手動計算節點的轉"
"換。"

msgid "Converting positions between transforms"
msgstr "在轉換之間轉換座標"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"有很多情境會需要在不同轉換座標系之間進行座標轉換。例如，當你有一個相對於玩家"
"的座標，想求出對應的世界座標（父節點座標），或是已知世界座標，想知道它在玩家"
"座標系下的位置。"

msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the ``*`` operator:"
msgstr "我們可以用 ``*`` 運算子來取得相對於玩家的向量在世界座標下的位置："

msgid ""
"And we can use the ``*`` operator in the opposite order to find a what world "
"space position would be if it was defined relative to the player:"
msgstr ""
"同理，也能用 ``*`` 運算子的相反運算來查出一個世界座標對應到玩家座標系的相對位"
"置："

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"如果你已經知道轉換本身位於 (0, 0)，可以直接用 ``basis_xform`` 或 "
"``basis_xform_inv`` 這類方法，省略掉平移的處理。"

msgid "Moving an object relative to itself"
msgstr "相對於自身移動物件"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"一個常見操作（尤其在 3D 遊戲中）是讓物件相對於自己移動。例如在第一人稱射擊遊"
"戲裡，按下 :kbd:`W` 時，角色會沿 -Z 軸向前移動。"

msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can add multiples "
"of the basis vectors to move an object relative to itself."
msgstr ""
"由於基底向量表示物件相對於父節點的方向，而 origin 向量代表位置，所以只要將基"
"底向量乘倍數後加到 origin，就能達到相對於自身移動的效果。"

msgid "This code moves an object 100 units to its own right:"
msgstr "以下程式碼會讓物件往自己的右方移動 100 單位："

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "若是在 3D 空間，請將 ``x`` 改成 ``basis.x``。"

msgid ""
"In actual projects, you can use ``translate_object_local`` in 3D or "
"``move_local_x`` and ``move_local_y`` in 2D to do this."
msgstr ""
"在實務上，3D 可以用 ``translate_object_local``，2D 可以用 ``move_local_x`` "
"與 ``move_local_y`` 來達成同樣效果。"

msgid "Applying transforms onto transforms"
msgstr "轉換疊加"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"轉換最重要的一點之一，就是你可以將多個轉換互相疊加。父節點的轉換會影響所有子"
"節點。讓我們來分析一個例子。"

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"在這張圖中，子節點的每個分量名稱後面都有個「2」以便和父節點區分。雖然數字很多"
"看起來很雜，其實每個數字都出現在箭頭旁和矩陣裡，幾乎一半的數字其實都是零。"

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"這裡父節點只做了縮放 (2, 1)，子節點做了縮放 (0.5, 0.5)，兩個節點都有各自的位"
"置設定。"

msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's ``origin`` vector is set to (1, "
"1), but this actually moves it (2, 1) in world space, due to the parent "
"node's basis vectors."
msgstr ""
"所有子節點的轉換都會受到父節點的影響。子節點縮放 (0.5, 0.5) 看起來是 1:1 的正"
"方形，但這只是在父節點座標系下。在世界座標中，子節點的 X 向量會變成 (1, 0)，"
"因為會被父節點的基底向量縮放。同理，子節點 ``origin`` 設成 (1, 1)，但實際會被"
"移動到 (2, 1)，這也是因為父節點的基底向量所致。"

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr "要手動算出子節點的世界座標轉換，可用如下程式碼："

msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the ``*`` operator:"
msgstr ""
"實務上，可以直接用 ``*`` 運算子把一個轉換套用到另一個，求出子節點的世界轉換："

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "矩陣相乘時，順序很重要！不要搞混。"

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "最後，套用單位轉換不會產生任何效果。"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"如果還想了解更多，可以參考 3Blue1Brown 關於矩陣組合的精彩影片：https://"
"www.youtube.com/watch?v=XkY2DOUCWMU"

msgid "Inverting a transformation matrix"
msgstr "反轉轉換矩陣"

msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations. Let's take a look "
"at a few examples."
msgstr ""
"``affine_inverse`` 函數會回傳一個能「反轉」前一個轉換的轉換。這在某些情況下很"
"有用，以下有幾個例子。"

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr "將反轉後的轉換和原本的轉換相乘，可以消除所有轉換效果："

msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position:"
msgstr "對座標先做轉換，再做反轉換，結果會回到原本座標："

msgid "How does it all work in 3D?"
msgstr "這些在 3D 空間下怎麼運作？"

msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform3D`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"轉換矩陣最棒的特點之一，就是 2D 和 3D 的原理和用法都很像。上面 2D 所有程式碼"
"與公式，在 3D 幾乎一樣，只有三個差異：多了一個軸（Z），每個軸"
"用 :ref:`class_Vector3` 表示，而且 Godot 會把 :ref:`class_Basis` "
"和 :ref:`class_Transform3D` 分開存放，這樣設計是因為 3D 的數學運算較複雜。"

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"3D 空間下，平移、旋轉、縮放、剪切等操作的概念和 2D 完全一樣。要縮放，直接將每"
"個分量相乘；要旋轉，改變每個基底向量的指向；要平移，操作 origin；要剪切，讓基"
"底向量不再垂直。"

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"你可以多實驗幾次轉換，體會它們的效果。Godot 允許你在屬性面板中直接編輯 3D 轉"
"換矩陣。你也可以下載這個專案，裡面用彩色線條和立方體幫助你在 2D/3D 下觀"
"察 :ref:`class_Basis` 向量與原點：https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"

msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"你無法在 Godot 4.0 的屬性檢視器直接編輯 Node2D 的轉換矩陣。未來 Godot 版本或"
"許會改進這一點。"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"如果想要更深入了解，建議參考 3Blue1Brown 關於 3D 線性轉換的精彩影片：https://"
"www.youtube.com/watch?v=rHLEWRxRGiM"

msgid "Representing rotation in 3D (advanced)"
msgstr "3D 中的旋轉表示法（進階）"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"2D 和 3D 轉換矩陣最大的差異在於：如果不依靠基底向量，該如何單獨表達旋轉這個操"
"作。"

msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, rotation is too complex to represent as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"2D 可以用很簡單的方式（atan2 反三角函數）在矩陣和角度之間轉換。但在 3D，旋轉"
"太複雜，無法用單一數字表示。有一種叫「歐拉角」的方式可以用三個數字來描述旋"
"轉，不過這個方法有很多限制，大多數情況下並不好用，只有很簡單的場景才適合。"

msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quaternion` struct. My "
"suggestion to you is to completely ignore how they work under-the-hood, "
"because they are very complicated and unintuitive."
msgstr ""
"在 3D，我們通常不用角度來描述旋轉，而是直接用轉換基底（Godot 幾乎到處用這套）"
"或用四元數（quaternion）。Godot 用 :ref:`class_Quaternion` 結構來表示四元數。"
"建議你不用深究四元數的底層原理，因為它非常複雜且不直觀。"

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr "但如果你真的想深入了解，這裡有幾個不錯的參考資源，建議照順序閱讀："

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.youtube.com/watch?v=mvmuCPvRoWQ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.youtube.com/watch?v=d4EgbgTm0Bg"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"
