#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Beziers, curves and paths"
msgstr "貝茲、曲線與路徑"

msgid ""
"Bezier curves are a mathematical approximation of natural geometric shapes. "
"We use them to represent a curve with as little information as possible and "
"with a high level of flexibility."
msgstr ""
"貝茲曲線是一種自然幾何形狀的數學近似。我們用它們來以最少的資訊，高度靈活地表"
"示一條曲線。"

msgid ""
"Unlike more abstract mathematical concepts, Bezier curves were created for "
"industrial design. They are a popular tool in the graphics software industry."
msgstr ""
"不同於更抽象的數學概念，貝茲曲線是專為工業設計而創造的。它們是圖形軟體產業中"
"常用的工具。"

msgid ""
"They rely on :ref:`interpolation<doc_interpolation>`, which we saw in the "
"previous article, combining multiple steps to create smooth curves. To "
"better understand how Bezier curves work, let's start from its simplest "
"form: Quadratic Bezier."
msgstr ""
"它們依賴於 :ref:`插值 <doc_interpolation>` （我們在前一篇文章中已介紹），結合"
"多個步驟來建立平滑的曲線。為了更好理解貝茲曲線的運作方式，讓我們從最簡單的形"
"式──二次貝茲曲線開始。"

msgid "Quadratic Bezier"
msgstr "二次貝茲曲線"

msgid "Take three points, the minimum required for Quadratic Bezier to work:"
msgstr "取三個點，這是二次貝茲曲線所需的最小數量："

msgid ""
"To draw a curve between them, we first interpolate gradually over the two "
"vertices of each of the two segments formed by the three points, using "
"values ranging from 0 to 1. This gives us two points that move along the "
"segments as we change the value of ``t`` from 0 to 1."
msgstr ""
"要在這三個點之間繪製一條曲線，我們首先對由這三個點形成的兩個線段的端點進行插"
"值（範圍從 0 到 1）。這樣當我們將 ``t`` 從 0 變到 1，就會得到兩個沿線段移動的"
"點。"

msgid ""
"We then interpolate ``q0`` and ``q1`` to obtain a single point ``r`` that "
"moves along a curve."
msgstr "然後將 ``q0`` 和 ``q1`` 做插值，得到一個隨著曲線移動的點 ``r``。"

msgid "This type of curve is called a *Quadratic Bezier* curve."
msgstr "這種曲線稱為 *二次貝茲曲線*。"

msgid "*(Image credit: Wikipedia)*"
msgstr "*(圖片來源：維基百科)*"

msgid "Cubic Bezier"
msgstr "三次貝茲曲線"

msgid ""
"Building upon the previous example, we can get more control by interpolating "
"between four points."
msgstr "在前述例子的基礎上，若以四個點進行插值，我們便能取得更多控制。"

msgid ""
"We first use a function with four parameters to take four points as an "
"input, ``p0``, ``p1``, ``p2`` and ``p3``:"
msgstr ""
"首先我們使用一個帶有四個參數的函式，分別輸入四個點 ``p0``、``p1``、``p2`` 和 "
"``p3``："

msgid ""
"We apply a linear interpolation to each couple of points to reduce them to "
"three:"
msgstr "接著對每一對點進行線性插值，將其減少為三個點："

msgid "We then take our three points and reduce them to two:"
msgstr "然後將這三個點進一步縮減為兩個點："

msgid "And to one:"
msgstr "再縮減為一個點："

msgid "Here is the full function:"
msgstr "以下是完整函式："

msgid ""
"The result will be a smooth curve interpolating between all four points:"
msgstr "結果會是一條在四個點之間平滑插值的曲線："

msgid ""
"Cubic Bezier interpolation works the same in 3D, just use ``Vector3`` "
"instead of ``Vector2``."
msgstr ""
"三次貝茲插值在 3D 中的用法也相同，只需將 ``Vector2`` 換成 ``Vector3`` 即可。"

msgid "Adding control points"
msgstr "新增控制點"

msgid ""
"Building upon Cubic Bezier, we can change the way two of the points work to "
"control the shape of our curve freely. Instead of having ``p0``, ``p1``, "
"``p2`` and ``p3``, we will store them as:"
msgstr ""
"在三次貝茲的基礎上，我們可以藉由改變其中兩個點的方式，來自由調整曲線的形狀。"
"我們不直接儲存 ``p0``、``p1``、``p2``、``p3``，而是這樣規劃："

msgid "``point0 = p0``: Is the first point, the source"
msgstr "``point0 = p0``：第一個點，起點"

msgid "``control0 = p1 - p0``: Is a vector relative to the first control point"
msgstr "``control0 = p1 - p0``：第一個控制點的相對向量"

msgid ""
"``control1 = p3 - p2``: Is a vector relative to the second control point"
msgstr "``control1 = p3 - p2``：第二個控制點的相對向量"

msgid "``point1 = p3``: Is the second point, the destination"
msgstr "``point1 = p3``：第二個點，終點"

msgid ""
"This way, we have two points and two control points which are relative "
"vectors to the respective points. If you've used graphics or animation "
"software before, this might look familiar:"
msgstr ""
"這樣我們就有了兩個點及兩個作為相對向量的控制點。如果你曾用過圖形或動畫軟體，"
"這應該看起來很熟悉："

msgid ""
"This is how graphics software presents Bezier curves to the users, and how "
"they work and look in Godot."
msgstr ""
"這就是圖形軟體向使用者呈現貝茲曲線的方式，也是它們在 Godot 裡運作與顯示的方"
"式。"

msgid "Curve2D, Curve3D, Path and Path2D"
msgstr "Curve2D、Curve3D、Path 與 Path2D"

msgid ""
"There are two objects that contain curves: :ref:`Curve3D <class_Curve3D>` "
"and :ref:`Curve2D <class_Curve2D>` (for 3D and 2D respectively)."
msgstr ""
"有兩種物件可以存放曲線：:ref:`Curve3D <class_Curve3D>` 和 :ref:`Curve2D "
"<class_Curve2D>` （分別對應 3D 與 2D）。"

msgid ""
"They can contain several points, allowing for longer paths. It is also "
"possible to set them to nodes: :ref:`Path3D <class_Path3D>` and :ref:`Path2D "
"<class_Path2D>` (also for 3D and 2D respectively):"
msgstr ""
"這些曲線類別可以包含多個點，允許建立較長的路徑。也能將它們設為節"
"點：:ref:`Path3D <class_Path3D>` 和 :ref:`Path2D <class_Path2D>` （分別對應 "
"3D 與 2D）："

msgid ""
"Using them, however, may not be completely obvious, so following is a "
"description of the most common use cases for Bezier curves."
msgstr "但它們的使用方式未必直覺，下方將說明貝茲曲線最常見的使用情境。"

msgid "Evaluating"
msgstr "取樣評估"

msgid ""
"Only evaluating them may be an option, but in most cases it's not very "
"useful. The big drawback with Bezier curves is that if you traverse them at "
"constant speed, from ``t = 0`` to ``t = 1``, the actual interpolation will "
"*not* move at constant speed. The speed is also an interpolation between the "
"distances between points ``p0``, ``p1``, ``p2`` and ``p3`` and there is not "
"a mathematically simple way to traverse the curve at constant speed."
msgstr ""
"只對曲線進行取樣評估是一種做法，但多數情境下實用性有限。貝茲曲線的一大缺點"
"是：如果你從 ``t = 0`` 以固定速度走到 ``t = 1``，實際插值的速度*並不*會均勻。"
"速度會受 ``p0``、``p1``、``p2``、``p3`` 之間距離的插值影響，數學上沒有簡單方"
"式能以固定速度遍歷曲線。"

msgid "Let's do an example with the following pseudocode:"
msgstr "我們來看個範例，以下是偽程式碼："

msgid ""
"As you can see, the speed (in pixels per second) of the circle varies, even "
"though ``t`` is increased at constant speed. This makes beziers difficult to "
"use for anything practical out of the box."
msgstr ""
"正如你所見，即便 ``t`` 以固定速率遞增，圓的移動速度（像素/秒）仍會變化。這讓"
"貝茲曲線在實際應用時不容易直接拿來用。"

msgid "Drawing"
msgstr "繪製"

msgid ""
"Drawing beziers (or objects based on the curve) is a very common use case, "
"but it's also not easy. For pretty much any case, Bezier curves need to be "
"converted to some sort of segments. This is normally difficult, however, "
"without creating a very high amount of them."
msgstr ""
"繪製貝茲曲線（或基於曲線的物件）是很常見的用途，但同樣不簡單。大多數情況下，"
"貝茲曲線都必須轉換為一系列線段。不過這麼做時通常會遇到如何避免產生過多線段的"
"困難。"

msgid ""
"The reason is that some sections of a curve (specifically, corners) may "
"require considerable amounts of points, while other sections may not:"
msgstr ""
"原因在於曲線某些區段（特別是轉角處）可能需要大量點，而其他區段則不需要："

msgid ""
"Additionally, if both control points were ``0, 0`` (remember they are "
"relative vectors), the Bezier curve would just be a straight line (so "
"drawing a high amount of points would be wasteful)."
msgstr ""
"另外，如果兩個控制點都是 ``0, 0`` （記得它們是相對向量），那貝茲曲線就變成一"
"條直線（此時產生過多點就很浪費資源）。"

msgid ""
"Before drawing Bezier curves, *tessellation* is required. This is often done "
"with a recursive or divide and conquer function that splits the curve until "
"the curvature amount becomes less than a certain threshold."
msgstr ""
"在繪製貝茲曲線之前，通常要先進行 *細分*。這通常透過遞迴或分治法分割曲線，直到"
"曲率小於某個門檻為止。"

msgid ""
"The *Curve* classes provide this via the :ref:`Curve2D.tessellate() "
"<class_Curve2D_method_tessellate>` function (which receives optional "
"``stages`` of recursion and angle ``tolerance`` arguments). This way, "
"drawing something based on a curve is easier."
msgstr ""
"*Curve* 類別透過 :ref:`Curve2D.tessellate() "
"<class_Curve2D_method_tessellate>` 函式（可選遞迴階段數 ``stages`` 與角度容"
"差 ``tolerance`` 參數）來提供細分功能。如此一來，基於曲線繪圖就更容易了。"

msgid "Traversal"
msgstr "遍歷"

msgid ""
"The last common use case for the curves is to traverse them. Because of what "
"was mentioned before regarding constant speed, this is also difficult."
msgstr ""
"最後一個常見用途是沿曲線遍歷。但如前所述，若要以固定速度遍歷曲線，會有困難。"

msgid ""
"To make this easier, the curves need to be *baked* into equidistant points. "
"This way, they can be approximated with regular interpolation (which can be "
"improved further with a cubic option). To do this, just use "
"the :ref:`Curve3D.sample_baked()<class_Curve3D_method_sample_baked>` method "
"together "
"with :ref:`Curve2D.get_baked_length()<class_Curve2D_method_get_baked_length>`. "
"The first call to either of them will bake the curve internally."
msgstr ""
"為了簡化操作，需要先將曲線 *烘焙* 為等距的點。如此一來就能用常規插值（甚至可"
"進一步用三次插值）進行近似。只需使用 :ref:`Curve3D.sample_baked() "
"<class_Curve3D_method_sample_baked>` 搭配 :ref:`Curve2D.get_baked_length() "
"<class_Curve2D_method_get_baked_length>` 方法。首次呼叫任一方法時，曲線會在內"
"部自動烘焙。"

msgid ""
"Traversal at constant speed, then, can be done with the following pseudo-"
"code:"
msgstr "固定速度遍歷曲線，可以用以下偽程式碼實現："

msgid "And the output will, then, move at constant speed:"
msgstr "如此輸出就能以固定速度移動："
