#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "進階向量運算"

msgid "Planes"
msgstr "平面"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"點積與單位向量有另一個有趣的性質。想像有一個通過原點且垂直於該向量的平面。平"
"面會將整個空間劃分為正（平面上方）與負（平面下方）區域，而且（與一般認知不"
"同）這些運算同樣適用於 2D："

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"垂直於表面的單位向量稱為 **單位法向量** ，通常簡稱為 *法線*。法線常見於平面、"
"3D 幾何（用於判斷面或頂點的朝向）等場合。 **法線** 本質上就是 **單位向量** ，"
"但因其用途而有此名稱。（就像我們會稱 (0,0) 為「原點」一樣！）。"

msgid ""
"The plane passes by the origin and the surface of it is perpendicular to the "
"unit vector (or *normal*). The side the vector points to is the positive "
"half-space, while the other side is the negative half-space. In 3D this is "
"exactly the same, except that the plane is an infinite surface (imagine an "
"infinite, flat sheet of paper that you can orient and is pinned to the "
"origin) instead of a line."
msgstr ""
"這個平面會通過原點，且其表面垂直於該單位向量（或 *法線*）。向量所指的一側是正"
"半空間，另一側則是負半空間。在 3D 中概念完全相同，不同的是平面是無限延伸的表"
"面（想像一張無限大的平坦紙張，固定在原點並可任意擺放），而不是一條線。"

msgid "Distance to plane"
msgstr "點到平面的距離"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"了解了平面的定義後，讓我們回來談點積。當你將一個 **單位向量** 與任意 **空間中"
"的點** 做點積時（沒錯，這次是向量和位置之間的點積），會得到 **該點到平面的距"
"離**："

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr "而且這不僅僅是絕對值距離，如果點位於負半空間，那麼距離也會是負值："

msgid "This allows us to tell which side of the plane a point is."
msgstr "這讓我們可以判斷一個點位於平面的哪一側。"

msgid "Away from the origin"
msgstr "偏離原點"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"我知道你在想什麼！目前這些都不錯，但*現實中的*平面其實可以在空間中任何地方，"
"而不只是通過原點。你想要更「真實」的*平面*運算，而且*現在*就想試試看。"

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"別忘了，平面不只將空間分成兩個部分，還具有*極性*。也就是說，即使有兩個平面完"
"全重疊，它們的正負半空間仍可能相反。"

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"基於這個特性，我們可以用一個 **法線** *N* 和一個 **距離原點的標量** *D* 來完"
"整描述一個平面。因此，一個平面就用 N 和 D 表示。例如："

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"在 3D 運算中，Godot 提供了 :ref:`Plane <class_Plane>` 內建型別來處理這些計"
"算。"

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"基本上，N 和 D 可以表示空間中任意一個平面，不論是 2D 還是 3D（取決於 N 的維"
"度），運算方式都相同。和前述的概念一樣，只是 D 代表從原點出發，沿著 N 方向到"
"平面的距離。舉例來說，假設你想要找到平面上的某一點，只需："

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"這樣會將法線向量拉長（縮放）到剛好碰到該平面。這個運算乍看之下可能有點混亂，"
"但其實非常簡單。如果我們要計算某點到平面的距離，也是類似做法，只是需要調整距"
"離："

msgid "The same thing, using a built-in function:"
msgstr "相同的事可以利用內建函式達成："

msgid "This will, again, return either a positive or negative distance."
msgstr "這樣會回傳正值或負值的距離。"

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"若要翻轉平面的極性，只需將 N 和 D 都取負號即可。這樣會得到一個同樣位置的平"
"面，但正負半空間會對調："

msgid ""
"Godot also implements this operator in :ref:`Plane <class_Plane>`. So, using "
"the format below will work as expected:"
msgstr ""
"Godot 也在 :ref:`Plane <class_Plane>` 中提供了這個運算操作，因此你可以直接這"
"樣寫："

msgid ""
"So, remember, the plane's main practical use is that we can calculate the "
"distance to it. So, when is it useful to calculate the distance from a point "
"to a plane? Let's see some examples."
msgstr ""
"所以記住，平面最實用的地方就是可以計算點到平面的距離。那麼，什麼情境下需要這"
"樣的計算呢？來看幾個例子。"

msgid "Constructing a plane in 2D"
msgstr "在 2D 中建立平面"

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"平面當然不會憑空出現，它必須被建構。在 2D 裡建立平面很簡單，你可以用一個法線"
"（單位向量）和一個點，或是空間中兩個點來建立。"

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so calculate D from the dot product of the normal and "
"the point."
msgstr ""
"如果已經有一個法線和一個點，那幾乎所有資訊都具備了。這時只要用法線與該點做點"
"積，就能求出 D。"

msgid ""
"For two points in space, there are actually two planes that pass through "
"them, sharing the same space but with normal pointing to the opposite "
"directions. To compute the normal from the two points, the direction vector "
"must be obtained first, and then it needs to be rotated 90 degrees to either "
"side:"
msgstr ""
"若是拿空間中的兩個點來建立平面，事實上會有兩個平面經過這兩點，它們的法線方向"
"相反但所在空間相同。你需要先取得這兩點的方向向量，然後將它旋轉 90 度（順時針"
"或逆時針）來得到法線："

msgid ""
"The rest is the same as the previous example. Either point_a or point_b will "
"work, as they are in the same plane:"
msgstr ""
"接下來的步驟就和前述範例一樣了。你使用 point_a 或 point_b 都可以，因為它們都"
"在同一個平面上："

msgid ""
"Doing the same in 3D is a little more complex and is explained further down."
msgstr "在 3D 空間中做類似的事情會稍微複雜一些，後面會進一步說明。"

msgid "Some examples of planes"
msgstr "平面的應用範例"

msgid ""
"Here is an example of what planes are useful for. Imagine you have a `convex "
"<https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"以下是一個平面應用的範例。假設你有一個 `凸 <https://www.mathsisfun.com/"
"definitions/convex.html>`__ 多邊形，例如矩形、梯形、三角形，或任何沒有邊向內"
"凹的多邊形。"

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"針對多邊形的每一個邊，我們計算經過該邊的平面。有了這些平面，你就可以做很多事"
"情，例如判斷一個點是否在多邊形內部。"

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"我們檢查所有平面，如果存在某個平面使得點到該平面的距離為正，則該點在多邊形外"
"部。若沒有這樣的平面，則該點就在多邊形內部。"

msgid "Code should be something like this:"
msgstr "程式碼範例如下："

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"很酷吧？其實還有更進一步的應用！只要再多做一點點，你就可以用類似邏輯來判斷兩"
"個凸多邊形是否重疊。這就是所謂的分離軸定理（SAT），大多數物理引擎都用這個原理"
"來偵測碰撞。"

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"對於單一點，只要檢查是否有平面回傳正距離就知道該點是否在外面。對於另一個多邊"
"形，則必須找到一個平面，使得*所有*另一多邊形的點對該平面計算時都為正距離。這"
"個檢查動作要對 A 的平面配 B 的點，再對 B 的平面配 A 的點各做一次："

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"可以看到，平面真的非常實用，而這只是一小部分應用而已。你可能會好奇，如果遇到"
"非凸多邊形怎麼辦？通常會先把凹多邊形拆分成多個凸多邊形，或是用 BSP 之類的技術"
"（不過現在已經比較少用了）。"

msgid "Collision detection in 3D"
msgstr "3D 碰撞偵測"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"這裡再多分享一點知識，感謝你耐心讀到這裡！雖然這不一定能馬上拿來用（因為 "
"Godot 本身就有很完善的碰撞偵測），但幾乎所有物理引擎和碰撞偵測函式庫都用到這"
"個原理：）"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"還記得之前提到，將 2D 的凸形狀轉換成一組 2D 平面對碰撞偵測很有用嗎？你可以藉"
"此判斷一個點是否在凸形狀內，或是兩個 2D 凸形狀是否有重疊。"

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"這套方法在 3D 也適用。如果兩個 3D 多面體發生碰撞，你就無法找到分離平面；反"
"之，如果找得到分離平面，表示兩者絕對沒有碰撞。"

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"補充一下，「分離平面」的意思是：多邊形 A 的所有頂點都在平面一側，多邊形 B 的"
"所有頂點都在平面另一側。這個平面一定是 A 或 B 某一個面的平面。"

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"不過在 3D 空間中，這個方法有個小問題：有些情況下可能找不到分離平面。例如下圖"
"這種情形："

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"為了避免這種狀況，還需要針對一些額外的平面進行測試；這些平面，是由多邊形 A "
"和 B 的邊分別做外積（叉積）產生的"

msgid "So the final algorithm is something like:"
msgstr "因此最終的演算法大致如下："

msgid "More information"
msgstr "更多資訊"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr "想了解更多在 Godot 中使用向量運算的資訊，請參考下列文章："

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"
