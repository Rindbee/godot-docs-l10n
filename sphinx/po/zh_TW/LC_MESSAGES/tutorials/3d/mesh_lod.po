#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Mesh level of detail (LOD)"
msgstr "網格的細節級別（LOD）"

msgid ""
"Level of detail (LOD) is one of the most important ways to optimize "
"rendering performance in a 3D project, along "
"with :ref:`doc_occlusion_culling`."
msgstr ""
"與 :ref:`doc_occlusion_culling` 一樣，細節級別（LOD）是優化 3D 專案算繪性能的"
"最重要方法之一。"

msgid "On this page, you'll learn:"
msgstr "在本指南中，我們將學到："

msgid "How mesh LOD can improve your 3D project's rendering performance."
msgstr "網格 LOD 如何提高 3D 專案的算繪性能。"

msgid "How to set up mesh LOD in Godot."
msgstr "如何在 Godot 中設定網格 LOD。"

msgid ""
"How to measure mesh LOD's effectiveness in your project (and alternatives "
"you can explore if it doesn't meet your expectations)."
msgstr ""
"如何衡量網格 LOD 在專案中的效果（如果達不到預期效果，還可以探索其他方法）。"

msgid ""
"You can see how mesh LOD works in action using the `Occlusion Culling and "
"Mesh LOD demo project <https://github.com/godotengine/godot-demo-projects/"
"tree/master/3d/occlusion_culling_mesh_lod>`__."
msgstr ""
"你可以參考 `Occlusion Culling and Mesh LOD 範例專案 <https://github.com/"
"godotengine/godot-demo-projects/tree/master/3d/"
"occlusion_culling_mesh_lod>`__，實際觀察網格 LOD 的運作。"

msgid "Introduction"
msgstr "前言"

msgid ""
"Historically, level of detail in 3D games involved manually authoring meshes "
"with lower geometry density, then configuring the distance thresholds at "
"which these lower-detailed meshes should be drawn. This approach is still "
"used today when increased control is needed."
msgstr ""
"過去 3D 遊戲的細節層次（LOD）通常需美術手動建立低多邊形版本的網格，並設定這些"
"網格在哪些距離門檻時切換顯示。當專案需要更精細的控制時，這種方式至今仍被採"
"用。"

msgid ""
"However, in projects that have a large amount of detailed 3D assets, setting "
"up LOD manually can be a very time-consuming process. As a result, automatic "
"mesh decimation and LOD configuration is becoming increasingly popular."
msgstr ""
"然而，在擁有大量詳細 3D 素材的專案中，手動設定 LOD 可能是一個非常耗時的過程。"
"因此，自動網格細分和 LOD 配置越來越受歡迎。"

msgid ""
"Godot provides a way to automatically generate less detailed meshes for LOD "
"usage on import, then use those LOD meshes when needed automatically. This "
"is completely transparent to the user. The `meshoptimizer <https://"
"meshoptimizer.org/>`__ library is used for LOD mesh generation behind the "
"scenes."
msgstr ""
"Godot 提供匯入時自動產生低細節網格（LOD）的方法，並會在需要時自動切換使用這"
"些 LOD 網格，對使用者來說完全透明。幕後會使用 `meshoptimizer <https://"
"meshoptimizer.org/>`__ 函式庫進行 LOD 網格的產生。"

msgid ""
"Mesh LOD works with any node that draws 3D meshes. This includes "
"MeshInstance3D, MultiMeshInstance3D, GPUParticles3D and CPUParticles3D."
msgstr ""
"網格 LOD 適用於任何繪製 3D 網格的節點。這包括 MeshInstance3D、"
"MultiMeshInstance3D、GPUParticles3D 和 CPUParticles3D。"

msgid "Visual comparison"
msgstr "視覺比較"

msgid ""
"Here is an example of LOD meshes generated on import. Lower detailed meshes "
"will be used when the camera is far away from the object:"
msgstr ""
"以下是匯入時生成 LOD 網格的範例。當相機遠離物體時，將使用細節較少的網格："

msgid "From most detailed (left) to least detailed (right), shaded view"
msgstr "從最詳細（左）到最不詳細（右），陰影視圖"

msgid ""
"Here's the same image with wireframe rendering to make the decimation easier "
"to see:"
msgstr "這是使用線框算繪的同一張圖像，以使抽取更容易看到："

msgid "From most detailed (left) to least detailed (right), wireframe view"
msgstr "從最詳細（左）到最不詳細（右），線框視圖"

msgid ""
"If you need to manually configure level of detail with artist-created "
"meshes, use :ref:`doc_visibility_ranges` instead of automatic mesh LOD."
msgstr ""
"如果你需要針對美術手動製作的多版本網格自行設定 LOD，請使"
"用 :ref:`doc_visibility_ranges`，而非自動網格 LOD。"

msgid "Generating mesh LOD"
msgstr "產生網格 LOD"

msgid ""
"By default, mesh LOD generation happens automatically for imported 3D scenes "
"(glTF, .blend, Collada, FBX). Once LOD meshes are generated, they will "
"automatically be used when rendering the scene. You don't need to configure "
"anything manually."
msgstr ""
"預設情況下，匯入的 3D 場景（如 glTF、.blend、Collada、FBX）會自動產生網格 "
"LOD。生成 LOD 網格後，場景在繪製時會自動套用這些網格，無需手動設定。"

msgid ""
"However, mesh LOD generation does **not** automatically happen for imported "
"3D meshes (OBJ). This is because OBJ files are not imported as full 3D "
"scenes by default, but only as individual mesh resources to load into a "
"MeshInstance3D node (or GPUParticles3D, CPUParticles3D, ...)."
msgstr ""
"但是，對於匯入的 3D 網格 (OBJ)，網格 LOD 產生**不會**自動發生。這是因為預設情"
"況下，OBJ 檔案不會作為完整的 3D 場景匯入，而僅作為單獨的網格資源載入到 "
"MeshInstance3D 節點（或 GPUParticles3D、CPUParticles3D...）中。"

msgid ""
"To make an OBJ file have mesh LOD generated for it, select it in the "
"FileSystem dock, go to the Import dock, change its **Import As** option to "
"**Scene** then click **Reimport**:"
msgstr ""
"若要使OBJ 檔案為其產生網格LOD，請在檔案系統擴充座中選擇它，請前往匯入擴充塢，"
"將其**匯入為** 選項變更為**場景**，然後按一下**重新匯入**："

msgid "Changing the import type on an OBJ file in the Import dock"
msgstr "在匯入塢中變更 OBJ 檔案的匯入型別"

msgid "This will require restarting the editor after clicking **Reimport**."
msgstr "點擊 **重新匯入** 後，會需要重新啟動編輯器。"

msgid ""
"The mesh LOD generation process is not perfect, and may occasionally "
"introduce rendering issues (especially in skinned meshes). Mesh LOD "
"generation can also take a while on complex meshes."
msgstr ""
"網格 LOD 生成過程並不完美，有時可能會引入算繪問題（尤其是在蒙皮網格中）。在複"
"雜的網格上，網格 LOD 產生也可能需要一段時間。"

msgid ""
"If mesh LOD causes a specific mesh to look broken, you can disable LOD "
"generation for it in the Import dock. This will also speed up resource "
"importing. This can be done globally in the 3D scene's import options, or on "
"a per-mesh basis using the Advanced Import Settings dialog."
msgstr ""
"如果網格 LOD 導致特定網格看起來損壞，您可以在匯入塢中停用它的 LOD 產生。這也"
"將加快資源匯入速度。這可以在 3D 場景的匯入選項中全域完成，也可以使用「進階匯"
"入設定」對話方塊在每個網格上完成。"

msgid ""
"See :ref:`Importing 3D scenes "
"<doc_importing_3d_scenes_using_the_import_dock>` for more information."
msgstr "詳情請參考 :ref:`doc_importing_3d_scenes_using_the_import_dock`。"

msgid "Comparing mesh LOD visuals and performance"
msgstr "比較網格 LOD 視覺效果和性能"

msgid ""
"To disable mesh LOD in the editor for comparison purposes, use the **Disable "
"Mesh LOD** advanced debug draw mode. This can be done using the menu in the "
"top-left corner of the 3D viewport (labeled **Perspective** or "
"**Orthogonal** depending on camera mode):"
msgstr ""
"若要在編輯器中停用網格 LOD 以進行比較，請使用 **停用網格 LOD** 進階偵錯繪製模"
"式。這可以使用 3D 視窗左上角的選單來完成（標記為 **透視** 或 **正交**，取決於"
"相機模式）："

msgid "Disabling mesh LOD in the 3D viewport's top-left menu"
msgstr "透過 3D 視口左上角的選單停用網格 LOD"

msgid ""
"Enable **View Frame Time** in the same menu to view FPS in the top-right "
"corner. Also enable **View Information** in the same menu to view the number "
"of primitives (vertices + indices) rendered in the bottom-right corner."
msgstr ""
"在同一選單中啟用 **顯示影格時間** 來在右上角查看 FPS，也可以啟用 **顯示資訊"
"**，以在右下角看到目前算繪的 primitive（頂點數＋索引數）。"

msgid ""
"If mesh LOD is working correctly in your scene and your camera is far away "
"enough from the mesh, you should notice the number of drawn primitives "
"decreasing and FPS increasing when mesh LOD is left enabled (unless you are "
"CPU-bottlenecked)."
msgstr ""
"如果你的場景中網格 LOD 正常運作，而且相機距離網格夠遠，當 LOD 啟用時，你應該"
"會發現算繪的 primitive 數量減少、FPS 上升（除非你遇到 CPU 瓶頸）。"

msgid ""
"To see mesh LOD decimation in action, change the debug draw mode to "
"**Display Wireframe** in the menu specified above, then adjust the "
"**Rendering > Mesh LOD > LOD Change > Threshold Pixels** project setting."
msgstr ""
"若要觀察網格 LOD 的抽取（decimation）效果，可以在上述選單切換到 **顯示線框** "
"偵錯模式，然後調整 **算繪 > Mesh LOD > LOD 切換 > Threshold Pixels** 專案設"
"定。"

msgid "Configuring mesh LOD performance and quality"
msgstr "配置網格 LOD 性能和質量"

msgid ""
"You can adjust how aggressive mesh LOD transitions should be in the root "
"viewport by changing the **Rendering > Mesh LOD > LOD Change > Threshold "
"Pixels** project setting. To change this value at runtime, set "
"``mesh_lod_threshold`` on the root viewport as follows:"
msgstr ""
"你可以透過調整專案設定的 **算繪 > Mesh LOD > LOD 切換 > Threshold Pixels**，"
"決定主視口中網格 LOD 切換的敏感程度。若要於執行時動態調整，可以對 root 視口"
"的 ``mesh_lod_threshold`` 屬性設定如下："

msgid ""
"Each viewport has its own ``mesh_lod_threshold`` property, which can be set "
"independently from other viewports."
msgstr ""
"每個視口（Viewport）都擁有獨立的 ``mesh_lod_threshold`` 屬性，可各自調整，不"
"互相影響。"

msgid ""
"The default mesh LOD threshold of 1 pixel is tuned to look *perceptually* "
"lossless; it provides a significant performance gain with an unnoticeable "
"loss in quality. Higher values will make LOD transitions happen sooner when "
"the camera moves away, resulting in higher performance, but lower quality."
msgstr ""
"預設的網格 LOD 閾值為 1 像素，目的是讓畫面在*感知上*接近無損，同時獲得顯著的"
"效能提升且幾乎無畫質損失。提高這個值會讓 LOD 切換在相機遠離時更早發生，提升效"
"能但畫質會下降。"

msgid ""
"If you need to perform per-object adjustments to mesh LOD, you can adjust "
"how aggressive LOD transitions should be by adjusting the **LOD Bias** "
"property on any node that inherits from GeometryInstance3D. Values *above* "
"``1.0`` will make LOD transitions happen later than usual (resulting in "
"higher quality, but lower performance). Values *below* ``1.0`` will make LOD "
"transitions happen sooner than usual (resulting in lower quality, but higher "
"performance)."
msgstr ""
"如果你需要針對單一物件調整 LOD 切換的積極程度，可以在繼承自 "
"GeometryInstance3D 的節點上設定 **LOD 偏差（LOD Bias）** 屬性。設定值*大於* "
"``1.0`` 會讓 LOD 切換比預設更晚（畫質較高、效能較低），*小於* ``1.0`` 則會讓 "
"LOD 更早切換（畫質較低、效能較高）。"

msgid ""
"Additionally, ReflectionProbe nodes have their own **Mesh LOD Threshold** "
"property that can be adjusted to improve rendering performance when the "
"reflection probe updates. This is especially important for ReflectionProbes "
"that use the **Always** update mode."
msgstr ""
"此外，ReflectionProbe 節點有自己的 **Mesh LOD Threshold（網格 LOD 閾值）** 屬"
"性，調整這個值可以提升反射探測器更新時的算繪效能。這對於設定為 **Always** "
"（永遠）更新模式的 ReflectionProbe 特別重要。"

msgid ""
"When rendering the scene, mesh LOD selection uses a screen-space metric. "
"This means it automatically takes camera field of view and viewport "
"resolution into account. Higher camera FOV and lower viewport resolutions "
"will make LOD selection more aggressive; the engine will display heavily "
"decimated models earlier when the camera moves away."
msgstr ""
"算繪場景時，網格 LOD 選擇使用螢幕空間度量。這意味著它會自動考慮相機視野和視口"
"解析度。較高的相機 FOV 和較低的視口解析度將使 LOD 選擇更加積極；當相機移開"
"時，引擎將提前顯示嚴重破壞的模型。"

msgid ""
"As a result, unlike :ref:`doc_visibility_ranges`, you don't need to do "
"anything specific in your project to take camera FOV and viewport resolution "
"into account."
msgstr ""
"因此，與 :ref:`doc_visibility_ranges` 不同，您無需在專案中執行任何特定操作即"
"可考慮相機 FOV 和視窗解析度。"

msgid "Using mesh LOD with MultiMesh and particles"
msgstr "將網格 LOD 與 MultiMesh 和粒子結合使用"

msgid ""
"For LOD selection, the point of the node's :abbr:`AABB (Axis-Aligned "
"Bounding Box)` that is the closest to the camera is used as a basis. This "
"applies to any kind of mesh LOD (including for individual MeshInstance3D)s, "
"but this has some implications for nodes that display multiple meshes at "
"once, such as MultiMeshInstance3D, GPUParticles3D and GPUParticles3D. Most "
"importantly, this means that all instances will be drawn with the same LOD "
"level at a given time."
msgstr ""
"對於 LOD 選取，使用節點 :abbr:`AABB (Axis-Aligned Bounding Box)` 中離攝影機最"
"近的點作為基礎。這適用於任何種類的網格 LOD (包括單獨的 MeshInstance3D 實例)，"
"但這對於一次顯示多個網格的節點 (例如 MultiMeshInstance3D、GPUParticles3D 和 "
"GPUParticles3D) 有一些影響。最重要的是，這表示在給定時間，所有實例將會以相同"
"的 LOD 等級繪製。"

msgid ""
"If you are noticing incorrect LOD selection with GPUParticles3D, make sure "
"the node's visibility AABB is configured by selecting the GPUParticles3D "
"node and using **GPUParticles3D > Generate AABB** at the top of the 3D "
"viewport."
msgstr ""
"如果你發現 GPUParticles3D 的 LOD 選擇不正確，請選取 GPUParticles3D 節點，並"
"在 3D 視口上方選單使用 **GPUParticles3D > 產生 AABB**，以正確設定節點的可見範"
"圍 AABB。"

msgid ""
"If you have instances in a MultiMesh that are far away from each other, they "
"should be placed in a separate MultiMeshInstance3D node. Doing so will also "
"improve rendering performance, as frustum and occlusion culling will be able "
"to cull individual nodes (while they can't cull individual instances in a "
"MultiMesh)."
msgstr ""
"如果 MultiMesh 中的實例彼此距離很遠，建議將它們分開放到不同的 "
"MultiMeshInstance3D 節點。這麼做能讓視錐體與遮蔽剔除能針對單一節點進行（而非 "
"MultiMesh 內的單一實例無法被剔除），進一步提升算繪效能。"
