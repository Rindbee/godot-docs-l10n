#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High dynamic range lighting"
msgstr "高動態範圍光照"

msgid "Introduction"
msgstr "前言"

msgid ""
"Normally, an artist does all the 3D modeling, then all the texturing, looks "
"at their awesome looking model in the 3D modeling software and says \"looks "
"fantastic, ready for integration!\" then goes into the game, lighting is "
"setup and the game runs."
msgstr ""
"通常美術會先完成所有的 3D 建模和貼圖，然後在 3D 建模軟體中檢查自己的作品，覺"
"得「看起來很棒，可以整合到專案裡了！」。接著進入遊戲，設定好燈光並開始執行。"

msgid ""
"So at what point does all this \"HDR\" business come into play? To "
"understand the answer, we need to look at how displays behave."
msgstr ""
"那麼, 所有這些\" HDR\"業務在什麼時候發揮作用？要理解答案, 我們需要查看顯示器"
"的行為."

msgid ""
"Your display outputs linear light ratios from some maximum to some minimum "
"intensity. Modern game engines perform complex math on linear light values "
"in their respective scenes. So what's the problem?"
msgstr ""
"您的顯示器輸出線性光比率從某個最大強度到某個最小強度. 現代遊戲引擎在各自的場"
"景中對線性光值進行複雜的數學計算. 這將會有什麼問題呢？"

msgid ""
"The display has a limited range of intensity, depending on the display type. "
"The game engine renders to an unlimited range of intensity values, however. "
"While \"maximum intensity\" means something to an sRGB display, it has no "
"bearing in the game engine; there is only a potentially infinitely wide "
"range of intensity values generated per frame of rendering."
msgstr ""
"根據顯示器型別的不同, 顯示的強度範圍有限. 然而, 遊戲引擎算繪的強度值範圍沒有"
"限制. 雖然 \"最大強度\" 對sRGB顯示器來說有一定的意義, 但在遊戲引擎中卻沒有任"
"何影響；每影格算繪時可能產生無限寬的強度值範圍."

msgid ""
"This means that some transformation of the scene light intensity, also known "
"as *scene-referred* light ratios, need to be transformed and mapped to fit "
"within the particular output range of the chosen display. This can be most "
"easily understood if we consider virtually photographing our game engine "
"scene through a virtual camera. Here, our virtual camera would apply a "
"particular camera rendering transform to the scene data, and the output "
"would be ready for display on a particular display type."
msgstr ""
"這表示場景光強（也就是 *場景參考* 光照比）需要經過轉換和映射，才能符合所選顯"
"示器的輸出範圍。這個概念可以想像成我們用虛擬相機拍下遊戲引擎裡的場景，由虛擬"
"相機套用特定的相機算繪轉換到場景資料，然後輸出給對應的顯示裝置。"

msgid ""
"Godot does not support high dynamic range *output* yet. It can only perform "
"lighting in HDR and tonemap the result to a low dynamic range image."
msgstr ""
"Godot 目前尚未支援高動態範圍 *輸出*。它只能在 HDR 模式下運算光照，並將結果經"
"過色調映射（tonemap）輸出為低動態範圍的影像。"

msgid ""
"For advanced users, it is still possible to get a non-tonemapped image of "
"the viewport with full HDR data, which can then be saved to an OpenEXR file."
msgstr ""
"對進階使用者而言，仍可取得未經色調映射（non-tonemapped）且保留完整 HDR 資料的"
"視窗畫面，並儲存為 OpenEXR 檔案。"

msgid "Computer displays"
msgstr "電腦顯示器"

msgid ""
"Almost all displays require a nonlinear encoding for the code values sent to "
"them. The display in turn, using its unique transfer characteristic, "
"\"decodes\" the code value into linear light ratios of output, and projects "
"the ratios out of the uniquely colored lights at each reddish, greenish, and "
"blueish emission site."
msgstr ""
"幾乎所有顯示器都需要對發送給它們的程式碼值進行非線性編碼. 顯示器又利用其獨特"
"的傳輸功能, 將程式碼值 \"解碼\" 為輸出的線性光比, 並在每個紅色, 綠色和藍色發"
"射點的獨特顏色的光中投射出這些比值."

msgid ""
"For a majority of computer displays, the specifications of the display are "
"outlined in accordance with IEC 61966-2-1, also known as the 1996 sRGB "
"specification. This specification outlines how an sRGB display is to behave, "
"including the color of the lights in the LED pixels as well as the transfer "
"characteristics of the input (OETF) and output (EOTF)."
msgstr ""
"大多數電腦顯示器的規格皆遵循 IEC 61966-2-1 標準，也就是 1996 年的 sRGB 規格。"
"這個標準規定了 sRGB 顯示器的行為，包括 LED 像素的發光顏色，以及輸入（OETF）和"
"輸出（EOTF）的傳輸特性。"

msgid ""
"Not all displays use the same OETF and EOTF as a computer display. For "
"example, television broadcast displays use the BT.1886 EOTF. However, Godot "
"currently only supports sRGB displays."
msgstr ""
"並非所有顯示器都使用與電腦顯示器相同的OETF和EOTF. 例如, 電視廣播顯示器使用"
"BT.1886 EOTF. 然而,Godot目前只支援sRGB顯示器."

msgid ""
"The sRGB standard is based around the nonlinear relationship between the "
"current to light output of common desktop computing CRT displays."
msgstr ""
"sRGB標準是圍繞著常見的桌面計算CRT顯示器的電流與光輸出之間的非線性關係而制定"
"的."

msgid ""
"The mathematics of a scene-referred model require that we multiply the scene "
"by different values to adjust the intensities and exposure to different "
"light ranges. The transfer function of the display can't appropriately "
"render the wider dynamic range of the game engine's scene output using the "
"simple transfer function of the display. A more complex approach to encoding "
"is required."
msgstr ""
"場景參考模型的數學要求我們將場景乘以不同的值, 以調整不同光照範圍的強度和曝"
"光. 顯示器簡單的傳遞函式不能恰當地算繪遊戲從引擎場景中輸出的更大動態範圍. 這"
"需要一種更複雜的編碼方法."

msgid "Scene linear & asset pipelines"
msgstr "場景線性和資源管道"

msgid ""
"Working in scene-linear sRGB is more complex than pressing a single switch. "
"First, imported image assets must be converted to linear light ratios on "
"import. Even when linearized, those assets may not be perfectly well-suited "
"for use as textures, depending on how they were generated."
msgstr ""
"在場景線性sRGB中工作並不像按一下開關那樣簡單. 首先, 匯入的圖像素材必須在匯入"
"時轉換為線性光比例. 即使將其線性化, 這些素材也可能並不完全適合用作紋理, 具體"
"取決於它們的生成方式."

msgid "There are two ways to do this:"
msgstr "有兩種方式可以做到："

msgid "sRGB transfer function to display linear ratios on image import"
msgstr "用於在圖像匯入時顯示線性比率的sRGB傳遞函式"

msgid ""
"This is the easiest method of using sRGB assets, but it's not the most "
"ideal. One issue with this is loss of quality. Using 8 bits per channel to "
"represent linear light ratios is not sufficient to quantize the values "
"correctly. These textures may also be compressed later, which can exacerbate "
"the problem."
msgstr ""
"這是最簡單的使用sRGB資源的方法, 但不是最理想的. 這樣做的一個問題是品質的損"
"失. 每通道使用8位元來表示線性光比率, 不足以正確量化這些值. 這些紋理以後也可能"
"會被壓縮, 可能會加劇這個問題."

msgid "Hardware sRGB transfer function to display linear conversion"
msgstr "硬體sRGB傳輸函式顯示線性轉換"

msgid ""
"The GPU will do the conversion after reading the texel using floating-point. "
"This works fine on PC and consoles, but most mobile devices don't support "
"it, or they don't support it on compressed texture formats (iOS for example)."
msgstr ""
"GPU 會在以浮點數讀取紋素（texel）後進行轉換。這在 PC 和家用主機上運作良好，但"
"多數行動裝置可能不支援，或是在壓縮紋理格式下（像是 iOS）不支援這個功能。"

msgid "Scene linear to display-referred nonlinear"
msgstr "場景線性到顯示參考的非線性"

msgid ""
"After all the rendering is done, the scene linear render requires "
"transforming to a suitable output such as an sRGB display. To do this, "
"enable sRGB conversion in the current :ref:`Environment <class_Environment>` "
"(more on that below)."
msgstr ""
"在所有算繪完成後，場景的線性算繪結果需要轉換成適合輸出的格式，例如 sRGB 顯示"
"器。為達到這個目的，請在目前的 :ref:`Environment <class_Environment>` 啟用 "
"sRGB 轉換（細節見下文）。"

msgid ""
"Keep in mind that the **sRGB -> Display Linear** and **Display Linear -> "
"sRGB** conversions must always be **both** enabled. Failing to enable one of "
"them will result in horrible visuals suitable only for avant-garde "
"experimental indie games."
msgstr ""
"請注意，**sRGB -> 顯示線性（Display Linear）** 和 **顯示線性 -> sRGB** 這兩個"
"轉換必須同時啟用。若只啟用其中一個，畫面會變得非常怪異，可能只適合前衛實驗風"
"格的獨立遊戲。"

msgid "Parameters of HDR"
msgstr "HDR的參數"

msgid ""
"HDR settings can be found in the :ref:`Environment <class_Environment>` "
"resource. Most of the time, these are found inside a :ref:`WorldEnvironment "
"<class_WorldEnvironment>` node or set in a Camera node. For more "
"information, see :ref:`doc_environment_and_post_processing`."
msgstr ""
"HDR 設定可以在 :ref:`Environment <class_Environment>` 資源中找到。通常會出現"
"在 :ref:`WorldEnvironment <class_WorldEnvironment>` 節點內，或是在相機節點中"
"設定。欲了解更多資訊，請參閱 :ref:`doc_environment_and_post_processing`。"
