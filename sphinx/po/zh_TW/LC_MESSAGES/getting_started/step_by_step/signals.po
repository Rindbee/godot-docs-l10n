#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Signal"
msgstr "訊號"

msgid "Using signals"
msgstr "繫結訊號"

msgid ""
"In this lesson, we will look at signals. They are messages that nodes emit "
"when something specific happens to them, like a button being pressed. Other "
"nodes can connect to that signal and call a function when the event occurs."
msgstr ""
"在本課中，我們將介紹訊號。它們是節點在發生特定事件時發出的消息，例如按下按"
"鈕。其他節點可以連接到該訊號，並在事件發生時呼叫函式。"

msgid ""
"Signals are a delegation mechanism built into Godot that allows one game "
"object to react to a change in another without them referencing one another. "
"Using signals limits `coupling <https://en.wikipedia.org/wiki/"
"Coupling_(computer_programming)>`_ and keeps your code flexible."
msgstr ""
"訊號是 Godot 內建的委派機制，允許一個遊戲物件對另一個遊戲物件的變化做出反應，"
"而無需相互引用。使用訊號可以限制 `耦合 <https://zh.wikipedia.org/zh-cn/"
"%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)>`_ ，"
"並保持程式碼的靈活性。"

msgid ""
"For example, you might have a life bar on the screen that represents the "
"player's health. When the player takes damage or uses a healing potion, you "
"want the bar to reflect the change. To do so, in Godot, you would use "
"signals."
msgstr ""
"例如，您可能在螢幕上有一個代表玩家生命值的生命條。當玩家受到傷害或使用治療藥"
"水時，您希望生命條反映變化。要做到這一點，在 Godot 中，你會使用到訊號。"

msgid ""
"Like methods (:ref:`class_callable`), signals are a first-class type since "
"Godot 4.0. This means you can pass them around as method arguments directly "
"without having to pass them as strings, which allows for better "
"autocompletion and is less error-prone. See the :ref:`class_signal` class "
"reference for a list of what you can do with the Signal type directly."
msgstr ""
"如同方法（參閱 :ref:`class_callable`），自 Godot 4.0 起，訊號也是第一級型別。"
"這表示您可以直接將它們作為方法引數傳遞，而無需將它們作為字串傳遞，這樣可以提"
"供更好的自動完成功能，並且更不容易出錯。請參閱 :ref:`class_signal` 類別參考以"
"了解您可以直接對 Signal 型別執行的操作列表。"

msgid ""
"As mentioned in the introduction, signals are Godot's version of the "
"observer pattern. You can learn more about it in `Game Programming Patterns "
"<https://gameprogrammingpatterns.com/observer.html>`__."
msgstr ""
"如同簡介中提到的，訊號是 Godot 實作的觀察者模式。您可以在 `遊戲程式設計模式 "
"<https://gameprogrammingpatterns.com/observer.html>`__ 這份資料中找到更多相關"
"資訊。"

msgid ""
"We will now use a signal to make our Godot icon from the previous lesson "
"(:ref:`doc_scripting_player_input`) move and stop by pressing a button."
msgstr ""
"現在，我們將使用訊號來使上一節課（ :ref:`doc_scripting_player_input` ）中的 "
"Godot 圖示移動，並通過按下按鈕來停止。"

msgid "For this project, we will be following the Godot naming conventions."
msgstr "在這個專案中，我們會遵守 Godot 的命名慣例。"

msgid ""
"**GDScript**: Classes (nodes) use PascalCase, variables and functions use "
"snake_case, and constants use ALL_CAPS (See :ref:`doc_gdscript_styleguide`)."
msgstr ""
"**GDScript** ：類別 (節點) 使用大駝峰法 (PascalCase)，變數與函式名稱使用蛇形"
"法 (snake_case)，常數則使用全大寫 (ALL_CAPS) (詳細請參"
"考 :ref:`doc_gdscript_styleguide`)。"

msgid ""
"**C#**: Classes, export variables and methods use PascalCase, private fields "
"use _camelCase, local variables and parameters use camelCase "
"(See :ref:`doc_c_sharp_styleguide`). Be careful to type the method names "
"precisely when connecting signals."
msgstr ""
"**C#** ：類別與匯出的變數與方法使用大駝峰法 (PascalCase)，Private 欄位使用底"
"線加小駝峰 (_camelCase)，區域變數與參數使用小駝峰法 (camelCase) (請參"
"考 :ref:`doc_c_sharp_styleguide` )。在連接訊號的時候請特別注意不要打錯方法名"
"稱。"

msgid "Scene setup"
msgstr "場景設定"

msgid ""
"To add a button to our game, we will create a new scene which will include "
"both a :ref:`Button <class_button>` and the ``sprite_2d.tscn`` scene we "
"created in the :ref:`doc_scripting_first_script` lesson."
msgstr ""
"為了替我們的遊戲新增一個按鈕，我們將建立一個新場景，其中會包含一"
"個 :ref:`Button <class_button>` 和我們在 :ref:`doc_scripting_first_script` 教"
"學課程中建立的 ``sprite_2d.tscn`` 場景。"

msgid "Create a new scene by going to the menu :menu:`Scene > New Scene`."
msgstr "到功能表 :menu:`Scene > New Scene` 建立新場景。"

msgid ""
"In the Scene dock, click the :button:`2D Scene` button. This will add "
"a :ref:`Node2D <class_Node2D>` as our root."
msgstr ""
"在 Scene 面板點擊 :button:`2D Scene` 按鈕，即會新增一個 :ref:`Node2D "
"<class_Node2D>` 作為根節點。"

msgid ""
"In the FileSystem dock, click and drag the ``sprite_2d.tscn`` file you saved "
"previously onto the Node2D to instantiate it."
msgstr ""
"在檔案系統面板中，按一下之前保存的 ``sprite_2d.tscn`` 檔並將其拖動到 Node2D "
"上，對其進行產生實體。"

msgid ""
"We want to add another node as a sibling of the Sprite2D. To do so, right-"
"click on Node2D and select :button:`Add Child Node`."
msgstr ""
"我們要新增另一個節點作為 Sprite2D 的同層級節點。請在 Node2D 上按右鍵並選"
"擇 :button:`Add Child Node`。"

msgid "Search for the :ref:`Button <class_button>` node and add it."
msgstr "搜尋並新增 :ref:`Button <class_button>` 節點。"

msgid ""
"The node is small by default. Click and drag on the bottom-right handle of "
"the Button in the viewport to resize it."
msgstr "該節點預設比較小。在視口中，點擊並拖拽該按鈕右下角的手柄來調整大小。"

msgid ""
"If you don't see the handles, ensure the select tool is active in the "
"toolbar."
msgstr "如果看不到手柄，請確保工具列中的選擇工具處於活動狀態。"

msgid "Click and drag on the button itself to move it closer to the sprite."
msgstr "點擊並拖拽按鈕使其更接近精靈。"

msgid ""
"You can also write a label on the Button by editing its :inspector:`Text` "
"property in the :ui:`Inspector`. Enter ``Toggle motion``."
msgstr ""
"你也可以在 :ui:`Inspector` 中編輯 Button 的 :inspector:`Text` 屬性來顯示文"
"字。請輸入 ``Toggle motion``。"

msgid "Your scene tree and viewport should look like this."
msgstr "你的視口跟場景樹應該會長這樣。"

msgid ""
"Save your newly created scene as ``node_2d.tscn``, if you haven't already. "
"You can then run it with :kbd:`F6` (:kbd:`Cmd + R` on macOS). At the moment, "
"the button will be visible, but nothing will happen if you press it."
msgstr ""
"如果你還沒保存場景的話，保存新建的場景為 ``node_2d.tscn`` 。然後你就可以使"
"用 :kbd:`F6`（macOS 則為 :kbd:`Cmd + R` ）來運作。此時，你可以看到按鈕，但是"
"按下之後不會有任何反應。"

msgid "Connecting a signal in the editor"
msgstr "使用程式碼來連接訊號"

msgid ""
"Here, we want to connect the Button's \"pressed\" signal to our Sprite2D, "
"and we want to call a new function that will toggle its motion on and off. "
"We need to have a script attached to the Sprite2D node, which we do from the "
"previous lesson."
msgstr ""
"然後，我們希望將按鈕的“pressed”訊號連接到我們的 Sprite2D，並且我們想要呼叫一"
"個新函式來打開和關閉其運動。我們需要像我們在上一課中所做的操作一樣，將一個腳"
"本附加到 Sprite2D 節點。"

msgid ""
"You can connect signals in the :ui:`Node` dock. Select the Button node and, "
"on the right side of the editor, click on the tab named :ui:`Node` next to "
"the :ui:`Inspector`."
msgstr ""
"你可以在 :ui:`Node` 面板連接訊號。選取 Button 節點，並在編輯器右側點"
"選 :ui:`Inspector` 旁的 :ui:`Node` 分頁。"

msgid "The dock displays a list of signals available on the selected node."
msgstr "停靠欄顯示所選節點上可用的訊號列表。"

msgid "Double-click the \"pressed\" signal to open the node connection window."
msgstr "按兩下“pressed”訊號，打開節點連接視窗。"

msgid ""
"There, you can connect the signal to the Sprite2D node. The node needs a "
"receiver method, a function that Godot will call when the Button emits the "
"signal. The editor generates one for you. By convention, we name these "
"callback methods \"_on_node_name_signal_name\". Here, it'll be "
"\"_on_button_pressed\"."
msgstr ""
"然後，您可以將訊號連接到 Sprite2D 節點。該節點需要一個用於接收按鈕訊號的函"
"式，當按鈕發出訊號時，Godot 將呼叫該函式。編輯器會為您生成一個。按照規範，我"
"們將這些回呼函式方法命名為\"_on_node_name_signal_name\"。在這裡，它被命名為"
"\"_on_button_pressed\"。"

msgid ""
"When connecting signals via the editor's Node dock, you can use two modes. "
"The simple one only allows you to connect to nodes that have a script "
"attached to them and creates a new callback function on them."
msgstr ""
"通過編輯器的節點面板連接訊號時，可以使用兩種模式。簡單的一個隻允許您連接到附"
"加了腳本的節點，並在它們上面建立一個新的回呼函式。"

msgid ""
"The advanced view lets you connect to any node and any built-in function, "
"add arguments to the callback, and set options. You can toggle the mode in "
"the window's bottom-right by clicking the :button:`Advanced` button."
msgstr ""
"進階視圖可讓你連接到任意節點與內建函式、為回呼新增參數並設定選項。你可以點擊"
"視窗右下的 :button:`Advanced` 來切換模式。"

msgid ""
"If you are using an external editor (such as VS Code), this automatic code "
"generation might not work. In this case, you need to connect the signal via "
"code as explained in the next section."
msgstr ""
"如果您使用外部編輯器（例如 VS Code），這個自動產生程式碼的功能可能無法運作。"
"在這種情況下，您需要透過程式碼連接訊號，如同下一節所說明。"

msgid ""
"Click the :button:`Connect` button to complete the signal connection and "
"jump to the :ui:`Script` workspace. You should see the new method with a "
"connection icon in the left margin."
msgstr ""
"按下 :button:`Connect` 以完成訊號連接，並跳轉到 :ui:`Script` 工作區。你應會看"
"到左側邊緣帶有連線圖示的新方法。"

msgid ""
"If you click the icon, a window pops up and displays information about the "
"connection. This feature is only available when connecting nodes in the "
"editor."
msgstr ""
"如果按一下該圖示，將彈出一個視窗並顯示有關連接的資訊。此功能僅在編輯器中連接"
"節點時可用。"

msgid ""
"Let's replace the line with the ``pass`` keyword with code that'll toggle "
"the node's motion."
msgstr "讓我們用程式碼替換帶有 ``pass`` 關鍵字的一行，以切換節點的運動。"

msgid ""
"Our Sprite2D moves thanks to code in the ``_process()`` function. Godot "
"provides a method to toggle processing on and off: :ref:`Node.set_process() "
"<class_Node_method_set_process>`. Another method of the Node class, "
"``is_processing()``, returns ``true`` if idle processing is active. We can "
"use the ``not`` keyword to invert the value."
msgstr ""
"我們的 Sprite2D 由於 ``_process()`` 函式中的程式碼而移動。Godot 提供了一種打"
"開和關閉處理的方法：:ref:`Node.set_process() "
"<class_Node_method_set_process>` 。Node 的另一個方法 ``is_processing()`` ，如"
"果空閒處理處於活動狀態，則返回 ``true`` 。我們可以使用 ``not`` 關鍵字來反轉該"
"值。"

msgid ""
"This function will toggle processing and, in turn, the icon's motion on and "
"off upon pressing the button."
msgstr "此函式將切換處理，進而切換按下按鈕時圖示的移動。"

msgid ""
"Before trying the game, we need to simplify our ``_process()`` function to "
"move the node automatically and not wait for user input. Replace it with the "
"following code, which we saw two lessons ago:"
msgstr ""
"在嘗試遊戲之前，我們需要簡化 ``_process()`` 函式，以自動移動節點，而不是等待"
"使用者輸入。將其替換為以下程式碼，這是我們在兩課前看到的程式碼："

msgid "Your complete ``sprite_2d.gd`` code should look like the following."
msgstr "完整的 ''Sprite_2d.gd'' 程式碼應該是類似下面這樣的。"

msgid ""
"Run the current scene by pressing :kbd:`F6` (:kbd:`Cmd + R` on macOS), and "
"click the button to see the sprite start and stop."
msgstr ""
"按 :kbd:`F6` （macOS 為 :kbd:`Cmd + R` ）執行目前場景，並點擊按鈕以觀察精靈開"
"始與停止。"

msgid "Connecting a signal via code"
msgstr "使用程式碼來連接訊號"

msgid ""
"You can connect signals via code instead of using the editor. This is "
"necessary when you create nodes or instantiate scenes inside of a script."
msgstr ""
"您可以通過程式碼連接訊號，而不是使用編輯器。這在腳本中建立節點或產生實體場景"
"時是必需的。"

msgid ""
"Let's use a different node here. Godot has a :ref:`Timer <class_Timer>` node "
"that's useful to implement skill cooldown times, weapon reloading, and more."
msgstr ""
"讓我們在這裡使用一個不同的節點。Godot 有一個 :ref:`Timer <class_Timer>` 節"
"點，可用於實作技能冷卻時間、武器重裝等。"

msgid ""
"Head back to the 2D workspace. You can either click the \"2D\" text at the "
"top of the window or press :kbd:`Ctrl + F1` (:kbd:`Ctrl + Cmd + 1` on macOS)."
msgstr ""
"回到 2D 工作區。你可以點擊視窗頂端的「2D」文字，或是按下鍵盤快速"
"鍵 :kbd:`Ctrl + F1` (macOS 上是 :kbd:`Ctrl + Cmd + 1`)。"

msgid ""
"In the Scene dock, right-click on the Sprite2D node and add a new child "
"node. Search for Timer and add the corresponding node. Your scene should now "
"look like this."
msgstr ""
"在“場景”面板中，右鍵點擊 Sprite2D 節點並新增新的子節點。搜索 Timer 並新增對應"
"節點。你的場景現在應該類似這樣。"

msgid ""
"With the Timer node selected, go to the :ui:`Inspector` and enable "
"the :inspector:`Autostart` property."
msgstr ""
"選取 Timer 節點，前往 :ui:`Inspector` 啟用 :inspector:`Autostart` 屬性。"

msgid ""
"Click the script icon next to Sprite2D to jump back to the scripting "
"workspace."
msgstr "點擊 Sprite2D 旁的腳本圖示，返回腳本工作區。"

msgid "We need to do two operations to connect the nodes via code:"
msgstr "我們需要執行兩個操作來通過程式碼連接節點："

msgid "Get a reference to the Timer from the Sprite2D."
msgstr "從 Sprite2D 獲得 Timer 的引用。"

msgid "Call the ``connect()`` method on the Timer's \"timeout\" signal."
msgstr "通過 Timer 的“timeout”訊號呼叫 ``connect()`` 方法。"

msgid ""
"To connect to a signal via code, you need to call the ``connect()`` method "
"of the signal you want to listen to. In this case, we want to listen to the "
"Timer's \"timeout\" signal."
msgstr ""
"要使用程式碼來連接訊號，你需要呼叫所需監聽節點訊號的 ``connect()`` 方法。這裡"
"我們要監聽的是 Timer 的“timeout”訊號。"

msgid ""
"We want to connect the signal when the scene is instantiated, and we can do "
"that using the :ref:`Node._ready() <class_Node_private_method__ready>` built-"
"in function, which is called automatically by the engine when a node is "
"fully instantiated."
msgstr ""
"我們想要在場景實例化時連接訊號，而我們可以使用 :ref:`Node._ready() "
"<class_Node_private_method__ready>` 這個內建函式來做到這一點。當節點完全實例"
"化後，引擎會自動呼叫這個函式。"

msgid ""
"To get a reference to a node relative to the current one, we use the "
"method :ref:`Node.get_node() <class_Node_method_get_node>`. We can store the "
"reference in a variable."
msgstr ""
"為了獲取相對於目前節點的引用，我們使用方法 :ref:`Node.get_node() "
"<class_Node_method_get_node>` 。我們可以將引用儲存在變數中。"

msgid ""
"The function ``get_node()`` looks at the Sprite2D's children and gets nodes "
"by their name. For example, if you renamed the Timer node to "
"\"BlinkingTimer\" in the editor, you would have to change the call to "
"``get_node(\"BlinkingTimer\")``."
msgstr ""
"``get_node()`` 函式會查看 Sprite2D 的子節點，並按節點的名稱獲取節點。例如，如"
"果在編輯器中將 Timer 節點重命名為“BlinkingTimer”，則必須將呼叫更改為 "
"``get_node(\"BlinkingTimer\")`` 。"

msgid ""
"We can now connect the Timer to the Sprite2D in the ``_ready()`` function."
msgstr "現在，我們可以在 ``_ready()`` 函式中將Timer連接到Sprite2D。"

msgid ""
"The line reads like so: we connect the Timer's \"timeout\" signal to the "
"node to which the script is attached. When the Timer emits ``timeout``, we "
"want to call the function ``_on_timer_timeout()``, that we need to define. "
"Let's add it at the bottom of our script and use it to toggle our sprite's "
"visibility."
msgstr ""
"該行讀起來是這樣的：我們將計時器的“timeout”訊號連接到腳本附加到的節點上。當計"
"時器發出“timeout”時，去呼叫我們需要定義的函式``_on_timer_timeout()``。讓我們"
"將其定義新增到腳本的底部，並使用它來切換 sprite 的可見性。"

msgid ""
"By convention, we name these callback methods in GDScript as "
"\"_on_node_name_signal_name\" and in C# as \"OnNodeNameSignalName\". Here, "
"it'll be \"_on_timer_timeout\" for GDScript and OnTimerTimeout() for C#."
msgstr ""
"按照慣例，我們將這些回呼函式方法在 GDScript 中命名"
"為“_on_node_name_signal_name”，在 C# 中命名為“OnNodeNameSignalName”。故此處的"
"GDScript 為“_on_timer_timeout”，C# 為“OnTimerTimeout()”。"

msgid ""
"The ``visible`` property is a boolean that controls the visibility of our "
"node. The line ``visible = not visible`` toggles the value. If ``visible`` "
"is ``true``, it becomes ``false``, and vice-versa."
msgstr ""
"``visible`` 屬性是一個布林值，用於控制節點的可見性。 ``visible = not "
"visible`` 行切換該值。如果 ``visible`` 是 ``true`` ，它就會變成 ``false`` ，"
"反之亦然。"

msgid ""
"If you run the Node2D scene now, you will see that the sprite blinks on and "
"off, at one second intervals."
msgstr "如果您現在執行 Node2D 場景，您會看到這個 Sprite 以一秒的間隔閃爍。"

msgid "Complete script"
msgstr "GDScript 範例"

msgid ""
"That's it for our little moving and blinking Godot icon demo! Here is the "
"complete ``sprite_2d.gd`` file for reference."
msgstr ""
"這就是我們小小的 Godot 圖示移動閃爍演示了！這是完整的 ``sprite_2d.gd`` 檔案，"
"僅供參考。"

msgid "Custom signals"
msgstr "自定訊號"

msgid ""
"This section is a reference on how to define and use your own signals, and "
"does not build upon the project created in previous lessons."
msgstr "本節介紹的是如何定義並使用你自己的訊號，不依賴之前課程所建立的專案。"

msgid ""
"You can define custom signals in a script. Say, for example, that you want "
"to show a game over screen when the player's health reaches zero. To do so, "
"you could define a signal named \"died\" or \"health_depleted\" when their "
"health reaches 0."
msgstr ""
"您可以在腳本中定義自訂訊號。例如，假設您希望在玩家的生命值為零時通過螢幕顯示"
"遊戲結束。為此，當他們的生命值達到 0 時，您可以定義一個名"
"為“died”或“health_depleted”的訊號。"

msgid ""
"As signals represent events that just occurred, we generally use an action "
"verb in the past tense in their names."
msgstr "由於訊號表示剛剛發生的事件，我們通常在其名稱中使用過去時態的動作動詞。"

msgid ""
"Your signals work the same way as built-in ones: they appear in "
"the :ui:`Node` tab and you can connect to them like any other."
msgstr ""
"自訂訊號與內建訊號運作方式相同：它們會出現在 :ui:`Node` 分頁中，你可以像其他"
"訊號一樣連接它們。"

msgid "To emit a signal in your scripts, call ``emit()`` on the signal."
msgstr "要在腳本中發出信號，需呼叫信號的 ``emit()`` 方法。"

msgid ""
"A signal can optionally declare one or more arguments. Specify the argument "
"names between parentheses:"
msgstr "訊號也可以宣告一個或多個參數。在括號中指定參數的名稱："

msgid ""
"The signal arguments show up in the editor's node dock, and Godot can use "
"them to generate callback functions for you. However, you can still emit any "
"number of arguments when you emit signals. So it's up to you to emit the "
"correct values."
msgstr ""
"訊號的參數會顯示在編輯器的節點 Dock 中。Godot 會使用訊號參數來產生回呼函式。"
"但送出訊號時一樣可以送出任意數量的參數，可自行決定是否要送出正確的數量。"

msgid ""
"To emit values along with the signal, add them as extra arguments to the "
"``emit()`` function:"
msgstr "若需要傳遞數值，可將數值放在 ``emit_signal`` 函式的第二個參數內："

msgid "Summary"
msgstr "總結"

msgid ""
"Any node in Godot emits signals when something specific happens to them, "
"like a button being pressed. Other nodes can connect to individual signals "
"and react to selected events."
msgstr ""
"Godot 中的任何節點都會在發生特定事件時發出訊號，例如按下按鈕。其他節點可以連"
"接到單個訊號並對所選事件做出反應。"

msgid ""
"Signals have many uses. With them, you can react to a node entering or "
"exiting the game world, to a collision, to a character entering or leaving "
"an area, to an element of the interface changing size, and much more."
msgstr ""
"訊號有很多用途。有了它們，你可以對進入或退出遊戲世界的節點、碰撞、角色進入或"
"離開某個區域、介面元素的大小變化等等做出反應。"

msgid ""
"For example, an :ref:`Area2D <class_Area2D>` representing a coin emits a "
"``body_entered`` signal whenever the player's physics body enters its "
"collision shape, allowing you to know when the player collected it."
msgstr ""
"許多 Godot 內建的型別都提供各種訊號可用來偵測事件。例如，當金幣 :ref:`Area2D "
"<class_Area2D>` 物件送出 ``body_entered`` 訊號，就表示玩家物理形體進入了金幣"
"的碰撞區域，代表玩家蒐集到金幣。"

msgid ""
"In the next section, :ref:`doc_your_first_2d_game`, you'll create a complete "
"2D game and put everything you learned so far into practice."
msgstr ""
"在下一章 :ref:`doc_your_first_2d_game` 中，你將會製作一款完整的 2D 遊戲，把目"
"前學到的知識全部實際應用。"
