#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Player scene and input actions"
msgstr "Player 場景與輸入事件"

msgid ""
"In the next two lessons, we will design the player scene, register custom "
"input actions, and code player movement. By the end, you'll have a playable "
"character that moves in eight directions."
msgstr ""
"在接下來的兩節課程中，我們將會設計玩家場景、註冊自訂輸入動作、編寫玩家移動程"
"式碼。在最後，你將會得到一個可以八方向移動的可遊玩角色。"

msgid ""
"Create a new scene by going to the **Scene** menu in the top-left and "
"clicking **New Scene**."
msgstr "到左上角 **Scene** 功能表點擊 **New Scene** 建立新場景。"

msgid ""
"Click the **Other Node** button and select the ``CharacterBody3D`` node type "
"to create a :ref:`CharacterBody3D <class_CharacterBody3D>` as the root node."
msgstr ""
"點擊 **Other Node** 並選擇 ``CharacterBody3D`` 節點型別，建"
"立 :ref:`CharacterBody3D <class_CharacterBody3D>` 作為根節點。"

msgid ""
"Rename the :ref:`CharacterBody3D <class_CharacterBody3D>` to ``Player``. "
"Character bodies are complementary to the area and rigid bodies used in the "
"2D game tutorial. Like rigid bodies, they can move and collide with the "
"environment, but instead of being controlled by the physics engine, **you** "
"dictate their movement. You will see how we use the node's unique features "
"when we code the jump and squash mechanics."
msgstr ""
"將 :ref:`CharacterBody3D <class_CharacterBody3D>` 重新命名為 ``Player``。角色"
"身體與 2D 教學中的 Area 與 RigidBody 互相對應。和剛體一樣，它能移動並與環境碰"
"撞，但移動不是由物理引擎主導，而是由 **你** 來控制。之後在實作跳躍與踩扁機制"
"時，你會看到此節點的獨特特性如何派上用場。"

msgid ""
"To learn more about the different physics node types, see "
"the :ref:`doc_physics_introduction`."
msgstr ""
"要學習更多關於不同物理節點型別的內容，請參"
"閱 :ref:`doc_physics_introduction`。"

msgid ""
"For now, we're going to create a basic rig for our character's 3D model. "
"This will allow us to rotate the model later via code while it plays an "
"animation."
msgstr ""
"現在，我們將為角色的 3D 模型建立一個基本的裝備。稍後我們將在播放動畫時通過程"
"式碼旋轉模型。"

msgid ""
"Add a :ref:`Node3D <class_Node3D>` node as a child of ``Player``. Select the "
"``Player`` node in the **Scene** tree and click the \"**+**\" button to add "
"a child node. Rename it to ``Pivot``."
msgstr ""
"新增一個 :ref:`Node3D <class_Node3D>` 作為 ``Player`` 的子節點。在 **Scene** "
"樹選取 ``Player``，點擊「**+**」新增子節點，並命名為 ``Pivot``。"

msgid ""
"Then, in the FileSystem dock, expand the ``art/`` folder by double-clicking "
"it and drag and drop ``player.glb`` onto ``Pivot``."
msgstr ""
"然後在檔案系統面板中，按兩下展開 ``art/`` 資料夾，將 ``player.glb`` 拖放到 "
"``Pivot`` 節點上。"

msgid ""
"This should instantiate the model as a child of ``Pivot``. You can rename it "
"to ``Character``."
msgstr ""
"這樣應該就會把這個模型產生實體為 ``Pivot`` 的子項。你可以將其重命名為 "
"``Character`` 。"

msgid ""
"The ``.glb`` files contain 3D scene data based on the open source glTF 2.0 "
"specification. They're a modern and powerful alternative to a proprietary "
"format like FBX, which Godot also supports. To produce these files, we "
"designed the model in `Blender 3D <https://www.blender.org/>`__ and exported "
"it to glTF."
msgstr ""
"``.glb`` 檔案包含基於開放原始碼 glTF 2.0 規格的 3D 場景資料。它們是現代且強大"
"的替代方案，可取代像 FBX 這樣的專有格式，而 Godot 也支援 FBX。為了產生這些檔"
"案，我們在 `Blender 3D <https://www.blender.org/>`__ 中設計模型，並將其匯出"
"為 glTF。"

msgid ""
"As with all kinds of physics nodes, we need a collision shape for our "
"character to collide with the environment. Select the ``Player`` node again "
"and add a child node :ref:`CollisionShape3D <class_CollisionShape3D>`. In "
"the **Inspector**, on the **Shape** property, add a new :ref:`SphereShape3D "
"<class_SphereShape3D>`."
msgstr ""
"與所有物理相關節點相同，我們需要碰撞形狀讓角色能與環境碰撞。再次選取 "
"``Player``，新增子節點 :ref:`CollisionShape3D <class_CollisionShape3D>`。在 "
"**Inspector** 的 **Shape** 屬性加入新的 :ref:`SphereShape3D "
"<class_SphereShape3D>`。"

msgid "The sphere's wireframe appears below the character."
msgstr "球體的線框出現在角色的下面。"

msgid ""
"It will be the shape the physics engine uses to collide with the "
"environment, so we want it to better fit the 3D model. Make it a bit larger "
"by dragging the orange dot in the viewport. My sphere has a radius of about "
"``0.8`` meters."
msgstr ""
"這將會是物理引擎用來與環境碰撞的形狀，所以我們希望它能更貼合 3D 模型。在視埠"
"中拖曳橘色圓點，將它稍微放大一點。我的球體的半徑大約是 ``0.8`` 公尺。"

msgid ""
"Then, move the collision shape up so its bottom roughly aligns with the "
"grid's plane."
msgstr "然後，將碰撞形狀向上移動，使其底部大致對齊格線平面。"

msgid ""
"To make moving the shape easier, you can toggle the model's visibility by "
"clicking the **eye icon** next to the ``Character`` or the ``Pivot`` nodes."
msgstr ""
"為了更容易移動形狀，你可以點擊 ``Character`` 或 ``Pivot`` 節點旁的 **眼睛圖示"
"** 來切換模型可見度。"

msgid "Save the scene as ``player.tscn``."
msgstr "將場景儲存為 ``player.tscn``。"

msgid ""
"With the nodes ready, we can almost get coding. But first, we need to define "
"some input actions."
msgstr "節點準備就緒後，我們開始編寫程式。但首先，我們需要定義一些輸入動作。"

msgid "Creating input actions"
msgstr "建立圖示"

msgid ""
"To move the character, we will listen to the player's input, like pressing "
"the arrow keys. In Godot, while we could write all the key bindings in code, "
"there's a powerful system that allows you to assign a label to a set of keys "
"and buttons. This simplifies our scripts and makes them more readable."
msgstr ""
"要移動角色，我們就要監聽玩家的輸入，比如按下方向鍵。在 Godot 中，我們能夠使用"
"程式碼來綁定按鍵，但還有一個非常強大的系統，可以讓你為一系列按鍵和按鈕設定標"
"籤。這樣可以簡化我們的腳本，讓它們更易讀。"

msgid ""
"This system is the Input Map. To access its editor, head to the **Project** "
"menu and select **Project Settings...**."
msgstr ""
"這個系統稱為 Input Map。要開啟其編輯器，請到 **Project** 功能表並選擇 "
"**Project Settings...**。"

msgid ""
"At the top, there are multiple tabs. Click on **Input Map**. This window "
"allows you to add new actions at the top; they are your labels. In the "
"bottom part, you can bind keys to these actions."
msgstr ""
"上方有多個分頁。點選 **Input Map**。此視窗允許你在上方新增動作，下方則可為動"
"作綁定按鍵或按鈕。"

msgid ""
"Godot projects come with some predefined actions designed for user interface "
"design (see above screenshot). These will become visible if you enable the "
"**Show Built-in Actions** toggle. We could use these here, but instead we're "
"defining our own to support gamepads. Leave **Show Built-in Actions** "
"disabled."
msgstr ""
"Godot 專案內含一些為使用者介面設計而預先定義的動作（見上方截圖）。啟用 "
"**Show Built-in Actions** 即可顯示。我們也可以直接使用它們，但這裡為了支援手"
"把，將自訂動作。請保持 **Show Built-in Actions** 關閉。"

msgid ""
"We're going to name our actions ``move_left``, ``move_right``, "
"``move_forward``, ``move_back``, and ``jump``."
msgstr ""
"我們將把我們的動作命名為 ``move_left``、``move_right``、``move_forward``、"
"``move_back`` 和 ``jump``。"

msgid ""
"To add an action, write its name in the bar at the top and press Enter or "
"click the **Add** button."
msgstr "要新增動作，請在上方輸入名稱後按 Enter，或點擊 **Add**。"

msgid "Create the following five actions:"
msgstr "有下列事項需注意："

msgid ""
"To bind a key or button to an action, click the \"**+**\" button to its "
"right. Do this for ``move_left``. Press the left arrow key and click **OK**."
msgstr ""
"要將按鍵或按鈕綁定到動作，點擊其右側的「**+**」按鈕。以 ``move_left`` 為例，"
"按左方向鍵後點擊 **OK**。"

msgid "Bind also the :kbd:`A` key, onto the action ``move_left``."
msgstr "將 :kbd:`A` 鍵也綁定在動作 ``move_left`` 上面。"

msgid ""
"Let's now add support for a gamepad's left joystick. Click the \"**+**\" "
"button again but this time, select the input within the input tree yourself. "
"Select the negative X axis of the left joystick under **Joypad Axes**."
msgstr ""
"接著加入手把左搖桿的支援。再次點擊「**+**」，這次請在輸入樹中自行選擇，於 "
"**Joypad Axes** 底下選擇左搖桿的負 X 軸。"

msgid "Leave the other values as default and press **OK**."
msgstr "其餘值維持預設，按 **OK**。"

msgid ""
"If you want controllers to have different input actions, you should use the "
"Devices option in Additional Options. Device 0 corresponds to the first "
"plugged gamepad, Device 1 corresponds to the second plugged gamepad, and so "
"on."
msgstr ""
"如果你想讓多個手柄有不同的輸入動作，你需要在額外選項中使用裝置選項。裝置 0 對"
"應的是第一個插入的手柄，裝置 1 對應的是第二個插入的手柄，以此類推。"

msgid ""
"Do the same for the other input actions. For example, bind the right arrow, "
"D, and the left joystick's positive axis to ``move_right``. After binding "
"all keys, your interface should look like this."
msgstr ""
"為其他輸入動作也執行同樣的操作。比如將右方向鍵、D、左搖桿的正軸綁定給 "
"``move_right``。全部綁定完後，你的介面應該類似這樣。"

msgid ""
"The final action to set up is the ``jump`` action. Bind the Space key and "
"the gamepad's A button located under **Joypad Buttons**."
msgstr ""
"最後設定 ``jump`` 動作。請綁定空白鍵與 **Joypad Buttons** 下的手把 A 鈕。"

msgid "Your jump input action should look like this."
msgstr "你的跳躍輸入動作應該會像這樣。"

msgid ""
"That's all the actions we need for this game. You can use this menu to label "
"any groups of keys and buttons in your projects."
msgstr ""
"這些就是這個遊戲所需的所有動作了。你可以使用這個功能表來對專案中的任意按鍵和"
"按鈕組進行標記。"

msgid "In the next part, we'll code and test the player's movement."
msgstr "在下一部分，我們將為玩家的移動進行程式設計和測試。"
