#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom modules in C++"
msgstr "以 C++ 自訂模組"

msgid "Modules"
msgstr "模組"

msgid ""
"Godot allows extending the engine in a modular way. New modules can be "
"created and then enabled/disabled. This allows for adding new engine "
"functionality at every level without modifying the core, which can be split "
"for use and reuse in different modules."
msgstr ""
"Godot 支援以模組化方式擴充引擎。你可以建立新模組，並啟用或停用它們。這讓你能"
"在不修改核心的情況下，於各層級加入新功能，並可分拆成不同模組重複利用。"

msgid "What for?"
msgstr "用途說明?"

msgid ""
"While it's recommended that most of a game be written in scripting (as it is "
"an enormous time saver), it's perfectly possible to use C++ instead. Adding "
"C++ modules can be useful in the following scenarios:"
msgstr ""
"雖然大多數遊戲建議主要以腳本撰寫（如此可大幅節省開發時間），但你完全可以選擇 "
"C++。下列情境適合以 C++ 製作模組："

msgid "Binding an external library to Godot (like PhysX, FMOD, etc)."
msgstr "將外部函式庫（如 PhysX、FMOD 等）繫結到 Godot。"

msgid "Optimize critical parts of a game."
msgstr "最佳化遊戲中關鍵部分。"

msgid "Adding new functionality to the engine and/or editor."
msgstr "為引擎或編輯器新增功能。"

msgid "Porting an existing game to Godot."
msgstr "將現有遊戲移植到 Godot。"

msgid "Write a whole, new game in C++ because you can't live without C++."
msgstr "如果你就是非 C++ 不可，也可以用 C++ 製作整個新遊戲。"

msgid "Creating a new module"
msgstr "建立新模組"

msgid ""
"Before creating a module, make sure to :ref:`download the source code of "
"Godot and compile it <toc-devel-compiling>`."
msgstr ""
"在建立模組前，請先 :ref:`下載 Godot 原始碼並完成編譯 <toc-devel-compiling>`。"

msgid ""
"To create a new module, the first step is creating a directory inside "
"``modules/``. If you want to maintain the module separately, you can "
"checkout a different VCS into modules and use it."
msgstr ""
"建立新模組的第一步是在 ``modules/`` 目錄下新增一個資料夾。若想獨立維護模組，"
"也可以在 modules 目錄內簽出（checkout）不同的版本控制系統（VCS）來使用。"

msgid ""
"The example module will be called \"summator\" (``godot/modules/summator``). "
"Inside we will create a summator class:"
msgstr ""
"假設範例模組名為「summator」（``godot/modules/summator``），我們會在其中建立"
"一個 summator 類別："

msgid "godot/modules/summator/summator.h"
msgstr "godot/modules/summator/summator.h"

msgid "And then the cpp file."
msgstr "接著是 cpp 檔。"

msgid "godot/modules/summator/summator.cpp"
msgstr "godot/modules/summator/summator.cpp"

msgid ""
"Then, the new class needs to be registered somehow, so two more files need "
"to be created:"
msgstr "然後，需要以某種方式註冊這個新類別，因此還要建立兩個檔案："

msgid ""
"These files must be in the top-level folder of your module (next to your "
"``SCsub`` and ``config.py`` files) for the module to be registered properly."
msgstr ""
"這些檔案必須放在模組的最上層資料夾（與 ``SCsub`` 和 ``config.py`` 同一層），"
"模組才能正確註冊。"

msgid "These files should contain the following:"
msgstr "這些檔案應包含以下內容："

msgid "godot/modules/summator/register_types.h"
msgstr "godot/modules/summator/register_types.h"

msgid "godot/modules/summator/register_types.cpp"
msgstr "godot/modules/summator/register_types.cpp"

msgid ""
"Next, we need to create an ``SCsub`` file so the build system compiles this "
"module:"
msgstr "接下來，需要建立 ``SCsub`` 檔案，讓建置系統可以編譯這個模組："

msgid "godot/modules/summator/SCsub"
msgstr "godot/modules/summator/SCsub"

msgid ""
"With multiple sources, you can also add each file individually to a Python "
"string list:"
msgstr "如果有多個原始檔，也可以分別將每個檔案加入 Python 字串清單："

msgid ""
"This allows for powerful possibilities using Python to construct the file "
"list using loops and logic statements. Look at some modules that ship with "
"Godot by default for examples."
msgstr ""
"如此可利用 Python 的迴圈和邏輯語句靈活產生檔案清單。請參考 Godot 內建模組的寫"
"法作為範例。"

msgid ""
"To add include directories for the compiler to look at you can append it to "
"the environment's paths:"
msgstr "若要新增編譯器搜尋的 include 目錄，可將其附加至建置環境的路徑中："

msgid ""
"If you want to add custom compiler flags when building your module, you need "
"to clone ``env`` first, so it won't add those flags to whole Godot build "
"(which can cause errors). Example ``SCsub`` with custom flags:"
msgstr ""
"若要為模組新增自訂編譯器旗標，須先複製 ``env``，避免影響整個 Godot 編譯（否則"
"可能導致錯誤）。以下為帶有自訂旗標的 ``SCsub`` 範例："

msgid ""
"And finally, the configuration file for the module, this is a Python script "
"that must be named ``config.py``:"
msgstr ""
"最後，還需要模組的組態設定檔，也就是一個必須命名為 ``config.py`` 的 Python 腳"
"本："

msgid "godot/modules/summator/config.py"
msgstr "godot/modules/summator/config.py"

msgid ""
"The module is asked if it's OK to build for the specific platform (in this "
"case, ``True`` means it will build for every platform)."
msgstr ""
"建置時會詢問是否可針對特定平台建置（本例中 ``True`` 代表所有平台都會建置）。"

msgid ""
"And that's it. Hope it was not too complex! Your module should look like "
"this:"
msgstr "就這樣，應該不會太複雜吧！你的模組結構應該會長這樣："

msgid ""
"You can then zip it and share the module with everyone else. When building "
"for every platform (instructions in the previous sections), your module will "
"be included."
msgstr ""
"你可以將模組壓縮打包，分享給其他人。當編譯所有平台版本時（詳見前面說明），你"
"的模組也會被包含進去。"

msgid "Using the module"
msgstr "使用模組"

msgid "You can now use your newly created module from any script:"
msgstr "你現在可以在任何腳本中使用你新建立的模組："

msgid "The output will be ``60``."
msgstr "輸出結果會是 ``60``。"

msgid ""
"The previous Summator example is great for small, custom modules, but what "
"if you want to use a larger, external library? Refer "
"to :ref:`doc_binding_to_external_libraries` for details about binding to "
"external libraries."
msgstr ""
"前面的 Summator 範例適合用來製作小型自訂模組。若要整合大型外部函式庫，請參"
"考 :ref:`doc_binding_to_external_libraries` 取得詳細繫結教學。"

msgid ""
"If your module is meant to be accessed from the running project (not just "
"from the editor), you must also recompile every export template you plan to "
"use, then specify the path to the custom template in each export preset. "
"Otherwise, you'll get errors when running the project as the module isn't "
"compiled in the export template. See the :ref:`Compiling <toc-devel-"
"compiling>` pages for more information."
msgstr ""
"如果你的模組要讓執行中的專案存取（不只是編輯器），那你還需要重新編譯所有要用"
"到的匯出範本，並在每個匯出預設設定中指定自訂範本路徑。否則執行專案時會因為模"
"組未被編譯進匯出範本而發生錯誤。詳情請參考 :ref:`編譯 <toc-devel-compiling>` "
"頁面。"

msgid "Compiling a module externally"
msgstr "外部編譯模組"

msgid ""
"Compiling a module involves moving the module's sources directly under the "
"engine's ``modules/`` directory. While this is the most straightforward way "
"to compile a module, there are a couple of reasons as to why this might not "
"be a practical thing to do:"
msgstr ""
"編譯模組通常是將原始碼直接放到引擎的 ``modules/`` 資料夾下。雖然這是最簡單直"
"觀的做法，不過有幾種情境可能不太適合："

msgid ""
"Having to manually copy modules sources every time you want to compile the "
"engine with or without the module, or taking additional steps needed to "
"manually disable a module during compilation with a build option similar to "
"``module_summator_enabled=no``. Creating symbolic links may also be a "
"solution, but you may additionally need to overcome OS restrictions like "
"needing the symbolic link privilege if doing this via script."
msgstr ""
"每次想在有或沒有模組的情況下編譯引擎，都必須手動複製模組原始碼，或是額外用 "
"``module_summator_enabled=no`` 這類建置選項來手動關閉模組。你也可以用符號連"
"結，但若用腳本自動化，還得處理作業系統權限（如需要符號連結權限）等限制。"

msgid ""
"Depending on whether you have to work with the engine's source code, the "
"module files added directly to ``modules/`` changes the working tree to the "
"point where using a VCS (like ``git``) proves to be cumbersome as you need "
"to make sure that only the engine-related code is committed by filtering "
"changes."
msgstr ""
"如果你有維護引擎原始碼，將模組檔案直接放在 ``modules/`` 會讓工作目錄變雜，使"
"用版控（如 git）時，還得過濾只提交引擎相關變更，會變得麻煩。"

msgid ""
"So if you feel like the independent structure of custom modules is needed, "
"lets take our \"summator\" module and move it to the engine's parent "
"directory:"
msgstr ""
"如果你想讓自訂模組維持獨立結構，可以把「summator」模組移到引擎的上層目錄："

msgid ""
"Compile the engine with our module by providing ``custom_modules`` build "
"option which accepts a comma-separated list of directory paths containing "
"custom C++ modules, similar to the following:"
msgstr ""
"然後以 ``custom_modules`` 建置選項編譯引擎，該選項可用逗號分隔路徑，指定多個"
"自訂 C++ 模組目錄，指令如下："

msgid ""
"The build system shall detect all modules under the ``../modules`` directory "
"and compile them accordingly, including our \"summator\" module."
msgstr ""
"建置系統會自動偵測 ``../modules`` 目錄下所有模組並編譯，包括我們的 summator "
"模組。"

msgid ""
"Any path passed to ``custom_modules`` will be converted to an absolute path "
"internally as a way to distinguish between custom and built-in modules. It "
"means that things like generating module documentation may rely on a "
"specific path structure on your machine."
msgstr ""
"所有傳給 ``custom_modules`` 的路徑都會在內部轉為絕對路徑，以區分自訂與內建模"
"組。這也表示，例如產生模組說明文件時，可能會仰賴你電腦上的特定路徑結構。"

msgid ""
":ref:`Introduction to the buildsystem - Custom modules build option "
"<doc_buildsystem_custom_modules>`."
msgstr ""
":ref:`建置系統簡介 - 自訂模組建置選項 <doc_buildsystem_custom_modules>`。"

msgid "Customizing module types initialization"
msgstr "自訂模組類型初始化流程"

msgid ""
"Modules can interact with other built-in engine classes during runtime and "
"even affect the way core types are initialized. So far, we've been using "
"``register_summator_types`` as a way to bring in module classes to be "
"available within the engine."
msgstr ""
"模組可以在執行時與其他內建引擎類別互動，甚至影響核心型別的初始化方式。到目前"
"為止，我們都是透過 ``register_summator_types`` 來讓模組類別在引擎中可用。"

msgid ""
"A crude order of the engine setup can be summarized as a list of the "
"following type registration methods:"
msgstr "引擎設定的執行順序大致如下，包含這些型別註冊方法："

msgid ""
"Our ``Summator`` class is initialized during the ``register_module_types()`` "
"call. Imagine that we need to satisfy some common module runtime dependency "
"(like singletons), or allow us to override existing engine method callbacks "
"before they can be assigned by the engine itself. In that case, we want to "
"ensure that our module classes are registered *before* any other built-in "
"type."
msgstr ""
"我們的 `Summator` 類別會在 ``register_module_types()`` 被呼叫時初始化。假如我"
"們需要滿足一些常見的模組執行時相依（例如單例），或希望可在引擎指派前覆寫既有"
"的引擎方法回呼，那麼就得確保模組類別會在其他內建型別*之前*註冊。"

msgid ""
"This is where we can define an optional ``preregister_summator_types()`` "
"method which will be called before anything else during the "
"``preregister_module_types()`` engine setup stage."
msgstr ""
"這時你可以選擇定義 ``preregister_summator_types()`` 方法，這個方法會在 "
"``preregister_module_types()`` 引擎初始化階段最早被呼叫。"

msgid ""
"We now need to add this method to ``register_types`` header and source files:"
msgstr "現在要把這個方法加到 register_types 的標頭和原始檔："

msgid ""
"Unlike other register methods, we have to explicitly define "
"``MODULE_SUMMATOR_HAS_PREREGISTER`` to let the build system know what "
"relevant method calls to include at compile time. The module's name has to "
"be converted to uppercase as well."
msgstr ""
"與其他註冊方法不同，這裡要明確定義 ``MODULE_SUMMATOR_HAS_PREREGISTER``，讓建"
"置系統知道在編譯時要包含對應方法呼叫。模組名稱必須轉為全大寫。"

msgid "Writing custom documentation"
msgstr "撰寫自訂說明文件"

msgid ""
"Writing documentation may seem like a boring task, but it is highly "
"recommended to document your newly created module to make it easier for "
"users to benefit from it. Not to mention that the code you've written one "
"year ago may become indistinguishable from the code that was written by "
"someone else, so be kind to your future self!"
msgstr ""
"撰寫說明文件或許乏味，但強烈建議為新模組寫文件，這樣使用者才容易受惠。況且，"
"一年前你寫過的程式碼，未來看起來可能和別人寫的沒兩樣，所以請善待未來的自己！"

msgid "There are several steps in order to setup custom docs for the module:"
msgstr "設定模組自訂說明文件需經過以下步驟："

msgid ""
"Make a new directory in the root of the module. The directory name can be "
"anything, but we'll be using the ``doc_classes`` name throughout this "
"section."
msgstr ""
"在模組根目錄下新增一個資料夾，名稱可自訂，本教學以 ``doc_classes`` 為例。"

msgid "Now, we need to edit ``config.py``, add the following snippet:"
msgstr "接下來編輯 ``config.py``，加入下列程式碼："

msgid ""
"The ``get_doc_path()`` function is used by the build system to determine the "
"location of the docs. In this case, they will be located in the ``modules/"
"summator/doc_classes`` directory. If you don't define this, the doc path for "
"your module will fall back to the main ``doc/classes`` directory."
msgstr ""
"``get_doc_path()`` 會被建置系統用來決定文件路徑。本例中，會指定為 ``modules/"
"summator/doc_classes``。若未定義此函式，模組說明文件會退回存放在主 ``doc/"
"classes`` 目錄。"

msgid ""
"The ``get_doc_classes()`` method is necessary for the build system to know "
"which registered classes belong to the module. You need to list all of your "
"classes here. The classes that you don't list will end up in the main ``doc/"
"classes`` directory."
msgstr ""
"``get_doc_classes()`` 必須列出所有要註冊為此模組的類別，讓建置系統知道這些類"
"別屬於你的模組。沒列出的類別會被放到主 ``doc/classes`` 目錄。"

msgid "Now we can generate the documentation:"
msgstr "現在可以產生說明文件："

msgid ""
"We can do this via running Godot's doctool i.e. ``godot --doctool <path>``, "
"which will dump the engine API reference to the given ``<path>`` in XML "
"format."
msgstr ""
"只要執行 Godot 的 doctool，例如 ``godot --doctool <路徑>``，即可將引擎 API 參"
"考文件以 XML 格式匯出到指定路徑。"

msgid ""
"In our case we'll point it to the root of the cloned repository. You can "
"point it to an another folder, and just copy over the files that you need."
msgstr ""
"本例會輸出到 clone 下來的儲存庫根目錄。你也可以輸出到其他資料夾，再將需要的檔"
"案複製過去。"

msgid "Run command:"
msgstr "執行指令："

msgid ""
"Now if you go to the ``godot/modules/summator/doc_classes`` folder, you will "
"see that it contains a ``Summator.xml`` file, or any other classes, that you "
"referenced in your ``get_doc_classes`` function."
msgstr ""
"現在打開 ``godot/modules/summator/doc_classes`` 資料夾，會看到裡面有 "
"``Summator.xml`` 或你在 ``get_doc_classes`` 內列出的類別 XML 檔。"

msgid ""
"Once the compilation process is finished, the docs will become accessible "
"within the engine's built-in documentation system."
msgstr "編譯完成後，你就能在引擎內建說明文件系統中存取這些文件。"

msgid ""
"In order to keep documentation up-to-date, all you'll have to do is simply "
"modify one of the XML files and recompile the engine from now on."
msgstr "之後要更新說明文件，只需修改 XML 檔並重新編譯引擎即可。"

msgid ""
"If you change your module's API, you can also re-extract the docs, they will "
"contain the things that you previously added. Of course if you point it to "
"your godot folder, make sure you don't lose work by extracting older docs "
"from an older engine build on top of the newer ones."
msgstr ""
"如果你有更動模組 API，也可以重新產生文件，原本加入的內容還會保留。但若你將文"
"件存到 Godot 資料夾時，請避免用舊引擎覆蓋新文件，造成內容遺失。"

msgid ""
"Note that if you don't have write access rights to your supplied ``<path>``, "
"you might encounter an error similar to the following:"
msgstr ""
"注意：如果你對指定的 ``<路徑>`` 沒有寫入權限，可能會遇到類似下列的錯誤："

msgid "Writing custom unit tests"
msgstr "撰寫自訂單元測試"

msgid ""
"It's possible to write self-contained unit tests as part of a C++ module. If "
"you are not familiar with the unit testing process in Godot yet, please "
"refer to :ref:`doc_unit_testing`."
msgstr ""
"你可以把獨立的單元測試寫成 C++ 模組的一部分。如果你還不熟 Godot 的單元測試流"
"程，請參考 :ref:`doc_unit_testing`。"

msgid "The procedure is the following:"
msgstr "步驟如下："

msgid "Create a new directory named ``tests/`` under your module's root:"
msgstr "在模組根目錄新增一個 ``tests/`` 資料夾："

msgid ""
"Create a new test suite: ``test_summator.h``. The header must be prefixed "
"with ``test_`` so that the build system can collect it and include it as "
"part of the ``tests/test_main.cpp`` where the tests are run."
msgstr ""
"建立新的測試套件：``test_summator.h``。標頭檔需以 ``test_`` 為開頭，讓建置系"
"統能自動收集並包含於 ``tests/test_main.cpp`` 執行測試。"

msgid "Write some test cases. Here's an example:"
msgstr "寫幾個測試案例。例如："

msgid "godot/modules/summator/tests/test_summator.h"
msgstr "godot/modules/summator/tests/test_summator.h"

msgid ""
"Compile the engine with ``scons tests=yes``, and run the tests with the "
"following command:"
msgstr "以 ``scons tests=yes`` 編譯引擎，然後用以下指令執行測試："

msgid "You should see the passing assertions now."
msgstr "你現在應該會看到所有測試通過。"

msgid "Adding custom editor icons"
msgstr "新增自訂編輯器圖示"

msgid ""
"Similarly to how you can write self-contained documentation within a module, "
"you can also create your own custom icons for classes to appear in the "
"editor."
msgstr ""
"就像你可以在模組中撰寫獨立說明文件一樣，也能為類別製作自訂圖示，讓它們在編輯"
"器裡顯示。"

msgid ""
"For the actual process of creating editor icons to be integrated within the "
"engine, please refer to :ref:`doc_editor_icons` first."
msgstr "實際建立並整合編輯器圖示，請先參考 :ref:`doc_editor_icons`。"

msgid "Once you've created your icon(s), proceed with the following steps:"
msgstr "建立好圖示後，請依下列步驟進行："

msgid ""
"Make a new directory in the root of the module named ``icons``. This is the "
"default path for the engine to look for module's editor icons."
msgstr ""
"在模組根目錄建立一個叫 ``icons`` 的資料夾。這是引擎尋找模組編輯器圖示的預設路"
"徑。"

msgid ""
"Move your newly created ``svg`` icons (optimized or not) into that folder."
msgstr "將你新做的 ``svg`` 圖示（無論有無最佳化）都放進這個資料夾。"

msgid ""
"Recompile the engine and run the editor. Now the icon(s) will appear in "
"editor's interface where appropriate."
msgstr "重新編譯引擎並開啟編輯器。你的圖示會在適當位置顯示於編輯器介面。"

msgid ""
"If you'd like to store your icons somewhere else within your module, add the "
"following code snippet to ``config.py`` to override the default path:"
msgstr ""
"如果你想把圖示存放在模組其他位置，請在 ``config.py`` 加入下列程式碼，覆寫預設"
"路徑："

msgid "Summing up"
msgstr "總結"

msgid "Remember to:"
msgstr "記得："

msgid "Use ``GDCLASS`` macro for inheritance, so Godot can wrap it."
msgstr "繼承時使用 ``GDCLASS`` 巨集，這樣 Godot 才能正確包裝該類別。"

msgid ""
"Use ``_bind_methods`` to bind your functions to scripting, and to allow them "
"to work as callbacks for signals."
msgstr "使用 ``_bind_methods`` 將函式繫結到腳本，並讓它們支援訊號回呼。"

msgid ""
"**Avoid multiple inheritance for classes exposed to Godot**, as ``GDCLASS`` "
"doesn't support this. You can still use multiple inheritance in your own "
"classes as long as they're not exposed to Godot's scripting API."
msgstr ""
"**避免將多重繼承的類別暴露給 Godot**，因為 ``GDCLASS`` 不支援多重繼承。只要類"
"別未暴露給 Godot 腳本 API，仍可自行多重繼承。"

msgid ""
"But this is not all, depending what you do, you will be greeted with some "
"(hopefully positive) surprises."
msgstr "不過要注意，根據用途不同，還會遇到許多（希望是正面的）驚喜。"

msgid ""
"If you inherit from :ref:`class_Node` (or any derived node type, such as "
"Sprite2D), your new class will appear in the editor, in the inheritance tree "
"in the \"Add Node\" dialog."
msgstr ""
"如果你繼承自 :ref:`class_Node` （或如 Sprite2D 等其他節點類型），新類別會出現"
"在編輯器的「新增節點」對話框的繼承樹上。"

msgid ""
"If you inherit from :ref:`class_Resource`, it will appear in the resource "
"list, and all the exposed properties can be serialized when saved/loaded."
msgstr ""
"如果你繼承自 :ref:`class_Resource`，該類別會出現在資源列表，且所有公開屬性都"
"能在儲存／讀取時自動序列化。"

msgid ""
"By this same logic, you can extend the Editor and almost any area of the "
"engine."
msgstr "用同樣方式，你還能擴充編輯器或是引擎幾乎任何部分。"
