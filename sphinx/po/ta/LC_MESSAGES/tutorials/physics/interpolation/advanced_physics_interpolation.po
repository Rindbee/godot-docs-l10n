#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced physics interpolation"
msgstr "மேம்பட்ட இயற்பியல் இடைக்கணிப்பு"

msgid ""
"Although the previous instructions will give satisfactory results in a lot "
"of games, in some cases you will want to go a stage further to get the best "
"possible results and the smoothest possible experience."
msgstr ""
"முந்தைய அறிவுறுத்தல்கள் நிறைய விளையாட்டுகளில் திருப்திகரமான முடிவுகளைத் தரும் "
"என்றாலும், சில சந்தர்ப்பங்களில் நீங்கள் சிறந்த முடிவுகளையும், மென்மையான அனுபவத்தையும் பெற "
"ஒரு கட்டத்திற்கு செல்ல விரும்புவீர்கள்."

msgid "Exceptions to automatic physics interpolation"
msgstr "தானியங்கி இயற்பியல் இடைக்கணிப்புக்கான விதிவிலக்குகள்"

msgid ""
"Even with physics interpolation active, there may be some local situations "
"where you would benefit from disabling automatic interpolation for "
"a :ref:`Node<class_Node>` (or branch of "
"the :ref:`SceneTree<class_SceneTree>`), and have the finer control of "
"performing interpolation manually."
msgstr ""
"இயற்பியல் இடைக்கணிப்பு செயலில் இருந்தாலும், சில உள்ளக சூழ்நிலைகள் இருக்கலாம், அங்கு நீங்கள் "
"தானியங்கி இடைக்கணிப்பை முடக்குவதன் மூலம் பயனடைவீர்கள்: ref: `முனை <class_node>` "
"(அல்லது கிளை: ref: `காட்சி <class_scenetree>`), மற்றும் கைதட்டலை கைமுறையாகச் "
"செய்வதற்கான சிறந்த கட்டுப்பாட்டைக் கொண்டிருக்க வேண்டும்."

msgid ""
"This is possible using "
"the :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>` "
"property which is present in all Nodes. If you for example, turn off "
"interpolation for a Node, the children will recursively also be affected (as "
"they default to inheriting the parent setting). This means you can easily "
"disable interpolation for an entire subscene."
msgstr ""
"இது: Ref: `node.physics_interpolation_mode "
"<class_node_property_physics_interpolation_mode>` எல்லா முனைகளிலும் இருக்கும் "
"சொத்து. எடுத்துக்காட்டாக, நீங்கள் ஒரு முனைக்கான இடைக்கணிப்பை அணைக்கவும், குழந்தைகளும் "
"மறுநிகழ்வு பாதிக்கப்படுவார்கள் (பெற்றோர் அமைப்பைப் பெறுவதற்கு அவர்கள் இயல்புநிலையாக "
"இருப்பதால்). இதன் பொருள் நீங்கள் ஒரு முழு துணைக்குழுவிற்கான இடைக்கணிப்பை எளிதாக "
"முடக்கலாம்."

msgid ""
"The most common situation where you may want to perform your own "
"interpolation is Cameras."
msgstr "உங்கள் சொந்த இடைக்கணிப்பை நீங்கள் செய்ய விரும்பும் பொதுவான சூழ்நிலை கேமராக்கள்."

msgid "Cameras"
msgstr "கேமராக்கள்"

msgid ""
"In many cases, a :ref:`Camera3D<class_Camera3D>` can use automatic "
"interpolation just like any other node. However, for best results, "
"especially at low physics tick rates, it is recommended that you take a "
"manual approach to camera interpolation."
msgstr ""
"பல சந்தர்ப்பங்களில், ஒரு: குறிப்பு: `கேமரா 3 டி <class_camera3d>` மற்ற முனைகளைப் "
"போலவே தானியங்கி இடைக்கணிப்பைப் பயன்படுத்தலாம். இருப்பினும், சிறந்த முடிவுகளுக்கு, "
"குறிப்பாக குறைந்த இயற்பியல் டிக் விகிதங்களில், கேமரா இடைக்கணிப்புக்கு ஒரு கையேடு "
"அணுகுமுறையை எடுக்க பரிந்துரைக்கப்படுகிறது."

msgid ""
"This is because viewers are very sensitive to camera movement. For instance, "
"a Camera3D that realigns slightly every 1/10th of a second (at 10tps tick "
"rate) will often be noticeable. You can get a much smoother result by moving "
"the camera each frame in ``_process``, and following an interpolated target "
"manually."
msgstr ""
"ஏனென்றால் பார்வையாளர்கள் கேமரா இயக்கத்திற்கு மிகவும் உணர்திறன் கொண்டவர்கள். உதாரணமாக, ஒரு "
"வினாடியின் ஒவ்வொரு 1/10 (10TPS டிக் விகிதத்தில்) சற்று சற்று மறுவாழ்வு அளிக்கும் ஒரு "
"கேமரா 3 டி பெரும்பாலும் கவனிக்கத்தக்கதாக இருக்கும். ஒவ்வொரு சட்டகத்தையும் `` _ "
"செயல்முறை`` இல் நகர்த்துவதன் மூலமும், இடைக்கணிப்பு இலக்கை கைமுறையாகப் பின்பற்றுவதன் "
"மூலமும் நீங்கள் மிகவும் மென்மையான முடிவைப் பெறலாம்."

msgid "Manual camera interpolation"
msgstr "கையேடு கேமரா இடைக்கணிப்பு"

msgid "Ensure the camera is using global coordinate space"
msgstr "கேமரா உலகளாவிய ஒருங்கிணைப்பு இடத்தைப் பயன்படுத்துகிறது என்பதை உறுதிப்படுத்தவும்"

msgid ""
"The very first step when performing manual camera interpolation is to make "
"sure the Camera3D transform is specified in *global space* rather than "
"inheriting the transform of a moving parent. This is because feedback can "
"occur between the movement of a parent node of a Camera3D and the movement "
"of the camera Node itself, which can mess up the interpolation."
msgstr ""
"கையேடு கேமரா இடைக்கணிப்பை நிகழ்த்தும் முதல் படி, நகரும் பெற்றோரின் உருமாற்றத்தை "
"மரபுரிமையாகப் பெறுவதை விட கேமரா 3 டி உருமாற்றம் * உலகளாவிய இடத்தில் * "
"குறிப்பிடப்பட்டுள்ளதா என்பதை உறுதிப்படுத்துவதாகும். ஏனென்றால், கேமரா 3 டி இன் பெற்றோர் "
"முனையின் இயக்கத்திற்கும் கேமரா முனையின் இயக்கத்திற்கும் இடையில் பின்னூட்டம் ஏற்படக்கூடும், "
"இது இடைக்கணிப்பைக் குழப்பக்கூடும்."

msgid "There are two ways of doing this:"
msgstr "இதைச் செய்ய இரண்டு வழிகள் உள்ளன:"

msgid ""
"Move the Camera3D so it is independent on its own branch, rather than being "
"a child of a moving object."
msgstr ""
"கேமரா 3 டி ஐ நகர்த்தவும், எனவே நகரும் பொருளின் குழந்தையாக இருப்பதை விட, அதன் சொந்த "
"கிளையில் சுயாதீனமாக இருக்கும்."

msgid ""
"Call :ref:`Node3D.top_level<class_Node3D_property_top_level>` and set this "
"to ``true``, which will make the Camera ignore the transform of its parent."
msgstr ""
"அழைப்பு: குறிப்பு: `node3d.top_level <class_node3d_property_top_level>` இதை `` "
"உண்மை`` என அமைக்கவும், இது கேமரா அதன் பெற்றோரின் மாற்றத்தை புறக்கணிக்கும்."

msgid "Typical example"
msgstr "வழக்கமான எடுத்துக்காட்டு"

msgid ""
"A typical example of a custom approach is to use the ``look_at`` function in "
"the Camera3D every frame in ``_process()`` to look at a target node (such as "
"the player)."
msgstr ""
"தனிப்பயன் அணுகுமுறையின் ஒரு பொதுவான எடுத்துக்காட்டு, கேமரா 3 டி இல் `` லுக்_ஏடி`` "
"செயல்பாட்டைப் பயன்படுத்துவது `` _ நடைமுறையில் () `` இலக்கு முனையைப் பார்க்க (பிளேயர் "
"போன்றவை)."

msgid ""
"But there is a problem. If we use the traditional ``get_global_transform()`` "
"on a Camera3D \"target\" node, this transform will only focus the Camera3D "
"on the target *at the current physics tick*. This is *not* what we want, as "
"the camera will jump about on each physics tick as the target moves. Even "
"though the camera may be updated each frame, this does not help give smooth "
"motion if the *target* is only changing each physics tick."
msgstr ""
"ஆனால் ஒரு சிக்கல் உள்ளது. கேமரா 3 டி \"இலக்கு\" முனையில் பாரம்பரிய `` "
"get_global_transform () `` ஐப் பயன்படுத்தினால், இந்த மாற்றம் தற்போதைய இயற்பியல் டிக்கில் "
"*இலக்கு *கேமரா 3 டி ஐ மட்டுமே மையப்படுத்தும் *. இலக்கு நகரும் போது ஒவ்வொரு இயற்பியல் "
"டிக்கிலும் கேமரா குதிக்கும் என்பதால் இது நாம் விரும்புவது * அல்ல. ஒவ்வொரு சட்டகத்தையும் "
"கேமரா புதுப்பித்தாலும், * இலக்கு * ஒவ்வொரு இயற்பியல் டிக்கையும் மாற்றினால் இது மென்மையான "
"இயக்கத்தை அளிக்க உதவாது."

msgid "get_global_transform_interpolated()"
msgstr "get_global_transform_interpolated ()"

msgid ""
"What we really want to focus the camera on, is not the position of the "
"target on the physics tick, but the *interpolated* position, i.e. the "
"position at which the target will be rendered."
msgstr ""
"கேமராவில் நாம் உண்மையில் கவனம் செலுத்த விரும்புவது, இயற்பியல் டிக்கின் இலக்கின் நிலை அல்ல, "
"ஆனால் * இடைக்கணிப்பு * நிலை, அதாவது இலக்கு வழங்கப்படும் நிலை."

msgid ""
"We can do this using "
"the :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>` "
"function. This acts exactly like "
"getting :ref:`Node3D.global_transform<class_Node3D_property_global_transform>` "
"but it gives you the *interpolated* transform (during a ``_process()`` call)."
msgstr ""
"இதைப் பயன்படுத்தி இதைச் செய்யலாம்: ref: `node3d.get_global_transform_interpolated "
"<class_node3d_method_get_global_transform_interpolated>` செயல்பாடு. இது "
"சரியாகப் பெறுவது போலவே செயல்படுகிறது: குறிப்பு: `node3d.global_transform "
"<class_node3d_property_global_transform>` ஆனால் இது உங்களுக்கு * இடைக்கணிப்பு * "
"உருமாற்றத்தை வழங்குகிறது (`_ -process ()` `அழைப்பின் போது)."

msgid ""
"``get_global_transform_interpolated()`` should only be used once or twice "
"for special cases such as cameras. It should **not** be used all over the "
"place in your code (both for performance reasons, and to give correct "
"gameplay)."
msgstr ""
"`` get_global_transform_interpolated () `` கேமராக்கள் போன்ற சிறப்பு நிகழ்வுகளுக்கு "
"ஒன்று அல்லது இரண்டு முறை மட்டுமே பயன்படுத்தப்பட வேண்டும். இது உங்கள் குறியீட்டில் எல்லா "
"இடங்களிலும் பயன்படுத்தப்படக்கூடாது (செயல்திறன் காரணங்களுக்காகவும், சரியான விளையாட்டைக் "
"கொடுக்கவும்)."

msgid ""
"Aside from exceptions like the camera, in most cases, your game logic should "
"be in ``_physics_process()``. In game logic you should be calling "
"``get_global_transform()`` or ``get_transform()``, which will give the "
"current physics transform (in global or local space respectively), which is "
"usually what you will want for gameplay code."
msgstr ""
"கேமரா போன்ற விதிவிலக்குகளைத் தவிர, பெரும்பாலான சந்தர்ப்பங்களில், உங்கள் விளையாட்டு வழக்கு "
"`` _physics_process () `` இல் இருக்க வேண்டும். விளையாட்டு தர்க்கத்தில் நீங்கள் `` "
"get_global_transform () `` அல்லது `` get_transform () `` என்று அழைக்க வேண்டும், "
"இது தற்போதைய இயற்பியல் மாற்றத்தை (முறையே உலகளாவிய அல்லது உள்ளக இடத்தில்) வழங்கும், இது "
"பொதுவாக விளையாட்டு குறியீட்டிற்கு நீங்கள் விரும்புவது."

msgid "Example manual camera script"
msgstr "எடுத்துக்காட்டு கையேடு கேமரா ச்கிரிப்ட்"

msgid ""
"Here is an example of a simple fixed camera which follows an interpolated "
"target:"
msgstr "இடைக்கணிக்கப்பட்ட இலக்கைப் பின்பற்றும் எளிய நிலையான கேமராவின் எடுத்துக்காட்டு இங்கே:"

msgid "Mouse look"
msgstr "சுட்டி தோற்றம்"

msgid ""
"Mouse look is a very common way of controlling cameras. But there is a "
"problem. Unlike keyboard input which can be sampled periodically on the "
"physics tick, mouse move events can come in continuously. The camera will be "
"expected to react and follow these mouse movements on the next frame, rather "
"than waiting until the next physics tick."
msgstr ""
"மவுச் தோற்றம் கேமராக்களைக் கட்டுப்படுத்துவதற்கான பொதுவான வழியாகும். ஆனால் ஒரு சிக்கல் "
"உள்ளது. இயற்பியல் டிக்கில் அவ்வப்போது மாதிரியாக இருக்கக்கூடிய விசைப்பலகை உள்ளீட்டைப் "
"போலன்றி, சுட்டி நகரும் நிகழ்வுகள் தொடர்ந்து வரலாம். அடுத்த இயற்பியல் டிக் வரை "
"காத்திருப்பதை விட, கேமரா அடுத்த சட்டகத்தில் இந்த சுட்டி இயக்கங்களை எதிர்வினையாற்றும் "
"மற்றும் பின்பற்றும் என்று எதிர்பார்க்கப்படுகிறது."

msgid ""
"In this situation, it can be better to disable physics interpolation for the "
"camera node "
"(using :ref:`Node.physics_interpolation_mode<class_Node_property_physics_interpolation_mode>`) "
"and directly apply the mouse input to the camera rotation, rather than apply "
"it in ``_physics_process``."
msgstr ""
"இந்த சூழ்நிலையில், கேமரா முனைக்கான இயற்பியல் இடைக்கணிப்பை முடக்குவது நல்லது "
"(பயன்படுத்துகிறது: குறிப்பு: `node.physics_interpolation_mode "
"<class_node_property_physics_interpolation_mode>` `` _phoscics` `_phorsics`` "
"_phorsics` `_phorsics`` _phorsics ஆகியவற்றில் நேரடியாக சுட்டி உள்ளீட்டை நேரடியாகப் "
"பயன்படுத்துங்கள்."

msgid ""
"Sometimes, especially with cameras, you will want to use a combination of "
"interpolation and non-interpolation:"
msgstr ""
"சில நேரங்களில், குறிப்பாக கேமராக்களுடன், நீங்கள் இடைக்கணிப்பு மற்றும் இடைக்கணிப்பு அல்லாத "
"கலவையைப் பயன்படுத்த விரும்புவீர்கள்:"

msgid ""
"A first person camera may position the camera at a player location (perhaps "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`), "
"but control the Camera rotation from mouse look *without* interpolation."
msgstr ""
"முதல் நபர் கேமரா ஒரு பிளேயர் இருப்பிடத்தில் கேமராவை நிலைநிறுத்தலாம் (ஒருவேளை "
"பயன்படுத்தலாம்: `node3d.get_global_transform_interpolated "
"<class_node3d_method_get_global_transform_interpolated>`), ஆனால் சுட்டி "
"தோற்றத்திலிருந்து * இடைமுகம் இல்லாமல் கேமரா சுழற்சியைக் கட்டுப்படுத்தவும்."

msgid ""
"A third person camera may similarly determine the look at (target location) "
"of the camera "
"using :ref:`Node3D.get_global_transform_interpolated<class_Node3D_method_get_global_transform_interpolated>`, "
"but position the camera using mouse look *without* interpolation."
msgstr ""
"மூன்றாவது நபர் கேமரா இதேபோல் கேமராவின் (இலக்கு இருப்பிடம்) தோற்றத்தை தீர்மானிக்கலாம்: "
"ref: `node3d.get_global_transform_interpolated "
"<class_node3d_method_get_global_transform_interpolated>`, ஆனால் மவுச் தோற்றத்தைப் "
"பயன்படுத்தி * குறுக்கீடு இல்லாமல் கேமராவை நிலைநிறுத்துங்கள்."

msgid ""
"There are many permutations and variations of camera types, but it should be "
"clear that in many cases, disabling automatic physics interpolation and "
"handling this yourself can give a better result."
msgstr ""
"கேமரா வகைகளின் பல வரிசைமாற்றங்கள் மற்றும் மாறுபாடுகள் உள்ளன, ஆனால் பல சந்தர்ப்பங்களில், "
"தானியங்கி இயற்பியல் இடைக்கணிப்பை முடக்குவதும், இதைக் கையாள்வதும் ஒரு சிறந்த முடிவைக் "
"கொடுக்கும் என்பது தெளிவாக இருக்க வேண்டும்."

msgid "Disabling interpolation on other nodes"
msgstr "மற்ற முனைகளில் இடைக்கணிப்பை முடக்குதல்"

msgid ""
"Although cameras are the most common example, there are a number of cases "
"when you may wish other nodes to control their own interpolation, or be non-"
"interpolated. Consider for example, a player in a top view game whose "
"rotation is controlled by mouse look. Disabling physics rotation allows the "
"player rotation to match the mouse in real-time."
msgstr ""
"கேமராக்கள் மிகவும் பொதுவான எடுத்துக்காட்டு என்றாலும், பிற முனைகள் அவற்றின் சொந்த "
"இடைக்கணிப்பைக் கட்டுப்படுத்த வேண்டும், அல்லது இடைநிறுத்தப்படாதவை என்று நீங்கள் விரும்பும் பல "
"வழக்குகள் உள்ளன. எடுத்துக்காட்டாக, ஒரு சிறந்த பார்வை விளையாட்டில் ஒரு வீரர் அதன் சுழற்சி "
"சுட்டி தோற்றத்தால் கட்டுப்படுத்தப்படுகிறது. இயற்பியல் சுழற்சியை முடக்குவது பிளேயர் "
"சுழற்சியை சுட்டியுடன் நிகழ்நேரத்தில் பொருத்த அனுமதிக்கிறது."

msgid "MultiMeshes"
msgstr "மல்டிமேச்கள்"

msgid ""
"Although most visual Nodes follow the single Node single visual instance "
"paradigm, MultiMeshes can control several instances from the same Node. "
"Therefore, they have some extra functions for controlling interpolation "
"functionality on a *per-instance* basis. You should explore these functions "
"if you are using interpolated MultiMeshes."
msgstr ""
"பெரும்பாலான காட்சி முனைகள் ஒற்றை முனை ஒற்றை காட்சி நிகழ்வு முன்னுதாரணத்தைப் "
"பின்பற்றினாலும், மல்டிமேச்கள் ஒரே முனையிலிருந்து பல நிகழ்வுகளை கட்டுப்படுத்த முடியும். "
"ஆகையால், * பெர்-ஃபார்ச்டன்ச் * அடிப்படையில் இடைக்கணிப்பு செயல்பாட்டைக் கட்டுப்படுத்த சில "
"கூடுதல் செயல்பாடுகளை அவை கொண்டுள்ளன. நீங்கள் இடைக்கணிக்கப்பட்ட மல்டிமேச்களைப் "
"பயன்படுத்துகிறீர்கள் என்றால் இந்த செயல்பாடுகளை ஆராய வேண்டும்."

msgid ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"
msgstr ":ref:`MultiMesh.reset_instance_physics_interpolation<class_MultiMesh_method_reset_instance_physics_interpolation>`"

msgid ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"
msgstr ":ref:`MultiMesh.set_buffer_interpolated<class_MultiMesh_method_set_buffer_interpolated>`"

msgid ""
"Full details are in the :ref:`MultiMesh<class_MultiMesh>` documentation."
msgstr "முழு விவரங்கள்: ref: `மல்டிமேச் <class_multimesh>` ஆவணங்கள்."
