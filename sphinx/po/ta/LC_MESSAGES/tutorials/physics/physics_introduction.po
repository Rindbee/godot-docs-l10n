#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Physics introduction"
msgstr "இயற்பியல் அறிமுகம்"

msgid ""
"In game development, you often need to know when two objects in the game "
"intersect or come into contact. This is known as **collision detection**. "
"When a collision is detected, you typically want something to happen. This "
"is known as **collision response**."
msgstr ""
"விளையாட்டு வளர்ச்சியில், விளையாட்டில் இரண்டு பொருள்கள் வெட்டும்போது அல்லது தொடர்பு "
"கொள்ளும்போது நீங்கள் அடிக்கடி தெரிந்து கொள்ள வேண்டும். இது ** மோதல் கண்டறிதல் ** என "
"அழைக்கப்படுகிறது. மோதல் கண்டறியப்பட்டால், நீங்கள் பொதுவாக ஏதாவது நடக்க விரும்புகிறீர்கள். "
"இது ** மோதல் பதில் ** என்று அழைக்கப்படுகிறது."

msgid ""
"Godot offers a number of collision objects in 2D and 3D to provide both "
"collision detection and response. Trying to decide which one to use for your "
"project can be confusing. You can avoid problems and simplify development if "
"you understand how each works and what their pros and cons are."
msgstr ""
"மோதல் கண்டறிதல் மற்றும் பதில் இரண்டையும் வழங்க கோடோட் 2D மற்றும் 3D இல் பல மோதல் பொருள்களை "
"வழங்குகிறது. உங்கள் திட்டத்திற்கு எது பயன்படுத்த வேண்டும் என்பதை தீர்மானிக்க முயற்சிப்பது "
"குழப்பமானதாக இருக்கும். ஒவ்வொன்றும் எவ்வாறு செயல்படுகின்றன, அவற்றின் நன்மை தீமைகள் என்ன "
"என்பதை நீங்கள் புரிந்து கொண்டால் நீங்கள் சிக்கல்களைத் தவிர்க்கலாம் மற்றும் வளர்ச்சியை எளிதாக்கலாம்."

msgid "In this guide, you will learn:"
msgstr "இந்த வழிகாட்டியில், நீங்கள் கற்றுக்கொள்வீர்கள்:"

msgid "Godot's four collision object types"
msgstr "கோடோட்டின் நான்கு மோதல் பொருள் வகைகள்"

msgid "How each collision object works"
msgstr "ஒவ்வொரு மோதல் பொருளும் எவ்வாறு செயல்படுகின்றன"

msgid "When and why to choose one type over another"
msgstr "எப்போது, ஏன் ஒரு வகையை மற்றொரு வகையைத் தேர்வு செய்வது"

msgid ""
"This document's examples will use 2D objects. Every 2D physics object and "
"collision shape has a direct equivalent in 3D and in most cases they work in "
"much the same way."
msgstr ""
"இந்த ஆவணத்தின் எடுத்துக்காட்டுகள் 2 டி பொருள்களைப் பயன்படுத்தும். ஒவ்வொரு 2 டி இயற்பியல் "
"பொருள் மற்றும் மோதல் வடிவம் 3D இல் நேரடி சமமானதாகும், பெரும்பாலான சந்தர்ப்பங்களில் அவை "
"ஒரே மாதிரியாக செயல்படுகின்றன."

msgid "Collision objects"
msgstr "மோதல் பொருள்கள்"

msgid ""
"Godot offers four kinds of collision objects which all "
"extend :ref:`CollisionObject2D <class_CollisionObject2D>`. The last three "
"listed below are physics bodies and additionally extend :ref:`PhysicsBody2D "
"<class_PhysicsBody2D>`."
msgstr ""
"கோடோட் நான்கு வகையான மோதல் பொருள்களை வழங்குகிறது, இவை அனைத்தும் நீட்டிக்கப்படுகின்றன: "
"குறிப்பு: `collisionObject2d <class_collisionObject2d>`. கீழே பட்டியலிடப்பட்டுள்ள "
"கடைசி மூன்று இயற்பியல் உடல்கள் மற்றும் கூடுதலாக நீட்டிக்கப்படுகின்றன: குறிப்பு: `இயற்பியல் "
"பாடி 2 டி <class_physicsbody2d>`."

msgid ":ref:`Area2D <class_Area2D>`"
msgstr ":ref:`Area2D <class_Area2D>`"

msgid ""
"``Area2D`` nodes provide **detection** and **influence**. They can detect "
"when objects overlap and can emit signals when bodies enter or exit. An "
"``Area2D`` can also be used to override physics properties, such as gravity "
"or damping, in a defined area."
msgstr ""
"`` Area2d`` முனைகள் ** கண்டறிதல் ** மற்றும் ** செல்வாக்கு ** ஆகியவற்றை வழங்குகின்றன. "
"பொருள்கள் ஒன்றுடன் ஒன்று இருக்கும்போது அவை கண்டறியலாம் மற்றும் உடல்கள் நுழையும்போது அல்லது "
"வெளியேறும்போது சமிக்ஞைகளை வெளியிடலாம். வரையறுக்கப்பட்ட பகுதியில் ஈர்ப்பு அல்லது ஈரப்பதம் "
"போன்ற இயற்பியல் பண்புகளை மேலெழுத ஒரு `` ஏரியா 2 டி`` பயன்படுத்தப்படலாம்."

msgid ":ref:`StaticBody2D <class_StaticBody2D>`"
msgstr ": ref: `staticbody2d <class_staticbody2d>`"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. They are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"ஒரு நிலையான உடல் என்பது இயற்பியல் இயந்திரத்தால் நகர்த்தப்படாத ஒன்றாகும். இது மோதல் "
"கண்டறிதலில் பங்கேற்கிறது, ஆனால் மோதலுக்கு பதிலளிக்கும் வகையில் நகராது. அவை பெரும்பாலும் "
"சுற்றுச்சூழலின் ஒரு பகுதியாக இருக்கும் அல்லது எந்தவொரு மாறும் நடத்தை தேவையில்லை."

msgid ":ref:`RigidBody2D <class_RigidBody2D>`"
msgstr ": ref: `rigidbody2d <class_rigidbody2d>`"

msgid ""
"This is the node that implements simulated 2D physics. You do not control a "
"``RigidBody2D`` directly, but instead you apply forces to it (gravity, "
"impulses, etc.) and the physics engine calculates the resulting "
"movement. :ref:`Read more about using rigid bodies. <doc_rigid_body>`"
msgstr ""
"உருவகப்படுத்தப்பட்ட 2 டி இயற்பியலை செயல்படுத்தும் முனை இது. நீங்கள் ஒரு `` ரிகிட்போடி 2 "
"டி`` நேரடியாகக் கட்டுப்படுத்த மாட்டீர்கள், ஆனால் அதற்கு பதிலாக நீங்கள் அதற்கு சக்திகளைப் "
"பயன்படுத்துகிறீர்கள் (ஈர்ப்பு, தூண்டுதல்கள் போன்றவை) மற்றும் இயற்பியல் இயந்திரம் இதன் விளைவாக "
"ஏற்படும் இயக்கத்தை கணக்கிடுகிறது. : ref: `கடுமையான உடல்களைப் பயன்படுத்துவது பற்றி "
"மேலும் படிக்கவும். <doc_rigid_body> `"

msgid ":ref:`CharacterBody2D <class_CharacterBody2D>`"
msgstr ":ref:`CharacterBody2D <class CharacterBody2D>`"

msgid ""
"A body that provides collision detection, but no physics. All movement and "
"collision response must be implemented in code."
msgstr ""
"மோதல் கண்டறிதலை வழங்கும் உடல், ஆனால் இயற்பியல் இல்லை. அனைத்து இயக்கம் மற்றும் மோதல் பதில் "
"குறியீட்டில் செயல்படுத்தப்பட வேண்டும்."

msgid "Physics material"
msgstr "இயற்பியல் பொருள்"

msgid ""
"Static bodies and rigid bodies can be configured to use "
"a :ref:`PhysicsMaterial <class_PhysicsMaterial>`. This allows adjusting the "
"friction and bounce of an object, and set if it's absorbent and/or rough."
msgstr ""
"நிலையான உடல்கள் மற்றும் கடினமான உடல்களை ஒரு பயன்படுத்த கட்டமைக்கலாம்: குறிப்பு: "
"`இயற்பியல் ஆற்றல் <class_physicsmaterial>`. இது ஒரு பொருளின் உராய்வு மற்றும் துள்ளலை "
"சரிசெய்ய அனுமதிக்கிறது, மேலும் அது உறிஞ்சக்கூடிய மற்றும்/அல்லது கடினமானதாக இருந்தால் "
"அமைக்கவும்."

msgid "Collision shapes"
msgstr "மோதல் வடிவங்கள்"

msgid ""
"A physics body can hold any number of :ref:`Shape2D <class_Shape2D>` objects "
"as children. These shapes are used to define the object's collision bounds "
"and to detect contact with other objects."
msgstr ""
"ஒரு இயற்பியல் உடல் எந்தவொரு எண்ணிக்கையையும் வைத்திருக்க முடியும்: குறிப்பு: `shate2d "
"<class_shape2d>` குழந்தைகளாக பொருள்கள். இந்த வடிவங்கள் பொருளின் மோதல் எல்லைகளை "
"வரையறுக்கவும், பிற பொருள்களுடனான தொடர்பைக் கண்டறியவும் பயன்படுத்தப்படுகின்றன."

msgid ""
"In order to detect collisions, at least one ``Shape2D`` must be assigned to "
"the object."
msgstr "மோதல்களைக் கண்டறிய, குறைந்தது ஒரு `` shate2d`` பொருளுக்கு ஒதுக்கப்பட வேண்டும்."

msgid ""
"The most common way to assign a shape is by adding a :ref:`CollisionShape2D "
"<class_CollisionShape2D>` or :ref:`CollisionPolygon2D "
"<class_CollisionPolygon2D>` as a child of the object. These nodes allow you "
"to draw the shape directly in the editor workspace."
msgstr ""
"ஒரு வடிவத்தை ஒதுக்க மிகவும் பொதுவான வழி ஒரு: ref: `collisionshape2d "
"<class_collesshape2d>` அல்லது: ref: `collisionPolygon2d "
"<class_collisionPolygon2d>` பொருளின் குழந்தையாக. இந்த முனைகள் எடிட்டர் பணியிடத்தில் "
"நேரடியாக வடிவத்தை வரைய அனுமதிக்கின்றன."

msgid ""
"Be careful to never scale your collision shapes in the editor. The \"Scale\" "
"property in the Inspector should remain ``(1, 1)``. When changing the size "
"of the collision shape, you should always use the size handles, **not** the "
"``Node2D`` scale handles. Scaling a shape can result in unexpected collision "
"behavior."
msgstr ""
"எடிட்டரில் உங்கள் மோதல் வடிவங்களை ஒருபோதும் அளவிட கவனமாக இருங்கள். இன்ச்பெக்டரில் உள்ள "
"\"அளவுகோல்\" சொத்து `` (1, 1) `` இருக்க வேண்டும். மோதல் வடிவத்தின் அளவை மாற்றும்போது, "
"நீங்கள் எப்போதும் அளவு கைப்பிடிகளைப் பயன்படுத்த வேண்டும், ** அல்ல ** `` node2d`` அளவிலான "
"கையாளுதல்கள். ஒரு வடிவத்தை அளவிடுவது எதிர்பாராத மோதல் நடத்தைக்கு வழிவகுக்கும்."

msgid "Physics process callback"
msgstr "இயற்பியல் செயல்முறை கால்பேக்"

msgid ""
"The physics engine runs at a fixed rate (a default of 60 iterations per "
"second). This rate is typically different from the frame rate which "
"fluctuates based on what is rendered and available resources."
msgstr ""
"இயற்பியல் இயந்திரம் ஒரு நிலையான விகிதத்தில் இயங்குகிறது (வினாடிக்கு 60 மறு செய்கைகளின் "
"இயல்புநிலை). இந்த விகிதம் பொதுவாக பிரேம் வீதத்திலிருந்து வேறுபட்டது, இது வழங்கப்பட்ட "
"மற்றும் கிடைக்கக்கூடிய வளங்களின் அடிப்படையில் மாறுபடும்."

msgid ""
"It is important that all physics related code runs at this fixed rate. "
"Therefore Godot differentiates :ref:`between physics and idle processing "
"<doc_idle_and_physics_processing>`. Code that runs each frame is called idle "
"processing and code that runs on each physics tick is called physics "
"processing. Godot provides two different callbacks, one for each of those "
"processing rates."
msgstr ""
"இயற்பியல் தொடர்பான அனைத்து குறியீடுகளும் இந்த நிலையான விகிதத்தில் இயங்குவது முதன்மை. "
"எனவே கோடோட் வேறுபடுகிறது: ref: `இயற்பியல் மற்றும் செயலற்ற செயலாக்கத்திற்கு இடையில் "
"<doc_idle_and_physics_processing>`. ஒவ்வொரு சட்டகத்தையும் இயங்கும் குறியீடு செயலற்ற "
"செயலாக்கம் மற்றும் ஒவ்வொரு இயற்பியல் டிக்கிலும் இயங்கும் குறியீடு இயற்பியல் செயலாக்கம் என்று "
"அழைக்கப்படுகிறது. கோடோட் இரண்டு வெவ்வேறு கால்பேக்குகளை வழங்குகிறது, அந்த செயலாக்க "
"விகிதங்களில் ஒவ்வொன்றிற்கும் ஒன்று."

msgid ""
"The physics callback, :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>`, is called before each physics "
"step. Any code that needs to access a body's properties should be run in "
"here. This method will be passed a ``delta`` parameter, which is a floating-"
"point number equal to the time passed in *seconds* since the last step. When "
"using the default 60 Hz physics update rate, it will typically be equal to "
"``0.01666...`` (but not always, see below)."
msgstr ""
"இயற்பியல் கால்பேக்,: ref: `node._physics_process () "
"<class_node_private_method__physics_process>`, ஒவ்வொரு இயற்பியல் படிநிலைக்கும் "
"முன் அழைக்கப்படுகிறது. உடலின் பண்புகளை அணுக வேண்டிய எந்த குறியீடும் இங்கே இயக்கப்பட "
"வேண்டும். இந்த முறை ஒரு `` டெல்டா`` அளவுருவை நிறைவேற்றும், இது கடைசி கட்டத்திலிருந்து "
"* வினாடிகளில் * கடந்து சென்ற நேரத்திற்கு சமமான மிதக்கும்-புள்ளி எண். இயல்புநிலை 60 "
"எர்ட்ச் இயற்பியல் புதுப்பிப்பு வீதத்தைப் பயன்படுத்தும் போது, இது பொதுவாக `` 0.01666 ... "
"`` (ஆனால் எப்போதும் இல்லை, கீழே காண்க) க்கு சமமாக இருக்கும்."

msgid ""
"It's recommended to always use the ``delta`` parameter when relevant in your "
"physics calculations, so that the game behaves correctly if you change the "
"physics update rate or if the player's device can't keep up."
msgstr ""
"உங்கள் இயற்பியல் கணக்கீடுகளில் பொருத்தமாக இருக்கும்போது `` டெல்டா`` அளவுருவைப் பயன்படுத்த "
"பரிந்துரைக்கப்படுகிறது, இதனால் நீங்கள் இயற்பியல் புதுப்பிப்பு வீதத்தை மாற்றினால் அல்லது "
"பிளேயரின் சாதனத்தைத் தொடர முடியாவிட்டால் விளையாட்டு சரியாக செயல்படுகிறது."

msgid "Collision layers and masks"
msgstr "மோதல் அடுக்குகள் மற்றும் முகமூடிகள்"

msgid ""
"One of the most powerful, but frequently misunderstood, collision features "
"is the collision layer system. This system allows you to build up complex "
"interactions between a variety of objects. The key concepts are **layers** "
"and **masks**. Each ``CollisionObject2D`` has 32 different physics layers it "
"can interact with."
msgstr ""
"மிகவும் சக்திவாய்ந்த, ஆனால் அடிக்கடி தவறாகப் புரிந்து கொள்ளப்பட்ட, மோதல் அம்சங்களில் ஒன்று "
"மோதல் அடுக்கு அமைப்பு. பல்வேறு பொருள்களுக்கு இடையில் சிக்கலான தொடர்புகளை உருவாக்க இந்த "
"அமைப்பு உங்களை அனுமதிக்கிறது. முக்கிய கருத்துக்கள் ** அடுக்குகள் ** மற்றும் ** "
"முகமூடிகள் **. ஒவ்வொரு `` collisionObject2d`` மற்றும் 32 வெவ்வேறு இயற்பியல் "
"அடுக்குகளுடன் அது தொடர்பு கொள்ள முடியும்."

msgid "Let's look at each of the properties in turn:"
msgstr "ஒவ்வொரு பண்புகளையும் பார்ப்போம்:"

msgid "collision_layer"
msgstr "மோதல்_லேயர்"

msgid ""
"This describes the layers that the object appears **in**. By default, all "
"bodies are on layer ``1``."
msgstr ""
"** இல் பொருள் தோன்றும் அடுக்குகளை இது விவரிக்கிறது **. இயல்பாக, எல்லா உடல்களும் அடுக்கு "
"`` 1`` இல் உள்ளன."

msgid "collision_mask"
msgstr "மோதல்_மாச்க்"

msgid ""
"This describes what layers the body will **scan** for collisions. If an "
"object isn't in one of the mask layers, the body will ignore it. By default, "
"all bodies scan layer ``1``."
msgstr ""
"மோதல்களுக்கு உடல் ** ச்கேன் ** எந்த அடுக்குகளை வழங்கும் என்பதை இது விவரிக்கிறது. ஒரு "
"பொருள் முகமூடி அடுக்குகளில் ஒன்றில் இல்லை என்றால், உடல் அதை புறக்கணிக்கும். இயல்பாக, எல்லா "
"உடல்களும் அடுக்கு `` 1`` ஐ ச்கேன் செய்கின்றன."

msgid ""
"These properties can be configured via code, or by editing them in the "
"Inspector."
msgstr ""
"இந்த பண்புகளை குறியீடு வழியாக அல்லது அவற்றை இன்ச்பெக்டரில் திருத்துவதன் மூலம் கட்டமைக்க "
"முடியும்."

msgid ""
"Keeping track of what you're using each layer for can be difficult, so you "
"may find it useful to assign names to the layers you're using. Names can be "
"assigned in **Project Settings > Layer Names > 2D Physics**."
msgstr ""
"நீங்கள் ஒவ்வொரு அடுக்கையும் பயன்படுத்துவதைக் கண்காணிப்பது கடினம், எனவே நீங்கள் பயன்படுத்தும் "
"அடுக்குகளுக்கு பெயர்களை ஒதுக்குவது பயனுள்ளதாக இருக்கும். பெயர்களை ** திட்ட அமைப்புகள்> "
"அடுக்கு பெயர்கள்> 2 டி இயற்பியல் ** இல் ஒதுக்கலாம்."

msgid "GUI example"
msgstr "GUI எடுத்துக்காட்டு"

msgid ""
"You have four node types in your game: Walls, Player, Enemy, and Coin. Both "
"Player and Enemy should collide with Walls. The Player node should detect "
"collisions with both Enemy and Coin, but Enemy and Coin should ignore each "
"other."
msgstr ""
"உங்கள் விளையாட்டில் நான்கு முனை வகைகள் உள்ளன: சுவர்கள், வீரர், எதிரி மற்றும் நாணயம். வீரர் "
"மற்றும் எதிரி இருவரும் சுவர்களுடன் மோத வேண்டும். பிளேயர் முனை எதிரி மற்றும் நாணயம் "
"ஆகியோருடன் மோதல்களைக் கண்டறிய வேண்டும், ஆனால் எதிரி மற்றும் நாணயம் ஒருவருக்கொருவர் "
"புறக்கணிக்க வேண்டும்."

msgid ""
"Start by naming layers 1-4 \"walls\", \"player\", \"enemies\", and \"coins\" "
"and place each node type in its respective layer using the \"Layer\" "
"property. Then set each node's \"Mask\" property by selecting the layers it "
"should interact with. For example, the Player's settings would look like "
"this:"
msgstr ""
"1-4 \"சுவர்கள்\", \"பிளேயர்\", \"எதிரிகள்\" மற்றும் \"நாணயங்கள்\" என்று பெயரிடுவதன் "
"மூலம் தொடங்கி, ஒவ்வொரு முனை வகையையும் \"அடுக்கு\" சொத்தைப் பயன்படுத்தி அந்தந்த அடுக்கில் "
"வைக்கவும். ஒவ்வொரு முனையின் \"முகமூடி\" சொத்தையும் தொடர்பு கொள்ள வேண்டிய அடுக்குகளைத் "
"தேர்ந்தெடுப்பதன் மூலம் அமைக்கவும். எடுத்துக்காட்டாக, வீரரின் அமைப்புகள் இப்படி இருக்கும்:"

msgid "Code example"
msgstr "குறியீடு எடுத்துக்காட்டு"

msgid ""
"In function calls, layers are specified as a bitmask. Where a function "
"enables all layers by default, the layer mask will be given as "
"``0xffffffff``. Your code can use binary, hexadecimal, or decimal notation "
"for layer masks, depending on your preference."
msgstr ""
"செயல்பாட்டு அழைப்புகளில், அடுக்குகள் பிட்மாச்க் என குறிப்பிடப்படுகின்றன. ஒரு செயல்பாடு "
"எல்லா அடுக்குகளையும் இயல்பாக செயல்படுத்தும் இடத்தில், அடுக்கு முகமூடி `` 0xffffffff`` "
"ஆக வழங்கப்படும். உங்கள் குறியீடு உங்கள் விருப்பத்தைப் பொறுத்து, அடுக்கு முகமூடிகளுக்கு "
"பைனரி, எக்சாடெசிமல் அல்லது தசம குறியீட்டைப் பயன்படுத்தலாம்."

msgid ""
"The code equivalent of the above example where layers 1, 3 and 4 were "
"enabled would be as follows:"
msgstr ""
"1, 3 மற்றும் 4 அடுக்குகள் இயக்கப்பட்ட மேலே உள்ள எடுத்துக்காட்டுக்கு சமமான குறியீடு "
"பின்வருமாறு இருக்கும்:"

msgid ""
"You can also set bits independently by calling "
"``set_collision_layer_value(layer_number, value)`` or "
"``set_collision_mask_value(layer_number, value)`` on any "
"given :ref:`CollisionObject2D <class_CollisionObject2D>` as follows:"
msgstr ""
"`` Set_collision_layer_value (அடுக்கு_நம்பர், மதிப்பு) `` அல்லது `` "
"set_collision_mask_value (அடுக்கு_நம்பர், மதிப்பு) `` ஏதேனும் கொடுக்கப்பட்டவை: resp: "
"`clivitionObject2d <class_collision2dd>` `closionObject2d>`"

msgid ""
"Export annotations can be used to export bitmasks in the editor with a user-"
"friendly GUI:"
msgstr ""
"பயனர் நட்பு GUI உடன் எடிட்டரில் பிட்மாச்க்குகளை ஏற்றுமதி செய்ய ஏற்றுமதி சிறுகுறிப்புகள் "
"பயன்படுத்தப்படலாம்:"

msgid ""
"Additional export annotations are available for render and navigation "
"layers, in both 2D and 3D. "
"See :ref:`doc_gdscript_exports_exporting_bit_flags`."
msgstr ""
"2 டி மற்றும் 3 டி இரண்டிலும் வழங்குதல் மற்றும் வழிசெலுத்தல் அடுக்குகளுக்கு கூடுதல் "
"ஏற்றுமதி சிறுகுறிப்புகள் கிடைக்கின்றன. காண்க: குறிப்பு: "
"`doc_gdscript_exports_exporting_bit_flags`."

msgid "Area2D"
msgstr "AREA2D"

msgid ""
"Area nodes provide **detection** and **influence**. They can detect when "
"objects overlap and emit signals when bodies enter or exit. Areas can also "
"be used to override physics properties, such as gravity or damping, in a "
"defined area."
msgstr ""
"பகுதி முனைகள் ** கண்டறிதல் ** மற்றும் ** செல்வாக்கு ** வழங்குகின்றன. உடல்கள் நுழையும் "
"போது அல்லது வெளியேறும்போது பொருள்கள் ஒன்றுடன் ஒன்று இருக்கும்போது அவை கண்டறியலாம். "
"வரையறுக்கப்பட்ட பகுதியில் ஈர்ப்பு அல்லது ஈரப்பதம் போன்ற இயற்பியல் பண்புகளை மேலெழுதவும் "
"பகுதிகள் பயன்படுத்தப்படலாம்."

msgid "There are three main uses for :ref:`Area2D <class_Area2D>`:"
msgstr "இதற்காக மூன்று முக்கிய பயன்பாடுகள் உள்ளன: ref: `area2d <class_area2d>`:"

msgid "Overriding physics parameters (such as gravity) in a given region."
msgstr "கொடுக்கப்பட்ட பிராந்தியத்தில் இயற்பியல் அளவுருக்களை (ஈர்ப்பு போன்றவை) மேலெழுதும்."

msgid ""
"Detecting when other bodies enter or exit a region or what bodies are "
"currently in a region."
msgstr ""
"மற்ற உடல்கள் ஒரு பிராந்தியத்தில் நுழையும்போது அல்லது வெளியேறும்போது அல்லது தற்போது ஒரு "
"பிராந்தியத்தில் என்ன உடல்கள் உள்ளன என்பதைக் கண்டறிதல்."

msgid "Checking other areas for overlap."
msgstr "ஒன்றுடன் ஒன்று மற்ற பகுதிகளை சரிபார்க்கிறது."

msgid "By default, areas also receive mouse and touchscreen input."
msgstr "இயல்பாக, பகுதிகள் சுட்டி மற்றும் தொடுதிரை உள்ளீட்டையும் பெறுகின்றன."

msgid "StaticBody2D"
msgstr "Staticbody2d"

msgid ""
"A static body is one that is not moved by the physics engine. It "
"participates in collision detection, but does not move in response to the "
"collision. However, it can impart motion or rotation to a colliding body "
"**as if** it were moving, using its ``constant_linear_velocity`` and "
"``constant_angular_velocity`` properties."
msgstr ""
"ஒரு நிலையான உடல் என்பது இயற்பியல் இயந்திரத்தால் நகர்த்தப்படாத ஒன்றாகும். இது மோதல் "
"கண்டறிதலில் பங்கேற்கிறது, ஆனால் மோதலுக்கு பதிலளிக்கும் வகையில் நகராது. இருப்பினும், இது "
"ஒரு மோதல் உடலுக்கு இயக்கம் அல்லது சுழற்சியை வழங்க முடியும் ** அதன் `` `` `` `` `` "
"`contrant_linear_velocity`` மற்றும்` `` constant_angular_velocity`` பண்புகளைப் "
"பயன்படுத்துகிறது."

msgid ""
"``StaticBody2D`` nodes are most often used for objects that are part of the "
"environment or that do not need to have any dynamic behavior."
msgstr ""
"`` Staticbody2d`` முனைகள் பெரும்பாலும் சுற்றுச்சூழலின் ஒரு பகுதியாக இருக்கும் அல்லது "
"எந்தவொரு மாறும் நடத்தை தேவையில்லை."

msgid "Example uses for ``StaticBody2D``:"
msgstr "எடுத்துக்காட்டு `` staticbody2d`` க்கு பயன்படுத்துகிறது:"

msgid "Platforms (including moving platforms)"
msgstr "தளங்கள் (நகரும் தளங்கள் உட்பட)"

msgid "Conveyor belts"
msgstr "கன்வேயர் பெல்ட்கள்"

msgid "Walls and other obstacles"
msgstr "சுவர்கள் மற்றும் பிற தடைகள்"

msgid "RigidBody2D"
msgstr "Rigidbody2d"

msgid ""
"This is the node that implements simulated 2D physics. You do not control "
"a :ref:`RigidBody2D <class_RigidBody2D>` directly. Instead, you apply forces "
"to it and the physics engine calculates the resulting movement, including "
"collisions with other bodies, and collision responses, such as bouncing, "
"rotating, etc."
msgstr ""
"உருவகப்படுத்தப்பட்ட 2 டி இயற்பியலை செயல்படுத்தும் முனை இது. நீங்கள் கட்டுப்படுத்த வேண்டாம் "
"a: ref: `rigidbody2d <class_rigidbody2d>` நேரடியாக. அதற்கு பதிலாக, நீங்கள் அதற்கு "
"சக்திகளைப் பயன்படுத்துகிறீர்கள் மற்றும் இயற்பியல் இயந்திரம் மற்ற உடல்களுடன் மோதல்கள் மற்றும் "
"துள்ளல், சுழற்றுதல் போன்ற மோதல் பதில்கள் உள்ளிட்ட இதன் விளைவாக இயக்கத்தை கணக்கிடுகிறது."

msgid ""
"You can modify a rigid body's behavior via properties such as \"Mass\", "
"\"Friction\", or \"Bounce\", which can be set in the Inspector."
msgstr ""
"இன்ச்பெக்டரில் அமைக்கக்கூடிய \"மாச்\", \"உராய்வு\" அல்லது \"பவுன்ச்\" போன்ற பண்புகள் "
"வழியாக நீங்கள் ஒரு கடினமான உடலின் நடத்தையை மாற்றலாம்."

msgid ""
"The body's behavior is also affected by the world's properties, as set in "
"**Project Settings > Physics**, or by entering an :ref:`Area2D "
"<class_Area2D>` that is overriding the global physics properties."
msgstr ""
"** திட்ட அமைப்புகள்> இயற்பியல் ** இல் குறிப்பிடப்பட்டுள்ளபடி, அல்லது உலகளாவிய இயற்பியல் "
"பண்புகளை மீறும் `AREA:` Area: `area:` area: `area:` area: `arigh2d "
"<class_area2d>` ஆகியவற்றில் உள்ளிடுவதன் மூலம் உடலின் நடத்தை உலகின் பண்புகளால் "
"பாதிக்கப்படுகிறது."

msgid ""
"When a rigid body is at rest and hasn't moved for a while, it goes to sleep. "
"A sleeping body acts like a static body, and its forces are not calculated "
"by the physics engine. The body will wake up when forces are applied, either "
"by a collision or via code."
msgstr ""
"ஒரு கடினமான உடல் ஓய்வில் இருக்கும்போது, சிறிது நேரம் நகராதபோது, அது தூங்கச் செல்லும். "
"ஒரு தூக்க உடல் ஒரு நிலையான உடலைப் போல செயல்படுகிறது, மேலும் அதன் படைகள் இயற்பியல் "
"இயந்திரத்தால் கணக்கிடப்படவில்லை. மோதல் மூலமாகவோ அல்லது குறியீடு வழியாகவோ சக்திகள் "
"பயன்படுத்தப்படும்போது உடல் எழுந்திருக்கும்."

msgid "Using RigidBody2D"
msgstr "RigidBody2D ஐப் பயன்படுத்துதல்"

msgid ""
"One of the benefits of using a rigid body is that a lot of behavior can be "
"had \"for free\" without writing any code. For example, if you were making "
"an \"Angry Birds\"-style game with falling blocks, you would only need to "
"create RigidBody2Ds and adjust their properties. Stacking, falling, and "
"bouncing would automatically be calculated by the physics engine."
msgstr ""
"ஒரு கடினமான உடலைப் பயன்படுத்துவதன் நன்மைகளில் ஒன்று, எந்தவொரு குறியீட்டை எழுதாமல் நிறைய "
"நடத்தை \"இலவசமாக\" இருக்க முடியும். எடுத்துக்காட்டாக, நீங்கள் ஒரு \"கோபமான பறவைகள்\"-"
"பாணி விளையாட்டை வீழ்த்தும் தொகுதிகள் தயாரித்திருந்தால், நீங்கள் ரிகிட் பாடி 2DS ஐ "
"உருவாக்கி அவற்றின் பண்புகளை சரிசெய்ய வேண்டும். அடுக்கி வைப்பது, விழுதல் மற்றும் துள்ளல் "
"ஆகியவை தானாகவே இயற்பியல் இயந்திரத்தால் கணக்கிடப்படும்."

msgid ""
"However, if you do wish to have some control over the body, you should take "
"care - altering the ``position``, ``linear_velocity``, or other physics "
"properties of a rigid body can result in unexpected behavior. If you need to "
"alter any of the physics-related properties, you should use "
"the :ref:`_integrate_forces() "
"<class_RigidBody2D_private_method__integrate_forces>` callback instead of "
"``_physics_process()``. In this callback, you have access to the "
"body's :ref:`PhysicsDirectBodyState2D <class_PhysicsDirectBodyState2D>`, "
"which allows for safely changing properties and synchronizing them with the "
"physics engine."
msgstr ""
"இருப்பினும், நீங்கள் உடலின் மீது கொஞ்சம் கட்டுப்பாட்டைக் கொண்டிருக்க விரும்பினால், நீங்கள் "
"கவனித்துக் கொள்ள வேண்டும் - `` நிலை``, `` லீனியர்_வெலோசிட்டி`` அல்லது ஒரு கடினமான "
"உடலின் பிற இயற்பியல் பண்புகள் எதிர்பாராத நடத்தைக்கு வழிவகுக்கும். இயற்பியல் தொடர்பான "
"எந்தவொரு பண்புகளையும் நீங்கள் மாற்ற வேண்டியிருந்தால், நீங்கள்: ref: `_integrate_forces () "
"<class_rigidbody2d_private_methodegrate_forces>` `_Physics_Process ()` `` "
"`என்பதற்கு பதிலாக கால்பேக் பயன்படுத்த வேண்டும். இந்த அழைப்பில், நீங்கள் உடலுக்கு அணுகல் "
"உள்ளது: ref: `இயற்பியல் டைரக்ட் போடிச்டேட் 2 டி <class_physicsDirectBodystate2d>`, "
"இது பண்புகளை பாதுகாப்பாக மாற்றவும் அவற்றை இயற்பியல் இயந்திரத்துடன் ஒத்திசைக்கவும் "
"அனுமதிக்கிறது."

msgid "For example, here is the code for an \"Asteroids\" style spaceship:"
msgstr "எடுத்துக்காட்டாக, ஒரு \"சிறுகோள்கள்\" பாணி விண்கலத்திற்கான குறியீடு இங்கே:"

msgid ""
"Note that we are not setting the ``linear_velocity`` or ``angular_velocity`` "
"properties directly, but rather applying forces (``thrust`` and ``torque``) "
"to the body and letting the physics engine calculate the resulting movement."
msgstr ""
"நாங்கள் `` லீனியர்_வெலோசிட்டி`` அல்லது `` கோண_வெலோசிட்டி`` பண்புகளை நேரடியாக "
"அமைக்கவில்லை என்பதை நினைவில் கொள்க, மாறாக உடலுக்கு (`` உந்துதல்`` மற்றும் `` டார்கே``) "
"சக்திகளைப் பயன்படுத்துகிறது மற்றும் இயற்பியல் என்சின் அதன் விளைவாக இயக்கத்தை கணக்கிட "
"அனுமதிக்கிறது ."

msgid ""
"When a rigid body goes to sleep, the ``_integrate_forces()`` function will "
"not be called. To override this behavior, you will need to keep the body "
"awake by creating a collision, applying a force to it, or by disabling "
"the :ref:`can_sleep <class_RigidBody2D_property_can_sleep>` property. Be "
"aware that this can have a negative effect on performance."
msgstr ""
"ஒரு கடினமான உடல் தூங்கச் செல்லும்போது, `` _INTEGRATE_FORCES () `` செயல்பாடு "
"அழைக்கப்படாது. இந்த நடத்தையை மீறுவதற்கு, நீங்கள் மோதலை உருவாக்குவதன் மூலமும், அதற்கு ஒரு "
"சக்தியைப் பயன்படுத்துவதன் மூலமோ அல்லது முடக்குவதன் மூலமோ உடலை விழித்திருக்க வேண்டும்: "
"ref: `can_sleep <class_rigidbody2d_property_can_sleep>` சொத்து. இது "
"செயல்திறனில் எதிர்மறையான விளைவை ஏற்படுத்தும் என்பதை அறிந்து கொள்ளுங்கள்."

msgid "Contact reporting"
msgstr "தொடர்பு அறிக்கை"

msgid ""
"By default, rigid bodies do not keep track of contacts, because this can "
"require a huge amount of memory if many bodies are in the scene. To enable "
"contact reporting, set the :ref:`max_contacts_reported "
"<class_RigidBody2D_property_max_contacts_reported>` property to a non-zero "
"value. The contacts can then be obtained "
"via :ref:`PhysicsDirectBodyState2D.get_contact_count() "
"<class_PhysicsDirectBodyState2D_method_get_contact_count>` and related "
"functions."
msgstr ""
"இயல்பாக, கடுமையான உடல்கள் தொடர்புகளைக் கண்காணிக்காது, ஏனென்றால் பல உடல்கள் காட்சியில் "
"இருந்தால் இதற்கு ஒரு பெரிய அளவு நினைவகம் தேவைப்படலாம். தொடர்பு அறிக்கையிடலை இயக்க,: "
"ref: `max_contacts_reported "
"<class_rigidbody2d_property_max_contacts_reported>` பூச்சியமற்ற மதிப்புக்கு "
"சொத்து. தொடர்புகளை பின்னர் பெறலாம்: ref: `இயற்பியல் டிஐடிக்டிரிக்போடிச்டேட் 2 டி."

msgid ""
"Contact monitoring via signals can be enabled via the :ref:`contact_monitor "
"<class_RigidBody2D_property_contact_monitor>` property. "
"See :ref:`RigidBody2D <class_RigidBody2D>` for the list of available signals."
msgstr ""
"சமிக்ஞைகள் வழியாக கண்காணிப்பை தொடர்பு கொள்ளலாம்: ref: `contact_monitor "
"<class_rigidbody2d_property_contact_monitor>` சொத்து. காண்க: ref: `rigidbody2d "
"<class_rigidbody2d>` கிடைக்கக்கூடிய சமிக்ஞைகளின் பட்டியலுக்கு."

msgid "CharacterBody2D"
msgstr "Reatolbody2d"

msgid ""
":ref:`CharacterBody2D <class_CharacterBody2D>` bodies detect collisions with "
"other bodies, but are not affected by physics properties like gravity or "
"friction. Instead, they must be controlled by the user via code. The physics "
"engine will not move a character body."
msgstr ""
". அதற்கு பதிலாக, அவை பயனரால் குறியீடு வழியாக கட்டுப்படுத்தப்பட வேண்டும். இயற்பியல் "
"இயந்திரம் ஒரு எழுத்து உடலை நகர்த்தாது."

msgid ""
"When moving a character body, you should not set its ``position`` directly. "
"Instead, you use the ``move_and_collide()`` or ``move_and_slide()`` methods. "
"These methods move the body along a given vector, and it will instantly stop "
"if a collision is detected with another body. After the body has collided, "
"any collision response must be coded manually."
msgstr ""
"ஒரு எழுத்து உடலை நகர்த்தும்போது, அதன் `` நிலை`` ஐ நேரடியாக அமைக்கக்கூடாது. அதற்கு "
"பதிலாக, நீங்கள் `` move_and_collide () `` அல்லது `` move_and_slide () `` "
"முறைகளைப் பயன்படுத்துகிறீர்கள். இந்த முறைகள் ஒரு குறிப்பிட்ட திசையனுடன் உடலை "
"நகர்த்துகின்றன, மேலும் மற்றொரு உடலுடன் மோதல் கண்டறியப்பட்டால் அது உடனடியாக நிறுத்தப்படும். "
"உடல் மோதிய பிறகு, எந்தவொரு மோதல் பதிலும் கைமுறையாக குறியிடப்பட வேண்டும்."

msgid "Character collision response"
msgstr "எழுத்து மோதல் பதில்"

msgid ""
"After a collision, you may want the body to bounce, to slide along a wall, "
"or to alter the properties of the object it hit. The way you handle "
"collision response depends on which method you used to move the "
"CharacterBody2D."
msgstr ""
"ஒரு மோதலுக்குப் பிறகு, உடல் துள்ள வேண்டும், ஒரு சுவருடன் சறுக்க வேண்டும் அல்லது அது "
"தாக்கும் பொருளின் பண்புகளை மாற்ற வேண்டும் என்று நீங்கள் விரும்பலாம். மோதல் பதிலை நீங்கள் "
"கையாளும் விதம், நீங்கள் எந்த முறையைப் பயன்படுத்தினீர்கள் என்பதைப் பொறுத்தது."

msgid ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"
msgstr ":ref:`move_and_collide <class_PhysicsBody2D_method_move_and_collide>`"

msgid ""
"When using ``move_and_collide()``, the function returns "
"a :ref:`KinematicCollision2D <class_KinematicCollision2D>` object, which "
"contains information about the collision and the colliding body. You can use "
"this information to determine the response."
msgstr ""
"`` Move_and_collide () `` ஐப் பயன்படுத்தும் போது, செயல்பாடு ஒரு: ref: "
"`ginematccolision2d <class_kinematamCollision2d>` பொருள், இதில் மோதல் மற்றும் "
"மோதும் உடல் பற்றிய தகவல்களைக் கொண்டுள்ளது. பதிலைத் தீர்மானிக்க இந்த தகவலைப் பயன்படுத்தலாம்."

msgid ""
"For example, if you want to find the point in space where the collision "
"occurred:"
msgstr "எடுத்துக்காட்டாக, மோதல் ஏற்பட்ட இடத்தின் புள்ளியை நீங்கள் கண்டுபிடிக்க விரும்பினால்:"

msgid "Or to bounce off of the colliding object:"
msgstr "அல்லது மோதும் பொருளிலிருந்து குதிக்க:"

msgid ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"
msgstr ":ref:`move_and_slide <class_CharacterBody2D_method_move_and_slide>`"

msgid ""
"Sliding is a common collision response; imagine a player moving along walls "
"in a top-down game or running up and down slopes in a platformer. While it's "
"possible to code this response yourself after using ``move_and_collide()``, "
"``move_and_slide()`` provides a convenient way to implement sliding movement "
"without writing much code."
msgstr ""
"நெகிழ் என்பது பொதுவான மோதல் பதில்; ஒரு வீரர் ஒரு மேல்-கீழ் விளையாட்டில் சுவர்களுடன் நகரும் "
"அல்லது ஒரு இயங்குதளத்தில் சரிவுகளை மேலே ஓடுவதை கற்பனை செய்து பாருங்கள். `` "
"Move_and_collide () ``, `` `move_and_slide ()` `` `அதிக குறியீட்டை எழுதாமல் "
"நெகிழ் இயக்கத்தை செயல்படுத்த ஒரு வசதியான வழியை வழங்குகிறது."

msgid ""
"``move_and_slide()`` automatically includes the timestep in its calculation, "
"so you should **not** multiply the velocity vector by ``delta``. This does "
"**not** apply to ``gravity`` as it is an acceleration and is time dependent, "
"and needs to be scaled by ``delta``."
msgstr ""
"`` move_and_slide () `` தானாகவே அதன் கணக்கீட்டில் நேர அட்டவணையை உள்ளடக்கியது, எனவே "
"நீங்கள் ** அல்ல ** திசைவேக திசையனை `` டெல்டா`` மூலம் பெருக்க வேண்டும். இது ஒரு "
"முடுக்கம் மற்றும் நேரத்தை சார்ந்தது என்பதால் `` ஈர்ப்பு`` க்கு பொருந்தாது, மேலும் `` "
"டெல்டா`` ஆல் அளவிடப்பட வேண்டும்."

msgid ""
"For example, use the following code to make a character that can walk along "
"the ground (including slopes) and jump when standing on the ground:"
msgstr ""
"எடுத்துக்காட்டாக, பின்வரும் குறியீட்டைப் பயன்படுத்தி தரையில் (சரிவுகள் உட்பட) நடந்து "
"செல்லக்கூடிய ஒரு பாத்திரத்தை உருவாக்கி, தரையில் நிற்கும்போது குதிக்கவும்:"

msgid ""
"See :ref:`doc_kinematic_character_2d` for more details on using "
"``move_and_slide()``, including a demo project with detailed code."
msgstr ""
"காண்க: குறிப்பு: `` move_and_slide () `` பயன்படுத்துவது பற்றிய கூடுதல் விவரங்களுக்கு "
"`doc_kinematic_character_2d`, விரிவான குறியீட்டைக் கொண்ட டெமோ திட்டம் உட்பட."
