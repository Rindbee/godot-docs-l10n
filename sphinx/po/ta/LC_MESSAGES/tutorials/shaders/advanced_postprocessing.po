#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced post-processing"
msgstr "மேம்பட்ட பிந்தைய செயலாக்கம்"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"This tutorial describes an advanced method for post-processing in Godot. In "
"particular, it will explain how to write a post-processing shader that uses "
"the depth buffer. You should already be familiar with post-processing "
"generally and, in particular, with the methods outlined in the :ref:`custom "
"post-processing tutorial <doc_custom_postprocessing>`."
msgstr ""
"இந்த பயிற்சி கோடோட்டில் பிந்தைய செயலாக்கத்திற்கான மேம்பட்ட முறையை விவரிக்கிறது. "
"குறிப்பாக, ஆழமான இடையகத்தைப் பயன்படுத்தும் பிந்தைய செயலாக்க சேடரை எவ்வாறு எழுதுவது "
"என்பதை இது விளக்கும். பொதுவாக பிந்தைய செயலாக்கத்தை நீங்கள் ஏற்கனவே அறிந்திருக்க வேண்டும், "
"குறிப்பாக, பின்வருமாறு கோடிட்டுக் காட்டப்பட்டுள்ள முறைகள்: `தனிப்பயன் பிந்தைய செயலாக்க "
"பயிற்சி <doc_custom_postprocessing>`."

msgid "Full screen quad"
msgstr "முழு திரை குவாட்"

msgid ""
"One way to make custom post-processing effects is by using a viewport. "
"However, there are two main drawbacks of using a Viewport:"
msgstr ""
"தனிப்பயன் பிந்தைய செயலாக்க விளைவுகளைச் செய்வதற்கான ஒரு வழி, காட்சியகத்தைப் "
"பயன்படுத்துவதன் மூலம். இருப்பினும், ஒரு காட்சிப் போர்டைப் பயன்படுத்துவதில் இரண்டு முக்கிய "
"குறைபாடுகள் உள்ளன:"

msgid "The depth buffer cannot be accessed"
msgstr "ஆழ இடையகத்தை அணுக முடியாது"

msgid "The effect of the post-processing shader is not visible in the editor"
msgstr "பிந்தைய செயலாக்க சேடரின் விளைவு எடிட்டரில் தெரியவில்லை"

msgid ""
"To get around the limitation on using the depth buffer, use "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` with a :ref:`QuadMesh "
"<class_QuadMesh>` primitive. This allows us to use a shader and to access "
"the depth texture of the scene. Next, use a vertex shader to make the quad "
"cover the screen at all times so that the post-processing effect will be "
"applied at all times, including in the editor."
msgstr ""
"ஆழமான இடையகத்தைப் பயன்படுத்துவதற்கான வரம்பைச் சுற்றி வர, A: Ref: `meshinstance3d "
"<class_meshinstance3d>` உடன் ஒரு: குறிப்பு: `குவாட்மேச் <class_quadmesh>` "
"பழமையானது. இது ஒரு சேடரைப் பயன்படுத்தவும், காட்சியின் ஆழமான அமைப்பை அணுகவும் நம்மை "
"அனுமதிக்கிறது. அடுத்து, குவாட் எல்லா நேரங்களிலும் திரையை மறைக்க ஒரு வெர்டெக்ச் சேடரைப் "
"பயன்படுத்தவும், இதனால் எடிட்டர் உட்பட எல்லா நேரங்களிலும் பிந்தைய செயலாக்க விளைவு "
"பயன்படுத்தப்படும்."

msgid ""
"First, create a new MeshInstance3D and set its mesh to a QuadMesh. This "
"creates a quad centered at position ``(0, 0, 0)`` with a width and height of "
"``1``. Set the width and height to ``2`` and enable **Flip Faces**. Right "
"now, the quad occupies a position in world space at the origin. However, we "
"want it to move with the camera so that it always covers the entire screen. "
"To do this, we will bypass the coordinate transforms that translate the "
"vertex positions through the difference coordinate spaces and treat the "
"vertices as if they were already in clip space."
msgstr ""
"முதலில், ஒரு புதிய மெசின்ச்டன்ச் 3 டி உருவாக்கி அதன் கண்ணி ஒரு குவாட்மேசுக்கு "
"அமைக்கவும். இது `` (0, 0, 0, 0) `` ஒரு அகலம் மற்றும் உயரத்துடன் `` 1`` என்ற நிலையில் "
"மையமாக ஒரு குவாட்டை உருவாக்குகிறது. அகலத்தையும் உயரத்தையும் `` 2`` ஆக அமைத்து, ** "
"ஃபிளிப் முகங்களை இயக்கவும் **. இப்போது, குவாட் உலக இடத்தில் ஒரு நிலையை "
"ஆக்கிரமித்துள்ளது. இருப்பினும், இது கேமராவுடன் செல்ல வேண்டும் என்று நாங்கள் "
"விரும்புகிறோம், இதனால் அது எப்போதும் முழு திரையையும் உள்ளடக்கியது. இதைச் செய்ய, "
"வெர்டெக்ச் நிலைகளை வேறுபாடு ஒருங்கிணைப்பு இடங்கள் மூலம் மொழிபெயர்க்கும் ஒருங்கிணைப்பு "
"உருமாற்றங்களை நாங்கள் புறக்கணிப்போம், மேலும் அவை ஏற்கனவே கிளிப் இடத்தில் இருப்பதைப் போல "
"செங்குத்துகளை நடத்துவோம்."

msgid ""
"The vertex shader expects coordinates to be output in clip space, which are "
"coordinates ranging from ``-1`` at the left and bottom of the screen to "
"``1`` at the top and right of the screen. This is why the QuadMesh needs to "
"have height and width of ``2``. Godot handles the transform from model to "
"view space to clip space behind the scenes, so we need to nullify the "
"effects of Godot's transformations. We do this by setting the ``POSITION`` "
"built-in to our desired position. ``POSITION`` bypasses the built-in "
"transformations and sets the vertex position in clip space directly."
msgstr ""
"வெர்டெக்ச் சேடர் ஒருங்கிணைப்புகள் கிளிப் இடத்தில் வெளியீடாக இருக்க வேண்டும் என்று "
"எதிர்பார்க்கிறது, அவை திரையின் இடது மற்றும் கீழ் `` -1`` முதல் திரையின் மேல் மற்றும் "
"வலதுபுறத்தில் `` 1`` வரையிலான ஒருங்கிணைப்புகளாகும். இதனால்தான் குவாட்மேசுக்கு `` 2`` "
"உயரமும் அகலமும் இருக்க வேண்டும். திரைக்குப் பின்னால் இடத்தை கிளிப் செய்ய இடத்தைக் காணும் "
"இடத்தை கோடோட் கையாளுகிறது, எனவே கோடோட்டின் மாற்றங்களின் விளைவுகளை நாம் ரத்து செய்ய "
"வேண்டும். நாங்கள் விரும்பிய நிலைக்கு உள்ளமைக்கப்பட்ட `` நிலை`` அமைப்பதன் மூலம் இதைச் "
"செய்கிறோம். `` நிலை`` உள்ளமைக்கப்பட்ட மாற்றங்களைத் தவிர்த்து, கிளிப் இடத்தில் வெர்டெக்ச் "
"நிலையை நேரடியாக அமைக்கிறது."

msgid ""
"In versions of Godot earlier than 4.3, this code recommended using "
"``POSITION = vec4(VERTEX, 1.0);`` which implicitly assumed the clip-space "
"near plane was at ``0.0``. That code is now incorrect and will not work in "
"versions 4.3+ as we use a \"reversed-z\" depth buffer now where the near "
"plane is at ``1.0``."
msgstr ""
"4.3 ஐ விட முந்தைய கோடோட்டின் பதிப்புகளில், இந்த குறியீடு `` நிலை = VEC4 (வெர்டெக்ச், "
"1.0); அந்தக் குறியீடு இப்போது தவறானது மற்றும் 4.3+ பதிப்புகளில் இயங்காது, ஏனெனில் "
"இப்போது \"தலைகீழ்-இசட்\" ஆழ இடையகத்தைப் பயன்படுத்துகிறோம், அங்கு அருகிலுள்ள வானூர்தி `` "
"1.0`` இல் உள்ளது."

msgid ""
"Even with this vertex shader, the quad keeps disappearing. This is due to "
"frustum culling, which is done on the CPU. Frustum culling uses the camera "
"matrix and the AABBs of Meshes to determine if the Mesh will be visible "
"*before* passing it to the GPU. The CPU has no knowledge of what we are "
"doing with the vertices, so it assumes the coordinates specified refer to "
"world positions, not clip space positions, which results in Godot culling "
"the quad when we turn away from the center of the scene. In order to keep "
"the quad from being culled, there are a few options:"
msgstr ""
"இந்த வெர்டெக்ச் சேடருடன் கூட, குவாட் மறைந்து கொண்டே இருக்கும். இது சிபியு இல் செய்யப்படும் "
"ஃப்ரச்டம் கல்லிங் காரணமாகும். ஃபிரச்டம் கல்லிங் கேமரா மேட்ரிக்சையும், மெச்களின் ஏப்சையும் "
"பயன்படுத்துகிறது, இது சி.பீ.யுவுக்கு அனுப்புவதற்கு முன் கண்ணி காணப்படுமா என்பதை "
"தீர்மானிக்க. நாம் செங்குத்துகளுடன் என்ன செய்கிறோம் என்பது பற்றி சிபியு க்கு எந்த அறிவும் "
"இல்லை, எனவே குறிப்பிடப்பட்ட ஆயத்தொகுப்புகள் உலக நிலைகளைக் குறிக்கின்றன, கிளிப் விண்வெளி "
"நிலைகள் அல்ல, இதன் விளைவாக காட்சியின் மையத்திலிருந்து நாம் விலகிச் செல்லும்போது கோடோட் "
"குவாட்டை வெட்டுகிறார். குவாட் வெட்டப்படாமல் இருக்க, சில விருப்பங்கள் உள்ளன:"

msgid ""
"Add the QuadMesh as a child to the camera, so the camera is always pointed "
"at it"
msgstr ""
"கேமராவில் ஒரு குழந்தையாக குவாட்மேசைச் சேர்க்கவும், எனவே கேமரா எப்போதும் அதை "
"சுட்டிக்காட்டுகிறது"

msgid ""
"Set the Geometry property ``extra_cull_margin`` as large as possible in the "
"QuadMesh"
msgstr ""
"`` எக்ச்ட்ரா_கல்_மார்சின்`` வடிவியல் சொத்தை குவாட்மேசில் முடிந்தவரை பெரியதாக அமைக்கவும்"

msgid ""
"The second option ensures that the quad is visible in the editor, while the "
"first option guarantees that it will still be visible even if the camera "
"moves outside the cull margin. You can also use both options."
msgstr ""
"இரண்டாவது விருப்பம் குவாட் எடிட்டரில் தெரியும் என்பதை உறுதி செய்கிறது, அதே நேரத்தில் "
"முதல் விருப்பம் கேமரா குல் விளிம்புக்கு வெளியே நகர்ந்தாலும் அது இன்னும் தெரியும் என்று "
"பொறுப்பு அளிக்கிறது. நீங்கள் இரண்டு விருப்பங்களையும் பயன்படுத்தலாம்."

msgid "Depth texture"
msgstr "ஆழ அமைப்பு"

msgid ""
"To read from the depth texture, we first need to create a texture uniform "
"set to the depth buffer by using ``hint_depth_texture``."
msgstr ""
"ஆழமான அமைப்பிலிருந்து படிக்க, `` Hint_depth_texture`` ஐப் பயன்படுத்தி ஆழமான "
"இடையகத்திற்கு ஒரு அமைப்பு சீரான தொகுப்பை உருவாக்க வேண்டும்."

msgid ""
"Once defined, the depth texture can be read with the ``texture()`` function."
msgstr "வரையறுக்கப்பட்டதும், ஆழமான அமைப்பை `` அமைப்பு () `` செயல்பாட்டுடன் படிக்கலாம்."

msgid ""
"Similar to accessing the screen texture, accessing the depth texture is only "
"possible when reading from the current viewport. The depth texture cannot be "
"accessed from another viewport to which you have rendered."
msgstr ""
"திரை அமைப்பை அணுகுவதைப் போலவே, தற்போதைய காட்சியமைப்பிலிருந்து படிக்கும்போது மட்டுமே "
"ஆழமான அமைப்பை அணுகுவது சாத்தியமாகும். நீங்கள் வழங்கிய மற்றொரு காட்சியகத்திலிருந்து "
"ஆழமான அமைப்பை அணுக முடியாது."

msgid ""
"The values returned by ``depth_texture`` are between ``1.0`` and ``0.0`` "
"(corresponding to the near and far plane, respectively, because of using a "
"\"reverse-z\" depth buffer) and are nonlinear. When displaying depth "
"directly from the ``depth_texture``, everything will look almost black "
"unless it is very close due to that nonlinearity. In order to make the depth "
"value align with world or model coordinates, we need to linearize the value. "
"When we apply the projection matrix to the vertex position, the z value is "
"made nonlinear, so to linearize it, we multiply it by the inverse of the "
"projection matrix, which in Godot, is accessible with the variable "
"``INV_PROJECTION_MATRIX``."
msgstr ""
"`` ஆழம்_டெக்ரேசன்`` திருப்பி அனுப்பப்பட்ட மதிப்புகள் `` 1.0`` மற்றும் `0.0`` (முறையே "
"அருகிலுள்ள மற்றும் தூர விமானத்துடன் தொடர்புடையவை,\" தலைகீழ்-இசட் \"ஆழமான இடையகத்தைப் "
"பயன்படுத்துவதால்) மற்றும் நேரியல் அல்ல. `` Bell_texture`` இலிருந்து ஆழத்தை நேரடியாகக் "
"காண்பிக்கும் போது, அந்த நேர்கோட்டுத்தன்மையின் காரணமாக மிக நெருக்கமாக இல்லாவிட்டால் எல்லாமே "
"கிட்டத்தட்ட கறுப்பாக இருக்கும். ஆழமான மதிப்பை உலகம் அல்லது மாதிரி ஆயத்தொலைவுகளுடன் "
"சீரமைக்க, மதிப்பை நேர்கோட்டுப்படுத்த வேண்டும். வெர்டெக்ச் நிலைக்கு ப்ரொசெக்சன் மேட்ரிக்சைப் "
"பயன்படுத்தும்போது, இசட் மதிப்பு நேர்கோட்டு செய்யப்படுகிறது, எனவே அதை நேர்கோட்டுக்கு, "
"திட்ட மேட்ரிக்சின் தலைகீழ் மூலம் பெருக்கி, கோடோட்டில், `` inv_progenction_matrix`` "
"மாறுபடும்."

msgid ""
"Firstly, take the screen space coordinates and transform them into "
"normalized device coordinates (NDC). NDC run ``-1.0`` to ``1.0`` in ``x`` "
"and ``y`` directions and from ``0.0`` to ``1.0`` in the ``z`` direction when "
"using the Vulkan backend. Reconstruct the NDC using ``SCREEN_UV`` for the "
"``x`` and ``y`` axis, and the depth value for ``z``."
msgstr ""
"முதலாவதாக, திரை விண்வெளி ஒருங்கிணைப்புகளை எடுத்து அவற்றை இயல்பாக்கப்பட்ட சாதன "
"ஒருங்கிணைப்புகளாக (என்.டி.சி) மாற்றவும். Ndc `` -1.0`` `` `y`` திசைகளில்` `1.0` "
"மற்றும்` `0.0` முதல்` `1.0`` வரை` `Z``` பயன்படுத்தும் போது இயக்கவும் வல்கன் பின்தளத்தில். "
"`` X`` மற்றும் `` y`` அச்சுக்கு `` ச்கிரீன்_யூவ்` ஐப் பயன்படுத்தி என்.டி.சி."

msgid ""
"This tutorial assumes the use of the Forward+ or Mobile renderers, which "
"both use Vulkan NDCs with a Z-range of ``[0.0, 1.0]``. In contrast, the "
"Compatibility renderer uses OpenGL NDCs with a Z-range of ``[-1.0, 1.0]``. "
"For the Compatibility renderer, replace the NDC calculation with this "
"instead:"
msgstr ""
"இந்த டுடோரியல் முன்னோக்கி+ அல்லது மொபைல் ரெண்டரர்களைப் பயன்படுத்துவதாகக் கருதுகிறது, இவை "
"இரண்டும் `` [0.0, 1.0] `` z- ரேஞ்ச் மூலம் வல்கன் என்.டி.சி.க்களைப் பயன்படுத்துகின்றன. "
"இதற்கு நேர்மாறாக, இணக்கத்தன்மை ரெண்டரர் ஓபன்சிஎல் என்.டி.சி.களை `` [-1.0, 1.0] `` சட் Z-"
"ரேஞ்ச் மூலம் பயன்படுத்துகிறது. பொருந்தக்கூடிய ரெண்டரருக்கு, என்.டி.சி கணக்கீட்டை "
"மாற்றுவதற்கு பதிலாக மாற்றவும்:"

msgid ""
"You can also use the ``CURRENT_RENDERER`` and ``RENDERER_COMPATIBILITY`` "
"built-in defines for a shader that will work in all renderers:"
msgstr ""
"நீங்கள் `` நடப்பு_ரெண்டரர்`` மற்றும் `` ரெண்டர்_பொமொபாட்டிபிலிட்டி`` உள்ளமைக்கப்பட்ட ஒரு "
"சேடருக்கு உள்ளமைக்கப்பட்ட வரையறைகளை நீங்கள் பயன்படுத்தலாம், இது அனைத்து ரெண்டரர்களிலும் "
"வேலை செய்யும்:"

msgid ""
"Convert NDC to view space by multiplying the NDC by "
"``INV_PROJECTION_MATRIX``. Recall that view space gives positions relative "
"to the camera, so the ``z`` value will give us the distance to the point."
msgstr ""
"NDC ஐ NDC ஐ `` inv_progenction_matrix`` மூலம் பெருக்கி இடத்தைக் காண NDC ஐ "
"மாற்றவும். பார்வை இடம் கேமராவுடன் தொடர்புடைய நிலைகளைத் தருகிறது என்பதை நினைவில் கொள்க, "
"எனவே `` Z`` மதிப்பு நமக்கு புள்ளிக்கு தூரத்தை அளிக்கும்."

msgid ""
"Because the camera is facing the negative ``z`` direction, the position will "
"have a negative ``z`` value. In order to get a usable depth value, we have "
"to negate ``view.z``."
msgstr ""
"கேமரா எதிர்மறையான `` Z`` திசையை எதிர்கொள்வதால், அந்த நிலைக்கு எதிர்மறை `` z`` "
"மதிப்பைக் கொண்டிருக்கும். பயன்படுத்தக்கூடிய ஆழமான மதிப்பைப் பெறுவதற்கு, நாம் `` view.z`` "
"ஐ மறுக்க வேண்டும்."

msgid ""
"The world position can be constructed from the depth buffer using the "
"following code, using the ``INV_VIEW_MATRIX`` to transform the position from "
"view space into world space."
msgstr ""
"பார்வையை இடத்திலிருந்து உலக இடமாக மாற்றுவதற்கு `` inv_view_matrix`` ஐப் பயன்படுத்தி, "
"பின்வரும் குறியீட்டைப் பயன்படுத்தி ஆழ இடையகத்திலிருந்து உலக நிலையை உருவாக்க முடியும்."

msgid "Example shader"
msgstr "எடுத்துக்காட்டு சேடர்"

msgid ""
"Once we add a line to output to ``ALBEDO``, we have a complete shader that "
"looks something like this. This shader lets you visualize the linear depth "
"or world space coordinates, depending on which line is commented out."
msgstr ""
"`` ஆல்பிடோ`` க்கு வெளியீட்டிற்கு ஒரு வரியைச் சேர்த்தவுடன், எங்களிடம் ஒரு முழுமையான சேடர் "
"உள்ளது, அது இதுபோன்றதாகத் தெரிகிறது. இந்த சேடர் நேரியல் ஆழம் அல்லது உலக விண்வெளி "
"ஆயங்களை காட்சிப்படுத்த உங்களை அனுமதிக்கிறது, எந்த வரி கருத்து தெரிவிக்கப்படுகிறது "
"என்பதைப் பொறுத்து."

msgid "An optimization"
msgstr "ஒரு தேர்வுமுறை"

msgid ""
"You can benefit from using a single large triangle rather than using a full "
"screen quad. The reason for this is explained `here <https://"
"michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes>`_. "
"However, the benefit is quite small and only beneficial when running "
"especially complex fragment shaders."
msgstr ""
"முழு திரை குவாட் பயன்படுத்துவதை விட ஒரு பெரிய முக்கோணத்தைப் பயன்படுத்துவதன் மூலம் நீங்கள் "
"பயனடையலாம். இதற்கான காரணம் `இங்கே <https://michaldrobot.com/2014/04/01/gcn-"
"execution-patterns-in-full-screen-passes>` _. இருப்பினும், நன்மை மிகவும் சிறியது "
"மற்றும் குறிப்பாக சிக்கலான துண்டு நிழல்களை இயக்கும் போது மட்டுமே நன்மை பயக்கும்."

msgid ""
"Set the Mesh in the MeshInstance3D to an :ref:`ArrayMesh <class_ArrayMesh>`. "
"An ArrayMesh is a tool that allows you to easily construct a Mesh from "
"Arrays for vertices, normals, colors, etc."
msgstr ""
"Meshinstance3d இல் கண்ணி ஒரு: ref: `arraymesh <class_arraymesh>` `. ஒரு "
"வரிசைமேச் என்பது செங்குத்துகள், இயல்பான, வண்ணங்கள் போன்றவற்றுக்கான வரிசைகளிலிருந்து ஒரு "
"கண்ணி எளிதாக உருவாக்க உங்களை அனுமதிக்கும் ஒரு கருவியாகும்."

msgid "Now, attach a script to the MeshInstance3D and use the following code:"
msgstr ""
"இப்போது, Meshinstance3d உடன் ஒரு ச்கிரிப்டை இணைத்து பின்வரும் குறியீட்டைப் பயன்படுத்தவும்:"

msgid ""
"The triangle is specified in normalized device coordinates. Recall, NDC run "
"from ``-1.0`` to ``1.0`` in both the ``x`` and ``y`` directions. This makes "
"the screen ``2`` units wide and ``2`` units tall. In order to cover the "
"entire screen with a single triangle, use a triangle that is ``4`` units "
"wide and ``4`` units tall, double its height and width."
msgstr ""
"முக்கோணம் இயல்பாக்கப்பட்ட சாதன ஒருங்கிணைப்புகளில் குறிப்பிடப்பட்டுள்ளது. நினைவுகூருங்கள் "
"இது திரை `` 2`` அலகுகள் அகலமாகவும், `` 2`` அலகுகளாகவும் இருக்கும். முழு திரையையும் "
"ஒரு முக்கோணத்துடன் மறைக்க, `` 4`` அலகுகள் அகலமாகவும், `4`` அலகுகள் உயரமாகவும், அதன் "
"உயரத்தையும் அகலத்தையும் இரட்டிப்பாக்கும் ஒரு முக்கோணத்தைப் பயன்படுத்தவும்."

msgid ""
"Assign the same vertex shader from above and everything should look exactly "
"the same."
msgstr ""
"மேலே இருந்து ஒரே வெர்டெக்ச் சேடரை ஒதுக்குங்கள், எல்லாமே ஒரே மாதிரியாக இருக்க வேண்டும்."

msgid ""
"The one drawback to using an ArrayMesh over using a QuadMesh is that the "
"ArrayMesh is not visible in the editor because the triangle is not "
"constructed until the scene is run. To get around that, construct a single "
"triangle Mesh in a modeling program and use that in the MeshInstance3D "
"instead."
msgstr ""
"ஒரு குவாட்மேசைப் பயன்படுத்துவதில் ஒரு வரிசைமேசைப் பயன்படுத்துவதில் ஒரு குறைபாடு "
"என்னவென்றால், வரிசை எடிட்டரில் அரேமேச் தெரியவில்லை, ஏனெனில் காட்சி இயங்கும் வரை முக்கோணம் "
"கட்டப்படவில்லை. அதைச் சுற்றி வர, ஒரு மாடலிங் திட்டத்தில் ஒரு முக்கோண கண்ணி கட்டவும், "
"அதற்கு பதிலாக Meshinstance3d இல் பயன்படுத்தவும்."
