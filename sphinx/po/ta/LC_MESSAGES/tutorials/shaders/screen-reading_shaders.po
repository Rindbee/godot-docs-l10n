#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Screen-reading shaders"
msgstr "திரை வாசிப்பு சேடர்கள்"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"It is often desired to make a shader that reads from the same screen to "
"which it's writing. 3D APIs, such as OpenGL or DirectX, make this very "
"difficult because of internal hardware limitations. GPUs are extremely "
"parallel, so reading and writing causes all sorts of cache and coherency "
"problems. As a result, not even the most modern hardware supports this "
"properly."
msgstr ""
"அது எழுதும் அதே திரையில் இருந்து படிக்கும் ஒரு சேடரை உருவாக்குவது பெரும்பாலும் "
"விரும்பப்படுகிறது. OpenGL அல்லது Directx போன்ற 3D பநிஇ கள் உள் வன்பொருள் வரம்புகள் "
"காரணமாக இதை மிகவும் கடினமாக்குகின்றன. சி.பீ.யுகள் மிகவும் இணையானவை, எனவே படிப்பது "
"மற்றும் எழுதுவது அனைத்து வகையான தற்காலிக சேமிப்பு மற்றும் ஒத்திசைவு சிக்கல்களை "
"ஏற்படுத்துகிறது. இதன் விளைவாக, மிக நவீன வன்பொருள் கூட இதை சரியாக ஆதரிக்கவில்லை."

msgid ""
"The workaround is to make a copy of the screen, or a part of the screen, to "
"a back-buffer and then read from it while drawing. Godot provides a few "
"tools that make this process easy."
msgstr ""
"திரையின் நகலை அல்லது திரையின் ஒரு பகுதியை ஒரு பின்-பஃபர் வரை உருவாக்கி, பின்னர் "
"வரும்போது அதிலிருந்து படிக்க வேண்டும். இந்த செயல்முறையை எளிதாக்கும் சில கருவிகளை "
"கோடோட் வழங்குகிறது."

msgid "Screen texture"
msgstr "திரை அமைப்பு"

msgid ""
"Godot :ref:`doc_shading_language` has a special texture to access the "
"already rendered contents of the screen. It is used by specifying a hint "
"when declaring a ``sampler2D`` uniform: ``hint_screen_texture``. A special "
"built-in varying ``SCREEN_UV`` can be used to obtain the UV relative to the "
"screen for the current fragment. As a result, this canvas_item fragment "
"shader results in an invisible object, because it only shows what lies "
"behind:"
msgstr ""
"கோடோட்: குறிப்பு: `doc_shading_language` திரையின் ஏற்கனவே வழங்கப்பட்ட உள்ளடக்கங்களை "
"அணுக ஒரு சிறப்பு அமைப்பைக் கொண்டுள்ளது. ஒரு `` sampleer2d`` சீருடை: `` "
"hint_screen_texture`` என்று அறிவிக்கும் போது ஒரு குறிப்பைக் குறிப்பிடுவதன் மூலம் இது "
"பயன்படுத்தப்படுகிறது. தற்போதைய துண்டுக்கு திரையுடன் தொடர்புடைய புற ஊதா பெற மாறுபடும் "
"ஒரு சிறப்பு உள்ளமைக்கப்பட்ட `` ச்கிரீன்_யூவ்`` பயன்படுத்தப்படலாம். இதன் விளைவாக, இந்த "
"கேன்வாச்_இடெம் துண்டு சேடர் ஒரு கண்ணுக்கு தெரியாத பொருளை விளைவிக்கிறது, ஏனென்றால் இது "
"பின்னால் என்ன இருக்கிறது என்பதை மட்டுமே காட்டுகிறது:"

msgid ""
"``textureLod`` is used here as we only want to read from the bottom mipmap. "
"If you want to read from a blurred version of the texture instead, you can "
"increase the third argument to ``textureLod`` and change the hint "
"``filter_nearest`` to ``filter_nearest_mipmap`` (or any other filter with "
"mipmaps enabled). If using a filter with mipmaps, Godot will automatically "
"calculate the blurred texture for you."
msgstr ""
"`` TextureLod`` இங்கே பயன்படுத்தப்படுகிறது, ஏனெனில் நாம் கீழே MIPMAP இலிருந்து "
"மட்டுமே படிக்க விரும்புகிறோம். அதற்கு பதிலாக அமைப்பின் மங்கலான பதிப்பிலிருந்து நீங்கள் "
"படிக்க விரும்பினால், நீங்கள் மூன்றாவது வாதத்தை `` TextureLod`` ஆக அதிகரிக்கலாம் மற்றும் "
"`` Filter_nearest`` ஐ `` `` `` `` Filte_nearest_mipmap`` க்கு மாற்றலாம் (அல்லது "
"MIPMAPS உடன் வேறு எந்த வடிப்பானும் இயக்கப்பட்டது) . MIPMAPS உடன் வடிகட்டியைப் "
"பயன்படுத்தினால், கோடோட் உங்களுக்கான மங்கலான அமைப்பை தானாகவே கணக்கிடும்."

msgid ""
"If the filter mode is not changed to a filter mode that contains ``mipmap`` "
"in its name, ``textureLod`` with an LOD parameter greater than ``0.0`` will "
"have the same appearance as with the ``0.0`` LOD parameter."
msgstr ""
"வடிகட்டி பயன்முறை அதன் பெயரில் `` mipmap`` கொண்ட வடிகட்டி பயன்முறையில் "
"மாற்றப்படாவிட்டால், `` 0.0` ஐ விட அதிகமான LOD அளவுருவுடன் `` 0.0` 0.0` 0.0` 0.0` "
"0.0` 0.0` `லாட் அளவுரு."

msgid "Screen texture example"
msgstr "திரை அமைப்பு எடுத்துக்காட்டு"

msgid ""
"The screen texture can be used for many things. There is a special demo for "
"*Screen Space Shaders*, that you can download to see and learn. One example "
"is a simple shader to adjust brightness, contrast and saturation:"
msgstr ""
"திரை அமைப்பை பல விசயங்களுக்கு பயன்படுத்தலாம். *ச்கிரீன் ச்பேச் சேடர்களுக்கு *ஒரு சிறப்பு "
"டெமோ உள்ளது, நீங்கள் பார்க்கவும் கற்றுக்கொள்ளவும் பதிவிறக்கம் செய்யலாம். ஒரு எடுத்துக்காட்டு "
"ஒளி, மாறுபாடு மற்றும் செறிவூட்டலை சரிசெய்ய ஒரு எளிய சேடர்:"

msgid "Behind the scenes"
msgstr "திரைக்குப் பின்னால்"

msgid ""
"While this seems magical, it's not. In 2D, when ``hint_screen_texture`` is "
"first found in a node that is about to be drawn, Godot does a full-screen "
"copy to a back-buffer. Subsequent nodes that use it in shaders will not have "
"the screen copied for them, because this ends up being inefficient. In 3D, "
"the screen is copied after the opaque geometry pass, but before the "
"transparent geometry pass, so transparent objects will not be captured in "
"the screen texture."
msgstr ""
"இது மந்திரமாகத் தோன்றினாலும், அது இல்லை. 2d இல், `` hint_screen_texture`` முதலில் "
"வரையப்படவிருக்கும் ஒரு முனையில் காணப்படும்போது, கோடோட் ஒரு முழு திரை நகலை ஒரு பின்-"
"பஃபருக்கு செய்கிறார். சேடர்களில் அதைப் பயன்படுத்தும் அடுத்த முனைகள் அவற்றுக்கு திரை "
"நகலெடுக்கப்படாது, ஏனெனில் இது திறமையற்றது. 3D இல், ஒளிபுகா வடிவியல் பாசுக்குப் பிறகு "
"திரை நகலெடுக்கப்படுகிறது, ஆனால் வெளிப்படையான வடிவியல் கடந்து செல்வதற்கு முன், "
"வெளிப்படையான பொருள்கள் திரை அமைப்பில் கைப்பற்றப்படாது."

msgid ""
"As a result, in 2D, if shaders that use ``hint_screen_texture`` overlap, the "
"second one will not use the result of the first one, resulting in unexpected "
"visuals:"
msgstr ""
"இதன் விளைவாக, 2d இல், `` hint_screen_texture`` ஒன்றுடன் ஒன்று பயன்படுத்தும் சேடர்கள் "
"என்றால், இரண்டாவது முதல் முடிவைப் பயன்படுத்தாது, இதன் விளைவாக எதிர்பாராத காட்சிகள் "
"ஏற்படுகின்றன:"

msgid ""
"In the above image, the second sphere (top right) is using the same source "
"for the screen texture as the first one below, so the first one "
"\"disappears\", or is not visible."
msgstr ""
"மேலே உள்ள படத்தில், இரண்டாவது கோளம் (மேல் வலது) கீழே உள்ள திரை அமைப்புக்கு ஒரே மூலத்தைப் "
"பயன்படுத்துகிறது, எனவே முதல் ஒன்று \"மறைந்துவிடும்\", அல்லது தெரியவில்லை."

msgid ""
"In 2D, this can be corrected via the :ref:`BackBufferCopy "
"<class_BackBufferCopy>` node, which can be instantiated between both "
"spheres. BackBufferCopy can work by either specifying a screen region or the "
"whole screen:"
msgstr ""
"2 டி இல், இதை சரிசெய்யலாம்: ref: `backbuffercopy <class_backbuffercopy>` முனை, "
"இது இரு கோளங்களுக்கிடையில் உடனடிப்படுத்தப்படலாம். ஒரு திரை பகுதி அல்லது முழு "
"திரையையும் குறிப்பிடுவதன் மூலம் பேக் பஃப்சோபி வேலை செய்யலாம்:"

msgid "With correct back-buffer copying, the two spheres blend correctly:"
msgstr "சரியான பின்-பஃபர் நகலெடுப்பதன் மூலம், இரண்டு கோளங்களும் சரியாக கலக்கின்றன:"

msgid ""
"In 3D, materials that use ``hint_screen_texture`` are considered transparent "
"themselves and will not appear in the resulting screen texture of other "
"materials. If you plan to instance a scene that uses a material with "
"``hint_screen_texture``, you will need to use a BackBufferCopy node."
msgstr ""
"3D இல், `` HINT_SCREEN_TEXTURE`` ஐப் பயன்படுத்தும் பொருட்கள் தங்களைத் தாங்களே "
"வெளிப்படையாகக் கருதுகின்றன, இதன் விளைவாக பிற பொருட்களின் திரை அமைப்பில் தோன்றாது. `` "
"HINT_SCREEN_TEXTURE`` உடன் ஒரு பொருளைப் பயன்படுத்தும் ஒரு காட்சியை நீங்கள் நிகழ்த்த "
"திட்டமிட்டால், நீங்கள் ஒரு பேக் பஃப்டெர்கோபி முனையைப் பயன்படுத்த வேண்டும்."

msgid ""
"In 3D, there is less flexibility to solve this particular issue because the "
"screen texture is only captured once. Be careful when using the screen "
"texture in 3D as it won't capture transparent objects and may capture some "
"opaque objects that are in front of the object using the screen texture."
msgstr ""
"3D இல், இந்த குறிப்பிட்ட சிக்கலை தீர்க்க குறைவான நெகிழ்வுத்தன்மை உள்ளது, ஏனெனில் திரை "
"அமைப்பு ஒரு முறை மட்டுமே கைப்பற்றப்படுகிறது. 3D இல் திரை அமைப்பைப் பயன்படுத்தும் போது "
"கவனமாக இருங்கள், ஏனெனில் இது வெளிப்படையான பொருள்களைப் பிடிக்காது மற்றும் திரை அமைப்பைப் "
"பயன்படுத்தி பொருளின் முன் இருக்கும் சில ஒளிபுகா பொருள்களைப் பிடிக்கலாம்."

msgid ""
"You can reproduce the back-buffer logic in 3D by creating a :ref:`Viewport "
"<class_Viewport>` with a camera in the same position as your object, and "
"then use the :ref:`Viewport's <class_Viewport>` texture instead of the "
"screen texture."
msgstr ""
"ஒரு: re: `ViewPort <class_viewport>` உங்கள் பொருளின் அதே நிலையில் ஒரு கேமராவுடன் "
"3D இல் பின்-பஃபர் தர்க்கத்தை நீங்கள் மீண்டும் உருவாக்கலாம், பின்னர்: rew: `viewport’s "
"<class_viewport>` அமைப்பு ஆகியவற்றைப் பயன்படுத்தவும் திரை அமைப்பு."

msgid "Back-buffer logic"
msgstr "பின்-பஃபர் வழக்கு"

msgid ""
"So, to make it clearer, here's how the backbuffer copying logic works in 2D "
"in Godot:"
msgstr ""
"எனவே, அதை தெளிவுபடுத்துவதற்கு, கோடோட்டில் 2d இல் பேக் பஃபர் நகலெடுக்கும் வழக்கு எவ்வாறு "
"செயல்படுகிறது என்பது இங்கே:"

msgid ""
"If a node uses ``hint_screen_texture``, the entire screen is copied to the "
"back buffer before drawing that node. This only happens the first time; "
"subsequent nodes do not trigger this."
msgstr ""
"ஒரு முனை `` hint_screen_texture`` ஐப் பயன்படுத்தினால், அந்த முனையை வரைவதற்கு முன் "
"முழு திரையும் பின் இடையகத்திற்கு நகலெடுக்கப்படுகிறது. இது முதல் முறையாக மட்டுமே "
"நடக்கிறது; அடுத்தடுத்த முனைகள் இதைத் தூண்டாது."

msgid ""
"If a BackBufferCopy node was processed before the situation in the point "
"above (even if ``hint_screen_texture`` was not used), the behavior described "
"in the point above does not happen. In other words, automatic copying of the "
"entire screen only happens if ``hint_screen_texture`` is used in a node for "
"the first time and no BackBufferCopy node (not disabled) was found before in "
"tree-order."
msgstr ""
"மேலே உள்ள புள்ளிக்கு முன்னர் ஒரு முதுகெலும்பு முனை செயலாக்கப்பட்டிருந்தால் (`` "
"hint_screen_texture`` பயன்படுத்தப்படாவிட்டாலும் கூட), மேலே உள்ள புள்ளியில் "
"விவரிக்கப்பட்டுள்ள நடத்தை நடக்காது. வேறு வார்த்தைகளில் கூறுவதானால், முதல் முறையாக ஒரு "
"முனையில் `` HINT_SCREEN_TEXTURE`` பயன்படுத்தப்பட்டால் மட்டுமே முழு திரையையும் தானாக "
"நகலெடுப்பது நிகழ்கிறது, மேலும் மரத்தின் ஆர்டரில் இதற்கு முன் எதுவும் காணப்படவில்லை."

msgid ""
"BackBufferCopy can copy either the entire screen or a region. If set to only "
"a region (not the whole screen) and your shader uses pixels not in the "
"region copied, the result of that read is undefined (most likely garbage "
"from previous frames). In other words, it's possible to use BackBufferCopy "
"to copy back a region of the screen and then read the screen texture from a "
"different region. Avoid this behavior!"
msgstr ""
"பேக் பஃப்டர்கோபி முழு திரை அல்லது ஒரு பகுதியையும் நகலெடுக்க முடியும். ஒரு "
"பிராந்தியத்திற்கு மட்டுமே அமைக்கப்பட்டால் (முழு திரை அல்ல) மற்றும் உங்கள் சேடர் "
"நகலெடுக்கப்படாத பிராந்தியத்தில் இல்லாத பிக்சல்களைப் பயன்படுத்தினால், அந்த வாசிப்பின் முடிவு "
"வரையறுக்கப்படவில்லை (பெரும்பாலும் முந்தைய பிரேம்களிலிருந்து குப்பை). வேறு வார்த்தைகளில் "
"கூறுவதானால், திரையின் ஒரு பகுதியை மீண்டும் நகலெடுக்க பேக் பஃப்சோபியைப் பயன்படுத்தலாம், "
"பின்னர் வேறு பிராந்தியத்திலிருந்து திரை அமைப்பைப் படிக்கலாம். இந்த நடத்தையைத் தவிர்க்கவும்!"

msgid "Depth texture"
msgstr "ஆழ அமைப்பு"

msgid ""
"For 3D shaders, it's also possible to access the screen depth buffer. For "
"this, the ``hint_depth_texture`` hint is used. This texture is not linear; "
"it must be converted using the inverse projection matrix."
msgstr ""
"3D சேடர்களுக்கு, திரை ஆழம் இடையகத்தை அணுகவும் முடியும். இதற்காக, `` "
"hint_depth_texture`` குறிப்பு பயன்படுத்தப்படுகிறது. இந்த அமைப்பு நேரியல் அல்ல; தலைகீழ் "
"திட்ட மேட்ரிக்சைப் பயன்படுத்தி இது மாற்றப்பட வேண்டும்."

msgid ""
"The following code retrieves the 3D position below the pixel being drawn:"
msgstr "பின்வரும் குறியீடு பிக்சலுக்குக் கீழே உள்ள 3D நிலையை மீட்டெடுக்கிறது:"

msgid "Normal-roughness texture"
msgstr "சாதாரண-வலது அமைப்பு"

msgid ""
"Normal-roughness texture is only supported in the Forward+ rendering method, "
"not Mobile or Compatibility."
msgstr ""
"சாதாரண-ரஃப் அமைப்பு முன்னோக்கி+ வழங்குதல் முறையில் மட்டுமே ஆதரிக்கப்படுகிறது, மொபைல் "
"அல்லது பொருந்தக்கூடிய தன்மை அல்ல."

msgid ""
"Similarly, the normal-roughness texture can be used to read the normals and "
"roughness of objects rendered in the depth prepass. The normal is stored in "
"the ``.xyz`` channels (mapped to the 0-1 range) while the roughness is "
"stored in the ``.w`` channel."
msgstr ""
"இதேபோல், ஆழமான தயாரிப்புகளில் வழங்கப்பட்ட பொருட்களின் இயல்பு மற்றும் கடினத்தன்மையைப் படிக்க "
"சாதாரண-ரஃப் அமைப்பு பயன்படுத்தப்படலாம். இயல்பானது `` .xyz`` சேனல்களில் (0-1 வரம்பிற்கு "
"மேப் செய்யப்பட்டுள்ளது) சேமிக்கப்படுகிறது, அதே நேரத்தில் கடினத்தன்மை `` .w`` சேனலில் "
"சேமிக்கப்படுகிறது."

msgid "Redefining screen textures"
msgstr "திரை அமைப்புகளை மறுவரையறை செய்தல்"

msgid ""
"The screen texture hints (``hint_screen_texture``, ``hint_depth_texture``, "
"and ``hint_normal_roughness_texture``) can be used with multiple uniforms. "
"For example, you may want to read from the texture multiple times with a "
"different repeat flag or filter flag."
msgstr ""
"திரை அமைப்பு குறிப்புகள் (`` HINT_SCREEN_TEXTURE``, `` HINT_DEPTH_TEXTURE``, "
"மற்றும் `` HINT_NORMAL_ROUGHNESS_TEXTURE``) பல சீருடைகளுடன் பயன்படுத்தப்படலாம். "
"எடுத்துக்காட்டாக, வேறு மீண்டும் மீண்டும் கொடி அல்லது வடிகட்டி கொடியுடன் பல முறை "
"அமைப்பிலிருந்து படிக்க விரும்பலாம்."

msgid ""
"The following example shows a shader that reads the screen space normal with "
"linear filtering, but reads the screen space roughness using nearest "
"neighbor filtering."
msgstr ""
"பின்வரும் எடுத்துக்காட்டு நேரியல் வடிகட்டலுடன் திரை இடத்தை இயல்பாகப் படிக்கும் ஒரு சேடரைக் "
"காட்டுகிறது, ஆனால் அருகிலுள்ள அண்டை வடிகட்டலைப் பயன்படுத்தி திரை விண்வெளி "
"கடினத்தன்மையைப் படிக்கிறது."
