#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a SubViewport as a texture"
msgstr "ஒரு துணைக் காண்பிப்பைப் பயன்படுத்துதல் ஒரு அமைப்பாக"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"This tutorial will introduce you to using the :ref:`SubViewport "
"<class_SubViewport>` as a texture that can be applied to 3D objects. In "
"order to do so, it will walk you through the process of making a procedural "
"planet like the one below:"
msgstr ""
"இந்த பயிற்சி உங்களை அறிமுகப்படுத்தும்: ref: `subviewport <class_subviewport>` 3D "
"பொருள்களுக்குப் பயன்படுத்தக்கூடிய ஒரு அமைப்பாக. அவ்வாறு செய்ய, கீழே உள்ளதைப் போன்ற ஒரு "
"நடைமுறை கிரகத்தை உருவாக்கும் செயல்முறையின் மூலம் அது உங்களை அழைத்துச் செல்லும்:"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr ""
"இந்த டுடோரியல் இந்த கிரகத்தில் உள்ளதைப் போல மாறும் வளிமண்டலத்தை எவ்வாறு குறியீடாக்குவது "
"என்பதை மறைக்காது."

msgid ""
"This tutorial assumes you are familiar with how to set up a basic scene "
"including: a :ref:`Camera3D <class_Camera3D>`, a :ref:`light source "
"<class_OmniLight3D>`, a :ref:`MeshInstance3D <class_MeshInstance3D>` with "
"a :ref:`Primitive Mesh <class_PrimitiveMesh>`, and applying "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>` to the mesh. The "
"focus will be on using the :ref:`SubViewport <class_SubViewport>` to "
"dynamically create textures that can be applied to the mesh."
msgstr ""
"இந்த டுடோரியல் ஒரு அடிப்படை காட்சியை எவ்வாறு அமைப்பது என்பது உங்களுக்குத் "
"தெரிந்திருப்பதாகக் கருதுகிறது: a: ref: `கேமரா 3 டி <class_camera3d>`, ஒரு: "
"குறிப்பு: `ஒளி மூல <class_omnilight3d>`, ஒரு: ref: `meshinstance3d "
"<class_meshinstance3d>` உடன் ப: குறிப்பு: `பழமையான கண்ணி "
"<class_primitivemesh>`, மற்றும் ஒரு: குறிப்பு: `standardMaterial3d "
"<class_standardMaterial3d>` கண்ணி. மெசில் பயன்படுத்தக்கூடிய அமைப்புகளை மாறும் "
"வகையில் உருவாக்க `சப் வியூ துறைமுகம் <class_subviewport>` பயன்படுத்துவதில் கவனம் "
"செலுத்தப்படும்."

msgid "In this tutorial, we'll cover the following topics:"
msgstr "இந்த டுடோரியலில், பின்வரும் தலைப்புகளை நாங்கள் உள்ளடக்குவோம்:"

msgid "How to use a :ref:`SubViewport <class_SubViewport>` as a render texture"
msgstr "ஒரு: ref: `subviewport <class_subviewport>` ஒரு வழங்குதல் அமைப்பாக"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "சமநிலை மேப்பிங் கொண்ட ஒரு கோளத்திற்கு ஒரு அமைப்பை மேப்பிங் செய்தல்"

msgid "Fragment shader techniques for procedural planets"
msgstr "நடைமுறை கிரகங்களுக்கான துண்டு நிழல் நுட்பங்கள்"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr ""
"A இலிருந்து ஒரு கடினமான வரைபடத்தை அமைத்தல்: ref: `ViewPort Structure "
"<class_viewPortTexture>`"

msgid "Setting up the scene"
msgstr "காட்சியை அமைத்தல்"

msgid "Create a new scene and add the following nodes exactly as shown below."
msgstr ""
"ஒரு புதிய காட்சியை உருவாக்கி, கீழே காட்டப்பட்டுள்ளபடி பின்வரும் முனைகளைச் சேர்க்கவும்."

msgid "Go into the the MeshInstance3D and make the mesh a SphereMesh"
msgstr "Meshinstance3d க்குச் சென்று கண்ணி ஒரு ச்பெர்மேசாக மாற்றவும்"

msgid "Setting up the SubViewport"
msgstr "சப் வியூ போர்ட்டை அமைத்தல்"

msgid ""
"Click on the :ref:`SubViewport <class_SubViewport>` node and set its size to "
"``(1024, 512)``. The :ref:`SubViewport <class_SubViewport>` can actually be "
"any size so long as the width is double the height. The width needs to be "
"double the height so that the image will accurately map onto the sphere, as "
"we will be using equirectangular projection, but more on that later."
msgstr ""
"என்பதைக் சொடுக்கு செய்க: ref: `subviewport <class_subviewport>` முனை மற்றும் அதன் "
"அளவை `` (1024, 512) `` என அமைக்கவும். தி: ரெஃப்: `சப் வியூ துறைமுகம் "
"<class_subviewport>` அகலம் உயரத்தை இரட்டிப்பாக்கும் வரை உண்மையில் எந்த அளவிலும் "
"இருக்கலாம். அகலம் இரு மடங்காக இருக்க வேண்டும், இதனால் படம் துல்லியமாக கோளத்தில் "
"வரைபடமாக்கும், ஏனெனில் நாம் சமநிலை திட்டத்தைப் பயன்படுத்துவோம், ஆனால் பின்னர் அதைப் பற்றி "
"மேலும்."

msgid ""
"Next disable 3D. We will be using a :ref:`ColorRect <class_ColorRect>` to "
"render the surface, so we don't need 3D either."
msgstr ""
"அடுத்து 3D ஐ முடக்கு. நாங்கள் ஒரு: ref: `கலர் <class_colorrect>` மேற்பரப்பை "
"வழங்குவோம், எனவே எங்களுக்கு 3D தேவையில்லை."

msgid ""
"Select the :ref:`ColorRect <class_ColorRect>` and in the inspector set the "
"anchors preset to ``Full Rect``. This will ensure that the :ref:`ColorRect "
"<class_ColorRect>` takes up the entire :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
"தேர்வு: ref: `வண்ணம் <class_colorrect>` மற்றும் இன்ச்பெக்டரில் நங்கூரங்களை முன்னமைவதை `` "
"முழு செவ்வகம்`` என அமைக்கவும். இது: ref: `கலர் <class_colorrect>` முழுவதையும் "
"எடுத்துக்கொள்கிறது: Ref: `subviewport <class_subviewport>`."

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to "
"the :ref:`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > "
"Material > ``New ShaderMaterial``)."
msgstr ""
"அடுத்து, ஒரு: ref: `சேடர் பொருள் <class_shadermaterial>` க்கு: குறிப்பு: `வண்ணம் "
"<class_colorrect>` (கலர்> கேன்வாசிடெம்> பொருள்> பொருள்> `` புதிய நிழல் தன்மை``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"இந்த டுடோரியலுக்கு நிழலுடன் அடிப்படை பரிச்சயம் பரிந்துரைக்கப்படுகிறது. இருப்பினும், "
"நீங்கள் சேடர்களுக்கு புதியதாக இருந்தாலும், எல்லா குறியீடுகளும் வழங்கப்படும், எனவே "
"உங்களுக்கு எந்த பிரச்சனையும் இருக்கக்கூடாது."

msgid ""
"Click the dropdown menu button for the shader material and click / Edit. "
"From here go to Shader > ``New Shader``. give it a name and click "
"\"Create\". click the shader in the inspector to open the shader editor. "
"Delete the default code and add the following:"
msgstr ""
"சேடர் பொருளுக்கு கீழ்தோன்றும் பட்டியல் பொத்தானைக் சொடுக்கு செய்து / திருத்து என்பதைக் "
"சொடுக்கு செய்க. இங்கிருந்து சேடருக்குச் செல்லுங்கள்> `` புதிய சேடர்``. அதற்கு ஒரு "
"பெயரைக் கொடுத்து \"உருவாக்கு\" என்பதைக் சொடுக்கு செய்க. சேடர் எடிட்டரைத் திறக்க "
"இன்ச்பெக்டரில் சேடரைக் சொடுக்கு செய்க. இயல்புநிலை குறியீட்டை நீக்கி பின்வருவனவற்றைச் "
"சேர்க்கவும்:"

msgid ""
"save the shader code, you'll see in the inspector that the above code "
"renders a gradient like the one below."
msgstr ""
"சேடர் குறியீட்டைச் சேமிக்கவும், மேலே உள்ள குறியீடு கீழே உள்ளதைப் போன்ற சாய்வை வழங்குவதை "
"இன்ச்பெக்டரில் காண்பீர்கள்."

msgid ""
"Now we have the basics of a :ref:`SubViewport <class_SubViewport>` that we "
"render to and we have a unique image that we can apply to the sphere."
msgstr ""
"இப்போது A இன் அடிப்படைகள் உள்ளன: ref: `subviewport <class_subviewport>` நாங்கள் "
"வழங்குகிறோம், நாங்கள் கோளத்திற்கு விண்ணப்பிக்கக்கூடிய ஒரு தனித்துவமான படம் எங்களிடம் உள்ளது."

msgid "Applying the texture"
msgstr "அமைப்பைப் பயன்படுத்துதல்"

msgid ""
"Now go into the :ref:`MeshInstance3D <class_MeshInstance3D>` and add "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>` to it. No need for a "
"special :ref:`Shader Material <class_ShaderMaterial>` (although that would "
"be a good idea for more advanced effects, like the atmosphere in the example "
"above)."
msgstr ""
"இப்போது: ref: `meshinstance3d <class_meshinstance3d>` மற்றும் a: ref: "
"`standardMaterial3d <class_standardMaterial3d>` அதற்குச் சேர்க்கவும். ஒரு சிறப்பு "
"தேவையில்லை: குறிப்பு: `சேடர் பொருள் <class_shadermaterial>` (மேலே உள்ள "
"எடுத்துக்காட்டில் வளிமண்டலம் போன்ற மேம்பட்ட விளைவுகளுக்கு இது ஒரு நல்ல யோசனையாக "
"இருந்தாலும்)."

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``"
msgstr ""
"Meshinstance3d> வடிவியல்இன்ச்டன்ச்> வடிவியல்> பொருள் மேலெழுதல்> `` புதிய "
"ச்டாண்டர்டேமேட்டரியல் 3 டி```"

msgid "Then click the dropdown for the StandardMaterial3D and click \"Edit\""
msgstr ""
"பின்னர் ச்டாண்டர்டிமேட்டரியல் 3 டி க்கான கீழ்தோன்றலைக் சொடுக்கு செய்து \"திருத்து\" என்பதைக் "
"சொடுக்கு செய்க"

msgid ""
"Go to the \"Resource\" section and check the ``Local to scene`` box. Then, "
"go to the \"Albedo\" section and click beside the \"Texture\" property to "
"add an Albedo Texture. Here we will apply the texture we made. Choose \"New "
"ViewportTexture\""
msgstr ""
"\"வள\" பிரிவுக்குச் சென்று `` உள்ளக முதல் காட்சி` பெட்டியை சரிபார்க்கவும். பின்னர், "
"\"ஆல்பிடோ\" பிரிவுக்குச் சென்று, ஆல்பிடோ அமைப்பைச் சேர்க்க \"அமைப்பு\" சொத்தின் அருகே "
"சொடுக்கு செய்க. இங்கே நாங்கள் செய்த அமைப்பைப் பயன்படுத்துவோம். \"புதிய "
"ViewPortTexture\" ஐத் தேர்வுசெய்க"

msgid ""
"Click on the ViewportTexture you just created in the inspector, then click "
"\"Assign\". Then, from the menu that pops up, select the Viewport that we "
"rendered to earlier."
msgstr ""
"இன்ச்பெக்டரில் நீங்கள் உருவாக்கிய ViewPortTexture இல் சொடுக்கு செய்து, பின்னர் \"ஒதுக்கு\" "
"என்பதைக் சொடுக்கு செய்க. பின்னர், மேல்தோன்றும் மெனுவிலிருந்து, நாங்கள் முன்பு வழங்கிய "
"காட்சியகத்தைத் தேர்ந்தெடுக்கவும்."

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr ""
"உங்கள் கோளம் இப்போது நாங்கள் காட்சியமைப்புக்கு வழங்கிய வண்ணங்களுடன் வண்ணமயமாக இருக்க வேண்டும்."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"அமைப்பு சுற்றும் இடத்தில் உருவாகும் அசிங்கமான மடிப்பைக் கவனிக்கவா? ஏனென்றால், புற ஊதா "
"ஆயத்தொலைவுகளின் அடிப்படையில் ஒரு வண்ணத்தைத் தேர்ந்தெடுப்பது மற்றும் புற ஊதா ஆயத்தொலைவுகள் "
"அமைப்பைச் சுற்றவில்லை. இது 2 டி வரைபடத் திட்டத்தில் ஒரு உன்னதமான சிக்கல். கேம் "
"உருவாக்குபவர்கள் பெரும்பாலும் 2 பரிமாண வரைபடத்தைக் கொண்டுள்ளனர், அவர்கள் ஒரு கோளத்தில் "
"திட்டமிட விரும்புகிறார்கள், ஆனால் அது சுற்றும்போது, அதில் பெரிய சீம்கள் உள்ளன. இந்த "
"சிக்கலுக்கு ஒரு நேர்த்தியான பணித்தொகுப்பு உள்ளது, அடுத்த பகுதியில் நாம் விளக்குவோம்."

msgid "Making the planet texture"
msgstr "கிரக அமைப்பை உருவாக்குதல்"

msgid ""
"So now, when we render to our :ref:`SubViewport <class_SubViewport>`, it "
"appears magically on the sphere. But there is an ugly seam created by our "
"texture coordinates. So how do we get a range of coordinates that wrap "
"around the sphere in a nice way? One solution is to use a function that "
"repeats on the domain of our texture. ``sin`` and ``cos`` are two such "
"functions. Let's apply them to the texture and see what happens. Replace the "
"existing color code in the shader with the following:"
msgstr ""
"எனவே இப்போது, நாங்கள் எங்கள்: ref: `SubViewPort <class_subViewPort>` வழங்கும்போது, "
"அது கோளத்தில் மாயமாகத் தோன்றுகிறது. ஆனால் எங்கள் அமைப்பு ஒருங்கிணைப்புகளால் உருவாக்கப்பட்ட "
"ஒரு அசிங்கமான மடிப்பு உள்ளது. எனவே கோளத்தை சுற்றி ஒரு நல்ல வழியில் சுற்றும் "
"ஒருங்கிணைப்புகளின் வரம்பை எவ்வாறு பெறுவது? எங்கள் அமைப்பின் களத்தில் மீண்டும் நிகழும் ஒரு "
"செயல்பாட்டைப் பயன்படுத்துவது ஒரு தீர்வு. `` பாவம்`` மற்றும் `` காச்`` போன்ற இரண்டு "
"செயல்பாடுகள். அவற்றை அமைப்புக்குப் பயன்படுத்துவோம், என்ன நடக்கிறது என்று பார்ப்போம். "
"தற்போதுள்ள வண்ணக் குறியீட்டை சேடரில் பின்வருவனவற்றோடு மாற்றவும்:"

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in "
"its :ref:`StandardMaterial3D <class_StandardMaterial3D>`. It uses a "
"projection technique called equirectangular projection, which translates a "
"spherical map onto a 2D plane."
msgstr ""
"மிகவும் மோசமாக இல்லை. நீங்கள் சுற்றிப் பார்த்தால், மடிப்பு இப்போது மறைந்துவிட்டதை நீங்கள் "
"காணலாம், ஆனால் அதன் இடத்தில், நாங்கள் துருவங்களை கிள்ளுகிறோம். இந்த கிள்ளுதல் கோடோட் அதன் "
"கோளங்களுக்கான அமைப்புகளை வரைபடமாக்குகிறது: ref: `standardMaterial3d "
"<class_standardMaterial3d>`. இது ஈக்விரெக்கர்ங்குலர் ப்ரொசெக்சன் எனப்படும் ஒரு திட்ட "
"நுட்பத்தைப் பயன்படுத்துகிறது, இது ஒரு கோள வரைபடத்தை 2 டி விமானத்தில் மொழிபெயர்க்கிறது."

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"நுட்பத்தைப் பற்றிய கொஞ்சம் கூடுதல் தகவல்களில் நீங்கள் ஆர்வமாக இருந்தால், நாங்கள் கோள "
"ஆயங்களிலிருந்து கார்ட்டீசியன் ஒருங்கிணைப்புகளாக மாறுவோம். கோள ஆயத்தொகுதிகள் கோளத்தின் "
"தீர்க்கரேகை மற்றும் அட்சரேகைகளை வரைபடமாக்குகின்றன, அதே நேரத்தில் கார்ட்டீசியன் "
"ஆயத்தொகுப்புகள், அனைத்து நோக்கங்களுக்கும் நோக்கங்களுக்கும், கோளத்தின் மையத்திலிருந்து புள்ளி "
"வரை ஒரு திசையன் ஆகும்."

msgid ""
"For each pixel, we will calculate its 3D position on the sphere. From that, "
"we will use 3D noise to determine a color value. By calculating the noise in "
"3D, we solve the problem of the pinching at the poles. To understand why, "
"picture the noise being calculated across the surface of the sphere instead "
"of across the 2D plane. When you calculate across the surface of the sphere, "
"you never hit an edge, and hence you never create a seam or a pinch point on "
"the pole. The following code converts the ``UVs`` into Cartesian coordinates."
msgstr ""
"ஒவ்வொரு பிக்சலுக்கும், அதன் 3D நிலையை கோளத்தில் கணக்கிடுவோம். அதிலிருந்து, வண்ண மதிப்பைத் "
"தீர்மானிக்க 3D சத்தத்தைப் பயன்படுத்துவோம். 3D இல் ஒலி கணக்கிடுவதன் மூலம், துருவங்களில் "
"கிள்ளுதல் சிக்கலை நாங்கள் தீர்க்கிறோம். ஏன் என்பதைப் புரிந்து கொள்ள, 2 டி விமானத்தின் "
"குறுக்கே பதிலாக கோளத்தின் மேற்பரப்பு முழுவதும் கணக்கிடப்படும் சத்தத்தை சித்தரிக்கவும். "
"கோளத்தின் மேற்பரப்பு முழுவதும் நீங்கள் கணக்கிடும்போது, நீங்கள் ஒருபோதும் ஒரு விளிம்பைத் தாக்க "
"மாட்டீர்கள், எனவே நீங்கள் ஒருபோதும் துருவத்தில் ஒரு மடிப்பு அல்லது ஒரு பிஞ்ச் புள்ளியை "
"உருவாக்க மாட்டீர்கள். பின்வரும் குறியீடு `` UVS`` ஐ கார்ட்டீசியன் ஆயத்தொகுப்புகளாக "
"மாற்றுகிறது."

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr ""
"`` யூனிட்`` ஒரு வெளியீட்டாக `` வண்ணம்`` மதிப்பைப் பயன்படுத்தினால், நாங்கள் பெறுகிறோம்:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"இப்போது கோளத்தின் மேற்பரப்பின் 3D நிலையை நாம் கணக்கிட முடியும், கிரகத்தை உருவாக்க 3D "
"சத்தத்தைப் பயன்படுத்தலாம். இந்த இரைச்சல் செயல்பாட்டை `shadertoy <https://"
"www.shadertoy.com/view/xsl3dl> இலிருந்து நேரடியாகப் பயன்படுத்துவோம்.` _:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr ""
"அனைத்து கடன் எழுத்தாளரான இனிகோ குலெசுக்கு செல்கிறது. இது `` மிட்`` உரிமத்தின் கீழ் "
"வெளியிடப்படுகிறது."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr ""
"இப்போது `` சத்தம்`` ஐப் பயன்படுத்த, பின்வருவனவற்றை `` துண்டு`` செயல்பாட்டில் சேர்க்கவும்:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "அமைப்பை முன்னிலைப்படுத்த, நாங்கள் பொருளை அசைக்கப்படாததாக அமைத்தோம்."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"ஒலி உண்மையில் கோளத்தைச் சுற்றி தடையின்றி போர்த்தப்படுவதை நீங்கள் இப்போது காணலாம். இது "
"உங்களுக்கு வாக்குறுதியளிக்கப்பட்ட கிரகத்தைப் போல எதுவும் இல்லை என்றாலும். எனவே இன்னும் "
"வண்ணமயமான ஒன்றுக்கு செல்லலாம்."

msgid "Coloring the planet"
msgstr "கிரகத்தை வண்ணமயமாக்குதல்"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"இப்போது கிரகங்களை வண்ணமயமாக்க. இதைச் செய்ய பல வழிகள் இருக்கும்போது, இப்போதைக்கு, நீர் "
"மற்றும் நிலத்திற்கு இடையில் ஒரு சாய்வுடன் ஒட்டிக்கொள்வோம்."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"சி.எல்.எச்.எல் இல் ஒரு சாய்வு செய்ய, நாங்கள் `` கலவை` செயல்பாட்டைப் பயன்படுத்துகிறோம். `` "
"கலவை`` அவற்றுக்கிடையே எவ்வளவு இடைக்கணிக்க வேண்டும் என்பதைத் தேர்வுசெய்ய இரண்டு மதிப்புகளை "
"எடுத்துக்கொள்கிறது; சாராம்சத்தில், இது * இரண்டு மதிப்புகளையும் ஒன்றாக கலக்கிறது. மற்ற "
"பநிஇ களில், இந்த செயல்பாடு பெரும்பாலும் `` லெர்ப்`` என்று அழைக்கப்படுகிறது. இருப்பினும், "
"`` லெர்ப்`` பொதுவாக இரண்டு மிதவைகளை ஒன்றாகக் கலக்க ஒதுக்கப்படுகிறது; `` கலவை`` அது "
"மிதவைகள் அல்லது திசையன் வகைகளாக இருந்தாலும் எந்த மதிப்புகளையும் எடுக்கலாம்."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"முதல் நிறம் கடலுக்கு நீலமானது. இரண்டாவது நிறம் ஒரு வகையான சிவப்பு நிறம் (ஏனெனில் "
"அனைத்து அன்னிய கிரகங்களுக்கும் சிவப்பு நிலப்பரப்பு தேவைப்படுகிறது). இறுதியாக, அவை `` "
"n * 0.5 + 0.5`` ஆல் ஒன்றிணைக்கப்படுகின்றன. `` -1`` மற்றும் `1`` இடையே` `n`` சீராக "
"மாறுபடும். எனவே `` கலவை` எதிர்பார்க்கும் `` 0-1`` வரம்பில் அதை வரைபடமாக்குகிறோம். "
"நீலத்திற்கும் சிவப்பு நிறத்திற்கும் இடையில் வண்ணங்கள் மாறுவதை இப்போது நீங்கள் காணலாம்."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"அது நாம் விரும்புவதை விட இன்னும் கொஞ்சம் மங்கலானது. கிரகங்கள் பொதுவாக நிலத்திற்கும் "
"கடலுக்கும் இடையில் ஒப்பீட்டளவில் தெளிவான பிரிவைக் கொண்டுள்ளன. அதைச் செய்ய, கடைசி காலத்தை "
"`` மென்மையான (-0.1, 0.0, n) `` என மாற்றுவோம். இதனால் முழு வரியும் ஆகிறது:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"மூன்றாவது உரையாடல் முதல் கீழே இருந்தால், மூன்றாவது உரையாடல் இரண்டாவது விட பெரியதாக "
"இருந்தால், `` 0`` மற்றும் `` 1 க்கு இடையில் சீராக கலக்கிறது என்றால் `` 0`` திரும்புவது "
"`` 0`` `` மூன்றாவது எண் முதல் மற்றும் இரண்டாவது இடையே இருந்தால். எனவே இந்த வரியில், `` "
"சிஃபம்ச்டெப்` `` 0`` `0``` `-0.1`` ஐ விடக் குறைவாக இருக்கும்போது,` `1`` 0 க்கு மேலே "
"இருக்கும்போது` `1`` ``."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"இதை இன்னும் கொஞ்சம் கிரகம்-ஒய் செய்ய இன்னும் ஒரு சேதி. நிலம் அவ்வளவு குமிழியாக "
"இருக்கக்கூடாது; விளிம்புகளை கொஞ்சம் கடுமையானதாக மாற்றுவோம். சத்தத்துடன் கரடுமுரடான "
"நிலப்பரப்பை உருவாக்க சேடர்களில் பெரும்பாலும் பயன்படுத்தப்படும் ஒரு தந்திரம் பல்வேறு "
"அதிர்வெண்களில் ஒருவருக்கொருவர் சத்தத்தின் அடுக்குகள். கண்டங்களின் ஒட்டுமொத்த குமிழி "
"கட்டமைப்பை உருவாக்க ஒரு அடுக்கைப் பயன்படுத்துகிறோம். பின்னர் மற்றொரு அடுக்கு விளிம்புகளை "
"சிறிது உடைக்கிறது, பின்னர் மற்றொரு, மற்றும் பல. நாம் என்ன செய்வோம் என்பது ஒன்றுக்கு "
"பதிலாக நான்கு கோடுகள் சேடர் குறியீட்டைக் கொண்டு கணக்கிடுவது. `` n`` ஆகிறது:"

msgid "And now the planet looks like:"
msgstr "இப்போது கோள் போல் தெரிகிறது:"

msgid "Making an ocean"
msgstr "ஒரு கடல் தயாரித்தல்"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"இந்த தோற்றத்தை ஒரு கோள் போல மாற்றுவதற்கான ஒரு இறுதி சேதி. கடலும் நிலமும் ஒளியை "
"வித்தியாசமாக பிரதிபலிக்கின்றன. எனவே கடல் நிலத்தை விட சற்று அதிகமாக பிரகாசிக்க "
"வேண்டும் என்று நாங்கள் விரும்புகிறோம். எங்கள் வெளியீட்டின் `` ஆல்பா`` சேனலில் நான்காவது "
"மதிப்பை `` வண்ணம்`` உடன் அனுப்புவதன் மூலமும், அதை ஒரு கடினமான வரைபடமாகப் "
"பயன்படுத்துவதன் மூலமும் இதைச் செய்யலாம்."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"இந்த வரி தண்ணீருக்கு `` 0.3`` மற்றும் நிலத்திற்கு `` 1.0`` ஆகியவற்றை வழங்குகிறது. இதன் "
"பொருள் நிலம் மிகவும் கடினமானதாக இருக்கும், அதே நேரத்தில் தண்ணீர் மிகவும் மென்மையாக "
"இருக்கும்."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"பின்னர், பொருளில், \"உலோக\" பிரிவின் கீழ், `` மெட்டாலிக்`` `` 0` மற்றும் `` ஏகப்பட்ட`` "
"என அமைக்கப்பட்டிருப்பதை உறுதிசெய்து கொள்ளுங்கள். இதற்கான காரணம் நீர் ஒளியை நன்றாக "
"பிரதிபலிக்கிறது, ஆனால் உலோகம் அல்ல. இந்த மதிப்புகள் உடல் ரீதியாக துல்லியமானவை அல்ல, "
"ஆனால் அவை இந்த டெமோவுக்கு போதுமானவை."

msgid ""
"Next, under the \"Roughness\" section set the roughness texture to "
"a :ref:`Viewport Texture <class_ViewportTexture>` pointing to our planet "
"texture :ref:`SubViewport <class_SubViewport>`. Finally, set the ``Texture "
"Channel`` to ``Alpha``. This instructs the renderer to use the ``alpha`` "
"channel of our output ``COLOR`` as the ``Roughness`` value."
msgstr ""
"அடுத்து, \"கடினத்தன்மை\" பிரிவின் கீழ் கரடுமுரடான அமைப்பை A: ref: `ViewPort "
"Structure <stoss_viewPortTexture>` எங்கள் கிரக அமைப்பை சுட்டிக்காட்டுகிறது: "
"குறிப்பு: `SubViewPort <stoss_subviewport>`. இறுதியாக, `` அமைப்பு சேனலை`` `` "
"ஆல்பா`` என அமைக்கவும். எங்கள் வெளியீட்டின் `` ஆல்பா`` சேனலை `` வண்ணம்`` `` கடினத்தன்மை`` "
"மதிப்பாகப் பயன்படுத்த இது ரெண்டரருக்கு அறிவுறுத்துகிறது."

msgid ""
"You'll notice that very little changes except that the planet is no longer "
"reflecting the sky. This is happening because, by default, when something is "
"rendered with an alpha value, it gets drawn as a transparent object over the "
"background. And since the default background of the :ref:`SubViewport "
"<class_SubViewport>` is opaque, the ``alpha`` channel of the :ref:`Viewport "
"Texture <class_ViewportTexture>` is ``1``, resulting in the planet texture "
"being drawn with slightly fainter colors and a ``Roughness`` value of ``1`` "
"everywhere. To correct this, we go into the :ref:`SubViewport "
"<class_SubViewport>` and enable the \"Transparent Bg\" property. Since we "
"are now rendering one transparent object on top of another, we want to "
"enable ``blend_premul_alpha``:"
msgstr ""
"கோள் இனி வானத்தை பிரதிபலிக்கவில்லை என்பதைத் தவிர மிகக் குறைந்த மாற்றங்களை நீங்கள் "
"கவனிப்பீர்கள். இது நடக்கிறது, ஏனெனில், இயல்புநிலையாக, ஏதேனும் ஆல்பா மதிப்புடன் "
"வழங்கப்படும்போது, அது பின்னணியில் வெளிப்படையான பொருளாக வரையப்படுகிறது. மற்றும் "
"இயல்புநிலை பின்னணியில்: Ref: `subviewport <class_subviewport>` என்பது ஒளிபுகா, "
"`` ஆல்பா`` சேனல்: ref: `Viewport அமைப்பு <class_viewporttexture>` என்பது `` 1`` "
"ஆகும், இதன் விளைவாக கிரக அமைப்பு ஏற்படுகிறது சற்று மங்கலான வண்ணங்கள் மற்றும் எல்லா "
"இடங்களிலும் `` 1`` மதிப்புடன் வரையப்பட்டிருப்பது. இதைச் சரிசெய்ய, நாங்கள்: ref: "
"`subviewport <class_subviewport>` மற்றும் \"வெளிப்படையான பி.சி\" சொத்தை "
"இயக்குகிறோம். நாம் இப்போது ஒரு வெளிப்படையான பொருளை மற்றொன்றுக்கு மேல் வழங்குவதால், `` "
"Cland_premul_alpha`` ஐ இயக்க விரும்புகிறோம்:"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"இது `` ஆல்பா`` மதிப்பால் வண்ணங்களை முன்கூட்டியே திட்டமிடுகிறது, பின்னர் அவற்றை சரியாக "
"ஒன்றாக கலக்கிறது. பொதுவாக, ஒரு வெளிப்படையான நிறத்தை மற்றொன்றுக்கு மேல் கலக்கும்போது, "
"பின்னணியில் `` 0`` (இந்த விசயத்தில் செய்வது போல) (இது போல) இருந்தாலும், நீங்கள் "
"வித்தியாசமான வண்ண இரத்தம் சிக்கல்களுடன் முடிவடையும். `` Cland_premul_alpha`` அதை "
"சரிசெய்கிறது."

msgid ""
"Now the planet should look like it is reflecting light on the ocean but not "
"the land. move around the :ref:`OmniLight3D <class_OmniLight3D>` in the "
"scene so you can see the effect of the reflections on the ocean."
msgstr ""
"இப்போது கோள் கடலில் ஒளியை பிரதிபலிப்பதைப் போல இருக்க வேண்டும், ஆனால் நிலம் அல்ல. சுற்றி "
"நகர்த்தவும்: ref: `omnilight3d <class_omnilight3d>` காட்சியில், எனவே கடலில் "
"பிரதிபலிப்புகளின் விளைவைக் காணலாம்."

msgid ""
"And there you have it. A procedural planet generated using "
"a :ref:`SubViewport <class_SubViewport>`."
msgstr ""
"அங்கே உங்களிடம் உள்ளது. A: ref: `SubViewPort <class_subViewPort>` ஐப் பயன்படுத்தி "
"உருவாக்கப்பட்ட ஒரு நடைமுறை கோள்."
