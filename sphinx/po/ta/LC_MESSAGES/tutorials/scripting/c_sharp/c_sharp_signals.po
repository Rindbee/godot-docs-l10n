#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "C# signals"
msgstr "சி# சமிக்ஞைகள்"

msgid ""
"For a detailed explanation of signals in general, see the :ref:`doc_signals` "
"section in the step by step tutorial."
msgstr ""
"பொதுவாக சமிக்ஞைகளின் விரிவான விளக்கத்திற்கு, படி டுடோரியலின் படி: ref: "
"`doc_signals` பிரிவு பார்க்கவும்."

msgid ""
"Signals are implemented using C# events, the idiomatic way to represent :ref:"
"`the observer pattern<doc_key_concepts_signals>` in C#. This is the "
"recommended way to use signals in C# and the focus of this page."
msgstr ""
"சி# நிகழ்வுகளைப் பயன்படுத்தி சமிக்ஞைகள் செயல்படுத்தப்படுகின்றன, "
"பிரதிநிதித்துவப்படுத்துவதற்கான முட்டாள்தனமான வழி: குறிப்பு: `பார்வையாளர் முறை "
"<doc_key_concepts_signals>` சி# இல். சி# மற்றும் இந்த பக்கத்தின் மையத்தில் சமிக்ஞைகளைப் "
"பயன்படுத்த இது பரிந்துரைக்கப்பட்ட வழி."

msgid ""
"In some cases it's necessary to use the older :ref:"
"`Connect()<class_object_method_connect>` and :ref:"
"`Disconnect()<class_object_method_disconnect>` APIs. See :ref:"
"`using_connect_and_disconnect` for more details."
msgstr ""
"சில சந்தர்ப்பங்களில் பழையவற்றைப் பயன்படுத்த வேண்டியது அவசியம்: ref: `இணைக்கவும் () "
"<class_object_method_connect>` மற்றும்: ref: `துண்டிக்கவும் () "
"<class_object_method_disconnect>` பநிஇ கள். காண்க: குறிப்பு: மேலும் விவரங்களுக்கு "
"`பயன்படுத்துதல்_கனெக்ட்_ஆன்ட்_டிச்கானெக்ட்` பயன்படுத்துகிறது."

msgid ""
"If you encounter a ``System.ObjectDisposedException`` while handling a "
"signal, you might be missing a signal disconnection. See :ref:"
"`disconnecting_automatically_when_the_receiver_is_freed` for more details."
msgstr ""
"நீங்கள் ஒரு `` சிச்டம்.ஆப்செக்ட் டிச்போச் எக்ச்செப்சன்`` ஐ சந்தித்தால், ஒரு சமிக்ஞையை கையாளும் "
"போது, நீங்கள் ஒரு சமிக்ஞை துண்டிக்கப்படுவதைக் காணவில்லை. காண்க: குறிப்பு: மேலும் "
"விவரங்களுக்கு `துண்டிக்கப்பட்ட_அவுட்டோமாய்டிக்_வென்_இ_ரேச்_ச்_ஃபிரீட்`."

msgid "Signals as C# events"
msgstr "சி# நிகழ்வுகளாக சமிக்ஞைகள்"

msgid ""
"To provide more type-safety, Godot signals are also all available through "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"You can handle these events, as any other event, with the ``+=`` and ``-=`` "
"operators."
msgstr ""
"மேலும் வகை-பாதுகாப்பை வழங்க, கோடோட் சிக்னல்கள் அனைத்தும் `நிகழ்வுகள் <https://learn."
"microsoft.com/en-us/dotnet/csharp/events-overview>` _ ஆகியவற்றின் மூலமும் "
"கிடைக்கின்றன. இந்த நிகழ்வுகளை வேறு எந்த நிகழ்வாகவும், ``+= `` மற்றும் ``-= `` `` `` "
"`` `` `` `` `` `` `` இந்த நிகழ்வுகளை நீங்கள் கையாளலாம்."

msgid ""
"In addition, you can always access signal names associated with a node type "
"through its nested ``SignalName`` class. This is useful when, for example, "
"you want to await on a signal (see :ref:`doc_c_sharp_differences_await`)."
msgstr ""
"கூடுதலாக, நீங்கள் எப்போதும் ஒரு முனை வகையுடன் தொடர்புடைய சமிக்ஞை பெயர்களை அதன் "
"உள்ளமைக்கப்பட்ட `` சிக்னல் பெயர்`` வகுப்பு மூலம் அணுகலாம். எடுத்துக்காட்டாக, நீங்கள் ஒரு "
"சமிக்ஞையில் காத்திருக்க விரும்பும் போது இது பயனுள்ளதாக இருக்கும் (பார்க்க: குறிப்பு: "
"`doc_c_sharp_differences_await`)."

msgid "Custom signals as C# events"
msgstr "சி# நிகழ்வுகளாக தனிப்பயன் சமிக்ஞைகள்"

msgid ""
"To declare a custom event in your C# script, use the ``[Signal]`` attribute "
"on a public delegate type. Note that the name of this delegate needs to end "
"with ``EventHandler``."
msgstr ""
"உங்கள் சி# ச்கிரிப்ட்டில் தனிப்பயன் நிகழ்வை அறிவிக்க, பொது சார்பாளர் வகையில் `` [சமிக்ஞை] "
"`` பண்புக்கூறு பயன்படுத்தவும். இந்த பிரதிநிதியின் பெயர் `` EventHandler`` உடன் "
"முடிவடைய வேண்டும் என்பதை நினைவில் கொள்க."

msgid ""
"Once this is done, Godot will create the appropriate events automatically "
"behind the scenes. You can then use said events as you'd do for any other "
"Godot signal. Note that events are named using your delegate's name minus "
"the final ``EventHandler`` part."
msgstr ""
"இது முடிந்ததும், கோடோட் திரைக்குப் பின்னால் தானாகவே பொருத்தமான நிகழ்வுகளை உருவாக்கும். "
"வேறு எந்த கோடோட் சிக்னலுக்கும் நீங்கள் செய்வது போல நீங்கள் சொன்ன நிகழ்வுகளைப் பயன்படுத்தலாம். "
"உங்கள் பிரதிநிதியின் பெயரைப் பயன்படுத்தி நிகழ்வுகள் பெயரிடப்பட்டுள்ளன என்பதை நினைவில் "
"கொள்க."

msgid ""
"If you want to connect to these signals in the editor, you will need to "
"(re)build the project to see them appear."
msgstr ""
"எடிட்டரில் இந்த சமிக்ஞைகளுடன் நீங்கள் இணைக்க விரும்பினால், அவை தோன்றுவதைக் காண நீங்கள் "
"திட்டத்தை உருவாக்க வேண்டும்."

msgid ""
"You can click the **Build** button in the upper-right corner of the editor "
"to do so."
msgstr ""
"அவ்வாறு செய்ய எடிட்டரின் மேல்-வலது மூலையில் உள்ள ** பில்ட் ** பொத்தானைக் சொடுக்கு "
"செய்யலாம்."

msgid "Signal emission"
msgstr "சமிக்ஞை உமிழ்வு"

msgid ""
"To emit signals, use the ``EmitSignal`` method. Note that, as for signals "
"defined by the engine, your custom signal names are listed under the nested "
"``SignalName`` class."
msgstr ""
"சமிக்ஞைகளை வெளியிடுவதற்கு, `` எமிட்சிக்னல்`` முறையைப் பயன்படுத்தவும். இயந்திரத்தால் "
"வரையறுக்கப்பட்ட சமிக்ஞைகளைப் பொறுத்தவரை, உங்கள் தனிப்பயன் சமிக்ஞை பெயர்கள் உள்ளமைக்கப்பட்ட `` "
"சிக்னல் பெயர்`` வகுப்பின் கீழ் பட்டியலிடப்பட்டுள்ளன என்பதை நினைவில் கொள்க."

msgid ""
"In contrast with other C# events, you cannot use ``Invoke`` to raise events "
"tied to Godot signals."
msgstr ""
"மற்ற சி# நிகழ்வுகளுக்கு மாறாக, கோடோட் சிக்னல்களுடன் பிணைக்கப்பட்ட நிகழ்வுகளை உயர்த்த நீங்கள் "
"`` இன்வோக்`` ஐப் பயன்படுத்த முடியாது."

msgid ""
"Signals support arguments of any :ref:`Variant-compatible type "
"<c_sharp_variant_compatible_types>`."
msgstr ""
"சிக்னல்கள் ஏதேனும் ஒரு வாதங்களை ஆதரிக்கின்றன: ref: `மாறுபாடு-இணக்கமான வகை "
"<c_sharp_variant_compatible_types>`."

msgid ""
"Consequently, any ``Node`` or ``RefCounted`` will be compatible "
"automatically, but custom data objects will need to inherit from "
"``GodotObject`` or one of its subclasses."
msgstr ""
"இதன் விளைவாக, எந்தவொரு `` முனை`` அல்லது `` மறுபயன்பாட்டு`` தானாகவே இணக்கமாக "
"இருக்கும், ஆனால் தனிப்பயன் தரவு பொருள்கள் `` கோடோடோப்செக்ட்` அல்லது அதன் "
"துணைப்பிரிவுகளிலிருந்து பெற வேண்டும்."

msgid "Bound values"
msgstr "கட்டுப்பட்ட மதிப்புகள்"

msgid ""
"Sometimes you'll want to bind values to a signal when the connection is "
"established, rather than (or in addition to) when the signal is emitted. To "
"do so, you can use an anonymous function like in the following example."
msgstr ""
"சமிக்ஞை வெளிப்படும் போது (அல்லது கூடுதலாக) இணைப்பு நிறுவப்படும் போது மதிப்புகளை ஒரு "
"சமிக்ஞையுடன் பிணைக்க சில நேரங்களில் நீங்கள் விரும்புவீர்கள். அவ்வாறு செய்ய, பின்வரும் "
"எடுத்துக்காட்டில் போன்ற அநாமதேய செயல்பாட்டைப் பயன்படுத்தலாம்."

msgid ""
"Here, the :ref:`Button.Pressed <class_BaseButton_signal_pressed>` signal "
"does not take any argument. But we want to use the same ``ModifyValue`` for "
"both the \"plus\" and \"minus\" buttons. So we bind the modifier value at "
"the time we're connecting the signals."
msgstr ""
"இங்கே, தி: ரெஃப்: `பொத்தான். ஆனால் \"பிளச்\" மற்றும் \"மைனச்\" பொத்தான்கள் இரண்டிற்கும் அதே "
"`` மாற்றியமைத்தல்`` ஐப் பயன்படுத்த விரும்புகிறோம். எனவே நாங்கள் சமிக்ஞைகளை இணைக்கும் "
"நேரத்தில் மாற்றியமைக்கும் மதிப்பை பிணைக்கிறோம்."

msgid "Signal creation at runtime"
msgstr "இயக்க நேரத்தில் சமிக்ஞை உருவாக்கம்"

msgid ""
"Finally, you can create custom signals directly while your game is running. "
"Use the ``AddUserSignal`` method for that. Be aware that it should be "
"executed before any use of said signals (either connecting to them or "
"emitting them). Also, note that signals created this way won't be visible "
"through the ``SignalName`` nested class."
msgstr ""
"இறுதியாக, உங்கள் விளையாட்டு இயங்கும்போது நேரடியாக தனிப்பயன் சமிக்ஞைகளை உருவாக்கலாம். "
"அதற்காக `` addusersignal`` முறையைப் பயன்படுத்தவும். கூறப்பட்ட சமிக்ஞைகளின் எந்தவொரு "
"பயன்பாட்டிற்கும் முன்னர் இது செயல்படுத்தப்பட வேண்டும் என்பதை அறிந்து கொள்ளுங்கள் (அவற்றுடன் "
"இணைத்தல் அல்லது அவற்றை வெளியிடுவது). மேலும், இந்த வழியில் உருவாக்கப்பட்ட சமிக்ஞைகள் `` "
"சிக்னல்நேம்`` உள்ளமைக்கப்பட்ட வகுப்பின் மூலம் தெரியவில்லை என்பதை நினைவில் கொள்க."

msgid "Using Connect and Disconnect"
msgstr "இணைப்பு மற்றும் துண்டிப்பு ஆகியவற்றைப் பயன்படுத்துதல்"

msgid ""
"In general, it isn't recommended to use :ref:"
"`Connect()<class_object_method_connect>` and :ref:"
"`Disconnect()<class_object_method_disconnect>`. These APIs don't provide as "
"much type safety as the events. However, they're necessary for :ref:"
"`connecting to signals defined by GDScript "
"<connecting_to_signals_cross_language>` and passing :ref:"
"`ConnectFlags<enum_Object_ConnectFlags>`."
msgstr ""
"பொதுவாக, பயன்படுத்த பரிந்துரைக்கப்படவில்லை: குறிப்பு: `இணைக்கவும் () "
"<class_object_method_connect>` மற்றும்: ref: `துண்டிக்கவும் () "
"<class_object_method_disconnect>`. இந்த பநிஇ கள் நிகழ்வுகளைப் போல வகை பாதுகாப்பை "
"வழங்காது. இருப்பினும், அவை அவசியமானவை: ref: `gdscript ஆல் வரையறுக்கப்பட்ட "
"சமிக்ஞைகளுடன் இணைத்தல் <connecting_to_signals_crorse_language>` மற்றும் கடந்து "
"செல்வது: `கனெக்ட்ஃப்ளாக்ச் <enum_object_connectflags>`."

msgid ""
"In the following example, pressing the button for the first time prints "
"``Greetings!``. ``OneShot`` disconnects the signal, so pressing the button "
"again does nothing."
msgstr ""
"பின்வரும் எடுத்துக்காட்டில், முதல் முறையாக பொத்தானை அழுத்தினால் `` வாழ்த்துக்கள்! ``. `` "
"ஒன்சாட்`` சிக்னலைத் துண்டிக்கிறது, எனவே பொத்தானை மீண்டும் அழுத்தினால் எதுவும் செய்யாது."

msgid "Disconnecting automatically when the receiver is freed"
msgstr "ரிசீவர் விடுவிக்கப்படும் போது தானாக துண்டிக்கப்படுதல்"

msgid ""
"Normally, when any ``GodotObject`` is freed (such as any ``Node``), Godot "
"automatically disconnects all connections associated with that object. This "
"happens for both signal emitters and signal receivers."
msgstr ""
"பொதுவாக, ஏதேனும் `` கோடோடோப்செக்ட்` `விடுவிக்கப்படும்போது (ஏதேனும்` `முனை`` போன்றவை), "
"கோடோட் தானாகவே அந்த பொருளுடன் தொடர்புடைய அனைத்து இணைப்புகளையும் துண்டிக்கிறது. சிக்னல் "
"உமிழ்ப்பவர்கள் மற்றும் சமிக்ஞை பெறுநர்கள் இரண்டிற்கும் இது நிகழ்கிறது."

msgid ""
"For example, a node with this code will print \"Hello!\" when the button is "
"pressed, then free itself. Freeing the node disconnects the signal, so "
"pressing the button again doesn't do anything:"
msgstr ""
"எடுத்துக்காட்டாக, இந்த குறியீட்டைக் கொண்ட ஒரு முனை \"அலோ!\" பொத்தானை அழுத்தும்போது, "
"தன்னை விடுவித்துக் கொள்ளுங்கள். முனையை விடுவிப்பது சிக்னலைத் துண்டிக்கிறது, எனவே "
"பொத்தானை மீண்டும் அழுத்தினால் எதுவும் செய்யாது:"

msgid ""
"When a signal receiver is freed while the signal emitter is still alive, in "
"some cases automatic disconnection won't happen:"
msgstr ""
"சமிக்ஞை உமிழ்ப்பான் இன்னும் உயிருடன் இருக்கும்போது ஒரு சமிக்ஞை பெறுநர் விடுவிக்கப்படும் "
"போது, சில சந்தர்ப்பங்களில் தானியங்கி துண்டிப்பு நடக்காது:"

msgid ""
"The signal is connected to a lambda expression that captures a variable."
msgstr "சமிக்ஞை ஒரு மாறக்கூடிய ஒரு லாம்ப்டா வெளிப்பாட்டுடன் இணைக்கப்பட்டுள்ளது."

msgid "The signal is a custom signal."
msgstr "சமிக்ஞை தனிப்பயன் சமிக்ஞை."

msgid ""
"The following sections explain these cases in more detail and include "
"suggestions for how to disconnect manually."
msgstr ""
"பின்வரும் பிரிவுகள் இந்த நிகழ்வுகளை இன்னும் விரிவாக விளக்குகின்றன மற்றும் கைமுறையாக "
"எவ்வாறு துண்டிக்கப்படுவது என்பதற்கான பரிந்துரைகளை உள்ளடக்குகின்றன."

msgid ""
"Automatic disconnection is totally reliable if a signal emitter is freed "
"before any of its receivers are freed. With a project style that prefers "
"this pattern, the above limits may not be a concern."
msgstr ""
"ஒரு சமிக்ஞை உமிழ்ப்பான் விடுவிக்கப்பட்டால் தானியங்கி துண்டிப்பு முற்றிலும் நம்பகமானது. இந்த "
"முறையை விரும்பும் திட்ட பாணியுடன், மேலே உள்ள வரம்புகள் கவலையாக இருக்காது."

msgid ""
"No automatic disconnection: a lambda expression that captures a variable"
msgstr "தானியங்கி துண்டிப்பு இல்லை: ஒரு மாறியைக் கைப்பற்றும் ஒரு லாம்ப்டா வெளிப்பாடு"

msgid ""
"If you connect to a lambda expression that captures variables, Godot can't "
"tell that the lambda is associated with the instance that created it. This "
"causes this example to have potentially unexpected behavior:"
msgstr ""
"மாறிகளைக் கைப்பற்றும் ஒரு லாம்ப்டா வெளிப்பாட்டுடன் நீங்கள் இணைந்தால், லாம்ப்டா அதை உருவாக்கிய "
"நிகழ்வோடு தொடர்புடையது என்று கோடோட் சொல்ல முடியாது. இது இந்த உதாரணத்தை எதிர்பாராத "
"நடத்தை கொண்டிருக்க காரணமாகிறது:"

msgid ""
"On tick 4, the lambda expression tries to access the ``Name`` property of "
"the node, but the node has already been freed. This causes the exception."
msgstr ""
"டிக் 4 இல், லாம்ப்டா வெளிப்பாடு முனையின் `` பெயர்` சொத்தை அணுக முயற்சிக்கிறது, ஆனால் "
"முனை ஏற்கனவே விடுவிக்கப்பட்டுள்ளது. இது விதிவிலக்கை ஏற்படுத்துகிறது."

msgid ""
"To disconnect, keep a reference to the delegate created by the lambda "
"expression and pass that to ``-=``. For example, this node connects and "
"disconnects using the ``_EnterTree`` and ``_ExitTree`` lifecycle methods:"
msgstr ""
"துண்டிக்க, லாம்ப்டா வெளிப்பாட்டால் உருவாக்கப்பட்ட பிரதிநிதியைப் பற்றிய குறிப்பை வைத்து அதை "
"``-= `` என்று அனுப்பவும். எடுத்துக்காட்டாக, இந்த முனை `` _Entertree`` மற்றும் "
"`_Exittree`` வாழ்க்கை சுழற்சி முறைகளைப் பயன்படுத்தி இணைத்து துண்டிக்கிறது:"

msgid ""
"In this example, ``Free`` causes the node to leave the tree, which calls "
"``_ExitTree``. ``_ExitTree`` disconnects the signal, so ``_tick`` is never "
"called again."
msgstr ""
"இந்த எடுத்துக்காட்டில், `` இலவசம்`` கணு மரத்தை விட்டு வெளியேற காரணமாகிறது, இது `` "
"_exittree`` என்று அழைக்கிறது. `` _Exittree`` சிக்னலைத் துண்டிக்கிறது, எனவே `` "
"_tick`` மீண்டும் அழைக்கப்படுவதில்லை."

msgid ""
"The lifecycle methods to use depend on what the node does. Another option is "
"to connect to signals in ``_Ready`` and disconnect in ``Dispose``."
msgstr ""
"பயன்படுத்துவதற்கான வாழ்க்கை சுழற்சி முறைகள் முனை என்ன செய்கின்றன என்பதைப் பொறுத்தது. "
"மற்றொரு விருப்பம் என்னவென்றால், `` _ready`` இல் உள்ள சமிக்ஞைகளுடன் இணைத்து `` "
"அப்புறப்படுத்துங்கள்` இல் துண்டிக்கவும்."

msgid ""
"Godot uses `Delegate.Target <https://learn.microsoft.com/en-us/dotnet/api/"
"system.delegate.target>`_ to determine what instance a delegate is "
"associated with. When a lambda expression doesn't capture a variable, the "
"generated delegate's ``Target`` is the instance that created the delegate. "
"When a variable is captured, the ``Target`` instead points at a generated "
"type that stores the captured variable. This is what breaks the association. "
"If you want to see if a delegate will be automatically cleaned up, try "
"checking its ``Target``."
msgstr ""
"கோடோட் `பிரதிநிதி. ஒரு லாம்ப்டா வெளிப்பாடு ஒரு மாறியைக் கைப்பற்றாதபோது, உருவாக்கப்பட்ட "
"பிரதிநிதியின் `` இலக்கு`` என்பது பிரதிநிதியை உருவாக்கிய சான்று. ஒரு மாறி "
"கைப்பற்றப்படும்போது, `` இலக்கு`` அதற்கு பதிலாக கைப்பற்றப்பட்ட மாறியை சேமிக்கும் ஒரு "
"உருவாக்கப்பட்ட வகையை சுட்டிக்காட்டுகிறது. இதுதான் சங்கத்தை உடைக்கிறது. ஒரு சார்பாளர் "
"தானாகவே தூய்மை செய்யப்படுவாரா என்பதை நீங்கள் பார்க்க விரும்பினால், அதன் `` இலக்கு`` ஐ "
"சரிபார்க்க முயற்சிக்கவும்."

msgid ""
"``Callable.From`` doesn't affect the ``Delegate.Target``, so connecting a "
"lambda that captures variables using ``Connect`` doesn't work any better "
"than ``+=``."
msgstr "`` Callable.from`` `` சார்பாளர்."

msgid "No automatic disconnection: a custom signal"
msgstr "தானியங்கி துண்டிப்பு இல்லை: தனிப்பயன் சமிக்ஞை"

msgid ""
"Connecting to a custom signal using ``+=`` doesn't disconnect automatically "
"when the receiving node is freed."
msgstr ""
"``+= `` ஐப் பயன்படுத்தி தனிப்பயன் சமிக்ஞையுடன் இணைப்பது பெறும் முனை விடுவிக்கப்படும் "
"போது தானாக துண்டிக்கப்படாது."

msgid "To disconnect, use ``-=`` at an appropriate time. For example:"
msgstr "துண்டிக்க, பொருத்தமான நேரத்தில் ``-= `` ஐப் பயன்படுத்தவும். உதாரணமாக:"

msgid ""
"Another solution is to use ``Connect``, which does disconnect automatically "
"with custom signals:"
msgstr ""
"மற்றொரு தீர்வு `` கனெக்ட்`` ஐப் பயன்படுத்துவது, இது தனிப்பயன் சமிக்ஞைகளுடன் தானாக "
"துண்டிக்கப்படும்:"
