#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Matrices and transforms"
msgstr "மெட்ரிக்குகள் மற்றும் உருமாற்றங்கள்"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"Before reading this tutorial, we recommend that you thoroughly read and "
"understand the :ref:`doc_vector_math` tutorial, as this tutorial requires a "
"knowledge of vectors."
msgstr ""
"இந்த டுடோரியலைப் படிப்பதற்கு முன், நீங்கள் முழுமையாகப் படித்து புரிந்து கொள்ள "
"பரிந்துரைக்கிறோம்: குறிப்பு: `doc_vector_math` டுடோரியல், ஏனெனில் இந்த டுடோரியலுக்கு "
"திசையன்களைப் பற்றிய அறிவு தேவைப்படுகிறது."

msgid ""
"This tutorial is about *transformations* and how we represent them in Godot "
"using matrices. It is not a full in-depth guide to matrices. Transformations "
"are most of the time applied as translation, rotation, and scale, so we will "
"focus on how to represent those with matrices."
msgstr ""
"இந்த பயிற்சி * மாற்றங்கள் * மற்றும் மெட்ரிக்குகளைப் பயன்படுத்தி கோடோட்டில் அவற்றை எவ்வாறு "
"பிரதிநிதித்துவப்படுத்துகிறோம். இது மெட்ரிக்குகளுக்கு முழு ஆழமான வழிகாட்டி அல்ல. "
"உருமாற்றங்கள் மொழிபெயர்ப்பு, சுழற்சி மற்றும் அளவுகோலாகப் பயன்படுத்தப்படுகின்றன, எனவே "
"மெட்ரிக்குகள் உள்ளவர்களை எவ்வாறு பிரதிநிதித்துவப்படுத்துவது என்பதில் கவனம் செலுத்துவோம்."

msgid ""
"Most of this guide focuses on 2D, using :ref:`class_Transform2D` "
"and :ref:`class_Vector2`, but the way things work in 3D is very similar."
msgstr ""
"இந்த வழிகாட்டியின் பெரும்பகுதி 2D இல் கவனம் செலுத்துகிறது: ref: `class_transform2d` "
"மற்றும்: ref:` class_vector2`, ஆனால் 3D இல் விசயங்கள் செயல்படும் விதம் மிகவும் "
"ஒத்திருக்கிறது."

msgid ""
"As mentioned in the previous tutorial, it is important to remember that in "
"Godot, the Y axis points *down* in 2D. This is the opposite of how most "
"schools teach linear algebra, with the Y axis pointing up."
msgstr ""
"முந்தைய டுடோரியலில் குறிப்பிட்டுள்ளபடி, கோடோட்டில், ஒய் அச்சு * கீழே * 2d இல் உள்ளது "
"என்பதை நினைவில் கொள்வது தேவை. பெரும்பாலான பள்ளிகள் நேரியல் இயற்கணிதத்தை எவ்வாறு "
"கற்பிக்கின்றன என்பதற்கு இது நேர்மாறானது, ஒய் அச்சு சுட்டிக்காட்டுகிறது."

msgid ""
"The convention is that the X axis is red, the Y axis is green, and the Z "
"axis is blue. This tutorial is color-coded to match these conventions, but "
"we will also represent the origin vector with a blue color."
msgstr ""
"மாநாடு என்னவென்றால், ஃச் அச்சு சிவப்பு, ஒய் அச்சு பச்சை, மற்றும் சட் அச்சு நீலமானது. இந்த "
"டுடோரியல் இந்த மாநாடுகளுடன் பொருந்துவதற்கு வண்ண-குறியிடப்பட்டுள்ளது, ஆனால் நீல நிறத்துடன் "
"தோற்றம் திசையனையும் பிரதிநிதித்துவப்படுத்துவோம்."

msgid "Matrix components and the Identity matrix"
msgstr "மேட்ரிக்ச் கூறுகள் மற்றும் அடையாள அணி"

msgid ""
"The identity matrix represents a transform with no translation, no rotation, "
"and no scale. Let's start by looking at the identity matrix and how its "
"components relate to how it visually appears."
msgstr ""
"அடையாள மேட்ரிக்ச் மொழிபெயர்ப்பு, சுழற்சி இல்லை, அளவு இல்லாத ஒரு உருமாற்றத்தைக் "
"குறிக்கிறது. அடையாள மேட்ரிக்சைப் பார்ப்பதன் மூலம் ஆரம்பிக்கலாம் மற்றும் அதன் கூறுகள் எவ்வாறு "
"பார்வைக்கு தோன்றும் என்பதோடு தொடர்புடையது."

msgid ""
"Matrices have rows and columns, and a transformation matrix has specific "
"conventions on what each does."
msgstr ""
"மெட்ரிக்சில் வரிசைகள் மற்றும் நெடுவரிசைகள் உள்ளன, மேலும் ஒரு உருமாற்ற மேட்ரிக்ச் ஒவ்வொன்றும் "
"என்ன செய்கிறது என்பதில் குறிப்பிட்ட மரபுகளைக் கொண்டுள்ளது."

msgid ""
"In the image above, we can see that the red X vector is represented by the "
"first column of the matrix, and the green Y vector is likewise represented "
"by the second column. A change to the columns will change these vectors. We "
"will see how they can be manipulated in the next few examples."
msgstr ""
"மேலே உள்ள படத்தில், சிவப்பு ஃச் திசையன் மேட்ரிக்சின் முதல் நெடுவரிசையால் "
"குறிப்பிடப்படுவதைக் காணலாம், மேலும் பச்சை ஒய் திசையன் இதேபோல் இரண்டாவது நெடுவரிசையால் "
"குறிப்பிடப்படுகிறது. நெடுவரிசைகளில் மாற்றம் இந்த திசையன்களை மாற்றும். அடுத்த சில "
"எடுத்துக்காட்டுகளில் அவை எவ்வாறு கையாளப்படலாம் என்பதைப் பார்ப்போம்."

msgid ""
"You should not worry about manipulating rows directly, as we usually work "
"with columns. However, you can think of the rows of the matrix as showing "
"which vectors contribute to moving in a given direction."
msgstr ""
"நாங்கள் வழக்கமாக நெடுவரிசைகளுடன் பணிபுரிவதால், வரிசைகளை நேரடியாக கையாளுவதைப் பற்றி "
"நீங்கள் கவலைப்படக்கூடாது. இருப்பினும், ஒரு குறிப்பிட்ட திசையில் நகர்த்துவதற்கு எந்த "
"திசையன்கள் பங்களிக்கின்றன என்பதைக் காண்பிப்பதாக மேட்ரிக்சின் வரிசைகளைப் பற்றி நீங்கள் "
"நினைக்கலாம்."

msgid ""
"When we refer to a value such as ``t.x.y``, that's the Y component of the X "
"column vector. In other words, the bottom-left of the matrix. Similarly, "
"``t.x.x`` is top-left, ``t.y.x`` is top-right, and ``t.y.y`` is bottom-"
"right, where ``t`` is the Transform2D."
msgstr ""
"`` T.x.y`` போன்ற மதிப்பைக் குறிப்பிடும்போது, அதுதான் ஃச் நெடுவரிசை திசையனின் ஒய் "
"கூறு. வேறு வார்த்தைகளில் கூறுவதானால், மேட்ரிக்சின் கீழ்-இடது. இதேபோல், `` t.x.x`` `` "
"t.y.x`` என்பது மேல்-வலதுசாரி, மற்றும் `` t.y.y``` கீழ்-வலது, அங்கு `` t`` உருமாற்றம் "
"2 டி ஆகும்."

msgid "Scaling the transformation matrix"
msgstr "உருமாற்ற மேட்ரிக்சை அளவிடுதல்"

msgid ""
"Applying a scale is one of the easiest operations to understand. Let's start "
"by placing the Godot logo underneath our vectors so that we can visually see "
"the effects on an object:"
msgstr ""
"ஒரு அளவைப் பயன்படுத்துவது புரிந்து கொள்ள எளிதான செயல்பாடுகளில் ஒன்றாகும். கோடோட் "
"லோகோவை எங்கள் திசையன்களுக்கு அடியில் வைப்பதன் மூலம் ஆரம்பிக்கலாம், இதன்மூலம் ஒரு பொருளின் "
"விளைவுகளை நாம் பார்வைக்கு காணலாம்:"

msgid ""
"Now, to scale the matrix, all we need to do is multiply each component by "
"the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times "
"2 becomes 0, so we end up with this:"
msgstr ""
"இப்போது, மேட்ரிக்சை அளவிட, நாம் செய்ய வேண்டியதெல்லாம் ஒவ்வொரு கூறுகளையும் நாம் விரும்பும் "
"அளவால் பெருக்க வேண்டும். இதை 2. மூலம் அளவிடுவோம். 1 முறை 2 2 ஆகிறது, மற்றும் 0 மடங்கு "
"2 0 ஆகிறது, எனவே நாம் இதை முடிக்கிறோம்:"

msgid "To do this in code, we multiply each of the vectors:"
msgstr "குறியீட்டில் இதைச் செய்ய, ஒவ்வொரு திசையன்களையும் பெருக்குகிறோம்:"

msgid ""
"If we wanted to return it to its original scale, we can multiply each "
"component by 0.5. That's pretty much all there is to scaling a "
"transformation matrix."
msgstr ""
"அதை அதன் அசல் அளவிற்கு திருப்பித் தர விரும்பினால், ஒவ்வொரு கூறுகளையும் 0.5 ஆல் "
"பெருக்கலாம். ஒரு உருமாற்ற மேட்ரிக்சை அளவிடுவது அவ்வளவுதான்."

msgid ""
"To calculate the object's scale from an existing transformation matrix, you "
"can use ``length()`` on each of the column vectors."
msgstr ""
"ஏற்கனவே உள்ள உருமாற்ற மேட்ரிக்சிலிருந்து பொருளின் அளவைக் கணக்கிட, ஒவ்வொரு நெடுவரிசை "
"திசையன்களிலும் `` நீளம் () `` ஐப் பயன்படுத்தலாம்."

msgid ""
"In actual projects, you can use the ``scaled()`` method to perform scaling."
msgstr ""
"உண்மையான திட்டங்களில், அளவிடுதல் செய்ய `` அளவிடப்பட்ட () `` முறையைப் பயன்படுத்தலாம்."

msgid "Rotating the transformation matrix"
msgstr "உருமாற்ற மேட்ரிக்சை சுழற்றுகிறது"

msgid ""
"We'll start the same way as earlier, with the Godot logo underneath the "
"identity matrix:"
msgstr ""
"அடையாள மேட்ரிக்சின் அடியில் கோடோட் லோகோவுடன் முந்தையதைப் போலவே நாங்கள் தொடங்குவோம்:"

msgid ""
"As an example, let's say we want to rotate our Godot logo clockwise by 90 "
"degrees. Right now the X axis points right and the Y axis points down. If we "
"rotate these in our head, we would logically see that the new X axis should "
"point down and the new Y axis should point left."
msgstr ""
"உதாரணமாக, எங்கள் கோடோட் லோகோவை 90 டிகிரி கடிகார திசையில் சுழற்ற விரும்புகிறோம் என்று "
"சொல்லலாம். இப்போது ஃச் அச்சு வலதுபுறம் சுட்டிக்காட்டுகிறது மற்றும் ஒய் அச்சு "
"சுட்டிக்காட்டுகிறது. இவற்றை நம் தலையில் சுழற்றினால், புதிய ஃச் அச்சு கீழே சுட்டிக்காட்டப்பட "
"வேண்டும் என்பதையும், புதிய ஒய் அச்சு இடதுபுறத்தை சுட்டிக்காட்ட வேண்டும் என்பதையும் "
"தர்க்கரீதியாகக் காண்போம்."

msgid ""
"You can imagine that you grab both the Godot logo and its vectors, and then "
"spin it around the center. Wherever you finish spinning, the orientation of "
"the vectors determines what the matrix is."
msgstr ""
"நீங்கள் கோடோட் லோகோ மற்றும் அதன் திசையன்கள் இரண்டையும் பிடுங்குவதை நீங்கள் கற்பனை செய்யலாம், "
"பின்னர் அதை மையத்தைச் சுற்றி சுழற்றுங்கள். நீங்கள் சுழற்றுவதை எங்கு முடித்தாலும், "
"திசையன்களின் நோக்குநிலை மேட்ரிக்ச் என்றால் என்ன என்பதை தீர்மானிக்கிறது."

msgid ""
"We need to represent \"down\" and \"left\" in normal coordinates, so means "
"we'll set X to (0, 1) and Y to (-1, 0). These are also the values of "
"``Vector2.DOWN`` and ``Vector2.LEFT``. When we do this, we get the desired "
"result of rotating the object:"
msgstr ""
"சாதாரண ஆயக்கட்டுகளில் \"பேரூர்\" மற்றும் \"இடது\" ஆகியவற்றை நாம் பிரதிநிதித்துவப்படுத்த "
"வேண்டும், எனவே நாம் ஃச் க்கு (0, 1) மற்றும் ஒய் (-1, 0) வரை அமைப்போம். இவை `` "
"vector2.down`` மற்றும் `` vecter2.left`` ஆகியவற்றின் மதிப்புகளாகும். இதைச் "
"செய்யும்போது, பொருளைச் சுழற்றுவதன் விரும்பிய முடிவைப் பெறுகிறோம்:"

msgid ""
"If you have trouble understanding the above, try this exercise: Cut a square "
"of paper, draw X and Y vectors on top of it, place it on graph paper, then "
"rotate it and note the endpoints."
msgstr ""
"மேலே உள்ளவற்றைப் புரிந்துகொள்வதில் சிக்கல் இருந்தால், இந்த பயிற்சியை முயற்சிக்கவும்: ஒரு "
"சதுர காகிதத்தை வெட்டி, அதன் மேல் ஃச் மற்றும் ஒய் திசையன்களை வரைந்து, வரைபட காகிதத்தில் "
"வைக்கவும், பின்னர் அதை சுழற்றி இறுதிப் புள்ளிகளைக் கவனியுங்கள்."

msgid ""
"To perform rotation in code, we need to be able to calculate the values "
"programmatically. This image shows the formulas needed to calculate the "
"transformation matrix from a rotation angle. Don't worry if this part seems "
"complicated, I promise it's the hardest thing you need to know."
msgstr ""
"குறியீட்டில் சுழற்சியைச் செய்ய, மதிப்புகளை நிரல் முறையில் கணக்கிட முடியும். சுழற்சி "
"கோணத்திலிருந்து உருமாற்ற மேட்ரிக்சைக் கணக்கிட தேவையான சூத்திரங்களை இந்த படம் "
"காட்டுகிறது. இந்த பகுதி சிக்கலானதாகத் தோன்றினால் கவலைப்பட வேண்டாம், நீங்கள் தெரிந்து கொள்ள "
"வேண்டிய கடினமான சேதி இது என்று நான் உறுதியளிக்கிறேன்."

msgid ""
"Godot represents all rotations with radians, not degrees. A full turn is "
"`TAU` or `PI*2` radians, and a quarter turn of 90 degrees is `TAU/4` or `PI/"
"2` radians. Working with `TAU` usually results in more readable code."
msgstr ""
"கோடோட் அனைத்து சுழற்சிகளையும் ரேடியன்களுடன் குறிக்கிறது, டிகிரி அல்ல. ஒரு முழு "
"திருப்பம் `த au` அல்லது` பை*2` ரேடியன்கள், மற்றும் 90 டிகிரி கால் திருப்பம் `த au/4` "
"அல்லது` பை/2` ரேடியன்கள். `த au` உடன் பணிபுரிவது வழக்கமாக மேலும் படிக்கக்கூடிய "
"குறியீட்டில் விளைகிறது."

msgid ""
"Fun fact: In addition to Y being *down* in Godot, rotation is represented "
"clockwise. This means that all the math and trig functions behave the same "
"as a Y-is-up CCW system, since these differences \"cancel out\". You can "
"think of rotations in both systems being \"from X to Y\"."
msgstr ""
"வேடிக்கையான உண்மை: கோடோட்டில் ஒய் * கீழே * இருப்பதோடு கூடுதலாக, சுழற்சி கடிகார "
"திசையில் குறிப்பிடப்படுகிறது. இதன் பொருள் அனைத்து கணித மற்றும் தூண்டுதலும் ஒரு Y-IS-UP "
"CCW அமைப்பைப் போலவே செயல்படுகின்றன, ஏனெனில் இந்த வேறுபாடுகள் \"ரத்து செய்கின்றன\". "
"இரண்டு அமைப்புகளிலும் \"ஃச் முதல் ஒய் வரை\" சுழற்சிகள் பற்றி நீங்கள் நினைக்கலாம்."

msgid ""
"In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug "
"in a value of 0.5 to the formula above and evaluate to find what the actual "
"values should be:"
msgstr ""
"0.5 ரேடியன்களின் சுழற்சியைச் செய்ய (சுமார் 28.65 டிகிரி), மேலே உள்ள சூத்திரத்திற்கு "
"0.5 மதிப்பை செருகுவோம், உண்மையான மதிப்புகள் என்னவாக இருக்க வேண்டும் என்பதைக் கண்டறிய "
"மதிப்பீடு செய்கிறோம்:"

msgid "Here's how that would be done in code (place the script on a Node2D):"
msgstr ""
"குறியீட்டில் அது எவ்வாறு செய்யப்படும் என்பது இங்கே (ச்கிரிப்டை ஒரு Node2D இல் வைக்கவும்):"

msgid ""
"To calculate the object's rotation from an existing transformation matrix, "
"you can use ``atan2(t.x.y, t.x.x)``, where t is the Transform2D."
msgstr ""
"ஏற்கனவே உள்ள உருமாற்ற மேட்ரிக்சிலிருந்து பொருளின் சுழற்சியைக் கணக்கிட, நீங்கள் `` atan2 "
"(t.x.y, t.x.x) `` ஐப் பயன்படுத்தலாம், அங்கு t என்பது உருமாற்றம் 2 டி ஆகும்."

msgid ""
"In actual projects, you can use the ``rotated()`` method to perform "
"rotations."
msgstr ""
"உண்மையான திட்டங்களில், சுழற்சிகளைச் செய்ய `` சுழற்றப்பட்ட () `` முறையைப் பயன்படுத்தலாம்."

msgid "Basis of the transformation matrix"
msgstr "உருமாற்ற மேட்ரிக்சின் அடிப்படை"

msgid ""
"So far we have only been working with the ``x`` and ``y``, vectors, which "
"are in charge of representing rotation, scale, and/or shearing (advanced, "
"covered at the end). The X and Y vectors are together called the *basis* of "
"the transformation matrix. The terms \"basis\" and \"basis vectors\" are "
"important to know."
msgstr ""
"இதுவரை நாங்கள் சுழற்சி, அளவு மற்றும்/அல்லது வெட்டுதல் ஆகியவற்றைக் குறிக்கும் பொறுப்பில் "
"உள்ள `` x`` மற்றும் `` y`` உடன் மட்டுமே பணியாற்றி வருகிறோம் (மேம்பட்ட, முடிவில் "
"மூடப்பட்டிருக்கும்). உருமாற்ற மேட்ரிக்சின் * அடிப்படை * என அழைக்கப்படும் ஃச் மற்றும் ஒய் "
"திசையன்கள் ஒன்றாக உள்ளன. \"அடிப்படை\" மற்றும் \"அடிப்படை திசையன்கள்\" என்ற சொற்களை அறிய "
"முதன்மை."

msgid ""
"You might have noticed that :ref:`class_Transform2D` actually has "
"three :ref:`class_Vector2` values: ``x``, ``y``, and ``origin``. The "
"``origin`` value is not part of the basis, but it is part of the transform, "
"and we need it to represent position. From now on we'll keep track of the "
"origin vector in all examples. You can think of origin as another column, "
"but it's often better to think of it as completely separate."
msgstr ""
"இதை நீங்கள் கவனித்திருக்கலாம்: ref: `class_transform2d` உண்மையில் மூன்று: ref:` "
"class_vector2` மதிப்புகள்: `` x``, `` y``, மற்றும் `` தோற்றம்``. `` தோற்றம்`` மதிப்பு "
"அடிப்படையின் ஒரு பகுதியாக இல்லை, ஆனால் அது உருமாற்றத்தின் ஒரு பகுதியாகும், மேலும் "
"நிலையை குறிக்க நமக்கு இது தேவை. இனிமேல் எல்லா எடுத்துக்காட்டுகளிலும் தோற்றம் திசையனைக் "
"கண்காணிப்போம். தோற்றத்தை மற்றொரு நெடுவரிசையாக நீங்கள் நினைக்கலாம், ஆனால் அதை முற்றிலும் "
"தனித்தனியாக நினைப்பது நல்லது."

msgid ""
"Note that in 3D, Godot has a separate :ref:`class_Basis` structure for "
"holding the three :ref:`class_Vector3` values of the basis, since the code "
"can get complex and it makes sense to separate it "
"from :ref:`class_Transform3D` (which is composed of one :ref:`class_Basis` "
"and one extra :ref:`class_Vector3` for the origin)."
msgstr ""
"3D இல், கோடோட் ஒரு தனி: ref: `class_basis` மூன்றைப் பிடிப்பதற்கான கட்டமைப்பு: ref:` "
"class_vector3` அடிப்படையின் மதிப்புகள், ஏனெனில் குறியீடு சிக்கலானதாகிவிடும், மேலும் "
"அதைப் பிரிப்பது அர்த்தமுள்ளதாக இருக்கும்: ref: `class_transform3d `(இது ஒன்றைக் "
"கொண்டது: ref:` class_basis` மற்றும் ஒரு கூடுதல்: Ref: `class_vector3` "
"தோற்றத்திற்கு)."

msgid "Translating the transformation matrix"
msgstr "உருமாற்ற மேட்ரிக்சை மொழிபெயர்க்கிறது"

msgid ""
"Changing the ``origin`` vector is called *translating* the transformation "
"matrix. Translating is basically a technical term for \"moving\" the object, "
"but it explicitly does not involve any rotation."
msgstr ""
"`` தோற்றம்` `திசையனை மாற்றுவது * உருமாற்ற மேட்ரிக்சை மொழிபெயர்க்கிறது. மொழிபெயர்ப்பது "
"அடிப்படையில் பொருளை \"நகர்த்துவதற்கான\" ஒரு தொழில்நுட்ப சொல், ஆனால் அது வெளிப்படையாக "
"எந்த சுழற்சியையும் உள்ளடக்குவதில்லை."

msgid ""
"Let's work through an example to help understand this. We will start with "
"the identity transform like last time, except we will keep track of the "
"origin vector this time."
msgstr ""
"இதைப் புரிந்துகொள்ள உதவ ஒரு எடுத்துக்காட்டு மூலம் செயல்படுவோம். கடைசி நேரத்தைப் போலவே "
"அடையாள மாற்றத்துடன் தொடங்குவோம், தவிர இந்த நேரத்தில் தோற்றம் திசையனைக் கண்காணிப்போம்."

msgid ""
"If we want to move the object to a position of (1, 2), we need to set its "
"``origin`` vector to (1, 2):"
msgstr ""
"நாம் பொருளை (1, 2) நிலைக்கு நகர்த்த விரும்பினால், அதன் `` தோற்றம்` `திசையனை (1, 2) என "
"அமைக்க வேண்டும்:"

msgid ""
"There is also a ``translated_local()`` method, which performs a different "
"operation to adding or changing ``origin`` directly. The "
"``translated_local()`` method will translate the object *relative to its own "
"rotation*. For example, an object rotated 90 degrees clockwise will move to "
"the right when ``translated_local()`` with ``Vector2.UP``. To translate "
"*relative to the global/parent frame* use ``translated()`` instead."
msgstr ""
"`` மொழிபெயர்க்கப்பட்ட_லோகல் () `` முறையும் உள்ளது, இது `` தோற்றம்`` நேரடியாகச் "
"சேர்ப்பதற்கு அல்லது மாற்றுவதற்கு வேறுபட்ட செயல்பாட்டைச் செய்கிறது. `` "
"மொழிபெயர்க்கப்பட்ட_லோகல் () `` முறை அதன் சொந்த சுழற்சியுடன் தொடர்புடைய பொருளை "
"*மொழிபெயர்க்கும் *. எடுத்துக்காட்டாக, 90 டிகிரி கடிகார திசையில் சுழற்றப்பட்ட ஒரு பொருள் "
"`` மொழிபெயர்க்கப்பட்ட_லோகல் () `` `vector2.up`` உடன் வலதுபுறமாக நகரும். உலகளாவிய/"
"பெற்றோர் சட்டத்துடன் தொடர்புடைய * மொழிபெயர்க்க * அதற்கு பதிலாக `` மொழிபெயர்க்கப்பட்ட () "
"`` ஐப் பயன்படுத்தவும்."

msgid ""
"Godot's 2D uses coordinates based on pixels, so in actual projects you will "
"want to translate by hundreds of units."
msgstr ""
"கோடோட்டின் 2 டி பிக்சல்களை அடிப்படையாகக் கொண்ட ஒருங்கிணைப்புகளைப் பயன்படுத்துகிறது, எனவே "
"உண்மையான திட்டங்களில் நீங்கள் நூற்றுக்கணக்கான அலகுகளால் மொழிபெயர்க்க விரும்புவீர்கள்."

msgid "Putting it all together"
msgstr "அதையெல்லாம் ஒன்றாக இணைப்பது"

msgid ""
"We're going to apply everything we mentioned so far onto one transform. To "
"follow along, create a project with a Sprite2D node and use the Godot logo "
"for the texture resource."
msgstr ""
"நாங்கள் இதுவரை குறிப்பிட்ட அனைத்தையும் ஒரு உருமாற்றத்தில் பயன்படுத்தப் போகிறோம். பின்தொடர, "
"ஒரு ச்ப்ரைட் 2 டி முனையுடன் ஒரு திட்டத்தை உருவாக்கி, அமைப்பு வளத்திற்கு கோடோட் லோகோவைப் "
"பயன்படுத்தவும்."

msgid ""
"Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. "
"I've posted a screenshot, and the code to reproduce it, but I encourage you "
"to try and reproduce the screenshot without looking at the code!"
msgstr ""
"மொழிபெயர்ப்பை (350, 150) என அமைப்போம், -0.5 ராட் மூலம் சுழற்றுங்கள், மற்றும் அளவைக் "
"காட்டலாம். குறியீடு!"

msgid "Shearing the transformation matrix (advanced)"
msgstr "உருமாற்ற மேட்ரிக்சை வெட்டுதல் (மேம்பட்டது)"

msgid ""
"If you are only looking for how to *use* transformation matrices, feel free "
"to skip this section of the tutorial. This section explores an uncommonly "
"used aspect of transformation matrices for the purpose of building an "
"understanding of them."
msgstr ""
"உருமாற்ற மெட்ரிக்குகளை * பயன்படுத்துவது * எவ்வாறு பயன்படுத்துவது என்பதை மட்டுமே நீங்கள் "
"தேடுகிறீர்களானால், டுடோரியலின் இந்த பகுதியைத் தவிர்க்க தயங்க. இந்த பிரிவு அவற்றைப் பற்றிய "
"புரிதலை உருவாக்கும் நோக்கத்திற்காக உருமாற்ற மெட்ரிக்குகளின் அசாதாரணமாகப் பயன்படுத்தப்படும் "
"அம்சத்தை ஆராய்கிறது."

msgid "Node2D provides a shearing property out of the box."
msgstr "Node2D பெட்டியின் வெளியே ஒரு வெட்டும் சொத்தை வழங்குகிறது."

msgid ""
"You may have noticed that a transform has more degrees of freedom than the "
"combination of the above actions. The basis of a 2D transformation matrix "
"has four total numbers in two :ref:`class_Vector2` values, while a rotation "
"value and a Vector2 for scale only has 3 numbers. The high-level concept for "
"the missing degree of freedom is called *shearing*."
msgstr ""
"மேற்கண்ட செயல்களின் கலவையை விட ஒரு உருமாற்றம் அதிக அளவிலான சுதந்திரத்தைக் கொண்டுள்ளது "
"என்பதை நீங்கள் கவனித்திருக்கலாம். 2 டி உருமாற்ற மேட்ரிக்சின் அடிப்படை இரண்டில் நான்கு மொத்த "
"எண்களைக் கொண்டுள்ளது: ref: `class_vector2` மதிப்புகள், அதே நேரத்தில் ஒரு சுழற்சி "
"மதிப்பு மற்றும் அளவிற்கான திசையன் 2 ஆகியவை 3 எண்களைக் கொண்டுள்ளன. காணாமல் போன அளவிலான "
"சுதந்திரத்திற்கான உயர் மட்ட கருத்து *வெட்டு *என்று அழைக்கப்படுகிறது."

msgid ""
"Normally, you will always have the basis vectors perpendicular to each "
"other. However, shearing can be useful in some situations, and understanding "
"shearing helps you understand how transforms work."
msgstr ""
"பொதுவாக, நீங்கள் எப்போதும் ஒருவருக்கொருவர் செங்குத்தாக அடிப்படை திசையன்களைக் "
"கொண்டிருப்பீர்கள். இருப்பினும், சில சூழ்நிலைகளில் வெட்டுதல் பயனுள்ளதாக இருக்கும், மேலும் "
"வெட்டுதல் புரிந்துகொள்வது மாற்றங்கள் எவ்வாறு செயல்படுகின்றன என்பதைப் புரிந்துகொள்ள "
"உதவுகிறது."

msgid ""
"To show you visually how it will look, let's overlay a grid onto the Godot "
"logo:"
msgstr ""
"இது எப்படி இருக்கும் என்பதை நீங்கள் பார்வைக்கு காண்பிக்க, கோடோட் லோகோவில் ஒரு கட்டத்தை "
"மேலடுக்கு செய்வோம்:"

msgid ""
"Each point on this grid is obtained by adding the basis vectors together. "
"The bottom-right corner is X + Y, while the top-right corner is X - Y. If we "
"change the basis vectors, the entire grid moves with it, as the grid is "
"composed of the basis vectors. All lines on the grid that are currently "
"parallel will remain parallel no matter what changes we make to the basis "
"vectors."
msgstr ""
"இந்த கட்டத்தின் ஒவ்வொரு புள்ளியும் அடிப்படை திசையன்களை ஒன்றாகச் சேர்ப்பதன் மூலம் "
"பெறப்படுகிறது. கீழ்-வலது மூலையில் ஃச் + ஒய், மேல்-வலது மூலையில் எக்ச்-ஒய் ஆகும். நாம் "
"அடிப்படை திசையன்களை மாற்றினால், கட்டம் அடிப்படை திசையன்களால் ஆனதால், முழு கட்டமும் "
"அதனுடன் நகர்கிறது. தற்போது இணையாக இருக்கும் கட்டத்தில் உள்ள அனைத்து வரிகளும் அடிப்படை "
"திசையன்களில் என்ன மாற்றங்களைச் செய்தாலும் இணையாக இருக்கும்."

msgid "As an example, let's set Y to (1, 1):"
msgstr "உதாரணமாக, ஒய் ஐ (1, 1) அமைப்போம்:"

msgid ""
"You can't set the raw values of a Transform2D in the editor, so you *must* "
"use code if you want to shear the object."
msgstr ""
"எடிட்டரில் ஒரு டிரான்ச்ஃபார்ம் 2 டி இன் மூல மதிப்புகளை நீங்கள் அமைக்க முடியாது, எனவே "
"நீங்கள் பொருளை வெட்ட விரும்பினால் குறியீட்டைப் பயன்படுத்த வேண்டும்."

msgid ""
"Due to the vectors no longer being perpendicular, the object has been "
"sheared. The bottom-center of the grid, which is (0, 1) relative to itself, "
"is now located at a world position of (1, 1)."
msgstr ""
"திசையன்கள் இனி செங்குத்தாக இல்லாததால், பொருள் வெட்டப்பட்டுள்ளது. கட்டத்தின் கீழ் மையமானது, "
"(0, 1) தன்னுடன் தொடர்புடையது, இப்போது (1, 1) உலக நிலையில் அமைந்துள்ளது."

msgid ""
"The intra-object coordinates are called UV coordinates in textures, so let's "
"borrow that terminology for here. To find the world position from a relative "
"position, the formula is U * X + V * Y, where U and V are numbers and X and "
"Y are the basis vectors."
msgstr ""
"இன்ட்ரா-ஆப்செக்ட் ஆயத்தொகுதிகள் புற ஊதா ஆயத்தொலைவுகள் என்று அழைக்கப்படுகின்றன, எனவே அந்த "
"சொற்களை இங்கே கடன் வாங்குவோம். உறவினர் நிலையில் இருந்து உலக நிலையை கண்டுபிடிக்க, தேற்றம் "
"உ * ஃச் + v * ஒய் ஆகும், அங்கு உ மற்றும் v எண்கள் மற்றும் ஃச் மற்றும் ஒய் ஆகியவை அடிப்படை "
"திசையன்கள்."

msgid ""
"The bottom-right corner of the grid, which is always at the UV position of "
"(1, 1), is at the world position of (2, 1), which is calculated from X*1 + "
"Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up "
"with our observation of where the bottom-right corner of the image is."
msgstr ""
"(1, 1) இன் புற ஊதா நிலையில் இருக்கும் கட்டத்தின் கீழ்-வலது மூலையில் (2, 1) உலக நிலையில் "
"உள்ளது, இது x*1 + y*1 இலிருந்து கணக்கிடப்படுகிறது, அதாவது (அதாவது ( 1, 0) + (1, "
"1), அல்லது (1 + 1, 0 + 1), அல்லது (2, 1). படத்தின் கீழ்-வலது மூலையில் எங்கே "
"இருக்கிறது என்பதை எங்கள் கவனிப்புடன் இது பொருந்துகிறது."

msgid ""
"Similarly, the top-right corner of the grid, which is always at the UV "
"position of (1, -1), is at the world position of (0, -1), which is "
"calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or "
"(0, -1). This matches up with our observation of where the top-right corner "
"of the image is."
msgstr ""
"இதேபோல், (1, -1) இன் புற ஊதா நிலையில் இருக்கும் கட்டத்தின் மேல் -வலது மூலையில் (0, -1) "
"உலக நிலையில் உள்ளது, இது x*1 + y* -இலிருந்து கணக்கிடப்படுகிறது 1, இது (1, 0) - "
"(1, 1), அல்லது (1 - 1, 0 - 1), அல்லது (0, -1). படத்தின் மேல்-வலது மூலையில் எங்கே "
"இருக்கிறது என்பதை இது கவனிப்பதன் மூலம் இது பொருந்துகிறது."

msgid ""
"Hopefully you now fully understand how a transformation matrix affects the "
"object, and the relationship between the basis vectors and how the object's "
"\"UV\" or \"intra-coordinates\" have their world position changed."
msgstr ""
"ஒரு உருமாற்ற மேட்ரிக்ச் பொருளை எவ்வாறு பாதிக்கிறது என்பதையும், அடிப்படை திசையன்களுக்கு "
"இடையிலான உறவு மற்றும் பொருளின் \"புற ஊதா\" அல்லது \"உள்-ஒருங்கிணைப்புகள்\" அவற்றின் "
"உலக நிலையை எவ்வாறு மாற்றியுள்ளன என்பதையும் நீங்கள் இப்போது முழுமையாக புரிந்துகொள்கிறீர்கள்."

msgid ""
"In Godot, all transform math is done relative to the parent node. When we "
"refer to \"world position\", that would be relative to the node's parent "
"instead, if the node had a parent."
msgstr ""
"கோடோட்டில், அனைத்து மாற்றும் கணிதமும் பெற்றோர் முனையுடன் தொடர்புடையது. \"உலக நிலை\" "
"என்று நாம் குறிப்பிடும்போது, அது ஒரு பெற்றோரைக் கொண்டிருந்தால், அது முனையின் பெற்றோருடன் "
"தொடர்புடையதாக இருக்கும்."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about linear transformations: https://www.youtube.com/watch?"
"v=kYB8IZa5AuE"
msgstr ""
"கூடுதல் விளக்கத்தை நீங்கள் விரும்பினால், நேரியல் மாற்றங்களைப் பற்றிய 3Blue1Brown இன் சிறந்த "
"வீடியோவைப் பார்க்க வேண்டும்: https://www.youtube.com/watch?v=kyb8iza5aue"

msgid "Practical applications of transforms"
msgstr "உருமாற்றங்களின் நடைமுறை பயன்பாடுகள்"

msgid ""
"In actual projects, you will usually be working with transforms inside "
"transforms by having multiple :ref:`class_Node2D` or :ref:`class_Node3D` "
"nodes parented to each other."
msgstr ""
"உண்மையான திட்டங்களில், நீங்கள் வழக்கமாக பலவற்றைக் கொண்டு உருமாறும் மாற்றங்களுடன் "
"பணிபுரிவீர்கள்: ref: `class_node2d` அல்லது: ref:` class_node3d` முனைகள் "
"ஒருவருக்கொருவர் பெற்றோர்."

msgid ""
"However, it's useful to understand how to manually calculate the values we "
"need. We will go over how you could use :ref:`class_Transform2D` "
"or :ref:`class_Transform3D` to manually calculate transforms of nodes."
msgstr ""
"இருப்பினும், நமக்குத் தேவையான மதிப்புகளை எவ்வாறு கைமுறையாக கணக்கிடுவது என்பதைப் "
"புரிந்துகொள்வது பயனுள்ளதாக இருக்கும். நீங்கள் எவ்வாறு பயன்படுத்தலாம் என்று நாங்கள் செல்வோம்: "
"ref: `class_transform2d` அல்லது: ref:` class_transform3d` முனைகளின் மாற்றங்களை "
"கைமுறையாகக் கணக்கிட."

msgid "Converting positions between transforms"
msgstr "உருமாற்றங்களுக்கு இடையில் நிலைகளை மாற்றுதல்"

msgid ""
"There are many cases where you'd want to convert a position in and out of a "
"transform. For example, if you have a position relative to the player and "
"would like to find the world (parent-relative) position, or if you have a "
"world position and want to know where it is relative to the player."
msgstr ""
"ஒரு மாற்றத்திற்கு உள்ளேயும் வெளியேயும் ஒரு நிலையை மாற்ற விரும்பும் பல சந்தர்ப்பங்கள் உள்ளன. "
"எடுத்துக்காட்டாக, நீங்கள் வீரருடன் தொடர்புடைய ஒரு நிலை இருந்தால், உலகத்தை (பெற்றோர்-"
"தொடர்புடைய) நிலையைக் கண்டுபிடிக்க விரும்பினால், அல்லது உங்களுக்கு உலக நிலை இருந்தால், "
"அது வீரருடன் தொடர்புடையது எங்குள்ளது என்பதை அறிய விரும்பினால்."

msgid ""
"We can find what a vector relative to the player would be defined in world "
"space as using the ``*`` operator:"
msgstr ""
"``*`` ஆபரேட்டரைப் பயன்படுத்துவதால், பிளேயருடன் தொடர்புடைய ஒரு திசையன் உலக இடத்தில் "
"வரையறுக்கப்படும் என்பதை நாம் காணலாம்:"

msgid ""
"And we can use the ``*`` operator in the opposite order to find a what world "
"space position would be if it was defined relative to the player:"
msgstr ""
"பிளேயருடன் ஒப்பிடும்போது வரையறுக்கப்பட்டால், உலக விண்வெளி நிலை என்னவாக இருக்கும் என்பதைக் "
"கண்டறிய எதிர் வரிசையில் ``*`` ஆபரேட்டரைப் பயன்படுத்தலாம்:"

msgid ""
"If you know in advance that the transform is positioned at (0, 0), you can "
"use the \"basis_xform\" or \"basis_xform_inv\" methods instead, which skip "
"dealing with translation."
msgstr ""
"உருமாற்றம் (0, 0) இல் நிலைநிறுத்தப்பட்டுள்ளது என்பது உங்களுக்குத் தெரிந்தால், அதற்கு "
"பதிலாக \"basis_xform\" அல்லது \"basy_xform_inv\" முறைகளைப் பயன்படுத்தலாம், இது "
"மொழிபெயர்ப்பைக் கையாள்வதைத் தவிர்க்கிறது."

msgid "Moving an object relative to itself"
msgstr "தன்னுடன் தொடர்புடைய ஒரு பொருளை நகர்த்துவது"

msgid ""
"A common operation, especially in 3D games, is to move an object relative to "
"itself. For example, in first-person shooter games, you would want the "
"character to move forward (-Z axis) when you press :kbd:`W`."
msgstr ""
"ஒரு பொதுவான செயல்பாடு, குறிப்பாக 3D விளையாட்டுகளில், ஒரு பொருளை தன்னுடன் தொடர்புடைய "
"நகர்த்துவதாகும். எடுத்துக்காட்டாக, முதல் நபர் துப்பாக்கி சுடும் விளையாட்டுகளில், நீங்கள் "
"அழுத்தும் போது பாத்திரம் முன்னேற வேண்டும் (-z அச்சு): kbd: `w`."

msgid ""
"Since the basis vectors are the orientation relative to the parent, and the "
"origin vector is the position relative to the parent, we can add multiples "
"of the basis vectors to move an object relative to itself."
msgstr ""
"அடிப்படை திசையன்கள் பெற்றோருடன் தொடர்புடைய நோக்குநிலை என்பதால், மற்றும் ஆரிசின் திசையன் "
"பெற்றோருடன் தொடர்புடைய நிலை என்பதால், தன்னுடன் தொடர்புடைய ஒரு பொருளை நகர்த்த அடிப்படை "
"திசையன்களின் மடங்குகளை நாம் சேர்க்கலாம்."

msgid "This code moves an object 100 units to its own right:"
msgstr "இந்த குறியீடு ஒரு பொருளை 100 அலகுகள் அதன் சொந்த உரிமைக்கு நகர்த்துகிறது:"

msgid "For moving in 3D, you would need to replace \"x\" with \"basis.x\"."
msgstr "3D இல் நகர்த்த, நீங்கள் \"ஃச்\" ஐ \"basy.x\" உடன் மாற்ற வேண்டும்."

msgid ""
"In actual projects, you can use ``translate_object_local`` in 3D or "
"``move_local_x`` and ``move_local_y`` in 2D to do this."
msgstr ""
"உண்மையான திட்டங்களில், இதைச் செய்ய நீங்கள் 3D அல்லது `move_local_x`` மற்றும்` "
"move_local_y`` ஆகியவற்றில் `` மொழிபெயர்ப்பு_ஆப்செக்ட்_லோகல்` ஐப் பயன்படுத்தலாம்."

msgid "Applying transforms onto transforms"
msgstr "உருமாற்றங்களில் மாற்றங்களைப் பயன்படுத்துதல்"

msgid ""
"One of the most important things to know about transforms is how you can use "
"several of them together. A parent node's transform affects all of its "
"children. Let's dissect an example."
msgstr ""
"உருமாற்றங்களைப் பற்றி தெரிந்து கொள்ள வேண்டிய மிக முக்கியமான விசயங்களில் ஒன்று, அவற்றில் "
"பலவற்றை நீங்கள் எவ்வாறு ஒன்றாகப் பயன்படுத்தலாம் என்பதுதான். பெற்றோர் முனையின் மாற்றம் அதன் "
"குழந்தைகள் அனைவரையும் பாதிக்கிறது. ஒரு உதாரணத்தை பிரிப்போம்."

msgid ""
"In this image, the child node has a \"2\" after the component names to "
"distinguish them from the parent node. It might look a bit overwhelming with "
"so many numbers, but remember that each number is displayed twice (next to "
"the arrows and also in the matrices), and that almost half of the numbers "
"are zero."
msgstr ""
"இந்த படத்தில், குழந்தை முனை பெற்றோர் முனையிலிருந்து வேறுபடுவதற்கு கூறு பெயர்களுக்குப் "
"பிறகு \"2\" உள்ளது. இது பல எண்களுடன் சற்று அதிகமாகத் தோன்றலாம், ஆனால் ஒவ்வொரு எண்ணும் "
"இரண்டு முறை (அம்புகளுக்கு அடுத்தது மற்றும் மெட்ரிக்குகளிலும்) காட்டப்படும் என்பதை நினைவில் "
"கொள்ளுங்கள், மேலும் எண்களில் கிட்டத்தட்ட பாதி பூச்சியமானது என்பதை நினைவில் கொள்ளுங்கள்."

msgid ""
"The only transformations going on here are that the parent node has been "
"given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and "
"both nodes have been given positions."
msgstr ""
"இங்கு நடக்கும் ஒரே மாற்றங்கள் என்னவென்றால், பெற்றோர் முனைக்கு (2, 1) அளவிடப்பட்டுள்ளது, "
"குழந்தைக்கு (0.5, 0.5) அளவு வழங்கப்பட்டுள்ளது, மேலும் இரண்டு முனைகளுக்கும் பதவிகள் "
"வழங்கப்பட்டுள்ளன."

msgid ""
"All child transformations are affected by the parent transformations. The "
"child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio "
"square, and it is, but only relative to the parent. The child's X vector "
"ends up being (1, 0) in world space, because it is scaled by the parent's "
"basis vectors. Similarly, the child node's ``origin`` vector is set to (1, "
"1), but this actually moves it (2, 1) in world space, due to the parent "
"node's basis vectors."
msgstr ""
"அனைத்து குழந்தை மாற்றங்களும் பெற்றோர் மாற்றங்களால் பாதிக்கப்படுகின்றன. குழந்தைக்கு (0.5, "
"0.5) அளவைக் கொண்டுள்ளது, எனவே இது 1: 1 விகித சதுரமாக இருக்கும் என்று நீங்கள் "
"எதிர்பார்க்கலாம், ஆனால் அது பெற்றோருடன் மட்டுமே தொடர்புடையது. குழந்தையின் ஃச் திசையன் உலக "
"இடைவெளியில் (1, 0) முடிவடைகிறது, ஏனெனில் இது பெற்றோரின் அடிப்படை திசையன்களால் "
"அளவிடப்படுகிறது. இதேபோல், குழந்தை முனையின் `` தோற்றம்` `திசையன் (1, 1) "
"அமைக்கப்பட்டுள்ளது, ஆனால் இது உண்மையில் பெற்றோர் முனையின் அடிப்படை திசையன்கள் காரணமாக உலக "
"இடைவெளியில் (2, 1) நகரும்."

msgid ""
"To calculate a child transform's world space transform manually, this is the "
"code we would use:"
msgstr ""
"ஒரு குழந்தை உருமாற்றத்தின் உலக இடத்தை கைமுறையாகக் கணக்கிட, இது நாம் பயன்படுத்தும் "
"குறியீடு:"

msgid ""
"In actual projects, we can find the world transform of the child by applying "
"one transform onto another using the ``*`` operator:"
msgstr ""
"உண்மையான திட்டங்களில், ``*`` ஆபரேட்டரைப் பயன்படுத்தி ஒரு உருமாற்றத்தை இன்னொருவருக்கு "
"பயன்படுத்துவதன் மூலம் குழந்தையின் உலக மாற்றத்தைக் காணலாம்:"

msgid "When multiplying matrices, order matters! Don't mix them up."
msgstr "மெட்ரிக்குகளை பெருக்கும்போது, ஆர்டர் விசயங்கள்! அவற்றை கலக்க வேண்டாம்."

msgid "Lastly, applying the identity transform will always do nothing."
msgstr "கடைசியாக, அடையாள மாற்றத்தைப் பயன்படுத்துவது எப்போதும் எதுவும் செய்யாது."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about matrix composition: https://www.youtube.com/watch?"
"v=XkY2DOUCWMU"
msgstr ""
"கூடுதல் விளக்கத்தை நீங்கள் விரும்பினால், மேட்ரிக்ச் கலவையைப் பற்றிய 3Blue1Brown இன் சிறந்த "
"வீடியோவைப் பார்க்க வேண்டும்: https://www.youtube.com/watch?v=xky2doucwmu"

msgid "Inverting a transformation matrix"
msgstr "மாற்றும் மேட்ரிக்சை தலைகீழ்"

msgid ""
"The \"affine_inverse\" function returns a transform that \"undoes\" the "
"previous transform. This can be useful in some situations. Let's take a look "
"at a few examples."
msgstr ""
"\"Affine_Inverse\" செயல்பாடு முந்தைய உருமாற்றத்தை \"செயல்தவிர்க்கிறது\" என்ற மாற்றத்தை "
"வழங்குகிறது. சில சூழ்நிலைகளில் இது பயனுள்ளதாக இருக்கும். சில எடுத்துக்காட்டுகளைப் "
"பார்ப்போம்."

msgid ""
"Multiplying an inverse transform by the normal transform undoes all "
"transformations:"
msgstr ""
"இயல்பான மாற்றத்தால் ஒரு தலைகீழ் மாற்றத்தை பெருக்கினால் அனைத்து மாற்றங்களையும் "
"செயல்தவிர்க்கவும்:"

msgid ""
"Transforming a position by a transform and its inverse results in the same "
"position:"
msgstr ""
"ஒரு நிலைப்பாட்டால் ஒரு நிலையை மாற்றுவது மற்றும் அதன் தலைகீழ் முடிவுகள் அதே நிலையில்:"

msgid "How does it all work in 3D?"
msgstr "இது 3D இல் எவ்வாறு செயல்படுகிறது?"

msgid ""
"One of the great things about transformation matrices is that they work very "
"similarly between 2D and 3D transformations. All the code and formulas used "
"above for 2D work the same in 3D, with 3 exceptions: the addition of a third "
"axis, that each axis is of type :ref:`class_Vector3`, and also that Godot "
"stores the :ref:`class_Basis` separately from the :ref:`class_Transform3D`, "
"since the math can get complex and it makes sense to separate it."
msgstr ""
"உருமாற்ற மெட்ரிக்குகள் பற்றிய ஒரு பெரிய சேதி என்னவென்றால், அவை 2 டி மற்றும் 3 டி "
"மாற்றங்களுக்கு இடையில் மிகவும் ஒத்தவை. 3D இல் 2D வேலைக்கு மேலே பயன்படுத்தப்படும் அனைத்து "
"குறியீடு மற்றும் சூத்திரங்களும் 3 விதிவிலக்குகளுடன்: மூன்றாவது அச்சைச் சேர்ப்பது, ஒவ்வொரு "
"அச்சும் வகை: ref: `class_vector3`, மேலும் கோடோட் சேமிக்கிறது: Ref:` class_basis "
"`தனித்தனியாக: ref:` class_transform3d`, கணிதம் சிக்கலானதாக இருக்கக்கூடும், மேலும் "
"அதைப் பிரிப்பது அர்த்தமுள்ளதாக இருக்கும்."

msgid ""
"All of the concepts for how translation, rotation, scale, and shearing work "
"in 3D are all the same compared to 2D. To scale, we take each component and "
"multiply it; to rotate, we change where each basis vector is pointing; to "
"translate, we manipulate the origin; and to shear, we change the basis "
"vectors to be non-perpendicular."
msgstr ""
"3D இல் மொழிபெயர்ப்பு, சுழற்சி, அளவுகோல் மற்றும் வெட்டுதல் ஆகியவை எவ்வாறு ஒரே "
"மாதிரியானவை என்பதற்கான அனைத்து கருத்துகளும் 2D உடன் ஒப்பிடும்போது ஒரே மாதிரியானவை. "
"அளவிட, நாங்கள் ஒவ்வொரு கூறுகளையும் எடுத்து அதைப் பெருக்குகிறோம்; சுழற்ற, ஒவ்வொரு "
"அடிப்படை திசையன் சுட்டிக்காட்டும் இடத்தை மாற்றுகிறோம்; மொழிபெயர்க்க, நாங்கள் தோற்றத்தை "
"கையாளுகிறோம்; வெட்டுவதற்கு, அடிப்படை திசையன்களை எதிரொலிக்காததாக மாற்றுகிறோம்."

msgid ""
"If you would like, it's a good idea to play around with transforms to get an "
"understanding of how they work. Godot allows you to edit 3D transform "
"matrices directly from the inspector. You can download this project which "
"has colored lines and cubes to help visualize the :ref:`class_Basis` vectors "
"and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-"
"projects/tree/master/misc/matrix_transform"
msgstr ""
"நீங்கள் விரும்பினால், அவை எவ்வாறு செயல்படுகின்றன என்பதைப் புரிந்துகொள்ள மாற்றங்களுடன் "
"விளையாடுவது நல்லது. 3D உருமாற்ற மெட்ரிக்குகளை இன்ச்பெக்டரிடமிருந்து நேரடியாக திருத்த "
"கோடோட் உங்களை அனுமதிக்கிறது. காட்சிப்படுத்த உதவும் வண்ண கோடுகள் மற்றும் க்யூப்சைக் கொண்ட "
"இந்த திட்டத்தை நீங்கள் பதிவிறக்கம் செய்யலாம்: re: `class_basis` திசையன்கள் மற்றும் 2d "
"மற்றும் 3d இரண்டிலும் தோற்றம்: https://github.com/godotengine/godot-demo-projects/"
"tree/master /misc/மேட்ரிக்ச்_ டிரான்ச்ஃபார்ம்"

msgid ""
"You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. "
"This may be changed in a future release of Godot."
msgstr ""
"கோடோட் 4.0 இன் இன்ச்பெக்டரில் நேரடியாக NODE2D இன் உருமாற்ற மேட்ரிக்சைத் திருத்த "
"முடியாது. கோடோட்டின் எதிர்கால வெளியீட்டில் இது மாற்றப்படலாம்."

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video about 3D linear transformations: https://www.youtube.com/"
"watch?v=rHLEWRxRGiM"
msgstr ""
"கூடுதல் விளக்கத்தை நீங்கள் விரும்பினால், 3D நேரியல் மாற்றங்களைப் பற்றிய 3Blue1Brown இன் "
"சிறந்த வீடியோவைப் பார்க்க வேண்டும்: https://www.youtube.com/watch?v=rhlewrxrgim"

msgid "Representing rotation in 3D (advanced)"
msgstr "3D (மேம்பட்ட) இல் சுழற்சியைக் குறிக்கும்"

msgid ""
"The biggest difference between 2D and 3D transformation matrices is how you "
"represent rotation by itself without the basis vectors."
msgstr ""
"2D மற்றும் 3D உருமாற்ற மெட்ரிக்குகளுக்கு இடையிலான மிகப்பெரிய வேறுபாடு என்னவென்றால், "
"அடிப்படை திசையன்கள் இல்லாமல் நீங்கள் சுழற்சியை எவ்வாறு பிரதிநிதித்துவப்படுத்துகிறீர்கள் "
"என்பதுதான்."

msgid ""
"With 2D, we have an easy way (atan2) to switch between a transformation "
"matrix and an angle. In 3D, rotation is too complex to represent as one "
"number. There is something called Euler angles, which can represent "
"rotations as a set of 3 numbers, however, they are limited and not very "
"useful, except for trivial cases."
msgstr ""
"2D உடன், ஒரு உருமாற்ற மேட்ரிக்ச் மற்றும் ஒரு கோணத்திற்கு இடையில் மாற எங்களுக்கு எளிதான "
"வழி (ATAN2) உள்ளது. 3D இல், சுழற்சி ஒரு எண்ணாகக் குறிக்க மிகவும் சிக்கலானது. யூலர் "
"கோணங்கள் என்று ஒன்று உள்ளது, இது சுழற்சிகளை 3 எண்களின் தொகுப்பாகக் குறிக்கும், "
"இருப்பினும், அவை குறைவாகவே உள்ளன, அவை கீழான நிகழ்வுகளைத் தவிர, மிகவும் பயனுள்ளதாக "
"இல்லை."

msgid ""
"In 3D we do not typically use angles, we either use a transformation basis "
"(used pretty much everywhere in Godot), or we use quaternions. Godot can "
"represent quaternions using the :ref:`class_Quaternion` struct. My "
"suggestion to you is to completely ignore how they work under-the-hood, "
"because they are very complicated and unintuitive."
msgstr ""
"3D இல் நாம் பொதுவாக கோணங்களைப் பயன்படுத்துவதில்லை, நாம் ஒரு உருமாற்ற அடிப்படையைப் "
"பயன்படுத்துகிறோம் (கோடோட்டில் எல்லா இடங்களிலும் பயன்படுத்தப்படுகிறது), அல்லது நாங்கள் "
"குவாட்டர்னியன்களைப் பயன்படுத்துகிறோம். கோடோட்: ref: `class_quaternion` struct ஐப் "
"பயன்படுத்தி குவாட்டர்னியன்களைக் குறிக்கலாம். உங்களுக்கான எனது பரிந்துரை என்னவென்றால், அவை "
"மிகவும் சிக்கலானவை மற்றும் நம்பிக்கையற்றவை என்பதால் அவை எவ்வாறு ஊட் கீழ் செயல்படுகின்றன "
"என்பதை முழுமையாக புறக்கணிப்பதாகும்."

msgid ""
"However, if you really must know how it works, here are some great "
"resources, which you can follow in order:"
msgstr ""
"இருப்பினும், இது எவ்வாறு செயல்படுகிறது என்பதை நீங்கள் உண்மையிலேயே அறிந்திருக்க வேண்டும் "
"என்றால், இங்கே சில சிறந்த ஆதாரங்கள் உள்ளன, அவை வரிசையில் பின்பற்றலாம்:"

msgid "https://www.youtube.com/watch?v=mvmuCPvRoWQ"
msgstr "https://www.youtube.com/watch?v=mvmuCPvRoWQ"

msgid "https://www.youtube.com/watch?v=d4EgbgTm0Bg"
msgstr "https://www.youtube.com/watch?v=d4EgbgTm0Bg"

msgid "https://eater.net/quaternions"
msgstr "https://eater.net/quaternions"
