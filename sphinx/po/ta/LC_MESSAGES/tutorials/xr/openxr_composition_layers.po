#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "OpenXR composition layers"
msgstr "Openxr கலவை அடுக்குகள்"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"In XR games you generally want to create user interactions that happen in 3D "
"space and involve users touching objects as if they are touching them in "
"real life."
msgstr ""
"எக்ச்ஆர் கேம்களில் நீங்கள் பொதுவாக 3D இடத்தில் நடக்கும் பயனர் தொடர்புகளை உருவாக்க "
"விரும்புகிறீர்கள், மேலும் பயனர்கள் பொருள்களை நிச வாழ்க்கையில் தொடுவதைப் போலத் தொடுவதை "
"உள்ளடக்குகிறார்கள்."

msgid ""
"Sometimes however creating a more traditional 2D interface is unavoidable. "
"In XR however you can't just add 2D components to your scene. Godot needs "
"depth information to properly position these elements so they appear at a "
"comfortable place for the user. Even with depth information there are "
"headsets with slanted displays that make it impossible for the standard 2D "
"pipeline to correctly render the 2D elements."
msgstr ""
"சில நேரங்களில் மிகவும் பாரம்பரியமான 2 டி இடைமுகத்தை உருவாக்குவது தவிர்க்க முடியாதது. "
"எக்ச்ஆரில் உங்கள் காட்சியில் 2 டி கூறுகளைச் சேர்க்க முடியாது. இந்த கூறுகளை சரியாக "
"நிலைநிறுத்த கோடோட் ஆழமான தகவல்கள் தேவை, எனவே அவை பயனருக்கு வசதியான இடத்தில் தோன்றும். "
"ஆழமான தகவலுடன் கூட சாய்ந்த காட்சிகளைக் கொண்ட எட்செட்டுகள் உள்ளன, அவை நிலையான 2 டி "
"பைப்லைன் 2 டி கூறுகளை சரியாக வழங்குவது சாத்தியமில்லை."

msgid ""
"The solution then is to render the UI to a :ref:`SubViewport "
"<class_subviewport>` and display the result of this using "
"a :ref:`ViewportTexture <class_viewporttexture>` on a 3D mesh. "
"The :ref:`QuadMesh <class_quadmesh>` is a suitable option for this."
msgstr ""
"தீர்வு இடைமுகம் ஐ A க்கு வழங்குவதாகும்: ref: `subviewport <class_subviewport>` "
"மற்றும் இதன் முடிவைப் பயன்படுத்தி ஒரு: re: `viewporttexture "
"<class_viewporttexture>` ஒரு 3D மெசில். தி: ரெஃப்: `குவாட்மேச் <class_quadmesh>` "
"இதற்கு பொருத்தமான வழி."

msgid ""
"See the `GUI in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/gui_in_3d>`_ example project for an example of this approach."
msgstr ""
"3d <https://github.com/godotengine/godot-demo-projects/tree/master/viewport/"
"gui_in_3d> `_ எடுத்துக்காட்டு திட்டம் இந்த அணுகுமுறையின் எடுத்துக்காட்டுக்கு."

msgid ""
"The problem with displaying the viewport in this way is that the rendered "
"result is sampled for lens distortion by the XR runtime and the resulting "
"quality loss can make UI text hard to read."
msgstr ""
"இந்த வழியில் காட்சியமைப்பைக் காண்பிப்பதில் உள்ள சிக்கல் என்னவென்றால், வழங்கப்பட்ட முடிவு "
"எக்ச்ஆர் இயக்க நேரத்தால் லென்ச் விலகலுக்காக மாதிரி செய்யப்படுகிறது, இதன் விளைவாக தரமான "
"இழப்பு இடைமுகம் உரையைப் படிக்க கடினமாக இருக்கும்."

msgid ""
"OpenXR offers a solution to this problem through composition layers. With "
"composition layers it is possible for the contents of a viewport to be "
"projected on a surface after lens distortion resulting in a much higher "
"quality end result."
msgstr ""
"கலவை அடுக்குகள் மூலம் இந்த சிக்கலுக்கு OpenXR ஒரு தீர்வை வழங்குகிறது. கலவை "
"அடுக்குகளுடன், லென்ச் விலகலுக்குப் பிறகு ஒரு காட்சியின் உள்ளடக்கங்கள் ஒரு மேற்பரப்பில் "
"திட்டமிடப்படுவது சாத்தியமாகும், இதன் விளைவாக மிக உயர்ந்த தரமான இறுதி முடிவு "
"கிடைக்கும்."

msgid ""
"As not all XR runtimes support all composition layer types, Godot implements "
"a fallback solution where we render the viewport as part of the normal scene "
"but with the aforementioned quality limitations."
msgstr ""
"எல்லா எக்ச்ஆர் ரன் டைம்களும் அனைத்து கலவை அடுக்கு வகைகளையும் ஆதரிக்காததால், கோடோட் ஒரு "
"குறைவடையும் தீர்வை செயல்படுத்துகிறார், அங்கு நாங்கள் காட்சியகத்தை சாதாரண காட்சியின் ஒரு "
"பகுதியாக வழங்குகிறோம், ஆனால் மேற்கூறிய தர வரம்புகளுடன்."

msgid ""
"When the composition layer is supported, it is the XR runtime that presents "
"the subviewport. This means the UI is only visible in the headset, it will "
"not be accessible by Godot and will thus not be shown when you have a "
"spectator view on the desktop."
msgstr ""
"கலவை அடுக்கு ஆதரிக்கப்படும் போது, இது எக்ச்ஆர் இயக்க நேரமாகும், இது சப் வியூ போர்ட்டை "
"முன்வைக்கிறது. இதன் பொருள் இடைமுகம் எட்செட்டில் மட்டுமே தெரியும், இது கோடோட் மூலம் அணுக "
"முடியாது, இதனால் டெச்க்டாப்பில் நீங்கள் பார்வையாளர் பார்வை இருக்கும்போது காண்பிக்கப்படாது."

msgid "There are currently 3 nodes that expose this functionality:"
msgstr "இந்த செயல்பாட்டை அம்பலப்படுத்தும் 3 முனைகள் தற்போது உள்ளன:"

msgid ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a cylinder (or "
"\"slice\" of a cylinder)."
msgstr ""
":ref:`OpenXRCompositionLayerCylinder <class_OpenXRCompositionLayerCylinder>` "
"shows the contents of the SubViewport on the inside of a கலன் (or \"slice\" "
"of a cylinder)."

msgid ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a sphere (or "
"\"slice\" of a sphere)."
msgstr ""
":ref:`OpenXRCompositionLayerEquirect <class_OpenXRCompositionLayerEquirect>` "
"shows the contents of the SubViewport on the interior of a கோளம் (or "
"\"slice\" of a sphere)."

msgid ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a flat rectangle."
msgstr ""
":ref:`OpenXRCompositionLayerQuad <class_OpenXRCompositionLayerQuad>` shows "
"the contents of the SubViewport on a கிடைவளைவு rectangle."

msgid "Setting up the SubViewport"
msgstr "சப் வியூ போர்ட்டை அமைத்தல்"

msgid ""
"The first step is adding a SubViewport for our 2D UI, this doesn't require "
"any specific steps. For our example we do mark the viewport as transparent."
msgstr ""
"முதல் படி எங்கள் 2 டி இடைமுகம் க்கான துணைக் காண்பிப்பைச் சேர்ப்பது, இதற்கு எந்த குறிப்பிட்ட "
"படிகளும் தேவையில்லை. எங்கள் எடுத்துக்காட்டுக்கு, காட்சியை வெளிப்படையானது என்று "
"குறிக்கிறோம்."

msgid ""
"You can now create the 2D UI by adding child nodes to the SubViewport as you "
"normally would. It is advisable to save the 2D UI in a subscene, this makes "
"it easier to do your layout."
msgstr ""
"நீங்கள் சாதாரணமாகப் போலவே சப் வியூ போர்ட்டில் குழந்தை முனைகளைச் சேர்ப்பதன் மூலம் இப்போது 2D "
"இடைமுகம் ஐ உருவாக்கலாம். 2D இடைமுகம் ஐ ஒரு துணைக்குழுவில் சேமிப்பது நல்லது, இது உங்கள் "
"தளவமைப்பைச் செய்வதை எளிதாக்குகிறது."

msgid ""
"The update mode \"When Visible\" will not work as Godot can't determine "
"whether the viewport is visible to the user. When assigning our viewport to "
"a composition layer Godot will automatically adjust this."
msgstr ""
"புதுப்பிப்பு பயன்முறை \"காணக்கூடிய போது\" செயல்படாது, ஏனெனில் காட்சியகம் பயனருக்குத் "
"தெரியுமா என்பதை கோடோட் தீர்மானிக்க முடியாது. எங்கள் காட்சியை ஒரு கலவை அடுக்குக்கு "
"ஒதுக்கும்போது கோடோட் இதை தானாகவே சரிசெய்யும்."

msgid "Adding a composition layer"
msgstr "ஒரு கலவை அடுக்கைச் சேர்ப்பது"

msgid ""
"The second step is adding our composition layer. We can add the correct "
"composition layer node as a child node of our :ref:`XROrigin3D "
"<class_xrorigin3d>` node. This is very important as the XR runtime positions "
"everything in relation to our origin."
msgstr ""
"இரண்டாவது படி எங்கள் கலவை அடுக்கைச் சேர்ப்பது. சரியான கலவை அடுக்கு முனையை எங்கள் "
"குழந்தை முனையாக சேர்க்கலாம்: குறிப்பு: `xrorigin3d <class_xrorigin3d>` முனை. "
"எக்ச்ஆர் இயக்க நேரம் எங்கள் தோற்றம் தொடர்பாக எல்லாவற்றையும் நிலைநிறுத்துவதால் இது மிகவும் "
"முக்கியமானது."

msgid ""
"We want to position the composition layer so it is at eye height and roughly "
"1 to 1.5 meters away from the player."
msgstr ""
"கலவை அடுக்கை நிலைநிறுத்த விரும்புகிறோம், எனவே இது கண் உயரத்திலும், வீரரிடமிருந்து "
"சுமார் 1 முதல் 1.5 மீட்டர் தொலைவில் உள்ளது."

msgid ""
"We now assign the SubViewport to the ``Layer Viewport`` property and enable "
"Alpha Blend."
msgstr ""
"நாங்கள் இப்போது சப் வியூ போர்ட்டை `` லேயர் வியாபோர்ட்`` சொத்துக்கு ஒதுக்குகிறோம் மற்றும் "
"ஆல்பா கலவையை இயக்குகிறோம்."

msgid ""
"As the player can walk away from the origin point, you will want to "
"reposition the composition layer when the player recenters the view. Using "
"the reference space ``Local Floor`` will apply this logic automatically."
msgstr ""
"வீரர் தோற்றம் புள்ளியிலிருந்து விலகிச் செல்ல முடியும் என்பதால், பிளேயர் பார்வையை "
"சமீபத்தியதாகக் கொள்ளும்போது கலவை அடுக்கை மாற்றியமைக்க விரும்புவீர்கள். குறிப்பு இடத்தைப் "
"பயன்படுத்துவது `` உள்ளக மாடி`` இந்த தர்க்கத்தை தானாகவே பயன்படுத்தும்."

msgid "Making the interface work"
msgstr "இடைமுகத்தை உருவாக்குகிறது"

msgid ""
"So far we're only displaying our UI, to make it work we need to add some "
"code. For this example we're going to keep things simple and make one of the "
"controllers work as a pointer. We'll then simulate mouse actions with this "
"pointer."
msgstr ""
"இதுவரை நாங்கள் எங்கள் இடைமுகம் ஐ மட்டுமே காண்பிக்கிறோம், அதைச் செயல்படுத்துவதற்கு சில "
"குறியீடுகளைச் சேர்க்க வேண்டும். இந்த எடுத்துக்காட்டுக்கு, நாங்கள் விசயங்களை எளிமையாக "
"வைத்திருக்கப் போகிறோம், மேலும் கட்டுப்பாட்டாளர்களில் ஒன்றை சுட்டிக்காட்டியாகச் செய்யப் "
"போகிறோம். இந்த சுட்டிக்காட்டி மூலம் சுட்டி செயல்களை உருவகப்படுத்துவோம்."

msgid ""
"This code also requires a ``MeshInstance3D`` node called ``Pointer`` to be "
"added as a child to our ``OpenXRCompositionLayerQuad`` node. We configure a "
"``SphereMesh`` with a radius ``0.01`` meters. We'll be using this as a "
"helper to visualize where the user is pointing."
msgstr ""
"இந்த குறியீட்டில் `` OpenxRcomPositionLayerQuad`` முனையில் ஒரு குழந்தையாக சேர்க்கப்பட "
"வேண்டும் `` சுட்டிக்காட்டி`` என்று அழைக்கப்படும் `` meshinstance3d`` முனை "
"தேவைப்படுகிறது. `` 0.01`` மீட்டர் ஆரம் மூலம் ஒரு `` ச்பெர்மேச்`` ஐ உள்ளமைக்கிறோம். பயனர் "
"எங்கு சுட்டிக்காட்டுகிறார் என்பதைக் காட்சிப்படுத்த இதை ஒரு உதவியாளராகப் பயன்படுத்துவோம்."

msgid ""
"The main function that drives this functionality is the ``intersects_ray`` "
"function on our composition layer node. This function takes the global "
"position and orientation of our pointer and returns the UV where our ray "
"intersects our viewport. It returns ``Vector2(-1.0, -1.0)`` if we're not "
"pointing at our viewport."
msgstr ""
"இந்த செயல்பாட்டை இயக்கும் முக்கிய செயல்பாடு எங்கள் கலவை அடுக்கு முனையில் `` "
"வெட்டுகிறது_ரே`` செயல்பாடு. இந்த செயல்பாடு எங்கள் சுட்டிக்காட்டி உலகளாவிய நிலை மற்றும் "
"நோக்குநிலையை எடுத்து, எங்கள் கதிர் எங்கள் காட்சியை வெட்டும் புற ஊதா திருப்புகிறது. இது "
"`` திசையன் 2 (-1.0, -1.0) `` எங்கள் காட்சியமைப்பில் சுட்டிக்காட்டவில்லை என்றால்."

msgid ""
"We start with setting up some variables, important here are the export "
"variables which identify our controller node with which we point to our "
"screen."
msgstr ""
"We தொடங்கு with setting மேலே some variables, important here அரே the ஏற்றுமதி "
"மாறிகள் which identify our controller கணு with which we புள்ளியம் பெறுநர் our "
"screen."

msgid ""
"Next we define a helper function that takes the value returned from "
"``intersects_ray`` and gives us the global position for that intersection "
"point. This implementation only works for our ``OpenXRCompositionLayerQuad`` "
"node."
msgstr ""
"அடுத்து ஒரு உதவி செயல்பாட்டை வரையறுக்கிறோம், இது `` குறுக்குவெட்டுகள்_ரே`` இலிருந்து "
"திரும்பிய மதிப்பை எடுத்து, அந்த குறுக்குவெட்டு புள்ளிக்கான உலகளாவிய நிலையை நமக்குத் "
"தருகிறது. இந்த செயல்படுத்தல் எங்கள் `` OpenxRcomPositionLayerquad`` முனைக்கு மட்டுமே "
"வேலை செய்கிறது."

msgid ""
"The main logic happens in our ``_process`` function. Here we start by hiding "
"our pointer, we then check if we have a valid controller and viewport, and "
"we call ``intersects_ray`` with the position and orientation of our "
"controller:"
msgstr ""
"முக்கிய வழக்கு எங்கள் `` _ செயல்முறை` செயல்பாட்டில் நிகழ்கிறது. இங்கே நாங்கள் எங்கள் "
"சுட்டிக்காட்டி மறைப்பதன் மூலம் தொடங்குகிறோம், எங்களிடம் செல்லுபடியாகும் கட்டுப்படுத்தி "
"மற்றும் காட்சியகம் இருக்கிறதா என்று சரிபார்க்கிறோம், மேலும் எங்கள் கட்டுப்படுத்தியின் நிலை "
"மற்றும் நோக்குநிலையுடன் `` குறுக்குவெட்டு_ரே` என்று அழைக்கிறோம்:"

msgid ""
"Next we check if we're intersecting with our viewport. If so, we check if "
"our button is pressed and place our pointer at our intersection point."
msgstr ""
"அடுத்து நாங்கள் எங்கள் காட்சியகத்துடன் வெட்டுகிறோமா என்று சரிபார்க்கிறோம். அப்படியானால், "
"எங்கள் பொத்தானை அழுத்தினால் சரிபார்த்து, எங்கள் சுட்டிக்காட்டி எங்கள் குறுக்குவெட்டு "
"புள்ளியில் வைக்கவும்."

msgid "Next we remember our state for next frame."
msgstr "அடுத்து அடுத்த சட்டகத்திற்கான எங்கள் மாநிலத்தை நினைவில் கொள்கிறோம்."

msgid "Finally, if we aren't intersecting, we clear our state."
msgstr "இறுதியாக, நாங்கள் வெட்டவில்லை என்றால், நாங்கள் எங்கள் நிலையை அழிக்கிறோம்."

msgid "Hole punching"
msgstr "துளை குத்துதல்"

msgid ""
"As the composition layer is composited on top of the render result, it can "
"be rendered in front of objects that are actually forward of the viewport."
msgstr ""
"வழங்குதல் முடிவுக்கு மேல் கலவை அடுக்கு தொகுக்கப்படுவதால், அதை உண்மையில் காட்சியமைப்பின் "
"முன்னோக்கி இருக்கும் பொருள்களுக்கு முன்னால் வழங்க முடியும்."

msgid ""
"By enabling hole punch you instruct Godot to render a transparent object "
"where our viewport is displayed. It does this in a way that fills the depth "
"buffer and clears the current rendering result. Anything behind our viewport "
"will now be cleared, while anything in front of our viewport will be "
"rendered as usual."
msgstr ""
"துளை பஞ்சை இயக்குவதன் மூலம், எங்கள் காட்சியகம் காட்டப்படும் ஒரு வெளிப்படையான பொருளை வழங்க "
"கோடோட்டை அறிவுறுத்துங்கள். இது ஆழமான இடையகத்தை நிரப்பும் மற்றும் தற்போதைய வழங்குதல் "
"முடிவை அழிக்கும் வகையில் இதைச் செய்கிறது. எங்கள் பார்வைக்கு பின்னால் உள்ள எதுவும் இப்போது "
"அழிக்கப்படும், அதே நேரத்தில் எங்கள் காட்சிக்கு முன் எதுவும் வழக்கம் போல் வழங்கப்படும்."

msgid ""
"You also need to set ``Sort Order`` to a negative value, the XR compositor "
"will now draw the viewport first, and then overlay our rendering result."
msgstr ""
"நீங்கள் `` வரிசை வரிசையை` எதிர்மறையான மதிப்புக்கு அமைக்க வேண்டும், எக்ச்ஆர் இசையமைப்பாளர் "
"இப்போது முதலில் காட்சியகத்தை வரைவார், பின்னர் எங்கள் வழங்குதல் முடிவை மேலெழுதும்."
