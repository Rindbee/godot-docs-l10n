#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "XR full screen effects"
msgstr "எக்ச்ஆர் முழு திரை விளைவுகள்"

msgid ""
"When adding custom full screen effects to your XR application, one approach "
"is using a full screen quad and applying effects to that quad's shader. Add "
"a :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene as a child "
"of your :ref:`XRCamera3D <class_XRCamera3D>`, and set the ``mesh`` property "
"to a :ref:`QuadMesh <class_QuadMesh>`. Set the width and height of the quad "
"to ``2``."
msgstr ""
"உங்கள் எக்ச்ஆர் பயன்பாட்டில் தனிப்பயன் முழு திரை விளைவுகளைச் சேர்க்கும்போது, ஒரு அணுகுமுறை "
"ஒரு முழு திரை குவாட் பயன்படுத்துகிறது மற்றும் அந்த குவாட் சேடருக்கு விளைவுகளைப் "
"பயன்படுத்துகிறது. A: ref: `meshinstance3d <class_meshinstance3d>` உங்கள் "
"குழந்தையாக உங்கள் காட்சிக்கு முனை: குறிப்பு: `xrcamera3d <class_xrcamera3d>` `` "
"`Mesh`` சொத்தை A க்கு அமைக்கவும்:` quthmesh <alsquadmesh> `. குவாட் அகலம் மற்றும் "
"உயரத்தை `` 2`` ஆக அமைக்கவும்."

msgid ""
"You can then add a shader to your quad to make it cover the screen. This is "
"done by setting the vertex shader's ``POSITION`` built-in to "
"``vec4(VERTEX.xy, 1.0, 1.0)``. However, when creating an effect that is "
"centered straight ahead in the user's view (such as a vignette effect), the "
"end result may look incorrect in XR."
msgstr ""
"உங்கள் குவாட் திரையை மறைக்க ஒரு சேடரைச் சேர்க்கலாம். வெர்டெக்ச் சேடரின் `` நிலை`` "
"உள்ளமைக்கப்பட்ட `` vec4 (vertex.xy, 1.0, 1.0) `` என அமைப்பதன் மூலம் இது "
"செய்யப்படுகிறது. இருப்பினும், பயனரின் பார்வையில் (விக்னெட் விளைவு போன்றவை) நேராக "
"முன்னால் இருக்கும் ஒரு விளைவை உருவாக்கும்போது, இறுதி முடிவு எக்ச்ஆரில் தவறாகத் தோன்றலாம்."

msgid ""
"Below shows captures of the right-eye view with a vignette shader, both from "
"the headset and the render target itself. The left captures are an "
"unmodified shader; the right captures adjust the full screen quad using the "
"projection matrix. While the capture on the left is centered in the render "
"target, it is off-center in the headset view. But, after applying the "
"projection matrix, we see that the effect is centered in the headset itself."
msgstr ""
"எட்செட் மற்றும் வழங்குதல் இலக்கு ஆகிய இரண்டிலிருந்தும் விக்னெட் சேடருடன் வலது கண் பார்வையின் "
"பிடிப்புகளை கீழே காட்டுகிறது. இடது பிடிப்புகள் மாற்றப்படாத சேடர்; சரியான பிடிப்புகள் "
"ப்ரொசெக்சன் மேட்ரிக்சைப் பயன்படுத்தி முழு திரை குவாட்டை சரிசெய்யின்றன. இடதுபுறத்தில் "
"பிடிப்பு வழங்குதல் இலக்கை மையமாகக் கொண்டிருந்தாலும், இது எட்செட் பார்வையில் மையமாக "
"உள்ளது. ஆனால், ப்ரொசெக்சன் மேட்ரிக்சைப் பயன்படுத்திய பிறகு, விளைவு எட்செட்டில் மையமாக "
"இருப்பதைக் காண்கிறோம்."

msgid "Applying the projection matrix"
msgstr "ப்ரொசெக்சன் மேட்ரிக்சைப் பயன்படுத்துதல்"

msgid ""
"To properly center the effect, the ``POSITION`` of the full screen quad "
"needs to take the asymmetric field of view into account. To do this while "
"also ensuring the quad has full coverage of the entire render target, we can "
"subdivide the quad and apply the projection matrix to the inner vertices. "
"Let's increase the subdivide width and depth of the quad."
msgstr ""
"விளைவை சரியாக மையப்படுத்த, முழு திரை குவாட்டின் `` நிலை`` சமச்சீரற்ற பார்வையை கணக்கில் "
"எடுத்துக்கொள்ள வேண்டும். முழு வழங்குதல் இலக்கையும் குவாட் முழுமையாகக் கொண்டிருப்பதை "
"உறுதிசெய்யும் அதே வேளையில், நாங்கள் குவாட்டை பிரித்து, ப்ரொசெக்சன் மேட்ரிக்சை உள் "
"செங்குத்துகளுக்குப் பயன்படுத்தலாம். குவாட்டின் துணைப்பிரிவு அகலம் மற்றும் ஆழத்தை "
"அதிகரிப்போம்."

msgid ""
"Then, in the vertex function of our shader, we apply an offset from the "
"projection matrix to the inner vertices. Here's an example of how you might "
"do this with the above simple vignette shader:"
msgstr ""
"பின்னர், எங்கள் சேடரின் வெர்டெக்ச் செயல்பாட்டில், திட்ட மேட்ரிக்சிலிருந்து உள் "
"செங்குத்துகளுக்கு ஆஃப்செட்டைப் பயன்படுத்துகிறோம். மேலே உள்ள எளிய விக்னெட் சேடருடன் இதை "
"நீங்கள் எவ்வாறு செய்யலாம் என்பதற்கான எடுத்துக்காட்டு இங்கே:"

msgid ""
"For more info on asymmetric FOV and its purpose, see this `Meta Asymmetric "
"Field of View FAQ <https://developers.meta.com/horizon/documentation/unity/"
"unity-asymmetric-fov-faq/>`_."
msgstr ""
"சமச்சீரற்ற FOV மற்றும் அதன் நோக்கம் பற்றிய கூடுதல் தகவலுக்கு, இந்த `மெட்டா சமச்சீரற்ற பார்வை "
"கேள்விகள் <https://developers.meta.com/horizon/documentation/unity/unity-"
"symmetricate-fov-faq/> _."

msgid "Limitations"
msgstr "வரம்புகள்"

msgid ""
"This full screen effect method has no performance concerns for per-pixel "
"effects such as the above vignette shader. However, it is not recommended to "
"read from the screen texture when using this technique. Full screen effects "
"that require reading from the screen texture effectively disable all "
"rendering performance optimizations in XR. This is because, when reading "
"from the screen texture, Godot makes a full copy of the render buffer; this "
"drastically increases the workload for the GPU and can create performance "
"concerns."
msgstr ""
"இந்த முழு திரை விளைவு முறைக்கு மேலே உள்ள விக்னெட் சேடர் போன்ற படப்புள்ளி விளைவுகளுக்கு "
"செயல்திறன் கவலைகள் இல்லை. இருப்பினும், இந்த நுட்பத்தைப் பயன்படுத்தும் போது திரை "
"அமைப்பிலிருந்து படிக்க பரிந்துரைக்கப்படவில்லை. திரை அமைப்பிலிருந்து வாசிப்பு தேவைப்படும் "
"முழு திரை விளைவுகள் எக்ச்ஆரில் அனைத்து வழங்குதல் செயல்திறன் மேம்படுத்தல்களையும் திறம்பட "
"முடக்குகின்றன. ஏனென்றால், திரை அமைப்பிலிருந்து படிக்கும்போது, கோடோட் வழங்குதல் பஃப்பரின் "
"முழு நகலை உருவாக்குகிறார்; இது சி.பீ.யுக்கான பணிச்சுமையை கடுமையாக அதிகரிக்கிறது "
"மற்றும் செயல்திறன் கவலைகளை உருவாக்க முடியும்."
