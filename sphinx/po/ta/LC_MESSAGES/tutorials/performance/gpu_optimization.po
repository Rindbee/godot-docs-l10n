#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GPU optimization"
msgstr "சி.பீ.யூ தேர்வுமுறை"

msgid "Introduction"
msgstr "அறிமுகம்"

msgid ""
"The demand for new graphics features and progress almost guarantees that you "
"will encounter graphics bottlenecks. Some of these can be on the CPU side, "
"for instance in calculations inside the Godot engine to prepare objects for "
"rendering. Bottlenecks can also occur on the CPU in the graphics driver, "
"which sorts instructions to pass to the GPU, and in the transfer of these "
"instructions. And finally, bottlenecks also occur on the GPU itself."
msgstr ""
"புதிய கிராபிக்ச் நற்பொருத்தங்கள் மற்றும் முன்னேற்றத்திற்கான தேவை நீங்கள் கிராபிக்ச் "
"இடையூறுகளை சந்திப்பீர்கள் என்று கிட்டத்தட்ட பொறுப்பு அளிக்கிறது. இவற்றில் சில சிபியு "
"பக்கத்தில் இருக்கலாம், உதாரணமாக கோடோட் எஞ்சினுக்குள் கணக்கீடுகளில் வழங்குதல் செய்வதற்கான "
"பொருள்களைத் தயாரிக்கலாம். கிராபிக்ச் டிரைவரில் சிபியு இல் சிக்கல் ஏற்படலாம், இது GPU க்கு "
"அனுப்ப வழிமுறைகளை வகைப்படுத்துகிறது, மேலும் இந்த வழிமுறைகளை மாற்றுவதில். இறுதியாக, "
"சி.பீ.யிலும் இடையூறுகளும் நிகழ்கின்றன."

msgid ""
"Where bottlenecks occur in rendering is highly hardware-specific. Mobile "
"GPUs in particular may struggle with scenes that run easily on desktop."
msgstr ""
"வழங்குதல் செய்வதில் இடையூறுகள் ஏற்படும் இடத்தில் மிகவும் வன்பொருள் சார்ந்தது. குறிப்பாக "
"மொபைல் சி.பீ.யுகள் டெச்க்டாப்பில் எளிதில் இயங்கும் காட்சிகளுடன் போராடக்கூடும்."

msgid ""
"Understanding and investigating GPU bottlenecks is slightly different to the "
"situation on the CPU. This is because, often, you can only change "
"performance indirectly by changing the instructions you give to the GPU. "
"Also, it may be more difficult to take measurements. In many cases, the only "
"way of measuring performance is by examining changes in the time spent "
"rendering each frame."
msgstr ""
"சி.பீ.யு இடையூறுகளைப் புரிந்துகொள்வதும் விசாரிப்பதும் சிபியு இன் நிலைமைக்கு சற்று "
"வித்தியாசமானது. ஏனென்றால், பெரும்பாலும், நீங்கள் சி.பீ.யுக்கு வழங்கும் வழிமுறைகளை "
"மாற்றுவதன் மூலம் மட்டுமே செயல்திறனை மறைமுகமாக மாற்ற முடியும். மேலும், அளவீடுகளை "
"எடுப்பது மிகவும் கடினமாக இருக்கலாம். பல சந்தர்ப்பங்களில், செயல்திறனை அளவிடுவதற்கான ஒரே "
"வழி ஒவ்வொரு சட்டகத்தையும் வழங்கும் நேரத்தின் மாற்றங்களை ஆராய்வதுதான்."

msgid "Draw calls, state changes, and APIs"
msgstr "அழைப்புகள், மாநில மாற்றங்கள் மற்றும் பநிஇ கள்"

msgid ""
"The following section is not relevant to end-users, but is useful to provide "
"background information that is relevant in later sections."
msgstr ""
"பின்வரும் பிரிவு இறுதி பயனர்களுக்கு பொருந்தாது, ஆனால் பிற்கால பிரிவுகளில் பொருத்தமான "
"பின்னணி தகவல்களை வழங்க பயனுள்ளதாக இருக்கும்."

msgid ""
"Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, "
"OpenGL ES or WebGL). The communication and driver activity involved can be "
"quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide "
"these instructions in a way that is preferred by the driver and GPU, we can "
"greatly increase performance."
msgstr ""
"கோடோட் சி.பீ.யுக்கு கிராபிக்ச் பநிஇ (வல்கன், ஓபன்சிஎல், ஓபன்சிஎல் இஎச் அல்லது வெப்சிஎல்) "
"வழியாக வழிமுறைகளை அனுப்புகிறது. சம்பந்தப்பட்ட தகவல்தொடர்பு மற்றும் இயக்கி செயல்பாடு "
"மிகவும் விலை உயர்ந்ததாக இருக்கும், குறிப்பாக ஓபன்சிஎல், ஓபன்சிஎல் இஎச் மற்றும் வெப்சிஎல். "
"இயக்கி மற்றும் சி.பீ.யுவால் விரும்பப்படும் வகையில் இந்த வழிமுறைகளை நாம் வழங்க முடிந்தால், "
"செயல்திறனை நாம் பெரிதும் அதிகரிக்க முடியும்."

msgid ""
"Nearly every API command in OpenGL requires a certain amount of validation "
"to make sure the GPU is in the correct state. Even seemingly simple commands "
"can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal "
"is to reduce these instructions to a bare minimum and group together similar "
"objects as much as possible so they can be rendered together, or with the "
"minimum number of these expensive state changes."
msgstr ""
"ஓபன்சிஎல்லில் உள்ள ஒவ்வொரு பநிஇ கட்டளைக்கும் சி.பீ.யூ சரியான நிலையில் இருப்பதை "
"உறுதிசெய்ய ஒரு குறிப்பிட்ட அளவு சரிபார்ப்பு தேவைப்படுகிறது. எளிமையான கட்டளைகள் கூட "
"திரைக்குப் பின்னால் வீட்டுப் பராமரிப்புக்கு வழிவகுக்கும். ஆகையால், இந்த வழிமுறைகளை "
"குறைந்தபட்சம் மற்றும் குழுவில் ஒரே மாதிரியான பொருள்களைக் குறைப்பதே குறிக்கோள், எனவே அவை "
"ஒன்றாக வழங்கப்படலாம், அல்லது இந்த விலையுயர்ந்த மாநில மாற்றங்களின் குறைந்தபட்ச எண்ணிக்கையுடன்."

msgid "2D batching"
msgstr "2 டி தொகுதி"

msgid "3D batching"
msgstr "3 டி தொகுதி"

msgid ""
"In 3D, we still aim to minimize draw calls and state changes. However, it "
"can be more difficult to batch together several objects into a single draw "
"call. 3D meshes tend to comprise hundreds or thousands of triangles, and "
"combining large meshes in real-time is prohibitively expensive. The costs of "
"joining them quickly exceeds any benefits as the number of triangles grows "
"per mesh. A much better alternative is to **join meshes ahead of time** "
"(static meshes in relation to each other). This can be done by artists, or "
"programmatically within Godot using an add-on."
msgstr ""
"3D இல், டிரா அழைப்புகள் மற்றும் மாநில மாற்றங்களைக் குறைப்பதை நாங்கள் இன்னும் நோக்கமாகக் "
"கொண்டுள்ளோம். இருப்பினும், பல பொருள்களை ஒரே டிரா அழைப்பில் ஒன்றாக இணைப்பது மிகவும் "
"கடினம். 3 டி மெச்கள் நூற்றுக்கணக்கான அல்லது ஆயிரக்கணக்கான முக்கோணங்களைக் கொண்டிருக்கின்றன, "
"மேலும் பெரிய நேரத்தில் பெரிய மெச்களை இணைப்பது தடைசெய்யக்கூடிய விலையுயர்ந்தது. அவற்றில் "
"சேருவதற்கான செலவுகள் ஒரு கண்ணிக்கு முக்கோணங்களின் எண்ணிக்கை வளரும்போது விரைவாக எந்த "
"நன்மைகளையும் மீறுகிறது. ஒரு சிறந்த மாற்று என்பது ** நேரத்திற்கு முன்பே மெச்களில் சேர "
"வேண்டும் ** (ஒருவருக்கொருவர் தொடர்பாக நிலையான மெச்கள்). இதை கலைஞர்களால் செய்ய முடியும், "
"அல்லது ஒரு துணை நிரலைப் பயன்படுத்தி கோடோட்டிற்குள் நிரல் முறையில் செய்ய முடியும்."

msgid ""
"For more information on 3D specific optimizations, "
"see :ref:`doc_optimizing_3d_performance`."
msgstr ""
"3D குறிப்பிட்ட மேம்படுத்தல்கள் பற்றிய கூடுதல் தகவலுக்கு, பார்க்க: குறிப்பு: "
"`Doc_optimiging_3d_performance`."

msgid "Reuse shaders and materials"
msgstr "சேடர்கள் மற்றும் பொருட்களை மீண்டும் பயன்படுத்தவும்"

msgid ""
"The Godot renderer is a little different to what is out there. It's designed "
"to minimize GPU state changes as much as possible. :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` does a good job at reusing materials that need "
"similar shaders. If custom shaders are used, make sure to reuse them as much "
"as possible. Godot's priorities are:"
msgstr ""
"கோடோட் ரெண்டரர் அங்குள்ளதை விட சற்று வித்தியாசமானது. இது சி.பீ.யூ மாநில மாற்றங்களை "
"முடிந்தவரை குறைக்க வடிவமைக்கப்பட்டுள்ளது. . தனிப்பயன் சேடர்கள் பயன்படுத்தப்பட்டால், அவற்றை "
"முடிந்தவரை மீண்டும் பயன்படுத்துவதை உறுதிப்படுத்திக் கொள்ளுங்கள். கோடோட்டின் முன்னுரிமைகள்:"

msgid ""
"**Reusing Materials:** The fewer different materials in the scene, the "
"faster the rendering will be. If a scene has a huge amount of objects (in "
"the hundreds or thousands), try reusing the materials. In the worst case, "
"use atlases to decrease the amount of texture changes."
msgstr ""
"** மீண்டும் பயன்படுத்துதல் பொருட்கள்: ** காட்சியில் குறைவான வேறுபட்ட பொருட்கள், வழங்குதல் "
"வேகமாக இருக்கும். ஒரு காட்சியில் ஒரு பெரிய அளவு பொருள்கள் இருந்தால் (நூற்றுக்கணக்கான "
"அல்லது ஆயிரக்கணக்கானவற்றில்), பொருட்களை மீண்டும் பயன்படுத்த முயற்சிக்கவும். மோசமான "
"நிலையில், அமைப்பு மாற்றங்களின் அளவைக் குறைக்க அட்லசைப் பயன்படுத்தவும்."

msgid ""
"**Reusing Shaders:** If materials can't be reused, at least try to reuse "
"shaders. Note: shaders are automatically reused between StandardMaterial3Ds "
"that share the same configuration (features that are enabled or disabled "
"with a check box) even if they have different parameters."
msgstr ""
"** சேடர்களை மீண்டும் பயன்படுத்துதல்: ** பொருட்களை மீண்டும் பயன்படுத்த முடியாவிட்டால், "
"குறைந்தபட்சம் சேடர்களை மீண்டும் பயன்படுத்த முயற்சிக்கவும். குறிப்பு: வெவ்வேறு அளவுருக்கள் "
"இருந்தாலும் கூட அதே உள்ளமைவைப் பகிரும் அதே உள்ளமைவைப் பகிரும் (ஒரு தேர்வுப்பெட்டியுடன் "
"இயக்கப்பட்ட அல்லது முடக்கப்பட்ட அம்சங்கள்) இடையே சேடர்கள் தானாகவே மீண்டும் "
"பயன்படுத்தப்படுகின்றன."

msgid ""
"If a scene has, for example, 20,000 objects with 20,000 different materials "
"each, rendering will be slow. If the same scene has 20,000 objects, but only "
"uses 100 materials, rendering will be much faster."
msgstr ""
"ஒரு காட்சியில், எடுத்துக்காட்டாக, 20,000 வெவ்வேறு பொருட்களைக் கொண்ட 20,000 பொருள்கள் "
"இருந்தால், வழங்குதல் மெதுவாக இருக்கும். அதே காட்சியில் 20,000 பொருள்கள் இருந்தால், ஆனால் "
"100 பொருட்களை மட்டுமே பயன்படுத்தினால், வழங்குதல் மிக வேகமாக இருக்கும்."

msgid "Pixel cost versus vertex cost"
msgstr "படப்புள்ளி செலவு மற்றும் வெர்டெக்ச் செலவு"

msgid ""
"You may have heard that the lower the number of polygons in a model, the "
"faster it will be rendered. This is *really* relative and depends on many "
"factors."
msgstr ""
"ஒரு மாதிரியில் உள்ள பலகோணங்களின் எண்ணிக்கை குறைவாக இருப்பதால், அது வேகமாக வழங்கப்படும் "
"என்று நீங்கள் கேள்விப்பட்டிருக்கலாம். இது * உண்மையில் * உறவினர் மற்றும் பல காரணிகளைப் "
"பொறுத்தது."

msgid ""
"On a modern PC and console, vertex cost is low. GPUs originally only "
"rendered triangles. This meant that every frame:"
msgstr ""
"நவீன பிசி மற்றும் கன்சோலில், வெர்டெக்ச் செலவு குறைவாக உள்ளது. சி.பீ.யுகள் முதலில் "
"முக்கோணங்களை மட்டுமே வழங்கின. இதன் பொருள் ஒவ்வொரு சட்டகமும்:"

msgid "All vertices had to be transformed by the CPU (including clipping)."
msgstr "அனைத்து செங்குத்துகளும் சிபியு ஆல் மாற்றப்பட வேண்டியிருந்தது (கிளிப்பிங் உட்பட)."

msgid "All vertices had to be sent to the GPU memory from the main RAM."
msgstr ""
"அனைத்து செங்குத்துகளையும் முதன்மையான ரேமிலிருந்து சி.பீ.யூ நினைவகத்திற்கு அனுப்ப "
"வேண்டியிருந்தது."

msgid ""
"Nowadays, all this is handled inside the GPU, greatly increasing "
"performance. 3D artists usually have the wrong feeling about polycount "
"performance because 3D modeling software (such as Blender, 3ds Max, etc.) "
"need to keep geometry in CPU memory for it to be edited, reducing actual "
"performance. Game engines rely on the GPU more, so they can render many "
"triangles much more efficiently."
msgstr ""
"இப்போதெல்லாம், இவை அனைத்தும் சி.பீ.யுவுக்குள் கையாளப்படுகின்றன, செயல்திறனை பெரிதும் "
"அதிகரிக்கின்றன. 3D கலைஞர்கள் வழக்கமாக பாலிகவுண்ட் செயல்திறனைப் பற்றி தவறான உணர்வைக் "
"கொண்டுள்ளனர், ஏனெனில் 3D மாடலிங் மென்பொருள் (பிளெண்டர், 3DS மேக்ச் போன்றவை போன்றவை) "
"சிபியு நினைவகத்தில் வடிவவியலைத் திருத்த வேண்டும், உண்மையான செயல்திறனைக் குறைக்கிறது. "
"கேம் என்சின்கள் சி.பீ.யை அதிகம் நம்பியுள்ளன, எனவே அவை பல முக்கோணங்களை மிகவும் திறமையாக "
"வழங்க முடியும்."

msgid ""
"On mobile devices, the story is different. PC and console GPUs are brute-"
"force monsters that can pull as much electricity as they need from the power "
"grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot "
"more power efficient."
msgstr ""
"மொபைல் சாதனங்களில், கதை வேறுபட்டது. பிசி மற்றும் கன்சோல் சி.பீ.யுகள் மிருகத்தனமான-சக்தி "
"அரக்கர்கள், அவை மின் கட்டத்திலிருந்து தேவையான அளவுக்கு மின்சாரத்தை இழுக்க முடியும். "
"மொபைல் சி.பீ.யுகள் ஒரு சிறிய பேட்டரியுக்கு மட்டுமே வரையறுக்கப்பட்டுள்ளன, எனவே அவை அதிக "
"ஆற்றல் திறமையாக இருக்க வேண்டும்."

msgid ""
"To be more efficient, mobile GPUs attempt to avoid *overdraw*. Overdraw "
"occurs when the same pixel on the screen is being rendered more than once. "
"Imagine a town with several buildings. GPUs don't know what is visible and "
"what is hidden until they draw it. For example, a house might be drawn and "
"then another house in front of it (which means rendering happened twice for "
"the same pixel). PC GPUs normally don't care much about this and just throw "
"more pixel processors to the hardware to increase performance (which also "
"increases power consumption)."
msgstr ""
"மிகவும் திறமையாக இருக்க, மொபைல் சி.பீ.யுகள் *ஓவர் டிரா *ஐ தவிர்க்க முயற்சிக்கின்றன. "
"திரையில் அதே படப்புள்ளி ஒன்றுக்கு மேற்பட்ட முறை வழங்கப்படும்போது ஓவர் டிரா ஏற்படுகிறது. "
"பல கட்டிடங்களைக் கொண்ட ஒரு நகரத்தை கற்பனை செய்து பாருங்கள். சி.பீ.யுகளுக்கு என்ன "
"தெரியும், அவர்கள் அதை வரையும் வரை மறைக்கப்பட்டவை என்று தெரியவில்லை. உதாரணமாக, ஒரு வீடு "
"வரையப்படலாம், பின்னர் அதன் முன் மற்றொரு வீடு (அதாவது வழங்குதல் ஒரே பிக்சலுக்கு இரண்டு "
"முறை நடந்தது). பிசி சி.பீ.யுகள் பொதுவாக இதைப் பற்றி அதிகம் கவலைப்படுவதில்லை, மேலும் "
"செயல்திறனை அதிகரிக்க அதிக படப்புள்ளி செயலிகளை வன்பொருளுக்கு எறிந்து விடுங்கள் (இது "
"மின் நுகர்வு அதிகரிக்கிறது)."

msgid ""
"Using more power is not an option on mobile so mobile devices use a "
"technique called *tile-based rendering* which divides the screen into a "
"grid. Each cell keeps the list of triangles drawn to it and sorts them by "
"depth to minimize *overdraw*. This technique improves performance and "
"reduces power consumption, but takes a toll on vertex performance. As a "
"result, fewer vertices and triangles can be processed for drawing."
msgstr ""
"அதிக சக்தியைப் பயன்படுத்துவது மொபைலில் ஒரு விருப்பமல்ல, எனவே மொபைல் சாதனங்கள் * ஓடு "
"அடிப்படையிலான வழங்குதல் * எனப்படும் நுட்பத்தைப் பயன்படுத்துகின்றன, இது திரையை ஒரு "
"கட்டமாக பிரிக்கிறது. ஒவ்வொரு கலமும் அதில் வரையப்பட்ட முக்கோணங்களின் பட்டியலை "
"வைத்திருக்கிறது மற்றும் *ஓவர் டிரா *ஐக் குறைக்க ஆழத்தால் அவற்றை வரிசைப்படுத்துகிறது. இந்த "
"நுட்பம் செயல்திறனை மேம்படுத்துகிறது மற்றும் மின் நுகர்வு குறைக்கிறது, ஆனால் வெர்டெக்ச் "
"செயல்திறனை பாதிக்கிறது. இதன் விளைவாக, குறைந்த செங்குத்துகள் மற்றும் முக்கோணங்களை "
"வரைபடத்திற்கு செயலாக்க முடியும்."

msgid ""
"Additionally, tile-based rendering struggles when there are small objects "
"with a lot of geometry within a small portion of the screen. This forces "
"mobile GPUs to put a lot of strain on a single screen tile, which "
"considerably decreases performance as all the other cells must wait for it "
"to complete before displaying the frame."
msgstr ""
"கூடுதலாக, திரையின் ஒரு சிறிய பகுதிக்குள் நிறைய வடிவவியலுடன் சிறிய பொருள்கள் "
"இருக்கும்போது ஓடு அடிப்படையிலான வழங்குதல் போராட்டங்கள். இது மொபைல் சி.பீ.யுகளை ஒரு "
"திரை ஓடு மீது நிறைய அழுத்தங்களை வைக்க கட்டாயப்படுத்துகிறது, இது செயல்திறனைக் கணிசமாகக் "
"குறைக்கிறது, ஏனெனில் மற்ற அனைத்து கலங்களும் சட்டத்தைக் காண்பிப்பதற்கு முன்பு அது முடிக்க "
"காத்திருக்க வேண்டும்."

msgid ""
"To summarize, don't worry about vertex count on mobile, but **avoid "
"concentration of vertices in small parts of the screen**. If a character, "
"NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller "
"level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid "
"having triangles smaller than the size of a pixel on screen."
msgstr ""
"சுருக்கமாக, மொபைலில் வெர்டெக்ச் எண்ணிக்கையைப் பற்றி கவலைப்பட வேண்டாம், ஆனால் ** திரையின் "
"சிறிய பகுதிகளில் செங்குத்துகளின் செறிவைத் தவிர்க்கவும் **. ஒரு பாத்திரம், NPC, வண்டி "
"போன்றவை வெகு தொலைவில் இருந்தால் (இதன் பொருள் சிறியதாகத் தோன்றுகிறது), சிறிய அளவிலான "
"விவரம் (LOD) மாதிரியைப் பயன்படுத்துங்கள். டெச்க்டாப் சி.பீ.யுக்களில் கூட, திரையில் ஒரு "
"பிக்சலின் அளவை விட சிறிய முக்கோணங்கள் இருப்பதைத் தவிர்ப்பது விரும்பத்தக்கது."

msgid "Pay attention to the additional vertex processing required when using:"
msgstr "பயன்படுத்தும்போது தேவையான கூடுதல் வெர்டெக்ச் செயலாக்கத்தில் கவனம் செலுத்துங்கள்:"

msgid "Skinning (skeletal animation)"
msgstr "ச்கின்னிங் (எலும்பு அனிமேசன்)"

msgid "Morphs (shape keys)"
msgstr "மோர்ப்கள் (வடிவ விசைகள்)"

msgid "Vertex-lit objects (common on mobile)"
msgstr "வெர்டெக்ச்-லிட் பொருள்கள் (மொபைலில் பொதுவானது)"

msgid "Pixel/fragment shaders and fill rate"
msgstr "பிக்சல்/துண்டு சேடர்கள் மற்றும் நிரப்பு வீதம்"

msgid ""
"In contrast to vertex processing, the costs of fragment (per-pixel) shading "
"have increased dramatically over the years. Screen resolutions have "
"increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for "
"an old 640×480 VGA screen. That is 27 times the area! Also, the complexity "
"of fragment shaders has exploded. Physically-based rendering requires "
"complex calculations for each fragment."
msgstr ""
"வெர்டெக்ச் செயலாக்கத்திற்கு மாறாக, துண்டு (ஒரு பிக்சல்) நிழலின் செலவுகள் பல ஆண்டுகளாக "
"வியத்தகு அளவில் அதிகரித்துள்ளன. திரை தீர்மானங்கள் அதிகரித்துள்ளன: 4 கே திரையின் பரப்பளவு "
"8,294,400 படப்புள்ளிகள், பழைய 640 × 480 விசிஏ திரைக்கு 307,200 ஆகும். அது 27 "
"மடங்கு பரப்பளவு! மேலும், துண்டு நிழல்களின் சிக்கலானது வெடித்தது. உடல் அடிப்படையிலான "
"வழங்குதல் ஒவ்வொரு துண்டுக்கும் சிக்கலான கணக்கீடுகள் தேவை."

msgid ""
"You can test whether a project is fill rate-limited quite easily. Turn off V-"
"Sync to prevent capping the frames per second, then compare the frames per "
"second when running with a large window, to running with a very small "
"window. You may also benefit from similarly reducing your shadow map size if "
"using shadows. Usually, you will find the FPS increases quite a bit using a "
"small window, which indicates you are to some extent fill rate-limited. On "
"the other hand, if there is little to no increase in FPS, then your "
"bottleneck lies elsewhere."
msgstr ""
"ஒரு திட்டம் மிக எளிதாக நிரப்பப்பட்டதா என்பதை நீங்கள் சோதிக்கலாம். நொடிக்கு பிரேம்களை "
"மூடுவதைத் தடுக்க வி-ஒத்திசைவை அணைக்கவும், பின்னர் ஒரு பெரிய சாளரத்துடன் இயங்கும் போது "
"நொடிக்கு பிரேம்களை ஒப்பிட்டுப் பாருங்கள், மிகச் சிறிய சாளரத்துடன் இயங்கும். நிழல்களைப் "
"பயன்படுத்தினால் இதேபோல் உங்கள் நிழல் வரைபட அளவைக் குறைப்பதன் மூலமும் நீங்கள் பயனடையலாம். "
"வழக்கமாக, ஒரு சிறிய சாளரத்தைப் பயன்படுத்தி FPS சிறிது அதிகரிக்கிறது என்பதை நீங்கள் "
"காண்பீர்கள், இது நீங்கள் ஓரளவிற்கு நிரப்பு வீத-வரையறுக்கப்பட்டிருப்பதைக் குறிக்கிறது. "
"மறுபுறம், எஃப்.பி.எச்சில் அதிகரிப்பு குறைவாக இருந்தால், உங்கள் சிக்கல் வேறு இடங்களில் "
"உள்ளது."

msgid ""
"You can increase performance in a fill rate-limited project by reducing the "
"amount of work the GPU has to do. You can do this by simplifying the shader "
"(perhaps turn off expensive options if you are using "
"a :ref:`StandardMaterial3D <class_StandardMaterial3D>`), or reducing the "
"number and size of textures used. Also, when using non-unshaded particles, "
"consider forcing vertex shading in their material to decrease the shading "
"cost."
msgstr ""
"சி.பீ.யூ செய்ய வேண்டிய வேலையின் அளவைக் குறைப்பதன் மூலம் நிரப்பு வீத-வரையறுக்கப்பட்ட "
"திட்டத்தில் செயல்திறனை அதிகரிக்கலாம். சேடரை எளிதாக்குவதன் மூலம் இதைச் செய்யலாம் (நீங்கள் "
"பயன்படுத்தினால் விலையுயர்ந்த விருப்பங்களை அணைக்கலாம்: ref: `standardmaterial3d "
"<class_standardMaterial3d>`) அல்லது பயன்படுத்தப்படும் அமைப்புகளின் எண்ணிக்கையையும் "
"அளவையும் குறைத்தல். மேலும், மறைக்கப்படாத துகள்களைப் பயன்படுத்தும் போது, நிழல் செலவைக் "
"குறைக்க அவற்றின் பொருளில் வெர்டெக்ச் நிழலை கட்டாயப்படுத்துவதைக் கவனியுங்கள்."

msgid ""
"On supported hardware, :ref:`doc_variable_rate_shading` can be used to "
"reduce shading processing costs without impacting the sharpness of edges on "
"the final image."
msgstr ""
"ஆதரிக்கப்பட்ட வன்பொருளில்,: `doc_variable_rate_shading` இறுதி படத்தில் விளிம்புகளின் "
"கூர்மையை பாதிக்காமல் நிழல் செயலாக்க செலவுகளைக் குறைக்க பயன்படுத்தலாம்."

msgid ""
"**When targeting mobile devices, consider using the simplest possible "
"shaders you can reasonably afford to use.**"
msgstr ""
"** மொபைல் சாதனங்களை குறிவைக்கும் போது, நீங்கள் நியாயமான முறையில் பயன்படுத்தக்கூடிய எளிய "
"சேடர்களைப் பயன்படுத்துவதைக் கவனியுங்கள். **"

msgid "Reading textures"
msgstr "படித்தல் அமைப்புகள்"

msgid ""
"The other factor in fragment shaders is the cost of reading textures. "
"Reading textures is an expensive operation, especially when reading from "
"several textures in a single fragment shader. Also, consider that filtering "
"may slow it down further (trilinear filtering between mipmaps, and "
"averaging). Reading textures is also expensive in terms of power usage, "
"which is a big issue on mobiles."
msgstr ""
"துண்டு நிழல்களின் மற்ற காரணி அமைப்புகளைப் படிப்பதற்கான செலவு ஆகும். அமைப்புகளைப் "
"படிப்பது ஒரு விலையுயர்ந்த செயல்பாடாகும், குறிப்பாக ஒரு துண்டு நிழலில் பல "
"அமைப்புகளிலிருந்து படிக்கும்போது. மேலும், வடிகட்டுதல் அதை மேலும் குறைக்கக்கூடும் என்பதைக் "
"கவனியுங்கள் (MIPMAPS க்கு இடையில் Trilinear வடிகட்டுதல் மற்றும் சராசரியாக). மின் "
"பயன்பாட்டின் அடிப்படையில் அமைப்புகளைப் படிப்பது விலை உயர்ந்தது, இது மொபைல்களில் ஒரு "
"பெரிய சிக்கல்."

msgid ""
"**If you use third-party shaders or write your own shaders, try to use "
"algorithms that require as few texture reads as possible.**"
msgstr ""
"** நீங்கள் மூன்றாம் தரப்பு சேடர்களைப் பயன்படுத்தினால் அல்லது உங்கள் சொந்த சேடர்களை எழுதினால், "
"முடிந்தவரை சில அமைப்பு வாசிப்புகள் தேவைப்படும் வழிமுறைகளைப் பயன்படுத்த முயற்சிக்கவும். **"

msgid "Texture compression"
msgstr "அமைப்பு சுருக்கம்"

msgid ""
"By default, Godot compresses textures of 3D models when imported using video "
"RAM (VRAM) compression. Video RAM compression isn't as efficient in size as "
"PNG or JPG when stored, but increases performance enormously when drawing "
"large enough textures."
msgstr ""
"இயல்புநிலையாக, வீடியோ ரேம் (VRAM) சுருக்கத்தைப் பயன்படுத்தி இறக்குமதி செய்யும்போது "
"கோடோட் 3D மாடல்களின் அமைப்புகளை சுருக்குகிறது. வீடியோ ரேம் சுருக்கமானது சேமிக்கப்படும் "
"போது பி.என்.சி அல்லது சே.பி.சி போன்ற அளவு திறமையாக இல்லை, ஆனால் போதுமான அளவிலான "
"அமைப்புகளை வரையும்போது செயல்திறனை பெரிதும் அதிகரிக்கிறது."

msgid ""
"This is because the main goal of texture compression is bandwidth reduction "
"between memory and the GPU."
msgstr ""
"ஏனென்றால், அமைப்பு சுருக்கத்தின் முக்கிய குறிக்கோள் நினைவகத்திற்கும் சி.பீ.யுக்கும் "
"இடையிலான அலைவரிசை குறைப்பு ஆகும்."

msgid ""
"In 3D, the shapes of objects depend more on the geometry than the texture, "
"so compression is generally not noticeable. In 2D, compression depends more "
"on shapes inside the textures, so the artifacts resulting from 2D "
"compression are more noticeable."
msgstr ""
"3D இல், பொருள்களின் வடிவங்கள் அமைப்பை விட வடிவவியலை அதிகம் சார்ந்துள்ளது, எனவே "
"சுருக்கமானது பொதுவாக கவனிக்கப்படாது. 2 டி இல், சுருக்கமானது அமைப்புகளுக்குள் உள்ள "
"வடிவங்களைப் பொறுத்தது, எனவே 2 டி சுருக்கத்தின் விளைவாக ஏற்படும் கலைப்பொருட்கள் மிகவும் "
"கவனிக்கத்தக்கவை."

msgid ""
"As a warning, most Android devices do not support texture compression of "
"textures with transparency (only opaque), so keep this in mind."
msgstr ""
"ஒரு எச்சரிக்கையாக, பெரும்பாலான ஆண்ட்ராய்டு சாதனங்கள் வெளிப்படைத்தன்மையுடன் (ஒளிபுகா "
"மட்டுமே) அமைப்புகளின் அமைப்பு சுருக்கத்தை ஆதரிக்காது, எனவே இதை மனதில் கொள்ளுங்கள்."

msgid ""
"Even in 3D, \"pixel art\" textures should have VRAM compression disabled as "
"it will negatively affect their appearance, without improving performance "
"significantly due to their low resolution."
msgstr ""
"3D இல் கூட, \"படப்புள்ளி ஆர்ட்\" அமைப்புகள் VRAM சுருக்க முடக்கப்பட்டிருக்க வேண்டும், "
"ஏனெனில் அவை குறைந்த தெளிவுத்திறன் காரணமாக செயல்திறனை கணிசமாக மேம்படுத்தாமல் அவற்றின் "
"தோற்றத்தை எதிர்மறையாக பாதிக்கும்."

msgid "Post-processing and shadows"
msgstr "பிந்தைய செயலாக்கம் மற்றும் நிழல்கள்"

msgid ""
"Post-processing effects and shadows can also be expensive in terms of "
"fragment shading activity. Always test the impact of these on different "
"hardware."
msgstr ""
"துண்டு துண்டான நிழல் செயல்பாட்டின் அடிப்படையில் பிந்தைய செயலாக்க விளைவுகள் மற்றும் "
"நிழல்களும் விலை உயர்ந்ததாக இருக்கும். வெவ்வேறு வன்பொருளில் இவற்றின் தாக்கத்தை எப்போதும் "
"சோதிக்கவும்."

msgid ""
"**Reducing the size of shadowmaps can increase performance**, both in terms "
"of writing and reading the shadowmaps. On top of that, the best way to "
"improve performance of shadows is to turn shadows off for as many lights and "
"objects as possible. Smaller or distant OmniLights/SpotLights can often have "
"their shadows disabled with only a small visual impact."
msgstr ""
". அதற்கு மேல், நிழல்களின் செயல்திறனை மேம்படுத்துவதற்கான சிறந்த வழி, முடிந்தவரை பல "
"விளக்குகள் மற்றும் பொருள்களுக்கு நிழல்களை அணைக்க வேண்டும். சிறிய அல்லது தொலைதூர "
"ஓம்னிலைட்ச்/ச்பாட்லைட்கள் பெரும்பாலும் அவற்றின் நிழல்களை ஒரு சிறிய காட்சி தாக்கத்துடன் "
"முடக்கலாம்."

msgid "Transparency and blending"
msgstr "வெளிப்படைத்தன்மை மற்றும் கலத்தல்"

msgid ""
"Transparent objects present particular problems for rendering efficiency. "
"Opaque objects (especially in 3D) can be essentially rendered in any order "
"and the Z-buffer will ensure that only the front most objects get shaded. "
"Transparent or blended objects are different. In most cases, they cannot "
"rely on the Z-buffer and must be rendered in \"painter's order\" (i.e. from "
"back to front) to look correct."
msgstr ""
"வெளிப்படையான பொருள்கள் செயல்திறனை வழங்குவதற்கான குறிப்பிட்ட சிக்கல்களை முன்வைக்கின்றன. "
"ஒளிபுகா பொருள்கள் (குறிப்பாக 3D இல்) அடிப்படையில் எந்தவொரு வரிசையிலும் வழங்கப்படலாம், "
"மேலும் Z- பஃபர் முன் பெரும்பாலான பொருள்கள் மட்டுமே நிழலாடுவதை உறுதி செய்யும். "
"வெளிப்படையான அல்லது கலப்பு பொருள்கள் வேறுபட்டவை. பெரும்பாலான சந்தர்ப்பங்களில், அவை இசட்-"
"பஃபரை நம்ப முடியாது, மேலும் சரியானதாக இருக்க \"பெயிண்டரின் வரிசையில்\" (அதாவது "
"பின்புறத்திலிருந்து முன்னால்) வழங்கப்பட வேண்டும்."

msgid ""
"Transparent objects are also particularly bad for fill rate, because every "
"item has to be drawn even if other transparent objects will be drawn on top "
"later on."
msgstr ""
"வெளிப்படையான பொருள்கள் நிரப்பு விகிதத்திற்கு குறிப்பாக மோசமானவை, ஏனென்றால் மற்ற "
"வெளிப்படையான பொருள்கள் பின்னர் மேலே வரையப்பட்டாலும் ஒவ்வொரு பொருளும் வரையப்பட வேண்டும்."

msgid ""
"Opaque objects don't have to do this. They can usually take advantage of the "
"Z-buffer by writing to the Z-buffer only first, then only performing the "
"fragment shader on the \"winning\" fragment, the object that is at the front "
"at a particular pixel."
msgstr ""
"ஒளிபுகா பொருள்கள் இதைச் செய்ய வேண்டியதில்லை. அவர்கள் வழக்கமாக முதலில் இசட்-பஃபருக்கு "
"மட்டுமே இசட்-பஃபர் பயன்படுத்திக் கொள்ளலாம், பின்னர் ஒரு குறிப்பிட்ட பிக்சலில் முன்னால் "
"இருக்கும் \"வென்ற\" துண்டு, \"வென்ற\" துண்டில் துண்டு நிழலை மட்டுமே செய்ய முடியும்."

msgid ""
"Transparency is particularly expensive where multiple transparent objects "
"overlap. It is usually better to use transparent areas as small as possible "
"to minimize these fill rate requirements, especially on mobile, where fill "
"rate is very expensive. Indeed, in many situations, rendering more complex "
"opaque geometry can end up being faster than using transparency to \"cheat\"."
msgstr ""
"வெளிப்படைத்தன்மை குறிப்பாக விலை உயர்ந்தது, அங்கு பல வெளிப்படையான பொருள்கள் ஒன்றுடன் "
"ஒன்று. இந்த நிரப்பு வீதத் தேவைகளை குறைக்க, குறிப்பாக மொபைலில், நிரம்பிய விகிதம் மிகவும் "
"விலை உயர்ந்ததாக இருக்கும் வகையில் வெளிப்படையான பகுதிகளை முடிந்தவரை சிறியதாகப் "
"பயன்படுத்துவது பொதுவாக நல்லது. உண்மையில், பல சூழ்நிலைகளில், மிகவும் சிக்கலான ஒளிபுகா "
"வடிவவியலை வழங்குவது \"ஏமாற்று\" செய்ய வெளிப்படைத்தன்மையைப் பயன்படுத்துவதை விட வேகமாக "
"முடிவடையும்."

msgid "Multi-platform advice"
msgstr "பல-தளம் அறிவுரை"

msgid ""
"If you are aiming to release on multiple platforms, test *early* and test "
"*often* on all your platforms, especially mobile. Developing a game on "
"desktop but attempting to port it to mobile at the last minute is a recipe "
"for disaster."
msgstr ""
"நீங்கள் பல தளங்களில் வெளியிடுவதை நோக்கமாகக் கொண்டிருந்தால், * ஆரம்ப * சோதனை மற்றும் உங்கள் "
"எல்லா தளங்களிலும், குறிப்பாக மொபைலில் * அடிக்கடி * சோதிக்கவும். டெச்க்டாப்பில் ஒரு "
"விளையாட்டை உருவாக்குவது, ஆனால் கடைசி நிமிடத்தில் அதை மொபைலுக்கு அனுப்ப முயற்சிப்பது "
"பேரழிவுக்கான செய்முறையாகும்."

msgid ""
"In general, you should design your game for the lowest common denominator, "
"then add optional enhancements for more powerful platforms. For example, you "
"may want to use the Compatibility rendering method for both desktop and "
"mobile platforms where you target both."
msgstr ""
"பொதுவாக, உங்கள் விளையாட்டை மிகக் குறைந்த பொதுவான வகுப்பிற்கு வடிவமைக்க வேண்டும், பின்னர் "
"அதிக சக்திவாய்ந்த தளங்களுக்கு விருப்ப மேம்பாடுகளைச் சேர்க்க வேண்டும். எடுத்துக்காட்டாக, "
"நீங்கள் இரண்டையும் குறிவைக்கும் டெச்க்டாப் மற்றும் மொபைல் தளங்களுக்கு பொருந்தக்கூடிய வழங்குதல் "
"முறையைப் பயன்படுத்த விரும்பலாம்."

msgid "Mobile/tiled renderers"
msgstr "மொபைல்/டைல்ட் ரெண்டரர்கள்"

msgid ""
"As described above, GPUs on mobile devices work in dramatically different "
"ways from GPUs on desktop. Most mobile devices use tile renderers. Tile "
"renderers split up the screen into regular-sized tiles that fit into super "
"fast cache memory, which reduces the number of read/write operations to the "
"main memory."
msgstr ""
"மேலே விவரிக்கப்பட்டுள்ளபடி, மொபைல் சாதனங்களில் உள்ள சி.பீ.யுகள் டெச்க்டாப்பில் "
"சி.பீ.யுகளிலிருந்து வியத்தகு முறையில் வேறுபட்ட வழிகளில் செயல்படுகின்றன. பெரும்பாலான "
"மொபைல் சாதனங்கள் ஓடு ரெண்டரர்களைப் பயன்படுத்துகின்றன. டைல் ரெண்டரர்கள் திரையை வழக்கமான "
"அளவிலான ஓடுகளாகப் பிரிக்கின்றன, அவை சூப்பர் ஃபாச்ட் கேச் நினைவகத்துடன் பொருந்துகின்றன, "
"இது முதன்மையான நினைவகத்திற்கு வாசிப்பு/எழுதும் செயல்பாடுகளின் எண்ணிக்கையை குறைக்கிறது."

msgid ""
"There are some downsides though. Tiled rendering can make certain techniques "
"much more complicated and expensive to perform. Tiles that rely on the "
"results of rendering in different tiles or on the results of earlier "
"operations being preserved can be very slow. Be very careful to test the "
"performance of shaders, viewport textures and post processing."
msgstr ""
"சில தீமைகள் உள்ளன. டைல்ட் வழங்குதல் சில நுட்பங்களை மிகவும் சிக்கலானதாகவும், செய்ய விலை "
"உயர்ந்ததாகவும் மாற்றும். வெவ்வேறு ஓடுகளில் வழங்குதல் செய்வதன் முடிவுகளை நம்பியிருக்கும் "
"ஓடுகள் அல்லது முந்தைய செயல்பாடுகளின் முடிவுகள் மிகவும் மெதுவாக இருக்கும். சேடர்கள், "
"வியூபோர்ட் அமைப்புகள் மற்றும் பிந்தைய செயலாக்கத்தின் செயல்திறனை சோதிக்க மிகவும் கவனமாக "
"இருங்கள்."
