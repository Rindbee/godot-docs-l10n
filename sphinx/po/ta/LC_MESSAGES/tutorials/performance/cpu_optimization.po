#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: ta\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "CPU optimization"
msgstr "சிபியு தேர்வுமுறை"

msgid "Measuring performance"
msgstr "செயல்திறனை அளவிடுதல்"

msgid ""
"We have to know where the \"bottlenecks\" are to know how to speed up our "
"program. Bottlenecks are the slowest parts of the program that limit the "
"rate that everything can progress. Focusing on bottlenecks allows us to "
"concentrate our efforts on optimizing the areas which will give us the "
"greatest speed improvement, instead of spending a lot of time optimizing "
"functions that will lead to small performance improvements."
msgstr ""
"எங்கள் திட்டத்தை எவ்வாறு விரைவுபடுத்துவது என்பதை \"இடையூறுகள்\" எங்கே என்பதை நாம் "
"அறிந்து கொள்ள வேண்டும். எல்லாவற்றையும் முன்னேற்றக்கூடிய விகிதத்தைக் கட்டுப்படுத்தும் "
"திட்டத்தின் மெதுவான பகுதிகள் இடையூறுகள். இடையூறுகளில் கவனம் செலுத்துவது, சிறிய "
"செயல்திறன் மேம்பாடுகளுக்கு வழிவகுக்கும் செயல்பாடுகளை மேம்படுத்துவதற்கு அதிக நேரம் "
"செலவழிப்பதற்குப் பதிலாக, மிகப் பெரிய வேக முன்னேற்றத்தை எங்களுக்கு வழங்கும் பகுதிகளை "
"மேம்படுத்துவதில் எங்கள் முயற்சிகளைக் குவிக்க அனுமதிக்கிறது."

msgid ""
"For the CPU, the easiest way to identify bottlenecks is to use a profiler."
msgstr ""
"சிபியு ஐப் பொறுத்தவரை, தடைகளை அடையாளம் காண எளிதான வழி ஒரு சுயவிவரத்தைப் "
"பயன்படுத்துவதாகும்."

msgid "CPU profilers"
msgstr "சிபியு விவரக்குறிப்புகள்"

msgid ""
"Profilers run alongside your program and take timing measurements to work "
"out what proportion of time is spent in each function."
msgstr ""
"சுயவிவரங்கள் உங்கள் திட்டத்துடன் இயங்குகின்றன, மேலும் ஒவ்வொரு செயல்பாட்டிலும் என்ன நேரம் "
"செலவிடப்படுகின்றன என்பதைச் செய்ய நேர அளவீடுகளை எடுத்துக்கொள்கிறது."

msgid ""
"The Godot IDE conveniently has a built-in profiler. It does not run every "
"time you start your project: it must be manually started and stopped. This "
"is because, like most profilers, recording these timing measurements can "
"slow down your project significantly."
msgstr ""
"கோடோட் ஐடிஇ வசதியாக ஒரு உள்ளமைக்கப்பட்ட விவரக்குறிப்பைக் கொண்டுள்ளது. உங்கள் திட்டத்தைத் "
"தொடங்கும் ஒவ்வொரு முறையும் இது இயங்காது: இது கைமுறையாக தொடங்கப்பட்டு நிறுத்தப்பட "
"வேண்டும். ஏனென்றால், பெரும்பாலான சுயவிவரங்களைப் போலவே, இந்த நேர அளவீடுகளையும் பதிவு "
"செய்வது உங்கள் திட்டத்தை கணிசமாக மெதுவாக்கும்."

msgid "After profiling, you can look back at the results for a frame."
msgstr ""
"சுயவிவரத்திற்குப் பிறகு, ஒரு சட்டகத்திற்கான முடிவுகளை நீங்கள் திரும்பிப் பார்க்கலாம்."

msgid "Screenshot of the Godot profiler"
msgstr "கோடோட் சுயவிவரத்தின் திரை காட்சி"

msgid "Results of a profile of one of the demo projects."
msgstr "டெமோ திட்டங்களில் ஒன்றின் சுயவிவரத்தின் முடிவுகள்."

msgid ""
"We can see the cost of built-in processes such as physics and audio, as well "
"as seeing the cost of our own scripting functions at the bottom."
msgstr ""
"இயற்பியல் மற்றும் ஆடியோ போன்ற உள்ளமைக்கப்பட்ட செயல்முறைகளின் விலையையும், எங்கள் சொந்த "
"ச்கிரிப்டிங் செயல்பாடுகளின் விலையையும் கீழே பார்க்கலாம்."

msgid ""
"Time spent waiting for various built-in servers may not be counted in the "
"profilers. This is a known bug."
msgstr ""
"பல்வேறு உள்ளமைக்கப்பட்ட சேவையகங்களுக்காக காத்திருக்கும் நேரம் விவரக்குறிப்பாளர்களில் "
"கணக்கிடப்படாது. இது அறியப்பட்ட பிழை."

msgid ""
"When a project is running slowly, you will often see an obvious function or "
"process taking a lot more time than others. This is your primary bottleneck, "
"and you can usually increase speed by optimizing this area."
msgstr ""
"ஒரு திட்டம் மெதுவாக இயங்கும்போது, ஒரு வெளிப்படையான செயல்பாடு அல்லது செயல்முறையை "
"மற்றவர்களை விட அதிக நேரம் எடுப்பதை நீங்கள் அடிக்கடி காண்பீர்கள். இது உங்கள் முதன்மை "
"இடையூறாகும், மேலும் இந்த பகுதியை மேம்படுத்துவதன் மூலம் நீங்கள் வழக்கமாக வேகத்தை "
"அதிகரிக்கலாம்."

msgid ""
"For more info about using Godot's built-in profiler, "
"see :ref:`doc_debugger_panel`."
msgstr ""
"கோடோட்டின் உள்ளமைக்கப்பட்ட சுயவிவரத்தைப் பயன்படுத்துவது பற்றிய கூடுதல் தகவலுக்கு, காண்க: "
"குறிப்பு: `doc_debugger_panel`."

msgid "External profilers"
msgstr "வெளிப்புற விவரக்குறிப்புகள்"

msgid ""
"Although the Godot IDE profiler is very convenient and useful, sometimes you "
"need more power, and the ability to profile the Godot engine source code "
"itself."
msgstr ""
"கோடோட் ஐடிஇ விவரக்குறிப்பு மிகவும் வசதியானது மற்றும் பயனுள்ளதாக இருந்தாலும், சில "
"நேரங்களில் உங்களுக்கு அதிக ஆற்றல் தேவை, மேலும் கோடோட் என்சின் மூலக் குறியீட்டை "
"சுயவிவரப்படுத்தும் திறன்."

msgid ""
"You can :ref:`use a number of third-party C++ profilers "
"<doc_using_cpp_profilers>` to do this."
msgstr ""
"உங்களால் முடியும்: ref: `இதைச் செய்ய பல மூன்றாம் தரப்பு சி ++ சுயவிவரங்களை "
"<doc_using_cpp_profilers> ஐப் பயன்படுத்தவும்."

msgid "Screenshot of Callgrind"
msgstr "கால் கிரைண்டின் திரை காட்சி"

msgid "Example results from Callgrind, which is part of Valgrind."
msgstr "வல்கிரைண்டின் ஒரு பகுதியாக இருக்கும் கால் கிரைண்டின் எடுத்துக்காட்டு முடிவுகள்."

msgid ""
"From the left, Callgrind is listing the percentage of time within a function "
"and its children (Inclusive), the percentage of time spent within the "
"function itself, excluding child functions (Self), the number of times the "
"function is called, the function name, and the file or module."
msgstr ""
"இடதுபுறத்தில் இருந்து, கால் கிரைண்ட் ஒரு செயல்பாட்டிற்குள் நேரத்தின் சதவீதத்தையும் அதன் "
"குழந்தைகளையும் (உள்ளடக்கிய) பட்டியலிடுகிறது, செயல்பாட்டிற்குள் செலவழித்த நேரத்தின் "
"விழுக்காடு, குழந்தை செயல்பாடுகளை (சுய) தவிர்த்து, செயல்பாடு எத்தனை முறை "
"அழைக்கப்படுகிறது, செயல்பாட்டு பெயர் , மற்றும் கோப்பு அல்லது தொகுதி."

msgid ""
"In this example, we can see nearly all time is spent under the "
"``Main::iteration()`` function. This is the master function in the Godot "
"source code that is called repeatedly. It causes frames to be drawn, physics "
"ticks to be simulated, and nodes and scripts to be updated. A large "
"proportion of the time is spent in the functions to render a canvas (66%), "
"because this example uses a 2D benchmark. Below this, we see that almost 50% "
"of the time is spent outside Godot code in ``libglapi`` and ``i965_dri`` "
"(the graphics driver). This tells us the a large proportion of CPU time is "
"being spent in the graphics driver."
msgstr ""
"இந்த எடுத்துக்காட்டில், கிட்டத்தட்ட எல்லா நேரமும் `` மெயின் :: மறு செய்கை () `` "
"செயல்பாட்டின் கீழ் செலவிடப்படுவதைக் காணலாம். இது கோடோட் மூலக் குறியீட்டில் உள்ள முதன்மை "
"செயல்பாடு, இது மீண்டும் மீண்டும் அழைக்கப்படுகிறது. இது பிரேம்களை வரையவும், இயற்பியல் உண்ணி "
"உருவகப்படுத்தப்படவும், முனைகள் மற்றும் ச்கிரிப்ட்கள் புதுப்பிக்கப்படவும் காரணமாகிறது. "
"கேன்வாசை (66%) வழங்குவதற்கான செயல்பாடுகளில் அதிக நேரம் செலவிடப்படுகிறது, ஏனெனில் இந்த "
"எடுத்துக்காட்டு 2 டி அளவுகோலைப் பயன்படுத்துகிறது. இதற்குக் கீழே, கிட்டத்தட்ட 50% நேரம் "
"கோடோட் குறியீட்டிற்கு வெளியே `` லிப்க்ளாபி`` மற்றும் `` i965_dri`` (கிராபிக்ச் டிரைவர்) "
"ஆகியவற்றில் செலவிடப்படுவதைக் காண்கிறோம். கிராபிக்ச் டிரைவரில் சிபியு நேரத்தின் "
"பெரும்பகுதி செலவிடப்படுவதாக இது நமக்குக் கூறுகிறது."

msgid ""
"This is actually an excellent example because, in an ideal world, only a "
"very small proportion of time would be spent in the graphics driver. This is "
"an indication that there is a problem with too much communication and work "
"being done in the graphics API. This specific profiling led to the "
"development of 2D batching, which greatly speeds up 2D rendering by reducing "
"bottlenecks in this area."
msgstr ""
"இது உண்மையில் ஒரு சிறந்த எடுத்துக்காட்டு, ஏனென்றால், ஒரு சிறந்த உலகில், கிராபிக்ச் "
"டிரைவரில் மிகச் சிறிய நேரம் மட்டுமே செலவிடப்படும். கிராபிக்ச் ஏபிஐயில் அதிக தொடர்பு "
"மற்றும் பணிகள் செய்யப்படுவதில் சிக்கல் உள்ளது என்பதற்கான அறிகுறியாகும். இந்த குறிப்பிட்ட "
"விவரக்குறிப்பு 2 டி பேட்சிங்கின் வளர்ச்சிக்கு வழிவகுத்தது, இது இந்த பகுதியில் உள்ள "
"இடையூறுகளை குறைப்பதன் மூலம் 2 டி ரெண்டரிங்கை பெரிதும் விரைவுபடுத்துகிறது."

msgid "Manually timing functions"
msgstr "கைமுறையாக நேர செயல்பாடுகள்"

msgid ""
"Another handy technique, especially once you have identified the bottleneck "
"using a profiler, is to manually time the function or area under test. The "
"specifics vary depending on the language, but in GDScript, you would do the "
"following:"
msgstr ""
"மற்றொரு எளிமையான நுட்பம், குறிப்பாக நீங்கள் ஒரு சுயவிவரத்தைப் பயன்படுத்தி இடையூறுகளை "
"அடையாளம் கண்டவுடன், சோதனையின் கீழ் செயல்பாடு அல்லது பகுதியை கைமுறையாக நேரம் "
"ஒதுக்குவது. பிரத்தியேகங்கள் மொழியைப் பொறுத்து வேறுபடுகின்றன, ஆனால் "
"சி.டி.எச்ச்கிரிப்டில், நீங்கள் பின்வருவனவற்றை செய்வீர்கள்:"

msgid ""
"When manually timing functions, it is usually a good idea to run the "
"function many times (1,000 or more times), instead of just once (unless it "
"is a very slow function). The reason for doing this is that timers often "
"have limited accuracy. Moreover, CPUs will schedule processes in a haphazard "
"manner. Therefore, an average over a series of runs is more accurate than a "
"single measurement."
msgstr ""
"கைமுறையாக நேர செயல்பாடுகளாக இருக்கும்போது, வழக்கமாக செயல்பாட்டை பல முறை (1,000 "
"அல்லது அதற்கு மேற்பட்ட முறை) இயக்குவது நல்லது, ஒரு முறை (இது மிகவும் மெதுவான "
"செயல்பாடாக இல்லாவிட்டால்). இதைச் செய்வதற்கான காரணம் என்னவென்றால், டைமர்கள் பெரும்பாலும் "
"மட்டுப்படுத்தப்பட்ட துல்லியத்தைக் கொண்டுள்ளன. மேலும், சிபியு கள் செயல்முறைகளை ஒரு "
"இடையூறாக திட்டமிடும். ஆகையால், தொடர்ச்சியான ரன்களில் சராசரியாக ஒரு அளவீட்டை விட "
"துல்லியமானது."

msgid ""
"As you attempt to optimize functions, be sure to either repeatedly profile "
"or time them as you go. This will give you crucial feedback as to whether "
"the optimization is working (or not)."
msgstr ""
"செயல்பாடுகளை மேம்படுத்த நீங்கள் முயற்சிக்கும்போது, நீங்கள் செல்லும்போது மீண்டும் மீண்டும் "
"சுயவிவரமாகவோ அல்லது நேரம் செய்யவோ மறக்காதீர்கள். தேர்வுமுறை செயல்படுகிறதா (அல்லது "
"இல்லை) என்பதற்கு இது உங்களுக்கு முக்கியமான கருத்துக்களை வழங்கும்."

msgid "Caches"
msgstr "தற்காலிக சேமிப்புகள்"

msgid ""
"CPU caches are something else to be particularly aware of, especially when "
"comparing timing results of two different versions of a function. The "
"results can be highly dependent on whether the data is in the CPU cache or "
"not. CPUs don't load data directly from the system RAM, even though it's "
"huge in comparison to the CPU cache (several gigabytes instead of a few "
"megabytes). This is because system RAM is very slow to access. Instead, CPUs "
"load data from a smaller, faster bank of memory called cache. Loading data "
"from cache is very fast, but every time you try and load a memory address "
"that is not stored in cache, the cache must make a trip to main memory and "
"slowly load in some data. This delay can result in the CPU sitting around "
"idle for a long time, and is referred to as a \"cache miss\"."
msgstr ""
"சிபியு தற்காலிக சேமிப்புகள் குறிப்பாக அறிந்திருக்க வேண்டிய ஒன்று, குறிப்பாக ஒரு "
"செயல்பாட்டின் இரண்டு வெவ்வேறு பதிப்புகளின் நேர முடிவுகளை ஒப்பிடும்போது. தரவு சிபியு "
"தற்காலிக சேமிப்பில் உள்ளதா இல்லையா என்பதைப் பொறுத்தது. சிபியு தற்காலிக சேமிப்புடன் "
"ஒப்பிடுகையில் (சில மெகாபைட்டுகளுக்கு பதிலாக பல சிகாபைட்) மிகப்பெரியதாக இருந்தாலும், "
"கணினி ரேமிலிருந்து நேரடியாக தரவை ஏற்றாது. கணினி ரேம் அணுக மிகவும் மெதுவாக "
"இருப்பதால் தான். அதற்கு பதிலாக, சிபியு கள் கேச் எனப்படும் சிறிய, வேகமான நினைவக "
"வங்கியில் இருந்து தரவை ஏற்றுகின்றன. தற்காலிக சேமிப்பில் இருந்து தரவை ஏற்றுவது மிக "
"வேகமாக உள்ளது, ஆனால் ஒவ்வொரு முறையும் நீங்கள் தற்காலிக சேமிப்பில் சேமிக்கப்படாத நினைவக "
"முகவரியை முயற்சித்து ஏற்றும்போது, தற்காலிக சேமிப்பு முதன்மையான நினைவகத்திற்கு ஒரு "
"பயணத்தை மேற்கொண்டு சில தரவுகளில் மெதுவாக ஏற்ற வேண்டும். இந்த நேரந்தவறுகை சிபியு நீண்ட "
"காலமாக சும்மா உட்கார்ந்திருக்கும், மேலும் இது \"கேச் மிச்\" என்று குறிப்பிடப்படுகிறது."

msgid ""
"This means that the first time you run a function, it may run slowly because "
"the data is not in the CPU cache. The second and later times, it may run "
"much faster because the data is in the cache. Due to this, always use "
"averages when timing, and be aware of the effects of cache."
msgstr ""
"இதன் பொருள் என்னவென்றால், நீங்கள் ஒரு செயல்பாட்டை முதன்முதலில் இயக்கும்போது, அது மெதுவாக "
"இயங்கக்கூடும், ஏனெனில் தரவு சிபியு தற்காலிக சேமிப்பில் இல்லை. இரண்டாவது மற்றும் பின்னர், "
"தரவு தற்காலிக சேமிப்பில் இருப்பதால் இது மிக வேகமாக இயங்கக்கூடும். இதன் காரணமாக, "
"நேரத்தின் போது எப்போதும் சராசரிகளைப் பயன்படுத்துங்கள், மேலும் தற்காலிக சேமிப்பின் "
"விளைவுகளைப் பற்றி எச்சரிக்கையாக இருங்கள்."

msgid ""
"Understanding caching is also crucial to CPU optimization. If you have an "
"algorithm (routine) that loads small bits of data from randomly spread out "
"areas of main memory, this can result in a lot of cache misses, a lot of the "
"time, the CPU will be waiting around for data instead of doing any work. "
"Instead, if you can make your data accesses localised, or even better, "
"access memory in a linear fashion (like a continuous list), then the cache "
"will work optimally and the CPU will be able to work as fast as possible."
msgstr ""
"கேச்சிங்கைப் புரிந்துகொள்வது சிபியு தேர்வுமுறைக்கு முக்கியமானது. முதன்மையான "
"நினைவகத்தின் தோராயமாக பரவியிருக்கும் பகுதிகளிலிருந்து சிறிய பிட் தரவை ஏற்றும் ஒரு "
"வழிமுறை (வழக்கமான) உங்களிடம் இருந்தால், இது நிறைய கேச் மிச்ச்கள், நிறைய நேரம், சிபியு "
"செய்வதற்கு பதிலாக தரவுக்காக காத்திருக்கும் எந்த வேலை. அதற்கு பதிலாக, உங்கள் தரவு "
"அணுகலை ஒரு நேரியல் பாணியில் (தொடர்ச்சியான பட்டியல் போன்றவை) உள்ளூர்மயமாக்கப்பட்ட அல்லது "
"இன்னும் சிறப்பாக அணுக முடிந்தால், கேச் உகந்ததாக செயல்படும், மேலும் சிபியு முடிந்தவரை "
"வேகமாக வேலை செய்ய முடியும்."

msgid ""
"Godot usually takes care of such low-level details for you. For example, the "
"Server APIs make sure data is optimized for caching already for things like "
"rendering and physics. Still, you should be especially aware of caching when "
"writing GDExtensions."
msgstr ""
"கோடோட் பொதுவாக உங்களுக்காக இதுபோன்ற குறைந்த அளவிலான விவரங்களை கவனித்துக்கொள்கிறார். "
"எடுத்துக்காட்டாக, வழங்குதல் மற்றும் இயற்பியல் போன்ற விசயங்களுக்கு ஏற்கனவே தற்காலிக "
"சேமிப்பிற்கு தரவு உகந்ததாக இருப்பதை சேவையக பநிஇ கள் உறுதிப்படுத்துகின்றன. இன்னும், "
"gdextensions ஐ எழுதும் போது நீங்கள் குறிப்பாக தேக்ககத்தைப் பற்றி அறிந்திருக்க வேண்டும்."

msgid "Languages"
msgstr "மொழிகள்"

msgid ""
"Godot supports a number of different languages, and it is worth bearing in "
"mind that there are trade-offs involved. Some languages are designed for "
"ease of use at the cost of speed, and others are faster but more difficult "
"to work with."
msgstr ""
"கோடோட் பல்வேறு மொழிகளை ஆதரிக்கிறது, மேலும் வர்த்தக பரிமாற்றங்கள் உள்ளன என்பதை நினைவில் "
"கொள்ள வேண்டும். சில மொழிகள் வேக செலவில் பயன்பாட்டிற்காக வடிவமைக்கப்பட்டுள்ளன, மற்றவை "
"வேகமானவை, ஆனால் வேலை செய்வது மிகவும் கடினம்."

msgid ""
"Built-in engine functions run at the same speed regardless of the scripting "
"language you choose. If your project is making a lot of calculations in its "
"own code, consider moving those calculations to a faster language."
msgstr ""
"நீங்கள் தேர்ந்தெடுக்கும் ச்கிரிப்டிங் மொழியைப் பொருட்படுத்தாமல் உள்ளமைக்கப்பட்ட இயந்திர "
"செயல்பாடுகள் அதே வேகத்தில் இயங்குகின்றன. உங்கள் திட்டம் அதன் சொந்த குறியீட்டில் நிறைய "
"கணக்கீடுகளைச் செய்தால், அந்த கணக்கீடுகளை வேகமான மொழிக்கு நகர்த்துவதைக் கவனியுங்கள்."

msgid "GDScript"
msgstr "GDSCRIPT"

msgid "C#"
msgstr "சி#"

msgid "Other languages"
msgstr "பிற மொழிகள்"

msgid ""
"Third parties provide support for several other languages, including `Rust "
"<https://github.com/godot-rust/gdext>`_."
msgstr ""
"`துரு <https://github.com/godot-rust/gdext>` _ உள்ளிட்ட பல மொழிகளுக்கு மூன்றாம் "
"தரப்பினர் ஆதரவை வழங்குகிறார்கள்."

msgid "C++"
msgstr "சி ++"

msgid ""
"Godot is written in C++. Using C++ will usually result in the fastest code. "
"However, on a practical level, it is the most difficult to deploy to end "
"users' machines on different platforms. Options for using C++ include "
"GDExtensions and :ref:`custom modules <doc_custom_modules_in_cpp>`."
msgstr ""
"கோடோட் சி ++ இல் எழுதப்பட்டுள்ளது. சி ++ ஐப் பயன்படுத்துவது பொதுவாக வேகமான குறியீட்டை "
"விளைவிக்கும். இருப்பினும், ஒரு நடைமுறை மட்டத்தில், வெவ்வேறு தளங்களில் பயனர்களின் "
"இயந்திரங்களை இறுதி செய்ய மிகவும் கடினம். C ++ ஐப் பயன்படுத்துவதற்கான விருப்பங்கள் "
"gdextensions மற்றும்: ref: `தனிப்பயன் தொகுதிகள் <doc_custom_modules_in_cpp>`."

msgid "Threads"
msgstr "நூல்கள்"

msgid ""
"Consider using threads when making a lot of calculations that can run in "
"parallel to each other. Modern CPUs have multiple cores, each one capable of "
"doing a limited amount of work. By spreading work over multiple threads, you "
"can move further towards peak CPU efficiency."
msgstr ""
"ஒருவருக்கொருவர் இணையாக இயங்கக்கூடிய நிறைய கணக்கீடுகளைச் செய்யும்போது நூல்களைப் "
"பயன்படுத்துவதைக் கவனியுங்கள். நவீன சிபியுக்களில் பல கோர்கள் உள்ளன, ஒவ்வொன்றும் ஒரு "
"குறிப்பிட்ட அளவு வேலைகளைச் செய்ய முடியும். பல நூல்களில் வேலையைப் பரப்புவதன் மூலம், நீங்கள் "
"உச்ச சிபியு செயல்திறனை நோக்கி மேலும் செல்லலாம்."

msgid ""
"The disadvantage of threads is that you have to be incredibly careful. As "
"each CPU core operates independently, they can end up trying to access the "
"same memory at the same time. One thread can be reading to a variable while "
"another is writing: this is called a *race condition*. Before you use "
"threads, make sure you understand the dangers and how to try and prevent "
"these race conditions. Threads can make debugging considerably more "
"difficult."
msgstr ""
"நூல்களின் தீமை என்னவென்றால், நீங்கள் நம்பமுடியாத கவனமாக இருக்க வேண்டும். ஒவ்வொரு சிபியு "
"கோர் சுயாதீனமாக இயங்குவதால், அவை ஒரே நேரத்தில் ஒரே நினைவகத்தை அணுக முயற்சிக்கும். ஒரு "
"நூல் ஒரு மாறிக்கு படிக்கலாம், மற்றொன்று எழுதுகிறது: இது ஒரு *ரேச் நிலை *என்று "
"அழைக்கப்படுகிறது. நீங்கள் நூல்களைப் பயன்படுத்துவதற்கு முன், ஆபத்துகள் மற்றும் இந்த இன "
"நிலைமைகளை எவ்வாறு முயற்சிப்பது மற்றும் தடுப்பது என்பதை உறுதிப்படுத்திக் கொள்ளுங்கள். "
"நூல்கள் பிழைத்திருத்தத்தை மிகவும் கடினமாக்கும்."

msgid "For more information on threads, see :ref:`doc_using_multiple_threads`."
msgstr ""
"நூல்களைப் பற்றிய கூடுதல் தகவலுக்கு, காண்க: ref: `doc_using_multiple_threads`."

msgid "SceneTree"
msgstr "காட்சி"

msgid ""
"Although Nodes are an incredibly powerful and versatile concept, be aware "
"that every node has a cost. Built-in functions such as ``_process()`` and "
"``_physics_process()`` propagate through the tree. This housekeeping can "
"reduce performance when you have a very large numbers of nodes (how many "
"exactly depends on the target platform and can range from thousands to tens "
"of thousands so ensure that you profile performance on all target platforms "
"during development)."
msgstr ""
"முனைகள் நம்பமுடியாத சக்திவாய்ந்த மற்றும் பல்துறை கருத்து என்றாலும், ஒவ்வொரு முனைக்கும் ஒரு "
"செலவு உள்ளது என்பதை அறிந்து கொள்ளுங்கள். `` _PROCESS () `` `மற்றும்` "
"_physics_process () `` மரத்தின் வழியாக பிரச்சாரம் செய்யுங்கள். உங்களிடம் மிகப் பெரிய "
"எண்ணிக்கையிலான முனைகள் இருக்கும்போது இந்த வீட்டு பராமரிப்பு செயல்திறனைக் குறைக்கலாம் "
"(எத்தனை சரியாக இலக்கு தளத்தைப் பொறுத்தது மற்றும் ஆயிரக்கணக்கான முதல் "
"பல்லாயிரக்கணக்கானவர்கள் வரை இருக்கும், எனவே வளர்ச்சியின் போது அனைத்து இலக்கு தளங்களிலும் "
"செயல்திறனை சுயவிவரப்படுத்துவதை உறுதிசெய்க)."

msgid ""
"Each node is handled individually in the Godot renderer. Therefore, a "
"smaller number of nodes with more in each can lead to better performance."
msgstr ""
"ஒவ்வொரு முனையும் கோடோட் ரெண்டரரில் தனித்தனியாக கையாளப்படுகிறது. எனவே, ஒவ்வொன்றிலும் "
"அதிக எண்ணிக்கையிலான முனைகள் சிறந்த செயல்திறனுக்கு வழிவகுக்கும்."

msgid ""
"One quirk of the :ref:`SceneTree <class_SceneTree>` is that you can "
"sometimes get much better performance by removing nodes from the SceneTree, "
"rather than by pausing or hiding them. You don't have to delete a detached "
"node. You can for example, keep a reference to a node, detach it from the "
"scene tree using :ref:`Node.remove_child(node) "
"<class_Node_method_remove_child>`, then reattach it later "
"using :ref:`Node.add_child(node) <class_Node_method_add_child>`. This can be "
"very useful for adding and removing areas from a game, for example."
msgstr ""
"ஒரு நகைச்சுவையானது: ref: `SceseTree <class_scenetree>` என்னவென்றால், சில "
"நேரங்களில் நீங்கள் இடைநிறுத்தப்படுவதையோ அல்லது மறைப்பதையோ விட, காட்சியில் இருந்து "
"முனைகளை அகற்றுவதன் மூலம் மிகச் சிறந்த செயல்திறனைப் பெறலாம். பிரிக்கப்பட்ட முனையை நீங்கள் "
"நீக்க வேண்டியதில்லை. எடுத்துக்காட்டாக, நீங்கள் ஒரு முனைக்கு ஒரு குறிப்பை வைத்து, காட்சி "
"மரத்திலிருந்து அதைப் பயன்படுத்தலாம்: ref: `node.remove_child (முனை) "
"<class_node_method_remove_child>`, பின்னர் அதைப் பயன்படுத்துங்கள்: reattach: "
"`node.add_child (node) class_node_method_add_child> `. எடுத்துக்காட்டாக, ஒரு "
"விளையாட்டிலிருந்து பகுதிகளைச் சேர்ப்பதற்கும் அகற்றுவதற்கும் இது மிகவும் பயனுள்ளதாக "
"இருக்கும்."

msgid ""
"You can avoid the SceneTree altogether by using Server APIs. For more "
"information, see :ref:`doc_using_servers`."
msgstr ""
"சேவையக பநிஇ களைப் பயன்படுத்துவதன் மூலம் நீங்கள் காட்சியை முழுவதுமாக தவிர்க்கலாம். மேலும் "
"தகவலுக்கு, காண்க: ref: `doc_using_servers`."

msgid "Physics"
msgstr "இயற்பியல்"

msgid ""
"In some situations, physics can end up becoming a bottleneck. This is "
"particularly the case with complex worlds and large numbers of physics "
"objects."
msgstr ""
"சில சூழ்நிலைகளில், இயற்பியல் ஒரு தடையாக மாறும். சிக்கலான உலகங்கள் மற்றும் அதிக "
"எண்ணிக்கையிலான இயற்பியல் பொருள்களின் விசயத்தில் இது குறிப்பாக உள்ளது."

msgid "Here are some techniques to speed up physics:"
msgstr "இயற்பியலை விரைவுபடுத்த சில நுட்பங்கள் இங்கே:"

msgid ""
"Try using simplified versions of your rendered geometry for collision "
"shapes. Often, this won't be noticeable for end users, but can greatly "
"increase performance."
msgstr ""
"மோதல் வடிவங்களுக்கு உங்கள் வழங்கப்பட்ட வடிவவியலின் எளிமையான பதிப்புகளைப் பயன்படுத்த "
"முயற்சிக்கவும். பெரும்பாலும், இது இறுதி பயனர்களுக்கு கவனிக்காது, ஆனால் செயல்திறனை "
"பெரிதும் அதிகரிக்கும்."

msgid ""
"Try removing objects from physics when they are out of view / outside the "
"current area, or reusing physics objects (maybe you allow 8 monsters per "
"area, for example, and reuse these)."
msgstr ""
"தற்போதைய பகுதிக்கு வெளியே / வெளியே இருக்கும்போது இயற்பியலில் இருந்து பொருட்களை அகற்ற "
"முயற்சிக்கவும், அல்லது இயற்பியல் பொருள்களை மீண்டும் பயன்படுத்தவும் (ஒருவேளை நீங்கள் ஒரு "
"பகுதிக்கு 8 அரக்கர்களை அனுமதிக்கலாம், எடுத்துக்காட்டாக, இவற்றை மீண்டும் பயன்படுத்தலாம்)."

msgid ""
"Another crucial aspect to physics is the physics tick rate. In some games, "
"you can greatly reduce the tick rate, and instead of for example, updating "
"physics 60 times per second, you may update them only 30 or even 20 times "
"per second. This can greatly reduce the CPU load."
msgstr ""
"இயற்பியலின் மற்றொரு முக்கியமான நற்பொருத்தம் இயற்பியல் டிக் விகிதம். சில விளையாட்டுகளில், "
"நீங்கள் டிக் விகிதத்தை வெகுவாகக் குறைக்கலாம், எடுத்துக்காட்டாக, இயற்பியலை நொடிக்கு 60 "
"முறை புதுப்பிக்க, நீங்கள் அவற்றை 30 அல்லது நொடிக்கு 20 மடங்கு மட்டுமே புதுப்பிக்கலாம். "
"இது சிபியு சுமையை வெகுவாகக் குறைக்கும்."

msgid ""
"The downside of changing physics tick rate is you can get jerky movement or "
"jitter when the physics update rate does not match the frames per second "
"rendered. Also, decreasing the physics tick rate will increase input lag. "
"It's recommended to stick to the default physics tick rate (60 Hz) in most "
"games that feature real-time player movement."
msgstr ""
"இயற்பியல் டிக் வீதத்தை மாற்றுவதன் தீங்கு என்னவென்றால், இயற்பியல் புதுப்பிப்பு வீதம் நொடிக்கு "
"பிரேம்களுடன் பொருந்தாதபோது நீங்கள் செர்கி இயக்கம் அல்லது நடுக்கம் பெறலாம். மேலும், இயற்பியல் "
"டிக் வீதத்தைக் குறைப்பது உள்ளீட்டு பின்னடைவை அதிகரிக்கும். நிகழ்நேர பிளேயர் இயக்கத்தைக் "
"கொண்டிருக்கும் பெரும்பாலான விளையாட்டுகளில் இயல்புநிலை இயற்பியல் டிக் வீதத்துடன் (60 எர்ட்ச்) "
"ஒட்டிக்கொள்ள பரிந்துரைக்கப்படுகிறது."

msgid ""
"The solution to jitter is to use *fixed timestep interpolation*, which "
"involves smoothing the rendered positions and rotations over multiple frames "
"to match the physics. You can either implement this yourself or use a `third-"
"party addon <https://github.com/lawnjelly/smoothing-addon>`__. Performance-"
"wise, interpolation is a very cheap operation compared to running a physics "
"tick. It's orders of magnitude faster, so this can be a significant "
"performance win while also reducing jitter."
msgstr ""
"*நிலையான நேர அட்டவணையின் இடைக்கணிப்பு *ஐப் பயன்படுத்துவதே நடுக்கத்திற்கான தீர்வு, இது "
"இயற்பியலுடன் பொருந்தக்கூடிய பல பிரேம்களில் வழங்கப்பட்ட நிலைகள் மற்றும் சுழற்சிகளை "
"மென்மையாக்குவதை உள்ளடக்கியது. இதை நீங்களே செயல்படுத்தலாம் அல்லது `மூன்றாம் தரப்பு துணை "
"<https://github.com/lawnjelly/smoothing-addon> __. செயல்திறன் வாரியாக, "
"இடைக்கணிப்பு என்பது இயற்பியல் டிக் இயக்குவதை ஒப்பிடும்போது மிகவும் மலிவான செயல்பாடாகும். "
"இது வேகமான ஆர்டர்கள், எனவே இது ஒரு குறிப்பிடத்தக்க செயல்திறன் வெற்றியாக இருக்கும், அதே "
"நேரத்தில் நடுக்கம் குறைகிறது."
