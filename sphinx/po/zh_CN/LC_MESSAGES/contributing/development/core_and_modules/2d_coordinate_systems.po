#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "2D coordinate systems and 2D transforms"
msgstr "2D 坐标系与 2D 变换"

msgid "Introduction"
msgstr "前言"

msgid ""
"This is a detailed overview of the available 2D coordinate systems and 2D "
"transforms that are built in. The basic concepts are covered in :ref:"
"`doc_viewport_and_canvas_transforms`."
msgstr ""
"本文对可用的 2D 坐标系和内置的 2D 变换进行了详细介绍。相关基础概念见 :ref:"
"`doc_viewport_and_canvas_transforms`\\ 。"

msgid ""
":ref:`Transform2D <class_Transform2D>` are matrices that convert coordinates "
"from one coordinate system to an other. In order to use them, it is "
"beneficial to know which coordinate systems are available in Godot. For a "
"deeper understanding, the :ref:`doc_matrices_and_transforms` tutorial offers "
"insights to the underlying functionality."
msgstr ""
":ref:`Transform2D <class_Transform2D>` 是用于在坐标系之间进行转换的矩阵，使用"
"前最好先了解一下 Godot 提供了哪些坐标系。如果需要更深入地了解底层的相关信息，"
"请参考 :ref:`doc_matrices_and_transforms` 教程。"

msgid "Godot 2D coordinate systems"
msgstr "Godot 2D 坐标系"

msgid ""
"The following graphic gives an overview of Godot 2D coordinate systems and "
"the available node-transforms, transform-functions and coordinate-system "
"related functions. At the left is the OS Window Manager screen, at the right "
"are the :ref:`CanvasItems <class_CanvasItem>`. For simplicity reasons this "
"graphic doesn't include :ref:`SubViewport <class_SubViewport>`, :ref:"
"`SubViewportContainer <class_SubViewportContainer>`, :ref:"
"`ParallaxLayer<class_ParallaxLayer>` and :ref:"
"`ParallaxBackground<class_ParallaxBackground>` all of which also influence "
"transforms."
msgstr ""
"下图展示的是 Godot 2D 中的坐标系、节点变换、变换函数、坐标系相关函数的概览。"
"最左侧是操作系统“窗口管理器”的屏幕，最右侧是 :ref:`CanvasItem "
"<class_CanvasItem>`\\ 。简单起见，这张图中没有加入 :ref:`SubViewport "
"<class_SubViewport>`\\ 、\\ :ref:`SubViewportContainer "
"<class_SubViewportContainer>`\\ 、\\ :ref:"
"`ParallaxLayer<class_ParallaxLayer>` 和 :ref:"
"`ParallaxBackground<class_ParallaxBackground>`\\ ，尽管它们也能够影响变换。"

msgid ""
"The graphic is based on a node tree of the following form: ``Root Window "
"(embed Windows)`` ⇒ ``Window (don't embed Windows)`` ⇒ ``CanvasLayer`` ⇒ "
"``CanvasItem`` ⇒ ``CanvasItem`` ⇒ ``CanvasItem``. There are more complex "
"combinations possible, like deeply nested Window and SubViewports, however "
"this example intends to provide an overview of the methodology in general."
msgstr ""
"这张图基于 ``根 Window（内嵌其他窗口）`` ⇒ ``Window（没有内嵌窗口）`` ⇒ "
"``CanvasLayer`` ⇒ ``CanvasItem`` ⇒ ``CanvasItem`` ⇒ ``CanvasItem`` 的节点树绘"
"制。节点树还可以有更加复杂的组合，例如可以让 Window 和 SubViewport 进行更深层"
"的嵌套，不过本示例主要的目的还是展示通用的思考方法。"

msgid "Click graphic to enlarge."
msgstr "单击图片放大。"

msgid "**Item Coordinates**"
msgstr "**Item 坐标**"

msgid ""
"This is the local coordinate system of a :ref:`CanvasItem "
"<class_CanvasItem>`."
msgstr "这是 :ref:`CanvasItem <class_CanvasItem>` 的局部坐标系。"

msgid "**Parent Item Coordinates**"
msgstr "**父 Item 坐标**"

msgid ""
"This is the local coordinate system of the parent's *CanvasItem*. When "
"positioning *CanvasItems* in the *Canvas*, they usually inherit the "
"transformations of their parent *CanvasItems*. An exceptions is :ref:"
"`CanvasItems.top_level <class_CanvasItem_property_top_level>`."
msgstr ""
"这是父级 *CanvasItem* 的局部坐标系。在\\ *画布*\\ 中放置 *CanvasItem* 时，这"
"些画布项会继承父级 *CanvasItem* 的变换。\\ :ref:`CanvasItems.top_level "
"<class_CanvasItem_property_top_level>` 则是例外。"

msgid "**Canvas Coordinates**"
msgstr "**画布坐标**"

msgid ""
"As mentioned in the previous tutorial :ref:`doc_canvas_layers`, there are "
"two types of canvases (*Viewport* canvas and *CanvasLayer* canvas) and both "
"have a canvas coordinate system. These are also called world coordinates. A "
"*Viewport* can contain multiple *Canvases* with different coordinate systems."
msgstr ""
"之前的教程 :ref:`doc_canvas_layers` 中就提到过，画布有两种（\\ *Viewport* 画"
"布和 *CanvasLayer* 画布），两者用的都是画布坐标系。画布坐标也叫世界坐标。一"
"个 *Viewport* 可以包含多个\\ *画布*\\ ，不同画布所使用的坐标系可以不同。"

msgid "**Viewport Coordinates**"
msgstr "**视口坐标**"

msgid "This is the coordinate system of the :ref:`Viewport <class_Viewport>`."
msgstr "这是 :ref:`Viewport <class_Viewport>` 的坐标系。"

msgid "**Camera Coordinates**"
msgstr "**相机坐标**"

msgid ""
"This is only used internally for functionality like 3D-camera ray "
"projections."
msgstr "仅在内部使用，用于实现 3D 相机光线投射等功能。"

msgid "**Embedder Coordinates / Screen Coordinates**"
msgstr "**嵌入器坐标 / 屏幕坐标**"

msgid ""
"Every *Viewport* (*Window* or *SubViewport*) in the scene tree is embedded "
"either in a different node or in the OS Window Manager. This coordinate "
"system's origin is identical to the top-left corner of the *Window* or "
"*SubViewport* and its scale is the one of the embedder or the OS Window "
"Manager."
msgstr ""
"场景树中的各个 *Viewport*\\ （\\ *Window* 或 *SubViewport*\\ ）不是嵌入在其他"
"节点中，就是嵌入在操作系统的“窗口管理器”中。这种坐标系的原点位于 *Window* 或 "
"*SubViewport* 的左上角，缩放与嵌入器或操作系统的“窗口管理器”一致。"

msgid ""
"If the embedder is the OS Window Manager, then they are also called Screen "
"Coordinates."
msgstr "如果嵌入器是操作系统的“窗口管理器”，那么对应的坐标也可以称为屏幕坐标。"

msgid "**Absolute Embedder Coordinates / Absolute Screen Coordinates**"
msgstr "**绝对嵌入器坐标 / 绝对屏幕坐标**"

msgid ""
"The origin of this coordinate system is the top-left corner of the embedding "
"node or the OS Window Manager screen. Its scale is the one of the embedder "
"or the OS Window Manager."
msgstr ""
"这种坐标系的原点是所嵌节点或的操作系统的“窗口管理器”的左上角。缩放与嵌入器或"
"操作系统的“窗口管理器”一致。"

msgid ""
"If the embedder is the OS Window Manager, then they are also called Absolute "
"Screen Coordinates."
msgstr ""
"如果嵌入器是操作系统的“窗口管理器”，那么对应的坐标也可以称为绝对屏幕坐标。"

msgid "Node transforms"
msgstr "节点变换"

msgid ""
"Each of the mentioned nodes have one or more transforms associated with them "
"and the combination of these nodes infer the transforms between the "
"different coordinate systems. With a few exceptions, the transforms are :ref:"
"`Transform2D <class_Transform2D>` and the following list shows details and "
"effects of each of them."
msgstr ""
"此处涉及的节点都有一个或多个变换与之关联，将节点组合后就得到了在不同坐标系之"
"间的变换。除了一些特殊情况之外，变换都是 :ref:`Transform2D "
"<class_Transform2D>`\\ ，下面列出了它们各自的详细信息和作用。"

msgid "**CanvasItem transform**"
msgstr "**CanvasItem 变换**"

msgid "*CanvasItems* are either *Control*-nodes or *Node2D*-nodes."
msgstr "*CanvasItem* 是 *Control* 或 *Node2D* 节点。"

msgid ""
"For *Control* nodes this transform consists of a :ref:`position "
"<class_Control_property_position>` relative to the parent's origin and a :"
"ref:`scale <class_Control_property_scale>` and :ref:`rotation "
"<class_Control_property_rotation>` around a :ref:`pivot point "
"<class_Control_property_pivot_offset>`."
msgstr ""
"*Control* 节点的变换包含相对于父节点原点的位置 :ref:`position "
"<class_Control_property_position>`\\ 、缩放 :ref:`scale "
"<class_Control_property_scale>` 以及围绕\\ :ref:`轴心点 "
"<class_Control_property_pivot_offset>`\\ 的旋转 :ref:`rotation "
"<class_Control_property_rotation>`\\ 。"

msgid ""
"For *Node2D* nodes :ref:`transform <class_Node2D_property_transform>` "
"consists of :ref:`position <class_Node2D_property_position>`, :ref:`rotation "
"<class_Node2D_property_rotation>`, :ref:`scale "
"<class_Node2D_property_scale>` and :ref:`skew <class_Node2D_property_skew>`."
msgstr ""
"*Node2D* 节点的变换为 :ref:`transform <class_Node2D_property_transform>`\\ ，"
"包含位置 :ref:`position <class_Node2D_property_position>`\\ 、\\ 旋转 :ref:"
"`rotation <class_Node2D_property_rotation>`\\ 、\\ 缩放 :ref:`scale "
"<class_Node2D_property_scale>` 以及偏斜 :ref:`skew "
"<class_Node2D_property_skew>`\\ 。"

msgid ""
"The transform affects the item itself and usually also child-*CanvasItems* "
"and in the case of a *SubViewportContainer* it affects the contained "
"*SubViewport*."
msgstr ""
"变换会影响画布项本身，通常还会影响子级的 *CanvasItem*\\ ；如果是 "
"*SubViewportContainer* 的话则会影响其包含的 *SubViewport*\\ 。"

msgid "**CanvasLayer transform**"
msgstr "**CanvasLayer 变换**"

msgid ""
"The *CanvasLayer's* :ref:`transform <class_CanvasLayer_property_transform>` "
"affects all *CanvasItems* within the *CanvasLayer*. It doesn't affect other "
"*CanvasLayers* or *Windows* in its *Viewport*."
msgstr ""
"*CanvasLayer 的*\\ 变换为 :ref:`transform "
"<class_CanvasLayer_property_transform>`\\ ，会影响该 *CanvasLayer* 中的所有 "
"*CanvasItem*\\ ，不会影响所属 *Viewport* 中的其他 *CanvasLayer* 和 "
"*Window*\\ 。"

msgid "**CanvasLayer follow viewport transform**"
msgstr "**CanvasLayer 视口跟随变换**"

msgid "**Viewport canvas transform**"
msgstr "**视口画布变换**"

msgid ""
"The :ref:`canvas transform <class_Viewport_property_canvas_transform>` "
"affects all *CanvasItems* in the *Viewport's* default canvas. It also "
"affects *CanvasLayers*, that have follow viewport transform enabled. The "
"*Viewport's* active :ref:`Camera2D <class_Camera2D>` works by changing this "
"transform. It doesn't affect this *Viewport's* embedded *Windows*."
msgstr ""
":ref:`画布变换 <class_Viewport_property_canvas_transform>`\\ 会影响该\\ "
"*Viewport* 默认画布中的所有 *CanvasItem*\\ ，还会影响启用了“跟随视口变换”的 "
"*CanvasLayer*\\ 。\\ *Viewport* 中活动 :ref:`Camera2D <class_Camera2D>` 的工"
"作原理就是修改这个变换。该变换不会影响 *Viewport* 中嵌套的 *Window*\\ 。"

msgid "**Viewport global canvas transform**"
msgstr "**视口全局画布变换**"

msgid ""
"*Viewports* also have a :ref:`global canvas transform "
"<class_Viewport_property_global_canvas_transform>`. This is the master "
"transform and affects all individual *Canvas Layer* and embedded *Window* "
"transforms. This is primarily used in Godot's CanvasItem Editor."
msgstr ""
"*Viewport* 还具有\\ :ref:`全局画布变换 "
"<class_Viewport_property_global_canvas_transform>`\\ 。这是主变换，会影响所有"
"\\ *CanvasLayer*\\ 和嵌套 *Window* 的变换，主要用于 Godot 的 CanvasItem 编辑"
"器。"

msgid "**Viewport stretch transform**"
msgstr "**视口拉伸变换**"

msgid ""
"Finally, *Viewports* have a *stretch transform*, which is used when resizing "
"or stretching the viewport. This transform is used for :ref:`Windows "
"<class_Window>` as described in :ref:`doc_multiple_resolutions`, but can "
"also be manually set on *SubViewports* by means of :ref:`size "
"<class_SubViewport_property_size>` and :ref:`size_2d_override "
"<class_SubViewport_property_size_2d_override>`. It's :ref:`translation "
"<class_Transform2D_method_get_origin>`, :ref:`rotation "
"<class_Transform2D_method_get_rotation>` and :ref:`skew "
"<class_Transform2D_method_get_skew>` are the default values and it can only "
"have non-default :ref:`scale <class_Transform2D_method_get_scale>`."
msgstr ""
"最后，\\ *Viewport* 拥有\\ *拉伸变换*\\ ，用于调整视口的大小和拉伸。\\ :ref:"
"`doc_multiple_resolutions` 中介绍了 :ref:`Window <class_Window>` 中对该变换的"
"用法，我们还可以通过 :ref:`size <class_SubViewport_property_size>` 和 :ref:"
"`size_2d_override <class_SubViewport_property_size_2d_override>` 手动设置 "
"*SubViewport* 的拉伸变换。平移 :ref:`translation "
"<class_Transform2D_method_get_origin>`\\ 、\\ 旋转 :ref:`rotation "
"<class_Transform2D_method_get_rotation>` 和偏斜 :ref:`skew "
"<class_Transform2D_method_get_skew>` 为默认值，只有缩放 :ref:`scale "
"<class_Transform2D_method_get_scale>` 可以是非默认值。"

msgid "**Window transform**"
msgstr "**窗口变换**"

msgid ""
"In order to scale and position the *Window's* content as described in :ref:"
"`doc_multiple_resolutions`, each :ref:`Window <class_Window>` contains a "
"*window transform*. It is for example responsible for the black bars at the "
"*Window's* sides so that the *Viewport* is displayed with a fixed aspect "
"ratio."
msgstr ""
":ref:`doc_multiple_resolutions` 中提到了 *Window* 内容的缩放和位移，为了实现"
"这种效果，每个 :ref:`Window <class_Window>` 都包含了一个\\ *窗口变换*\\ 。一"
"个例子就是用来实现 *Window* 的黑边，这样 *Viewport* 就能够按照固定的纵横比来"
"显示了。"

msgid "**Window position**"
msgstr "**窗口位置**"

msgid ""
"Every *Window* also has a :ref:`position <class_Window_property_position>` "
"to describe its position within its embedder. The embedder can be another "
"*Viewport* or the OS Window Manager."
msgstr ""
"每个 *Window* 都还有一个 :ref:`position "
"<class_Window_property_position>`\\ ，描述的是它在嵌入器中的位置。嵌入器可以"
"是另一个 *Viewport*\\ ，也可以是操作系统窗口管理器。"

msgid "**SubViewportContainer shrink transform**"
msgstr "**SubViewportContainer 收缩变换**"

msgid ""
":ref:`stretch <class_SubViewportContainer_property_stretch>` together with :"
"ref:`stretch_shrink <class_SubViewportContainer_property_stretch_shrink>` "
"declare for a *SubViewportContainer* if and by what integer factor the "
"contained *SubViewport* should be scaled in comparison to the container's "
"size."
msgstr ""
"*SubViewportContainer* 的 :ref:`stretch "
"<class_SubViewportContainer_property_stretch>` 和 :ref:`stretch_shrink "
"<class_SubViewportContainer_property_stretch_shrink>` 声明的是它所包含的 "
"*SubViewport* 是否使用相对于容器大小的整数级缩放以及对应的缩放系数。"
