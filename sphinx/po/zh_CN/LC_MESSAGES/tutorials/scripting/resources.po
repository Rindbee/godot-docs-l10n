#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Resources"
msgstr "资源"

msgid "Nodes and resources"
msgstr "节点和资源"

msgid ""
"Up to this tutorial, we focused on the :ref:`Node <class_Node>` class in "
"Godot as that's the one you use to code behavior and most of the engine's "
"features rely on it. There is another datatype that is just as "
"important: :ref:`Resource <class_Resource>`."
msgstr ""
"在本教程之前, 我们重点研究Godot中的 :ref:`Node <class_Node>` 类, 因为它是你用"
"来编码行为的类, 并且引擎的大多数功能都依赖于该类. 还有另一个同样重要的数据类"
"型: :ref:`Resource <class_Resource>`."

msgid ""
"*Nodes* give you functionality: they draw sprites, 3D models, simulate "
"physics, arrange user interfaces, etc. **Resources** are **data "
"containers**. They don't do anything on their own: instead, nodes use the "
"data contained in resources."
msgstr ""
"*节点* 为你提供功能: 它们绘制精灵, 3D模型, 模拟物理, 排列用户界面等. **资源"
"** 是 **数据容器** . 它们自己不能做任何事情: 而是, 节点使用资源中包含的数据."

msgid ":ref:`Texture <class_Texture>`"
msgstr ":ref:`Texture <class_Texture>`"

msgid ":ref:`Script <class_Script>`"
msgstr ":ref:`Script <class_Script>`"

msgid ":ref:`Mesh <class_Mesh>`"
msgstr ":ref:`Mesh <class_Mesh>`"

msgid ":ref:`Animation <class_Animation>`"
msgstr ":ref:`Animation <class_Animation>`"

msgid ":ref:`AudioStream <class_AudioStream>`"
msgstr ":ref:`AudioStream <class_AudioStream>`"

msgid ":ref:`Font <class_Font>`"
msgstr ":ref:`Font <class_Font>`"

msgid ":ref:`Translation <class_Translation>`"
msgstr ":ref:`Translation <class_Translation>`"

msgid ""
"When the engine loads a resource from disk, **it only loads it once**. If a "
"copy of that resource is already in memory, trying to load the resource "
"again will return the same copy every time. As resources only contain data, "
"there is no need to duplicate them."
msgstr ""
"当引擎从磁盘加载资源时, **它只加载一次** . 如果该资源的副本已在内存中, 则每次"
"尝试再次加载该资源将返回相同的副本. 由于资源只包含数据, 因此无需复制它们."

msgid "External vs built-in"
msgstr "外部与内置"

msgid "There are two ways to save resources. They can be:"
msgstr "有两种保存资源的方法. 它们是:"

msgid "**External** to a scene, saved on the disk as individual files."
msgstr "**外部** , 对于场景, 作为单独文件保存在磁盘上."

msgid ""
"**Built-in**, saved inside the ``.tscn`` or the ``.scn`` file they're "
"attached to."
msgstr "**内置**\\ ，保存在它们所附加的 ``.tscn`` 或 ``.scn`` 文件内。"

msgid ""
"The path property tells us where the resource comes from. In this case, it "
"comes from a PNG image called ``robi.png``. When the resource comes from a "
"file like this, it is an external resource. If you erase the path or this "
"path is empty, it becomes a built-in resource."
msgstr ""
"``Path`` 属性告诉我们资源来自何处. 在这里, 它来自一个叫 ``robi.png`` 的PNG图"
"像. 当资源来自这样的文件时, 它属于外部资源. 如果你去掉这个路径或此路径为空, "
"则它将成为内置资源."

msgid ""
"The switch between built-in and external resources happens when you save the "
"scene. In the example above, if you erase the path ``\"res://robi.png\"`` "
"and save, Godot will save the image inside the ``.tscn`` scene file."
msgstr ""
"保存场景时, 将在内置资源和外部资源之间进行切换. 在上面的示例中, 如果删除路径 "
"``\"res://robi.png\"`` 并保存,Godot会将图像保存在 ``.tscn`` 场景文件中."

msgid ""
"Even if you save a built-in resource, when you instance a scene multiple "
"times, the engine will only load one copy of it."
msgstr ""
"即使你保存一个内置资源, 当多次实例化一个场景时, 引擎也只会加载该场景的一个副"
"本."

msgid "Loading resources from code"
msgstr "从代码中加载资源"

msgid ""
"There are two ways to load resources from code. First, you can use the "
"``load()`` function anytime:"
msgstr "有两种方法可以从代码加载资源. 首先, 你可以随时使用 ``load()`` 函数:"

msgid "Loading scenes"
msgstr "加载场景"

msgid ""
"This method creates the nodes in the scene's hierarchy, configures them, and "
"returns the root node of the scene. You can then add it as a child of any "
"other node."
msgstr ""
"此方法在场景的层次结构中创建节点, 对其进行配置, 然后返回场景的根节点. 然后, "
"你可以将其添加为任何其他节点的子级."

msgid "Freeing resources"
msgstr "释放资源"

msgid "Creating your own resources"
msgstr "创建自己的资源"

msgid ""
"This comes with many distinct advantages over alternative data structures, "
"such as JSON, CSV, or custom TXT files. Users can only import these assets "
"as a :ref:`Dictionary <class_Dictionary>` (JSON) or as a :ref:`FileAccess "
"<class_FileAccess>` to parse. What sets Resources apart is their inheritance "
"of :ref:`Object <class_Object>`, :ref:`RefCounted <class_RefCounted>`, "
"and :ref:`Resource <class_Resource>` features:"
msgstr ""
"与 JSON、CSV 和自定义 TXT 文件等其他数据结构相比，资源具有许多明显的优势。用"
"户只能将前者导入为 :ref:`Dictionary <class_Dictionary>` (JSON) 或要解析"
"的 :ref:`FileAccess <class_FileAccess>`。而资源则不同，它们继承"
"了 :ref:`Object <class_Object>`、 :ref:`RefCounted <class_RefCounted>` "
"和 :ref:`Resource <class_Resource>` 的如下特性："

msgid ""
"They can define constants, so constants from other data fields or objects "
"are not needed."
msgstr "它们可以定义常量, 因此不需要其他数据字段或对象中的常量."

msgid ""
"They can define methods, including setter/getter methods for properties. "
"This allows for abstraction and encapsulation of the underlying data. If the "
"Resource script's structure needs to change, the game using the Resource "
"need not also change."
msgstr ""
"它们可以定义方法, 包括属性的 ``setter/getter`` 方法. 这允许对基础数据进行抽象"
"和封装. 如果资源脚本的结构需要更改, 则使用资源的游戏则不必更改."

msgid ""
"They can define signals, so Resources can trigger responses to changes in "
"the data they manage."
msgstr "它们可以定义信号, 因此 ``Resources`` 可以触发对所管理数据更改的响应."

msgid ""
"They have defined properties, so users know 100% that their data will exist."
msgstr "它们具有已定义的属性, 因此用户知道其数据将100％存在."

msgid ""
"Resource auto-serialization and deserialization is a built-in Godot Engine "
"feature. Users do not need to implement custom logic to import/export a "
"resource file's data."
msgstr ""
"资源自动序列化和反序列化是一个Godot引擎的内置功能. 用户无需实现自定义逻辑即可"
"导入/导出资源文件的数据."

msgid ""
"Resources can even serialize sub-Resources recursively, meaning users can "
"design even more sophisticated data structures."
msgstr "资源甚至可以递归地序列化子资源, 这意味着用户可以设计更复杂的数据结构."

msgid ""
"Users can save Resources as version-control-friendly text files (\\*.tres). "
"Upon exporting a game, Godot serializes resource files as binary files "
"(\\*.res) for increased speed and compression."
msgstr ""
"用户可以将资源保存为版本控制友好的文本文件(``*.tres``). 导出游戏后,Godot将资"
"源文件序列化为二进制文件(``*.res``), 以提高速度和压缩率."

msgid ""
"Godot Engine's Inspector renders and edits Resource files out-of-the-box. As "
"such, users often do not need to implement custom logic to visualize or edit "
"their data. To do so, double-click the resource file in the FileSystem dock "
"or click the folder icon in the Inspector and open the file in the dialog."
msgstr ""
"Godot 引擎的检查器开箱即用地渲染和编辑资源文件。这样，用户通常不需要实现自定"
"义逻辑即可可视化或编辑其数据。为此，请在文件系统面板中双击资源文件，或在检查"
"器中点击文件夹图标，然后在对话框中打开该文件。"

msgid ""
"They can extend **other** resource types besides just the base Resource."
msgstr "它们可以扩展除基本 Resource 之外的\\ **其他**\\ 资源类型。"

msgid "Godot makes it easy to create custom Resources in the Inspector."
msgstr "Godot 可以轻松地在检查器面板中创建自定义 Resource。"

msgid "Set the ``script`` property in the Inspector to be your script."
msgstr "将检查器中的 ``script`` 属性设置为你的脚本。"

msgid ""
"If the script's language supports :ref:`script classes "
"<doc_gdscript_basics_class_name>`, then it streamlines the process. Defining "
"a name for your script alone will add it to the Inspector's creation dialog. "
"This will auto-add your script to the Resource object you create."
msgstr ""
"如果脚本的语言支持\\ :ref:`脚本类 <doc_gdscript_basics_class_name>`\\ ，则可"
"以简化该过程。仅为脚本定义名称会将其添加到“检查器”的创建对话框。这会将脚本自"
"动添加到你创建的 Resource 对象中。"

msgid ""
"Let's see some examples. Create a :ref:`Resource <class_Resource>` and name "
"it ``bot_stats``. It should appear in your file tab with the full name "
"``bot_stats.tres``. Without a script, it's useless, so let's add some data "
"and logic! Attach a script to it named ``bot_stats.gd`` (or just create a "
"new script, and then drag it to it)."
msgstr ""
"让我们来看一个例子。创建一个 :ref:`Resource <class_Resource>` 然后把它命名为 "
"``bot_stats``\\ 。此时文件面板中会显示全名 ``bot_stats.tres``\\ 。不带脚本的"
"话这个文件没什么意义，那我们就来添加一些数据和逻辑吧！给它附加一个名叫 "
"``bot_stats.gd`` 的脚本（或者新建一个脚本之后把它拖上来）。"

msgid ""
"Now, create a :ref:`CharacterBody3D <class_CharacterBody3D>`, name it "
"``Bot``, and add the following script to it:"
msgstr ""
"然后创建一个 :ref:`CharacterBody3D <class_CharacterBody3D>`\\ ，命名为 "
"``Bot``\\ ，再加一个脚本，内容如下："

msgid ""
"Now, select the :ref:`CharacterBody3D <class_CharacterBody3D>` node which we "
"named ``bot``, and drag&drop the ``bot_stats.tres`` resource onto the "
"Inspector. It should print 10! Obviously, this setup can be used for more "
"advanced features than this, but as long you really understand *how* it all "
"worked, you should figure out everything else related to Resources."
msgstr ""
"现在选中这个名为 ``bot`` 的 :ref:`CharacterBody3D <class_CharacterBody3D>` 节"
"点，将 ``bot_stats.tres`` 资源拖到检查器中。这样就会输出 10 了！很显然，这种"
"做法能够实现比这更加高级的功能，只要你能够理解其中的\\ *原理*\\ ，那么 "
"Resource 相关的东西就是一通百通的了。"

msgid ""
"Resource scripts are similar to Unity's ScriptableObjects. The Inspector "
"provides built-in support for custom resources. If desired though, users can "
"even design their own Control-based tool scripts and combine them with "
"an :ref:`EditorPlugin <class_EditorPlugin>` to create custom visualizations "
"and editors for their data."
msgstr ""
"资源脚本类似于 Unity 的 ScriptableObject。检查器为自定义资源提供内置支持。如"
"果需要的话，用户甚至可以设计自己的基于 Control 控件的工具脚本，并将它们与一"
"个 :ref:`EditorPlugin <class_EditorPlugin>` 结合起来，以为他们的数据创建自定"
"义的可视化和编辑器。"

msgid ""
"Unreal Engine's DataTables and CurveTables are also easy to recreate with "
"Resource scripts. DataTables are a String mapped to a custom struct, similar "
"to a Dictionary mapping a String to a secondary custom Resource script."
msgstr ""
"用 Resource 脚本来模拟虚幻引擎的 DataTable 和 CurveTable 也很容易。DataTable "
"是将字符串映射到了自定义结构体，类似于用字典将字符串映射到次级自定义 "
"Resource 脚本。"

msgid ""
"Instead of inlining the Dictionary values, one could also, alternatively:"
msgstr "除了内联 Dictionary 值之外，还可以选择："

msgid ""
"Import a table of values from a spreadsheet and generate these key-value "
"pairs."
msgstr "从电子表格导入值表并生成这些键值对。"

msgid ""
"Design a visualization within the editor and create a plugin that adds it to "
"the Inspector when you open these types of Resources."
msgstr ""
"在编辑器中设计可视化方法，创建一个简单的插件，在你打开这些类型的 Resource "
"时，将其添加到检查器中。"

msgid ""
"CurveTables are the same thing, except mapped to an Array of float values or "
"a :ref:`Curve <class_Curve>`/:ref:`Curve2D <class_Curve2D>` resource object."
msgstr ""
"CurveTable 是相同的东西，除了映射到一个浮点值数组或一个 :ref:`Curve "
"<class_Curve>`/ :ref:`Curve2D <class_Curve2D>` 资源对象之外。"

msgid ""
"In the example below, Godot would load the ``Node`` script, see that it "
"doesn't extend ``Resource``, and then determine that the script failed to "
"load for the Resource object since the types are incompatible."
msgstr ""
"在下面的示例中，Godot 将加载 ``Node`` 脚本，并看到它没有扩展 "
"``Resource``\\ ，然后判断脚本由于类型不兼容而无法为 Resource 对象加载。"
