#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDScript reference"
msgstr "GDScript 参考"

msgid ""
":ref:`GDScript<doc_gdscript>` is a high-level, `object-oriented <https://"
"en.wikipedia.org/wiki/Object-oriented_programming>`_, `imperative <https://"
"en.wikipedia.org/wiki/Imperative_programming>`_, and `gradually typed "
"<https://en.wikipedia.org/wiki/Gradual_typing>`_ programming language built "
"for Godot. It uses an indentation-based syntax similar to languages like "
"`Python <https://en.wikipedia.org/wiki/Python_%28programming_language%29>`_. "
"Its goal is to be optimized for and tightly integrated with Godot Engine, "
"allowing great flexibility for content creation and integration."
msgstr ""
":ref:`GDScript<doc_gdscript>` 是一种\\ `面向对象 <https://zh.wikipedia.org/"
"wiki/"
"%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1>`_\\ "
"的高级\\ `指令式 <https://zh.wikipedia.org/wiki/"
"%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B>`_\\ \\ `渐进类型 <https://"
"en.wikipedia.org/wiki/Gradual_typing>`_\\ 编程语言，专为 Godot 构建，以与 "
"`Python <https://zh.wikipedia.org/wiki/Python>`_ 等语言类似的缩进结构为其基本"
"语句结构。设计 GDScript 这门语言旨在与 Godot 引擎紧密集成，对 Godot 引擎进行"
"优化，从而为程序内容的创建与继承提供灵活的手段。"

msgid "GDScript is entirely independent from Python and is not based on it."
msgstr "GDScript 与 Python 无关，并不是基于 Python 开发的。"

msgid "History"
msgstr "历史"

msgid ""
"Documentation about GDScript's history has been moved to "
"the :ref:`Frequently Asked Questions <doc_faq_what_is_gdscript>`."
msgstr ""
"关于 GDScript 历史的文档已移至\\ :ref:`常见问题 "
"<doc_faq_what_is_gdscript>`\\ 。"

msgid "Example of GDScript"
msgstr "GDScript 示例"

msgid ""
"Some people can learn better by taking a look at the syntax, so here's an "
"example of how GDScript looks."
msgstr ""
"考虑到部分开发者了解过编程语法，学起GDScript来会较为上手，这里给出一个简单的 "
"GDScript 示例供参考学习。"

msgid ""
"If you have previous experience with statically typed languages such as C, C+"
"+, or C# but never used a dynamically typed one before, it is advised you "
"read this tutorial: :ref:`doc_gdscript_more_efficiently`."
msgstr ""
"如果你以前有过使用 C、C++、C# 等静态类型语言的编程经验，却从未使用过动态类型"
"编程语言，建议阅读此教程：\\ :ref:`doc_gdscript_more_efficiently`\\ 。"

msgid "Identifiers"
msgstr "标识符"

msgid ""
"Any string that restricts itself to alphabetic characters (``a`` to ``z`` "
"and ``A`` to ``Z``), digits (``0`` to ``9``) and ``_`` qualifies as an "
"identifier. Additionally, identifiers must not begin with a digit. "
"Identifiers are case-sensitive (``foo`` is different from ``FOO``)."
msgstr ""
"标识符仅限于含字母字符（ ``a`` 到 ``z`` 和 ``A`` 到 ``Z`` ）、 数字（ ``0`` "
"到 ``9`` ）和下划线 ``_`` 的字符串，不能以数字开头，且大小写敏感（如 ``foo`` "
"和 ``FOO`` 就是两个不同的标识符）。"

msgid ""
"Identifiers may also contain most Unicode characters part of `UAX#31 "
"<https://www.unicode.org/reports/tr31/>`__. This allows you to use "
"identifier names written in languages other than English. Unicode characters "
"that are considered \"confusable\" for ASCII characters and emoji are not "
"allowed in identifiers."
msgstr ""
"标识符现在也允许包含 `UAX#31 <https://www.unicode.org/reports/tr31/>`__ 所提"
"供的部分 Unicode 字符，即现在也可将非英文字符作为标识符使用，而 Unicode 字符"
"中易与 ASCII 字符混淆的字符以及颜文字则无法作为标识符使用。"

msgid "Keywords"
msgstr "关键字"

msgid ""
"The following is the list of keywords supported by the language. Since "
"keywords are reserved words (tokens), they can't be used as identifiers. "
"Operators (like ``in``, ``not``, ``and`` or ``or``) and names of built-in "
"types as listed in the following sections are also reserved."
msgstr ""
"下表为该语言所支持的关键字列表。由于关键字是保留字（词法单元），因此不能用作"
"标识符。运算符（如 ``in``\\ 、\\ ``not``\\ 、\\ ``and``\\ 、\\ ``or``\\ ）及"
"后文中出现的内置类型名称亦为保留字。"

msgid ""
"Keywords are defined in the `GDScript tokenizer <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_ in "
"case you want to take a look under the hood."
msgstr ""
"若想深入了解关键字，可在 `GDScript 词法分析器 <https://github.com/"
"godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp>`_\\ 中"
"找到对于关键字的定义。"

msgid "Keyword"
msgstr "关键字"

msgid "Description"
msgstr "描述"

msgid "if"
msgstr "if"

msgid "See `if/else/elif`_."
msgstr "见 `if/else/elif`_\\ 。"

msgid "elif"
msgstr "elif"

msgid "else"
msgstr "else"

msgid "for"
msgstr "for"

msgid "See for_."
msgstr "见 for_\\ 。"

msgid "while"
msgstr "while"

msgid "See while_."
msgstr "见 while_\\ 。"

msgid "match"
msgstr "match"

msgid "See match_."
msgstr "见 match_\\ 。"

msgid "when"
msgstr "when"

msgid "Used by `pattern guards <Pattern guards_>`_ in ``match`` statements."
msgstr "用于 ``match`` 语句中的\\ `模式防护 <Pattern guards_>`_\\ 。"

msgid "break"
msgstr "break"

msgid "Exits the execution of the current ``for`` or ``while`` loop."
msgstr "退出当前 ``for`` 或 ``while`` 循环的执行。"

msgid "continue"
msgstr "continue"

msgid ""
"Immediately skips to the next iteration of the ``for`` or ``while`` loop."
msgstr "立即跳到 ``for`` 或 ``while`` 循环的下一个迭代。"

msgid "pass"
msgstr "pass"

msgid ""
"Used where a statement is required syntactically but execution of code is "
"undesired, e.g. in empty functions."
msgstr "语法上要求在不希望执行代码的语句中使用，例如在空函数中使用。"

msgid "return"
msgstr "return"

msgid "Returns a value from a function."
msgstr "从函数当中返回一个值。"

msgid "class"
msgstr "class"

msgid "Defines an inner class. See `Inner classes`_."
msgstr "定义内部类。见\\ `内部类`_\\ 。"

msgid "class_name"
msgstr "class_name"

msgid ""
"Defines the script as a globally accessible class with the specified name. "
"See `Registering named classes`_."
msgstr "将脚本定义为具有指定名称的全局可访问类。见\\ `注册具名类`_\\ 。"

msgid "extends"
msgstr "extends"

msgid "Defines what class to extend with the current class."
msgstr "定义当前类的父类。"

msgid "is"
msgstr "is"

msgid ""
"Tests whether a variable extends a given class, or is of a given built-in "
"type."
msgstr "检测变量是否继承自给定的类，或检测该变量是否为给定的内置类型。"

msgid "in"
msgstr "in"

msgid ""
"Tests whether a value is within a string, array, range, dictionary, or node. "
"When used with ``for``, it iterates through them instead of testing."
msgstr ""
"通常情况下用来检测字符串、列表、范围、字典、节点中是否存在某个值，而和 "
"``for`` 关键字连用时，则用于遍历字符串、列表、范围、字典、节点中的内容。"

msgid "as"
msgstr "as"

msgid "Cast the value to a given type if possible."
msgstr "尝试将值转换为给定类型的值。"

msgid "self"
msgstr "self"

msgid "Refers to current class instance. See `self`_."
msgstr "引用当前类实例。见 `self`_\\ 。"

msgid "super"
msgstr "super"

msgid "Resolves the scope of the parent method. See `Inheritance`_."
msgstr "解析父类作用域内的方法。见\\ `继承`_\\ 。"

msgid "signal"
msgstr "signal"

msgid "Defines a signal. See `Signals`_."
msgstr "定义信号。见\\ `信号`_\\ 。"

msgid "func"
msgstr "func"

msgid "Defines a function.  See `Functions`_."
msgstr "定义函数。见\\ `函数`_\\ 。"

msgid "static"
msgstr "static"

msgid "Defines a static function or a static member variable."
msgstr "将一个函数声明为静态函数，或将一个成员变量声明为静态成员变量。"

msgid "const"
msgstr "const"

msgid "Defines a constant. See `Constants`_."
msgstr "定义常量。见\\ `常量`_\\ 。"

msgid "enum"
msgstr "enum"

msgid "Defines an enum. See `Enums`_."
msgstr "定义枚举。见\\ `枚举`_\\ 。"

msgid "var"
msgstr "var"

msgid "Defines a variable. See `Variables`_."
msgstr "定义变量。见\\ `变量`_\\ 。"

msgid "breakpoint"
msgstr "breakpoint"

msgid ""
"Editor helper for debugger breakpoints. Unlike breakpoints created by "
"clicking in the gutter, ``breakpoint`` is stored in the script itself. This "
"makes it persistent across different machines when using version control."
msgstr ""
"用来设置脚本编辑器辅助调试断点的关键字。与在脚本编辑器每行最左侧点击红点所创"
"建的断点不同，\\ ``breakpoint`` 关键字可以储存在脚本内部。在不同设备上使用版"
"本工具进行调试时，由 ``breakpoint`` 关键字创建的断点仍旧有效。"

msgid "preload"
msgstr "preload"

msgid "Preloads a class or variable. See `Classes as resources`_."
msgstr "预加载类或变量。见\\ `类作为资源`_\\ 。"

msgid "await"
msgstr "await"

msgid ""
"Waits for a signal or a coroutine to finish. See `Awaiting signals or "
"coroutines`_."
msgstr "等待信号或协程完成。见\\ `等待信号和协程`_\\ 。"

msgid "yield"
msgstr "yield"

msgid "Previously used for coroutines. Kept as keyword for transition."
msgstr "以前的版本中用于协程，现保留为关键字，以便旧版本迁移至新版本。"

msgid "assert"
msgstr "assert"

msgid ""
"Asserts a condition, logs error on failure. Ignored in non-debug builds. See "
"`Assert keyword`_."
msgstr ""
"断言条件，若断言失败则记录错误。非调试版本中会忽略断言语法。见 `Assert 关键字"
"`_\\ 。"

msgid "void"
msgstr "void"

msgid "Used to represent that a function does not return any value."
msgstr "用于代表函数不返回任何值。"

msgid "PI"
msgstr "PI"

msgid "PI constant."
msgstr "PI（π）常数。"

msgid "TAU"
msgstr "TAU"

msgid "TAU constant."
msgstr "TAU（τ）常数。"

msgid "INF"
msgstr "INF"

msgid "Infinity constant. Used for comparisons and as result of calculations."
msgstr "无穷常量，用于比较和计算结果。"

msgid "NAN"
msgstr "NAN"

msgid ""
"NAN (not a number) constant. Used as impossible result from calculations."
msgstr "NAN（非数）常量，用作计算后不可能得到的结果。"

msgid "Operators"
msgstr "运算符"

msgid ""
"The following is the list of supported operators and their precedence. All "
"binary operators are `left-associative <https://en.wikipedia.org/wiki/"
"Operator_associativity>`_, including the ``**`` operator. This means that "
"``2 ** 2 ** 3`` is equal to ``(2 ** 2) ** 3``. Use parentheses to explicitly "
"specify precedence you need, for example ``2 ** (2 ** 3)``. The ternary ``if/"
"else`` operator is right-associative."
msgstr ""
"下列为 GDScript 所支持的运算符及其运算优先级。所有二进制运算符均为\\ `左结合"
"运算符 <https://en.wikipedia.org/wiki/Operator_associativity>`_\\ ，其中就包"
"括 ``**``\\ ，即 ``2 ** 2 ** 3`` 等价于 ``(2 ** 2) ** 3``\\ 。为避免运算歧"
"义，请使用括号来处理该运算的优先级，如 ``2 ** (2 ** 3)``\\ 。"

msgid "**Operator**"
msgstr "**运算符**"

msgid "**Description**"
msgstr "**描述**"

msgid "``(`` ``)``"
msgstr "``(`` ``)``"

msgid "Grouping (highest priority)"
msgstr "分组（优先级最高）"

msgid ""
"Parentheses are not really an operator, but allow you to explicitly specify "
"the precedence of an operation."
msgstr "括号其实不是运算符，但是能够让你显式指定运算的优先级。"

msgid "``x[index]``"
msgstr "``x[index]``"

msgid "Subscription"
msgstr "下标"

msgid "``x.attribute``"
msgstr "``x.attribute``"

msgid "Attribute reference"
msgstr "属性引用"

msgid "``foo()``"
msgstr "``foo()``"

msgid "Function call"
msgstr "函数调用"

msgid "``await x``"
msgstr "``await x``"

msgid "`Awaiting signals or coroutines`_"
msgstr "`等待信号或协程`_"

msgid "``x is Node``"
msgstr "``x is Node``"

msgid "``x is not Node``"
msgstr "``x is not Node``"

msgid "Type checking"
msgstr "类型检查"

msgid ""
"See also :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` "
"function."
msgstr ""
"另见 :ref:`is_instance_of() <class_@GDScript_method_is_instance_of>` 函数。"

msgid "``x ** y``"
msgstr "``x ** y``"

msgid "Power"
msgstr "幂（乘方）"

msgid ""
"Multiplies ``x`` by itself ``y`` times, similar to calling :ref:`pow() "
"<class_@GlobalScope_method_pow>` function."
msgstr ""
"将 ``x`` 与其自身相乘 ``y`` 次，类似于调用 :ref:`pow() "
"<class_@GlobalScope_method_pow>` 函数。"

msgid "``~x``"
msgstr "``~x``"

msgid "Bitwise NOT"
msgstr "按位取反"

msgid "``+x``"
msgstr "``+x``"

msgid "``-x``"
msgstr "``-x``"

msgid "Identity / Negation"
msgstr "取同 / 取负（相反数）"

msgid "``x * y``"
msgstr "``x * y``"

msgid "``x / y``"
msgstr "``x / y``"

msgid "``x % y``"
msgstr "``x % y``"

msgid "Multiplication / Division / Remainder"
msgstr "乘法/除法/余数"

msgid ""
"The ``%`` operator is additionally used for :ref:`format strings "
"<doc_gdscript_printf>`."
msgstr "``%`` 运算符也用于\\ :ref:`字符串的格式化 <doc_gdscript_printf>`\\ 。"

msgid ""
"**Note:** These operators have the same behavior as C++, which may be "
"unexpected for users coming from Python, JavaScript, etc. See a detailed "
"note after the table."
msgstr ""
"**注意：**\\ 这些运算符的运算机制与其在 C++ 中的运算机制一致，而对于使用 "
"Python、JavaScript 等语言的用户则可能会存在在其意料之外的运算机制，详情见表"
"后。"

msgid "``x + y``"
msgstr "``x + y``"

msgid "``x - y``"
msgstr "``x - y``"

msgid "Addition (or Concatenation) / Subtraction"
msgstr "加法（或连接）/减法"

msgid "``x << y``"
msgstr "``x << y``"

msgid "``x >> y``"
msgstr "``x >> y``"

msgid "Bit shifting"
msgstr "位移位"

msgid "``x & y``"
msgstr "``x & y``"

msgid "Bitwise AND"
msgstr "按位与"

msgid "``x ^ y``"
msgstr "``x ^ y``"

msgid "Bitwise XOR"
msgstr "按位异或"

msgid "``x | y``"
msgstr "``x | y``"

msgid "Bitwise OR"
msgstr "按位或"

msgid "``x == y``"
msgstr "``x == y``"

msgid "``x != y``"
msgstr "``x != y``"

msgid "``x < y``"
msgstr "``x < y``"

msgid "``x > y``"
msgstr "``x > y``"

msgid "``x <= y``"
msgstr "``x <= y``"

msgid "``x >= y``"
msgstr "``x >= y``"

msgid "Comparison"
msgstr "比较"

msgid "See a detailed note after the table."
msgstr "详情见表后。"

msgid "``x in y``"
msgstr "``x in y``"

msgid "``x not in y``"
msgstr "``x not in y``"

msgid "Inclusion checking"
msgstr "检查包含关系"

msgid "``in`` is also used with the for_ keyword as part of the syntax."
msgstr "``in`` 也在 for_ 关键字的语法中使用。"

msgid "``not x``"
msgstr "``not x``"

msgid "``!x``"
msgstr "``!x``"

msgid "Boolean NOT and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“非”及其\\ :ref:`不推荐使用 <boolean_operators>`\\ 的形式"

msgid "``x and y``"
msgstr "``x and y``"

msgid "``x && y``"
msgstr "``x && y``"

msgid "Boolean AND and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“与”及其\\ :ref:`不推荐使用 <boolean_operators>`\\ 的形式"

msgid "``x or y``"
msgstr "``x or y``"

msgid "``x || y``"
msgstr "``x || y``"

msgid "Boolean OR and its :ref:`unrecommended <boolean_operators>` alias"
msgstr "布尔“或”及其\\ :ref:`不推荐使用 <boolean_operators>`\\ 的形式"

msgid "``true_expr if cond else false_expr``"
msgstr "``真表达式 if 条件 else 假表达式``"

msgid "Ternary if/else"
msgstr "三元（目）运算符 if/else"

msgid "``x as Node``"
msgstr "``x as Node``"

msgid "`Type casting <casting_>`_"
msgstr "`类型转换 <casting_>`_"

msgid "``x = y``"
msgstr "``x = y``"

msgid "``x += y``"
msgstr "``x += y``"

msgid "``x -= y``"
msgstr "``x -= y``"

msgid "``x *= y``"
msgstr "``x *= y``"

msgid "``x /= y``"
msgstr "``x /= y``"

msgid "``x **= y``"
msgstr "``x **= y``"

msgid "``x %= y``"
msgstr "``x %= y``"

msgid "``x &= y``"
msgstr "``x &= y``"

msgid "``x |= y``"
msgstr "``x |= y``"

msgid "``x ^= y``"
msgstr "``x ^= y``"

msgid "``x <<= y``"
msgstr "``x <<= y``"

msgid "``x >>= y``"
msgstr "``x >>= y``"

msgid "Assignment (lowest priority)"
msgstr "赋值（优先级最低）"

msgid "You cannot use an assignment operator inside an expression."
msgstr "表达式中不能使用赋值运算符。"

msgid "The behavior of some operators may differ from what you expect:"
msgstr "一些运算符的运算机制可能会与你所预期的运算机制有所不同："

msgid ""
"If both operands of the ``/`` operator are :ref:`int <class_int>`, then "
"integer division is performed instead of fractional. For example ``5 / 2 == "
"2``, not ``2.5``. If this is not desired, use at least one :ref:`float "
"<class_float>` literal (``x / 2.0``), cast (``float(x) / y``), or multiply "
"by ``1.0`` (``x * 1.0 / y``)."
msgstr ""
"若运算符 ``/`` 两端的数值均为 :ref:`int<class_int>`，则进行整数除法而非浮点数"
"除法。例如： ``5 /2 == 2`` 中该算式的结果为 ``2`` 而非 ``2.5``\\ 。若希望进行"
"浮点数运算，请将该运算符两端的其中一个数值的类型改"
"为 :ref:`float<class_float>` ，如直接使用浮点数（ ``x / 2.0`` ）、转换类型"
"（ ``float(x) / y`` ）、乘以 ``1.0`` （ ``x * 1.0 / y`` ）等。"

msgid ""
"The ``%`` operator is only available for ints, for floats use "
"the :ref:`fmod() <class_@GlobalScope_method_fmod>` function."
msgstr ""
"运算符 ``%`` 仅适用于整型数值的取余运算，对于小数的取余运算，请使"
"用 :ref:`fmod() <class_@GlobalScope_method_fmod>` 方法。"

msgid ""
"For negative values, the ``%`` operator and ``fmod()`` use `truncation "
"<https://en.wikipedia.org/wiki/Truncation>`_ instead of rounding towards "
"negative infinity. This means that the remainder has a sign. If you need the "
"remainder in a mathematical sense, use the :ref:`posmod() "
"<class_@GlobalScope_method_posmod>` and :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` functions instead."
msgstr ""
"对于负值，\\ ``%`` 运算符和 ``fmod()`` 函数会使用 `截断算法 <https://"
"en.wikipedia.org/wiki/Truncation>`_ 进行运算，而非向负无穷大舍入，此时余数会"
"带有符号（即余数可能为负）。如果你需要数学意义上的余数，请改"
"用 :ref:`posmod() <class_@GlobalScope_method_posmod>` 和 :ref:`fposmod() "
"<class_@GlobalScope_method_fposmod>` 函数。"

msgid ""
"The ``==`` and ``!=`` operators sometimes allow you to compare values of "
"different types (for example, ``1 == 1.0`` is true), but in other cases it "
"can cause a runtime error. If you're not sure about the types of the "
"operands, you can safely use the :ref:`is_same() "
"<class_@GlobalScope_method_is_same>` function (but note that it is more "
"strict about types and references). To compare floats, use "
"the :ref:`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` "
"and :ref:`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` "
"functions instead."
msgstr ""
"``==`` 和 ``!=`` 运算符在有些情况下允许比较不同类型的值（例如 ``1 == 1.0`` 的"
"结果为真），但在其他情况下可能会发生运行时错误。若你不能确定操作数的类型，可"
"使用 :ref:`is_same() <class_@GlobalScope_method_is_same>` 函数来进行安全比较"
"（但请注意，该函数对类型和引用更加严格）。要比较浮点数，请改"
"用 :ref:`is_equal_approx() <class_@GlobalScope_method_is_equal_approx>` "
"和 :ref:`is_zero_approx() <class_@GlobalScope_method_is_zero_approx>` 函数。"

msgid "Literals"
msgstr "字面量"

msgid "**Example(s)**"
msgstr "**示例**"

msgid "``null``"
msgstr "``null``"

msgid "Null value"
msgstr "空值"

msgid "``false``, ``true``"
msgstr "``false``\\ 、\\ ``true``"

msgid "Boolean values"
msgstr "布尔值"

msgid "``45``"
msgstr "``45``"

msgid "Base 10 integer"
msgstr "十进制整数"

msgid "``0x8f51``"
msgstr "``0x8f51``"

msgid "Base 16 (hexadecimal) integer"
msgstr "十六进制整数"

msgid "``0b101010``"
msgstr "``0b101010``"

msgid "Base 2 (binary) integer"
msgstr "二进制整数"

msgid "``3.14``, ``58.1e-10``"
msgstr "``3.14``\\ 、\\ ``58.1e-10``"

msgid "Floating-point number (real)"
msgstr "浮点数（实数）"

msgid "``\"Hello\"``, ``'Hi'``"
msgstr "``\"Hello\"``\\ 、\\ ``\"Hi\"``"

msgid "Regular strings"
msgstr "常规字符串"

msgid "``\"\"\"Hello\"\"\"``, ``'''Hi'''``"
msgstr "``\"\"\"Hello\"\"\"``\\ 、\\ ``'''Hi'''``"

msgid "Triple-quoted regular strings"
msgstr "常规字符串（用三对引号括住）"

msgid "``r\"Hello\"``, ``r'Hi'``"
msgstr "``r\"Hello\"``\\ 、\\ ``r'Hi'``"

msgid "Raw strings"
msgstr "原始字符串"

msgid "``r\"\"\"Hello\"\"\"``, ``r'''Hi'''``"
msgstr "``r\"\"\"Hello\"\"\"``\\ 、\\ ``r'''Hi'''``"

msgid "Triple-quoted raw strings"
msgstr "原始字符串（用三对引号括住）"

msgid "``&\"name\"``"
msgstr "``&\"name\"``"

msgid ":ref:`StringName <class_StringName>`"
msgstr ":ref:`StringName <class_StringName>`"

msgid "``^\"Node/Label\"``"
msgstr "``^\"Node/Label\"``"

msgid ":ref:`NodePath <class_NodePath>`"
msgstr ":ref:`NodePath <class_NodePath>`"

msgid ""
"There are also two constructs that look like literals, but actually are not:"
msgstr "也有两种长得像字面量，但实际上不是字面量的量："

msgid "**Example**"
msgstr "**示例**"

msgid "``$NodePath``"
msgstr "``$NodePath``"

msgid "Shorthand for ``get_node(\"NodePath\")``"
msgstr "``get_node(\"NodePath\")`` 的简写"

msgid "``%UniqueNode``"
msgstr "``%UniqueNode``"

msgid "Shorthand for ``get_node(\"%UniqueNode\")``"
msgstr "``get_node(\"%UniqueNode\")`` 的简写"

msgid ""
"Integers and floats can have their numbers separated with ``_`` to make them "
"more readable. The following ways to write numbers are all valid:"
msgstr ""
"整数和浮点数中的数字可用 ``_`` 分隔，方便阅读。以下表示数字的方法均有效："

msgid "**Regular string literals** can contain the following escape sequences:"
msgstr "**常规字符串字面量**\\ 内可包含以下转义序列："

msgid "**Escape sequence**"
msgstr "**转义序列**"

msgid "**Expands to**"
msgstr "**转义为**"

msgid "``\\n``"
msgstr "``\\n``"

msgid "Newline (line feed)"
msgstr "换行符"

msgid "``\\t``"
msgstr "``\\t``"

msgid "Horizontal tab character"
msgstr "水平制表符"

msgid "``\\r``"
msgstr "``\\r``"

msgid "Carriage return"
msgstr "回车符"

msgid "``\\a``"
msgstr "``\\a``"

msgid "Alert (beep/bell)"
msgstr "警报（蜂鸣/响铃）"

msgid "``\\b``"
msgstr "``\\b``"

msgid "Backspace"
msgstr "退格键"

msgid "``\\f``"
msgstr "``\\f``"

msgid "Formfeed page break"
msgstr "换页符"

msgid "``\\v``"
msgstr "``\\v``"

msgid "Vertical tab character"
msgstr "垂直制表符"

msgid "``\\\"``"
msgstr "``\\\"``"

msgid "Double quote"
msgstr "双引号"

msgid "``\\'``"
msgstr "``\\'``"

msgid "Single quote"
msgstr "单引号"

msgid "``\\\\``"
msgstr "``\\\\``"

msgid "Backslash"
msgstr "反斜杠"

msgid "``\\uXXXX``"
msgstr "``\\uXXXX``"

msgid "UTF-16 Unicode codepoint ``XXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode UTF-16 码位 ``XXXX``\\ （16进制，不区分大小写）"

msgid "``\\UXXXXXX``"
msgstr "``\\UXXXXXX``"

msgid "UTF-32 Unicode codepoint ``XXXXXX`` (hexadecimal, case-insensitive)"
msgstr "Unicode UTF-32 码位 ``XXXXXX``\\ （16进制，不区分大小写）"

msgid ""
"There are two ways to represent an escaped Unicode character above "
"``0xFFFF``:"
msgstr "有两种方法可以表示 ``0xFFFF`` 以上的转义 Unicode 字符："

msgid ""
"as a `UTF-16 surrogate pair <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX``."
msgstr ""
"使用 `UTF-16 代理对 <https://en.wikipedia.org/wiki/"
"UTF-16#Code_points_from_U+010000_to_U+10FFFF>`_ ``\\uXXXX\\uXXXX`` 表示。"

msgid "as a single UTF-32 codepoint ``\\UXXXXXX``."
msgstr "使用单个 UTF-32 码位 ``\\UXXXXXX`` 表示。"

msgid ""
"Also, using ``\\`` followed by a newline inside a string will allow you to "
"continue it in the next line, without inserting a newline character in the "
"string itself."
msgstr ""
"此外，在字符串中使用 ``\\`` 后换行可以让斜杠后的文字自动换行，而无需在字符串"
"中插入换行符。"

msgid ""
"A string enclosed in quotes of one type (for example ``\"``) can contain "
"quotes of another type (for example ``'``) without escaping. Triple-quoted "
"strings allow you to avoid escaping up to two consecutive quotes of the same "
"type (unless they are adjacent to the string edges)."
msgstr ""
"使用某一种引号（如 ``\"``）构成的字符串，无需转义即可包含另一种引号（如 "
"``'``），而三引号字符串在与其他字符串边缘不相邻的情况下，最多可避免连续两个同"
"种引号的转义。"

msgid ""
"**Raw string literals** always encode the string as it appears in the source "
"code. This is especially useful for regular expressions. A raw string "
"literal doesn't process escape sequences, however it does recognize ``\\\\`` "
"and ``\\\"`` (``\\'``) and replaces them with themselves. Thus, a string can "
"have a quote that matches the opening one, but only if it's preceded by a "
"backslash."
msgstr ""
"**原始字符串字面量**\\ 始终按照源代码中出现的方式对字符串进行编码，特别适用于"
"正则表达式当中。原始字符串虽不处理转义序列，但可以识别 ``\\\\`` 和 ``\\\"`` "
"（ ``\\'`` ）等字符，并将其替换为其自身。一个字符串内可以含有一对相匹配的引"
"号，但这些引号前面必须有一个反斜杠才可以让字符串包含它们。"

msgid ""
"Some strings cannot be represented using raw string literals: you cannot "
"have an odd number of backslashes at the end of a string or have an "
"unescaped opening quote inside the string. However, in practice this doesn't "
"matter since you can use a different quote type or use concatenation with a "
"regular string literal."
msgstr ""
"而有些字符串却不能使用原始字符串字面量来表示：不能在字符串末尾有奇数个反斜"
"杠，不能在字符串内部有未转义的开引号。但在实际应用中，这些问题并不重要，因为"
"你可以通过使用不同类型的引号，或者与普通字符串字面量进行拼接，来解决这个问"
"题。"

msgid "GDScript also supports :ref:`format strings <doc_gdscript_printf>`."
msgstr "GDScript 也支持\\ :ref:`格式字符串 <doc_gdscript_printf>`\\ 。"

msgid "Annotations"
msgstr "注解"

msgid ""
"Annotations are special tokens in GDScript that act as modifiers to a script "
"or its code and may affect how the script is treated by the Godot engine or "
"editor."
msgstr ""
"注解是 GDScript 中的一类特殊标记，用来修饰脚本或脚本中的代码，影响 Godot 引擎"
"或编辑器对该脚本或代码所产生的效果。"

msgid ""
"Every annotation starts with the ``@`` character and is specified by a name. "
"A detailed description and example for each annotation can be found inside "
"the :ref:`GDScript class reference <class_@GDScript>`."
msgstr ""
"注解均以 ``@`` 符号开头，加以注解名称而构成。有关注解的详细说明及其使用范例"
"见 :ref:`GDScript 类参考 <class_@GDScript>`\\ 。"

msgid "For instance, you can use it to export a value to the editor:"
msgstr "例如可以用来将值导出到编辑器："

msgid ""
"For more information about exporting properties, read the :ref:`GDScript "
"exports <doc_gdscript_exports>` article."
msgstr ""
"更多关于导出属性的信息见 :ref:`GDScript 导出属性<doc_gdscript_exports>`\\ 。"

msgid ""
"Any constant expression compatible with the required argument type can be "
"passed as an annotation argument value:"
msgstr "只要与所需参数类型兼容，就可以将常量表达式用作注解的参数值："

msgid ""
"Annotations can be specified one per line or all in the same line. They "
"affect the next statement that isn't an annotation. Annotations can have "
"arguments sent between parentheses and separated by commas."
msgstr ""
"注解既可单行修饰，也可多行修饰，修饰离该注解最近的非注解语句。注解可携带参"
"数，每个参数均在注解名后的括号内，彼此之间用逗号隔开。"

msgid "Both of these are the same:"
msgstr "这两种写法是一样的："

msgid "``@onready`` annotation"
msgstr "``@onready`` 注解"

msgid ""
"When using nodes, it's common to desire to keep references to parts of the "
"scene in a variable. As scenes are only warranted to be configured when "
"entering the active scene tree, the sub-nodes can only be obtained when a "
"call to ``Node._ready()`` is made."
msgstr ""
"使用节点时，经常会需要将场景中某一部分的引用存放在变量中。由于场景只有在进入"
"活动场景树时才会进行正确配置，故而仅在调用 ``Node._ready()`` 时才能获得子节"
"点。"

msgid ""
"This can get a little cumbersome, especially when nodes and external "
"references pile up. For this, GDScript has the ``@onready`` annotation, that "
"defers initialization of a member variable until ``_ready()`` is called. It "
"can replace the above code with a single line:"
msgstr ""
"这样可能很麻烦，尤其是在节点和外部引用越来越多的时候。为了解决这个问题，"
"GDScript 提供了 ``@onready`` 注解，能够将成员变量的初始化推迟到调用 "
"``_ready()`` 时。上面的代码可以替换为一行："

msgid ""
"Applying ``@onready`` and any ``@export`` annotation to the same variable "
"doesn't work as you might expect. The ``@onready`` annotation will cause the "
"default value to be set after the ``@export`` takes effect and will override "
"it:"
msgstr ""
"使用 ``@onready`` 和 ``@export`` 去注解同一个变量并不会如你所愿。\\ "
"``@onready`` 注解会让默认值在 ``@export`` 生效之后设置，导致发生覆盖："

msgid ""
"Therefore, the ``ONREADY_WITH_EXPORT`` warning is generated, which is "
"treated as an error by default. We do not recommend disabling or ignoring it."
msgstr ""
"为此，本引擎提供了 ``ONREADY_WITH_EXPORT`` 警告选项，默认将该操作作为编辑器错"
"误进行处理。我们并不推荐关闭或忽略该警告选项。"

msgid "Comments"
msgstr "注释"

msgid ""
"Anything from a ``#`` to the end of the line is ignored and is considered a "
"comment."
msgstr "从 ``#`` 到行尾的内容都会被忽略，视为注释。"

msgid ""
"In the Godot script editor, special keywords are highlighted within comments "
"to bring the user's attention to specific comments:"
msgstr ""
"Godot 的脚本编辑器会高亮显示注释中的一些特殊关键字，提醒用户注意某些注释："

msgid ""
"**Critical** *(appears in red)*: ``ALERT``, ``ATTENTION``, ``CAUTION``, "
"``CRITICAL``, ``DANGER``, ``SECURITY``"
msgstr ""
"**关键提示**\\ *（标红）*\\ ：\\ ``ALERT``\\ 、\\ ``ATTENTION``\\ 、\\ "
"``CAUTION``\\ 、\\ ``CRITICAL``\\ 、\\ ``DANGER``\\ 、\\ ``SECURITY``"

msgid ""
"**Warning** *(appears in yellow)*: ``BUG``, ``DEPRECATED``, ``FIXME``, "
"``HACK``, ``TASK``, ``TBD``, ``TODO``, ``WARNING``"
msgstr ""
"**警告提示**\\ *（标黄）*\\ ：\\ ``BUG``\\ 、\\ ``DEPRECATED``\\ 、\\ "
"``FIXME``\\ 、\\ ``HACK``\\ 、\\ ``TASK``\\ 、\\ ``TBD``\\ 、\\ ``TODO``\\ 、"
"\\ ``WARNING``"

msgid ""
"**Notice** *(appears in green)*: ``INFO``, ``NOTE``, ``NOTICE``, ``TEST``, "
"``TESTING``"
msgstr ""
"**一般提示**\\ *（标绿）*\\ ：\\ ``INFO``\\ 、\\ ``NOTE``\\ 、\\ "
"``NOTICE``\\ 、\\ ``TEST``\\ 、\\ ``TESTING``"

msgid ""
"These keywords are case-sensitive, so they must be written in uppercase for "
"them to be recognized:"
msgstr "这些关键字大小写敏感，需要全大写才能保证能被引擎识别："

msgid ""
"The list of highlighted keywords and their colors can be changed in the "
"**Text Editor > Theme > Comment Markers** section of the Editor Settings."
msgstr ""
"可以在编辑器设置的 **文本编辑器 > 主题 > 注释标记** 部分中更改突出显示的关键"
"字列表及其颜色。"

msgid ""
"Use two hash symbols (``##``) instead of one (``#``) to add a *documentation "
"comment*, which will appear in the script documentation and in the inspector "
"description of an exported variable. Documentation comments must be placed "
"directly *above* a documentable item (such as a member variable), or at the "
"top of a file. Dedicated formatting options are also available. "
"See :ref:`doc_gdscript_documentation_comments` for details."
msgstr ""
"把一个井号（\\ ``#``\\ ）换成两个（\\ ``##``\\ ）可以添加\\ *文档注释*\\ ，文"
"档注释会在脚本文档和变量的检查器描述中显示。文档注释必须放在可编写文档内容"
"（例如成员变量）的正\\ *上方*\\ 或放在文件的开头。还可以使用专门的格式化选"
"项，详见 :ref:`doc_gdscript_documentation_comments`\\ 。"

msgid "Code regions"
msgstr "代码区块"

msgid ""
"Code regions are special types of comments that the script editor "
"understands as *foldable regions*. This means that after writing code region "
"comments, you can collapse and expand the region by clicking the arrow that "
"appears at the left of the comment. This arrow appears within a purple "
"square to be distinguishable from standard code folding."
msgstr ""
"代码区块是一种特殊类型的注释，脚本编辑器将其理解为\\ *可折叠区块*\\，即在编写"
"代码区块注释后，可以通过点击注释左侧出现的箭头来折叠和展开该区块。该箭头用一"
"个紫色方块包围起来，以区别于标准的代码折叠。"

msgid "The syntax is as follows:"
msgstr "语法如下："

msgid ""
"To create a code region quickly, select several lines in the script editor, "
"right-click the selection then choose **Create Code Region**. The region "
"description will be selected automatically for editing."
msgstr ""
"要快速创建代码区块，请在脚本编辑器中选择若干行，右键点击选区，然后选择\\ **创"
"建代码区块**\\即可。系统将自动选中区块描述以对其进行编辑。"

msgid "It is possible to nest code regions within other code regions."
msgstr "可将代码区块嵌套在其他代码区块内。"

msgid "Here's a concrete usage example of code regions:"
msgstr "以下为代码区块的具体使用示例："

msgid ""
"This can be useful to organize large chunks of code into easier to "
"understand sections. However, remember that external editors generally don't "
"support this feature, so make sure your code is easy to follow even when not "
"relying on folding code regions."
msgstr ""
"代码区块可将大块代码组织成更容易理解的部分。但请注意，外部编辑器通常不支持该"
"特性。因此即便不依赖代码区块，也要确保你的代码易于理解。"

msgid ""
"Individual functions and indented sections (such as ``if`` and ``for``) can "
"*always* be collapsed in the script editor. This means you should avoid "
"using a code region to contain a single function or indented section, as it "
"won't bring much of a benefit. Code regions work best when they're used to "
"group multiple elements together."
msgstr ""
"单独的函数与被缩进的部分（如 ``if`` 和 ``for``\\ ）\\ *始终*\\ 可以在脚本编辑"
"器中折叠，此时应避免使用代码区块来包含这些可始终折叠起来的部分，执意使用亦"
"可，但也并不会带来太多好处。若要将多个元素分组在一起，使用代码区块效果最佳。"

msgid "Line continuation"
msgstr "行间语句接续"

msgid ""
"A line of code in GDScript can be continued on the next line by using a "
"backslash (``\\``). Add one at the end of a line and the code on the next "
"line will act like it's where the backslash is. Here is an example:"
msgstr ""
"在 GDScript 中，一行语句可通过反斜杠（\\ ``\\``\\ ）接续到下一行。将反斜杠加"
"在一行语句末尾可将该行代码与下一行代码相衔接。如："

msgid "A line can be continued multiple times like this:"
msgstr "可按以下方式对单个语句行进行多行接续："

msgid "Built-in types"
msgstr "内置类型"

msgid ""
"Built-in types are stack-allocated. They are passed as values. This means a "
"copy is created on each assignment or when passing them as arguments to "
"functions. The exceptions are ``Object``, ``Array``, ``Dictionary``, and "
"packed arrays (such as ``PackedByteArray``), which are passed by reference "
"so they are shared. All arrays, ``Dictionary``, and some objects (``Node``, "
"``Resource``) have a ``duplicate()`` method that allows you to make a copy."
msgstr ""
"内置类型分配在栈上、按值传递，即每次赋值或将其作为参数传递给函数时均会复制其"
"值。例外是对象 ``Object``\\ 、数组 ``Array``\\ 、字典 ``Dictionary`` 以及紧缩"
"数组（如\\ ``PackedByteArray``\\ ），这些类型的值按引用传递，实例的值相互共"
"享。数组、字典 ``Dictionary`` 以及部分对象（\\ ``Node``\\ 、\\ "
"``Resource``\\ ）均有 ``duplicate()`` 方法，能够用来制作副本。"

msgid "Basic built-in types"
msgstr "基本内置类型"

msgid "A variable in GDScript can be assigned to several built-in types."
msgstr "GDScript 中的变量可赋以不同内置类型的值。"

msgid "null"
msgstr "null"

msgid ""
"``null`` is an empty data type that contains no information and can not be "
"assigned any other value."
msgstr "``null`` 为空数据类型，既不包含任何信息，也不能赋值为其他任何值。"

msgid ""
"Only types that inherit from Object can have a ``null`` value (Object is "
"therefore called a \"nullable\" type). :ref:`Variant types "
"<doc_variant_class>` must have a valid value at all times, and therefore "
"cannot have a ``null`` value."
msgstr ""
"只有继承自 Object 的类型才能具有 ``null`` 值（因此 Object 被称为“可空”类"
"型）。\\ :ref:`Variant 类型 <doc_variant_class>`\\ 的值必须始终有效，因此不能"
"具有 ``null`` 值。"

msgid ":ref:`bool <class_bool>`"
msgstr ":ref:`bool <class_bool>`"

msgid "Short for \"boolean\", it can only contain ``true`` or ``false``."
msgstr "“boolean”（布尔）的缩写，只能包含 ``true`` 或 ``false``\\ 。"

msgid ":ref:`int <class_int>`"
msgstr ":ref:`int<class_int>`"

msgid ""
"Short for \"integer\", it stores whole numbers (positive and negative). It "
"is stored as a 64-bit value, equivalent to ``int64_t`` in C++."
msgstr ""
"英文“integer”（整数）的缩写，存储整数（正整数和负整数）。存储的是 64 位值，等"
"效于 C++ 中的 ``int64_t``\\ 。"

msgid ":ref:`float <class_float>`"
msgstr ":ref:`float<class_float>`"

msgid ""
"Stores real numbers, including decimals, using floating-point values. It is "
"stored as a 64-bit value, equivalent to ``double`` in C++. Note: Currently, "
"data structures such as ``Vector2``, ``Vector3``, and ``PackedFloat32Array`` "
"store 32-bit single-precision ``float`` values."
msgstr ""
"使用浮点值存储实数，包括小数。存储的是 64 位值，等效于 C++ 中的 "
"``double``\\ 。注意：目前 ``Vector2``\\ 、\\ ``Vector3``\\ 、\\ "
"``PackedFloat32Array`` 等数据结构存储的是 32 位单精度 ``float`` 值。"

msgid ":ref:`String <class_String>`"
msgstr ":ref:`String <class_String>`"

msgid ""
"A sequence of characters in `Unicode format <https://en.wikipedia.org/wiki/"
"Unicode>`_."
msgstr ""
"`Unicode 格式 <https://zh.wikipedia.org/zh-cn/Unicode>`_\\ 的字符序列。"

msgid ""
"An immutable string that allows only one instance of each name. They are "
"slower to create and may result in waiting for locks when multithreading. In "
"exchange, they're very fast to compare, which makes them good candidates for "
"dictionary keys."
msgstr ""
"不可变字符串，一个实例仅允许拥有一个名称。该类型的实例创建起来较慢，在多线程"
"环境下可能会导致锁等待。不过，该类型的实例比较起来比字符串快，非常适合在字典"
"中作为键名使用。"

msgid ""
"A pre-parsed path to a node or a node property.  It can be easily assigned "
"to, and from, a String. They are useful to interact with the tree to get a "
"node, or affecting properties like with :ref:`Tweens <class_Tween>`."
msgstr ""
"节点或节点属性的预解析路径，可以轻松地赋值成字符串，亦或从字符串中转换为节点"
"路径。节点路径可用于与节点树交互以获取节点，亦或通过诸如 :ref:`Tween "
"<class_Tween>`\\等方式来影响属性。"

msgid "Vector built-in types"
msgstr "内置向量类型"

msgid ":ref:`Vector2 <class_Vector2>`"
msgstr ":ref:`Vector2 <class_Vector2>`"

msgid ""
"2D vector type containing ``x`` and ``y`` fields. Can also be accessed as an "
"array."
msgstr ""
"2D 向量类型，包含 ``x`` 和 ``y`` 两个字段，也可像访问数组元素一样访问这两个字"
"段。"

msgid ":ref:`Vector2i <class_Vector2i>`"
msgstr ":ref:`Vector2i <class_Vector2i>`"

msgid ""
"Same as a Vector2 but the components are integers. Useful for representing "
"items in a 2D grid."
msgstr "同 Vector2，但其分量均为整型数值，非常适用于制作 2D 网格显示物品功能。"

msgid ":ref:`Rect2 <class_Rect2>`"
msgstr ":ref:`Rect2 <class_Rect2>`"

msgid ""
"2D Rectangle type containing two vectors fields: ``position`` and ``size``. "
"Also contains an ``end`` field which is ``position + size``."
msgstr ""
"2D 矩形类型，包含两个向量字段：\\ ``position`` 和 ``size``\\ 。还包含一个 "
"``end`` 字段，即 ``position + size``\\ 。"

msgid ":ref:`Vector3 <class_Vector3>`"
msgstr ":ref:`Vector3 <class_Vector3>`"

msgid ""
"3D vector type containing ``x``, ``y`` and ``z`` fields. This can also be "
"accessed as an array."
msgstr ""
"3D 向量类型，包含 ``x``\\ 、\\ ``y``\\ 、\\ ``z`` 三个字段，也可以像访问数组"
"元素一样访问这些字段。"

msgid ":ref:`Vector3i <class_Vector3i>`"
msgstr ":ref:`Vector3i <class_Vector3i>`"

msgid ""
"Same as Vector3 but the components are integers. Can be use for indexing "
"items in a 3D grid."
msgstr ""
"同 Vector3 ，但其分量均为整型数值，可用于为 3D 网格中的每个物品编制索引。"

msgid ":ref:`Transform2D <class_Transform2D>`"
msgstr ":ref:`Transform2D <class_Transform2D>`"

msgid "3×2 matrix used for 2D transforms."
msgstr "用于 2D 变换的 3×2 矩阵。"

msgid ":ref:`Plane <class_Plane>`"
msgstr ":ref:`Plane <class_Plane>`"

msgid ""
"3D Plane type in normalized form that contains a ``normal`` vector field and "
"a ``d`` scalar distance."
msgstr ""
"3D 平面类型的标准形式，包含一个向量字段 ``normal`` 以及一个 标量距离 "
"``d``\\ 。"

msgid ":ref:`Quaternion <class_Quaternion>`"
msgstr ":ref:`Quaternion <class_Quaternion>`"

msgid ""
"Quaternion is a datatype used for representing a 3D rotation. It's useful "
"for interpolating rotations."
msgstr "四元数是一种用于表示 3D 旋转的数据类型，对于内插旋转十分有用。"

msgid ":ref:`AABB <class_AABB>`"
msgstr ":ref:`AABB <class_AABB>`"

msgid ""
"Axis-aligned bounding box (or 3D box) contains 2 vectors fields: "
"``position`` and ``size``. Also contains an ``end`` field which is "
"``position + size``."
msgstr ""
"轴对齐边界框（或 3D 框），包含 2 个向量字段：\\ ``position`` 和 ``size``\\ 。"
"还包含一个 ``end`` 字段，即 ``position + size``\\ 。"

msgid ":ref:`Basis <class_Basis>`"
msgstr ":ref:`Basis <class_Basis>`"

msgid ""
"3x3 matrix used for 3D rotation and scale. It contains 3 vector fields "
"(``x``, ``y`` and ``z``) and can also be accessed as an array of 3D vectors."
msgstr ""
"用于 3D 旋转和缩放的 3×3 矩阵，包含 3 个向量字段（\\ ``x``\\ 、\\ ``y``\\ 、"
"\\ ``z``\\ ），可以以 3D 向量数组的形式访问。"

msgid ":ref:`Transform3D <class_Transform3D>`"
msgstr ":ref:`Transform3D <class_Transform3D>`"

msgid ""
"3D Transform contains a Basis field ``basis`` and a Vector3 field ``origin``."
msgstr ""
"3D 线性变换，包含一个 Basis（基）字段 ``basis`` 和一个 Vector3 字段 "
"``origin``\\ 。"

msgid "Engine built-in types"
msgstr "引擎内置类型"

msgid ":ref:`Color <class_Color>`"
msgstr ":ref:`Color <class_Color>`"

msgid ""
"Color data type contains ``r``, ``g``, ``b``, and ``a`` fields. It can also "
"be accessed as ``h``, ``s``, and ``v`` for hue/saturation/value."
msgstr ""
"颜色数据类型包含 ``r``\\ 、\\ ``g``\\ 、\\ ``b``\\ 、\\ ``a`` 四个字段，也可"
"以用 ``h``\\ 、\\ ``s``\\ 、\\ ``v`` 这三个字段来分别访问色相、饱和度、明度。"

msgid ":ref:`RID <class_RID>`"
msgstr ":ref:`RID <class_RID>`"

msgid "Resource ID (RID). Servers use generic RIDs to reference opaque data."
msgstr "资源 ID（RID）。服务器使用通用的 RID 来引用不透明的数据。"

msgid ":ref:`Object <class_Object>`"
msgstr ":ref:`Object <class_Object>`"

msgid "Base class for anything that is not a built-in type."
msgstr "所有非内置类型的基类型。"

msgid "Container built-in types"
msgstr "容器内置类型"

msgid ":ref:`Array <class_Array>`"
msgstr ":ref:`Array <class_Array>`"

msgid ""
"Generic sequence of arbitrary object types, including other arrays or "
"dictionaries (see below). The array can resize dynamically. Arrays are "
"indexed starting from index ``0``. Negative indices count from the end."
msgstr ""
"任意对象类型的泛型序列，包括其他数组或字典（见下文）。数组可以动态调整大小，"
"其索引从 ``0`` 开始，索引为负整数时则表示从数组尾部开始计数。"

msgid "Typed arrays"
msgstr "类型化数组"

msgid ""
"Godot 4.0 added support for typed arrays. On write operations, Godot checks "
"that element values match the specified type, so the array cannot contain "
"invalid values. The GDScript static analyzer takes typed arrays into "
"account, however array methods like ``front()`` and ``back()`` still have "
"the ``Variant`` return type."
msgstr ""
"Godot 4.0 开始支持类型化数组。向类型化数组中写入数据时，Godot 会检查每个元素"
"是否与该数组所指定的类型相匹配，因此类型化数组不能含有无效数据。而诸如 "
"``front()`` 和 ``back()`` 等方法，虽然 GDScript 静态分析器会将类型化数组考虑"
"在内，却仍会返回 ``Variant`` 类型的数值。"

msgid ""
"Typed arrays have the syntax ``Array[Type]``, where ``Type`` can be any "
"``Variant`` type, native or user class, or enum. Nested array types (like "
"``Array[Array[int]]``) are not supported."
msgstr ""
"类型化数组通过 ``Array[Type]`` 指定，其中类型 ``Type`` 可以是 ``Variant`` 类"
"型、内置类型，也可以是用户自定义类型、枚举类型等。不支持类型化数组嵌套（如 "
"``Array[Array[int]]``\\ ）。"

msgid "``Array`` and ``Array[Variant]`` are the same thing."
msgstr "``Array`` 等价于 ``Array[Varaint]``\\ 。"

msgid ""
"Arrays are passed by reference, so the array element type is also an "
"attribute of the in-memory structure referenced by a variable in runtime. "
"The static type of a variable restricts the structures that it can reference "
"to. Therefore, you **cannot** assign an array with a different element type, "
"even if the type is a subtype of the required type."
msgstr ""
"数组是按引用传递的，因此数组元素类型也是运行时变量引用的内存结构的一个属性。"
"变量的静态类型限制了它可以引用的结构。因此，你\\ **不能**\\为数组内的元素赋予"
"不同的元素类型的值，即使该类型是数组所接受类型的子类型。"

msgid ""
"If you want to *convert* a typed array, you can create a new array and use "
"the :ref:`Array.assign() <class_Array_method_assign>` method:"
msgstr ""
"若需要对类型化数组进行\\ *转换*\\ ，可以创建一个新数组并使"
"用 :ref:`Array.assign() <class_Array_method_assign>` 方法："

msgid ""
"The only exception was made for the ``Array`` (``Array[Variant]``) type, for "
"user convenience and compatibility with old code. However, operations on "
"untyped arrays are considered unsafe."
msgstr ""
"``Array`` （ ``Array[Variant]`` ）则是例外，这样做可以保证用户使用的便捷性与"
"与旧版本代码的兼容性。不过，非类型化的数组是不安全的。"

msgid "Packed arrays"
msgstr "紧缩数组"

msgid ""
"PackedArrays are generally faster to iterate on and modify compared to a "
"typed Array of the same type (e.g. PackedInt64Array versus Array[int]) and "
"consume less memory. In the worst case, they are expected to be as fast as "
"an untyped Array. Conversely, non-Packed Arrays (typed or not) have extra "
"convenience methods such as :ref:`Array.map <class_Array_method_map>` that "
"PackedArrays lack. Consult the :ref:`class reference "
"<class_PackedFloat32Array>` for details on the methods available. Typed "
"Arrays are generally faster to iterate on and modify than untyped Arrays."
msgstr ""
"与相同类型的类型化数组 Array 相比，紧缩数组的遍历和修改速度通常更快（例如 "
"PackedInt64Array 与 Array[int] 比较）。即便是最坏的情况，这两种数组也不会比无"
"类型的 Array 慢。不过非紧缩数组（无论是否类型化）都会额外包含类"
"似 :ref:`Array.map <class_Array_method_map>` 的便捷方法，紧缩数组则不提供。具"
"体有哪些方法可用见\\ :ref:`类参考 <class_PackedFloat32Array>`\\ 。类型化数组"
"的遍历和修改速度通常比无类型数组更快。"

msgid ""
"While all Arrays can cause memory fragmentation when they become large "
"enough, if memory usage and performance (iteration and modification speed) "
"is a concern and the type of data you're storing is compatible with one of "
"the ``Packed`` Array types, then using those may yield improvements. "
"However, if you do not have such concerns (e.g. the size of your array does "
"not reach the tens of thousands of elements) it is likely more helpful to "
"use regular or typed Arrays, as they provide convenience methods that can "
"make your code easier to write and maintain (and potentially faster if your "
"data requires such operations a lot). If the data you will store is of a "
"known type (including your own defined classes), prefer to use a typed Array "
"as it may yield better performance in iteration and modification compared to "
"an untyped Array."
msgstr ""
"只要足够大，任何 Array 都可能导致内存的碎片化。如果你需要在意内存占用和性能"
"（迭代速度和修改速度），并且存储的数据类型与某种 ``Packed`` 数组类型兼容，那"
"么使用这些类型有可能带来改进。当然如果你没有这些顾虑（比如数组中的元素达不到"
"数万个），那么使用常规的 Array 或类型化的 Array 可能更方便，因为它们提供了便"
"捷的方法，可以使你的代码更易于编写和维护（如果你的数据需要大量此类操作，也许"
"还能提升速度）。如果你知道要存储什么类型的数据（包括你自己定义的类），那么建"
"议使用类型化数组，因为与无类型数组相比，类型化数组在迭代和修改时可以提供更好"
"的性能。"

msgid ""
":ref:`PackedByteArray <class_PackedByteArray>`: An array of bytes (integers "
"from 0 to 255)."
msgstr ""
":ref:`PackedByteArray <class_PackedByteArray>`\\ ：字节（从 0 到 255 的整数）"
"数组。"

msgid ""
":ref:`PackedInt32Array <class_PackedInt32Array>`: An array of 32-bit "
"integers."
msgstr ":ref:`PackedInt32Array <class_PackedInt32Array>`\\ ：32位整数数组。"

msgid ""
":ref:`PackedInt64Array <class_PackedInt64Array>`: An array of 64-bit "
"integers."
msgstr ":ref:`PackedInt64Array <class_PackedInt64Array>`\\ ：64位整数数组。"

msgid ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`: An array of 32-bit "
"floats."
msgstr ""
":ref:`PackedFloat32Array <class_PackedFloat32Array>`\\ ：32位浮点数数组。"

msgid ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`: An array of 64-bit "
"floats."
msgstr ""
":ref:`PackedFloat64Array <class_PackedFloat64Array>`\\ ：64位浮点数数组。"

msgid ""
":ref:`PackedStringArray <class_PackedStringArray>`: An array of strings."
msgstr ":ref:`PackedStringArray <class_PackedStringArray>`\\ ：字符串数组。"

msgid ""
":ref:`PackedVector2Array <class_PackedVector2Array>`: An array "
"of :ref:`Vector2 <class_Vector2>` values."
msgstr ""
":ref:`PackedVector2Array <class_PackedVector2Array>`\\ ：\\ :ref:`Vector2 "
"<class_Vector2>` 类型的数组。"

msgid ""
":ref:`PackedVector3Array <class_PackedVector3Array>`: An array "
"of :ref:`Vector3 <class_Vector3>` values."
msgstr ""
":ref:`PackedVector3Array <class_PackedVector3Array>`\\ ：\\ :ref:`Vector3 "
"<class_Vector3>` 类型的数组。"

msgid ""
":ref:`PackedVector4Array <class_PackedVector4Array>`: An array "
"of :ref:`Vector4 <class_Vector4>` values."
msgstr ""
":ref:`PackedVector4Array <class_PackedVector4Array>`\\ ：\\ :ref:`Vector4 "
"<class_Vector4>` 类型的数组。"

msgid ""
":ref:`PackedColorArray <class_PackedColorArray>`: An array of :ref:`Color "
"<class_Color>` values."
msgstr ""
":ref:`PackedColorArray <class_PackedColorArray>`\\ ：\\ :ref:`Color "
"<class_Color>` 类型的数组。"

msgid ":ref:`Dictionary <class_Dictionary>`"
msgstr ":ref:`Dictionary <class_Dictionary>`"

msgid "Associative container which contains values referenced by unique keys."
msgstr "关联容器，其内部数值通过与之对应的唯一的键进行引用。"

msgid ""
"Lua-style table syntax is also supported. Lua-style uses ``=`` instead of "
"``:`` and doesn't use quotes to mark string keys (making for slightly less "
"to write). However, keys written in this form can't start with a digit (like "
"any GDScript identifier), and must be string literals."
msgstr ""
"字典也支持 Lua 风格的 table 语法。Lua 风格的 GDScript 字典语法在标记字符串键"
"时，使用的是 ``=`` 而非 ``:``\\ ，且不使用引号（这样要写的东西会稍微少一"
"些）。但请注意，以这种形式编写的键和 GDScript 标识符一样不能以数字开头，且必"
"须为字面量。"

msgid ""
"To add a key to an existing dictionary, access it like an existing key and "
"assign to it:"
msgstr "要向现有字典添加键，可以像访问现有键一样访问要添加的键，并给其赋值："

msgid ""
"The bracket syntax can be used to access properties of "
"any :ref:`class_Object`, not just Dictionaries. Keep in mind it will cause a "
"script error when attempting to index a non-existing property. To avoid "
"this, use the :ref:`Object.get() <class_Object_method_get>` "
"and :ref:`Object.set() <class_Object_method_set>` methods instead."
msgstr ""
"方括号语法不仅可以用在 Dictionary 上，而且还可以用来存取任"
"何 :ref:`class_Object` 的属性。不过要注意：尝试读取不存在的属性会引发脚本错"
"误。要避免这一点，可换用 :ref:`Object.get() <class_Object_method_get>` "
"和 :ref:`Object.set() <class_Object_method_set>` 方法。"

msgid "Typed dictionaries"
msgstr "类型化字典"

msgid ""
"Godot 4.4 added support for typed dictionaries. On write operations, Godot "
"checks that element keys and values match the specified type, so the "
"dictionary cannot contain invalid keys or values. The GDScript static "
"analyzer takes typed dictionaries into account. However, dictionary methods "
"that return values still have the ``Variant`` return type."
msgstr ""
"Godot 4.4 添加了对类型化字典的支持。写入时，Godot 会检查元素的键、值是否与指"
"定的类型匹配，这样字典中就不会包含无效的键、值了。GDScript 静态分析器也会考虑"
"类型化字典。不过字典中能够将值返回的方法返回的仍然是 ``Variant`` 类型。"

msgid ""
"Typed dictionaries have the syntax ``Dictionary[KeyType, ValueType]``, where "
"``KeyType`` and ``ValueType`` can be any ``Variant`` type, native or user "
"class, or enum. Both the key and value type **must** be specified, but you "
"can use ``Variant`` to make either of them untyped. Nested typed collections "
"(like ``Dictionary[String, Dictionary[String, int]]``) are not supported."
msgstr ""
"类型化字典的语法为 ``Dictionary[键类型, 值类型]``\\ ，其中 ``键类型`` 和 ``值"
"类型`` 可以是任意 ``Variant`` 类型、原生类和用户类、枚举。键和值的类型\\ **必"
"须**\\ 同时指定，不过两者都可以用 ``Variant`` 来忽略类型。不支持嵌套的类型化"
"合集（例如 ``Dictionary[String, Dictionary[String, int]]``\\ ）。"

msgid "``Dictionary`` and ``Dictionary[Variant, Variant]`` are the same thing."
msgstr "``Dictionary`` 和 ``Dictionary[Variant, Variant]`` 是一样的。"

msgid ":ref:`Signal <class_Signal>`"
msgstr ":ref:`Signal <class_Signal>`"

msgid ""
"A signal is a message that can be emitted by an object to those who want to "
"listen to it. The Signal type can be used for passing the emitter around."
msgstr ""
"信号由对象发出，并由对象所监听。Signal 类型可以用于将信号广播者作为参数进行传"
"递。"

msgid ""
"Signals are better used by getting them from actual objects, e.g. "
"``$Button.button_up``."
msgstr "信号可以直接从对象实例中进行引用，如 ``$Button.button_up``\\ 。"

msgid ":ref:`Callable <class_Callable>`"
msgstr ":ref:`Callable <class_Callable>`"

msgid ""
"Contains an object and a function, which is useful for passing functions as "
"values (e.g. when connecting to signals)."
msgstr ""
"可调用体包含一个对象及其某个函数，适用于将函数作为数值传递（例如：将可调用体"
"用于信号连接）。"

msgid ""
"Getting a method as a member returns a callable. ``var x = "
"$Sprite2D.rotate`` will set the value of ``x`` to a callable with "
"``$Sprite2D`` as the object and ``rotate`` as the method."
msgstr ""
"像获取类成员一样获取方法就会返回可调用体。\\ ``var x = $Sprite2D.rotate`` 就"
"会将 ``x`` 赋值为一个可调用体，该可调用体含有 ``$Sprite2D`` 对象及其方法 "
"``rotate``\\ 。"

msgid "You can call it using the ``call`` method: ``x.call(PI)``."
msgstr ""
"可以调用 ``call`` 方法来调用可调体所指向的方法，如： ``x.call(PI)``\\ 。"

msgid "Variables"
msgstr "变量"

msgid ""
"Variables can exist as class members or local to functions. They are created "
"with the ``var`` keyword and may, optionally, be assigned a value upon "
"initialization."
msgstr ""
"变量可以作为类成员存在，也可以作为函数的局部变量存在，用 ``var`` 关键字创建，"
"可以在初始化时指定一个值。"

msgid ""
"Variables can optionally have a type specification. When a type is "
"specified, the variable will be forced to have always that same type, and "
"trying to assign an incompatible value will raise an error."
msgstr ""
"变量可进行类型指定。指定类型时，将强制该变量始终容纳与被指定类型相同类型的数"
"据。试图分配与该类型不兼容的值将触发报错。"

msgid ""
"Types are specified in the variable declaration using a ``:`` (colon) symbol "
"after the variable name, followed by the type."
msgstr "在变量声明中，在变量名后面使用 ``:``\\ （冒号）+ 类型名 来指定类型。"

msgid ""
"If the variable is initialized within the declaration, the type can be "
"inferred, so it's possible to omit the type name:"
msgstr "如果在声明中初始化变量，则可以推断变量类型，在此情况下可省略类型名称："

msgid ""
"Type inference is only possible if the assigned value has a defined type, "
"otherwise it will raise an error."
msgstr "类型推断只有在指定的值具有定义的类型时才能通过检查，否则将触发报错。"

msgid "Valid types are:"
msgstr "有效的类型有："

msgid "Built-in types (Array, Vector2, int, String, etc.)."
msgstr "内置类型（如 Array 、 Vector2、 int、 String 等）。"

msgid "Engine classes (Node, Resource, RefCounted, etc.)."
msgstr "引擎类（Node、Resource、RefCounted 等）。"

msgid ""
"Constant names if they contain a script resource (``MyScript`` if you "
"declared ``const MyScript = preload(\"res://my_script.gd\")``)."
msgstr ""
"包含脚本资源的常量名（如 ``MyScript`` ，前提是声明了 ``const MyScript = "
"preload(\"res://my_script.gd\")`` ）。"

msgid ""
"Other classes in the same script, respecting scope "
"(``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the "
"``class InnerClass`` in the same scope)."
msgstr ""
"在同一个脚本中的其他内部类，此时需要注意作用域（比如：在相同作用域内，在 "
"``class InnerClass`` 中声明 ``class NestedClass`` 则会得到 "
"``InnerClass.NestedClass`` ）。"

msgid "Script classes declared with the ``class_name`` keyword."
msgstr "通过 ``class_name`` 关键字声明的脚本类。"

msgid "Autoloads registered as singletons."
msgstr "自动加载的节点——单例节点。"

msgid ""
"While ``Variant`` is a valid type specification, it's not an actual type. It "
"only means there's no set type and is equivalent to not having a static type "
"at all. Therefore, inference is not allowed by default for ``Variant``, "
"since it's likely a mistake."
msgstr ""
"虽然 ``Variant`` 类型被引擎视作有效类型，但其并不是一个确切的类型，只是一个"
"“没有固定类型”的代名词。使用 ``Variant`` 类型很有可能会导致报错，因此引擎默认"
"不会对该类型进行推断。"

msgid ""
"You can turn off this check, or make it only a warning, by changing it in "
"the project settings. See :ref:`doc_gdscript_warning_system` for details."
msgstr ""
"你可以在项目设置中将该检查关闭，或将其设为警告。详"
"见 :ref:`doc_gdscript_warning_system`\\。"

msgid "Initialization order"
msgstr "初始化顺序"

msgid "Member variables are initialized in the following order:"
msgstr "成员变量的初始化顺序如下："

msgid ""
"Depending on the variable's static type, the variable is either ``null`` "
"(untyped variables and objects) or has a default value of the type (``0`` "
"for ``int``, ``false`` for ``bool``, etc.)."
msgstr ""
"变量根据其静态类型，取值为 ``null``\\ （无类型变量和对象）或类型的默认值（\\ "
"``int``\\ 为 ``0``\\ 、\\ ``bool``\\ 为\\ ``false``\\ 等）。"

msgid ""
"The specified values are assigned in the order of the variables in the "
"script, from top to bottom."
msgstr "根据脚本中变量的声明顺序，由上至下进行指定值的赋值。"

msgid ""
"(Only for ``Node``-derived classes) If the ``@onready`` annotation is "
"applied to a variable, its initialization is deferred to step 5."
msgstr ""
"（仅适用于派生自 ``Node`` 的类）如果变量由 ``@onready`` 注解修饰，则会推迟到"
"第 5 步再初始化。"

msgid "If defined, the ``_init()`` method is called."
msgstr "所有非 ``@onready`` 成员变量均完成定义时调用 ``_init()`` 方法。"

msgid ""
"When instantiating scenes and resources, the exported values are assigned."
msgstr "初始化场景和资源时，赋导出的值。"

msgid ""
"(Only for ``Node``-derived classes) ``@onready`` variables are initialized."
msgstr "（仅适用于派生自 ``Node`` 的类）初始化 ``@onready`` 变量。"

msgid ""
"(Only for ``Node``-derived classes) If defined, the ``_ready()`` method is "
"called."
msgstr ""
"（仅适用于派生自 ``Node`` 的类）如果定义了 ``_ready()`` 方法，则会对其进行调"
"用。"

msgid ""
"You can specify a complex expression as a variable initializer, including "
"function calls. Make sure the variables are initialized in the correct "
"order, otherwise your values may be overwritten. For example:"
msgstr ""
"复杂表达式也能够作为变量的初始化器，其中也包括函数调用。请确保初始化变量时变"
"量的声明顺序正确，否则对应的值可能会被覆盖。例如："

msgid "Will print:"
msgstr "会在控制台中打印出："

msgid ""
"To fix this, move the ``_data`` variable definition above the ``a`` "
"definition or remove the empty dictionary assignment (``= {}``)."
msgstr ""
"解决这个问题只需将 ``_data`` 变量的定义移动到 ``a`` 的定义之前，或者移除空字"
"典的赋值（\\ ``={}``\\ ）。"

msgid "Static variables"
msgstr "静态变量"

msgid "A class member variable can be declared static:"
msgstr "成员变量可以声明为静态成员变量："

msgid ""
"Static variables belong to the class, not instances. This means that static "
"variables share values between multiple instances, unlike regular member "
"variables."
msgstr ""
"静态变量直属于类而非类的实例，即静态变量可以在多个类实例之间共享数据，这一点"
"与一般的成员变量有所区别。"

msgid ""
"From inside a class, you can access static variables from any function, both "
"static and non-static. From outside the class, you can access static "
"variables using the class or an instance (the second is not recommended as "
"it is less readable)."
msgstr ""
"在类内，静态函数和非静态函数都可以访问静态变量。在类外，可以通过使用类名或类"
"的实例来访问静态变量（后者并不推荐，因为可读性较低）。"

msgid ""
"The ``@export`` and ``@onready`` annotations cannot be applied to a static "
"variable. Local variables cannot be static."
msgstr ""
"``@export`` 注解和 ``@onready`` 注解不能修饰静态成员变量。局部变量不能声明为"
"静态局部变量。"

msgid ""
"The following example defines a ``Person`` class with a static variable "
"named ``max_id``. We increment the ``max_id`` in the ``_init()`` function. "
"This makes it easy to keep track of the number of ``Person`` instances in "
"our game."
msgstr ""
"下面的例子中定义了一个 ``Person`` 类，其中有一个静态变量 ``max_id``\\ 。我们"
"在 ``_init()`` 函数中为 ``max_id`` 加一。这样就能够很方便地记录游戏中 "
"``Person`` 实例的数量。"

msgid ""
"In this code, we create two instances of our ``Person`` class and check that "
"the class and every instance have the same ``max_id`` value, because the "
"variable is static and accessible to every instance."
msgstr ""
"下面我们创建两个 ``Person`` 类的实例，会发现类和实例具有相同的 ``max_id`` "
"值，这是因为该成员变量是静态成员变量，能够在每个实例中访问。"

msgid "Static variables can have type hints, setters and getters:"
msgstr "静态变量可以指定类型、设置 setter 函数和 getter 函数："

msgid "A base class static variable can also be accessed via a child class:"
msgstr "父类的静态成员变量也可以在子类中访问："

msgid ""
"When referencing a static variable from a tool script, the other script "
"containing the static variable **must** also be a tool script. "
"See :ref:`Running code in the editor "
"<doc_running_code_in_the_editor_important_information>` for details."
msgstr ""
"工具脚本引用静态变量时，包含该静态变量的脚本\\ **必须**\\ 同为工具脚本。详见"
"《\\ :ref:`在编辑器中运行代码 "
"<doc_running_code_in_the_editor_important_information>`\\ 》。"

msgid "``@static_unload`` annotation"
msgstr "``@static_unload`` 注解"

msgid ""
"Since GDScript classes are resources, having static variables in a script "
"prevents it from being unloaded even if there are no more instances of that "
"class and no other references left. This can be important if static "
"variables store large amounts of data or hold references to other project "
"resources, such as scenes. You should clean up this data manually, or use "
"the :ref:`@static_unload <class_@GDScript_annotation_@static_unload>` "
"annotation if static variables don't store important data and can be reset."
msgstr ""
"GDScript 的类均为资源，而静态变量会阻止脚本资源卸载，即便该脚本所对应的类的实"
"例以及对该实例引用并不存在，静态变量依旧会阻止该脚本资源卸载。在静态变量存储"
"大量数据，同时还含有对其他对象的引用（比如场景）的情况下，更需要引起格外重"
"视。你需要手动清理掉这些数据，亦或是使用 :ref:`@static_unload "
"<class_@GDScript_annotation_@static_unload>` 注解，让静态变量在不存储重要数据"
"时得到重置。"

msgid ""
"Currently, due to a bug, scripts are never freed, even if ``@static_unload`` "
"annotation is used."
msgstr ""
"目前由于某个漏洞导致含静态成员变量的脚本实例即使使用了 ``@static_unload`` 注"
"解也无法被清除的问题。"

msgid ""
"Note that ``@static_unload`` applies to the entire script (including inner "
"classes) and must be placed at the top of the script, before ``class_name`` "
"and ``extends``:"
msgstr ""
"请注意，\\ ``@static_unload`` 注解修饰的是整个脚本（包括内部类），必须置于脚"
"本最开头，位于 ``class_name`` 和 ``extends`` 关键字之前："

msgid "See also `Static functions`_ and `Static constructor`_."
msgstr "亦可见 `静态函数`_ 和 `静态构造函数`_ 。"

msgid "Casting"
msgstr "类型转换"

msgid ""
"Values assigned to typed variables must have a compatible type. If it's "
"needed to coerce a value to be of a certain type, in particular for object "
"types, you can use the casting operator ``as``."
msgstr ""
"赋予给指定了类型的变量的值必须具有与其类型相兼容的类型。若需要将值强制转换为"
"特定类型，特别是对于对象类型而言要进行转型，则可以使用强制转型运算符 "
"``as``\\。"

msgid ""
"Casting between object types results in the same object if the value is of "
"the same type or a subtype of the cast type."
msgstr ""
"如果值是对象类型，且为与目标类型相同的类型，亦或为目标类型的子类型，则进行转"
"型后会得到同一个对象。"

msgid ""
"If the value is not a subtype, the casting operation will result in a "
"``null`` value."
msgstr "如果该值的类型不是目标类型的子类型，则强制转型操作将产生 ``null`` 值。"

msgid ""
"For built-in types, they will be forcibly converted if possible, otherwise "
"the engine will raise an error."
msgstr "对于内置类型，如果允许，则将对其进行强制转型，否则将触发报错。"

msgid ""
"Casting is also useful to have better type-safe variables when interacting "
"with the scene tree:"
msgstr ""
"与场景树进行交互时，在获取节点这方面，强制转型也更加类型安全，十分有用："

msgid "Constants"
msgstr "常量"

msgid ""
"Constants are values you cannot change when the game is running. Their value "
"must be known at compile-time. Using the ``const`` keyword allows you to "
"give a constant value a name. Trying to assign a value to a constant after "
"it's declared will give you an error."
msgstr ""
"常量是游戏运行时不可更改的量，其值在编译时必须已知，可使用 ``const`` 关键字为"
"常量值赋予名称。尝试为常量重新赋值将会触发报错。"

msgid "We recommend using constants whenever a value is not meant to change."
msgstr "建议使用常量来储存不应更改的值。"

msgid ""
"Although the type of constants is inferred from the assigned value, it's "
"also possible to add explicit type specification:"
msgstr ""
"常量的类型虽然可以从赋予的值中推断出来，但也可以通过显式添加类型来指定："

msgid "Assigning a value of an incompatible type will raise an error."
msgstr "赋予与指定的类型不相容的值将触发报错。"

msgid ""
"You can also create constants inside a function, which is useful to name "
"local magic values."
msgstr "也可以在函数内使用常量来声明一些局部魔法值。"

msgid "Enums"
msgstr "枚举"

msgid ""
"Enums are basically a shorthand for constants, and are pretty useful if you "
"want to assign consecutive integers to some constant."
msgstr "枚举实质上是常量的简写，适用于为某些常量连续赋整数值。"

msgid ""
"If you pass a name to the enum, it will put all the keys inside a "
"constant :ref:`Dictionary <class_Dictionary>` of that name. This means all "
"constant methods of a dictionary can also be used with a named enum."
msgstr ""
"若将名称传递给枚举，则该枚举将会把所有键纳入该名称的 :ref:`Dictionary "
"<class_Dictionary>` 中，即字典中的所有常方法均可用于具名枚举当中。"

msgid ""
"Keys in a named enum are not registered as global constants. They should be "
"accessed prefixed by the enum's name (``Name.KEY``)."
msgstr ""
"从 Godot 3.1 开始，不会再将具名枚举的键注册为全局常量，此后，应在枚举常量前缀"
"以枚举名的形式来访问枚举内的枚举常量（ ``Name.KEY`` ）；见后面的例子。"

msgid ""
"If not assigning a value to a key of an enum it will be assigned the "
"previous value plus one, or ``0`` if it is the first entry in the enum. "
"Multiple keys with the same value are allowed."
msgstr ""
"如果没有为枚举中的键赋值，就会自动赋值为前一个值加一，如果是枚举中的第一个条"
"目则赋值为 ``0``\\ 。不同的键可以具有相同的值。"

msgid "Functions"
msgstr "函数"

msgid ""
"Functions always belong to a `class <Classes_>`_. The scope priority for "
"variable look-up is: local → class member → global. The ``self`` variable is "
"always available and is provided as an option for accessing class members "
"(see `self`_), but is not always required (and should *not* be sent as the "
"function's first argument, unlike Python)."
msgstr ""
"函数始终属于某个\\ `类 <Classes_>`_\\ 。查找变量时，作用域的查找顺序是：局部→"
"类成员→全局。始终可以通过 ``self`` 变量访问类成员（见 `self`_\\ ），但这不是"
"必须的（与 Python 不同，在 GDScript 中\\ *不应该*\\ 将其作为函数的第一个参数"
"传递）。"

msgid ""
"A function can ``return`` at any point. The default return value is ``null``."
msgstr "函数可以在任何时候用 ``return`` 返回，默认的返回值为 ``null``\\ 。"

msgid ""
"If a function contains only one line of code, it can be written on one line:"
msgstr "如果函数中仅包含一行代码，就可以写成一行："

msgid ""
"Functions can also have type specification for the arguments and for the "
"return value. Types for arguments can be added in a similar way to variables:"
msgstr "函数的参数以及返回值也都可以指定类型。参数类型的添加方式与变量类似："

msgid ""
"If a function argument has a default value, it's possible to infer the type:"
msgstr "如果函数参数有默认值，就可以对该参数的类型进行推断："

msgid ""
"The return type of the function can be specified after the arguments list "
"using the arrow token (``->``):"
msgstr "函数的返回类型可以在参数列表后使用箭头标记（\\ ``->``\\ ）指定："

msgid ""
"Functions that have a return type **must** return a proper value. Setting "
"the type as ``void`` means the function doesn't return anything. Void "
"functions can return early with the ``return`` keyword, but they can't "
"return any value."
msgstr ""
"有返回类型的函数\\ **必须**\\ 返回与返回值类型相匹配的值。将返回值类型设置为 "
"``void`` 表示该函数不返回任何东西。这种函数称为 void 函数，可以使用 "
"``return`` 关键字提前返回，但不能返回任何值。"

msgid ""
"Non-void functions must **always** return a value, so if your code has "
"branching statements (such as an ``if``/``else`` construct), all the "
"possible paths must have a return. E.g., if you have a ``return`` inside an "
"``if`` block but not after it, the editor will raise an error because if the "
"block is not executed, the function won't have a valid value to return."
msgstr ""
"非 void 函数 **必须** 返回一个值，如果你的代码具有分支语句（例如 ``if``/"
"``else`` 构造），则所有可能的路径都必须有返回值。例如，如果在 ``if`` 块内有一"
"个 ``return``\\，但在其后没有，则编辑器将抛出一个错误，因为如果该代码块未执"
"行，那么该函数将没有值进行有效返回。"

msgid "Referencing functions"
msgstr "引用函数"

msgid ""
"Functions are first-class values in terms of the :ref:`Callable "
"<class_Callable>` object. Referencing a function by name without calling it "
"will automatically generate the proper callable. This can be used to pass "
"functions as arguments."
msgstr ""
"就 :ref:`Callable <class_Callable>` 对象而言，函数是其第一类值。如果通过名称"
"来引用函数但不调用，那么就会自动生成对应的可调用体。可以将这种可调用体作为函"
"数的参数传递。"

msgid ""
"Callables **must** be called with the :ref:`call() "
"<class_Callable_method_call>` method. You cannot use the ``()`` operator "
"directly. This behavior is implemented to avoid performance issues on direct "
"function calls."
msgstr ""
"可调用体\\ **必须**\\ 使用 :ref:`call() <class_Callable_method_call>` 方法进"
"行调用，不能直接使用 ``()`` 运算符。实现这种行为是为了避免影响直接调用函数的"
"性能问题。"

msgid "Lambda functions"
msgstr "Lambda 函数"

msgid ""
"Lambda functions allow you to declare functions that do not belong to a "
"class. Instead, a :ref:`Callable <class_Callable>` object is created and "
"assigned to a variable directly. This can be useful to create callables to "
"pass around without polluting the class scope."
msgstr ""
"Lambda 函数允许声明不属于类的函数，会直接创建 :ref:`Callable "
"<class_Callable>` 对象并将其赋值给变量。Lambda 函数可以创建可传递的可调用体，"
"同时又不会污染该类的作用范围，非常有用。"

msgid ""
"To call the created lambda you can use the :ref:`call() "
"<class_Callable_method_call>` method:"
msgstr ""
"要调用所创建出来的 Lambda 函数，你可以调用其 :ref:`call() "
"<class_Callable_method_call>` 方法："

msgid ""
"Lambda functions can be named for debugging purposes (the name is displayed "
"in the Debugger):"
msgstr "Lambda 函数还可用于代码调试（其名称会显示在调试器上）："

msgid ""
"You can specify type hints for lambda functions in the same way as for "
"regular ones:"
msgstr "你也可以像普通函数那样为 Lambda 函数添加类型提示："

msgid ""
"Note that if you want to return a value from a lambda function, an explicit "
"``return`` is required (you can't omit ``return``):"
msgstr ""
"注意，若想要在 Lambda 函数中返回值，必须显式使用 ``return`` 关键字进行返回"
"（即无法省略 ``return``\\ ）："

msgid "Lambda functions capture the local environment:"
msgstr "Lambda 函数可以捕获局部环境："

msgid ""
"Local variables are captured by value once, when the lambda is created. So "
"they won't be updated in the lambda if reassigned in the outer function:"
msgstr ""
"创建 Lambda 函数时，Lambda 函数只会捕获一次局部变量的值，如果在 Lambda 函数外"
"重新为该局部变量赋值，则其值不会在 Lambda 函数内更新："

msgid ""
"Also, a lambda cannot reassign an outer local variable. After exiting the "
"lambda, the variable will be unchanged, because the lambda capture "
"implicitly shadows it:"
msgstr ""
"此外，Lambda 函数也无法给外部的局部变量重新赋值。退出 Lambda 函数体后该变量不"
"会发生改变，因为 Lambda 函数中捕获的版本隐式覆盖了该变量："

msgid ""
"However, if you use pass-by-reference data types (arrays, dictionaries, and "
"objects), then the content changes are shared until you reassign the "
"variable:"
msgstr ""
"不过，如果你使用的是通过引用传递的数据类型（如数组、字典、对象等）的话，那么"
"在你为这些变量重新赋值之前，这些变量会共享其内容更改："

msgid "Static functions"
msgstr "静态函数"

msgid ""
"A function can be declared static. When a function is static, it has no "
"access to the instance member variables or ``self``. A static function has "
"access to static variables. Also static functions are useful to make "
"libraries of helper functions:"
msgstr ""
"函数可以声明为静态函数。静态函数无法通过\\ ``self``\\ 关键字访问实例的成员变"
"量，但可以访问静态变量，非常适用于创建辅助函数库："

msgid "Lambda functions cannot be declared static."
msgstr "Lambda 函数不可声明为静态函数。"

msgid "See also `Static variables`_ and `Static constructor`_."
msgstr "见\\ `静态变量`_\\ 和\\ `静态构造函数`_\\ 。"

msgid "Variadic functions"
msgstr "可变参数函数"

msgid ""
"A variadic function is a function that can take a variable number of "
"arguments. Since Godot 4.5, GDScript supports variadic functions. To declare "
"a variadic function, you need to use the *rest parameter*, which collects "
"all the excess arguments into an array."
msgstr ""
"可变参数函数是一种可带不定数量参数的函数。从 Godot 4.5 版本开始起 GDScript 支"
"持可变参数函数。若要定义一个可变参数函数，你需要用到\\ *剩余参数*\\ ，剩余参"
"数会将多余的实际参数打包进一个数组内。"

msgid ""
"A function can have at most one rest parameter, which must be the last one "
"in the parameter list. The rest parameter cannot have a default value. "
"Static and lambda functions can also be variadic."
msgstr ""
"一个函数至多可拥有一个剩余参数，且剩余参数必须为参数列表的最后一位，剩余参数"
"不可赋予默认值。静态函数和Lambda函数均可变为可变参数函数。"

msgid ""
"Static typing works for variadic functions too. However, typed arrays are "
"currently not supported as a static type of the rest parameter:"
msgstr ""
"静态类型也适用于可变参数函数，但类型化数组目前不能作为剩余参数的类型使用："

msgid ""
"Although you can declare functions as variadic using the rest parameter, "
"unpacking parameters when calling a function using *spread syntax* that "
"exists in some languages ​​(JavaScript, PHP) is currently not supported in "
"GDScript. However, you can use ``callv()`` to call a function with an array "
"of arguments:"
msgstr ""
"虽然可以用剩余参数定义可变参数函数，但GDScript目前不支持用某些语言（如"
"JavaScript、PHP等）中的\\ *展开语法*\\ 来调用可变参数函数，不过你可以通过调"
"用 ``callv()`` 函数来调用可变参数函数，调用时需要传入实际参数所组成的数组："

msgid "Abstract functions"
msgstr "抽象函数"

msgid "See `Abstract classes and methods`_."
msgstr "参见 `抽象类与抽象方法`_."

msgid "Statements and control flow"
msgstr "语句与流程控制"

msgid ""
"Statements are standard and can be assignments, function calls, control flow "
"structures, etc (see below). ``;`` as a statement separator is entirely "
"optional."
msgstr ""
"标准的语句可以是赋值、函数调用以及流程控制结构等（见下方）。\\ ``;`` 为语句分"
"隔符，在使用时可写可略。"

msgid "Expressions"
msgstr "表达式"

msgid ""
"Expressions are sequences of operators and their operands in orderly "
"fashion. An expression by itself can be a statement too, though only calls "
"are reasonable to use as statements since other expressions don't have side "
"effects."
msgstr ""
"表达式是运算符和操作数的有序排列，尽管表达式本身可以构成一个语句，但仅函数调"
"用才适合作为语句使用，因为其他类型的表达式通常不会产生副作用。"

msgid ""
"Expressions return values that can be assigned to valid targets. Operands to "
"some operator can be another expression. An assignment is not an expression "
"and thus does not return any value."
msgstr ""
"表达式返回的数值可赋值给有效目标，而某些运算符的操作数也可以变成一条表达式。"
"赋值语句因无返回值而不能作为表达式使用。"

msgid "Here are some examples of expressions:"
msgstr "以下是一些表达式的示例："

msgid ""
"Identifiers, attributes, and subscripts are valid assignment targets. Other "
"expressions cannot be on the left side of an assignment."
msgstr ""
"标识符、对象属性和下标均可视为表达式有效的赋值目标，而在赋值语句中，表达式不"
"能位于赋值等号左侧。"

msgid ""
"``self`` can be used to refer to the current instance and is often "
"equivalent to directly referring to symbols available in the current script. "
"However, ``self`` also allows you to access properties, methods, and other "
"names that are defined dynamically (i.e. are expected to exist in subtypes "
"of the current class, or are provided using :ref:`_set() "
"<class_Object_private_method__set>` and/or :ref:`_get() "
"<class_Object_private_method__get>`)."
msgstr ""
"``self`` 可用于引用当前实例，通常等同于直接引用当前脚本中的可用符号。不过你还"
"可以通过 ``self`` 访问动态定义的属性、方法和其他名称（即应当在当前类的子类中"
"定义，或使用 :ref:`_set() <class_Object_private_method__set>` 和/"
"或 :ref:`_get() <class_Object_private_method__get>` 提供）。"

msgid ""
"Beware that accessing members of child classes in the base class is often "
"considered a bad practice, because this blurs the area of responsibility of "
"any given piece of code, making the overall relationship between parts of "
"your game harder to reason about. Besides that, one can simply forget that "
"the parent class had some expectations about it's descendants."
msgstr ""
"请注意，通常认为在基类中访问子类的成员是一种不良实践，因为这会使所有代码的责"
"任范围都变得模糊，让游戏中各部分之间的整体关系变得更加难以判断。除此之外，人"
"们还可能会忘记父类对其子类存在这些要求。"

msgid "if/else/elif"
msgstr "if/else/elif"

msgid ""
"Simple conditions are created by using the ``if``/``else``/``elif`` syntax. "
"Parenthesis around conditions are allowed, but not required. Given the "
"nature of the tab-based indentation, ``elif`` can be used instead of "
"``else``/``if`` to maintain a level of indentation."
msgstr ""
"条件句通过使用 ``if``/``else``/``elif`` 语法创建。条件中的括号可写可不写。考"
"虑到基于制表符缩进的性质，可以使用 ``elif`` 而非 ``else``/``if`` 来保持缩进级"
"别相同。"

msgid "Short statements can be written on the same line as the condition:"
msgstr "短的语句可以与条件句写在同一行内："

msgid ""
"Sometimes, you might want to assign a different initial value based on a "
"boolean expression. In this case, ternary-if expressions come in handy:"
msgstr ""
"有时你可能希望基于布尔表达式来赋予不同的初始值，为此，三元表达式将派上用场："

msgid ""
"Ternary-if expressions can be nested to handle more than 2 cases. When "
"nesting ternary-if expressions, it is recommended to wrap the complete "
"expression over multiple lines to preserve readability:"
msgstr ""
"可以通过嵌套三元表达式来处理的超过两种可能性的情况。嵌套时，推荐把三元 if 表"
"达式拆分为多行以保证代码的可读性："

msgid ""
"You may also wish to check if a value is contained within something. You can "
"use an ``if`` statement combined with the ``in`` operator to accomplish this:"
msgstr ""
"你可能还想要检查某个值是否包含在某些容器之中，可以通过 ``if`` 语句与 ``in`` "
"运算符组合来实现："

msgid ""
"Simple loops are created by using ``while`` syntax. Loops can be broken "
"using ``break`` or continued using ``continue`` (which skips to the next "
"iteration of the loop without executing any further code in the current "
"iteration):"
msgstr ""
"一般的循环通过 ``while`` 语法创建，可以使用 ``break`` 来跳出整个循环，或者使"
"用 ``continue`` 来跳出当前批次的循环并进入下一轮的循环当中（但会将该关键字下"
"方所有在该循环体内的语句全部跳过）："

msgid ""
"To iterate through a range, such as an array or table, a *for* loop is used. "
"When iterating over an array, the current array element is stored in the "
"loop variable. When iterating over a dictionary, the *key* is stored in the "
"loop variable."
msgstr ""
"要迭代一个范围，例如数组或表，请使用 *for* 循环。迭代数组时，当前数组元素被存"
"储在循环变量中。迭代字典时，*键* 被存储在循环变量中。"

msgid ""
"If you want to assign values on an array as it is being iterated through, it "
"is best to use ``for i in array.size()``."
msgstr ""
"若需要在数组迭代时对数组进行赋值操作，则推荐使用 ``for i in array.size()`` 来"
"进行该操作。"

msgid ""
"The loop variable is local to the for-loop and assigning to it will not "
"change the value on the array. Objects passed by reference (such as nodes) "
"can still be manipulated by calling methods on the loop variable."
msgstr ""
"循环变量只属于该循环，为其赋值并不会更改数组的值。如果循环变量是通过引用传递"
"的对象（如节点），则仍可通过调用其方法来操作所指向的对象。"

msgid ""
"A ``match`` statement is used to branch execution of a program. It's the "
"equivalent of the ``switch`` statement found in many other languages, but "
"offers some additional features."
msgstr ""
"``match`` 语句用于分支流程的执行，相当于在许多其他语言中出现的 ``switch`` 语"
"句，但提供了一些附加功能。"

msgid ""
"``match`` is more type strict than the ``==`` operator. For example ``1`` "
"will **not** match ``1.0``. The only exception is ``String`` vs "
"``StringName`` matching: for example, the String ``\"hello\"`` is considered "
"equal to the StringName ``&\"hello\"``."
msgstr ""
"``match`` 对类型的要求比 ``==`` 运算符更严格。例如 ``1`` 和 ``1.0`` 是\\ **不"
"匹配**\\ 的。唯一的例外是 ``String`` 和 ``StringName`` 的匹配：例如会认为字符"
"串 ``\"hello\"`` 和 StringName ``&\"hello\"`` 相等。"

msgid "Basic syntax"
msgstr "基本语法"

msgid "Crash-course for people who are familiar with switch statements"
msgstr "给熟悉 switch 语句的人提供的速成课程"

msgid "Replace ``switch`` with ``match``."
msgstr "将 ``switch`` 替换为 ``match``\\ 。"

msgid "Remove ``case``."
msgstr "删除 ``case``\\ 。"

msgid "Remove any ``break``\\ s."
msgstr "删除 ``break``\\ 。"

msgid "Change ``default`` to a single underscore."
msgstr "将 ``default`` 替换为单个下划线。"

msgid "Control flow"
msgstr "流程控制"

msgid ""
"The patterns are matched from top to bottom. If a pattern matches, the first "
"corresponding block will be executed. After that, the execution continues "
"below the ``match`` statement."
msgstr ""
"按照从上到下的顺序进行模式匹配。匹配成功时，会执行第一个对应的代码块。执行完"
"成后，会继续执行 ``match`` 语句后的内容。"

msgid ""
"The special ``continue`` behavior in ``match`` supported in 3.x was removed "
"in Godot 4.0."
msgstr ""
"3.x 版本支持在 ``match`` 中使用 ``continue`` 执行特殊行为，此行为已在 Godot "
"4.0 中移除。"

msgid "The following pattern types are available:"
msgstr "可以使用以下模式类型："

msgid "Literal pattern"
msgstr "字面量模式"

msgid "Matches a `literal <Literals_>`_:"
msgstr "匹配\\ `字面量 <Literals_>`_\\ ："

msgid "Expression pattern"
msgstr "表达式模式"

msgid ""
"Matches a constant expression, an identifier, or an attribute access "
"(``A.B``):"
msgstr "匹配表达式常量、标识符或属性访问（\\ ``A.B``\\ ）："

msgid "Wildcard pattern"
msgstr "通配符模式"

msgid "This pattern matches everything. It's written as a single underscore."
msgstr "匹配所有内容，用一个下划线来表示通配内容。"

msgid ""
"It can be used as the equivalent of the ``default`` in a ``switch`` "
"statement in other languages:"
msgstr "可以与其他语言的 ``switch`` 语句中的 ``default`` 等效："

msgid "Binding pattern"
msgstr "绑定模式"

msgid ""
"A binding pattern introduces a new variable. Like the wildcard pattern, it "
"matches everything - and also gives that value a name. It's especially "
"useful in array and dictionary patterns:"
msgstr ""
"绑定模式引入一个新的变量，与通配符模式类似匹配所有内容，并将值赋给这个新的变"
"量，在数组和字典模式中特别有用："

msgid "Array pattern"
msgstr "数组模式"

msgid ""
"Matches an array. Every single element of the array pattern is a pattern "
"itself, so you can nest them."
msgstr ""
"匹配一个数组，数组模式的每个元素本身都可以是一个模式，因此可以对其进行嵌套。"

msgid ""
"The length of the array is tested first, it has to be the same size as the "
"pattern, otherwise the pattern doesn't match."
msgstr "首先检测数组的长度，其长度必须与语句块条件的数组长度相同，否则不匹配。"

msgid ""
"**Open-ended array**: An array can be bigger than the pattern by making the "
"last subpattern ``..``."
msgstr ""
"**开放式数组**\\ ：将最后一个子模式写成 ``..`` 就可以允许匹配长度超过模式中数"
"组长度的数组。"

msgid "Every subpattern has to be comma-separated."
msgstr "每个子模式都必须用逗号分隔开来。"

msgid "Dictionary pattern"
msgstr "字典模式"

msgid ""
"Works in the same way as the array pattern. Every key has to be a constant "
"pattern."
msgstr "作用方式同数组模式，且每个键必须为一个常量模式。"

msgid ""
"The size of the dictionary is tested first, it has to be the same size as "
"the pattern, otherwise the pattern doesn't match."
msgstr "首先检测字典的大小，其大小必须与语句块条件的字典大小相同，否则不匹配。"

msgid ""
"**Open-ended dictionary**: A dictionary can be bigger than the pattern by "
"making the last subpattern ``..``."
msgstr ""
"**开放式字典**\\ ：将最后一个子模式写成 ``..`` 就可以允许匹配大小超过模式中字"
"典大小的字典。"

msgid "Every subpattern has to be comma separated."
msgstr "每个子模式都必须用逗号分隔开。"

msgid ""
"If you don't specify a value, then only the existence of the key is checked."
msgstr "若不指定键的值，则仅检查键的存在。"

msgid "A value pattern is separated from the key pattern with a ``:``."
msgstr "值模式与键模式之间以 ``:`` 分隔。"

msgid "Multiple patterns"
msgstr "多重模式"

msgid ""
"You can also specify multiple patterns separated by a comma. These patterns "
"aren't allowed to have any bindings in them."
msgstr ""
"你还可以用逗号来分隔同一语句块条件里的多个模式，这些模式不允许包含任何绑定。"

msgid "Pattern guards"
msgstr "模式防护"

msgid ""
"A *pattern guard* is an optional condition that follows the pattern list and "
"allows you to make additional checks before choosing a ``match`` branch. "
"Unlike a pattern, a pattern guard can be an arbitrary expression."
msgstr ""
"*模式防护*\\ （Pattern Guard）是一个跟在模式列表后面的可选条件，可以用来在选"
"择 ``match`` 分支之前进行额外的检查。与模式不同，模式防护可以是任意表达式。"

msgid ""
"Only one branch can be executed per ``match``. Once a branch is chosen, the "
"rest are not checked. If you want to use the same pattern for multiple "
"branches or to prevent choosing a branch with too general pattern, you can "
"specify a pattern guard after the list of patterns with the ``when`` keyword:"
msgstr ""
"一个 ``match`` 只会执行一个分支。选中某个分支后就不会再检查其他分支。如果希望"
"让多个分支使用同一个模式，或者想要防止选中某个模式过于宽泛的分支，你可以在模"
"式列表后用 ``when`` 关键字指定防护表达式："

msgid ""
"If there is no matching pattern for the current branch, the pattern guard is "
"**not** evaluated and the patterns of the next branch are checked."
msgstr ""
"如果没有匹配当前分支的模式，就\\ **不会**\\ 对防护表达式求值，程序将检查下一"
"个分支的模式。"

msgid "If a matching pattern is found, the pattern guard is evaluated."
msgstr "如果识别到匹配的模式，就会对防护表达式求值。"

msgid ""
"If it's true, then the body of the branch is executed and ``match`` ends."
msgstr "值为 true 时，就会执行分支的内容，然后结束 ``match``\\ 。"

msgid "If it's false, then the patterns of the next branch are checked."
msgstr "值为 false 时，就会继续检查下一个分支的模式。"

msgid "Classes"
msgstr "类"

msgid ""
"By default, all script files are unnamed classes. In this case, you can only "
"reference them using the file's path, using either a relative or an absolute "
"path. For example, if you name a script file ``character.gd``:"
msgstr ""
"默认情况下，所有脚本文件都是未命名的类，这时只能使用文件的路径来引用这些无名"
"类（相对路径或绝对路径）。如果你将脚本文件命名为 ``character.gd``\\ 的话："

msgid "Registering named classes"
msgstr "注册具名类"

msgid ""
"You can give your class a name to register it as a new type in Godot's "
"editor. For that, you use the ``class_name`` keyword. You can optionally use "
"the ``@icon`` annotation with a path to an image, to use it as an icon. Your "
"class will then appear with its new icon in the editor:"
msgstr ""
"你也可以使用 ``class_name`` 关键字来为你的类起名，将其注册为 Godot 编辑器中的"
"新类型。你还可以配合使用 ``@icon`` 注解，向其括号中输入图片的路径，将该图片作"
"为该类的图标使用。这样，你的类就会和新的图标一起显示在编辑器中："

msgid ""
"SVG images that are used as custom node icons should have the **Editor > "
"Scale With Editor Scale** and **Editor > Convert Icons With Editor "
"Theme** :ref:`import options <doc_importing_images_editor_import_options>` "
"enabled. This allows icons to follow the editor's scale and theming settings "
"if the icons are designed with the same color palette as Godot's own icons."
msgstr ""
"SVG 图片在用作自定义节点图标时，需要在该图片的 :ref:`导入选项 "
"<doc_importing_images_editor_import_options>` 中将 **编辑器 > 依照编辑器比例"
"缩放** 与 **编辑器 > 依照编辑器主题转换颜色** 勾选，这样才能让有跟 Godot 图标"
"色调相同的图标在编辑器中能够同步其缩放、同步其主题设置。"

msgid "Here's a class file example:"
msgstr "这是一个类文件示例："

msgid "If you want to use ``extends`` too, you can keep both on the same line:"
msgstr "如果你还想要用 ``extends``\\ ，就可以将这两个关键字写在同一行："

msgid ""
"Named classes are globally registered, which means they become available to "
"use in other scripts without the need to ``load`` or ``preload`` them:"
msgstr ""
"具名类会注册到全局空间当中，这样其他脚本就可以直接引用这些具名类，无需通过\\ "
"``load``\\ 或\\ ``preload``\\ 来加载它们。"

msgid ""
"Godot initializes non-static variables every time you create an instance, "
"and this includes arrays and dictionaries. This is in the spirit of thread "
"safety, since scripts can be initialized in separate threads without the "
"user knowing."
msgstr ""
"由于脚本可以在用户不知情的情况下在单独的线程中初始化，出于线程安全考虑，"
"Godot 在每次创建实例时，引擎都会初始化非静态变量，其中就包括数组和字典。"

msgid ""
"The Godot editor will hide these custom classes with names that begin with "
"the prefix \"Editor\" in the 'Create New Node' or 'Create New Scene' dialog "
"windows. The classes are available for instantiation at runtime via their "
"class names, but are automatically hidden by the editor windows along with "
"the built-in editor nodes used by the Godot editor."
msgstr ""
"Godot 编辑器会在“新建节点”和“新建场景”对话框窗口中隐藏名称以“Editor”开头的自"
"定义类。这些类可以在运行时通过类名进行实例化，但会与 Godot 编辑器使用的内置编"
"辑器节点一起被编辑器窗口自动隐藏。"

msgid "Abstract classes and methods"
msgstr "抽象类与抽象方法"

msgid ""
"Since Godot 4.5, you can define abstract classes and methods using the "
"``@abstract`` annotation."
msgstr ""
"从 Godot 4.5 版本起，你可以通过\\ ``@abstract``\\ 注解来定义抽象类和抽象方"
"法。"

msgid ""
"An abstract class is a class that cannot be instantiated directly. Instead, "
"it is meant to be inherited by other classes. Attempting to instantiate an "
"abstract class will result in an error."
msgstr "抽象类无法直接实例化，需要其他类来继承之，尝试实例化抽象类将会报错。"

msgid ""
"An abstract method is a method that has no implementation. Therefore, a "
"newline or a semicolon is expected after the function header. This defines a "
"contract that inheriting classes must conform to, because the method "
"signature must be compatible when overriding."
msgstr ""
"抽象方法不含有方法实现，需要在函数头后面另起新文本行或使用分号来结尾。抽象函"
"数定义了继承的类必须遵循的契约，这是因为方法签名需在方法重写时保持兼容。"

msgid ""
"Inheriting classes must either provide implementations for all abstract "
"methods, or the inheriting class must be marked as abstract. If a class has "
"at least one abstract method (either its own or an unimplemented inherited "
"one), then it must also be marked as abstract. However, the reverse is not "
"true: an abstract class is allowed to have no abstract methods."
msgstr ""
"抽象类的子类要么必须实现所有抽象方法，要么继续将抽象方法标记为抽象方法，若一"
"个类含有至少一个抽象方法（不论是该类含有的，还是继承过来且未实现的），则该类"
"也必须要标记为抽象类，反之则不然——抽象类可以不含抽象方法。"

msgid ""
"If you want to declare a method as optional to be overridden, you should use "
"a non-abstract method and provide a default implementation."
msgstr "若想声明可重写的可选方法，应使用具体方法，且需要指定其默认实现。"

msgid ""
"For example, you could have an abstract class called ``Shape`` that defines "
"an abstract method called ``draw()``. You can then create subclasses like "
"``Circle`` and ``Square`` that implement the ``draw()`` method in their own "
"way. This allows you to define a common *interface* for all shapes without "
"having to implement all the details in the abstract class itself:"
msgstr ""
"例如：你可以有一个叫\\ ``Shape``\\ 的抽象类，其中定义了个叫\\ ``draw()``\\ 的"
"抽象方法，你可以在创建几个子类（如\\ ``Circle``\\ 、\\ ``Square``\\ ）来实现"
"其各自的\\ ``draw()``\\ 方法，这样就可以给所有形状定义一个通用的\\ *接口"
"*\\ ，无需在抽象类里实现其细节。"

msgid ""
"Both inner classes and classes created using ``class_name`` can be abstract. "
"This example creates two abstract classes, one of which is a subclass of "
"another abstract class:"
msgstr ""
"通过\\ ``class_name``\\ 声明的类与内部类均可变为抽象类，下例创建了两个抽象"
"类，其中一个为另一个的子类。"

msgid ""
"Since an abstract class cannot be instantiated, it is not possible to attach "
"an abstract class to a node. If you attempt to do so, the engine will print "
"an error when running the scene:"
msgstr ""
"由于抽象类无法被实例化，抽象类所在的脚本也无法附加到节点上。尝试这样做会导致"
"引擎在运行场景时打印报错："

msgid ""
"Unnamed classes can also be defined as abstract, the ``@abstract`` "
"annotation must precede ``extends``:"
msgstr ""
"无名类亦可声明为抽象类，需要将\\ ``@abstract``\\ 注解附加在\\ ``extends``\\ "
"关键字之前。"

msgid "Inheritance"
msgstr "继承"

msgid "A class (stored as a file) can inherit from:"
msgstr "类（以文件形式保存）可以继承自："

msgid "A global class."
msgstr "全局类。"

msgid "Another class file."
msgstr "另一个类文件。"

msgid "An inner class inside another class file."
msgstr "另一个类文件中的内部类。"

msgid "Multiple inheritance is not allowed."
msgstr "不允许多重继承。"

msgid "Inheritance uses the ``extends`` keyword:"
msgstr "继承使用 ``extends`` 关键字："

msgid ""
"If inheritance is not explicitly defined, the class will default to "
"inheriting :ref:`class_RefCounted`."
msgstr ""
"如果没有显式指定继承的类，则默认该类继承自 :ref:`class_RefCounted`\\ 。"

msgid ""
"To check if a given instance inherits from a given class, the ``is`` keyword "
"can be used:"
msgstr "要检查给定的实例是否继承自给定的类，可以使用 ``is`` 关键字："

msgid ""
"To call a function in a *super class* (i.e. one ``extend``-ed in your "
"current class), use the ``super`` keyword:"
msgstr ""
"要调用\\ *基类*\\ （即当前类的 ``extends`` 关键字后的类）中的函数，请使用 "
"``super`` 关键字："

msgid ""
"This is especially useful because functions in extending classes replace "
"functions with the same name in their super classes. If you still want to "
"call them, you can use ``super``:"
msgstr ""
"由于子类中的函数会替换基类中同名的函数，因此若仍然想调用在基类中的该函数，则"
"可以使用 ``super`` 关键字："

msgid ""
"If you need to call a different function from the super class, you can "
"specify the function name with the attribute operator:"
msgstr "如果需要调用父类中的其他方法，可以用属性运算符指定函数名称："

msgid ""
"One of the common misconceptions is trying to override *non-virtual* engine "
"methods such as ``get_class()``, ``queue_free()``, etc. This is not "
"supported for technical reasons."
msgstr ""
"开发者通常会误以为可以覆写引擎内的\\ *非虚*\\ 方法，如 ``get_class()``\\ 、"
"\\ ``queue_free()`` 等。出于技术性原因，暂不支持这种操作。"

msgid ""
"In Godot 3, you can *shadow* engine methods in GDScript, and it will work if "
"you call this method in GDScript. However, the engine will **not** execute "
"your code if the method is called inside the engine on some event."
msgstr ""
"在 Godot 3 中，你可以在 GDScript 中\\ *隐藏*\\ 引擎方法，在 GDScript 中调用时"
"执行的就是你所定义的版本。然而如果是引擎内部需要调用该方法，那么引擎所执行的"
"就\\ **不是**\\ 你所定义的版本。"

msgid ""
"In Godot 4, even shadowing may not always work, as GDScript optimizes native "
"method calls. Therefore, we added the ``NATIVE_METHOD_OVERRIDE`` warning, "
"which is treated as an error by default. We strongly advise against "
"disabling or ignoring the warning."
msgstr ""
"Godot 4 的 GDScript 对内置方法的调用机制进行了优化，很多时候都无法再使用同名"
"方法来隐藏了。鉴于此，我们增添了 ``NATIVE_METHOD_OVERRIDE`` 警告选项，默认会"
"对这种情况报错。我们强烈建议保持该选项开启，不要作为警告而忽略之。"

msgid ""
"Note that this does not apply to virtual methods such as ``_ready()``, "
"``_process()`` and others (marked with the ``virtual`` qualifier in the "
"documentation and the names start with an underscore). These methods are "
"specifically for customizing engine behavior and can be overridden in "
"GDScript. Signals and notifications can also be useful for these purposes."
msgstr ""
"请注意，\\ ``_ready()``\\ 、\\ ``_process()`` 等（在文档中标为 ``virtual`` 且"
"以下划线开头的）虚方法不受此限制。这些方法是专门用于自定义引擎行为的方法，可"
"在 GDScript 中覆盖。信号、通知也可用于自定义引擎行为。"

msgid "Class constructor"
msgstr "类的构造函数"

msgid ""
"The class constructor, called on class instantiation, is named ``_init``. If "
"you want to call the base class constructor, you can also use the ``super`` "
"syntax. Note that every class has an implicit constructor that is always "
"called (defining the default values of class variables). ``super`` is used "
"to call the explicit constructor:"
msgstr ""
"类的构造函数名为 ``_init``\\ ，会在类进行初始化时调用 。若想要在构造函数中调"
"用父类的构造函数，同样可以使用 ``super`` 语法。请注意，每个类都有一个隐式构造"
"函数，始终由引擎调用（用来定义类变量的默认值）。\\ ``super`` 则用于调用显式构"
"造函数："

msgid "This is better explained through examples. Consider this scenario:"
msgstr "通过示例可以更好地说明这一点。考虑一下这种情况："

msgid "There are a few things to keep in mind here:"
msgstr "这里有几点需要牢记："

msgid ""
"If the inherited class (``state.gd``) defines an ``_init`` constructor that "
"takes arguments (``e`` in this case), then the inheriting class "
"(``idle.gd``) *must* define ``_init`` as well and pass appropriate "
"parameters to ``_init`` from ``state.gd``."
msgstr ""
"如果被继承的类（\\ ``state.gd``\\ ）定义了一个带有参数（此处的 ``e``\\ ）的 "
"``_init`` 构造函数，那么继承的类（\\ ``idle.gd``\\ ）也\\ *必须*\\ 定义 "
"``_init``\\ ，并且要将适当的参数传递给 ``state.gd`` 的 ``_init``\\ 。"

msgid ""
"``idle.gd`` can have a different number of arguments than the base class "
"``state.gd``."
msgstr ""
"``Idle.gd`` 的构造函数的参数数量可以与基类 ``State.gd`` 的构造函数的参数数量"
"有所不同。"

msgid ""
"In the example above, ``e`` passed to the ``state.gd`` constructor is the "
"same ``e`` passed in to ``idle.gd``."
msgstr ""
"在上面的示例中，传递给 ``State.gd`` 构造函数的 ``e`` 与传递给 ``Idle.gd`` 的 "
"``e`` 是相同的。"

msgid ""
"If ``idle.gd``'s ``_init`` constructor takes 0 arguments, it still needs to "
"pass some value to the ``state.gd`` base class, even if it does nothing. "
"This brings us to the fact that you can pass expressions to the base "
"constructor as well, not just variables, e.g.:"
msgstr ""
"如果 ``idle.gd`` 的 ``_init`` 构造函数不接受任何参数，即便该构造函数即便什么"
"也不做，也仍然需要将一些值传递给 ``state.gd`` 父类。因此我们除了可以给基类构"
"造函数传变量之外，还可以传表达式，例如："

msgid "func _init():"
msgstr "func _init():"

msgid "super(5)"
msgstr "super(5)"

msgid "Static constructor"
msgstr "静态构造函数"

msgid ""
"A static constructor is a static function ``_static_init`` that is called "
"automatically when the class is loaded, after the static variables have been "
"initialized:"
msgstr ""
"静态构造函数是名为 ``_static_init`` 的静态函数。载入类时，静态变量初始化后会"
"自动调用该函数："

msgid ""
"A static constructor cannot take arguments and must not return any value."
msgstr "静态构造函数不能含有任何参数，不能返回值。"

msgid "Inner classes"
msgstr "内部类"

msgid ""
"A class file can contain inner classes. Inner classes are defined using the "
"``class`` keyword. They are instanced using the ``ClassName.new()`` function."
msgstr ""
"类文件可以包含内部类。内部类使用 ``class`` 关键字定义，用 ``类名.new()`` 函数"
"来进行实例化。"

msgid "Classes as resources"
msgstr "类作为资源"

msgid ""
"Classes stored as files are treated as :ref:`GDScripts <class_GDScript>`. "
"They must be loaded from disk to access them in other classes. This is done "
"using either the ``load`` or ``preload`` functions (see below). Instancing "
"of a loaded class resource is done by calling the ``new`` function on the "
"class object:"
msgstr ""
"以文件形式存储的类会作为 :ref:`GDScript <class_GDScript>` 处理。这些类必须先"
"从磁盘加载，然后才能在其他类中访问。加载可以通过调用 ``load`` 或 ``preload`` "
"函数来完成（见下文）。对已加载的类资源进行实例化则是通过调用类对象上的 "
"``new`` 函数来完成的："

msgid "Exports"
msgstr "导出"

msgid ""
"Documentation about exports has been moved to :ref:`doc_gdscript_exports`."
msgstr "有关导出的文档已移至 :ref:`doc_gdscript_exports`\\ 。"

msgid "Properties (setters and getters)"
msgstr "属性（setter 与 getter）"

msgid ""
"Sometimes, you want a class' member variable to do more than just hold data "
"and actually perform some validation or computation whenever its value "
"changes. It may also be desired to encapsulate its access in some way."
msgstr ""
"有时，你可能不止希望对类成员进行数据存储操作，甚至想要在更改成员值的时候对其"
"进行有效性检查操作或运算操作。你也可能希望以某种方式对该类成员的访问进行封"
"装。"

msgid ""
"For this, GDScript provides a special syntax to define properties using the "
"``set`` and ``get`` keywords after a variable declaration. Then you can "
"define a code block that will be executed when the variable is accessed or "
"assigned."
msgstr ""
"鉴于此，GDScript 提供了一套特别的语法，通过在变量定义后使用 ``set``\\ 、\\ "
"``get`` 关键字来对类成员属性的读写进行封装。这样一来，你就可以在 ``set``\\ "
"（setter 函数）、\\ ``get``\\ （getter 函数）语句块里定义代码，在该成员被读写"
"时执行之。"

msgid "Example:"
msgstr "示例："

msgid ""
"Unlike ``setget`` in previous Godot versions, ``set`` and ``get`` methods "
"are **always** called (except as noted below), even when accessed inside the "
"same class (with or without prefixing with ``self.``). This makes the "
"behavior consistent. If you need direct access to the value, use another "
"variable for direct access and make the property code use that name."
msgstr ""
"与之前的 Godot 版本中的 ``setget`` 不同，即使在同一个类中进行访问（不管是否添"
"加 ``self.`` 前缀），也\\ **始终**\\ 会调用属性的 ``set`` 方法和 ``get`` 方法"
"（例外见下文） 。这样访问属性时的行为就一致了。如果你需要直接访问实际的值，请"
"再添加一个变量用于直接访问，然后在属性相关的代码中使用这个变量的变量名。"

msgid "Alternative syntax"
msgstr "替代语法"

msgid ""
"Also there is another notation to use existing class functions if you want "
"to split the code from the variable declaration or you need to reuse the "
"code across multiple properties (but you can't distinguish which property "
"the setter/getter is being called for):"
msgstr ""
"如果你想要拆分实现代码和变量声明，或者需要让多个属性共用相同的代码（此时无法"
"区分调用的是哪个属性的 setter/getter），也有另一种写法："

msgid "This can also be done in the same line:"
msgstr "也可以将这个写法缩在同一行内写："

msgid ""
"The setter and getter must use the same notation, mixing styles for the same "
"variable is not allowed."
msgstr ""
"Setter 函数和 Getter 函数在给一个变量定义时必须使用相同的定义格式，不允许混合"
"使用这两种定义格式。"

msgid ""
"You cannot specify type hints for *inline* setters and getters. This is done "
"on purpose to reduce the boilerplate. If the variable is typed, then the "
"setter's argument is automatically of the same type, and the getter's return "
"value must match it. Separated setter/getter functions can have type hints, "
"and the type must match the variable's type or be a wider type."
msgstr ""
"不允许对 *匿名*\\ setter 函数和 getter 函数进行类型指定，以减少代码的重复抄写"
"量。若变量含有指定的类型，则其 setter 函数的参数会自动转换到相同的类型，同时"
"其 getter 函数的返回值类型也必须与该类型相配。具名 setter/getter 函数允许指定"
"类型提示，但这些函数的设值/返回类型必须与该属性的类型或该类型的广义类型相配。"

msgid "When setter/getter is not called"
msgstr "Setter/getter 函数不会被调用的情况"

msgid ""
"When a variable is initialized, the value of the initializer will be written "
"directly to the variable. Including if the ``@onready`` annotation is "
"applied to the variable."
msgstr ""
"变量在进行初始化时，其初始值会直接赋予给该变量，包括 ``@onready`` 注解所修饰"
"的变量也是如此。"

msgid ""
"Using the variable's name to set it inside its own setter or to get it "
"inside its own getter will directly access the underlying member, so it "
"won't generate infinite recursion and saves you from explicitly declaring "
"another variable:"
msgstr ""
"在一个变量的 setter 函数和 getter 函数内访问该变量的变量名，会直接访问该变量"
"所代表的成员属性，不会导致 setter 函数和 getter 函数被无限次迭代调用，同时避"
"免了显式声明另一个变量："

msgid "This also applies to the alternative syntax:"
msgstr "这种情况也同样适用于替代语法："

msgid ""
"The exception does **not** propagate to other functions called in the setter/"
"getter. For example, the following code **will** cause an infinite recursion:"
msgstr ""
"这种例外\\ **不适用**\\ 于 setter/getter 中调用的其他函数。下面的示例代码\\ "
"**会**\\ 造成无限递归："

msgid "Tool mode"
msgstr "工具模式"

msgid ""
"By default, scripts don't run inside the editor and only the exported "
"properties can be changed. In some cases, it is desired that they do run "
"inside the editor (as long as they don't execute game code or manually avoid "
"doing so). For this, the ``@tool`` annotation exists and must be placed at "
"the top of the file:"
msgstr ""
"默认情况下，脚本不会在编辑器内运行，只有更改导出的属性这一操作会在编辑器内运"
"行。在某些情况下，我们确实希望这些代码能在编辑器中运行（只要这些代码不执行游"
"戏逻辑，也可以手动避免之）。为此可以用 ``@tool`` 注解，必须将其写在文件的顶"
"部："

msgid "See :ref:`doc_running_code_in_the_editor` for more information."
msgstr "详情见 :ref:`doc_running_code_in_the_editor`\\ 。"

msgid ""
"Be cautious when freeing nodes with ``queue_free()`` or ``free()`` in a tool "
"script (especially the script's owner itself). As tool scripts run their "
"code in the editor, misusing them may lead to crashing the editor."
msgstr ""
"由于工具脚本是在编辑器中运行代码的，故在工具脚本中使用 ``queue_free()`` 或 "
"``free()`` 释放节点时需要谨慎（尤其是对脚本所有者本身使用的时候更是如此）。对"
"工具脚本滥用释放节点代码可能会导致编辑器崩溃。"

msgid "Memory management"
msgstr "内存管理"

msgid ""
"Godot implements reference counting to free certain instances that are no "
"longer used, instead of a garbage collector, or requiring purely manual "
"management. Any instance of the :ref:`class_RefCounted` class (or any class "
"that inherits it, such as :ref:`class_Resource`) will be freed automatically "
"when no longer in use. For an instance of any class that is not "
"a :ref:`class_RefCounted` (such as :ref:`class_Node` or the "
"base :ref:`class_Object` type), it will remain in memory until it is deleted "
"with ``free()`` (or ``queue_free()`` for Nodes)."
msgstr ""
"Godot 通过实现引用计数来释放某些不再使用的实例，而非通过垃圾收集器（GC），或"
"者需要纯手动管理内存释放来实现这一操作。:ref:`class_RefCounted` 类（或继承该"
"类的任何类，例如 :ref:`class_Resource`）的任何实例在不再使用时将自动释放。对"
"于非 :ref:`class_RefCounted` 类（例如 :ref:`class_Node` 或基"
"本 :ref:`class_Object` 类型）的实例，这些实例将保留在内存中，直到使用 "
"``free()`` （或用于节点的 ``queue_free()``）才会从内存中删除。"

msgid ""
"If a :ref:`class_Node` is deleted via ``free()`` or ``queue_free()``, all of "
"its children will also recursively be deleted."
msgstr ""
"如果通过 ``free()`` 或 ``queue_free()`` 删除 :ref:`class_Node`\\ ，则它的所有"
"子节点也将会被递归删除。"

msgid ""
"To avoid reference cycles that can't be freed, a :ref:`class_WeakRef` "
"function is provided for creating weak references, which allow access to the "
"object without preventing a :ref:`class_RefCounted` from freeing. Here is an "
"example:"
msgstr ""
"为了避免造成无法释放的循环引用，Godot 提供了用于创建弱引用"
"的 :ref:`class_WeakRef` 类，可以访问到对象，但是不会阻"
"止 :ref:`class_RefCounted` 的释放。见下例："

msgid ""
"Alternatively, when not using references, the "
"``is_instance_valid(instance)`` can be used to check if an object has been "
"freed."
msgstr ""
"在没有使用引用的情况下，也可以用 ``is_instance_valid(instance)`` 来检查对象是"
"否已被释放。"

msgid "Signals"
msgstr "信号"

msgid ""
"Signals are a tool to emit messages from an object that other objects can "
"react to. To create custom signals for a class, use the ``signal`` keyword."
msgstr ""
"信号是从对象中发出消息的工具，其他对象可以对该信号做出反应。要为一个类创建自"
"定义信号，请使用 ``signal`` 关键字。"

msgid ""
"Signals are a `Callback <https://en.wikipedia.org/wiki/"
"Callback_(computer_programming)>`_ mechanism. They also fill the role of "
"Observers, a common programming pattern. For more information, read the "
"`Observer tutorial <https://gameprogrammingpatterns.com/observer.html>`_ in "
"the Game Programming Patterns ebook."
msgstr ""
"信号是一种\\ `回调 <https://zh.wikipedia.org/zh-cn/"
"%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0>`_\\ 机制，同时还充当观察者的角色，这是"
"一种常见的编程模式。有关更多信息，请阅读《游戏编程模式》电子书中的\\ `观察者"
"教程 <https://gameprogrammingpatterns.com/observer.html>`_\\ 。"

msgid ""
"You can connect these signals to methods the same way you connect built-in "
"signals of nodes like :ref:`class_Button` or :ref:`class_RigidBody3D`."
msgstr ""
"你可以将这些信号连接到方法，就像连接 :ref:`class_Button` "
"或 :ref:`class_RigidBody3D` 等节点的内置信号一样。"

msgid ""
"In the example below, we connect the ``health_depleted`` signal from a "
"``Character`` node to a ``Game`` node. When the ``Character`` node emits the "
"signal, the game node's ``_on_character_health_depleted`` is called:"
msgstr ""
"在下面的示例中，我们将 ``Character`` 节点的 ``health_depleted`` 信号连接到 "
"``Game`` 节点上。当 ``Character`` 节点发出信号时，Game 节点的 "
"``_on_character_health_depleted`` 就会被调用："

msgid "You can emit as many arguments as you want along with a signal."
msgstr "可以在发出一个信号时给该信号附带任意数量的参数。"

msgid ""
"Here is an example where this is useful. Let's say we want a life bar on "
"screen to react to health changes with an animation, but we want to keep the "
"user interface separate from the player in our scene tree."
msgstr ""
"下面这个示例就是该特性的一个不错的实现。假设我们希望屏幕上的生命条能够通过动"
"画对生命值做出反应，但我们希望在场景树中让用户界面与游戏角色保持独立。"

msgid ""
"In our ``character.gd`` script, we define a ``health_changed`` signal and "
"emit it with :ref:`Signal.emit() <class_Signal_method_emit>`, and from a "
"``Game`` node higher up our scene tree, we connect it to the ``Lifebar`` "
"using the :ref:`Signal.connect() <class_Signal_method_connect>` method:"
msgstr ""
"在我们的 ``character.gd`` 脚本中，我们定义了一个 ``health_changed`` 信号并使"
"用 :ref:`Signal.emit() <class_Signal_method_emit>` 发出它，并从我们场景树中更"
"高的 ``Game`` 节点发出，我们使用 :ref:`Signal.connect() "
"<class_Signal_method_connect>` 方法将其连接到 ``Lifebar``\\ ："

msgid ""
"In the ``Game`` node, we get both the ``Character`` and ``Lifebar`` nodes, "
"then connect the character, that emits the signal, to the receiver, the "
"``Lifebar`` node in this case."
msgstr ""
"在 ``Game`` 节点中，我们同时获得 ``Character`` 和 ``Lifebar`` 节点，然后将发"
"出信号的 ``Character`` 连接到接收者节点上，在本例中 ``Lifebar`` 为这一接收者"
"节点。"

msgid ""
"This allows the ``Lifebar`` to react to health changes without coupling it "
"to the ``Character`` node."
msgstr ""
"这样 ``Lifebar`` 就能够对生命值的变化做出反应，无需将其耦合到 ``Character`` "
"节点内。"

msgid ""
"You can write optional argument names in parentheses after the signal's "
"definition:"
msgstr "可以在信号的定义后面添加括号，并在该括号内写入可选的参数名称："

msgid ""
"These arguments show up in the editor's node dock, and Godot can use them to "
"generate callback functions for you. However, you can still emit any number "
"of arguments when you emit signals; it's up to you to emit the correct "
"values."
msgstr ""
"这些参数会显示在编辑器的节点面板中，Godot 会在生成回调函数时自动为你添加这些"
"参数。但是，在发出信号时仍然可以发出任意数量的参数，需要由你来确定该信号需要"
"准确发出的值。"

msgid ""
"You can also create copies of GDScript Callable objects which accept "
"additional arguments using :ref:`Callable.bind() "
"<class_Callable_method_bind>`. This allows you to add extra information to "
"the connection if the emitted signal itself doesn't give you access to all "
"the data that you need."
msgstr ""
"你还可以通过 :ref:`Callable.bind() <class_Callable_method_bind>` 制作 "
"GDScript 的 Callable 对象的副本，接受额外的参数。如果发出的信号没有提供你所需"
"要的所有数据，就可以通过这种方法为连接添加额外的信息。"

msgid ""
"When the signal is emitted, the callback method receives the bound values, "
"in addition to those provided by the signal."
msgstr "信号触发时，回调方法除接收信号参数外，还会收到绑定的值。"

msgid ""
"Building on the example above, let's say we want to display a log of the "
"damage taken by each character on the screen, like ``Player1 took 22 "
"damage.``. The ``health_changed`` signal doesn't give us the name of the "
"character that took damage. So when we connect the signal to the in-game "
"console, we can add the character's name using the bind method:"
msgstr ""
"接着上面的示例，我们要在屏幕上显示每个角色受到的伤害，例如 ``Player1 遭受了 "
"22 伤害。``\\ 。然而 ``health_changed`` 信号并没有给我们提供受到伤害的角色的"
"名称。因此，在我们将信号连接到游戏终端上时，可以在绑定参数这组数据中添加该角"
"色的名称："

msgid ""
"Our ``BattleLog`` node receives each bound element as an extra argument:"
msgstr "我们的 ``BattleLog`` 节点会收到绑定的元素，每个元素都是额外的参数："

msgid "Awaiting signals or coroutines"
msgstr "等待信号或协程函数"

msgid ""
"The ``await`` keyword can be used to create `coroutines <https://"
"en.wikipedia.org/wiki/Coroutine>`_ which wait until a signal is emitted "
"before continuing execution. Using the ``await`` keyword with a signal or a "
"call to a function that is also a coroutine will immediately return the "
"control to the caller. When the signal is emitted (or the called coroutine "
"finishes), it will resume execution from the point on where it stopped."
msgstr ""
"``await`` 关键字可以用来创建\\ `协程 <https://zh.wikipedia.org/wiki/"
"%E5%8D%8F%E7%A8%8B>`_\\ ，会等待某个信号发出之后再继续执行下面的代码。对信号"
"或者对同为协程的函数调用使用 ``await`` 关键字会立即将控制权返回给调用方。发出"
"信号时（或者调用的协程函数完成时），就会从停止的地方继续往下执行代码。"

msgid ""
"For example, to stop execution until the user presses a button, you can do "
"something like this:"
msgstr ""
"例如，要暂停代码执行，直到到用户按下某个按钮后才能继续往下执行剩余代码，你就"
"可以这样写："

msgid ""
"In this case, the ``wait_confirmation`` becomes a coroutine, which means "
"that the caller also needs to await it:"
msgstr ""
"此时 ``wait_confirmation`` 就会变成协程函数，调用方也需要对它进行等待操作："

msgid ""
"Note that requesting a coroutine's return value without ``await`` will "
"trigger an error:"
msgstr "请注意，不使用 ``await`` 直接请求协程的返回值会触发报错："

msgid ""
"However, if you don't depend on the result, you can just call it "
"asynchronously, which won't stop execution and won't make the current "
"function a coroutine:"
msgstr ""
"不过如果你不需要结果，那么直接异步调用即可，这样既不会阻止运行，也不会让当前"
"函数变为协程："

msgid ""
"If you use await with an expression that isn't a signal nor a coroutine, the "
"value will be returned immediately and the function won't give the control "
"back to the caller:"
msgstr ""
"如果对既不是信号也不是协程的表达式使用 await，则会立即返回对应的值，函数也不"
"会将控制权转交回调用方："

msgid ""
"This also means that returning a signal from a function that isn't a "
"coroutine will make the caller await that signal:"
msgstr "也就是说，如果从非协程函数中返回信号，那么调用方就会等待那个信号："

msgid ""
"Unlike ``yield`` in previous Godot versions, you cannot obtain the function "
"state object. This is done to ensure type safety. With this type safety in "
"place, a function cannot say that it returns an ``int`` while it actually "
"returns a function state object during runtime."
msgstr ""
"与之前版本 Godot 中的 ``yield`` 不同，出于类型安全的考虑，现版本无法获取函数"
"状态对象。实现了这种类型安全之后，就不能说函数在返回 ``int`` 的同时还可能在运"
"行时返回函数状态对象了。"

msgid "Assert keyword"
msgstr "Assert 关键字"

msgid ""
"The ``assert`` keyword can be used to check conditions in debug builds. "
"These assertions are ignored in non-debug builds. This means that the "
"expression passed as argument won't be evaluated in a project exported in "
"release mode. Due to this, assertions must **not** contain expressions that "
"have side effects. Otherwise, the behavior of the script would vary "
"depending on whether the project is run in a debug build."
msgstr ""
"``assert`` 关键字可用于在调试版本中检查断言条件，而在非调试版本中则会忽略掉这"
"些断言，意味着在发布模式下导出的项目中断言语法不会评估作为参数传递的表达式。"
"因此，断言 **决不能** 包含具有副作用的表达式，否则，脚本的行为将取决于该项目"
"是否在调试版本中运行。"

msgid ""
"When running a project from the editor, the project will be paused if an "
"assertion error occurs."
msgstr "在编辑器中运行项目时，如果发生断言错误，则会暂停该项目的运行。"

msgid ""
"You can optionally pass a custom error message to be shown if the assertion "
"fails:"
msgstr "你还可以传入自定义错误消息，这些消息会在断言失败时显示："
