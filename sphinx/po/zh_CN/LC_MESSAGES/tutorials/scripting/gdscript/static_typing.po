#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Static typing in GDScript"
msgstr "GDScript 静态类型编程"

msgid "In this guide, you will learn:"
msgstr "在本指南中，你将学会："

msgid "how to use static typing in GDScript;"
msgstr "如何在 GDScript 中使用静态类型编程;"

msgid "that static types can help you avoid bugs;"
msgstr "静态类型编程可以帮助你避免问题;"

msgid "that static typing improves your experience with the editor."
msgstr "静态类型编程可以提升编辑器的使用体验。"

msgid ""
"Where and how you use this language feature is entirely up to you: you can "
"use it only in some sensitive GDScript files, use it everywhere, or don't "
"use it at all."
msgstr ""
"这项语言功能的使用场合、使用方式完全取决于你：你可以只在部分敏感的 GDScript "
"文件中使用，也可以在所有地方都使用，甚至可以完全不使用。"

msgid ""
"Static types can be used on variables, constants, functions, parameters, and "
"return types."
msgstr "静态类型编程可用于变量、常量、函数、参数和返回类型。"

msgid "A brief look at static typing"
msgstr "静态类型编程简介"

msgid ""
"With static typing, GDScript can detect more errors without even running the "
"code. Also type hints give you and your teammates more information as you're "
"working, as the arguments' types show up when you call a method. Static "
"typing improves editor autocompletion and :ref:`documentation "
"<doc_gdscript_documentation_comments>` of your scripts."
msgstr ""
"使用 GDScript 静态类型编程，Godot 在编写代码时甚至可以帮你检测到更多代码错"
"误，在你工作时为你和你的团队提供更多信息，当你调用方法时，会显示出参数的类"
"型。静态类型编程也能改善编辑器的自动补全体验，其中也包括脚本的\\ :ref:`文档 "
"<doc_gdscript_documentation_comments>`\\ 。"

msgid ""
"Static types also give you better code completion options. Below, you can "
"see the difference between a dynamic and a static typed completion options."
msgstr ""
"静态类型编程还能为你提供更好的代码补全选项。下面，你可以看到一个名为 "
"``PlayerController`` 类的动态类型和静态类型补全选项之间的区别。"

msgid ""
"You've probably encountered a lack of autocomplete suggestions after a dot:"
msgstr ""
"你之前可能已经将节点存储在了变量中，打了一个句点符号，却没有代码自动补全提"
"示："

msgid "Completion options for dynamic typed code."
msgstr "动态类型的代码补全选项。"

msgid ""
"This is due to dynamic code. Godot cannot know what value type you're "
"passing to the function. If you write the type explicitly however, you will "
"get all methods, properties, constants, etc. from the value:"
msgstr ""
"由于动态代码是动态的，因此 Godot 无法得知你传递给函数的值的类型。可如果你明确"
"地声明了类型，则将从该节点类型获取所有公共方法和变量："

msgid "Completion options for static typed code."
msgstr "静态类型的代码补全选项。"

msgid ""
"If you prefer static typing, we recommend enabling the **Text Editor > "
"Completion > Add Type Hints** editor setting. Also consider enabling `some "
"warnings <Warning system_>`_ that are disabled by default."
msgstr ""
"若偏向静态类型编程，建议开启编辑器选项\\ **文本编辑器 > 补全 > 添加类型提示"
"**\\ ，顺便也可以考虑开启默认关闭的\\ `某些选项 <Warning system_>`_\\ 。"

msgid ""
"Also, typed GDScript improves performance by using optimized opcodes when "
"operand/argument types are known at compile time. More GDScript "
"optimizations are planned in the future, such as JIT/AOT compilation."
msgstr ""
"同时，在操作数/参数类型在编译时已知时，静态类型编程编写的 GDScript 代码还能通"
"过优化后的操作码提升代码运行性能。未来还计划进行更多 GDScript 方面的优化，如 "
"JIT/AOT 编译。"

msgid ""
"Overall, typed programming gives you a more structured experience. It helps "
"prevent errors and improves the self-documenting aspect of your scripts. "
"This is especially helpful when you're working in a team or on a long-term "
"project: studies have shown that developers spend most of their time reading "
"other people's code, or scripts they wrote in the past and forgot about. The "
"clearer and the more structured the code, the faster it is to understand, "
"the faster you can move forward."
msgstr ""
"总体而言，静态类型编程可为你提供更加结构化的体验，有助于避免代码错误，改善脚"
"本的文档生成能力。当你在团队中或长期项目中工作时，静态类型编程将会特别有用。"
"研究表明，开发人员将大部分时间要么都花在阅读别人的代码上，要么都花在阅读他们"
"以前编写过但后来忘掉的脚本上。代码越清晰、越结构化，开发人员理解得也就越快，"
"项目开发的速度也就越快。"

msgid "How to use static typing"
msgstr "如何使用静态类型编程"

msgid "There is no difference between ``=`` and ``:=`` for constants."
msgstr "对于常量而言，\\ ``=`` 和 ``:=`` 没有区别。"

msgid ""
"You don't need to write type hints for constants, as Godot sets it "
"automatically from the assigned value. But you can still do so to make the "
"intent of your code clearer. Also, this is useful for typed arrays (like "
"``const A: Array[int] = [1, 2, 3]``), since untyped arrays are used by "
"default."
msgstr ""
"常量不需要写类型提示，Godot 会自动根据所赋的值设置该常量的类型，你仍然可以写"
"上类型提示来让代码更整洁。同时，这样写对于类型化数组也还是很有用的（比如 "
"``const A: Array[int] = [1, 2, 3]``\\ ），因为默认使用的是无类型的数组。"

msgid "What can be a type hint"
msgstr "类型提示可以是什么"

msgid "Here is a complete list of what can be used as a type hint:"
msgstr "下面列出的是所有可以用作类型提示的东西："

msgid ""
"``Variant``. Any type. In most cases this is not much different from an "
"untyped declaration, but increases readability. As a return type, forces the "
"function to explicitly return some value."
msgstr ""
"``Variant``\\ ，任何类型。大多数情况下与不写类型声明差不多，但能够增加可读"
"性。作为返回类型时，能够强制函数显式返回值。"

msgid ""
"*(Only return type)* ``void``. Indicates that the function does not return "
"any value."
msgstr "*（仅作返回类型使用）* ``void``\\ 。表示函数不返回任何值。"

msgid ":ref:`Built-in types <doc_gdscript_builtin_types>`."
msgstr ":ref:`内置类型 <doc_gdscript_builtin_types>`\\ 。"

msgid "Native classes (``Object``, ``Node``, ``Area2D``, ``Camera2D``, etc.)."
msgstr ""
"原生类（\\ ``Object``\\ 、\\ ``Node``\\ 、\\ ``Area2D``\\ 、\\ ``Camera2D`` "
"等）。"

msgid ":ref:`Global classes <doc_gdscript_basics_class_name>`."
msgstr ":ref:`全局类 <doc_gdscript_basics_class_name>`\\ 。"

msgid ":ref:`Inner classes <doc_gdscript_basics_inner_classes>`."
msgstr ":ref:`内部类 <doc_gdscript_basics_inner_classes>`\\ 。"

msgid ""
"Global, native and custom named enums. Note that an enum type is just an "
"``int``, there is no guarantee that the value belongs to the set of enum "
"values."
msgstr ""
"全局具名常量与内部具名常量。注意：枚举是 ``int`` 类型的数据，不能保证一个值属"
"于该枚举。"

msgid ""
"Constants (including local ones) if they contain a preloaded class or enum."
msgstr "包含预加载类和枚举的常量（或局部常量）。"

msgid "Specify the return type of a function with the arrow ``->``"
msgstr "使用箭头 ``->`` 来定义函数的返回类型"

msgid "Covariance and contravariance"
msgstr "协变与逆变"

msgid ""
"When inheriting base class methods, you should follow the `Liskov "
"substitution principle <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__."
msgstr ""
"继承基类方法时，应遵循\\ `里氏代换原则 <https://en.wikipedia.org/wiki/"
"Liskov_substitution_principle>`__\\ 。"

msgid ""
"**Covariance:** When you inherit a method, you can specify a return type "
"that is more specific (**subtype**) than the parent method."
msgstr ""
"**协变：**\\ 继承方法时，你可以为子类方法指定一个比该子类方法的父类方法更为具"
"体的返回值类型（\\ **子类型**\\ ）。"

msgid ""
"**Contravariance:** When you inherit a method, you can specify a parameter "
"type that is less specific (**supertype**) than the parent method."
msgstr ""
"**逆变：**\\ 继承方法时，你可以为子类方法指定一个比该子类方法的父类方法更不具"
"体的参数类型（\\ **超类型**\\ ）。"

msgid "Example:"
msgstr "示例："

msgid "Specify the element type of an ``Array``"
msgstr "指定 ``Array`` 的元素类型"

msgid "To define the type of an ``Array``, enclose the type name in ``[]``."
msgstr "要定义 Array 的类型，请将类型名称填写在 ``[]`` 内。"

msgid ""
"The array will remain untyped, but the ``name`` variable within the ``for`` "
"loop will always be of ``String`` type."
msgstr ""
"数组仍旧不会限定类型，但 ``for`` 循环的 ``name`` 循环变量则始终为 ``String`` "
"类型。"

msgid "Type casting"
msgstr "类型转换"

msgid ""
"Type casting is an important concept in typed languages. Casting is the "
"conversion of a value from one type to another."
msgstr ""
"类型转换是类型语言的关键概念，转型是指将值从一种类型转换为另一种类型的操作或"
"过程。"

msgid ""
"Imagine an ``Enemy`` in your game, that ``extends Area2D``. You want it to "
"collide with the ``Player``, a ``CharacterBody2D`` with a script called "
"``PlayerController`` attached to it. You use the ``body_entered`` signal to "
"detect the collision. With typed code, the body you detect is going to be a "
"generic ``PhysicsBody2D``, and not your ``PlayerController`` on the "
"``_on_body_entered`` callback."
msgstr ""
"想象你的游戏中的一个敌人，\\ ``extends Area2D``\\ 。你希望它与游戏角色，即一"
"个附带有一个名为 ``PlayerController`` 的脚本的 ``CharacterBody2D``, 碰撞，那"
"么你可以使用 ``body_entered`` 信号来检测碰撞。使用类型化代码，其检测到的物体"
"（body）将是通用的 ``PhysicsBody2D`` 而非 ``_on_body_entered`` 回调上使用的 "
"``PlayerController``\\ 。"

msgid ""
"As we're dealing with a custom type, if the ``body`` doesn't extend "
"``PlayerController``, the ``player`` variable will be set to ``null``. We "
"can use this to check if the body is the player or not. We will also get "
"full autocompletion on the player variable thanks to that cast."
msgstr ""
"在处理自定义类型时，如果 ``body`` 没有继承 ``PlayerController`` 类，则 "
"``player`` 变量将被赋值为 ``null``\\ 。我们可以用这种操作来检查物体是否为游戏"
"玩家角色。多亏了类型转换，我们还能获得 ``player`` 变量的代码自动补全功能。"

msgid ""
"If you try to cast with a built-in type and it fails, Godot will throw an "
"error."
msgstr ""
"如果你尝试使用内置类型进行转型且转型失败，则将触发 Godot 脚本编辑器底部报错。"

msgid "Safe lines"
msgstr "安全行"

msgid ""
"You can also use casting to ensure safe lines. Safe lines are a tool to tell "
"you when ambiguous lines of code are type-safe. As you can mix and match "
"typed and dynamic code, at times, Godot doesn't have enough information to "
"know if an instruction will trigger an error or not at runtime."
msgstr ""
"你也可以使用转型语法来确保存在安全行，安全行是 Godot 3.1 中加入的新工具，可以"
"告诉你一行歧义代码在什么情况下类型安全。由于你有时会混合使用静态类型代码和动"
"态类型代码，有时如果指令在运行时触发错误，Godot 可能没有足够的信息进行判断。"

msgid ""
"This happens when you get a child node. Let's take a timer for example: with "
"dynamic code, you can get the node with ``$Timer``. GDScript supports `duck-"
"typing <https://stackoverflow.com/a/4205163/8125343>`__, so even if your "
"timer is of type ``Timer``, it is also a ``Node`` and an ``Object``, two "
"classes it extends. With dynamic GDScript, you also don't care about the "
"node's type as long as it has the methods you need to call."
msgstr ""
"当你需要获得子节点时就会发生这种情况。以计时器为例：使用动态代码，你可以使用 "
"``$Timer`` 获取节点。GDScript 支持\\ `鸭子类型 <https://stackoverflow.com/a/"
"4205163/8125343>`__\\ ，即使你的计时器是 ``Timer`` 类型，计时器也继承了 "
"``Node`` 和 ``Object`` 这两个类。使用动态类型的 GDScript，只要节点具有你需要"
"调用的方法，你也不必关心节点的类型。"

msgid ""
"You can use casting to tell Godot the type you expect when you get a node: "
"``($Timer as Timer)``, ``($Player as CharacterBody2D)``, etc. Godot will "
"ensure the type works and if so, the line number will turn green at the left "
"of the script editor."
msgstr ""
"当你得到一个节点时，可以使用强制转型来告诉 Godot 你所期望的类型： ``($Timer "
"as Timer)`` 、 ``($Player as KinematicBody2D)`` 等，Godot 将确认该类型是否有"
"效，如果有效，在脚本编辑器的左侧的行号将会变为绿色。"

msgid "Unsafe vs Safe Line"
msgstr "不安全行 vs 安全行"

msgid "Unsafe line (line 7) vs Safe Lines (line 6 and 8)"
msgstr "不安全代码行（第 7 行）vs 安全代码行（第 6 行和第 8 行）"

msgid ""
"Even though ``node_2`` declaration is marked as an unsafe line, it is more "
"reliable than ``node_1`` declaration. Because if you change the node type in "
"the scene and accidentally forget to change it in the script, the error will "
"be detected immediately when the scene is loaded. Unlike ``node_1``, which "
"will be silently cast to ``null`` and the error will be detected later."
msgstr ""
"虽然 ``node_2`` 的声明被标记为了不安全行，但比起 ``node_1`` 的声明来看却更加"
"可靠，这是因为如果你不小心在场景中更改了节点的类型，又忘记把它改回去的话，就"
"会在场景加载时触发报错。\\ ``node_1`` 的情况则是会被静默转型成 ``null`` ，触"
"发报错。"

msgid ""
"You can turn off safe lines or change their color in the editor settings."
msgstr "可以在编辑器设置中关闭安全行或更改其颜色。"

msgid "Typed or dynamic: stick to one style"
msgstr "静态编程还是动态编程：坚持一种风格"

msgid ""
"Typed GDScript and dynamic GDScript can coexist in the same project. But "
"it's recommended to stick to either style for consistency in your codebase, "
"and for your peers. It's easier for everyone to work together if you follow "
"the same guidelines, and faster to read and understand other people's code."
msgstr ""
"静态类型的 GDScript 和动态类型的 GDScript 可共存于同一项目，但还是建议二选其"
"一，以确保每个人代码风格的一致性。如果你们遵循相同的规范，那么每个人就都可以"
"更轻松地协作，阅读、理解他人的代码也就会更加迅速。"

msgid "::"
msgstr "： ::"

msgid "pass"
msgstr "pass"

msgid "Warning system"
msgstr "警告系统"

msgid ""
"Detailed documentation about the GDScript warning system has been moved "
"to :ref:`doc_gdscript_warning_system`."
msgstr ""
"关于 GDScript 警告系统的文档已移至 :ref:`doc_gdscript_warning_system`\\ 。"

msgid ""
"We have a number of warnings aimed specifically at users of typed GDScript. "
"By default, these warnings are disabled, you can enable them in Project "
"Settings (**Debug > GDScript**, make sure **Advanced Settings** is enabled)."
msgstr ""
"对于静态类型 GDScript 编程的用户，我们提供了大量警告，这些警告默认关闭，但你"
"可以将这些警告在项目设置（**调试 > GDScript**）中开启，在此之前，请确保你已启"
"用了项目设置的**高级设置**模式。"

msgid ""
"You can enable the ``UNTYPED_DECLARATION`` warning if you want to always use "
"static types. Additionally, you can enable the ``INFERRED_DECLARATION`` "
"warning if you prefer a more readable and reliable, but more verbose syntax."
msgstr ""
"若始终进行静态类型编程，你可以启用 ``UNTYPED_DECLARATION`` 警告。此外，你还可"
"以启用 ``INFERRED_DECLARATION`` 警告来让你的代码可读性更强、更有可靠性，但同"
"时也会让你的代码更加冗长。"

msgid ""
"``UNSAFE_*`` warnings make unsafe operations more noticeable, than unsafe "
"lines. Currently, ``UNSAFE_*`` warnings do not cover all cases that unsafe "
"lines cover."
msgstr ""
"``UNSAFE_*`` 警告会让不安全操作比不安全行更容易引人注意。目前, ``UNSAFE_*`` "
"警告并不能涵盖不安行所涵盖的所有情况。"

msgid "Common unsafe operations and their safe counterparts"
msgstr "常见的不安全操作及其安全操作"

msgid "``UNSAFE_PROPERTY_ACCESS`` and ``UNSAFE_METHOD_ACCESS`` warnings"
msgstr "``UNSAFE_PROPERTY_ACCESS`` 与 ``UNSAFE_METHOD_ACCESS`` 警告"

msgid "``UNSAFE_CAST`` warning"
msgstr "``UNSAFE_CAST`` 警告"

msgid "Cases where you can't specify types"
msgstr "不能指定类型的情况"

msgid ""
"To wrap up this introduction, let's mention cases where you can't use type "
"hints. This will trigger a **syntax error**."
msgstr ""
"最后，我们将介绍一些不能使用类型提示的情况。以下所有示例 **都会触发报错** 。"

msgid "Summary"
msgstr "总结"

msgid ""
"Typed GDScript is a powerful tool. It helps you write more structured code, "
"avoid common errors, and create scalable and reliable systems. Static types "
"improve GDScript performance and more optimizations are planned for the "
"future."
msgstr ""
"静态类型的 GDScript 是一个十分强大的工具，可以帮助编写更多结构化的代码，避免"
"常见错误，创建灵活的代码系统。将来，由于即将进行的编译器优化，静态类型也将会"
"带来不错的性能提升。"
