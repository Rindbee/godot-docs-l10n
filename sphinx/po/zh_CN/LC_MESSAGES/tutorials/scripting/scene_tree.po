#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using SceneTree"
msgstr "使用 SceneTree"

msgid "Introduction"
msgstr "前言"

msgid ""
"In previous tutorials, everything revolved around the concept of nodes. "
"Scenes are collections of nodes. They become active once they enter the "
"*scene tree*."
msgstr ""
"在之前的教程中，所有内容都是围绕节点这一概念展开的。场景是节点的合集，节点一"
"进入 *场景树* 就会被激活。"

msgid "MainLoop"
msgstr "MainLoop"

msgid ""
"The way Godot works internally is as follows. There is the :ref:`OS "
"<class_OS>` class, which is the only instance that runs at the beginning. "
"Afterwards, all drivers, servers, scripting languages, scene system, etc are "
"loaded."
msgstr ""
"Godot 内部的工作方式是这样的：开始的时候只会有一个 :ref:`OS <class_OS>` 类的"
"实例在运行，然后才会把驱动程序、服务器、脚本语言、场景系统等等这些加载进来。"

msgid ""
"When initialization is complete, :ref:`OS <class_OS>` needs to be supplied "
"a :ref:`MainLoop <class_MainLoop>` to run. Up to this point, all this is "
"internals working (you can check main/main.cpp file in the source code if "
"you are ever interested to see how this works internally)."
msgstr ""
"初始化完成后，就会为 :ref:`OS <class_OS>` 提供一个 :ref:`MainLoop "
"<class_MainLoop>` 来运行。目前为止的所有内容都是内部工作（如果你有兴趣查看内"
"部如何工作，可以在源代码中查看 main/main.cpp 文件）。"

msgid ""
"The user program, or game, starts in the MainLoop. This class has a few "
"methods, for initialization, idle (frame-synchronized callback), fixed "
"(physics-synchronized callback), and input. Again, this is low level and "
"when making games in Godot, writing your own MainLoop seldom makes sense."
msgstr ""
"用户程序或游戏会在 MainLoop 中启动，这个类包含初始化、空闲（帧同步回调）、固"
"定（物理同步回调）、输入等方法。当然这也属于底层，用 Godot 制作游戏时几乎不会"
"遇到需要自行编写 MainLoop 的情况。"

msgid "SceneTree"
msgstr "SceneTree"

msgid ""
"The scene system provides its own main loop to OS, :ref:`SceneTree "
"<class_SceneTree>`. This is automatically instanced and set when running a "
"scene, no need to do any extra work."
msgstr ""
"场景系统为 OS 提供了自己的主循环，即 :ref:`SceneTree <class_SceneTree>`\\ 。"
"运行场景时会自动实例化并设置该场景，无需执行任何其他工作。"

msgid ""
"It's important to know that this class exists because it has a few important "
"uses:"
msgstr "重要的是要知道此类的存在, 因为它有一些重要的用途:"

msgid ""
"It contains the root :ref:`Viewport <class_Viewport>`, to which a scene is "
"added as a child when it's first opened to become part of the *Scene Tree* "
"(more on that next)."
msgstr ""
"它包含根 :ref:`Viewport <class_Viewport>`, 当场景第一次打开成为 *Scene Tree* "
"的一部分时, 会将场景作为子级添加到其中(接下来会有更多)."

msgid ""
"It contains information about the groups and has the means to call all nodes "
"in a group or get a list of them."
msgstr "它包含有关编组的信息, 并具有调用编组中所有节点或获取它们的列表的方法."

msgid ""
"It contains some global state functionality, such as setting pause mode or "
"quitting the process."
msgstr "它包含一些全局状态功能, 例如设置暂停模式或退出进程."

msgid ""
"When a node is part of the Scene Tree, the :ref:`SceneTree "
"<class_SceneTree>` singleton can be obtained by "
"calling :ref:`Node.get_tree() <class_Node_method_get_tree>`."
msgstr ""
"当节点是场景树的一部分时, 可以通过调用 :ref:`Node.get_tree() "
"<class_Node_method_get_tree>` 获得 :ref:`SceneTree <class_SceneTree>` 单例."

msgid "Root viewport"
msgstr "根视图"

msgid ""
"The root :ref:`Viewport <class_Viewport>` is always at the top of the scene. "
"From a node, it can be obtained in two different ways:"
msgstr ""
"根 :ref:`Viewport <class_Viewport>` 始终位于场景的顶部. 从一个节点, 可以通过"
"两种不同的方式获得它:"

msgid ""
"This node contains the main viewport. Anything that is a child of "
"a :ref:`Viewport <class_Viewport>` is drawn inside of it by default, so it "
"makes sense that the top of all nodes is always a node of this type "
"otherwise nothing would be seen."
msgstr ""
"此节点包含主视口, 默认情况下, :ref:`Viewport <class_Viewport>` 的任何子节点都"
"将绘制在其中, 因此以Viewport作为根节点是有意义的, 否则将看不到任何内容."

msgid ""
"While other viewports can be created in the scene (for split-screen effects "
"and such), this one is the only one that is never created by the user. It's "
"created automatically inside SceneTree."
msgstr ""
"尽管可以在场景中创建其他视图(用于分屏效果等), 但该视图是唯一不由用户创建的视"
"图. 它是在 ``SceneTree`` 内部自动创建的."

msgid "Scene tree"
msgstr "场景树"

msgid ""
"When a node is connected, directly or indirectly, to the root viewport, it "
"becomes part of the *scene tree*."
msgstr "当节点直接或间接连接到根视图时，它就成为了\\ *场景树*\\ 的一部分。"

msgid ""
"This means that as explained in previous tutorials, it will get the "
"``_enter_tree()`` and ``_ready()`` callbacks (as well as ``_exit_tree()``)."
msgstr ""
"因此，正如在之前的教程中所解释的，它将获得 ``_enter_tree()`` 和 ``_ready()`` "
"回调（以及 ``_exit_tree()`` ）。"

msgid ""
"When nodes enter the *Scene Tree*, they become active. They get access to "
"everything they need to process, get input, display 2D and 3D visuals, "
"receive and send notifications, play sounds, etc. When they are removed from "
"the *scene tree*, they lose these abilities."
msgstr ""
"当节点进入\\ *场景树*\\ 时，它们将变为活动状态。它们可以访问需要处理的所有内"
"容、获取输入、显示 2D 和 3D 视觉效果、收发通知、播放声音等。当从\\ *场景树"
"*\\ 中删除时，它们将失去这些能力。"

msgid "Tree order"
msgstr "树顺序"

msgid ""
"Most node operations in Godot, such as drawing 2D, processing, or getting "
"notifications are done in *tree order*, or top to bottom as seen in the "
"editor (also known as pre-order traversal):"
msgstr ""
"Godot中的大多数节点操作，如绘制 2D、处理或获取notifications(通知)，都是以 *树"
"型顺序* 或编辑器中看到的自上而下的方式完成的(也称为前序遍历):"

msgid ""
"For example, the top node in a scene has its ``_process()`` function called "
"first, then the node below it has its ``_process()`` function called, then "
"the node below that and so on."
msgstr ""
"例如，场景中的顶部节点首先调用其``_process()``函数，然后它下面的节点调用其"
"``_process()``函数，然后是它下面的节点，依此类推。"

msgid ""
"The order of operations can also be overridden using the "
"``process_priority`` node property. Nodes with a lower number are called "
"first. For example, nodes with the priorities \"0, 1, 2, 3\" would be called "
"in that order from left to right."
msgstr ""
"也可以使用``process_priority``节点属性覆盖操作顺序。首先调用编号较小的节点。"
"例如，优先级为 “0、1、2、3” 的节点将按从左到右的顺序被调用。"

msgid "\"Becoming active\" by entering the *Scene Tree*"
msgstr "通过进入\\ *场景树*\\ “变为活动状态”"

msgid "A scene is loaded from disk or created by scripting."
msgstr "从磁盘加载场景或通过脚本创建场景。"

msgid ""
"Every node of the newly added scene will receive the \"enter_tree\" "
"notification ( ``_enter_tree()`` callback in GDScript) in top-to-bottom "
"order (pre-order traversal)."
msgstr ""
"新添加的场景的每个节点都将按照从上到下的顺序接收 ``enter_tree`` 通知"
"（GDScript 中的 ``_enter_tree()`` 回调函数）。"

msgid ""
"When a scene (or part of it) is removed, they receive the \"exit scene\" "
"notification ( ``_exit_tree()`` callback in GDScript) in bottom-to-top order "
"(the exact reverse of top-to-bottom order)."
msgstr ""
"删除场景（或场景的一部分）后，它们将按照自底向上的顺序（自顶向下的逆序）收到 "
"``exit scene`` 通知（GDScript中的 ``_exit_tree()`` 回调函数）。"

msgid "Changing current scene"
msgstr "更改当前场景"
