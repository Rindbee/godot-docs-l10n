#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "GDExtension C example"
msgstr "GDExtension C 示例"

msgid "Introduction"
msgstr "前言"

msgid ""
"This is a simple example on how to work with GDExtension directly with C "
"code. Note that the API is not meant to be used directly, so this will "
"definitely be quite verbose and require a lot of steps even for a small "
"example. However, it serves as a reference for creating bindings for a "
"different language. It is still possible to use the API directly if you "
"prefer, which might be convenient when only binding a third-party library."
msgstr ""
"这是一个关于如何在 C 代码中直接使用 GDExtension 的简单示例。请注意，相关 API "
"的初衷并不是直接使用，所以注定会相当冗长，即便是小型示例也需要大量步骤。不过"
"可以把这个示例当作绑定其他语言的参考。如果你愿意，仍然可以直接使用这些 API，"
"用来绑定第三方库的话可能比较方便。"

msgid ""
"In this example we will create a custom node that moves a sprite on the "
"screen based on the user's parameters. While very simple, it serves to show "
"how to do some of the things with GDExtension, like registering custom "
"classes with methods, properties, and signals. It gives an insight on the "
"GDExtension API."
msgstr ""
"在这个示例中，我们将创建一个自定义节点，会根据用户参数在屏幕上移动精灵。虽然"
"非常简单，但它展示了 GDExtension 的使用方法，比如注册带有方法、属性和信号的自"
"定义类，可以让你对 GDExtension API 有一个初步的了解。"

msgid "Setting up the project"
msgstr "设置项目"

msgid "There are a few prerequisites you'll need:"
msgstr "这里有一些前置需求是你需要的："

msgid "a Godot 4.2 (or later) executable,"
msgstr "Godot 4.2（或后续版本）可执行文件，"

msgid "a C compiler,"
msgstr "C 编译器，"

msgid "SCons as a build tool."
msgstr "使用 Scons 作为构建工具。"

msgid ""
"Since this is using the API directly, there's no need to use the `godot-cpp "
"repository <https://github.com/godotengine/godot-cpp>`__."
msgstr ""
"由于是直接使用 API，就不需要使用 `godot-cpp 仓库 <https://github.com/"
"godotengine/godot-cpp>`__\\ 了。"

msgid "File structure"
msgstr "文件结构"

msgid "To organize our files, we're gonna split into mainly two folders:"
msgstr "我们主要分两个文件夹来组织文件："

msgid ""
"We also need a copy of the ``gdextension_interface.h`` header from the Godot "
"source code, which can be obtained directly from the Godot executable by "
"running the following command:"
msgstr ""
"我们还需要复制一份 Godot 源码中的 ``gdextension_interface.h`` 头文件，可以运"
"行下面的命令直接从 Godot 可执行文件中获取："

msgid ""
"This creates the header in the current folder, so you can just copy it to "
"the ``src`` folder in the example project."
msgstr ""
"这样就会在当前文件夹中创建这个头文件，你可以将其复制到示例项目的 ``src`` 文件"
"夹中。"

msgid ""
"Lastly, there's another source of information we need to refer to, which is "
"the JSON file with the Godot API reference. This file won't be used by the "
"code directly, we will only use it to extract some information manually."
msgstr ""
"最后，我们还需要参考另一个信息来源，那就是包含 Godot API 参考的 JSON 文件。代"
"码不会直接使用这个文件，我们只会手动从中提取一些信息。"

msgid "To get this JSON file, just call the Godot executable:"
msgstr "要获取这个 JSON 文件，只需调用 Godot 可执行文件："

msgid ""
"The resulting ``extension_api.json`` file will be created in the current "
"folder. You can copy this file to the example folder to have it handy."
msgstr ""
"最终的 ``extension_api.json`` 文件会在当前文件夹中创建。你可以将其复制到示例"
"文件夹中，方便查看。"

msgid ""
"This extension is targeting Godot 4.2, but it should work on later versions "
"as well. If you want to target a different minimal version, make sure to get "
"the header and the JSON from the version Godot version you are targeting."
msgstr ""
"这个扩展是针对 Godot 4.2 开发的，但应该也能在后续版本中使用。如果你想要针对其"
"他最低版本开发，请确保从该版本的 Godot 中获取对应的头文件和 JSON。"

msgid "Buildsystem"
msgstr "构建系统"

msgid ""
"Using a buildsystem makes our life a lot easier when dealing with C code. "
"For the sake of convenience, we'll use SCons since it's the same as what "
"Godot itself uses."
msgstr ""
"使用构建系统可以让我们在处理 C 代码时更加轻松。方便起见，我们将使用 SCons，因"
"为 Godot 本身使用的就是这个构建系统。"

msgid ""
"The following ``SConstruct`` file is a simple one that will build your "
"extension to the current platform that you are using, be it Linux, macOS, or "
"Windows. This will be a non-optimized build for debugging purposes. It also "
"assumes a 64-bit build, which is relevant for some parts of the example "
"code. Making other build types and cross-compilation is out of the scope of "
"this tutorial. Save this file to the root folder."
msgstr ""
"下面的 ``SConstruct`` 文件是一个简单的示例，会根据你当前使用的平台来构建扩"
"展，无论是 Linux、macOS 还是 Windows。得到的是一个用于调试的未优化构建。这个"
"文件还认为你要使用 64 位构建，示例代码中的某些部分会涉及到。制作其他构建类型"
"和交叉编译都不在本教程的讨论范围内。请将此文件保存到根文件夹中。"

msgid ""
"This will include all C files in the ``src`` folder, so we don't need to "
"change this file when adding new source files."
msgstr ""
"这个文件会包含 ``src`` 文件夹中的所有 C 文件，因此在添加新的源文件时，我们就"
"不需要再更改此文件了。"

msgid "Initializing the extension"
msgstr "初始化扩展"

msgid ""
"The first bit of code will be responsible for initializing the extension. "
"This is what makes Godot aware of what our GDExtension provides, such as "
"classes and plugins."
msgstr ""
"第一段代码负责扩展的初始化，作用是让 Godot 知道我们的 GDExtension 提供了哪些"
"内容，例如类和插件。"

msgid ""
"Create the file ``init.h`` in the ``src`` folder, with the following "
"contents:"
msgstr "请在 ``src`` 文件夹中创建 ``init.h`` 文件，内容如下："

msgid ""
"The functions declared here have the signatures expected by the GDExtension "
"API."
msgstr "这里声明的函数具有 GDExtension API 所期望的签名。"

msgid ""
"Note the inclusion of the ``defs.h`` file. This is one of our helpers to "
"simplify writing the extension code. For now it will only contain the "
"definition of ``GDE_EXPORT``, a macro that makes the function public in the "
"shared library so Godot can properly call it. This macro helps abstracting "
"what each compiler expects."
msgstr ""
"注意其中包含了 ``defs.h`` 文件。这是我们的一个辅助工具，用于简化扩展代码的编"
"写。目前它只包含 ``GDE_EXPORT`` 的定义，这是一个宏，用于在共享库中公开函数，"
"方便 Godot 正确调用。这个宏有助于抽象不同编译器的要求。"

msgid ""
"Create the ``defs.h`` file in the ``src`` folder with the following contents:"
msgstr "请在 ``src`` 文件夹中创建 ``defs.h`` 文件，内容如下："

msgid ""
"We also include some standard headers to make things easier. Now we only "
"have to include ``defs.h`` and those will come as a bonus."
msgstr ""
"我们还包含了一些标准头文件来简化操作。现在只需要包含 ``defs.h`` 就会顺带把这"
"些头文件包含进来。"

msgid ""
"Now, let's implement the functions we just declared. Create a file called "
"``init.c`` in the ``src`` folder and add this code:"
msgstr ""
"现在，让我们来实现刚刚声明的函数。请在 ``src`` 文件夹中创建一个名为 "
"``init.c`` 的文件，添加以下代码："

msgid ""
"What this does is set up the initialization data that Godot expects. The "
"functions to initialize and deinitialize are set so Godot will call then "
"when needed. It also sets the initialization level which varies per "
"extension. Since we plan to add a custom node, the ``SCENE`` level is enough."
msgstr ""
"这段代码设置了 Godot 所需的初始化数据。这里设置了初始化函数和反初始化函数，"
"Godot 可以在需要时调用。另外还设置了初始化级别，这个级别因扩展而异。因为我们"
"计划添加的是一个自定义节点，所以 ``SCENE`` 级别就足够了。"

msgid ""
"We will fill the ``initialize_gdexample_module()`` function later to "
"register our custom class."
msgstr ""
"我们会在 ``initialize_gdexample_module()`` 函数里注册自定义类，内容稍后再写。"

msgid "A basic class"
msgstr "最简单的类"

msgid ""
"In order to make an actual node, first we'll create a C struct to hold data "
"and functions that will act as methods. The plan is to make this a custom "
"node that inherits from :ref:`Sprite2D <class_Sprite2D>`."
msgstr ""
"要创建实际的节点，我们首先需要创建一个 C 结构体来存放数据，创建一些函数来充当"
"方法。我们的计划是让自定义节点继承 :ref:`Sprite2D <class_Sprite2D>`\\ 。"

msgid ""
"Create a file called ``gdexample.h`` in the ``src`` folder with the "
"following contents:"
msgstr "请在 ``src`` 文件夹中创建 ``gdexample.h`` 文件，内容如下："

msgid ""
"Noteworthy here is the ``object`` field, which holds a pointer to the Godot "
"object, and the ``gdexample_class_bind_methods()`` function, which will "
"register the metadata of our custom class (properties, methods, and "
"signals). The latter is not entirely necessary, as we can do it when "
"registering the class, but it makes clearer to separate the concerns and let "
"our class register its own metadata."
msgstr ""
"这里值得注意的是存放指向 Godot 对象指针的 ``object`` 字段，以及注册自定义类元"
"数据（属性、方法、信号）的 ``gdexample_class_bind_methods()`` 函数。后者并不"
"是完全必要的，因为我们可以在注册类时注册元数据，但使用专门的函数可以将关注点"
"分离，让类注册自己的元数据。"

msgid ""
"The ``object`` field is necessary because our class will inherit a Godot "
"class. Since we can't inherit it directly, as we are not interacting with "
"the source code (and C doesn't even have classes), we instead tell Godot to "
"create an object of a type it knows and attach our extension to it. We will "
"need the reference to such objects when calling methods on the parent class, "
"for instance."
msgstr ""
"``object`` 字段是必需的，因为我们的类要继承 Godot 中的类。由于并不是在和源代"
"码交互（甚至 C 里也没有类），我们无法直接进行继承，而是要让 Godot 创建已知类"
"型的对象，然后将我们的扩展附加到这个对象上。举个例子，我们调用父类方法的时候"
"就需要引用这个对象。"

msgid ""
"Let's create the source counterpart of this header. Create the file "
"``gdexample.c`` in the ``src`` folder and add the following code to it:"
msgstr ""
"让我们为这个头文件创建对应的源码。请在 ``src`` 文件夹中创建 ``gdexample.c`` "
"文件，添加如下代码："

msgid ""
"As we don't have anything to do with those functions yet, they'll stay empty "
"for a while."
msgstr "这些函数我们暂时还用不到，就先留空。"

msgid ""
"The next step is registering our class. However, in order to do so we need "
"to create a :ref:`StringName <class_StringName>` and for that we have to get "
"a function from the GDExtension API. Since we'll need this a few times and "
"we'll also need other things, let's create a wrapper API to facilitate this "
"kind of chore."
msgstr ""
"下一步是类的注册。不过，在此之前我们需要创建一个 :ref:`StringName "
"<class_StringName>`\\ ，为此我们必须从 GDExtension API 中获取一个函数。由于我"
"们会多次用到这个功能，并且还需要其他一些东西，让我们创建一个封装 API 来简化这"
"类繁琐的工作。"

msgid "A wrapper API"
msgstr "封装 API"

msgid "We'll start by creating an ``api.h`` file in the ``src`` folder:"
msgstr "我们首先在 ``src`` 文件夹中创建 ``api.h`` 文件："

msgid ""
"This file will include many other helpers as we fill our extension with "
"something useful. For now it only has a pointer to a function that creates a "
"StringName from a C string (in Latin-1 encoding) and another to destruct a "
"StringName, which we'll need to use to avoid leaking memory, as well as the "
"function to register a class, which is our initial goal."
msgstr ""
"随着我们对扩展的不断完善，这个文件中还会逐渐包含许多其他辅助工具。目前就只有"
"三个函数指针：一个用来根据 C 字符串（Latin-1 编码）创建 StringName；一个用来"
"析构 StringName，我们需要用它来避免内存泄漏；第三个函数则是用来注册类的，是我"
"们最初的目标。"

msgid ""
"We also keep a reference to the ``class_library`` here. This is something "
"that Godot provides to us when initializing the extension and we'll need to "
"use it when registering the things we create so Godot can tell which "
"extension is making the call."
msgstr ""
"我们这里还留了一个对 ``class_library`` 的引用。这是 Godot 在初始化扩展时提供"
"给我们的内容，需要在注册我们创建的内容时用到，方便 Godot 知道是哪个扩展在进行"
"调用。"

msgid ""
"There's also a function to load those function pointers from the GDExtension "
"API."
msgstr "还有一个函数的作用是从 GDExtension API 中加载这些函数指针。"

msgid ""
"Let's work on the source counterpart of this header. Create the ``api.c`` "
"file in the ``src`` folder, adding the following code:"
msgstr ""
"我们来处理这个头文件对应的源码吧。请在 ``src`` 文件夹中创建 ``api.c`` 文件，"
"添加如下代码："

msgid ""
"The first important thing here is ``p_get_proc_address``. This a function "
"from the GDExtension API that is passed during initialization. You can use "
"this function to request specific functions from the API by their name. Here "
"we are caching the results so we don't have to keep a reference for "
"``p_get_proc_address`` everywhere and use our wrapper instead."
msgstr ""
"这里第一个重要的部分是 ``p_get_proc_address``\\ 。这是 GDExtension API 中的一"
"个函数，在初始化时传入。你可以使用这个函数通过名称向 API 请求对应的函数。我们"
"在这里将结果缓存了起来，这样就不必再到处保留对 ``p_get_proc_address`` 的引"
"用，可以直接使用我们的封装函数。"

msgid ""
"At the start we request the ``variant_get_ptr_destructor()`` function. This "
"is not going to be used outside of this function, so we don't add to our "
"wrapper and only cache it locally. The cast is necessary to silence compiler "
"warnings."
msgstr ""
"我们最开始请求的是 ``variant_get_ptr_destructor()`` 函数。这个函数不会在此函"
"数之外使用，因此我们不将其添加到封装器中，只在本地缓存。这个类型转换是必要"
"的，可以消除编译器警告。"

msgid ""
"Then we get the function that creates a StringName from a C string, exactly "
"what we mentioned before as a needed function. We store that in our "
"``constructors`` struct."
msgstr ""
"然后我们获取的是之前提到过的根据 C 字符串创建 StringName 的函数。我们将其存储"
"在 ``constructors`` 结构体中。"

msgid ""
"Next, we use the ``variant_get_ptr_destructor()`` function we just got to "
"query for the destructor for StringName, using the enum value from "
"``gdextension_interface.h`` API as a parameter. We could get destructors for "
"other types in a similar manner, but we'll limit ourselves to what is needed "
"for the example."
msgstr ""
"接下来，我们使用刚刚获取的 ``variant_get_ptr_destructor()`` 函数来查询 "
"StringName 的析构函数，参数是 ``gdextension_interface.h`` API 中的枚举值。其"
"他类型的析构函数也可以通过类似的方式获取，不过这里就只获取示例代码需要用到的"
"东西了。"

msgid ""
"Lastly, we get the ``classdb_register_extension_class2()`` function, which "
"we'll need in order to register our custom class."
msgstr ""
"最后，我们获取的是 ``classdb_register_extension_class2()`` 函数，需要用它来注"
"册自定义类。"

msgid ""
"You may wonder why the ``2`` is there in the function name. This means it's "
"the second version of this function. The old version is kept to ensure "
"backwards compatibility with older extensions, but since we have the second "
"version available, it's best to use the new one, because we don't intend to "
"support older Godot versions in this example."
msgstr ""
"你可能会好奇为什么函数名称里有个 ``2``\\ 。它表示的是这是这个函数的第二个版"
"本。保留旧版本是为了确保向后兼容旧的扩展，但既然可以用第二版，我们就最好使用"
"这个新版本，因为我们在这个示例中不打算支持旧版本的 Godot。"

msgid ""
"The ``gdextension_interface.h`` header documents in which Godot version each "
"function was introduced."
msgstr ""
"``gdextension_interface.h`` 头文件记录了每个函数是在哪个 Godot 版本中引入的。"

msgid ""
"We also define the ``class_library`` variable here, which will be set during "
"initialization."
msgstr "我们还在这里定义了 ``class_library`` 变量，会在初始化时设置。"

msgid ""
"Speaking of initialization, now we have to change the ``init.c`` file in "
"order to fill the things we just added:"
msgstr "说到初始化，现在我们需要修改 ``init.c`` 文件，填入我们刚刚添加的内容："

msgid ""
"Here we set the ``class_library`` as needed and call our new ``load_api()`` "
"function. Don't forget to also include the new headers at the top of this "
"file:"
msgstr ""
"我们在这里设置了所需的 ``class_library`` 并调用了新的 ``load_api()`` 函数。别"
"忘了在文件顶部包含新的头文件："

msgid ""
"Since we are here, we can register our new custom class. Let's fill the "
"``initialize_gdexample_module()`` function:"
msgstr ""
"既然我们在这里，就可以注册一下我们的自定义类。让我们填写 "
"``initialize_gdexample_module()`` 函数："

msgid ""
"The struct with the class information is the biggest thing here. None of its "
"fields are required with the exception of ``create_instance_func`` and "
"``free_instance_func``. We haven't made those functions yet, so we'll have "
"to work on them soon. Note that we skip the initialization if it isn't at "
"the ``SCENE`` level. This function may be called multiple times, once for "
"each level, but we only want to register our class once."
msgstr ""
"包含类信息的结构体是这里最重要的部分。除了 ``create_instance_func`` 和 "
"``free_instance_func`` 之外，其他字段都不是必需的。我们还没有创建这些函数，所"
"以稍后需要着手处理。请注意，我们在不是 ``SCENE`` 层级时跳过了初始化。这个函数"
"可能会被多次调用，每个层级调用一次，但我们只想注册一次类。"

msgid ""
"The other undefined thing here is ``StringName``. This will be an opaque "
"struct meant to hold the data of a Godot StringName in our extension. We'll "
"define it in the appropriately named ``defs.h`` file:"
msgstr ""
"这里的另一个未定义项是 ``StringName``\\ 。在我们的扩展中，这是一个用来存放 "
"Godot 的 StringName 数据的不透明结构体。顾名思义，我们会在 ``defs.h`` 文件中"
"定义："

msgid ""
"As mentioned in the comment, the sizes can be found in the "
"``extension_api.json`` file that we generated earlier, under the "
"``builtin_class_sizes`` property. The ``BUILD_32`` is never defined, as we "
"assume we are working with a 64-bits build of Godot here, but if you need it "
"you can add ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` to your ``SConstruct`` "
"file."
msgstr ""
"如注释所述，大小可以在我们之前生成的 ``extension_api.json`` 文件中找到，位于 "
"``builtin_class_sizes`` 属性下。\\ ``BUILD_32`` 并没有定义，因为我们假设在这"
"里使用的是 64 位的 Godot 构建，但如果你需要的话就可以将 "
"``env.Append(CPPDEFINES=[\"BUILD_32\"])`` 添加到你的 ``SConstruct`` 文件中。"

msgid ""
"The ``// Types.`` comment foreshadows that we'll be adding more types to "
"this file. Let's leave that for later."
msgstr ""
"``// Types.`` 注释预示着我们将在这个文件中添加更多类型。这个我们以后再说。"

msgid "A demo project"
msgstr "演示项目"

msgid "Custom methods"
msgstr "自定义方法"

msgid "Add the declarations to the ``api.h`` file:"
msgstr "在 ``api.h`` 文件中添加声明："

msgid "Let's create two new wrappers in the ``api.h`` file:"
msgstr "让我们在 ``api.h`` 文件中创建两个新的封装："

msgid "Let's create these two functions in the ``api.h`` file:"
msgstr "让我们在 ``api.h`` 文件中创建这两个函数："

msgid "Custom properties"
msgstr "自定义属性"

msgid "Binding virtual methods"
msgstr "绑定虚方法"

msgid "Registering and emitting a signal"
msgstr "信号的注册和触发"

msgid "Conclusion"
msgstr "总结"
