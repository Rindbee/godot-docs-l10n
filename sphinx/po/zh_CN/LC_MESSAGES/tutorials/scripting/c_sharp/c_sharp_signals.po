#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "C# signals"
msgstr "C# 信号"

msgid ""
"For a detailed explanation of signals in general, see the :ref:`doc_signals` "
"section in the step by step tutorial."
msgstr "有关信号的详细解释，请参阅逐步教程中的 :ref:`doc_signals` 部分。"

msgid ""
"Signals are implemented using C# events, the idiomatic way to "
"represent :ref:`the observer pattern<doc_key_concepts_signals>` in C#. This "
"is the recommended way to use signals in C# and the focus of this page."
msgstr ""
"信号是使用 C# 事件实现的，这是在 C# 中表示\\ :ref:`观察者模式"
"<doc_key_concepts_signals>`\\ 的惯用方式。这是在 C# 中使用信号的推荐方式，也"
"是本页的重点。"

msgid ""
"If you encounter a ``System.ObjectDisposedException`` while handling a "
"signal, you might be missing a signal disconnection. "
"See :ref:`disconnecting_automatically_when_the_receiver_is_freed` for more "
"details."
msgstr ""
"如果在处理信号时遇到 ``System.ObjectDisposedException``\\ ，则可能是忘记信号"
"断开连接。有关更多详细信息，请参"
"阅 :ref:`disconnecting_automatically_when_the_receiver_is_freed`\\ 。"

msgid "Signals as C# events"
msgstr "信号作为 C# 事件"

msgid ""
"To provide more type-safety, Godot signals are also all available through "
"`events <https://learn.microsoft.com/en-us/dotnet/csharp/events-overview>`_. "
"You can handle these events, as any other event, with the ``+=`` and ``-=`` "
"operators."
msgstr ""
"为了提供更多的类型安全，Godot 信号也都可以通过 `事件 <https://"
"learn.microsoft.com/zh-cn/dotnet/csharp/events-overview>`_ 获取。你可以用 "
"``+=`` 和 ``-=`` 运算符来处理这些事件，就像其他任何事件一样。"

msgid ""
"In addition, you can always access signal names associated with a node type "
"through its nested ``SignalName`` class. This is useful when, for example, "
"you want to await on a signal (see :ref:`doc_c_sharp_differences_await`)."
msgstr ""
"此外，你可以通过节点类型的嵌套 ``SignalName`` 类来访问与之相关的信号名称。这"
"在你想要等待一个信号时很有用，例如（参"
"见 :ref:`doc_c_sharp_differences_await` ）。"

msgid "Custom signals as C# events"
msgstr "自定义信号作为 C# 事件"

msgid ""
"To declare a custom event in your C# script, use the ``[Signal]`` attribute "
"on a public delegate type. Note that the name of this delegate needs to end "
"with ``EventHandler``."
msgstr ""
"要在你的 C# 脚本中声明一个自定义事件，你需要在一个公共委托类型上使用 "
"``[Signal]`` 特性。注意，这个委托的名称必须以 ``EventHandler`` 结尾。"

msgid ""
"Once this is done, Godot will create the appropriate events automatically "
"behind the scenes. You can then use said events as you'd do for any other "
"Godot signal. Note that events are named using your delegate's name minus "
"the final ``EventHandler`` part."
msgstr ""
"一旦完成这一步，Godot 就会在后台自动创建相应的事件。你可以像使用任何其他 "
"Godot 信号一样使用这些事件。注意，事件的名称是用你的委托的名称减去最后的 "
"``EventHandler`` 部分来命名的。"

msgid ""
"If you want to connect to these signals in the editor, you will need to "
"(re)build the project to see them appear."
msgstr ""
"如果你想在编辑器中连接到这些信号，你需要（重新）构建项目以查看它们的出现。"

msgid "Signal emission"
msgstr "信号发射"

msgid ""
"To emit signals, use the ``EmitSignal`` method. Note that, as for signals "
"defined by the engine, your custom signal names are listed under the nested "
"``SignalName`` class."
msgstr ""
"要发射信号，使用 ``EmitSignal`` 方法。请注意，就像引擎定义的信号一样，你的自"
"定义信号名称列在嵌套的 ``SignalName`` 类下。"

msgid ""
"In contrast with other C# events, you cannot use ``Invoke`` to raise events "
"tied to Godot signals."
msgstr ""
"与其他 C# 事件不同，你不能使用 ``Invoke`` 来触发与 Godot 信号绑定的事件。"

msgid ""
"Signals support arguments of any :ref:`Variant-compatible type "
"<c_sharp_variant_compatible_types>`."
msgstr ""
"信号支持任何 :ref:`Variant 兼容 <c_sharp_variant_compatible_types>`\\ 类型的"
"参数。"

msgid ""
"Consequently, any ``Node`` or ``RefCounted`` will be compatible "
"automatically, but custom data objects will need to inherit from "
"``GodotObject`` or one of its subclasses."
msgstr ""
"因此，任何 ``Node`` 或 ``RefCounted`` 都会自动兼容，但自定义数据对象需要继承"
"自 ``GodotObject`` 或其子类之一。"

msgid "Bound values"
msgstr "绑定值"

msgid ""
"Sometimes you'll want to bind values to a signal when the connection is "
"established, rather than (or in addition to) when the signal is emitted. To "
"do so, you can use an anonymous function like in the following example."
msgstr ""
"有时你会想在连接建立时将值绑定到信号，而不是（或者除了）在信号发出时。要做到"
"这一点，你可以使用一个匿名函数，如下面的例子所示。"

msgid ""
"Here, the :ref:`Button.Pressed <class_BaseButton_signal_pressed>` signal "
"does not take any argument. But we want to use the same ``ModifyValue`` for "
"both the \"plus\" and \"minus\" buttons. So we bind the modifier value at "
"the time we're connecting the signals."
msgstr ""
"在这里，\\ :ref:`Button.Pressed <class_BaseButton_signal_pressed>` 信号不接受"
"任何参数。但我们希望对“加号”和“减号”按钮使用相同的 ``ModifyValue``\\ 。因此，"
"我们在连接信号时绑定该修饰值。"

msgid "Signal creation at runtime"
msgstr "运行时创建信号"

msgid ""
"Finally, you can create custom signals directly while your game is running. "
"Use the ``AddUserSignal`` method for that. Be aware that it should be "
"executed before any use of said signals (either connecting to them or "
"emitting them). Also, note that signals created this way won't be visible "
"through the ``SignalName`` nested class."
msgstr ""
"最后，你可以在游戏运行时直接创建自定义信号。使用 ``AddUserSignal`` 方法来实现"
"这一功能。注意，这个方法应该在使用这些信号（无论是连接还是发射）之前执行。另"
"外，注意这种方式创建的信号不会通过 ``SignalName`` 嵌套类显示。"

msgid "Using Connect and Disconnect"
msgstr "使用 Connect 和 Disconnect"

msgid ""
"In general, it isn't recommended to "
"use :ref:`Connect()<class_object_method_connect>` "
"and :ref:`Disconnect()<class_object_method_disconnect>`. These APIs don't "
"provide as much type safety as the events. However, they're necessary "
"for :ref:`connecting to signals defined by GDScript "
"<connecting_to_signals_cross_language>` and "
"passing :ref:`ConnectFlags<enum_Object_ConnectFlags>`."
msgstr ""
"总的来说，不建议使用 :ref:`Connect()<class_object_method_connect>` "
"和 :ref:`Disconnect()<class_object_method_disconnect>`。These APIs don't "
"provide as much type safety as the events. However, they're necessary "
"for :ref:`connecting to signals defined by GDScript "
"<connecting_to_signals_cross_language>` and "
"passing :ref:`ConnectFlags<enum_Object_ConnectFlags>`."

msgid ""
"In the following example, pressing the button for the first time prints "
"``Greetings!``. ``OneShot`` disconnects the signal, so pressing the button "
"again does nothing."
msgstr ""
"在下面的示例中，第一次按下按钮会打印 ``Greetings!``\\ 。\\ ``OneShot`` 会断开"
"信号，因此再次按下按钮不会执行任何操作。"

msgid "Disconnecting automatically when the receiver is freed"
msgstr "接收者释放时自动断开连接"

msgid ""
"Normally, when any ``GodotObject`` is freed (such as any ``Node``), Godot "
"automatically disconnects all connections associated with that object. This "
"happens for both signal emitters and signal receivers."
msgstr ""
"通常，当任何 ``GodotObject``\\ （例如任何 ``Node``\\ ）被释放时，Godot 会自动"
"断开与该对象关联的所有连接。信号发射器和信号接收器都会如此。"

msgid ""
"For example, a node with this code will print \"Hello!\" when the button is "
"pressed, then free itself. Freeing the node disconnects the signal, so "
"pressing the button again doesn't do anything:"
msgstr ""
"例如，具有此代码的节点将在按下按钮时打印“Hello!”，然后释放它自己。释放该节点"
"会断开该信号，因此再次按下按钮不会执行任何操作："

msgid ""
"When a signal receiver is freed while the signal emitter is still alive, in "
"some cases automatic disconnection won't happen:"
msgstr ""
"当信号接收器被释放而信号发射器仍处于活动状态时，在某些情况下自动断开连接不会"
"发生："

msgid ""
"The signal is connected to a lambda expression that captures a variable."
msgstr "该信号连接到一个捕获变量的lambda表达式。"

msgid "The signal is a custom signal."
msgstr "该信号是自定义信号。"

msgid ""
"The following sections explain these cases in more detail and include "
"suggestions for how to disconnect manually."
msgstr "以下部分将更详细地解释这些情况，并会包含一些如何手动断开连接的建议。"

msgid ""
"Automatic disconnection is totally reliable if a signal emitter is freed "
"before any of its receivers are freed. With a project style that prefers "
"this pattern, the above limits may not be a concern."
msgstr ""
"如果信号发射器在其接收器被释放之前释放，则自动断开连接是完全可靠的。对于喜欢"
"这种模式的项目风格，上述限制可能不是问题。"

msgid ""
"No automatic disconnection: a lambda expression that captures a variable"
msgstr "不自动断开连接：捕获变量的 lambda 表达式"

msgid ""
"If you connect to a lambda expression that captures variables, Godot can't "
"tell that the lambda is associated with the instance that created it. This "
"causes this example to have potentially unexpected behavior:"
msgstr ""
"如果你连接到一个捕获变量的 lambda 表达式，Godot 就无法判断该 lambda 与创建它"
"的实例相关联。这会导致该示例出现潜在的意外行为："

msgid ""
"On tick 4, the lambda expression tries to access the ``Name`` property of "
"the node, but the node has already been freed. This causes the exception."
msgstr ""
"在 tick 4 时，lambda 表达式尝试访问节点的 ``Name`` 属性，但该节点已被释放。这"
"将会导致异常。"

msgid ""
"To disconnect, keep a reference to the delegate created by the lambda "
"expression and pass that to ``-=``. For example, this node connects and "
"disconnects using the ``_EnterTree`` and ``_ExitTree`` lifecycle methods:"
msgstr ""
"要断开连接，请保留对 lambda 表达式创建的委托的引用，并将其传递给 ``-=``\\ 。"
"例如，该节点使用 ``_EnterTree`` 和 ``_ExitTree`` 生命周期方法连接和断开连接："

msgid ""
"In this example, ``Free`` causes the node to leave the tree, which calls "
"``_ExitTree``. ``_ExitTree`` disconnects the signal, so ``_tick`` is never "
"called again."
msgstr ""
"在这个例子中，\\ ``Free`` 导致节点离开树，从而调用 ``_ExitTree``\\ 。\\ "
"``_ExitTree`` 将断开该信号，因此 ``_tick`` 不再被调用。"

msgid ""
"The lifecycle methods to use depend on what the node does. Another option is "
"to connect to signals in ``_Ready`` and disconnect in ``Dispose``."
msgstr ""
"要使用的生命周期方法取决于节点要做什么。另一个选择是在 ``_Ready`` 中连接到信"
"号，并在 ``Dispose`` 中断开连接。"

msgid ""
"Godot uses `Delegate.Target <https://learn.microsoft.com/en-us/dotnet/api/"
"system.delegate.target>`_ to determine what instance a delegate is "
"associated with. When a lambda expression doesn't capture a variable, the "
"generated delegate's ``Target`` is the instance that created the delegate. "
"When a variable is captured, the ``Target`` instead points at a generated "
"type that stores the captured variable. This is what breaks the association. "
"If you want to see if a delegate will be automatically cleaned up, try "
"checking its ``Target``."
msgstr ""
"Godot 使用 `Delegate.Target <https://learn.microsoft.com/zh-cn/dotnet/api/"
"system.delegate.target>`_ 来确定委托与哪个实例关联。当 lambda 表达式没捕获变"
"量时，生成的委托的 ``Target`` 是创建该委托的实例。当变量被捕获时，\\ "
"``Target`` 指向存储捕获变量的生成类型。这就是断开关联的原因。如果你想查看委托"
"是否会被自动清理，请尝试检查其 ``Target``\\ 。"

msgid ""
"``Callable.From`` doesn't affect the ``Delegate.Target``, so connecting a "
"lambda that captures variables using ``Connect`` doesn't work any better "
"than ``+=``."
msgstr ""
"``Callable.From`` 不会影响 ``Delegate.Target``\\ ，因此使用 ``Connect`` 连接"
"捕获变量的 lambda 并不比 ``+=`` 更好。"

msgid "No automatic disconnection: a custom signal"
msgstr "不自动断开连接：自定义信号"

msgid ""
"Connecting to a custom signal using ``+=`` doesn't disconnect automatically "
"when the receiving node is freed."
msgstr "当接收节点被释放时，使用 ``+=`` 连接到自定义信号不会自动断开连接。"

msgid "To disconnect, use ``-=`` at an appropriate time. For example:"
msgstr "要断开连接，请在适当的时候使用 ``-=``\\ 。例如："

msgid ""
"Another solution is to use ``Connect``, which does disconnect automatically "
"with custom signals:"
msgstr "另一种解决方案是使用 ``Connect``\\ ，它会自动与自定义信号断开连接："
