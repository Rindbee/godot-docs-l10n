#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Containers"
msgstr "使用容器"

msgid ""
":ref:`Anchors <doc_size_and_anchors>` are an efficient way to handle "
"different aspect ratios for basic multiple resolution handling in GUIs."
msgstr ""
":ref:`Anchors <doc_size_and_anchors>` 是 GUI 中处理基本多分辨率时应对不同纵横"
"比的有效方法。"

msgid "For more complex user interfaces, they can become difficult to use."
msgstr "对于更复杂的用户界面, 它们可能会变得难以使用."

msgid ""
"This is often the case of games, such as RPGs, online chats, tycoons or "
"simulations. Another common case where more advanced layout features may be "
"required is in-game tools (or simply just tools)."
msgstr ""
"这通常是游戏的情况下, 如角色扮演类, 在线聊天, 大富翁类或模拟类游戏. 另一个需"
"要更高级布局功能的常见情况是游戏内工具(或者仅仅是工具)."

msgid ""
"All these situations require a more capable OS-like user interface, with "
"advanced layout and formatting. For that, :ref:`Containers "
"<class_container>` are more useful."
msgstr ""
"这些情况需要一个更强大的类似操作系统的用户界面，具有先进的布局和格式。"
"用 :ref:`Container <class_container>` 会更方便。"

msgid "Container layout"
msgstr "容器布局"

msgid ""
"Containers provide a huge amount of layout power (as an example, the Godot "
"editor user interface is entirely done using them):"
msgstr ""
"容器提供了巨大的布局能力(例如,Godot编辑器的用户界面就是完全使用它们完成的):"

msgid ""
"When a :ref:`Container <class_Container>`-derived node is used, all "
"children :ref:`Control <class_Control>` nodes give up their own positioning "
"ability. This means the *Container* will control their positioning and any "
"attempt to manually alter these nodes will be either ignored or invalidated "
"the next time their parent is resized."
msgstr ""
"当使用 :ref:`Container <class_Container>` 派生的节点时，所有作为子项"
"的 :ref:`Control <class_Control>` 节点都会放弃自我定位能力。这意味着\\ *容器"
"*\\ 将控制它们的位置，任何手动更改这些节点的尝试，都将在它们的父节点下一次调"
"整大小时被忽略或失效。"

msgid ""
"Likewise, when a *Container* derived node is resized, all its children will "
"be re-positioned according to it, with a behavior based on the type of "
"container used:"
msgstr ""
"同样，调整 *Container* 派生节点的大小时，它的所有子节点都将根据它重新定位，其"
"行为基于所用的容器类型："

msgid "Example of *HBoxContainer* resizing children buttons."
msgstr "*HBoxContainer* 调整子按钮大小的例子。"

msgid ""
"The real strength of containers is that they can be nested (as nodes), "
"allowing the creation of very complex layouts that resize effortlessly."
msgstr ""
"容器的真正优势在于它们可以嵌套(作为节点), 允许创建非常复杂的布局, 调整毫不费"
"力."

msgid "Sizing options"
msgstr "大小选项"

msgid ""
"**Fill**: Ensures the control *fills* the designated area within the "
"container. No matter if a control *expands* or not (see below), it will only "
"*fill* the designated area when this is toggled on (it is by default)."
msgstr ""
"**Fill填充** : 确保控件 *fills填充* 容器内指定的区域. 无论控件是否 *expands扩"
"展* (见下面), 当此选项被选中时(默认情况), 只 *填充* 指定区域."

msgid ""
"Experimenting with these flags and different containers is recommended to "
"get a better grasp on how they work."
msgstr "建议使用这些标记和不同的容器进行试验, 以便更好地了解它们是如何工作的."

msgid "Container types"
msgstr "容器类型"

msgid ""
"Godot provides several container types out of the box as they serve "
"different purposes:"
msgstr "Godot提供了几种开箱即用的容器类型, 因为它们有不同的用途:"

msgid "Box Containers"
msgstr "盒式容器"

msgid "Grid Container"
msgstr "网格容器"

msgid ""
"Arranges child controls in a grid layout (via :ref:`GridContainer "
"<class_GridContainer>`, amount of columns must be specified). Uses both the "
"vertical and horizontal expand flags."
msgstr ""
"将子控件按照网格排列（使用 :ref:`GridContainer <class_GridContainer>` ，必须"
"指定列数），会同时用到垂直和水平扩展选项。"

msgid "Margin Container"
msgstr "边距容器"

msgid ""
"Child controls are expanded towards the bounds of this control "
"(via :ref:`MarginContainer <class_MarginContainer>`). Padding will be added "
"on the margins depending on the theme configuration."
msgstr ""
"将子节点扩展到该控件的边界（使用 :ref:`MarginContainer "
"<class_MarginContainer>` ），会根据主题的设置来添加不同大小的边距。"

msgid ""
"Again, keep in mind that the margins are a *Theme* value, so they need to be "
"edited from the constants overrides section of each control:"
msgstr ""
"同样, 请记住, 边距是一个 *Theme* 值, 所以它们需要从每个控件的常量重写部分进行"
"编辑:"

msgid "Tab Container"
msgstr "选项卡容器"

msgid ""
"Allows you to place several child controls stacked on top of each other "
"(via :ref:`TabContainer <class_TabContainer>`), with only the *current* one "
"visible."
msgstr ""
"允许你将多个子控件堆叠在一起（使用 :ref:`TabContainer "
"<class_TabContainer>` ），只会显示 *当前* 控件。"

msgid ""
"Changing the *current* one is done via tabs located at the top of the "
"container, via clicking:"
msgstr "点击容器顶部的选项卡可以更改 *当前* 控件："

msgid ""
"The titles are generated from the node names by default (although they can "
"be overridden via *TabContainer* API)."
msgstr ""
"标题默认是根据节点名称生成的（尽管可以通过 *TabContainer* 的 API 重写）。"

msgid ""
"Settings such as tab placement and *StyleBox* can be modified in the "
"*TabContainer* theme overrides."
msgstr ""
"可以在 *TabContainer* 的主题覆盖项中修改类似选项卡位置和 *StyleBox* 等设置。"

msgid "Split Container"
msgstr "拆分容器"

msgid ""
"Accepts only one or two children controls, then places them side to side "
"with a divisor (via :ref:`HSplitContainer <class_HSplitContainer>` "
"and :ref:`VSplitContainer <class_VSplitContainer>`). Respects both "
"horizontal and vertical flags, as well as *Ratio*."
msgstr ""
"只接受单个或者两个子控件，会将它们相邻放置，中间是分隔线（使"
"用 :ref:`HSplitContainer <class_HSplitContainer>` 和 :ref:`VSplitContainer "
"<class_VSplitContainer>` ），会使用到水平和垂直选项以及 *Ratio* 属性。"

msgid ""
"The divisor can be dragged around to change the size relation between both "
"children:"
msgstr "可以通过拖动分隔线来调整两个子节点所占区域的大小："

msgid "PanelContainer"
msgstr "PanelContainer"

msgid "ScrollContainer"
msgstr "ScrollContainer"

msgid ""
"Mouse wheel and touch drag (when touch is available) are also valid ways to "
"pan the child control around."
msgstr "鼠标滚轮和触摸拖动(当触摸可用时)也是平移子控件的有效方法."

msgid ""
"As in the example above, one of the most common ways to use this container "
"is together with a *VBoxContainer* as child."
msgstr ""
"正如上面的例子中所展示的，使用此容器最常见的方法之一，是将 *VBoxContainer* 作"
"为子容器一起使用。"

msgid "SubViewportContainer"
msgstr "SubViewportContainer"

msgid "Creating custom Containers"
msgstr "创建自定义容器"
