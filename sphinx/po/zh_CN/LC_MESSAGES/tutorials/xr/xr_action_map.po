#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The XR action map"
msgstr "XR 动作映射"

msgid ""
"As the XR action map is currently part of the OpenXR module, OpenXR needs to "
"be enabled in your project settings to expose it:"
msgstr ""
"由于 XR 动作映射目前是 OpenXR 模块的一部分，因此需要在项目设置中启用 OpenXR "
"才能显示它："

msgid ""
"You will then find the XR Action Map interface in the bottom of the screen:"
msgstr "然后，你会在屏幕底部看到 XR 行动地图界面："

msgid ""
"Godot's input system allows changes to what inputs are bound to actions in "
"runtime, OpenXR does not."
msgstr "Godot 的输入系统允许在运行时更改输入与操作的绑定，而 OpenXR 则不允许。"

msgid ""
"Godot's input system is based on device ids which are meaningless in OpenXR."
msgstr "Godot 的输入系统基于设备 ID，而这在 OpenXR 中毫无意义。"

msgid ""
"This does mean that a game/application that mixes traditional inputs with XR "
"controllers will have a separation. For most applications either one or the "
"other is used and this is not seen as a problem. In the end, it's a "
"limitation of the system."
msgstr ""
"这确实意味着混合了传统输入和 XR 控制器的游戏/应用将会有一个分离。对于大多数应"
"用来说，要么使用一个，要么使用另一个，这不被视为问题。最后，这是系统的限制。"

msgid "The default action map"
msgstr "默认动作映射"

msgid ""
"Godot will automatically create a default action map if no action map file "
"is found."
msgstr "如果找不到操作映射文件，Godot 会自动创建默认操作映射。"

msgid "Action sets"
msgstr "动作集"

msgid "for Steam this is SteamVR,"
msgstr "对于 Steam，这是 SteamVR，"

msgid ""
"for Meta on desktop this is the Oculus Client (including when using Quest "
"link),"
msgstr "对于桌面上的 Meta，这是 Oculus 客户端(包括使用 Quest link 时)，"

msgid "for Meta on Quest this is the Quest's native OpenXR client,"
msgstr "对于 Quest 上的 Meta，这是 Quest 的本地 OpenXR 客户端，"

msgid "on Linux this could be Monado, etc."
msgstr "在 Linux 上，这可能是 Monado 等。"

msgid ""
"The action map allows us to organize our actions in sets. Each set can be "
"enabled or disabled on its own."
msgstr "行动地图允许我们组织我们的行动。每组都可以单独启用或禁用。"

msgid ""
"The concept here is that you could have different sets that provide bindings "
"in different scenarios. You could have:"
msgstr "这里的概念是，在不同的场景中，可以有不同的集合来提供绑定。你可以:"

msgid ""
"For your first XR game/application we highly recommend starting with just a "
"single action set and to not over-engineer things."
msgstr ""
"对于你的第一个 XR 游戏/应用程序，我们强烈建议只从一个动作集开始，不要过度设"
"计。"

msgid "Col"
msgstr "Col"

msgid "Value"
msgstr "值"

msgid "Description"
msgstr "描述"

msgid "1"
msgstr "1"

msgid "my_first_action_set"
msgstr "my_first_action_set"

msgid ""
"This is the internal name of the action set. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"这是动作集的内部名称。除了大小之外，OpenXR 没有对这个名称指定具体的限制，但是"
"有些 XR 运行时不喜欢空格或特殊字符。"

msgid "2"
msgstr "2"

msgid "My first action set"
msgstr "我的第一套动作"

msgid ""
"This is a human-readable name for the action set. Some XR runtimes will "
"display this name to the end user, for example in configuration dialogs."
msgstr ""
"这是动作集的可读名称。一些 XR 运行时会向最终用户显示这个名称，例如在配置对话"
"框中。"

msgid "3"
msgstr "3"

msgid "0"
msgstr "0"

msgid ""
"This is the priority of the action set. If multiple active action sets have "
"actions bound to the same controllers inputs or outputs, the action set with "
"the highest priority value will determine the action that is updated."
msgstr ""
"这是动作集的优先级。如果多个活动动作集具有绑定到相同控制器输入或输出的动作，"
"则具有最高优先级值的动作集将确定被更新的动作。"

msgid "Actions"
msgstr "动作"

msgid ""
"Actions can be used for both input and output and each action has a type "
"that defines its behavior."
msgstr "动作可以用于输入和输出，每个动作都有一个类型，用于指定其行为。"

msgid "The ``Bool`` type is used for discrete input like buttons."
msgstr "``Bool`` 类型用于离散输入，例如按键。"

msgid "The ``Float`` type is used for analogue input like triggers."
msgstr "``Float`` 类型用于模拟输入，例如触发器。"

msgid ""
"These two are special as they are the only ones that are interchangeable. "
"OpenXR will handle conversions between ``Bool`` and ``Float`` inputs and "
"actions. You can get the value of a ``Float`` type action by calling the "
"method ``get_float`` on your :ref:`XRController3D <class_xrcontroller3d>` "
"node. It emits the ``input_float_changed`` signal when changed."
msgstr ""
"这两者的特别之处在于它们是唯一可以互换的动作。OpenXR 会处理 ``Bool`` 和 "
"``Float`` 输入或动作之间的转换。可以通过调用 :ref:`XRController3D "
"<class_xrcontroller3d>` 节点上的方法 ``get_float`` 来获得一个 ``Float`` 类动"
"作的值。此值更改的时候会发出 ``input_float_changed`` 信号。"

msgid ""
"Where analogue inputs are queried as buttons a threshold is applied. This "
"threshold is currently managed exclusively by the XR runtime. There are "
"plans to extend Godot to provide some level of control over these thresholds "
"in the future."
msgstr ""
"以按键查询模拟输入时会应用一个阈值。该阈值目前由 XR 运行时专门管理。未来有计"
"划对 Godot 进行扩展，为这些阈值提供某种程度上的控制。"

msgid ""
"The ``Vector2`` type defines the input as an axis input. Touchpads, "
"thumbsticks and similar inputs are exposed as vectors. You can get the value "
"of a ``Vector2`` type action by calling the method ``get_vector2`` on "
"your :ref:`XRController3D <class_xrcontroller3d>` node. It emits the "
"``input_vector2_changed`` signal when changed."
msgstr ""
"``Vector2`` 类型将输入定义为轴输入。触摸屏，操纵杆等类似输入都以向量形式显"
"示。可以通过在 :ref:`XRController3D <class_xrcontroller3d>` 节点上调用 "
"``get_vector2`` 方法来获取 ``Vector2`` 类动作的值。当发生更改时，它会发出 "
"``input_vector2_changed`` 信号。"

msgid "aim_pose"
msgstr "aim_pose"

msgid ""
"This is the internal name of the action. OpenXR doesn't specify specific "
"restrictions on this name other then size, however some XR runtimes will not "
"like spaces or special characters."
msgstr ""
"这是该动作的内部名称。除大小外 OpenXR 不明确指定对该名称的任何限制，但某些 "
"XR 运行时会排斥空格或特殊字符。"

msgid "Aim pose"
msgstr "瞄准姿势"

msgid ""
"This is a human-readable name for the action. Some XR runtimes will display "
"this name to the end user, for example in configuration dialogs."
msgstr ""
"这是该动作的人类可读名称。某些 XR 运行时会将该名称显示给终端用户，例如在配置"
"窗口中。"

msgid "Pose"
msgstr "姿势"

msgid "The type of this action."
msgstr "主题类型变种。"

msgid ""
"OpenXR defines a number of bindable input poses that are commonly available "
"for controllers. There are no rules for which poses are supported for "
"different controllers. The poses OpenXR currently defines are:"
msgstr ""
"OpenXR 定义了许多控制器常用的可绑定输入姿态。对于不同的控制器支持哪些姿势，没"
"有规则。OpenXR 目前定义的姿势有:"

msgid ""
"If hand tracking is used, there are currently big differences in "
"implementations between the different XR runtimes. As a result the action "
"map is currently not suitable for hand tracking. Work is being done on this "
"so stay tuned."
msgstr ""
"如果使用手部跟踪，目前不同 XR 运行时之间的实现存在很大差异。因此，动作图目前"
"不适合手部跟踪。这方面的工作正在进行中，敬请关注。"

msgid ""
"Let's complete our list of actions for a very simple shooting game/"
"application:"
msgstr "让我们完成一个非常简单的射击游戏/应用程序的动作列表:"

msgid "The actions we have added are:"
msgstr "我们添加的操作有:"

msgid "grab, which detects that the user wants to hold something."
msgstr "抓取，检测用户想要拿东西。"

msgid ""
"shoot, which detects that the user wants to fire the weapon they are holding."
msgstr "射击，它检测到用户想要发射他们持有的武器。"

msgid "haptic, which allows us to output haptic feedback."
msgstr "触觉，它允许我们输出触觉反馈。"

msgid ""
"We are still investigating the restrictions around binding multiple actions "
"to the same output as this scenario makes sense. The OpenXR specification "
"seems to not allow this."
msgstr ""
"我们仍在研究将多个动作绑定到同一个输出的限制，因为这种场景是有意义的。OpenXR "
"规范似乎不允许这样做。"

msgid "Now that we have our basic actions defined, it's time to hook them up."
msgstr "既然我们已经定义了基本的动作，那么是时候把它们连接起来了。"

msgid "Profiles"
msgstr "配置文件"

msgid ""
"This generic name is chosen because controllers don't cover the entire "
"system. Currently there are also profiles for trackers, remotes and tracked "
"pens. There are also provisions for devices such as treadmills, haptic vests "
"and such even though those are not part of the specification yet."
msgstr ""
"选择这个通用名称是因为控制器不能覆盖整个系统。目前也有跟踪器、遥控器和跟踪笔"
"的配置文件。对于跑步机、触觉背心等设备也有规定，尽管这些还不是规范的一部分。"

msgid ""
"It is important to know that OpenXR has strict checking on supported "
"devices. The core specification identifies a number of controllers and "
"similar devices with their supported inputs and outputs. Every XR runtime "
"must accept these interaction profiles even if they aren't applicable."
msgstr ""
"要知道 OpenXR 对支持的设备有严格的检查，这一点很重要。核心规范确定了许多控制"
"器和类似设备及其支持的输入和输出。每个 XR 运行时都必须接受这些交互配置文件，"
"即使它们不适用。"

msgid ""
"New devices are added through extensions and XR runtimes must specify which "
"ones they support. XR runtimes that do not support a device added through "
"extensions will not accept these profiles. XR runtimes that do not support "
"added input or output types will often crash if supplied."
msgstr ""
"新设备是通过扩展添加的，XR 运行时必须指定它们支持哪些设备。不支持通过扩展添加"
"的设备的 XR 运行时将不接受这些配置文件。不支持添加的输入或输出类型的 XR 运行"
"时通常会崩溃。"

msgid ""
"This does mean that in order to support new devices, you might need to "
"update to a more recent version of Godot."
msgstr "这意味着为了支持新的设备，你可能需要升级到最新版本的Godot。"

msgid ""
"How the XR runtime does this is left to the implementation of the runtime "
"and there are thus vast differences between the runtimes. Some runtimes "
"might even permit users to edit the bindings themselves."
msgstr ""
"XR 运行时如何做到这一点取决于运行时的实现，因此运行时之间有很大的差异。一些运"
"行时甚至允许用户自己编辑绑定。"

msgid ""
"For example, when the Touch controller profile is used any of the following "
"scenarios could be true:"
msgstr "例如，当使用触摸控制器配置文件时，以下任何一种情况都可能发生:"

msgid ""
"we could be using a Quest Pro controller but no Quest Pro profile was given "
"or the XR runtime being used does not support the Quest Pro controller,"
msgstr ""
"我们可以使用 Quest Pro 控制器，但没有提供 Quest Pro 配置文件，或者使用的 XR "
"运行时不支持 Quest Pro 控制器，"

msgid ""
"it could be a completely different controller for which no profile was given "
"but the XR runtime is using the touch bindings as a base."
msgstr ""
"它可能是一个完全不同的控制器，没有给出配置文件，但是 XR 运行时使用触摸绑定作"
"为基础。"

msgid ""
"Ergo, there currently is no way to know with certainty, which controller the "
"user is actually using."
msgstr "因此，目前没有办法确切地知道用户实际使用的是哪个控制器。"

msgid ""
"Finally, and this trips up a lot of people, the bindings aren't set in "
"stone. It is fully allowed, and even expected, that an XR runtime allows a "
"user to customise the bindings."
msgstr ""
"最后，这让很多人犯了错误，绑定并不是一成不变的。XR 运行时允许用户定制绑定是完"
"全允许的，甚至是可以预期的。"

msgid ""
"At the moment none of the XR runtimes offer this functionality though "
"SteamVR has an existing UI from OpenVRs action map system that is still "
"accessible. This is actively being worked on however."
msgstr ""
"目前，没有一个 XR 运行时提供这种功能，尽管 SteamVR 有一个来自 OpenVRs action "
"map system 的现有 UI ，仍然可以访问。不过，这方面的工作正在积极进行中。"

msgid "Our first controller binding"
msgstr "第一个控制器绑定"

msgid ""
"Let's set up our first controller binding, using the Touch controller as an "
"example."
msgstr "让我们以触摸控制器为例，设置我们的第一个控制器绑定。"

msgid "Let's finish our configuration:"
msgstr "引擎配置："

msgid "The simple controller"
msgstr "简单控制器"

msgid "Binding Modifiers"
msgstr "绑定修改器"
