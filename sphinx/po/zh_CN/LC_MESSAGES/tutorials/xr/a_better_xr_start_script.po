#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: YEAR-MO-DA HO:MI+ZONE\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "A better XR start script"
msgstr "更好的 XR 启动脚本"

msgid ""
"In :ref:`doc_setting_up_xr` we introduced a startup script that initialises "
"our setup which we used as our script on our main node. This script performs "
"the minimum steps required for any given interface."
msgstr ""
"在 :ref:`doc_setting_up_xr` 中，我们介绍了一个用于初始化配置的启动脚本，并将"
"其作为主节点脚本使用，以执行任何接口部署所需的最小步骤。"

msgid ""
"When using OpenXR there are a number of improvements we should do here. For "
"this we've created a more elaborate starting script. You will find these "
"used in our demo projects."
msgstr ""
"使用 OpenXR 时，这个脚本最好进行一些改进。为此，我们重新编写了一个更为详尽的"
"启动脚本。你可以在演示项目中找到它。"

msgid ""
"Alternatively, if you are using XR Tools (see :ref:"
"`doc_introducing_xr_tools`) it contains a version of this script updated "
"with some features related to XR tools."
msgstr ""
"除此以外，如果你使用 XR 工具（见 :ref:`doc_introducing_xr_tools`），它也包含"
"了另一个版本的启动脚本，那个版本在源代码基础上添加了一些与 XR 工具相关联的功"
"能。"

msgid ""
"Below we will detail out the script used in our demos and explain the parts "
"that are added."
msgstr "下面将详细介绍演示中使用的脚本，并解释添加的部分。"

msgid "Signals for our script"
msgstr "脚本的信号"

msgid ""
"We are introducing 3 signals to our script so that our game can add further "
"logic:"
msgstr "我们在脚本中引入了 3 个信号以方便在游戏中添加更多逻辑："

msgid ""
"``focus_lost`` is emitted when the player takes off their headset or when "
"the player enters the menu system of the headset."
msgstr ""
"``focus_lost`` 作为检测玩家摘下头戴设备或进入头戴设备的菜单系统时的触发器。"

msgid ""
"``focus_gained`` is emitted when the player puts their headset back on or "
"exists the menu system and returns to the game."
msgstr ""
"``focus_gained`` 信号则相反，在玩家重新戴上头戴设备或退出菜单系统并返回游戏时"
"触发。"

msgid ""
"``pose_recentered`` is emitted when the headset requests the players "
"position to be reset."
msgstr "``pose_recentered`` 信号在头戴设备请求重置玩家位置时触发。"

msgid "Our game should react accordingly to these signals."
msgstr "我们的游戏将根据这些信号作出相应的反应。"

msgid "Variables for our script"
msgstr "脚本的变量"

msgid "We introduce a few new variables to our script as well:"
msgstr "我们还向脚本引入了几个新变量："

msgid ""
"``maximum_refresh_rate`` will control the headsets refresh rate if this is "
"supported by the headset."
msgstr ""
"``maximum_refresh_rate`` 将控制头显设备的刷新率——如果头显设备支持控制的话。"

msgid ""
"``xr_interface`` holds a reference to our XR interface, this already existed "
"but we now type it to get full access to our :ref:`XRInterface "
"<class_xrinterface>` API."
msgstr ""
"``xr_interface`` 保存了对我们的 XR 接口的引用，这个变量其实已经存在，但现在我"
"们将其类型化，以便更好地访问 :ref:`XRInterface <class_xrinterface>` API。"

msgid "``xr_is_focussed`` will be set to true whenever our game has focus."
msgstr "``xr_is_focussed`` 将在我们的游戏获得焦点时设置为 true。"

msgid "Our updated ready function"
msgstr "更新后的 `_ready` 函数"

msgid "We add a few things to the ready function."
msgstr "我们在 ``_ready`` 函数中新加了一些东西。"

msgid ""
"If we're using the mobile or forward+ renderer we set the viewports "
"``vrs_mode`` to ``VRS_XR``. On platforms that support this, this will enable "
"foveated rendering."
msgstr ""
"如果我们使用移动或 Forward+ 渲染器，我们可以将 viewports 的 ``vrs_mode`` 设置"
"为 ``VRS_XR`` 。在支持此功能的平台上，这样设置将启用锥形渲染。"

msgid ""
"If we're using the compatibility renderer, we check if the OpenXR foveated "
"rendering settings are configured and if not, we output a warning. See :ref:"
"`OpenXR Settings <doc_openxr_settings>` for further details."
msgstr ""
"使用兼容性渲染器时，Godot 会检查是否配置了 OpenXR 的锥形渲染设置，如果没有进"
"行配置，将弹出警告。详请参阅 :ref:`OpenXR Settings <doc_openxr_settings>`。"

msgid ""
"We hook up a number of signals that will be emitted by the :ref:`XRInterface "
"<class_xrinterface>`. We'll provide more detail about these signals as we "
"implement them."
msgstr ""
"这些信号将由 :ref:`XRInterface <class_xrinterface>` 触发。随着实现的深入，后"
"续将提供更多关于这些信号的详细信息。"

msgid ""
"We also quit our application if we couldn't successfully initialise OpenXR. "
"Now this can be a choice. If you are making a mixed mode game you setup the "
"VR mode of your game on success, and setup the non-VR mode of your game on "
"failure. However, when running a VR only application on a standalone "
"headset, it is nicer to exit on failure than to hang the system."
msgstr ""
"如果我们无法顺利启动 OpenXR ，我们也会选择退出应用。对于混合现实游戏的开发来"
"说，你可以在成功初始化后进入 VR 模式，若失败再切换至非 VR 模式。不过，在一个"
"独立的 VR 设备上运行仅支持 VR 的应用，启动失败时直接退出程序会比让系统挂着更"
"合适。"

msgid "On session begun"
msgstr "会话开始"

msgid ""
"This signal is emitted by OpenXR when our session is setup. This means the "
"headset has run through setting everything up and is ready to begin "
"receiving content from us. Only at this time various information is properly "
"available."
msgstr ""
"该信号由 OpenXR 在我们设置会话时发出。意味着头戴设备已经完成了所有设置，并准"
"备好开始接收程序内容。只有此时，各种信息才能正确地获取到。"

msgid ""
"The main thing we do here is to check our headsets refresh rate. We also "
"check the available refresh rates reported by the XR runtime to determine if "
"we want to set our headset to a higher refresh rate."
msgstr ""
"在这里，我们主要做的事情是检查头戴设备的刷新率。除此以外还检查 XR 运行时报告"
"的可用刷新率，以确定是否要将头戴设备设置为更高的刷新率。"

msgid ""
"Finally we match our physics update rate to our headset update rate. Godot "
"runs at a physics update rate of 60 updates per second by default while "
"headsets run at a minimum of 72, and for modern headsets often up to 144 "
"frames per second. Not matching the physics update rate will cause "
"stuttering as frames are rendered without objects moving."
msgstr ""
"最后，我们将物理更新速率与头戴设备的更新速率相匹配。Godot 默认物理帧刷新率为"
"每秒 60 帧，而 HMD 通常至少以每秒 72 帧运行，当下先进的头戴设备甚至高达 144 "
"帧 / 秒。如果不将物理帧刷新率相匹配，将导致设备在对象尚未移动前过早开始渲染，"
"导致画面出现卡顿。"

msgid "On visible state"
msgstr "进入可见状态"

msgid ""
"This signal is emitted by OpenXR when our game becomes visible but is not "
"focussed. This is a bit of a weird description in OpenXR but it basically "
"means that our game has just started and we're about to switch to the "
"focussed state next, that the user has opened a system menu or the users has "
"just took their headset off."
msgstr ""
"当游戏变得可见但未检测到聚焦时，OpenXR 会发出这个信号。这一状态在 OpenXR 文档"
"中的描述有些迷惑，不过基本上来说，它通常指游戏刚启动，用户打开了系统菜单或用"
"户刚摘下头戴设备，即将切换到聚焦状态时。"

msgid ""
"On receiving this signal we'll update our focussed state, we'll change the "
"process mode of our node to disabled which will pause processing on this "
"node and it's children, and emit our ``focus_lost`` signal."
msgstr ""
"收到此信号时，Godot 将更新聚焦状态，将并节点的处理模式更改为禁用，从而暂停该"
"节点及其子节点的处理，然后发出 ``focus_lost`` 信号。"

msgid ""
"If you've added this script to your root node, this means your game will "
"automatically pause when required. If you haven't, you can connect a method "
"to the signal that performs additional changes."
msgstr ""
"如果你将此脚本添加到根节点，这意味着你的游戏将在需要时自动暂停。如果没有，你"
"可以将方法连接到该信号，以执行额外的更改。"

msgid ""
"While your game is in visible state because the user has opened a system "
"menu, Godot will keep rendering frames and head tracking will remain active "
"so your game will remain visible in the background. However controller and "
"hand tracking will be disabled until the user exits the system menu."
msgstr ""
"如果游戏是因当用户打开系统菜单而处于可见状态，Godot 会继续渲染帧并保持头部跟"
"踪活跃，因此游戏会在后台保持可见。然而，控制器和手部跟踪将被禁用，直到用户退"
"出系统菜单为止。"

msgid "On focussed state"
msgstr "进入聚焦状态"

msgid ""
"This signal is emitted by OpenXR when our game gets focus. This is done at "
"the completion of our startup, but it can also be emitted when the user "
"exits a system menu, or put their headset back on."
msgstr ""
"OpenXR 会在游戏获得聚焦时发出这个信号。这会在启动完成时触发，但也可能在用户退"
"出系统菜单或重新戴上头戴设备时触发。"

msgid ""
"Note also that when your game starts while the user is not wearing their "
"headset, the game stays in 'visible' state until the user puts their headset "
"on."
msgstr ""
"同时注意，当游戏在用户未佩戴头戴设备时启动，游戏会保持在可见状态，直到用户戴"
"上头戴设备。"

msgid ""
"It is thus important to keep your game paused while in visible mode. If you "
"don't the game will keep on running while your user isn't interacting with "
"your game. Also when the game returns to focussed mode, suddenly all "
"controller and hand tracking is re-enabled and could have game breaking "
"consequences if you do not react to this accordingly. Be sure to test this "
"behaviour in your game!"
msgstr ""
"因此，在可见模式下保持游戏暂停非常重要。如果不暂停，游戏会在用户未与游戏互动"
"时继续运行。此外，当游戏返回到聚焦模式时，所有控制器和手部跟踪会突然重新启"
"用，如果你没有对此作出相应反应，可能会导致游戏出现严重问题。一定要在游戏中测"
"试这种行为！"

msgid ""
"While handling our signal we will update the focusses state, unpause our "
"node and emit our ``focus_gained`` signal."
msgstr ""
"在处理该信号时，Godot 将更新聚焦状态，解除节点的暂停，并发出 "
"``focus_gained`` 信号。"

msgid "On stopping state"
msgstr "进入停止状态"

msgid ""
"This signal is emitted by OpenXR when we enter our stop state. There are "
"some differences between platforms when this happens. On some platforms this "
"is only emitted when the game is being closed. But on other platforms this "
"will also be emitted every time the player takes off their headset."
msgstr ""
"OpenXR 会在进入停止状态时发出这个信号。不同平台在该情况下的表现会有所不同。一"
"部分平台只会在游戏关闭时发出此信号，另一部分在玩家摘下头戴设备时也会发出。"

msgid "For now this method is only a place holder."
msgstr "目前为止，该方法只充当一个占位符。"

msgid "On pose recentered"
msgstr "姿势重新居中"

msgid ""
"This signal is emitted by OpenXR when the user requests their view to be "
"recentered. Basically this communicates to your game that the user is now "
"facing forward and you should re-orient the player so they are facing "
"forward in the virtual world."
msgstr ""
"当用户请求重新定位视角时，OpenXR 会发出此信号。该信号主要用于告诉你的游戏：用"
"户现在面朝前方，你应该重新定位玩家，使其在虚拟世界中面朝前方。"

msgid ""
"As doing so is dependent on your game, your game needs to react accordingly."
msgstr ""
"由于重新定位视角依赖于游戏设计，因此你的游戏需要被设计能正确地做出反应。"

msgid ""
"All we do here is emit the ``pose_recentered`` signal. You can connect to "
"this signal and implement the actual recenter code. Often it is enough to "
"call :ref:`center_on_hmd() <class_XRServer_method_center_on_hmd>`."
msgstr ""
"下面这段代码里，我们只是发出 ``pose_recentered`` 信号，并未提供用户重新定位的"
"代码实现。你可以连接到这个信号并自行实现它。通常调用 :ref:`center_on_hmd() "
"<class_XRServer_method_center_on_hmd>` 就足够了。"

msgid ""
"And that finished our script. It was written so that it can be re-used over "
"multiple projects. Just add it as the script on your main node (and extend "
"it if needed) or add it on a child node specific for this script."
msgstr ""
"这样就完成了我们的脚本。它被设计为能够重复利用。只需将它添加为主节点的脚本"
"（如有需要还可以进行扩展），或者添加到专门用于此脚本的子节点上。"

msgid "Translation status"
msgstr "翻译状态"
