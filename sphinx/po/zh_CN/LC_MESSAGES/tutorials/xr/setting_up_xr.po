#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "设置 XR"

msgid "Introduction to the XR system in Godot"
msgstr "Godot 的 XR 系统简介"

msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot 引擎内置了一套模块化扩展现实（XR）系统，该系统通过抽象化不同 XR 平台的"
"底层实现细节，以简化跨平台 XR 应用的开发流程。该系统的核心是 :ref:`XRServer "
"<class_xrserver>` 类，它作为整个 XR 架构的中枢接口，允许开发者通过该接口发现"
"并连接各类 XR 运行时环境。"

msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with "
"the :ref:`XRServer <class_xrserver>` and can be queried with the "
"``find_interface`` method on the :ref:`XRServer <class_xrserver>`. When the "
"desired interface is found it can be initialized by calling ``initialize`` "
"on the interface."
msgstr ""
"支持的 XR 平台都实现为一个 :ref:`XRInterface <class_xrinterface>` 类。平台支"
"持的接口会在 :ref:`XRServer <class_xrserver>` 中注册，并可通"
"过 :ref:`XRServer <class_xrserver>` 的 ``find_interface`` 方法查找到，还可通"
"过调用该接口的 ``initialize`` 方法来初始化它。"

msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"已注册的接口仅意味着该接口可用，如果主机系统不支持接口，初始化可能会失败并返"
"回 ``false``\\ 。不幸的是，初始化失败的原因在不同平台上各不相同：可能是因为用"
"户没有安装所需软件，或者是根本没插入头戴设备。作为开发者，你必须对接口初始化"
"失败的情况准备好应对措施。"

msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"由于 XR 对输出有特殊要求——尤其是头戴设备要为双眼提供不同的图像输出，Godot 中"
"的 :ref:`XRServer <class_xrserver>` 将覆盖渲染系统的大部分功能。对于独立设备"
"来说，最终输出由 :ref:`XRInterface <class_xrinterface>` 处理，而 Godot 的常规"
"输出系统将被禁用。对于作为第二屏幕使用的桌面 XR 设备来说，可以使用独立"
"的 :ref:`Viewport <class_viewport>` 来处理 XR 输出，从而使 Godot 的主窗口能显"
"示其他内容。"

msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"请注意，只能有一个主接口负责处理输出到 XR 设备，默认情况下它将是第一个被初始"
"化的接口。 Godot 目前仅支持单个头戴设备的实现。不过，也有可能存在第二个接口"
"（比如为仅支持 3DOF 的设备添加跟踪功能），但这种情况已经愈发少见。"

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>` 在所有意图和目的上都代表了游戏空间的中心"
"点。这是一个过于简单的说法，但我们稍后会更详细地解释。XR 平台在物理空间中跟踪"
"的所有对象都相对于此点定位。"

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>` 代表着在为 XR 设备渲染输出时使用的（立"
"体）摄像机。该节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更"
"新。"

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>` 代表玩家使用的控制器，通常有两"
"个：左右手各一个。该节点提供对控制器上各种状态的访问，并在玩家按下按钮时发送"
"信号。节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更新。"

msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"还有其他与 XR 相关的节点，并且关于这三个节点还有更多内容可以讨论，具体将稍后"
"再谈。"

msgid "Which Renderer to use"
msgstr "使用哪些渲染器"

msgid ""
"Godot has 3 renderer options for projects: Compatibility, Mobile, and "
"Forward+. The current recommendation is to use the Mobile renderer for any "
"desktop VR project, and use the Compatibility renderer for any project "
"running on a standalone headset like the Meta Quest 3. XR projects will run "
"with the Forward+ renderer, but it isn't well optimized for XR right now "
"compared to the other two."
msgstr ""
"Godot 为项目提供了 3 种渲染器：兼容（Compatibility）、移动（Mobile）和 "
"Forward+。目前的建议是，对于任何桌面 VR 项目使用移动渲染器，对于在独立头显"
"（如 Meta Quest 3）上运行的项目使用兼容渲染器。XR 项目可以使用 Forward+ 渲染"
"器运行，但与另外两种渲染器相比，目前它针对 XR 的优化还不够完善。"

msgid "OpenXR"
msgstr "OpenXR"

msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR 是由 Khronos Group 维护的 XR 行业开放标准，其目的是允许不同的 XR 平台"
"通过共用一套标准化 API，为 XR 应用程序的开发提供便利。该标准与 Godot 的利益非"
"常吻合。"

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR 的 Vulkan 实现与 Vulkan 紧密集成，并接管了 Vulkan 系统的一部分。这就要"
"求在设置 XR 系统之前，需要对 Vulkan 渲染器中的某些核心图形功能先行集成。这是"
"将 OpenXR 包含为核心接口的主要决定因素之一。"

msgid "Setting up the XR scene"
msgstr "设置 XR 场景"

msgid "And the right hand:"
msgstr "将脚本添加到节点："

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"现在，所有节点都在场景的平面上，它们将在运行时自动正确定位。为了帮助开发期间"
"的调试，可以将相机向上移动，再把 ``y`` 轴设置为 ``1.7``\\ ，并将控制器节点分"
"别移动到 ``-0.5, 1.0, -0.5``\\ （左手）和 ``0.5, 1.0, -0.5``\\ （右手）。"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"上述代码片段假设我们正在使用 OpenXR，如果你希望使用其他接口，可以更改"
"``find_interface`` 调用。"

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"正如你看到的，我们在代码中关闭了垂直同步（DisplayServer.VSYNC_DISABLED）。在"
"使用 OpenXR 时，将渲染结果输出到一个头戴显示器（HMD）通常需要以 90Hz 或更高的"
"频率运行。如果你的显示器是 60Hz 且开启了垂直同步，那么输出将限制在每秒 60 "
"帧。"

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "像 OpenXR 这样的 XR 接口会执行它们自己的同步。"

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set "
"``Engine.physics_ticks_per_second`` to a higher value."
msgstr ""
"同时请注意，默认情况下物理引擎以 60Hz 运行，渲染和物理帧数不一致可能会导致物"
"理效果不流畅。你应该将 ``Engine.physics_ticks_per_second`` 设置为更高的值。"

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr "完成配置后运行项目，你应该会漂浮在某个空间中，并能够四处观察。"

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr "在接下来的基础教程中，我们将创建一个只使用单场景的游戏作为练习。"
