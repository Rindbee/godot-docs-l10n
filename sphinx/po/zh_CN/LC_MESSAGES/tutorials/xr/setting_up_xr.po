# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 16:36+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Setting up XR"
msgstr "设置 XR"

msgid "Introduction to the XR system in Godot"
msgstr "Godot 的 XR 系统简介"

#, fuzzy
msgid ""
"Godot provides a modular XR system that abstracts many of the different XR "
"platform specifics away from the user. At the core sits the :ref:`XRServer "
"<class_xrserver>` which acts as a central interface to the XR system that "
"allows users to discover interfaces and interact with the components of the "
"XR system."
msgstr ""
"Godot 提供了一个模块化的拓展现实系统，该系统为用户抽象出不同 XR 平台的工作细"
"节。其核心是 :ref:`XRServer <class_xrserver>`，它是 XR 系统的中央接口，允许用"
"户借助此发现其他接口并与 XR 系统的组件进行交互。"

#, fuzzy
msgid ""
"Each supported XR platform is implemented as an :ref:`XRInterface "
"<class_xrinterface>`. Supported interfaces register themselves with the :ref:"
"`XRServer <class_xrserver>` and can be queried with the ``find_interface`` "
"method on the :ref:`XRServer <class_xrserver>`. When the desired interface "
"is found it can be initialized by calling ``initialize`` on the interface."
msgstr ""
"每个支持的 XR 平台都实现为一个 :ref:`XRInterface <class_xrinterface>`。支持的"
"接口会在 :ref:`XRServer <class_xrserver>` 中注册，并可以通过 :ref:`XRServer "
"<class_xrserver>` 的 ``find_interface`` 方法进行查询。当找到所需的接口后，可"
"以通过调用该接口的 ``initialize`` 方法来初始化它。"

#, fuzzy
msgid ""
"A registered interface means nothing more than that the interface is "
"available, if the interface is not supported by the host system, "
"initialization may fail and return ``false``. This can have many reasons and "
"sadly the reasons differ from platform to platform. It can be because the "
"user hasn't installed the required software, or that the user simply hasn't "
"plugged in their headset. You as a developer must thus react properly on an "
"interface failing to initialize."
msgstr ""
"一个已注册的接口仅意味着该接口可用，如果主机系统不支持该接口，初始化可能会失"
"败并返回 ``false`` 。初始化失败有多种原因，不幸的是，这些原因在不同平台上各不"
"相同：可能是因为用户没有安装所需的软件，或者用户根本没有插入他们的头戴设备。"
"作为开发者，你必须对接口初始化失败做出适当的反应。"

#, fuzzy
msgid ""
"Due to the special requirements for output in XR, especially for head "
"mounted devices that supply different images to each eye, the :ref:`XRServer "
"<class_xrserver>` in Godot will override various features in the rendering "
"system. For stand-alone devices this means the final output is handled by "
"the :ref:`XRInterface <class_xrinterface>` and Godot's usual output system "
"is disabled. For desktop XR devices that work as a second screen it is "
"possible to dedicate a separate :ref:`Viewport <class_viewport>` to handle "
"the XR output, leaving the main Godot window available for displaying "
"alternative content."
msgstr ""
"由于 XR 对输出有特殊要求——尤其是头戴设备需要为每只眼睛提供不同的图像，Godot "
"中的 :ref:`XRServer <class_xrserver>` 将会覆盖渲染系统中的各种功能。对于独立"
"设备来说，这意味着最终输出由 :ref:`XRInterface <class_xrinterface>` 处理，而 "
"Godot 的常规输出系统将被禁用。对于作为第二屏幕使用的桌面 XR 设备，可以专门使"
"用一个独立的 :ref:`Viewport <class_viewport>` 来处理 XR 输出，从而使 Godot 的"
"主窗口能够显示其他内容。"

#, fuzzy
msgid ""
"Note that only one interface can be responsible for handling the output to "
"an XR device, this is known as the primary interface and by default will be "
"the first interface that is initialized. Godot currently thus only supports "
"implementations with a single headset. It is possible, but increasingly "
"uncommon, to have a secondary interface, for example to add tracking to an "
"otherwise 3DOF only device."
msgstr ""
"请注意，只能有一个接口负责处理输出到 XR 设备，这个接口被称为主接口，默认情况"
"下将是第一个被初始化的接口。因此，Godot 目前仅支持具有单个头戴设备的实现。也"
"可以使用辅助接口，例如为原本只有 3DOF 的设备添加追踪功能，但这种情况在实际开"
"发中越来越少见。"

#, fuzzy
msgid ""
"There are three XR specific node types that you will find in nearly all XR "
"applications:"
msgstr "在几乎所有的 XR 应用程序中，你会发现三种特定于 XR 的节点类型："

msgid ""
":ref:`XROrigin3D <class_xrorigin3d>` represents, for all intents and "
"purposes, the center point of your play space. That is an oversimplified "
"statement but we'll go into more detail later. All objects tracked in "
"physical space by the XR platform are positioned in relation to this point."
msgstr ""
":ref:`XROrigin3D <class_xrorigin3d>`代表着游戏空间的中心点。这种说法易于理"
"解，但有些过于简化，我们稍后会详细解释。XR 平台跟踪的所有物体都是相对于这一点"
"定位的。"

msgid ""
":ref:`XRCamera3D <class_xrcamera3d>` represents the (stereo) camera that is "
"used when rendering output for the XR device. The positioning of this node "
"is controlled by the XR system and updated automatically using the tracking "
"information provided by the XR platform."
msgstr ""
":ref:`XRCamera3D <class_xrcamera3d>`代表着在为 XR 设备渲染输出时使用的（立"
"体）摄像机。该节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更"
"新。"

msgid ""
":ref:`XRController3D <class_xrcontroller3d>` represents a controller used by "
"the player, commonly there are two, one held in each hand. These nodes give "
"access to various states on these controllers and send out signals when the "
"player presses buttons on them. The positioning of this node is controlled "
"by the XR system and updated automatically using the tracking information "
"provided by the XR platform."
msgstr ""
":ref:`XRController3D <class_xrcontroller3d>`代表玩家使用的控制器，通常有两"
"个：左右手各一个。该节点提供对控制器上各种状态的访问，并在玩家按下按钮时发送"
"信号。节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更新。"

#, fuzzy
msgid ""
"There are other XR related nodes and there is much more to say about these "
"three nodes, but we'll get into that later on."
msgstr ""
"还有其他与 XR 有关的节点。以上三个节点的内容实际上不止于此，但我们可以稍后再"
"谈。"

msgid "Prerequisites for XR in Godot 4"
msgstr "在 Godot 4 中使用 XR 的先决条件"

#, fuzzy
msgid ""
"While in Godot 3 most things worked out of the box, Godot 4 needs a little "
"more setup. This is mainly due to the more advanced nature of the Vulkan "
"renderer. There are many rendering features in Vulkan the XR system uses "
"that aren't enabled by default. They are very easy to turn on, simply open "
"up your project settings and tick the XR shaders tickbox in the XR section:"
msgstr ""
"在 Godot 3 中，大多数东西开箱即用，而 Godot 4 则需要一些设置：Vulkan 渲染器拥"
"有更多高级特性，但 XR 系统所需的 Vulkan 渲染功能是默认关闭的。开启这些功能只"
"需打开项目设置，在 XR 部分勾选 XR 着色器复选框即可："

msgid ""
"As Godot 4 is still in development, many post process effects have not yet "
"been updated to support stereoscopic rendering. Using these will have "
"adverse effects."
msgstr ""
"由于 Godot 4 仍在开发中，许多后期处理效果尚未更新以支持立体渲染。使用这些效果"
"将产生不良影响。"

#, fuzzy
msgid ""
"Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the "
"future XR desktop projects should use Forward+, and projects for stand-alone "
"headsets should use Mobile. However Compatibility is the recommended "
"renderer for now due to it having the best XR performance."
msgstr ""
"Godot 4 有三种渲染器选项，包括 Compatibility、Mobile 和 Forward+。将来，XR 桌"
"面项目应该使用 Forward+，而独立头戴设备的项目应该使用 Mobile。然而，由于 "
"Compatibility 具有最佳的 XR 性能，目前仅推荐使用它作为渲染器。"

msgid "OpenXR"
msgstr "OpenXR"

#, fuzzy
msgid ""
"OpenXR is a new industry standard that allows different XR platforms to "
"present themselves through a standardised API to XR applications. This "
"standard is an open standard maintained by the Khronos Group and thus aligns "
"very well with Godot's interests."
msgstr ""
"OpenXR 是一个由 Khronos Group 维护的 XR 行业开放标准，其目的是允许不同的 XR "
"平台通过共用一套标准化 API 以方便 XR 应用程序进行兼容。该标准与 Godot 的利益"
"非常吻合。"

msgid ""
"The Vulkan implementation of OpenXR is closely integrated with Vulkan, "
"taking over part of the Vulkan system. This requires tight integration of "
"certain core graphics features in the Vulkan renderer which are needed "
"before the XR system is setup. This was one of the main deciding factors to "
"include OpenXR as a core interface."
msgstr ""
"OpenXR 的 Vulkan 实现与 Vulkan 紧密集成，并接管了 Vulkan 系统的一部分。这就要"
"求在设置 XR 系统之前，需要对 Vulkan 渲染器中的某些核心图形功能先行集成。这是"
"将 OpenXR 包含为核心接口的主要决定因素之一。"

msgid ""
"This also means OpenXR needs to be enabled when Godot starts in order to set "
"things up correctly. The required setting can be found in your project "
"settings:"
msgstr ""
"这也意味着需要在 Godot 启动时启用 OpenXR，以便正确设置。启动页面可在项目设置"
"中找到："

msgid ""
"As setup is brought forward with OpenXR you can find several other settings "
"related to OpenXR here as well. These can't be changed while your "
"application is running. The default settings will get us started and we will "
"go into detail in another section of the documentation."
msgstr ""
"你还可以在这里找到与 OpenXR 相关的其他设置。这些设置在应用程序运行时无法更"
"改。默认设置即可让我们开始工作，并且我们将在文档的另一部分详细介绍这些设置。"

msgid "Setting up the XR scene"
msgstr "设置 XR 场景"

#, fuzzy
msgid ""
"Every XR application needs at least an :ref:`XROrigin3D <class_xrorigin3d>` "
"and an :ref:`XRCamera3D <class_xrcamera3d>` node. Most will have two :ref:"
"`XRController3D <class_xrcontroller3d>`, one for the left hand and one for "
"the right. Keep in mind that the camera and controller nodes should be "
"children of the origin node. Add these nodes to a new scene and rename the "
"controller nodes to ``LeftHand`` and ``RightHand``, your scene should look "
"something like this:"
msgstr ""
"每个 XR 应用程序至少需要一个 :ref:`XROrigin3D <class_xrorigin3d>` 和一个 :"
"ref:`XRCamera3D <class_xrcamera3d>` 节点。大多数还会有两个 :ref:"
"`XRController3D <class_xrcontroller3d>`——一个左手一个右手。注意相机和控制器节"
"点应当是子节点。将这些节点添加到一个新场景中，并将控制器节点重命名为 "
"LeftHand 和 RightHand，你的场景应如下所示："

msgid ""
"Next you need to configure the controllers, select the left hand and set it "
"up as follows:"
msgstr "接下来，你需要配置控制器。选择左手控制器，并按如下方式进行设置："

msgid "And the right hand:"
msgstr "将脚本添加到节点："

msgid ""
"Right now all these nodes are on the floor, they will be positioned "
"correctly in runtime. To help during development, it can be helpful to move "
"the camera upwards so its ``y`` is set to ``1.7``, and move the controller "
"nodes to ``-0.5, 1.0, -0.5`` and ``0.5, 1.0, -0.5`` for respectively the "
"left and right hand."
msgstr ""
"现在，所有节点都在场景的平面上，它们将在运行时自动正确定位。为了帮助开发期间"
"的调试，可以将相机向上移动，再把 ``y`` 轴设置为 ``1.7``，并将控制器节点分别移"
"动到 ``-0.5, 1.0, -0.5``（左手）和 ``0.5, 1.0, -0.5``（右手）。"

#, fuzzy
msgid ""
"Next we need to add a script to our root node. Add the following code into "
"this script:"
msgstr "现在给主节点添加一个脚本, 并添加以下代码:"

msgid ""
"This code fragment assumes we are using OpenXR, if you wish to use any of "
"the other interfaces you can change the ``find_interface`` call."
msgstr ""
"上述代码片段假设我们正在使用 OpenXR，如果你希望使用其他接口，可以更改"
"``find_interface`` 调用。"

msgid ""
"As you can see in the code snippet above, we turn off v-sync. When using "
"OpenXR you are outputting the rendering results to an HMD that often "
"requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and "
"v-sync is turned on, you will limit the output to 60 frames per second."
msgstr ""
"正如你看到的，我们在代码中关闭了垂直同步（DisplayServer.VSYNC_DISABLED）。在"
"使用 OpenXR 时，将渲染结果输出到一个头戴显示器（HMD）通常需要以 90Hz 或更高的"
"频率运行。如果你的显示器是 60Hz 且开启了垂直同步，那么输出将限制在每秒 60 "
"帧。"

msgid "XR interfaces like OpenXR perform their own sync."
msgstr "像 OpenXR 这样的 XR 接口会执行它们自己的同步。"

msgid ""
"Also note that by default the physics engine runs at 60Hz as well and this "
"can result in choppy physics. You should set ``Engine."
"physics_ticks_per_second`` to a higher value."
msgstr ""
"同时请注意，默认情况下物理引擎以 60Hz 运行，渲染和物理帧数不一致可能会导致物"
"理效果不流畅。你应该将 ``Engine.physics_ticks_per_second`` 设置为更高的值。"

#, fuzzy
msgid ""
"If you run your project at this point in time, everything will work but you "
"will be in a dark world. So to finish off our starting point add a :ref:"
"`DirectionalLight3D <class_directionallight3d>` and a :ref:`WorldEnvironment "
"<class_worldenvironment>` node to your scene. You may wish to also add a "
"mesh instance as a child to each controller node just to temporarily "
"visualise them. Make sure you configure a sky in your world environment."
msgstr ""
"如果你此时运行项目，一切会正常工作，但是你会处在一个黑暗的世界中。因此，为了"
"完善我们的起步项目，请在场景中添加一个 :ref:`DirectionalLight3D "
"<class_directionallight3d>` 和一个 :ref:`WorldEnvironment "
"<class_worldenvironment>` 节点。你可能还希望在每个控制器节点下添加一个网格实"
"例，以便临时可视化它们。除此以外，别忘了在世界环境中配置一个天空盒。"

msgid ""
"Now run your project, you should be floating somewhere in space and be able "
"to look around."
msgstr "完成配置后运行项目，你应该会漂浮在某个空间中，并能够四处观察。"

#, fuzzy
msgid ""
"While traditional level switching can definitely be used with XR "
"applications, where this scene setup is repeated in each level, most find it "
"easier to set this up once and loading levels as a subscene. If you do "
"switch scenes and replicate the XR setup in each one, do make sure you do "
"not run ``initialize`` multiple times. The effect can be unpredictable "
"depending on the XR interface used."
msgstr ""
"虽然传统的关卡切换——即设置多个关卡场景并在每个场景中重复以上设置——可以用于 "
"XR 应用程序，但多数开发者发现：只设置一次并将关卡作为子场景加载，开发会更容易"
"一些。如果你确实需要切换场景并在每个场景中复制 XR 设置，请确保不要多次运行 "
"``initialize``。多处运行会导致不可预测的结果，具体还取决于所使用的 XR 接口。"

msgid ""
"For the rest of this basic tutorial series we will create a game that uses a "
"single scene."
msgstr "在接下来的基础教程中，我们将创建一个只使用单场景的游戏作为练习。"

msgid "Translation status"
msgstr "翻译状态"
