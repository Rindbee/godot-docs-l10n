#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Optimizing Navigation Performance"
msgstr "优化导航性能"

msgid ""
"Common Navigation related performance problems can be categorized into the "
"following topics:"
msgstr "常见的导览相关性能问题可分为以下主题："

msgid ""
"Performance problems with parsing scene tree nodes for navigation mesh "
"baking."
msgstr "为导航网格烘焙解析场景树节点时的性能问题。"

msgid "Performance problems with baking the actual navigation mesh."
msgstr "烘焙实际导航网格时的性能问题。"

msgid "Performance problems with NavigationAgent path queries."
msgstr "NavigationAgent 路径查询的性能问题。"

msgid "Performance problems with the actual path search."
msgstr "实际路径搜索的性能问题。"

msgid "Performance problems with synchronizing the navigation map."
msgstr "同步导航地图的性能问题。"

msgid ""
"In the following sections information can be found on how to identify and "
"fix or at least mitigate their impact on framerates."
msgstr ""
"在以下部分中可以找到有关如何识别和修复或至少减轻其对影格速率的影响的信息。"

msgid "Performance problems with parsing scene tree nodes"
msgstr "解析场景树节点的性能问题"

msgid ""
"Prefer using simple shapes with as few edges as possible e.g. nothing "
"rounded like a circle, sphere or torus."
msgstr ""
"喜欢使用边缘尽可能少的简单形状，例如，不要像圆形、球体或圆环那样呈圆形。"

msgid ""
"Prefer using physics collision shapes over complex visual meshes as source "
"geometry as meshes need to be copied from the GPU and are commonly much more "
"detailed than necessary."
msgstr ""
"优先使用物理碰撞形状而不是复杂的视觉网格作为来源几何体，因为网格需要从GPU复"
"制，并且通常比必要的详细得多。"

msgid ""
"In general avoid using very complex geometry as source geometry for baking "
"navigation meshes. E.g. never use a very detailed visual mesh, as parsing "
"its shape to data arrays and voxelizing it for the navigation mesh baking "
"will take a long time for no real quality gain on the final navigation mesh. "
"Instead, use a very simplified level of detail version of a shape. Even "
"better, use very primitive shapes like boxes and rectangles that only "
"roughly cover the same geometry but still yield a baked result good enough "
"for pathfinding."
msgstr ""
"一般来说，避免使用非常复杂的几何体作为烘焙导览网格的来源几何体。例如，永远不"
"要使用非常详细的视觉网格，因为将其形状解析为数据数组并将其体素化以进行导览网"
"格烘焙将花费很长时间，而不会在最终导览网格上获得真正的质量增益。相反，请使用"
"形状的非常简化的细节等级版本。更好的是，使用非常原始的形状，例如盒子和矩形，"
"它们仅大致覆盖相同的几何形状，但仍然会产生足够好的路径搜寻烘焙结果。"

msgid ""
"Prefer using simple physics collision shapes over visual meshes, as the "
"source geometry for baking navigation meshes. Physics shapes are by default "
"very limited and optimized shapes that are easy and quick to parse. A visual "
"mesh on the other hand can range from simple to complex. On top, to gain "
"access to visual mesh data the parser needs to request the mesh data arrays "
"from the RenderingServer as visual mesh data is stored directly on the GPU "
"and is not cached on the CPU. This requires locking the RenderingServer "
"thread and can severely impact framerate at runtime while the rendering runs "
"multi-threaded. If the rendering runs single-threaded, the framerate impact "
"might be even worse and the mesh parsing might freeze the entire game for a "
"few seconds on complex meshes."
msgstr ""
"喜欢使用简单的物理碰撞形状而不是视觉网格，作为烘焙导览网格的来源几何。预设情"
"况下，物理形状是非常有限且经过最佳化的形状，可以轻松快速地解析。另一方面，视"
"觉网格的范围可以从简单到复杂。最重要的是，为了存取视觉网格数据，解析器需要从"
"算绘服务器请求网格数据数组，因为视觉网格数据直接储存在GPU上，而不是缓存在CPU"
"上。这需要锁定RenderingServer线程，并且在算绘以多线程运作时会严重影响运作时的"
"影格速率。如果算绘运作单线程，影格率影响可能会更严重，并且网格解析可能会在复"
"杂网格上冻结整个游戏几秒钟。"

msgid "Performance problems with navigation mesh baking"
msgstr "烘焙导航网格的性能问题"

msgid ""
"At runtime, always prefer to use a background thread for baking navigation "
"meshes."
msgstr "在运作时，总是更喜欢使用后台线程来烘焙导览网格。"

msgid ""
"Increase NavigationMesh ``cell_size`` and ``cell_height`` to create less "
"voxels."
msgstr "增加NavigationMesh ``cell_size`` 和 ``cell_height`` 以建立较少的体素。"

msgid ""
"Change the ``SamplePartitionType`` from watershed to monotone or layers to "
"gain baking performance."
msgstr "将 ``SamplePartitionType`` 从分水岭更改为单调或分层以获得烘焙性能。"

msgid ""
"NEVER scale source geometry with nodes to avoid precision errors. Most scale "
"applies only visually and shapes that are very large at their base scale "
"require still a lot of extra processing even while downscaled."
msgstr ""
"切勿使用节点缩放源几何体以避免精度错误。大多数比例仅适用于视觉，即使缩小比"
"例，在基本比例下非常大的形状仍然需要大量额外的处理。"

msgid ""
"Baking navigation meshes at runtime should always be done in a background "
"thread if possible. Even small sized navigation meshes can take far longer "
"to bake than what is possible to squeeze into a single frame, at least if "
"the framerate should stay at a bearable level."
msgstr ""
"如果可能的话，在运作时烘焙导览网格应该始终在后台线程中完成。即使是小尺寸的导"
"览网格物体的烘焙时间也可能比挤入单个影格所需的时间长得多，至少在影格率保持在"
"可忍受的水平的情况下是如此。"

msgid ""
"Complexity of source geometry data parsed from scene tree nodes has big "
"impact on baking performance as everything needs to be mapped to a grid / "
"voxels. For runtime baking performance the NavigationMesh cell size and cell "
"height should be set as high as possible without causing navigation mesh "
"quality problems for a game. If cell size or cell height is set too low the "
"baking is forced to create an excessive amount of voxels to process the "
"source geometry. If the source geometry spans over a very large game world "
"it is even possible that the baking process runs out off memory in the "
"middle and crashes the game. The partition type can also be lowered "
"depending on how complex the games source geometry is to gain some "
"performance. E.g. games with mostly flat surfaces with blocky geometry can "
"get away with the monotone or layers mode that are a lot faster to bake (e."
"g. because they require no distance field pass)."
msgstr ""
"从场景树节点解析的源几何数据的复杂性对烘焙性能有很大影响，因为所有内容都需要"
"映射到一个栅格/体素上。对于运行时烘焙的性能，NavigationMesh 单元格大小和单元"
"格高度应设置得尽可能高，从而不会产生游戏的导航网格质量问题。如果单元格大小或"
"单元格高度设置得太低，则烘焙将被迫创建过多的体素来处理源几何体。如果源几何体"
"跨越非常大的游戏世界，甚至有可能烘焙过程在中途耗尽内存并导致游戏崩溃。分区类"
"型也可以根据游戏源几何体的复杂程度来降低，以获得一些性能。例如。具有块状几何"
"形状的大部分平坦表面的游戏，可以摆脱单层或分层模式，它们的烘焙速度要快得多"
"（例如，因为它们不需要距离场阶段）。"

msgid ""
"Never scale source geometry with nodes. Not only can it result in a lot of "
"precision errors with wrongly matched vertices and edges but also some "
"scaling only exists as visuals and not in the actual parsed data. E.g. if a "
"mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a "
"MeshInstance, the mesh still requires a gigantic and very complex voxel grid "
"to be processed for the baking."
msgstr ""
"切勿使用节点缩放源几何。它不仅会导致大量精确度错误（顶点和边配对错误），而且"
"某些缩放仅以视觉形式存在，而不存在于实际解析的数据中。例如，如果网格在编辑器"
"中以视觉方式缩小，例如在MeshInstance上将比例设为0.001，则网格仍然需要巨大且非"
"常复杂的体素网格来处理烘焙。"

msgid "Performance problems with NavigationAgent path queries"
msgstr "NavigationAgent 路径查询的性能问题"

msgid ""
"Avoid unnecessary path resets and queries every frame in NavigationAgent "
"scripts."
msgstr "避免在 NavigationAgent 脚本中每一帧都对路径进行不必要的重置和查询。"

msgid "Avoid updating all NavigationAgent paths in the same frame."
msgstr "避免在同一帧里更新所有 NavigationAgent 的路径。"

msgid ""
"Logical errors and wasteful operations in the custom NavigationAgent scripts "
"are very common causes of performance issues, e.g. watch out for resetting "
"the path every single frame. By default NavigationAgents are optimized to "
"only query new paths when the target position changes, the navigation map "
"changes or they are forced too far away from the desired path distance."
msgstr ""
"自定义NavigationAgent脚本中的逻辑错误和浪费性操作是导致性能问题的常见原因，例"
"如，请注意每影格重设路径。预设情况下，NavigationAgents经过最佳化，仅在目标位"
"置变更、导览地图变更或被迫远离所需路径距离时查询新路径。"

msgid ""
"E.g. when AI should move to the player, the target position should not be "
"set to the player position every single frame as this queries a new path "
"every frame. Instead, the distance from the current target position to the "
"player position should be compared and only when the player has moved too "
"far away a new target position should be set."
msgstr ""
"例如，当AI应移动到玩家时，目标位置不应每影格都设定为玩家位置，因为这会每影格"
"查询新路径。相反，应该比较从目前目标位置到玩家位置的距离，并且只有当玩家移动"
"得太远时才应该设定新的目标位置。"

msgid ""
"Do not check beforehand if a target position is reachable every frame. What "
"looks like an innocent check is the equivalent of an expensive path query "
"behind the scene. If the plan is to request a new path anyway should the "
"position be reachable, a path should be queried directly. By looking at the "
"last position of the returned path and if that position is in a "
"\"reachable\" distance to the checked position it answers the \"is this "
"position reachable?\" question. This avoids doing the equivalent of two full "
"path queries every frame for the same NavigationAgent."
msgstr ""
"不要预先检查每个画面是否可以到达目标位置。看似无害的检查实际上相当于幕后昂贵"
"的路径查询。如果计划无论如何都要请求新路径（如果位置可达），则应直接查询路"
"径。透过查看返回路径的最后一个位置，如果该位置距检查位置处于“可到达”距离，则"
"它会回答“该位置是否可到达？”问题。这避免了对同一个NavigationAgent每影格执行两"
"次完整路径查询的等效操作。"

msgid ""
"Divide the total number of NavigationAgents into update groups or use random "
"timers so that they do not all request new paths in the same frame."
msgstr ""
"将导览代理程序的总数分割为更新组或使用随机定时器，以便它们不会在同一影格中全"
"部请求新路径。"

msgid "Performance problems with the actual path search"
msgstr "实际路径搜索的性能问题"

msgid ""
"Optimize overdetailed navigation meshes by reducing the amount of polygons "
"and edges."
msgstr "透过减少多边形和边的数量来优化过于详细的导览网格。"

msgid ""
"The cost of the actual path search correlates directly with the amount of "
"navigation mesh polygons and edges and not the real size of a game world. If "
"a giant game world uses very optimized navigation meshes with only few "
"polygons that cover large areas, performance should be acceptable. If the "
"game world is splintered into very small navigation meshes that each have "
"tiny polygons (like for TileMaps) pathfinding performance will be reduced."
msgstr ""
"实际路径搜寻的成本与导览网格多边形和边缘的数量直接相关，而不是与游戏世界的实"
"际大小相关。如果一个巨大的游戏世界使用非常优化的导览网格，只有少数多边形覆盖"
"大面积，那么性能应该是可以接受的。如果游戏世界被分割成非常小的导览网格，每个"
"导览网格都有微小的多边形（如TileMap），则寻路性能将会降低。"

msgid ""
"A common problem is a sudden performance drop when a target position is not "
"reachable in a path query. This performance drop is \"normal\" and the "
"result of a too large, too unoptimized navigation mesh with way to much "
"polygons and edges to search through. In normal path searches where the "
"target position can be reached quickly the pathfinding will do an early exit "
"as soon as the position is reached which can hide this lack of optimization "
"for a while. If the target position can not be reached the pathfinding has "
"to do a far longer search through the available polygons to confirm that the "
"position is absolutely not reachable."
msgstr ""
"一个常见问题是当路径查询中无法到达目标位置时效能突然下降。这种性能下降是“正常"
"的”，是导览网格太大、未优化的结果，需要搜寻大量多边形和边缘。在可以快速到达目"
"标位置的正常路径搜寻中，一旦到达该位置，寻路就会提前退出，这可以暂时隐藏这种"
"优化不足的情况。如果无法到达目标位置，则寻路必须对可用多边形进行更长的搜索，"
"以确认该位置绝对无法到达。"

msgid "Performance problems with navigation map synchronization"
msgstr "导航地图同步的性能问题"

msgid ""
"Merge navigation meshes polygons by vertex instead of by edge connection "
"wherever possible."
msgstr "合并导览尽可能透过顶点而不是边连接来网格化多边形。"

msgid ""
"When changes are made to e.g. navigation meshes or navigation regions, the "
"NavigationServer needs to synchronize the navigation map. Depending on the "
"complexity of navigation meshes, this can take a significant amount of time "
"which may impact the framerate."
msgstr ""
"当对导览网格或导览区域进行变更时，导览服务器需要同步导览地图。根据导览网格的"
"复杂性，这可能需要大量时间，这可能会影响影格速率。"

msgid ""
"The NavigationServer merges navigation meshes either by vertex or by edge "
"connection. The merge by vertex happens when the two vertex of two different "
"edges land in the same map grid cells. This is a rather quick and low-cost "
"operation. The merge by edge connection happens in a second pass for all "
"still unmerged edges. All the free edges are checked for possible edge "
"connections by both distance and angle which is rather costly."
msgstr ""
"导览服务器透过顶点或边连接合并导览网格。当两条不同边的两个顶点落在同一地图网"
"格单元中时，就会发生以顶点合并。这是一个相当快速且低成本的操作。对于所有尚未"
"合并的边，按边连接进行合并发生在第二遍。透过距离和角度检查所有自由边缘是否有"
"可能的边缘连接，这是相当昂贵的。"

msgid ""
"So apart from the general rule to have as few polygon edges as possible, as "
"many edges as possible should be merged by vertex upfront so only a few "
"edges are left for the more costly edge connection calculation. The debug "
"Navigation PerformanceMonitor can be used to get statistics on how many "
"polygons and edges are available and how many of them are unmerged or not "
"merged by vertex. If the ratio between vertex merged and edge connections is "
"way off (vertex should be significantly higher) the navigation meshes are "
"properly created or placed very inefficient."
msgstr ""
"因此，除了具有尽可能少的多边形边的一般规则之外，还应透过顶点预先合并尽可能多"
"的边，以便只留下少量边用于成本更高的边连接计算。调试导览性能摄像头可用于取得"
"有关可用多边形和边的数量以及其中有多少未合并或未按顶点合并的统计数据。如果顶"
"点合并和边连接之间的比率相差很大（顶点应该明显更高），则导览网格会正确建立或"
"放置得非常低效。"
