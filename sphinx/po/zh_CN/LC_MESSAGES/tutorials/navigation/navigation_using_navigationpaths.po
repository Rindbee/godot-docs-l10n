#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using NavigationPaths"
msgstr "使用 NavigationPath"

msgid "Obtaining a NavigationPath"
msgstr "获取 NavigationPath"

msgid ""
"Navigation paths can be directly queried from the NavigationServer and do "
"not require any additional nodes or objects as long as the navigation map "
"has a navigation mesh to work with."
msgstr ""
"导航路径可以直接从NavigationServer查询，并且不需要任何其他节点或对象，只要导"
"航地图具有可使用的导航网格即可。"

msgid ""
"To obtain a 2D path, use ``NavigationServer2D.map_get_path(map, from, to, "
"optimize, navigation_layers)``."
msgstr ""
"要获取 2D 路径，请使用 ``NavigationServer2D.map_get_path(地图, 起点, 终点, 优"
"化, 导航层)``\\ 。"

msgid ""
"To obtain a 3D path, use ``NavigationServer3D.map_get_path(map, from, to, "
"optimize, navigation_layers)``."
msgstr ""
"要获取 3D 路径，请使用 ``NavigationServer3D.map_get_path(地图, 起点, 终点, 优"
"化, 导航层)``\\ 。"

msgid ""
"For more customizable navigation path queries that require additional setup "
"see :ref:`doc_navigation_using_navigationpathqueryobjects`."
msgstr ""
"有关需要额外设定的更多可自定义导览路径查询，请参"
"阅 :ref:`doc_navigation_using_navigationpathqueryobjects`\\ 。"

msgid ""
"One of the required parameters for the query is the RID of the navigation "
"map. Each game world has a default navigation map automatically created. The "
"default navigation maps can be retrieved with "
"``get_world_2d().get_navigation_map()`` from any Node2D inheriting node or "
"``get_world_3d().get_navigation_map()`` from any Node3D inheriting node. The "
"second and third parameters are the starting position and the target "
"position as Vector2 for 2D or Vector3 for 3D."
msgstr ""
"查询所需的参数之一是导航地图的RID。每个游戏世界都有一个自动创建的默认导航地"
"图。默认导航地图可以使用 ``get_world_2d().get_navigation_map()`` 从任何Node2D"
"继承节点检索，也可以使用 ``get_world_3d().get_navigation_map()`` 从任意Node3D"
"继承节点检索。第二和第三参数是起始位置和目标位置，作为2D的Vector2或3D的"
"Vector3。"

msgid ""
"If the ``optimized`` parameter is ``true``, path positions will be shortened "
"along polygon corners with an additional funnel algorithm pass. This works "
"well for free movement on navigation meshes with unequally sized polygons as "
"the path will hug around corners along the polygon corridor found by the A* "
"algorithm. With small cells the A* algorithm creates a very narrow funnel "
"corridor that can create ugly corner paths when used with grids."
msgstr ""
"如果 ``optimized`` 参数为 ``true``\\ ，则会额外做一遍漏斗算法，将路径点沿着多"
"边形的角落缩短。这种处理适用于在多边形大小不一致的导航网格上自由移动的情况，"
"因为路径会沿着 A* 算法找到的多边形走廊绕过拐角。如果单元格较小，A* 算法就会创"
"建出非常狭窄的漏斗形走廊，使用栅格时，路径的拐角处就会很难看。"

msgid ""
"If the ``optimized`` parameter is ``false``, path positions will be placed "
"at the center of each polygon edge. This works well for pure grid movement "
"on navigation meshes with equally sized polygons as the path will go through "
"the center of the grid cells. Outside of grids due to polygons often "
"covering large open areas with a single, long edge this can create paths "
"with unnecessary long detours."
msgstr ""
"如果 ``optimized`` 参数为 ``false`` ，则路径位置将放置在每个多边形边缘的中"
"心。这适用于具有相同大小多边形的导航网格上的纯网格移动，因为路径将穿过网格单"
"元的中心。在网格之外，由于多边形通常用一条长边覆盖大的开放区域，这可能会产生"
"不必要的长迂回路径。"

msgid ""
"A returned ``path`` by the NavigationServer will be a ``PackedVector2Array`` "
"for 2D or a ``PackedVector3Array`` for 3D. These are just a memory-optimized "
"``Array`` of vector positions. All position vectors inside the array are "
"guaranteed to be inside a NavigationPolygon or NavigationMesh. The path "
"array, if not empty, has the navigation mesh position closest to the "
"starting position at the first index ``path[0]`` position. The closest "
"available navigation mesh position to the target position is the last index "
"``path[path.size()-1]`` position. All indexes between are the path points "
"that an actor should follow to reach the target without leaving the "
"navigation mesh."
msgstr ""
"NavigationServer返回的 ``path`` 将是2D的 ``PackedVector2Array`` 或3D的 "
"``PackedVector3Array``\\ 。这些只是一个经过内存优化的矢量位置 ``Array``\\ 。"
"阵列内的所有位置矢量都保证位于NavigationPolygon或NavigationMesh内。如果路径数"
"组不是空的，则其导航网格位置最靠近第一个索引 ``path[0]`` 位置处的起始位置。离"
"目标位置最近的可用导航网格位置是最后一个索引 ``path[path.size()-1]`` 位置。之"
"间的所有索引都是参与者在不离开导航网格的情况下到达目标所应遵循的路径点。"

msgid ""
"If the target position is on a different navigation mesh that is not merged "
"or connected the navigation path will lead to the closest possible position "
"on the starting position navigation mesh."
msgstr ""
"如果目标位置位于未合并或连接的不同导览网格上，则导览路径将通往起始位置导览网"
"格上最接近的可能位置。"

msgid ""
"The following script moves a Node3D inheriting node along a navigation path "
"using the default navigation map by setting the target position with "
"``set_movement_target()``."
msgstr ""
"以下脚本透过使用 ``set_movement_target()`` 设定目标位置，使用预设导览地图沿着"
"导览路径移动Node3D继承节点。"
