#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "3D gizmo plugins"
msgstr "3D 小工具插件"

msgid "Introduction"
msgstr "前言"

msgid ""
"3D gizmo plugins are used by the editor and custom plugins to define the "
"gizmos attached to any kind of Node3D node."
msgstr ""
"3D 小工具插件是由编辑器和自定义插件用来定义附加到任何类型的 Node3D 节点的小工"
"具。"

msgid ""
"This tutorial shows the two main approaches to defining your own custom "
"gizmos. The first option works well for simple gizmos and creates less "
"clutter in your plugin structure, and the second one will let you store some "
"per-gizmo data."
msgstr ""
"本教程将介绍定义自定义小工具的两种主要方法。第一种方法适用于简单的小工具，可"
"以减少插件结构的混乱，第二种方法可以让你存储各个小工具的一些数据。"

msgid ""
"This tutorial assumes you already know how to make generic plugins. If in "
"doubt, refer to the :ref:`doc_making_plugins` page."
msgstr ""
"本教程假设你已经知道如何制作通用插件。如有疑问，请参阅 :ref:"
"`doc_making_plugins` 页面。"

msgid "The EditorNode3DGizmoPlugin"
msgstr "EditorNode3DGizmoPlugin"

msgid "This would be a basic setup:"
msgstr "这是一个基本设置:"

msgid ""
"For simple gizmos, inheriting :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>` is enough. If you want to store some per-"
"gizmo data or you are porting a Godot 3.0 gizmo to 3.1+, you should go with "
"the second approach."
msgstr ""
"简单的小工具只要继承 :ref:`EditorNode3DGizmoPlugin "
"<class_EditorNode3DGizmoPlugin>` 就足够了。如果你想存储各个小工具的一些数据，"
"或者你要把 Godot 3.0 的小工具移植到 3.1+，你应该选择第二种方法。"

msgid "Simple approach"
msgstr "简单方法"

msgid ""
"The first step is to, in our custom gizmo plugin, override the :ref:"
"`_has_gizmo()<class_EditorNode3DGizmoPlugin_private_method__has_gizmo>` "
"method so that it returns ``true`` when the node parameter is of our target "
"type."
msgstr ""
"第一步，在我们的自定义小工具插件中，覆盖 :ref:"
"`_has_gizmo()<class_EditorNode3DGizmoPlugin_private_method__has_gizmo>` 方"
"法，以便当节点参数是目标类型时返回 ``true``\\ 。"

msgid ""
"Then we can override methods like :ref:"
"`_redraw()<class_EditorNode3DGizmoPlugin_private_method__redraw>` or all the "
"handle related ones."
msgstr ""
"我们可以覆盖譬如 :ref:"
"`_redraw()<class_EditorNode3DGizmoPlugin_private_method__redraw>` 之类的方"
"法，或所有与句柄相关的方法。"

msgid ""
"Note that we created a material in the `_init` method, and retrieved it in "
"the `_redraw` method using :ref:"
"`get_material()<class_EditorNode3DGizmoPlugin_method_get_material>`. This "
"method retrieves one of the material's variants depending on the state of "
"the gizmo (selected and/or editable)."
msgstr ""
"请注意，我们在 `_init` 方法中创建了一个材质，并在 `_redraw` 方法中使用 :ref:"
"`get_material()<class_EditorNode3DGizmoPlugin_method_get_material>` 检索了该"
"材质。该方法根据小工具的状态（选中和/或可编辑）来检索材质的变体之一。"

msgid "So the final plugin would look somewhat like this:"
msgstr "你最后的场景应该是这样的:"

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks in :ref:"
"`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>` to get properly "
"working handles."
msgstr ""
"请注意，我们刚刚在 `_redraw` 方法中添加了一些句柄，但我们仍然需要在 :ref:"
"`EditorNode3DGizmoPlugin <class_EditorNode3DGizmoPlugin>` 中实现其余与句柄相"
"关的回调，以获得正常工作的句柄。"

msgid "Alternative approach"
msgstr "替代方法"

msgid ""
"In some cases we want to provide our own implementation of :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>`, maybe because we want to have "
"some state stored in each gizmo or because we are porting an old gizmo "
"plugin and we don't want to go through the rewriting process."
msgstr ""
"在某些情况下，我们希望提供自己的 :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>` 实现，可能是因为希望在各个小工具"
"中存储一些状态，或者因为正在移植旧的小工具插件，而不想经历重写过程。"

msgid ""
"In these cases all we need to do is, in our new gizmo plugin, override :ref:"
"`_create_gizmo()<class_EditorNode3DGizmoPlugin_private_method__create_gizmo>`, "
"so it returns our custom gizmo implementation for the Node3D nodes we want "
"to target."
msgstr ""
"在这些情况下，我们需要做的就是在新小工具插件中覆盖 :ref:"
"`_create_gizmo()<class_EditorNode3DGizmoPlugin_private_method__create_gizmo>`\\ ，"
"这样它就会返回我们想要针对的 Node3D 节点的自定义小工具实现。"

msgid ""
"This way all the gizmo logic and drawing methods can be implemented in a new "
"class extending :ref:`EditorNode3DGizmo<class_EditorNode3DGizmo>`, like so:"
msgstr ""
"这样，所有的小工具逻辑和绘制方法都可以在扩展 :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>` 的新类中实现，像这样："

msgid ""
"Note that we just added some handles in the `_redraw` method, but we still "
"need to implement the rest of handle-related callbacks in :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>` to get properly working handles."
msgstr ""
"请注意，我们刚刚在 `_redraw` 方法中添加了一些句柄，但我们仍然需要在 :ref:"
"`EditorNode3DGizmo<class_EditorNode3DGizmo>` 中实现其余与句柄相关的回调，以获"
"得正常工作的句柄。"
