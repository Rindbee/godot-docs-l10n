#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using compute shaders"
msgstr "使用计算着色器"

msgid ""
"This tutorial will walk you through the process of creating a minimal "
"compute shader. But first, a bit of background on compute shaders and how "
"they work with Godot."
msgstr ""
"本教程会带领你创建一个最简单的计算着色器。但首先需要先介绍一下计算着色器的背"
"景以及在 Godot 中的工作原理。"

msgid ""
"This tutorial assumes you are familiar with shaders generally. If you are "
"new to shaders please read :ref:`doc_introduction_to_shaders` and :ref:`your "
"first shader <toc-your-first-shader>` before proceeding with this tutorial."
msgstr ""
"本教程假定你已大致熟悉着色器。如果你是着色器新手，请先阅读"
"《\\ :ref:`doc_introduction_to_shaders`\\ 》和《\\ :ref:`你的第一个着色器 "
"<toc-your-first-shader>`\\ 》，然后再继续本教程。"

msgid ""
"A compute shader is a special type of shader program that is orientated "
"towards general purpose programming. In other words, they are more flexible "
"than vertex shaders and fragment shaders as they don't have a fixed purpose "
"(i.e. transforming vertices or writing colors to an image). Unlike fragment "
"shaders and vertex shaders, compute shaders have very little going on behind "
"the scenes. The code you write is what the GPU runs and very little else. "
"This can make them a very useful tool to offload heavy calculations to the "
"GPU."
msgstr ""
"计算着色器是一种着重于通用编程特殊的着色器。换句话说，它们相比于节点和片段着"
"色器更加灵活，因为它们没有固定的用途（节点变换或图片着色）。不同于节点和片段"
"着色器，计算着色器的幕后工作非常少。GPU 运行的代码就是你编写的代码，此外几乎"
"没有其他内容。因此，计算着色器在将繁重计算转移到 GPU 上时非常有用。"

msgid "Now let's get started by creating a short compute shader."
msgstr "现在我们以一个简短的计算着色器入手。"

msgid ""
"First, in the **external** text editor of your choice, create a new file "
"called ``compute_example.glsl`` in your project folder. When you write "
"compute shaders in Godot, you write them in GLSL directly. The Godot shader "
"language is based on GLSL. If you are familiar with normal shaders in Godot, "
"the syntax below will look somewhat familiar."
msgstr ""
"首先，用你选用的 **外部** 编辑器，在项目文件夹中创建一个命名为 "
"``compute_example.glsl`` 的新文件。Godot 的计算着色器直接使用 GLSL 代码。"
"Godot 着色器语言基于 GLSL，如果你对 Godot 正常着色器熟悉，那么对以下语法也会"
"比较熟悉。"

msgid ""
"Compute shaders can only be used from RenderingDevice-based renderers (the "
"Forward+ or Mobile renderer). To follow along with this tutorial, ensure "
"that you are using the Forward+ or Mobile renderer. The setting for which is "
"located in the top right-hand corner of the editor."
msgstr ""
"计算着色器只能在基于 RenderingDevice 的渲染器（Forward+ 或 Mobile）中使用。想"
"要按照本教程操作的话，请确保你使用的是 Forward+ 或 Mobile 渲染器。相关设置位"
"于编辑器的右上角。"

msgid ""
"Note that compute shader support is generally poor on mobile devices (due to "
"driver bugs), even if they are technically supported."
msgstr ""
"请注意，虽然理论上移动设备支持计算着色器，但（由于驱动器问题）这一支持通常较"
"差。"

msgid "Let's take a look at this compute shader code:"
msgstr "我们把它调成蓝色："

msgid ""
"This code takes an array of floats, multiplies each element by 2 and store "
"the results back in the buffer array. Now let's look at it line-by-line."
msgstr ""
"这段代码接受一个 float 数组，将其中的每个元素和 2 相乘，并将结果存储回数组"
"中。现在，我们来逐行观察这段代码。"

msgid "These two lines communicate two things:"
msgstr "这两行文本传达了以下的两件事："

msgid ""
"The following code is a compute shader. This is a Godot-specific hint that "
"is needed for the editor to properly import the shader file."
msgstr ""
"如下的代码为计算着色器。这是 Godot 特有的提示文本，编辑器需要此文本才能正确导"
"入着色器文件。"

msgid "The code is using GLSL version 450."
msgstr "代码使用的是 GLSL 450。"

msgid ""
"You should never have to change these two lines for your custom compute "
"shaders."
msgstr "在编写计算着色器时，你应当永远以这两行作为文件的开头。"

msgid ""
"Next, we communicate the number of invocations to be used in each workgroup. "
"Invocations are instances of the shader that are running within the same "
"workgroup. When we launch a compute shader from the CPU, we tell it how many "
"workgroups to run. Workgroups run in parallel to each other. While running "
"one workgroup, you cannot access information in another workgroup. However, "
"invocations in the same workgroup can have some limited access to other "
"invocations."
msgstr ""
"接下来我们要传达每个工作组所使用的调用次数。“调用”指的是同一个工作组中运行的"
"着色器实例。从 CPU 启动计算着色器时，我们会告诉它需要运行多少个工作组。工作组"
"之间是并行执行的。运行时，一个工作组无法访问另一个工作组中的信息。不过同一个"
"工作组中的不同调用可以相互进行有限的访问。"

msgid "Think about workgroups and invocations as a giant nested ``for`` loop."
msgstr "你可以将工作组和调用想象成巨型的嵌套 ``for`` 循环。"

msgid ""
"Workgroups and invocations are an advanced topic. For now, remember that we "
"will be running two invocations per workgroup."
msgstr ""
"工作组与调用属于高阶内容。目前请需要记住我们在每个工作组中运行了两个调用。"

msgid ""
"Here we provide information about the memory that the compute shader will "
"have access to. The ``layout`` property allows us to tell the shader where "
"to look for the buffer, we will need to match these ``set`` and ``binding`` "
"positions from the CPU side later."
msgstr ""
"这里我们提供的是与计算着色器所能访问的内存相关的信息。我们可以通过 "
"``layout`` 属性告诉着色器去哪里寻找缓冲，稍后我们需要在 CPU 一侧匹配这些 "
"``set`` 和 ``binding`` 的位置。"

msgid ""
"The ``restrict`` keyword tells the shader that this buffer is only going to "
"be accessed from one place in this shader. In other words, we won't bind "
"this buffer in another ``set`` or ``binding`` index. This is important as it "
"allows the shader compiler to optimize the shader code. Always use "
"``restrict`` when you can."
msgstr ""
"关键字 ``restrict`` 能够告诉着色器该缓冲只会在这个着色器中的某个单一位置进行"
"访问。换句话说，我们不会将该缓冲绑定到其他 ``set`` 或 ``binding`` 索引。这一"
"点非常重要，着色器编译器就能够借此对着色器代码进行优化。能使用 ``restrict`` "
"时请一定要使用。"

msgid ""
"This is an *unsized* buffer, which means it can be any size. So we need to "
"be careful not to read from an index larger than the size of the buffer."
msgstr ""
"这是一个\\ *未指明大小*\\ 的缓冲，也就是说可以是任意大小。因此我们需要注意不"
"要让用来读取的索引超过缓冲的大小。"

msgid "Create a local RenderingDevice"
msgstr "创建局部 RenderingDevice"

msgid "Provide input data"
msgstr "提供输入数据"

msgid ""
"As you might remember, we want to pass an input array to our shader, "
"multiply each element by 2 and get the results."
msgstr ""
"你可能还记得，我们想将一个输入数组传递给着色器，将每个元素乘以 2 然后获取结"
"果。"

msgid ""
"We need to create a buffer to pass values to a compute shader. We are "
"dealing with an array of floats, so we will use a storage buffer for this "
"example. A storage buffer takes an array of bytes and allows the CPU to "
"transfer data to and from the GPU."
msgstr ""
"我们需要创建一个缓冲区来将值传递给计算着色器。我们处理的是一个浮点数数组，所"
"以在这个示例中我们将使用存储缓冲区。存储缓冲区接收一个字节数组，能够在 CPU "
"与 GPU 之间进行数据传输。"

msgid "So let's initialize an array of floats and create a storage buffer:"
msgstr "让我们初始化一个浮点数数组并创建一个存储缓冲区："

msgid ""
"With the buffer in place we need to tell the rendering device to use this "
"buffer. To do that we will need to create a uniform (like in normal shaders) "
"and assign it to a uniform set which we can pass to our shader later."
msgstr ""
"有了缓冲区后，我们需要让渲染设备来使用这个缓冲区。为此，我们需要创建一个 "
"uniform（和普通着色器中一样）并将其分配给一个 uniform 集，稍后我们可以将其传"
"递给着色器。"

msgid "Defining a compute pipeline"
msgstr "定义计算管线"

msgid ""
"The next step is to create a set of instructions our GPU can execute. We "
"need a pipeline and a compute list for that."
msgstr ""
"下一步需要创建一套 GPU 可以运行的指令。为此我们需要一个管线和一个计算列表。"

msgid "The steps we need to do to compute our result are:"
msgstr "需要执行以下步骤才能够得到计算结果："

msgid "Create a new pipeline."
msgstr "新建管线。"

msgid "Begin a list of instructions for our GPU to execute."
msgstr "开启需要让 GPU 执行的指令列表。"

msgid "Bind our compute list to our pipeline"
msgstr "将计算列表绑定至管线"

msgid "Bind our buffer uniform to our pipeline"
msgstr "将缓冲区 uniform 绑定至管线"

msgid "Specify how many workgroups to use"
msgstr "指定要使用的工作组数量"

msgid "End the list of instructions"
msgstr "关闭指令列表"

msgid "Execute a compute shader"
msgstr "执行计算着色器"

msgid "Retrieving results"
msgstr "获取结果"
