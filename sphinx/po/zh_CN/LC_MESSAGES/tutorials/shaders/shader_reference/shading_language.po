#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Shading language"
msgstr "着色语言"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and "
"functions are supported, and the few remaining ones will likely be added "
"over time."
msgstr ""
"Godot 使用类似于 GLSL ES 3.0 的着色语言。支持大多数数据类型和函数，并且可能会"
"随着时间的推移添加剩余的几种类型和函数。"

msgid ""
"If you are already familiar with GLSL, the :ref:`Godot Shader Migration "
"Guide<doc_converting_glsl_to_godot_shaders>` is a resource that will help "
"you transition from regular GLSL to Godot's shading language."
msgstr ""
"如果你已经熟悉 GLSL，\\ :ref:`Godot 着色器迁移指南 "
"<doc_converting_glsl_to_godot_shaders>`\\ 是一个帮助你从常规 GLSL 转换到 "
"Godot 着色语言的资源。"

msgid "Data types"
msgstr "数据类型"

msgid "Most GLSL ES 3.0 datatypes are supported:"
msgstr "支持大多数 GLSL ES 3.0 数据类型："

msgid "Type"
msgstr "类型"

msgid "Description"
msgstr "描述"

msgid "**void**"
msgstr "**void**"

msgid "Void datatype, useful only for functions that return nothing."
msgstr "Void 数据类型，只对不返回任何内容的函数有用。"

msgid "**bool**"
msgstr "**bool**"

msgid "Boolean datatype, can only contain ``true`` or ``false``."
msgstr "布尔数据类型，只能包含 ``true`` 或 ``false``\\ 。"

msgid "**bvec2**"
msgstr "**bvec2**"

msgid "Two-component vector of booleans."
msgstr "布尔的两分量向量。"

msgid "**bvec3**"
msgstr "**bvec3**"

msgid "Three-component vector of booleans."
msgstr "布尔的三分量向量。"

msgid "**bvec4**"
msgstr "**bvec4**"

msgid "Four-component vector of booleans."
msgstr "布尔的四分量向量。"

msgid "**int**"
msgstr "**int**"

msgid "**ivec2**"
msgstr "**ivec2**"

msgid "Two-component vector of signed integers."
msgstr "有符号整数的双分量向量。"

msgid "**ivec3**"
msgstr "**ivec3**"

msgid "Three-component vector of signed integers."
msgstr "有符号整数的三分量向量。"

msgid "**ivec4**"
msgstr "**ivec4**"

msgid "Four-component vector of signed integers."
msgstr "有符号整数的四分量向量。"

msgid "**uint**"
msgstr "**uint**"

msgid "Unsigned scalar integer; can't contain negative numbers."
msgstr "无符号标量整数；不能包含负数。"

msgid "**uvec2**"
msgstr "**uvec2**"

msgid "Two-component vector of unsigned integers."
msgstr "无符号整数的两分量向量。"

msgid "**uvec3**"
msgstr "**uvec3**"

msgid "Three-component vector of unsigned integers."
msgstr "无符号整数的三分量向量。"

msgid "**uvec4**"
msgstr "**uvec4**"

msgid "Four-component vector of unsigned integers."
msgstr "无符号整数的四分量向量。"

msgid "**float**"
msgstr "**float**"

msgid "**vec2**"
msgstr "**vec2**"

msgid "Two-component vector of floating-point values."
msgstr "浮点值的两分量向量。"

msgid "**vec3**"
msgstr "**vec3**"

msgid "Three-component vector of floating-point values."
msgstr "浮点值的三分量向量。"

msgid "**vec4**"
msgstr "**vec4**"

msgid "Four-component vector of floating-point values."
msgstr "浮点值的四分量向量。"

msgid "**mat2**"
msgstr "**mat2**"

msgid "2x2 matrix, in column major order."
msgstr "2x2 矩阵，按列主要顺序。"

msgid "**mat3**"
msgstr "**mat3**"

msgid "3x3 matrix, in column major order."
msgstr "3x3 矩阵，按列主要顺序。"

msgid "**mat4**"
msgstr "**mat4**"

msgid "4x4 matrix, in column major order."
msgstr "4x4 矩阵，按列主要顺序。"

msgid "**sampler2D**"
msgstr "**sampler2D**"

msgid "Sampler type for binding 2D textures, which are read as float."
msgstr "用于绑定被读取为浮点数的 2D 纹理的采样器类型。"

msgid "**isampler2D**"
msgstr "**isampler2D**"

msgid "Sampler type for binding 2D textures, which are read as signed integer."
msgstr "用于绑定被读取为有符号整数的 2D 纹理的采样器类型。"

msgid "**usampler2D**"
msgstr "**usampler2D**"

msgid ""
"Sampler type for binding 2D textures, which are read as unsigned integer."
msgstr "用于绑定被读取为无符号整数的 2D 纹理的采样器类型。"

msgid "**sampler2DArray**"
msgstr "**sampler2DArray**"

msgid "Sampler type for binding 2D texture arrays, which are read as float."
msgstr "用于绑定被读取为浮点数的 2D 纹理数组的采样器类型。"

msgid "**isampler2DArray**"
msgstr "**isampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as signed integer."
msgstr "用于绑定被读取为有符号整数的 2D 纹理数组的采样器类型。"

msgid "**usampler2DArray**"
msgstr "**usampler2DArray**"

msgid ""
"Sampler type for binding 2D texture arrays, which are read as unsigned "
"integer."
msgstr "用于绑定被读取为无符号整数的 2D 纹理数组的采样器类型。"

msgid "**sampler3D**"
msgstr "**sampler3D**"

msgid "Sampler type for binding 3D textures, which are read as float."
msgstr "用于绑定被读取为浮点数的 3D 纹理的采样器类型。"

msgid "**isampler3D**"
msgstr "**isampler3D**"

msgid "Sampler type for binding 3D textures, which are read as signed integer."
msgstr "用于绑定被读取为有符号整数的 3D 纹理的采样器类型。"

msgid "**usampler3D**"
msgstr "**usampler3D**"

msgid ""
"Sampler type for binding 3D textures, which are read as unsigned integer."
msgstr "用于绑定被读取为无符号整数的 3D 纹理的采样器类型。"

msgid "**samplerCube**"
msgstr "**samplerCube**"

msgid "Sampler type for binding Cubemaps, which are read as float."
msgstr "用于绑定被读取为浮点数的立方体贴图的采样器类型。"

msgid "**samplerCubeArray**"
msgstr "**samplerCubeArray**"

msgid ""
"Sampler type for binding Cubemap arrays, which are read as float. Only "
"supported in Forward+ and Mobile, not Compatibility."
msgstr ""
"用于绑定被读取为浮点数的立方体贴图数组的采样器类型。仅在 Forward+ 和移动中支"
"持，兼容不支持。"

msgid "**samplerExternalOES**"
msgstr "**samplerExternalOES**"

msgid ""
"External sampler type. Only supported in Compatibility/Android platform."
msgstr "外部采样器类型。仅在兼容/ Android 平台中支持。"

msgid "Comments"
msgstr "注释"

msgid ""
"The shading language supports the same comment syntax as used in C# and C++, "
"using ``//`` for single-line comments and ``/* */`` for multi-line comments:"
msgstr ""
"着色语言支持与 C# 和 C++ 相同的注释语法，使用 ``//`` 进行单行注释和 ``/* */"
"`` 进行多行注释："

msgid ""
"Additionally, you can use documentation comments that are displayed in the "
"inspector when hovering a shader parameter. Documentation comments are "
"currently only supported when placed immediately above a ``uniform`` "
"declaration. These documentation comments only support the **multiline** "
"comment syntax and must use **two** leading asterisks (``/**``) instead of "
"just one (``/*``):"
msgstr ""
"此外，你还可以使用当将鼠标悬停在着色器参数上时显示在检查器中的文档注释。当"
"前，仅当将文档注释放置在 ``uniform`` 声明正上方时，才支持该注释。这些文档注释"
"仅支持\\ **多行**\\ 注释语法，并且必须使用\\ **两个**\\ 前导星号（\\ ``/"
"**``\\ ），而不是仅使用一个（\\ ``/*``\\ ）："

msgid ""
"The asterisks on the follow-up lines are not required, but are recommended "
"as per the :ref:`doc_shaders_style_guide`. These asterisks are automatically "
"stripped by the inspector, so they won't appear in the tooltip."
msgstr ""
"后续行上的星号不是必需的，但根据《\\ :ref:`doc_shaders_style_guide`\\ 》建议"
"使用。这些星号会被检查器自动删除，因此它们不会出现在工具提示中。"

msgid "Casting"
msgstr "类型转换"

msgid ""
"Just like GLSL ES 3.0, implicit casting between scalars and vectors of the "
"same size but different type is not allowed. Casting of types of different "
"size is also not allowed. Conversion must be done explicitly via "
"constructors."
msgstr ""
"与 GLSL ES 3.0 一样，不允许在大小相同但类型不同的标量和向量之间进行隐式转换。"
"也不允许强制转换不同大小的类型。转换必须通过构造函数显式完成。"

msgid "Example:"
msgstr "示例："

msgid ""
"Default integer constants are signed, so casting is always needed to convert "
"to unsigned:"
msgstr "默认整数常量是有符号的，因此转换为无符号时始终需要强制类型转换："

msgid "Members"
msgstr "成员"

msgid ""
"Individual scalar members of vector types are accessed via the \"x\", \"y\", "
"\"z\" and \"w\" members. Alternatively, using \"r\", \"g\", \"b\" and \"a\" "
"also works and is equivalent. Use whatever fits best for your needs."
msgstr ""
"向量类型的单个标量成员可通过“x”、“y”、“z”和“w”成员访问。或者，使"
"用“r”、“g”、“b”和“a”也行且效果相同。使用最适合你需求的方式。"

msgid ""
"For matrices, use the ``m[column][row]`` indexing syntax to access each "
"scalar, or ``m[column]`` to access a vector by column index. For example, "
"for accessing the y-component of the translation from a mat4 transform "
"matrix (4th column, 2nd line) you use ``m[3][1]`` or ``m[3].y``."
msgstr ""
"对于矩阵，使用 ``m[column][row]`` 索引语法来访问每个标量，或使用 "
"``m[column]`` 按列索引来访问一个向量。例如，要从 mat4 变换矩阵中访问它的 y 分"
"量（第 4 列，第 2 行），可使用 ``m[3][1]`` 或 ``m[3].y``\\ 。"

msgid "Constructing"
msgstr "构造"

msgid "Construction of vector types must always pass:"
msgstr "向量类型的构造必须始终通过："

msgid ""
"Matrices can also be built from a matrix of another dimension. There are two "
"rules:"
msgstr "矩阵也可以由另一维的矩阵构建。有两个规则："

msgid ""
"1. If a larger matrix is constructed from a smaller matrix, the additional "
"rows and columns are set to the values they would have in an identity "
"matrix. 2. If a smaller matrix is constructed from a larger matrix, the top, "
"left submatrix of the larger matrix is used."
msgstr ""
"1. 如果较大的矩阵由较小的矩阵构成，则额外的行和列将设置为它们在单位矩阵中的"
"值。 2. 如果较小的矩阵由较大的矩阵构成，则使用较大矩阵的左上子矩阵。"

msgid "Swizzling"
msgstr "调换"

msgid ""
"It is possible to obtain any combination of components in any order, as long "
"as the result is another vector type (or scalar). This is easier shown than "
"explained:"
msgstr ""
"只要结果是另一种向量类型（或标量），就可以按任意顺序获得组件的任意组合。百闻"
"不如一见："

msgid "Precision"
msgstr "精度"

msgid ""
"It is possible to add precision modifiers to datatypes; use them for "
"uniforms, variables, arguments and varyings:"
msgstr ""
"可以为数据类型添加精度修饰符；将它们用于 uniform、变量、参数、varying："

msgid ""
"Using lower precision for some operations can speed up the math involved (at "
"the cost of less precision). This is rarely needed in the vertex processor "
"function (where full precision is needed most of the time), but is often "
"useful in the fragment processor."
msgstr ""
"对某些操作使用较低的精度可以加快所涉及的数学运算速度（但代价是精度较低）。这"
"在顶点处理函数中鲜有需要（大多数情况下需要全精度），但在片段处理函数中通常很"
"有用。"

msgid ""
"Some architectures (mainly mobile) can benefit significantly from this, but "
"there are downsides such as the additional overhead of conversion between "
"precisions. Refer to the documentation of the target architecture for "
"further information. In many cases, mobile drivers cause inconsistent or "
"unexpected behavior and it is best to avoid specifying precision unless "
"necessary."
msgstr ""
"某些架构（主要是移动架构）可以从中受益匪浅，但也存在一些缺点，例如精度转换的"
"额外开销。有关更多信息，请参阅目标架构的文档。在许多情况下，移动驱动程序会导"
"致不一致或意外的行为，除非必要，否则最好避免指定精度。"

msgid "Arrays"
msgstr "数组"

msgid "Arrays are containers for multiple variables of a similar type."
msgstr "数组是用于多个相似类型的变量的容器。"

msgid "Local arrays"
msgstr "局部数组"

msgid ""
"Local arrays are declared in functions. They can use all of the allowed "
"datatypes, except samplers. The array declaration follows a C-style syntax: "
"``[const] + [precision] + typename + identifier + [array size]``."
msgstr ""
"局部数组在函数中声明。它们可以使用除采样器之外的所有允许的数据类型。数组声明"
"遵循 C 样式语法：\\ ``[const] + [precision] + typename + identifier + [array "
"size]``\\ 。"

msgid "They can be initialized at the beginning like:"
msgstr "它们可以在开始时被初始化，像这样："

msgid ""
"You can declare multiple arrays (even with different sizes) in one "
"expression:"
msgstr "你可以在一个表达式中声明多个数组（即使大小不同）："

msgid "To access an array element, use the indexing syntax:"
msgstr "要访问一个数组元素，请使用索引语法："

msgid ""
"Arrays also have a built-in function ``.length()`` (not to be confused with "
"the built-in ``length()`` function). It doesn't accept any parameters and "
"will return the array's size."
msgstr ""
"数组还有一个内置函数 ``.length()``\\ （不要与内置函数 ``length()`` 混淆）。它"
"不接受任何参数，并将返回数组的大小。"

msgid ""
"If you use an index either below 0 or greater than array size - the shader "
"will crash and break rendering. To prevent this, use ``length()``, ``if``, "
"or ``clamp()`` functions to ensure the index is between 0 and the array's "
"length. Always carefully test and check your code. If you pass a constant "
"expression or a number, the editor will check its bounds to prevent this "
"crash."
msgstr ""
"如果你使用的索引小于 0 或大于数组大小——着色器将崩溃并中断渲染。为防止这种情"
"况，请使用 ``length()``\\ 、\\ ``if`` 或 ``clamp()`` 函数来确保索引介于 0 和"
"数组长度之间。务必仔细测试和检查你的代码。如果你传递一个常量表达式或数字，编"
"辑器将检查其边界以防止这种崩溃。"

msgid "Global arrays"
msgstr "全局数组"

msgid ""
"You can declare arrays in global space as either ``const`` or ``uniform``:"
msgstr "你可以在全局作用域中将数组声明为 ``const`` 或 ``uniform``\\："

msgid ""
"Global arrays use the same syntax as local arrays, except with a ``const`` "
"or ``uniform`` added to their declaration. Note that uniform arrays can't "
"have a default value."
msgstr ""
"全局数组的语法与局部数组相同，只是在声明时需要添加 ``const`` 或 "
"``uniform``\\。注意，uniform 数组不能有默认值。"

msgid "Constants"
msgstr "常量"

msgid ""
"Use the ``const`` keyword before the variable declaration to make that "
"variable immutable, which means that it cannot be modified. All basic types, "
"except samplers can be declared as constants. Accessing and using a constant "
"value is slightly faster than using a uniform. Constants must be initialized "
"at their declaration."
msgstr ""
"在变量声明前使用 ``const`` 关键字，可以使该变量不可变， 这意味着它不能被修"
"改。除采样器外的所有基本类型都可以被声明为常量。访问和使用常量值的速度比使用 "
"uniform 的速度略快。常量必须在其声明时被初始化。"

msgid ""
"Constants cannot be modified and additionally cannot have hints, but "
"multiple of them (if they have the same type) can be declared in a single "
"expression e.g"
msgstr ""
"常量不能被修改，也不能有提示，但可以在单个表达式中声明多个常量（如果它们具有"
"相同的类型），例如"

msgid "Similar to variables, arrays can also be declared with ``const``."
msgstr "与变量类似，数组也可以用 ``const`` 来声明。"

msgid ""
"Constants can be declared both globally (outside of any function) or locally "
"(inside a function). Global constants are useful when you want to have "
"access to a value throughout your shader that does not need to be modified. "
"Like uniforms, global constants are shared between all shader stages, but "
"they are not accessible outside of the shader."
msgstr ""
"常量既可以被全局声明（在任何函数之外），也可以被本地声明（在函数内部）。当你"
"想要访问整个着色器中不需要修改的值时，全局常量非常有用。与 uniform 一样，全局"
"常量在所有着色器阶段之间共享，但在着色器外部无法访问。"

msgid ""
"Constants of the ``float`` type must be initialized using ``.`` notation "
"after the decimal part or by using the scientific notation. The optional "
"``f`` post-suffix is also supported."
msgstr ""
"``float`` 类型常量的初始化必须使用整数部分后的 ``.`` 符号或科学计数法。还支持"
"可选的 ``f`` 后缀。"

msgid ""
"Constants of the ``uint`` (unsigned int) type must have a ``u`` suffix to "
"differentiate them from signed integers. Alternatively, this can be done by "
"using the ``uint(x)`` built-in conversion function."
msgstr ""
"``uint``\\ （无符号整数）类型的常量必须有后缀 ``u``\\ ，以区别于有符号整数。"
"或者，也可以使用 ``uint(x)`` 内置转换函数来实现这一点。"

msgid "Structs"
msgstr "结构体"

msgid ""
"Structs are compound types which can be used for better abstraction of "
"shader code. You can declare them at the global scope like:"
msgstr ""
"结构体是一种复合类型，可以对着色器代码进行更好的抽象。你可以在全局范围内声明"
"它们，如下所示："

msgid "After declaration, you can instantiate and initialize them like:"
msgstr "声明后，你可以像这样实例化和初始化它们："

msgid "Or use struct constructor for same purpose:"
msgstr "或者使用结构体的构造函数达到同样的效果："

msgid ""
"Structs may contain other struct or array, you can also instance them as "
"global constant:"
msgstr "结构体中可以包含其他结构体或者数组，你还可以把它们作为全局常量实例化："

msgid "You can also pass them to functions:"
msgstr "也可以把它们传递给函数："

msgid "Operators"
msgstr "运算符"

msgid ""
"Godot shading language supports the same set of operators as GLSL ES 3.0. "
"Below is the list of them in precedence order:"
msgstr ""
"Godot 着色语言支持与 GLSL ES 3.0 相同的运算符集。以下是按优先顺序列出的运算符"
"列表："

msgid "Precedence"
msgstr "优先级"

msgid "Class"
msgstr "类"

msgid "Operator"
msgstr "运算符"

msgid "1 (highest)"
msgstr "1（最高）"

msgid "parenthetical grouping"
msgstr "括号分组"

msgid "**()**"
msgstr "**()**"

msgid "2"
msgstr "2"

msgid "unary"
msgstr "一元"

msgid "**+, -, !, ~**"
msgstr "**+, -, !, ~**"

msgid "3"
msgstr "3"

msgid "multiplicative"
msgstr "乘除余"

msgid "**/, \\*, %**"
msgstr "**/, \\*, %**"

msgid "4"
msgstr "4"

msgid "additive"
msgstr "加减法"

msgid "**+, -**"
msgstr "**+, -**"

msgid "5"
msgstr "5"

msgid "bit-wise shift"
msgstr "按位移位"

msgid "**<<, >>**"
msgstr "**<<, >>**"

msgid "6"
msgstr "6"

msgid "relational"
msgstr "关系比较"

msgid "**<, >, <=, >=**"
msgstr "**<, >, <=, >=**"

msgid "7"
msgstr "7"

msgid "equality"
msgstr "相等比较"

msgid "**==, !=**"
msgstr "**==, !=**"

msgid "8"
msgstr "8"

msgid "bit-wise AND"
msgstr "按位与"

msgid "**&**"
msgstr "**&**"

msgid "9"
msgstr "9"

msgid "bit-wise exclusive OR"
msgstr "按位异或"

msgid "**^**"
msgstr "**^**"

msgid "10"
msgstr "10"

msgid "bit-wise inclusive OR"
msgstr "按位或"

msgid "**|**"
msgstr "**|**"

msgid "11"
msgstr "11"

msgid "logical AND"
msgstr "逻辑与"

msgid "**&&**"
msgstr "**&&**"

msgid "12 (lowest)"
msgstr "12（最低）"

msgid "logical inclusive OR"
msgstr "逻辑或"

msgid "**||**"
msgstr "**||**"

msgid "Operation"
msgstr "运算"

msgid "Equivalent Scalar Operation"
msgstr "等价标量运算"

msgid "``vec3(4, 5, 6) + 2``"
msgstr "``vec3(4, 5, 6) + 2``"

msgid "``vec3(4 + 2, 5 + 2, 6 + 2)``"
msgstr "``vec3(4 + 2, 5 + 2, 6 + 2)``"

msgid "``vec2(3, 4) * vec2(10, 20)``"
msgstr "``vec2(3, 4) * vec2(10, 20)``"

msgid "``vec2(3 * 10, 4 * 20)``"
msgstr "``vec2(3 * 10, 4 * 20)``"

msgid "``mat2(vec2(1, 2), vec2(3, 4)) + 10``"
msgstr "``mat2(vec2(1, 2), vec2(3, 4)) + 10``"

msgid "``mat2(vec2(1 + 10, 2 + 10), vec2(3 + 10, 4 + 10))``"
msgstr "``mat2(vec2(1 + 10, 2 + 10), vec2(3 + 10, 4 + 10))``"

msgid "Flow control"
msgstr "控制流"

msgid "Godot Shading language supports the most common types of flow control:"
msgstr "Godot 着色语言支持最常见的控制流类型："

msgid ""
"Keep in mind that in modern GPUs, an infinite loop can exist and can freeze "
"your application (including editor). Godot can't protect you from this, so "
"be careful not to make this mistake!"
msgstr ""
"请记住，在现代 GPU 中，无限循环可以存在，并可能冻结你的应用程序（包括编辑"
"器）。Godot 无法保护你免受这种影响，因此请小心，不要犯这种错误！"

msgid ""
"Also, when comparing floating-point values against a number, make sure to "
"compare them against a *range* instead of an exact number."
msgstr ""
"此外，将浮点值与数字进行比较时，请确保将它们与一个\\ *范围*\\ 而不是一个精确"
"数字进行比较。"

msgid ""
"A comparison like ``if (value == 0.3)`` may not evaluate to ``true``. "
"Floating-point math is often approximate and can defy expectations. It can "
"also behave differently depending on the hardware."
msgstr ""
"类似 ``if (value == 0.3)`` 的比较可能不会评估为 ``true``\\ 。浮点数学通常是近"
"似的，可能会与预期不符。它还可能根据硬件的不同而表现不同。"

msgid "**Don't** do this."
msgstr "**不要**\\ 这样做。"

msgid ""
"Instead, always perform a range comparison with an epsilon value. The larger "
"the floating-point number (and the less precise the floating-point number), "
"the larger the epsilon value should be."
msgstr ""
"相反，始终使用 epsilon 值进行范围比较。浮点数越大（浮点数越不精确），则 "
"epsilon 值应该越大。"

msgid ""
"See `floating-point-gui.de <https://floating-point-gui.de/>`__ for more "
"information."
msgstr ""
"有关更多信息，请参阅 `floating-point-gui.de <https://floating-point-gui.de/"
">`__\\ 。"

msgid "Discarding"
msgstr "丢弃"

msgid ""
"Fragment, light, and custom functions (called from fragment or light) can "
"use the ``discard`` keyword. If used, the fragment is discarded and nothing "
"is written."
msgstr ""
"片段函数、光照函数以及自定义函数（从片段或光照中调用）可使用 ``discard`` 关键"
"字。若使用该关键字，则丢弃当前片段且不写入任何数据。"

msgid ""
"Beware that ``discard`` has a performance cost when used, as it will prevent "
"the depth prepass from being effective on any surfaces using the shader. "
"Also, a discarded pixel still needs to be rendered in the vertex shader, "
"which means a shader that uses ``discard`` on all of its pixels is still "
"more expensive to render compared to not rendering any object in the first "
"place."
msgstr ""
"请注意，使用 ``discard`` 会降低性能，因为它会阻止预深度阶段在使用着色器的任何"
"表面上起作用。此外，被丢弃的像素仍需在顶点着色器中渲染，这意味着，与一开始就"
"不渲染任何对象相比，在所有像素上使用 ``discard`` 的着色器的渲染成本仍然更高。"

msgid "Functions"
msgstr "函数"

msgid ""
"It is possible to define functions in a Godot shader. They use the following "
"syntax:"
msgstr "可以在 Godot 着色器中定义函数。它们使用以下语法："

msgid ""
"You can only use functions that have been defined above (higher in the "
"editor) the function from which you are calling them. Redefining a function "
"that has already been defined above (or is a built-in function name) will "
"cause an error."
msgstr ""
"你只能使用已在调用它们的函数上方（编辑器中较高位置）定义的函数。重新定义已在"
"上方定义的函数（或使用内置函数名称）将导致错误。"

msgid "Function arguments can have special qualifiers:"
msgstr "函数参数可以有特殊的限定符："

msgid "**in**: Means the argument is only for reading (default)."
msgstr "**in**\\ ：表示该参数仅供读取（默认）。"

msgid "**out**: Means the argument is only for writing."
msgstr "**out**\\ ：表示该参数仅供写入。"

msgid "**inout**: Means the argument is fully passed via reference."
msgstr "**inout**\\ ：表示参数完全通过引用传递。"

msgid ""
"**const**: Means the argument is a constant and cannot be changed, may be "
"combined with **in** qualifier."
msgstr "**const**\\ ：表示参数是常量且不能更改，可以与 **in** 限定符结合使用。"

msgid "Example below:"
msgstr "以下为示例："

msgid "Varyings"
msgstr "Varying"

msgid ""
"To send data from the vertex to the fragment (or light) processor function, "
"*varyings* are used. They are set for every primitive vertex in the *vertex "
"processor*, and the value is interpolated for every pixel in the *fragment "
"processor*."
msgstr ""
"要从顶点处理器函数往片段（或者灯光）处理器函数里发送数据，可以使用 "
"*varying*\\ 。它们在\\ *顶点处理器*\\ 中为每个图元顶点设置，并且该值对\\ *片"
"段处理器*\\ 中的每个像素进行插值。"

msgid "Varying can also be an array:"
msgstr "Varying 也可以是一个数组："

msgid ""
"It's also possible to send data from *fragment* to *light* processors using "
"*varying* keyword. To do so you can assign it in the *fragment* and later "
"use it in the *light* function."
msgstr ""
"也可以使用 *varying* 关键字将数据从\\ *片段*\\ 处理器发送到\\ *灯光*\\ 处理"
"器。在\\ *片段*\\ 函数中赋值，然后在\\ *灯光*\\ 函数中使用即可。"

msgid ""
"Note that varying may not be assigned in custom functions or a *light "
"processor* function like:"
msgstr ""
"请注意，在自定义函数或\\ *灯光处理器*\\ 函数中可能无法为 varying 赋值，例如："

msgid ""
"This limitation was introduced to prevent incorrect usage before "
"initialization."
msgstr "加入这一限制的目的是为了防止在初始化前进行错误的使用。"

msgid "Interpolation qualifiers"
msgstr "插值限定符"

msgid ""
"Certain values are interpolated during the shading pipeline. You can modify "
"how these interpolations are done by using *interpolation qualifiers*."
msgstr ""
"某些值在着色管道期间进行插值。你可以使用\\ *插值限定符*\\ 来修改这些插值的方"
"式。"

msgid "There are two possible interpolation qualifiers:"
msgstr "有两种可能的插值限定符："

msgid "Qualifier"
msgstr "限定符"

msgid "**flat**"
msgstr "**flat**"

msgid "The value is not interpolated."
msgstr "该值未插值。"

msgid "**smooth**"
msgstr "**smooth**"

msgid ""
"The value is interpolated in a perspective-correct fashion. This is the "
"default."
msgstr "该值以透视校正方式进行插值。这是默认值。"

msgid "Uniforms"
msgstr "Uniform"

msgid "Uniform hints"
msgstr "Uniform 提示"

msgid ""
"Godot provides optional uniform hints to make the compiler understand what "
"the uniform is used for, and how the editor should allow users to modify it."
msgstr ""
"Godot 提供了可选的 uniform 提示，用于让编译器理解 uniform 的用途，以及编辑器"
"应如何允许用户修改它。"

msgid "Uniforms can also be assigned default values:"
msgstr "Uniform 也可以分配默认值："

msgid ""
"Note that when adding a default value and a hint, the default value goes "
"after the hint."
msgstr "请注意，同时添加默认值和提示时，默认值应该写在提示的后面。"

msgid "Full list of uniform hints below:"
msgstr "以下是完整的提示列表："

msgid "Hint"
msgstr "提示"

msgid "**vec3, vec4**"
msgstr "**vec3、vec4**"

msgid "source_color"
msgstr "source_color"

msgid "Used as color."
msgstr "用作颜色。"

msgid "hint_enum(\"String1\", \"String2\")"
msgstr "hint_enum(\"String1\", \"String2\")"

msgid "**int, float**"
msgstr "**int、float**"

msgid "hint_range(min, max[, step])"
msgstr "hint_range(min, max[, step])"

msgid "Restricted to values in a range (with min/max/step)."
msgstr "限制取值范围（最小值/最大值/步长）。"

msgid "Used as albedo color."
msgstr "用作反照颜色。"

msgid "hint_normal"
msgstr "hint_normal"

msgid "Used as normalmap."
msgstr "用作法线贴图。"

msgid "hint_default_white"
msgstr "hint_default_white"

msgid "As value or albedo color, default to opaque white."
msgstr "作为值或反照颜色，默认为不透明白色。"

msgid "hint_default_black"
msgstr "hint_default_black"

msgid "As value or albedo color, default to opaque black."
msgstr "作为值或反照颜色，默认为不透明黑色。"

msgid "hint_default_transparent"
msgstr "hint_default_transparent"

msgid "As value or albedo color, default to transparent black."
msgstr "作为值或反照颜色，默认为透明黑色。"

msgid "hint_anisotropy"
msgstr "hint_anisotropy"

msgid "As flowmap, default to right."
msgstr "作为 FlowMap，默认为右。"

msgid "hint_roughness[_r, _g, _b, _a, _normal, _gray]"
msgstr "hint_roughness[_r, _g, _b, _a, _normal, _gray]"

msgid ""
"Used for roughness limiter on import (attempts reducing specular aliasing). "
"``_normal`` is a normal map that guides the roughness limiter, with "
"roughness increasing in areas that have high-frequency detail."
msgstr ""
"用于导入时的粗糙度限制器（尝试减少镜面锯齿）。\\ ``_normal``\\ 是引导粗糙度限"
"制器的法线贴图，在具有高频细节的区域中粗糙度会增加。"

msgid "filter[_nearest, _linear][_mipmap][_anisotropic]"
msgstr "filter[_nearest, _linear][_mipmap][_anisotropic]"

msgid "Enabled specified texture filtering."
msgstr "启用指定的纹理过滤。"

msgid "repeat[_enable, _disable]"
msgstr "repeat[_enable, _disable]"

msgid "Enabled texture repeating."
msgstr "启用纹理重复。"

msgid "hint_screen_texture"
msgstr "hint_screen_texture"

msgid "Texture is the screen texture."
msgstr "纹理是屏幕纹理。"

msgid "hint_depth_texture"
msgstr "hint_depth_texture"

msgid "Texture is the depth texture."
msgstr "纹理是深度纹理。"

msgid "hint_normal_roughness_texture"
msgstr "hint_normal_roughness_texture"

msgid "Texture is the normal roughness texture (only supported in Forward+)."
msgstr "纹理是法线粗糙度纹理（仅在 Forward+ 中受支持）。"

msgid "You can close the group by using:"
msgstr "结束分组的方法是："

msgid ""
"The syntax also supports subgroups (it's not mandatory to declare the base "
"group before this):"
msgstr "这一语法还支持子分组（在此之前不需要声明基础分组）："

msgid "Global uniforms"
msgstr "全局 Uniform"

msgid ""
"Sometimes, you want to modify a parameter in many different shaders at once. "
"With a regular uniform, this takes a lot of work as all these shaders need "
"to be tracked and the uniform needs to be set for each of them. Global "
"uniforms allow you to create and update uniforms that will be available in "
"all shaders, in every shader type (``canvas_item``, ``spatial``, "
"``particles``, ``sky`` and ``fog``)."
msgstr ""
"有时你会想要统一修改很多不同着色器中的某个参数。使用普通的 uniform 就会很麻"
"烦，因为你需要记录这些着色器，并且需要一个个地设 uniform。使用全局 uniform 就"
"可以创建并更新所有着色器中均可以使用的 uniform，所有类型的着色器都适用（\\ "
"``canvas_item``\\ 、\\ ``spatial``\\ 、\\ ``particles``\\ 、\\ ``sky``\\ 、"
"\\ ``fog``\\ ）。"

msgid ""
"Global uniforms are especially useful for environmental effects that affect "
"many objects in a scene, like having foliage bend when the player is nearby, "
"or having objects move with the wind."
msgstr ""
"全局 uniform 适用于能够影响场景中大量对象的环境效果，例如玩家在附近时的植被弯"
"曲效果、物体随风移动的效果等。"

msgid ""
"To create a global uniform, open the **Project Settings** then go to the "
"**Shader Globals** tab. Specify a name for the uniform (case-sensitive) and "
"a type, then click **Add** in the top-right corner of the dialog. You can "
"then edit the value assigned to the uniform by clicking the value in the "
"list of uniforms:"
msgstr ""
"要创建全局 uniform，请打开\\ **项目设置**\\ ，切换到\\ **着色器全局量**\\ 选"
"项卡。为 uniform 指定名称（区分大小写）和类型，然后点击对话框右上角的\\ **添"
"加**\\ 。点击 uniform 列表中的值即可编辑 uniform 的取值："

msgid ""
"Adding a global uniform in the Shader Globals tab of the Project Settings"
msgstr "在“项目设置”的“着色器全局量”中添加全局 uniform"

msgid "After creating a global uniform, you can use it in a shader as follows:"
msgstr "创建全局 uniform 之后，在着色器中的使用方法如下："

msgid ""
"Note that the global uniform *must* exist in the Project Settings at the "
"time the shader is saved, or compilation will fail. While you can assign a "
"default value using ``global uniform vec4 my_color = ...`` in the shader "
"code, it will be ignored as the global uniform must always be defined in the "
"Project Settings anyway."
msgstr ""
"请注意，保存着色器的时候该全局 uniform *必须*\\ 在“项目设置”中存在，否则编译"
"就会失败。虽然可以在着色器代码中使用 ``global uniform vec4 my_color = ...`` "
"赋默认值，但是这个默认值会被忽略，因为全局 uniform 必须在“项目设置”中定义。"

msgid ""
"Assigning global uniform values can be done as many times as desired without "
"impacting performance, as setting data doesn't require synchronization "
"between the CPU and GPU."
msgstr ""
"全局 uniform 可以重复赋值，不会影响性能，因为设置数据不需要在 CPU 和 GPU 之间"
"进行同步。"

msgid ""
"Therefore, it's not recommended to read global shader uniform values "
"continuously in a script. If you need to read values in a script after "
"setting them, consider creating an :ref:`autoload <doc_singletons_autoload>` "
"where you store the values you need to query at the same time you're setting "
"them as global uniforms."
msgstr ""
"因此，不建议在脚本中频繁读取全局着色器 uniform 的取值。如果你需要在设值之后用"
"脚本读取，请考虑创建一个\\ :ref:`自动加载 <doc_singletons_autoload>`\\ ，在设"
"置需要查询的全局 uniform 的同时保存对应的值。"

msgid "Per-instance uniforms"
msgstr "单实例 uniform"

msgid ""
"Per-instance uniforms are set on each GeometryInstance3D, rather than on "
"each Material instance. Take this into account when working with meshes that "
"have multiple materials assigned to them, or MultiMesh setups."
msgstr ""
"单实例 uniform 设置在每个 GeometryInstance3D 上，而不是在每个材质实例上。在处"
"理指定了多种材质的网格或多重网格设置时，请考虑这一点。"

msgid ""
"After saving the shader, you can change the per-instance uniform's value "
"using the inspector:"
msgstr "在保存着色器后，你可以在检查器中更改单实例 uniform 的值："

msgid ""
"Setting a per-instance uniform's value in the GeometryInstance3D section of "
"the inspector"
msgstr "在检查器中的 GeometryInstance3D 部分设置单实例 uniform 的值"

msgid ""
"When using per-instance uniforms, there are some restrictions you should be "
"aware of:"
msgstr "在使用单实例 uniform 时，你应该注意一些限制："

msgid ""
"**Per-instance uniforms do not support textures**, only regular scalar and "
"vector types. As a workaround, you can pass a texture array as a regular "
"uniform, then pass the index of the texture to be drawn using a per-instance "
"uniform."
msgstr ""
"**单实例 uniform 不支持纹理**\\ ，仅可以是常规的标量和向量类型。作为解决方"
"法，你可以传递一个纹理数组作为常规 uniform，之后传递一个单实例 uniform 作为绘"
"制时纹理的索引。"

msgid ""
"GDScript uses different variable types than GLSL does, so when passing "
"variables from GDScript to shaders, Godot converts the type automatically. "
"Below is a table of the corresponding types:"
msgstr ""
"GDScript 使用的变量类型与 GLSL 不同，所以当把变量从 GDScript 传递到着色器时，"
"Godot 会自动转换类型。以下是相应类型的表格："

msgid "GLSL type"
msgstr "GLSL 类型"

msgid "GDScript type"
msgstr "GDScript 类型"

msgid "Notes"
msgstr "注意"

msgid "Bitwise packed int where bit 0 (LSB) corresponds to x."
msgstr "按位打包整数，其中位 0 (LSB) 对应 x。"

msgid "For example, a bvec2 of (bx, by) could be created in the following way:"
msgstr "例如，值为 (bx, by) 的 bvec2 可以按以下方式创建："

msgid "**Vector2i**"
msgstr "**Vector2i**"

msgid "**Vector3i**"
msgstr "**Vector3i**"

msgid "**Vector4i**"
msgstr "**Vector4i**"

msgid "**Vector2**"
msgstr "**Vector2**"

msgid "**Vector3**, **Color**"
msgstr "**Vector3**\\ 、\\ **Color**"

msgid "When Color is used, it will be interpreted as (r, g, b)."
msgstr "使用 Color 时会将其解释为 (r, g, b)。"

msgid "**Vector4**, **Color**, **Rect2**, **Plane**, **Quaternion**"
msgstr ""
"**Vector4**\\ 、\\ **Color**\\ 、\\ **Rect2**\\ 、\\ **Plane**\\ 、\\ "
"**Quaternion**"

msgid "When Color is used, it will be interpreted as (r, g, b, a)."
msgstr "使用 Color 时会将其解释为 (r, g, b, a)。"

msgid ""
"When Rect2 is used, it will be interpreted as (position.x, position.y, "
"size.x, size.y)."
msgstr "使用 Rect2 时会将其解释为 (position.x, position.y, size.x, size.y)。"

msgid ""
"When Plane is used it will be interpreted as (normal.x, normal.y, normal.z, "
"d)."
msgstr "使用 Plane 时会将其解释为 (normal.x, normal.y, normal.z, d)。"

msgid "**Transform2D**"
msgstr "**Transform2D**"

msgid "**Basis**"
msgstr "**Basis**"

msgid "**Projection**, **Transform3D**"
msgstr "**Projection**\\ 、\\ **Transform3D**"

msgid "When a Transform3D is used, the w Vector is set to the identity."
msgstr "使用 Transform3D 时，向量 w 为单位向量。"

msgid "**Texture2D**"
msgstr "**Texture2D**"

msgid "**Texture2DArray**"
msgstr "**Texture2DArray**"

msgid "**Texture3D**"
msgstr "**Texture3D**"

msgid "**Cubemap**"
msgstr "**Cubemap**"

msgid "**CubemapArray**"
msgstr "**CubemapArray**"

msgid "Built-in variables"
msgstr "内置变量"

msgid ":ref:`Spatial shaders <doc_spatial_shader>`"
msgstr ":ref:`空间着色器 <doc_spatial_shader>`"

msgid ":ref:`Canvas item shaders <doc_canvas_item_shader>`"
msgstr ":ref:`画布物品着色器 <doc_canvas_item_shader>`"

msgid ":ref:`Particle shaders <doc_particle_shader>`"
msgstr ":ref:`粒子着色器 <doc_particle_shader>`"

msgid ":ref:`Sky shaders <doc_sky_shader>`"
msgstr ":ref:`天空着色器 <doc_sky_shader>`"

msgid ":ref:`Fog shaders <doc_fog_shader>`"
msgstr ":ref:`雾效着色器 <doc_fog_shader>`"

msgid "Built-in functions"
msgstr "内置函数"
