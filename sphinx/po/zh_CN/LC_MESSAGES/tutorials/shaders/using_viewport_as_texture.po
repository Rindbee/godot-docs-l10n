#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using a SubViewport as a texture"
msgstr "使用 SubViewport 作为纹理"

msgid "Introduction"
msgstr "前言"

msgid ""
"This tutorial does not cover how to code a dynamic atmosphere like the one "
"this planet has."
msgstr "本教程没有介绍如何编写像这个星球那样的动态氛围."

msgid "In this tutorial, we'll cover the following topics:"
msgstr "在本教程中, 我们将介绍以下主题:"

msgid "How to use a :ref:`SubViewport <class_SubViewport>` as a render texture"
msgstr "如何使用 :ref:`SubViewport <class_SubViewport>` 作为渲染纹理"

msgid "Mapping a texture to a sphere with equirectangular mapping"
msgstr "使用 equirectangular 映射将纹理映射到球体"

msgid "Fragment shader techniques for procedural planets"
msgstr "程序式行星的片段着色器技术"

msgid ""
"Setting a Roughness map from a :ref:`Viewport Texture "
"<class_ViewportTexture>`"
msgstr "从\\ :ref:`视口纹理 <class_ViewportTexture>`\\ 设置粗糙度贴图"

msgid "Setting up the scene"
msgstr "设置场景"

msgid "Setting up the SubViewport"
msgstr "设置 SubViewport"

msgid ""
"Next, we add a :ref:`Shader Material <class_ShaderMaterial>` to the :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."
msgstr ""
"接下来, 我们为 :ref:`Shader Material <class_ShaderMaterial>` 添加一个 :ref:"
"`ColorRect <class_ColorRect>` (ColorRect > CanvasItem > Material > Material "
"> ``New ShaderMaterial``)."

msgid ""
"Basic familiarity with shading is recommended for this tutorial. However, "
"even if you are new to shaders, all the code will be provided, so you should "
"have no problem following along."
msgstr ""
"建议本教程基本了解阴影. 但是, 即使你不熟悉着色器, 也将提供所有代码, 因此后续"
"操作应该没有问题."

msgid "Applying the texture"
msgstr "应用纹理"

msgid ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``New "
"StandardMaterial3D``"
msgstr ""
"MeshInstance3D > GeometryInstance > Geometry > Material Override > ``新建 "
"StandardMaterial3D``"

msgid "Then click the dropdown for the StandardMaterial3D and click \"Edit\""
msgstr "然后点开 StandardMaterial3D 的下拉菜单，点击“编辑”"

msgid ""
"Go to the \"Resource\" section and check the ``Local to scene`` box. Then, "
"go to the \"Albedo\" section and click beside the \"Texture\" property to "
"add an Albedo Texture. Here we will apply the texture we made. Choose \"New "
"ViewportTexture\""
msgstr ""
"找到“Resource”部分并勾选 ``Local to scene`` 复选框。然后找到“Albedo”部分，"
"在“Texture”属性旁单击，添加反照率纹理。这里我们要使用自己创建的纹理，请选"
"择“新建 ViewportTexture”"

msgid ""
"Click on the ViewportTexture you just created in the inspector, then click "
"\"Assign\". Then, from the menu that pops up, select the Viewport that we "
"rendered to earlier."
msgstr ""
"在检查器中点击刚才创建的 ViewportTexture，然后点击“分配”。接下来，在弹出的菜"
"单中选择之前用于渲染的 Viewport。"

msgid ""
"Your sphere should now be colored in with the colors we rendered to the "
"Viewport."
msgstr "现在, 你的球体应使用我们渲染到视口的颜色进行着色."

msgid ""
"Notice the ugly seam that forms where the texture wraps around? This is "
"because we are picking a color based on UV coordinates and UV coordinates do "
"not wrap around the texture. This is a classic problem in 2D map projection. "
"Game developers often have a 2-dimensional map they want to project onto a "
"sphere, but when it wraps around, it has large seams. There is an elegant "
"workaround for this problem that we will illustrate in the next section."
msgstr ""
"注意到在纹理环绕的地方形成的丑陋缝隙吗？这是因为我们是根据UV坐标来选取颜色"
"的, 而UV坐标并不会环绕纹理. 这是二维地图投影中的一个典型问题. 游戏开发人员通"
"常有一个二维贴图, 他们想投射到一个球体上, 但是当它环绕时, 将有接缝. 这个问题"
"有一个优雅的解决方法, 我们将在下一节中说明."

msgid "Making the planet texture"
msgstr "制作行星纹理"

msgid ""
"So now, when we render to our :ref:`SubViewport <class_SubViewport>`, it "
"appears magically on the sphere. But there is an ugly seam created by our "
"texture coordinates. So how do we get a range of coordinates that wrap "
"around the sphere in a nice way? One solution is to use a function that "
"repeats on the domain of our texture. ``sin`` and ``cos`` are two such "
"functions. Let's apply them to the texture and see what happens. Replace the "
"existing color code in the shader with the following:"
msgstr ""
"那么现在我们往 :ref:`SubViewport <class_SubViewport>` 里渲染的东西就会神奇地"
"出现在球体上。不过由于纹理坐标的原因，球体上会存在一条很丑的缝隙，我们该如何"
"让坐标优雅地环绕球体呢？一种解决方法是使用在纹理域内重复的函数，比如 ``sin`` "
"和 ``cos``\\ 。让我们把它们应用到纹理上，看看会发生什么。请将着色器中的已有颜"
"色代码替换成下面的内容："

msgid ""
"Not too bad. If you look around, you can see that the seam has now "
"disappeared, but in its place, we have pinching at the poles. This pinching "
"is due to the way Godot maps textures to spheres in its :ref:"
"`StandardMaterial3D <class_StandardMaterial3D>`. It uses a projection "
"technique called equirectangular projection, which translates a spherical "
"map onto a 2D plane."
msgstr ""
"还凑合吧。现在球体的四周就再也看不到缝隙了，不过取而代之的是两个极点的地方会"
"有收缩的现象。这种收缩的现象是 Godot 使用 :ref:`StandardMaterial3D "
"<class_StandardMaterial3D>` 将纹理映射到球体表面的方式造成的。这里使用的是一"
"种叫做“等距柱状投影”的将球面图形转化为 2D 平面的技术。"

msgid ""
"If you are interested in a little extra information on the technique, we "
"will be converting from spherical coordinates into Cartesian coordinates. "
"Spherical coordinates map the longitude and latitude of the sphere, while "
"Cartesian coordinates are, for all intents and purposes, a vector from the "
"center of the sphere to the point."
msgstr ""
"如果你对技术方面的一些额外信息感兴趣，我们将从球面坐标转换为直角坐标。球面坐"
"标映射的是球体的经度和纬度，而直角坐标则是从球体中心到点的一个向量。"

msgid "And if we use ``unit`` as an output ``COLOR`` value, we get:"
msgstr "如果我们使用 ``unit`` 作为输出 ``COLOR`` 值, 我们可以得到:"

msgid ""
"Now that we can calculate the 3D position of the surface of the sphere, we "
"can use 3D noise to make the planet. We will be using this noise function "
"directly from a `Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_:"
msgstr ""
"现在我们可以计算出球体表面的3D位置, 可以使用3D噪声来制作球体. 直接从 "
"`Shadertoy <https://www.shadertoy.com/view/Xsl3Dl>`_ 中使用这个噪声函数:"

msgid ""
"All credit goes to the author, Inigo Quilez. It is published under the "
"``MIT`` licence."
msgstr "所有功劳归作者Inigo Quilez所有. 它是在 ``MIT`` 许可下发布的."

msgid ""
"Now to use ``noise``, add the following to the    ``fragment`` function:"
msgstr "现在使用 ``noised`` , 将以下内容添加到 ``fragment`` 函数中:"

msgid "In order to highlight the texture, we set the material to unshaded."
msgstr "为了突出显示纹理, 我们将材质设置为无阴影."

msgid ""
"You can see now that the noise indeed wraps seamlessly around the sphere. "
"Although this looks nothing like the planet you were promised. So let's move "
"onto something more colorful."
msgstr ""
"你现在可以看到, 尽管这看起来完全不像所承诺的球体, 但噪音确实无缝地包裹着球"
"体. 对此, 让我们进入一些更丰富多彩的东西."

msgid "Coloring the planet"
msgstr "着色这个星球"

msgid ""
"Now to make the planet colors. While there are many ways to do this, for "
"now, we will stick with a gradient between water and land."
msgstr ""
"现在来制作行星的颜色. 虽然有很多方法可以做到这一点, 但目前, 我们将使用水和陆"
"地之间的梯度."

msgid ""
"To make a gradient in GLSL, we use the ``mix`` function. ``mix`` takes two "
"values to interpolate between and a third argument to choose how much to "
"interpolate between them; in essence, it *mixes* the two values together. In "
"other APIs, this function is often called ``lerp``. However, ``lerp`` is "
"typically reserved for mixing two floats together; ``mix`` can take any "
"values whether it be floats or vector types."
msgstr ""
"要在 GLSL 中创建渐变, 我们使用 ``mix`` 函数. ``mix`` 需要两个值来插值和第三个"
"参数来选择在它们之间插入多少, 实质上它将两个值 *混合* 在一起. 在其他API中, 此"
"函数通常称为 ``lerp`` . 虽然 ``lerp`` 通常用于将两个浮点数混合在一起, 但 "
"``mix`` 可以取任何值, 无论它是浮点数还是向量类型."

msgid ""
"The first color is blue for the ocean. The second color is a kind of reddish "
"color (because all alien planets need red terrain). And finally, they are "
"mixed together by ``n * 0.5 + 0.5``. ``n`` smoothly varies between ``-1`` "
"and ``1``. So we map it into the ``0-1`` range that ``mix`` expects. Now you "
"can see that the colors change between blue and red."
msgstr ""
"第一种颜色是蓝色, 代表海洋. 第二种颜色是一种偏红的颜色, 因为所有外星球都需要"
"红色的地形. 最后, 它们 ``n * 0.5 + 0.5`` 混合在一起. ``n`` 在 ``-1`` 和 "
"``1`` 之间平滑变化. 所以我们把它映射到 ``mix`` 预期的 ``0-1`` 范围内. 现在你"
"可以看到, 颜色在蓝色和红色之间变化."

msgid ""
"That is a little more blurry than we want. Planets typically have a "
"relatively clear separation between land and sea. In order to do that, we "
"will change the last term to ``smoothstep(-0.1, 0.0, n)``. And thus the "
"whole line becomes:"
msgstr ""
"这比我们想要的还要模糊一些. 行星通常在陆地和海洋之间有一个相对清晰的分隔. 为"
"了做到这一点, 我们将把最后一项改为 ``smoothstep(-0.1, 0.0, n)`` . 整条线就变"
"成了这样:"

msgid ""
"What ``smoothstep`` does is return ``0`` if the third argument is below the "
"first and ``1`` if the third argument is larger than the second and smoothly "
"blends between ``0`` and ``1`` if the third number is between the first and "
"the second. So in this line, ``smoothstep`` returns ``0`` whenever ``n`` is "
"less than ``-0.1`` and it returns ``1`` whenever ``n`` is above ``0``."
msgstr ""
"``smoothstep`` 所做的是, 如果第三个参数低于第一个参数, 则返回 ``0`` , 如果第"
"三个参数大于第二个参数, 则返回 ``1`` , 如果第三个数字在第一个和第二个之间, 则"
"在 ``0`` 和 ``1`` 之间平滑地混合. 所以在这一行中, 当 ``n`` 小于 ``-0.1`` 时, "
"``smoothstep`` 返回 ``0`` , 当 ``n`` 高于 ``0`` 时, 它返回 ``1`` ."

msgid ""
"One more thing to make this a little more planet-y. The land shouldn't be so "
"blobby; let's make the edges a little rougher. A trick that is often used in "
"shaders to make rough looking terrain with noise is to layer levels of noise "
"over one another at various frequencies. We use one layer to make the "
"overall blobby structure of the continents. Then another layer breaks up the "
"edges a bit, and then another, and so on. What we will do is calculate ``n`` "
"with four lines of shader code instead of just one. ``n`` becomes:"
msgstr ""
"还有一件事, 使其更像一个行星. 这片土地不应该是圆球状的；让我们把边缘变得更粗"
"糙一些. 在着色器中经常使用的一个技巧是在不同的频率下将不同层次的噪声叠加在一"
"起, 使地形看起来粗糙. 我们使用一个层来制作大陆的整体球状结构. 然后, 另一层将"
"边缘打碎, 然后是另一层, 以此类推. 我们要做的是用四行着色器代码来计算 ``n`` , "
"而不是只有一行. ``n`` 变成了:"

msgid "And now the planet looks like:"
msgstr "现在这个星球看起来像:"

msgid "Making an ocean"
msgstr "制作海洋"

msgid ""
"One final thing to make this look more like a planet. The ocean and the land "
"reflect light differently. So we want the ocean to shine a little more than "
"the land. We can do this by passing a fourth value into the ``alpha`` "
"channel of our output ``COLOR`` and using it as a Roughness map."
msgstr ""
"让这个看起来更像是一颗行星的最后一件事. 海洋和陆地以不同的方式反射光线. 因"
"此, 我们希望海洋比陆地更加闪耀. 我们可以通过将第四个值传递到输出 ``COLOR`` "
"的 ``alpha`` 通道并将其用作粗糙度图来实现."

msgid ""
"This line returns ``0.3`` for water and ``1.0`` for land. This means that "
"the land is going to be quite rough, while the water will be quite smooth."
msgstr ""
"该行对于水返回 ``0.3`` , 对于土地返回 ``1.0`` . 这意味着土地将变得很粗糙, 而"
"水将变得非常光滑."

msgid ""
"And then, in the material, under the \"Metallic\" section, make sure "
"``Metallic`` is set to ``0`` and ``Specular`` is set to ``1``. The reason "
"for this is the water reflects light really well, but isn't metallic. These "
"values are not physically accurate, but they are good enough for this demo."
msgstr ""
"然后，在材质中，在“Metallic”（金属性）部分，请确保 ``Metallic`` 为 "
"``0``\\ 、\\ ``Specular`` 为 ``1``\\ 。这样做的原因是水对光线的反射非常好，但"
"它不是金属的。这些值在物理上并不准确，但对于这个演示来说已经足够好了。"

msgid ""
"This pre-multiplies the colors by the ``alpha`` value and then blends them "
"correctly together. Typically, when blending one transparent color on top of "
"another, even if the background has an ``alpha`` of ``0`` (as it does in "
"this case), you end up with weird color bleed issues. Setting "
"``blend_premul_alpha`` fixes that."
msgstr ""
"这是将颜色预先乘以 ``alpha`` 值, 然后将它们正确地混合在一起. 通常情况下, 当在"
"一个透明的颜色上混合另一个颜色时, 即使背景的 ``alpha`` 为 ``0`` (如本例), 也"
"会出现奇怪的颜色渗漏问题. 设置 ``blend_premul_alpha`` 可以解决这个问题."
