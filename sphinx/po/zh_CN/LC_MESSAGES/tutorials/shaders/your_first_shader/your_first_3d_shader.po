#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "你的第一个 3D 着色器"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你已经决定开始编写一个自定义 Spatial 着色器。或许你在网上看到一个很酷的着色器"
"技巧，或许你发现 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 并不能"
"完全满足你的需求。总之，你决定写一个自己的，你想弄清楚从哪里开始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"这个教程将说明如何编写空间着色器, 并将涵盖比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 更多的主题."

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"空间着色器比CanvasItem着色器有更多的内置功能. 对空间着色器的期望是:Godot为常"
"见的用例提供了功能, 用户仅需在着色器中设置适当的参数. 这对于PBR(基于物理的渲"
"染)工作流来说尤其如此."

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In the :ref:"
"`second part <doc_your_second_spatial_shader>` we will take the concepts "
"from this tutorial and set up custom materials in a fragment shader by "
"writing an ocean water shader."
msgstr ""
"这个教程分为两个部分。在第一部分中，我们会使用在 vertex 函数中根据高度图进行"
"顶点位移，从而制作地形。在\\ :ref:`第二部分 "
"<doc_your_second_spatial_shader>`\\ 中，我们会使用这个脚本中涉及的概念在片断"
"着色器中设置自定义材质，编写海洋水体着色器。"

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"这个教程假定你对着色器中的类型（\\ ``vec2``\\ 、\\ ``float``\\ 、\\ "
"``sampler2D``\\ ）和函数等基础知识有一定的了解。如果你对这些概念摸不着头脑，"
"那么在完成这个教程之前，你最好先从\\ `《着色器之书》 <https://"
"thebookofshaders.com/?lan=ch>`\\ 获取一些基本知识。"

msgid "Where to assign my material"
msgstr "在何处设定材质"

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或网格本身上设置了材质，那么所有共享该网格的 MeshInstance3D 都共"
"享该材质。但是如果你想在多个网格实例中重用同一个网格，而每个实例又要具有不同"
"的材质，那么你就应该在 MeshInstance3D 上设置材质。"

msgid "Setting up"
msgstr "设置"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "向场景添加一个新的 :ref:`MeshInstance3D <class_MeshInstance3D>` 节点。"

msgid ""
"In the inspector tab beside \"Mesh\" click \"[empty]\" and select \"New "
"PlaneMesh\". Then click on the image of a plane that appears."
msgstr ""
"在检查器选项卡中，点击“Mesh”旁边的“[空]”，然后选择“新建 PlaneMesh”。然后点击"
"出现的平面的图像。"

msgid "This adds a :ref:`PlaneMesh <class_planemesh>` to our scene."
msgstr "这会在场景中添加一个 :ref:`PlaneMesh <class_planemesh>` ."

msgid ""
"Then, in the viewport, click in the upper left corner on the button that "
"says \"Perspective\". A menu will appear. In the middle of the menu are "
"options for how to display the scene. Select 'Display Wireframe'."
msgstr ""
"然后，在视图中，单击左上角的“透视”按钮。会出现一个菜单，在菜单中间找到如何显"
"示场景的选项。选择“显示线框”。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "这将允许你查看构成平面的三角形."

msgid ""
"Now set ``Subdivide Width`` and ``Subdivide Depth`` of the :ref:`PlaneMesh "
"<class_planemesh>` to ``32``."
msgstr ""
"现在将 :ref:`PlaneMesh <class_planemesh>` 的 ``Subdivide Width`` 和 "
"``Subdivide Depth`` 设置为 ``32``\\ 。"

msgid ""
"Now click beside \"Shader\" where it says \"[empty]\" and select \"New "
"Shader\"."
msgstr "现在点击“Shader”旁边写着“[空]”的地方，选择“新建 Shader”。"

msgid ""
"The shader editor should now pop up and you are ready to begin writing your "
"first Spatial shader!"
msgstr "现在将弹出一个着色器编辑器, 你已经准备好编写你的第一个空间着色器了！"

msgid "Shader magic"
msgstr "着色器魔术"

msgid "We define the vertex shader like so:"
msgstr "我们像这样定义顶点着色器:"

msgid ""
"With nothing in the ``vertex()`` function, Godot will use its default vertex "
"shader. We can easily start to make changes by adding a single line:"
msgstr ""
"在 ``vertex()`` 函数中没有任何内容,Godot将使用其默认的顶点着色器. 我们可以简"
"单地通过添加一行进行更改:"

msgid "Adding this line, you should get an image like the one below."
msgstr "添加此行后, 你应该会得到类似下方的图像."

msgid ""
"Okay, let's unpack this. The ``y`` value of the ``VERTEX`` is being "
"increased. And we are passing the ``x`` and ``z`` components of the "
"``VERTEX`` as arguments to ``cos`` and ``sin``; that gives us a wave-like "
"appearance across the ``x`` and ``z`` axes."
msgstr ""
"好, 我们来解读一下. ``VERTEX`` 的 ``y`` 值正在增加. 我们将 ``VERTEX`` 的 "
"``x`` 和 ``z`` 分量作为参数传递给 ``cos`` 和 ``sin`` ；这样就得到了在 ``x`` "
"和 ``z`` 轴上呈现出波浪状的图像."

msgid ""
"What we want to achieve is the look of little hills; after all. ``cos`` and "
"``sin`` already look kind of like hills. We do so by scaling the inputs to "
"the ``cos`` and ``sin`` functions."
msgstr ""
"我们想要实现的是小山丘的外观. 而 ``cos`` 和 ``sin`` 已经有点像山丘了. 我们便"
"可以通过缩放 ``cos`` 和 ``sin`` 函数的输入来实现."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "看起来效果好了一些, 但它仍然过于尖锐和重复, 让我们把它变得更有趣一点."

msgid "Noise heightmap"
msgstr "噪声高度图"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"噪声是一种非常流行的伪造地形的工具. 可以认为它和余弦函数一样生成重复的小山, "
"只是在噪声的影响下每个小山都拥有不同的高度."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"要在着色器中访问纹理，请在着色器顶部附近、\\ ``vertex()`` 函数外部添加以下代"
"码。"

msgid ""
"This will allow you to send a noise texture to the shader. Now look in the "
"inspector under your material. You should see a section called \"Shader "
"Params\". If you open it up, you'll see a section called \"noise\"."
msgstr ""
"你可以用它将噪声纹理发送给着色器。现在看看检查器中的材质。你应该会看到一个名"
"为“Shader Params”（着色器参数）的区域。如果展开该区域，就会看到一个"
"叫“noise”的部分。"

msgid ""
":ref:`FastNoiseLite <class_fastnoiselite>` is used by the NoiseTexture2D to "
"generate a heightmap."
msgstr ""
"NoiseTexture2D 使用 :ref:`FastNoiseLite <class_fastnoiselite>` 来生成高度图。"

msgid "Once you set it up and should look like this."
msgstr "设置好后, 看起来应该像这样."

msgid ""
"Note: ``xyzw`` is the same as ``rgba`` in GLSL, so instead of ``texture()."
"x`` above, we could use ``texture().r``. See the `OpenGL documentation "
"<https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ for more "
"details."
msgstr ""
"注意: ``xyzw`` 和GLSL中的 ``rgba`` 是相同的, 所以我们可以用 ``texture().x`` "
"代替上面的 ``texture().r`` . 详情请参见 `OpenGL 文档 <https://www.khronos."
"org/opengl/wiki/Data_Type_(GLSL)#Vectors>`_ ."

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用此代码后, 你可以看到纹理创建了随机外观的山峰."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前它还很尖锐, 我们需要稍微柔化一下山峰. 这将用到uniform值. 你在之前已经使用"
"了uniform 值来传递噪声纹理, 现在让我们来学习一下其中的工作原理."

msgid "Uniforms"
msgstr "Uniform"

msgid ""
"Uniform variables allow you to pass data from the game into the shader. They "
"are very useful for controlling shader effects. Uniforms can be almost any "
"datatype that can be used in the shader. To use a uniform, you declare it in "
"your :ref:`Shader<class_Shader>` using the keyword ``uniform``."
msgstr ""
"uniform值变量允许你把游戏的变量传递到着色器. 它们对于控制着色器效果非常有用. "
"几乎所有在着色器中使用的数据类型都可以作为uniform值. 要使用uniform值, 请在 :"
"ref:`Shader<class_Shader>` 中使用关键字 ``uniform`` 声明它."

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "让我们做一个改变地形高度的uniform."

msgid "Now it looks much better."
msgstr "现在它看起来好多了."

msgid "Interacting with light"
msgstr "与光交互"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"注意网格颜色是如何变得平滑的. 这是因为它的光线是平滑的. 让我们加一盏灯吧!"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你会看到光线影响了地形, 但这看起来很奇怪. 问题是光线对地形的影响就像在平面上"
"一样. 这是因为光着色器使用 :ref:`网格 <class_mesh>` 中的法线来计算光."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法线存储在网格中, 但是我们在着色器中改变网格的形状, 所以法线不再正确. 为了解"
"决这个问题, 我们可以在着色器中重新计算法线, 或者使用与我们的噪声相对应的法线"
"纹理.Godot让这一切变得很简单."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"你可以在顶点函数中手动计算新的法线，然后只需设置法线 ``NORMAL``\\ 。设置好 "
"``NORMAL`` 后，Godot 将为我们完成所有困难的光照计算。我们将在本教程的下一部分"
"介绍这种方法，现在我们将从纹理中读取法线。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"相反, 我们将再次依靠噪声来计算法线. 我们通过传入第二个噪声纹理来做到这一点."

msgid ""
"Now, because this is a normalmap and not a per-vertex normal, we are going "
"to assign it in the ``fragment()`` function. The ``fragment()`` function "
"will be explained in more detail in the next part of this tutorial."
msgstr ""
"现在, 因为这是一个法线贴图, 而不是每个顶点的法线, 我们将在 ``fragment()`` 函"
"数中分配它. ``fragment()`` 函数将在本教程的下一部分中详细解释."

msgid ""
"Lastly, in order to ensure that we are reading from the same places on the "
"noise texture and the normalmap texture, we are going to pass the ``VERTEX."
"xz`` position from the ``vertex()`` function to the ``fragment()`` function. "
"We do that with varyings."
msgstr ""
"最后, 为了确保我们从噪声纹理和法线图纹理的相同位置读取数据, 我们将把 "
"``vertex()`` 函数中的 ``VERTEX.xz`` 坐标传递给 ``fragment()`` 函数. 我们用"
"variings来做这个."

msgid ""
"Above the ``vertex()`` define a ``vec2`` called ``tex_position``. And inside "
"the ``vertex()`` function assign ``VERTEX.xz`` to ``tex_position``."
msgstr ""
"在 ``vertex()`` 上面定义一个 ``vec2`` 叫做 ``tex_position`` . 在 "
"``vertex()`` 函数中, 将 ``VERTEX.xz`` 分配给 ``tex_position`` ."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "现在我们可以从 ``fragment()`` 函数中访问 ``tex_position`` ."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法线就位后, 光线就会对网格的高度做出动态反应."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "我们甚至可以把灯拖来拖去, 灯光会自动更新."

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教程的完整代码. 你可以看到,Godot会为你处理大多数繁琐的事情, 本教程篇"
"幅不会太长."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"这就是这部分的全部内容. 希望你现在已了解Godot中顶点着色器的基本知识. 在本教程"
"的下一部分中, 我们将编写一个片段函数来配合这个顶点函数, 并且我们将介绍一种更"
"高级的技术来将这个地形转换成一个移动的波浪海洋."
