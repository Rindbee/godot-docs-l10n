#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Your first 3D shader"
msgstr "你的第一个 3D 着色器"

msgid ""
"You have decided to start writing your own custom Spatial shader. Maybe you "
"saw a cool trick online that was done with shaders, or you have found that "
"the :ref:`StandardMaterial3D <class_StandardMaterial3D>` isn't quite meeting "
"your needs. Either way, you have decided to write your own and now you need "
"to figure out where to start."
msgstr ""
"你已经决定开始编写一个自定义 Spatial 着色器。或许你在网上看到一个很酷的着色器"
"技巧，或许你发现 :ref:`StandardMaterial3D <class_StandardMaterial3D>` 并不能"
"完全满足你的需求。总之，你决定写一个自己的，你想弄清楚从哪里开始。"

msgid ""
"This tutorial will explain how to write a Spatial shader and will cover more "
"topics than the :ref:`CanvasItem <doc_your_first_canvasitem_shader>` "
"tutorial."
msgstr ""
"这个教程将说明如何编写 Spatial 着色器，并将涵盖比 :ref:`CanvasItem "
"<doc_your_first_canvasitem_shader>` 更多的主题。"

msgid ""
"Spatial shaders have more built-in functionality than CanvasItem shaders. "
"The expectation with spatial shaders is that Godot has already provided the "
"functionality for common use cases and all the user needs to do in the "
"shader is set the proper parameters. This is especially true for a PBR "
"(physically based rendering) workflow."
msgstr ""
"Spatial 着色器相比 CanvasItem 着色器内置了更多功能。其设计思路是，由 Godot 为"
"常见用例提供现成功能，用户只需在着色器中设置合适的参数即可。这一点在 PBR（基"
"于物理的渲染）工作流中尤为明显。"

msgid ""
"This is a two-part tutorial. In this first part we will create terrain using "
"vertex displacement from a heightmap in the vertex function. In "
"the :ref:`second part <doc_your_second_spatial_shader>` we will take the "
"concepts from this tutorial and set up custom materials in a fragment shader "
"by writing an ocean water shader."
msgstr ""
"这个教程分为两个部分。在第一部分中，我们会使用在 vertex 函数中根据高度图进行"
"顶点位移，从而制作地形。在\\ :ref:`第二部分 "
"<doc_your_second_spatial_shader>`\\ 中，我们会使用这个脚本中涉及的概念在片段"
"着色器中设置自定义材质，编写海洋水体着色器。"

msgid ""
"This tutorial assumes some basic shader knowledge such as types (``vec2``, "
"``float``, ``sampler2D``), and functions. If you are uncomfortable with "
"these concepts it is best to get a gentle introduction from `The Book of "
"Shaders <https://thebookofshaders.com>`_ before completing this tutorial."
msgstr ""
"这个教程假定你对着色器中的类型（\\ ``vec2``\\ 、\\ ``float``\\ 、\\ "
"``sampler2D``\\ ）和函数等基础知识有一定的了解。如果你对这些概念摸不着头脑，"
"那么在完成这个教程之前，你最好先从\\ `《着色器之书》 <https://"
"thebookofshaders.com/?lan=ch>`_\\ 获取一些基本知识。"

msgid "Where to assign my material"
msgstr "在何处设置我的材质"

msgid ""
"In 3D, objects are drawn using :ref:`Meshes <class_Mesh>`. Meshes are a "
"resource type that store geometry (the shape of your object) and materials "
"(the color and how the object reacts to light) in units called \"surfaces\". "
"A Mesh can have multiple surfaces, or just one. Typically, you would import "
"a mesh from another program (e.g. Blender). But Godot also has a "
"few :ref:`PrimitiveMeshes <class_primitivemesh>` that allow you to add basic "
"geometry to a scene without importing Meshes."
msgstr ""
"在 3D 中，物体是使用 :ref:`Meshes（网格） <class_Mesh>` 来绘制的。网格是一种"
"资源类型，它以称为“表面（surfaces）”的单元来存储几何体（物体的形状）和材质"
"（颜色以及物体对光的反应）。一个网格可以拥有多个表面，也可以只有一个。通常，"
"你会从其他程序（例如 Blender）中导入网格。但 Godot 也提供了一"
"些 :ref:`PrimitiveMeshes <class_primitivemesh>` ，允许你无需导入网格即可向场"
"景中添加基础几何体。"

msgid ""
"There are multiple node types that you can use to draw a mesh. The main one "
"is :ref:`MeshInstance3D <class_MeshInstance3D>`, but you can also "
"use :ref:`GPUParticles3D <class_GPUParticles3D>`, :ref:`MultiMeshes "
"<class_MultiMesh>` (with a :ref:`MultiMeshInstance3D "
"<class_MultiMeshInstance3D>`), or others."
msgstr ""
"你可以使用多种节点类型来绘制网格。其中最主要的是 :ref:`MeshInstance3D "
"<class_MeshInstance3D>` ，但你也可以使用 :ref:`GPUParticles3D "
"<class_GPUParticles3D>` 、:ref:`MultiMeshes <class_MultiMesh>` （需配"
"合 :ref:`MultiMeshInstance3D <class_MultiMeshInstance3D>` 使用）或其他节点类"
"型。"

msgid ""
"Typically, a material is associated with a given surface in a mesh, but some "
"nodes, like MeshInstance3D, allow you to override the material for a "
"specific surface, or for all surfaces."
msgstr ""
"通常，材质会与网格中的某个给定表面关联，但有些节点，例如 MeshInstance3D，允许"
"你覆写特定表面或所有表面的材质。"

msgid ""
"If you set a material on the surface or mesh itself, then all "
"MeshInstance3Ds that share that mesh will share that material. However, if "
"you want to reuse the same mesh across multiple mesh instances, but have "
"different materials for each instance then you should set the material on "
"the MeshInstance3D."
msgstr ""
"如果你在表面或网格本身上设置了材质，那么所有共享该网格的 MeshInstance3D 都共"
"享该材质。但是如果你想在多个网格实例中重用同一个网格，而每个实例又要具有不同"
"的材质，那么你就应该在 MeshInstance3D 上设置材质。"

msgid ""
"For this tutorial we will set our material on the mesh itself rather than "
"taking advantage of the MeshInstance3D's ability to override materials."
msgstr ""
"在本教程中，我们将把材质直接设置于网格本身，而非利用 MeshInstance3D 可覆盖材"
"质的功能。"

msgid "Setting up"
msgstr "设置"

msgid ""
"Add a new :ref:`MeshInstance3D <class_MeshInstance3D>` node to your scene."
msgstr "向场景添加一个新的 :ref:`MeshInstance3D <class_MeshInstance3D>` 节点。"

msgid "This will allow you to see the triangles making up the plane."
msgstr "这将允许你查看构成平面的三角形."

msgid ""
"Materials that inherit from the :ref:`class_Material` resource, such "
"as :ref:`class_StandardMaterial3D` and :ref:`class_ParticleProcessMaterial`, "
"can be converted to a :ref:`class_ShaderMaterial` and their existing "
"properties will be converted to an accompanying text shader. To do so, right-"
"click on the material in the FileSystem dock and choose **Convert to "
"ShaderMaterial**. You can also do so by right-clicking on any property "
"holding a reference to the material in the inspector."
msgstr ""
"继承自 :ref:`class_Material` 资源的材质，例"
"如 :ref:`class_StandardMaterial3D` 和 :ref:`class_ParticleProcessMaterial`，"
"可以转换为 :ref:`class_ShaderMaterial`，并且它们现有的属性将被转换为附带的文"
"本着色器。要执行此操作，请在文件系统面板中右键单击材质并选择**转换为 "
"ShaderMaterial**。你也可以通过在检查器中右键单击任何持有材质引用的属性来完成"
"此操作。"

msgid "Shader magic"
msgstr "着色器魔术"

msgid "Adding this line, you should get an image like the one below."
msgstr "添加此行后, 你应该会得到类似下方的图像."

msgid ""
"This looks better, but it is still too spiky and repetitive, let's make it a "
"little more interesting."
msgstr "看起来效果好了一些, 但它仍然过于尖锐和重复, 让我们把它变得更有趣一点."

msgid "Noise heightmap"
msgstr "噪声高度图"

msgid ""
"Noise is a very popular tool for faking the look of terrain. Think of it as "
"similar to the cosine function where you have repeating hills except, with "
"noise, each hill has a different height."
msgstr ""
"噪声是一种非常流行的伪造地形的工具. 可以认为它和余弦函数一样生成重复的小山, "
"只是在噪声的影响下每个小山都拥有不同的高度."

msgid ""
"To access a texture in a shader add the following code near the top of your "
"shader, outside the ``vertex()`` function."
msgstr ""
"要在着色器中访问纹理，请在着色器顶部附近、\\ ``vertex()`` 函数外部添加以下代"
"码。"

msgid "Once you set it up and should look like this."
msgstr "设置好后, 看起来应该像这样."

msgid "Using this code you can see the texture creates random looking hills."
msgstr "使用此代码后, 你可以看到纹理创建了随机外观的山峰."

msgid ""
"Right now it is too spiky, we want to soften the hills a bit. To do that, we "
"will use a uniform. You already used a uniform above to pass in the noise "
"texture, now let's learn how they work."
msgstr ""
"目前它还很尖锐, 我们需要稍微柔化一下山峰. 这将用到uniform值. 你在之前已经使用"
"了uniform 值来传递噪声纹理, 现在让我们来学习一下其中的工作原理."

msgid "Uniforms"
msgstr "Uniform"

msgid "Let's make a uniform that changes the height of the terrain."
msgstr "让我们做一个改变地形高度的uniform."

msgid "Now it looks much better."
msgstr "现在它看起来好多了."

msgid "Interacting with light"
msgstr "与光交互"

msgid ""
"Note how the mesh color goes flat. This is because the lighting on it is "
"flat. Let's add a light!"
msgstr ""
"注意网格颜色是如何变得平滑的. 这是因为它的光线是平滑的. 让我们加一盏灯吧!"

msgid ""
"You can see the light affecting the terrain, but it looks odd. The problem "
"is the light is affecting the terrain as if it were a flat plane. This is "
"because the light shader uses the normals from the :ref:`Mesh <class_mesh>` "
"to calculate light."
msgstr ""
"你会看到光线影响了地形, 但这看起来很奇怪. 问题是光线对地形的影响就像在平面上"
"一样. 这是因为光着色器使用 :ref:`网格 <class_mesh>` 中的法线来计算光."

msgid ""
"The normals are stored in the Mesh, but we are changing the shape of the "
"Mesh in the shader, so the normals are no longer correct. To fix this, we "
"can recalculate the normals in the shader or use a normal texture that "
"corresponds to our noise. Godot makes both easy for us."
msgstr ""
"法线存储在网格中, 但是我们在着色器中改变网格的形状, 所以法线不再正确. 为了解"
"决这个问题, 我们可以在着色器中重新计算法线, 或者使用与我们的噪声相对应的法线"
"纹理.Godot让这一切变得很简单."

msgid ""
"You can calculate the new normal manually in the vertex function and then "
"just set ``NORMAL``. With ``NORMAL`` set, Godot will do all the difficult "
"lighting calculations for us. We will cover this method in the next part of "
"this tutorial, for now we will read normals from a texture."
msgstr ""
"你可以在顶点函数中手动计算新的法线，然后只需设置法线 ``NORMAL``\\ 。设置好 "
"``NORMAL`` 后，Godot 将为我们完成所有困难的光照计算。我们将在本教程的下一部分"
"介绍这种方法，现在我们将从纹理中读取法线。"

msgid ""
"Instead we will rely on the NoiseTexture again to calculate normals for us. "
"We do that by passing in a second noise texture."
msgstr ""
"相反, 我们将再次依靠噪声来计算法线. 我们通过传入第二个噪声纹理来做到这一点."

msgid ""
"And now we can access ``tex_position`` from the ``fragment()`` function."
msgstr "现在我们可以从 ``fragment()`` 函数中访问 ``tex_position`` ."

msgid ""
"With the normals in place the light now reacts to the height of the mesh "
"dynamically."
msgstr "法线就位后, 光线就会对网格的高度做出动态反应."

msgid ""
"We can even drag the light around and the lighting will update automatically."
msgstr "我们甚至可以把灯拖来拖去, 灯光会自动更新."

msgid "Full code"
msgstr "完整代码"

msgid ""
"Here is the full code for this tutorial. You can see it is not very long as "
"Godot handles most of the difficult stuff for you."
msgstr ""
"以下是本教程的完整代码. 你可以看到,Godot会为你处理大多数繁琐的事情, 本教程篇"
"幅不会太长."

msgid ""
"That is everything for this part. Hopefully, you now understand the basics "
"of vertex shaders in Godot. In the next part of this tutorial we will write "
"a fragment function to accompany this vertex function and we will cover a "
"more advanced technique to turn this terrain into an ocean of moving waves."
msgstr ""
"这就是这部分的全部内容. 希望你现在已了解Godot中顶点着色器的基本知识. 在本教程"
"的下一部分中, 我们将编写一个片段函数来配合这个顶点函数, 并且我们将介绍一种更"
"高级的技术来将这个地形转换成一个移动的波浪海洋."
