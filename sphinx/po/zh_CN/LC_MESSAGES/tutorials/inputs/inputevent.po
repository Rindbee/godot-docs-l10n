#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using InputEvent"
msgstr "使用 InputEvent"

msgid "What is it?"
msgstr "这是什么？"

msgid ""
"Managing input is usually complex, no matter the OS or platform. To ease "
"this a little, a special built-in type is provided, :ref:`InputEvent "
"<class_InputEvent>`. This datatype can be configured to contain several "
"types of input events. Input events travel through the engine and can be "
"received in multiple locations, depending on the purpose."
msgstr ""
"无论操作系统或平台如何，管理输入通常很复杂。为了稍微简化这一点，引擎提供了一"
"种特殊的内置类型 :ref:`InputEvent <class_InputEvent>`\\ 。该数据类型可以被配"
"置为包含几种类型的输入事件。输入事件通过引擎传播，并可以根据目的在多个位置接"
"收。"

msgid "Here is a quick example, closing your game if the escape key is hit:"
msgstr "这里有一个简单的示例，按下 ESC 键时关闭你的游戏："

msgid ""
"However, it is cleaner and more flexible to use the provided :ref:`InputMap "
"<class_InputMap>` feature, which allows you to define input actions and "
"assign them different keys. This way, you can define multiple keys for the "
"same action (e.g. the keyboard escape key and the start button on a "
"gamepad). You can then more easily change this mapping in the project "
"settings without updating your code, and even build a key mapping feature on "
"top of it to allow your game to change the key mapping at runtime!"
msgstr ""
"但是，使用提供的 :ref:`InputMap <class_InputMap>` 功能将更简洁灵活，它允许你"
"定义输入操作并为其分配不同的键。这样，你可以为同一动作定义多个键（例如键盘上"
"的退出键和游戏手柄上的开始按钮）。然后，你可以更轻松地在项目设置中更改该映"
"射，而无需更新代码，甚至可以在其上构建一个键映射功能，以允许你的游戏在运行时"
"更改键映射！"

msgid ""
"You can set up your InputMap under **Project > Project Settings > Input "
"Map** and then use those actions like this:"
msgstr ""
"你可以在\\ **项目 > 项目设置 > 按键映射**\\ 下设置你的输入映射，这些动作的使"
"用方法如下："

msgid "How does it work?"
msgstr "工作原理是怎样的？"

msgid ""
"Every input event is originated from the user/player (though it's possible "
"to generate an InputEvent and feed them back to the engine, which is useful "
"for gestures). The DisplayServer for each platform will read events from the "
"operating system, then feed them to the root :ref:`Window <class_Window>`."
msgstr ""
"每个输入事件都来源于用户/玩家（虽然也可以自己生成 InputEvent 并提供给引擎，多"
"用于手势）。各个平台的 DisplayServer 都会从操作系统读取事件，然后提供给"
"根 :ref:`Window <class_Window>`\\ 。"

msgid ""
"The window's :ref:`Viewport <class_Viewport>` does quite a lot of stuff with "
"the received input, in order:"
msgstr ""
"窗口的 :ref:`Viewport <class_Viewport>` 会对收到的输入进行很多处理，依次为："

msgid ""
"If the Viewport is embedding Windows, the Viewport tries to interpret the "
"event in its capability as a Window-Manager (e.g. for resizing or moving "
"Windows)."
msgstr ""
"如果该 Viewport 内嵌了 Window，则该 Viewport 会尝试以窗口管理器的身份解释事件"
"（例如对 Window 进行大小调整和移动）。"

msgid ""
"First of all, the standard :ref:`Node._input() "
"<class_Node_private_method__input>` function will be called in any node that "
"overrides it (and hasn't disabled input processing "
"with :ref:`Node.set_process_input() <class_Node_method_set_process_input>`). "
"If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. This ensures that you can filter all events of interest, even "
"before the GUI. For gameplay input, :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` is generally a better fit, "
"because it allows the GUI to intercept the events."
msgstr ""
"首先会调用标准的 :ref:`Node._input() <class_Node_private_method__input>` 函"
"数，调用只会发生在覆盖了这个函数（并且输入处理没有通"
"过 :ref:`Node.set_process_input() <class_Node_method_set_process_input>` 禁"
"用）的节点上。如果某个函数消耗了该事件，可以调"
"用 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`\\ ，事件就不会再继续传播。这样"
"就确保你可以在 GUI 之前过滤自己感兴趣的事件。对于游戏输入，"
"\\ :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` 通常更合适，因为这个函数能够让 "
"GUI 拦截事件。"

msgid ""
"Second, it will try to feed the input to the GUI, and see if any control can "
"receive it. If so, the :ref:`Control <class_Control>` will be called via the "
"virtual function :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` and the signal \"gui_input\" will "
"be emitted (this function is re-implementable by script by inheriting from "
"it). If the control wants to \"consume\" the event, it will "
"call :ref:`Control.accept_event() <class_Control_method_accept_event>` and "
"the event will not spread any more. Use the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` property to control whether "
"a :ref:`Control <class_Control>` is notified of mouse events "
"via :ref:`Control._gui_input() <class_Control_private_method__gui_input>` "
"callback, and whether these events are propagated further."
msgstr ""
"然后，它会尝试将输入提供给 GUI，并查看是否有控件可以接收它。如果有，"
"该 :ref:`Control <class_Control>` 将通过虚函数 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` 被调用并发出“gui_input”信号（此函"
"数可通过继承它的脚本重新实现）。如果该控件想“消耗”该事件，它将调"
"用 :ref:`Control.accept_event() <class_Control_method_accept_event>` 阻止事件"
"的传播。请使用 :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` 属性来控制 :ref:`Control "
"<class_Control>` 是否通过 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>` 回调接收鼠标事件的通知，以及是否进"
"一步传播这些事件。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>`). This happens only "
"for :ref:`InputEventKey <class_InputEventKey>`, :ref:`InputEventShortcut "
"<class_InputEventShortcut>` and :ref:`InputEventJoypadButton "
"<class_InputEventJoypadButton>`. If any function consumes the event, it can "
"call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The shortcut input callback is ideal for treating events that are "
"intended as shortcuts."
msgstr ""
"如果事件到目前为止还没有被消耗，并且覆盖了 :ref:`Node._shortcut_input() "
"<class_Node_private_method__shortcut_input>` 函数（并且没有通"
"过 :ref:`Node.set_process_shortcut_input() "
"<class_Node_method_set_process_shortcut_input>` 禁用），那么就会调用这个回"
"调。只有 :ref:`InputEventKey <class_InputEventKey>`\\ 、"
"\\ :ref:`InputEventShortcut <class_InputEventShortcut>` "
"和 :ref:`InputEventJoypadButton <class_InputEventJoypadButton>` 才会如此。如"
"果某个函数消耗了该事件，它可以调用 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`\\ ，那么事件就不会再继续传播。"
"快捷键输入回调主要用于处理快捷键相关的事件。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` callback will be called if "
"overridden (and not disabled "
"with :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>`). This happens only if "
"the event is an :ref:`InputEventKey <class_InputEventKey>`. If any function "
"consumes the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled key input callback is ideal for key events."
msgstr ""
"如果事件到目前为止还没有被消耗，并且 :ref:`Node._unhandled_key_input() "
"<class_Node_private_method__unhandled_key_input>` 函数已被覆盖（并且没有通"
"过 :ref:`Node.set_process_unhandled_key_input() "
"<class_Node_method_set_process_unhandled_key_input>` 禁用），那么该回调将被调"
"用。仅当事件是 :ref:`InputEventKey <class_InputEventKey>` 时才会如此。如果某"
"个函数消耗了该事件，它可以调用 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`\\ ，事件就不会再继续传播。未处"
"理按键输入回调主要用于处理按键相关的事件。"

msgid ""
"If so far no one consumed the event, the :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` callback will be called if "
"overridden (and not disabled with :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>`). If any function consumes "
"the event, it can call :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`, and the event will not spread "
"any more. The unhandled input callback is ideal for full-screen gameplay "
"events, so they are not received when a GUI is active."
msgstr ""
"如果事件到目前为止还没有被消耗，并且覆盖了 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` 函数（并且没有通"
"过 :ref:`Node.set_process_unhandled_input() "
"<class_Node_method_set_process_unhandled_input>` 禁用），那么就会调用这个回"
"调。如果某个函数消耗了该事件，它可以调"
"用 :ref:`Viewport.set_input_as_handled() "
"<class_Viewport_method_set_input_as_handled>`\\ ，事件就不会再继续传播。未处"
"理输入回调主要用于处理全屏游戏事件，因此 GUI 处于活动状态时不会收到。"

msgid ""
"If no one wanted the event so far, and :ref:`Object Picking "
"<class_viewport_property_physics_object_picking>` is turned on, the event is "
"used for object picking. For the root viewport, this can also be enabled "
"in :ref:`Project Settings <class_ProjectSettings_property_physics/common/"
"enable_object_picking>`. In the case of a 3D scene if a :ref:`Camera3D "
"<class_Camera3D>` is assigned to the Viewport, a ray to the physics world "
"(in the ray direction from the click) will be cast. If this ray hits an "
"object, it will call the :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` function in the "
"relevant physics object. In the case of a 2D scene, conceptually the same "
"happens with :ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>`."
msgstr ""
"如果到目前为止没有节点想要该事件，并且\\ :ref:`对象拾取 "
"<class_viewport_property_physics_object_picking>`\\ 已打开，则该事件将用于对"
"象拾取。对于根视口，也可以在\\ :ref:`项目设置 "
"<class_ProjectSettings_property_physics/common/enable_object_picking>`\\ 中启"
"用该设置。在 3D 场景的情况下，如果将 :ref:`Camera3D <class_Camera3D>` 分配给"
"该 Viewport，则会向物理世界投射一条射线（以从点击开始的射线方向）。如果该射线"
"击中物体，它将调用相关物理对象中的 :ref:`CollisionObject3D._input_event() "
"<class_CollisionObject3D_private_method__input_event>` 函数。对于 2D 场景，从"
"概念上讲，:ref:`CollisionObject2D._input_event() "
"<class_CollisionObject2D_private_method__input_event>` 也会发生同样的情况。"

msgid ""
"When sending events to its child and descendant nodes, the viewport will do "
"so, as depicted in the following graphic, in a reverse depth-first order, "
"starting with the node at the bottom of the scene tree, and ending at the "
"root node. Excluded from this process are Windows and SubViewports."
msgstr ""
"视口会向子孙节点发送事件，如下图所示，发送时会按照逆深度优先顺序进行，从场景"
"树最底部的节点开始，到根节点结束。这个过程中会跳过 Window 和 SubViewport。"

msgid ""
"This order doesn't apply to :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`, which uses a different method "
"based on event location or focused Control. GUI **mouse** events also travel "
"up the scene tree, subject to the :ref:`Control.mouse_filter "
"<class_Control_property_mouse_filter>` restrictions described above. "
"However, since these events target specific Controls, only direct ancestors "
"of the targeted Control node receive the event. GUI **keyboard and joypad** "
"events *do not* travel up the scene tree, and can only be handled by the "
"Control that received them. Otherwise, they will be propagated as non-GUI "
"events through :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>`."
msgstr ""
"该顺序不适用于 :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`\\ ，它使用的方法不同，基于事件位置"
"或聚焦的 Control。GUI **鼠标**\\ 事件也会沿场景树向上传播，受上"
"述 :ref:`Control.mouse_filter <class_Control_property_mouse_filter>` 限制的约"
"束。不过由于这些事件针对的是特定的 Control，只有目标 Control 节点的直接父节点"
"会接收到该事件。GUI **键盘和手柄**\\ 事件\\ *不会*\\ 沿场景树向上传播，只能由"
"接收到事件的 Control 处理。否则就会通过 :ref:`Node._unhandled_input() "
"<class_Node_private_method__unhandled_input>` 作为非 GUI 事件传播。"

msgid ""
"Since Viewports don't send events to other :ref:`SubViewports "
"<class_SubViewport>`, one of the following methods has to be used:"
msgstr ""
"由于 Viewport 不会将事件发送给其他 :ref:`SubViewport "
"<class_SubViewport>`\\ ，所以需要在下列方法中选择一个："

msgid ""
"Use a :ref:`SubViewportContainer <class_SubViewportContainer>`, which "
"automatically sends events to its child :ref:`SubViewports "
"<class_SubViewport>` after :ref:`Node._input() "
"<class_Node_private_method__input>` or :ref:`Control._gui_input() "
"<class_Control_private_method__gui_input>`."
msgstr ""
"使用 :ref:`SubViewportContainer <class_SubViewportContainer>`\\ ，这个节点会"
"在 :ref:`Node._input() <class_Node_private_method__input>` "
"或 :ref:`Control._gui_input() <class_Control_private_method__gui_input>` 之"
"后，自动将事件发送给其子级 :ref:`SubViewport <class_SubViewport>`\\ 。"

msgid "Implement event propagation based on the individual requirements."
msgstr "根据具体需求实现事件传播逻辑。"

msgid ""
"In accordance with Godot's node-based design, this enables specialized child "
"nodes to handle and consume particular events, while their ancestors, and "
"ultimately the scene root, can provide more generalized behavior if needed."
msgstr ""
"根据 Godot 基于节点的设计，这使得专门的子节点能够处理和消耗特定的事件，而它们"
"的祖先以及最终的场景根，可以在需要时提供更通用的行为。"

msgid "Anatomy of an InputEvent"
msgstr "InputEvent 剖析"

msgid ""
":ref:`InputEvent <class_InputEvent>` is just a base built-in type, it does "
"not represent anything and only contains some basic information, such as "
"event ID (which is increased for each event), device index, etc."
msgstr ""
":ref:`InputEvent <class_InputEvent>` 只是一个基本的内置类型，它不代表任何东"
"西，只包含一些基本信息，例如事件 ID（每个事件都会增加）、设备索引等。"

msgid ""
"There are several specialized types of InputEvent, described in the table "
"below:"
msgstr "InputEvent 有几种专门的类型，如下表所述："

msgid "Event"
msgstr "事件"

msgid "Description"
msgstr "描述"

msgid ":ref:`InputEvent <class_InputEvent>`"
msgstr ":ref:`InputEvent <class_InputEvent>`"

msgid "Empty Input Event."
msgstr "空输入事件。"

msgid ":ref:`InputEventKey <class_InputEventKey>`"
msgstr ":ref:`InputEventKey <class_InputEventKey>`"

msgid "Contains a keycode and Unicode value, as well as modifiers."
msgstr "包含键码和 Unicode 值以及修饰键。"

msgid ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"
msgstr ":ref:`InputEventMouseButton <class_InputEventMouseButton>`"

msgid "Contains click information, such as button, modifiers, etc."
msgstr "包含点击信息，例如按钮、修饰键等。"

msgid ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"
msgstr ":ref:`InputEventMouseMotion <class_InputEventMouseMotion>`"

msgid ""
"Contains motion information, such as relative and absolute positions and "
"speed."
msgstr "包含运动信息，例如相对位置、绝对位置和速度。"

msgid ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"
msgstr ":ref:`InputEventJoypadMotion <class_InputEventJoypadMotion>`"

msgid "Contains Joystick/Joypad analog axis information."
msgstr "包含操纵杆/操纵手柄模拟轴信息。"

msgid ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"
msgstr ":ref:`InputEventJoypadButton <class_InputEventJoypadButton>`"

msgid "Contains Joystick/Joypad button information."
msgstr "包含操纵杆/操纵手柄按钮信息。"

msgid ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"
msgstr ":ref:`InputEventScreenTouch <class_InputEventScreenTouch>`"

msgid ""
"Contains multi-touch press/release information. (only available on mobile "
"devices)"
msgstr "包含多点触控按下/释放信息。（仅适用于移动设备）"

msgid ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"
msgstr ":ref:`InputEventScreenDrag <class_InputEventScreenDrag>`"

msgid ""
"Contains multi-touch drag information. (only available on mobile devices)"
msgstr "包含多点触控拖动信息。（仅适用于移动设备）"

msgid ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"
msgstr ":ref:`InputEventMagnifyGesture <class_InputEventMagnifyGesture>`"

msgid "Contains a position, a factor as well as modifiers."
msgstr "包含位置、系数以及修饰键。"

msgid ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"
msgstr ":ref:`InputEventPanGesture <class_InputEventPanGesture>`"

msgid "Contains a position, a delta as well as modifiers."
msgstr "包含位置、增量以及修饰键。"

msgid ":ref:`InputEventMIDI <class_InputEventMIDI>`"
msgstr ":ref:`InputEventMIDI <class_InputEventMIDI>`"

msgid "Contains MIDI-related information."
msgstr "包含 MIDI 相关的信息。"

msgid ":ref:`InputEventShortcut <class_InputEventShortcut>`"
msgstr ":ref:`InputEventShortcut <class_InputEventShortcut>`"

msgid "Contains a shortcut."
msgstr "包含快捷键。"

msgid ":ref:`InputEventAction <class_InputEventAction>`"
msgstr ":ref:`InputEventAction <class_InputEventAction>`"

msgid ""
"Contains a generic action. These events are often generated by the "
"programmer as feedback. (more on this below)"
msgstr "包含通用动作。这些事件通常由程序员生成作为反馈。（更多信息见下文）"

msgid "Input actions"
msgstr "输入动作"

msgid ""
"Input actions are a grouping of zero or more InputEvents into a commonly "
"understood title (for example, the default \"ui_left\" action grouping both "
"joypad-left input and a keyboard's left arrow key). They are not required to "
"represent an InputEvent but are useful because they abstract various inputs "
"when programming the game logic."
msgstr ""
"输入动作是对若干 InputEvent 的分组，为每一组事件赋予能够普遍理解标题（例如默"
"认的“ui_left”动作将手柄向左的输入和键盘上的左方向键分到了一组）。使用输入动作"
"来代表 InputEvent 不是必须的，但之所以有用，是因为输入动作对游戏逻辑编程时的"
"各种输入进行了抽象。"

msgid "This allows for:"
msgstr "这样就可以："

msgid ""
"The same code to work on different devices with different inputs (e.g., "
"keyboard on PC, Joypad on console)."
msgstr ""
"用相同的代码在不同的设备上处理不同的输入（例如，PC 上的键盘、主机上的游戏手"
"柄）。"

msgid "Input to be reconfigured at runtime."
msgstr "在运行时重新配置输入。"

msgid "Actions to be triggered programmatically at runtime."
msgstr "在运行时以编程的方式触发动作。"

msgid ""
"Actions can be created from the Project Settings menu in the **Input Map** "
"tab and assigned input events."
msgstr ""
"动作可以从“项目设置”菜单中的\\ **输入映射**\\ 选项卡创建并分配输入事件。"

msgid ""
"Alternatively, it may be desired to supply the game back with an action from "
"the game code (a good example of this is detecting gestures). The Input "
"singleton has a method for this: :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>`. You would normally use it like this:"
msgstr ""
"或者，可能需要从游戏代码中向游戏提供一个动作（一个很好的例子是检测手势）。"
"Input 单例有一个方法 :ref:`Input.parse_input_event() "
"<class_input_method_parse_input_event>` 来用于此。通常会像这样使用它："

msgid ""
"See :ref:`doc_first_3d_game_input_actions` for a tutorial on adding input "
"actions in the project settings."
msgstr ""
"有关在项目设置中添加输入操作的教程，请参"
"阅 :ref:`doc_first_3d_game_input_actions`\\ 。"

msgid "InputMap"
msgstr "InputMap"

msgid ""
"Customizing and re-mapping input from code is often desired. If your whole "
"workflow depends on actions, the :ref:`InputMap <class_InputMap>` singleton "
"is ideal for reassigning or creating different actions at runtime. This "
"singleton is not saved (must be modified manually) and its state is run from "
"the project settings (project.godot). So any dynamic system of this type "
"needs to store settings in the way the programmer best sees fit."
msgstr ""
"通常需要从代码中自定义输入和重新映射输入。如果你的整个工作流程都依赖于动作，"
"则 :ref:`InputMap <class_InputMap>` 单例非常适合在运行时重新分配或创建不同的"
"动作。该单例不会被保存（必须手动修改），其状态从项目设置（project.godot）运"
"行。因此，任何该类型的动态系统都需要以程序员认为最合适的方式来存储设置。"
