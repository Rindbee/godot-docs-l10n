#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "High-level multiplayer"
msgstr "高级多人游戏"

msgid "High-level vs low-level API"
msgstr "高层API vs 底层 API"

msgid ""
"The following explains the differences of high- and low-level networking in "
"Godot as well as some fundamentals. If you want to jump in head-first and "
"add networking to your first nodes, skip to `Initializing the network`_ "
"below. But make sure to read the rest later on!"
msgstr ""
"下面解释了 Godot 高阶、低阶网络的区别以及其一些基本原理。如果你想一头扎进去，"
"直接为你的最初的节点添加网络功能，请跳到下面的\\ `初始化网络`_\\ ，但切记也要"
"阅读一下其余部分！"

msgid ""
"Godot always supported standard low-level networking via :abbr:`UDP (User "
"Datagram Protocol)`, :abbr:`TCP (Transmission Control Protocol)` and some "
"higher-level protocols such as :abbr:`HTTP (Hypertext Transfer Protocol)` "
"and :abbr:`SSL (Secure Sockets Layer)`. These protocols are flexible and can "
"be used for almost anything. However, using them to synchronize game state "
"manually can be a large amount of work. Sometimes that work can't be avoided "
"or is worth it, for example when working with a custom server implementation "
"on the backend. But in most cases, it's worthwhile to consider Godot's high-"
"level networking API, which sacrifices some of the fine-grained control of "
"low-level networking for greater ease of use."
msgstr ""
"Godot 始终支持通过 :abbr:`UDP (用户数据报协议)`、 :abbr:`TCP (传输控制协议)` "
"和一些更高级别的协议（如 :abbr:`SSL(安全套接层)` 和 :abbr:`HTTP (超文本传输协"
"议)` ）进行标准的低级网络连接。这些协议非常灵活，几乎可以用于任何用途。然而，"
"使用这些协议来手动同步游戏状态可能需要做大量的工作，这些工作有些情况下是无法"
"避免的，也有些情况下是值得去做的，比如在后台使用自定义服务器实现这种情况下。"
"而在大多数情况下，值得去考虑使用一下 Godot 的高级网络 API，它虽牺牲了对低级网"
"络的一些细度控制，却换来了更强的易用性。"

msgid "This is due to the inherent limitations of the low-level protocols:"
msgstr "这是底层协议的固有限制所造成的："

msgid ""
"TCP ensures packets will always arrive reliably and in order, but latency is "
"generally higher due to error correction. It's also quite a complex protocol "
"because it understands what a \"connection\" is, and optimizes for goals "
"that often don't suit applications like multiplayer games. Packets are "
"buffered to be sent in larger batches, trading less per-packet overhead for "
"higher latency. This can be useful for things like HTTP, but generally not "
"for games. Some of this can be configured and disabled (e.g. by disabling "
"\"Nagle's algorithm\" for the TCP connection)."
msgstr ""
"TCP 能够确保数据包始终可以可靠、有序地到达接收端，但是由于其错误纠正机制，其"
"延迟通常会更高。TCP本身也是一个相当复杂的协议，因为它理解什么是“连接”，它优化"
"的目标也不经常是多人游戏这种应用程序。系统会将数据包缓冲成更大的批次发送出"
"去，用更高的延迟来换取更小的单数据包开销，对于 HTTP 之类的东西可能很有用，但"
"对于游戏通常不太有用。其中一些可以进行配置和禁用（例如禁用 TCP 连接的“Nagle "
"算法”）。"

msgid ""
"UDP is a simpler protocol, which only sends packets (and has no concept of a "
"\"connection\"). No error correction makes it pretty quick (low latency), "
"but packets may be lost along the way or received in the wrong order. Added "
"to that, the MTU (maximum packet size) for UDP is generally low (only a few "
"hundred bytes), so transmitting larger packets means splitting them, "
"reorganizing them and retrying if a part fails."
msgstr ""
"UDP 则是一个更简单的协议，它只发送数据包（没有“连接”的概念），而且因为没有错"
"误纠正机制，所以速度非常快（延迟低），但数据包就可能会发生丢包或以接收顺序错"
"误等情况。此外，UDP 的 MTU（Maximum Packet Size，最大数据包大小）一般很低（只"
"有几百字节），传输更大的数据包意味着需要对这些数据包进行分割、重组，某一部分"
"失败时还要进行重试。"

msgid ""
"In general, TCP can be thought of as reliable, ordered, and slow; UDP as "
"unreliable, unordered and fast. Because of the large difference in "
"performance, it often makes sense to re-build the parts of TCP wanted for "
"games (optional reliability and packet order), while avoiding the unwanted "
"parts (congestion/traffic control features, Nagle's algorithm, etc). Due to "
"this, most game engines come with such an implementation, and Godot is no "
"exception."
msgstr ""
"一般来说，大家会觉得 TCP 可靠有序但速度缓慢；UDP不可靠、无序，但是速度很快。"
"由于二者在性能上的巨大差异，在避免不需要的部分（拥塞/流量控制特性、Nagle算法"
"等）的同时，重新构建游戏所需的TCP部分（可选的可靠性和包顺序）一般来说还是有道"
"理的。正因为如此，大多数游戏引擎都带有这样的实现，Godot 也不例外。"

msgid ""
"In summary, you can use the low-level networking API for maximum control and "
"implement everything on top of bare network protocols or use the high-level "
"API based on :ref:`SceneTree <class_SceneTree>` that does most of the heavy "
"lifting behind the scenes in a generally optimized way."
msgstr ""
"综上所述，你可以使用低级网络API来实现最大限度的控制，并在完全裸露的网络协议之"
"上实现所有功能，也可以使用基于 :ref:`SceneTree <class_SceneTree>` 的高级网络"
"API，该API通常以一种比较优化的方式在后台完成大部分繁重工作。"

msgid ""
"Most of Godot's supported platforms offer all or most of the mentioned high- "
"and low-level networking features. As networking is always largely hardware "
"and operating system dependent, however, some features may change or not be "
"available on some target platforms. Most notably, the HTML5 platform "
"currently offers WebSockets and WebRTC support but lacks some of the higher-"
"level features, as well as raw access to low-level protocols like TCP and "
"UDP."
msgstr ""
"Godot 支持的大多数平台都有提供所有或大部分上述高、低网络功能，但由于网络在很"
"大程度上依赖于硬件和操作系统，在某些目标平台上，一些特性可能会有所改变或者不"
"可使用。最值得注意的是 HTML5 平台目前只提供了对 WebSocket 和 WebRTC 的支持，"
"但缺乏一些高级功能，以及对 TCP 和 UDP 等低级协议的原始访问。"

msgid ""
"More about TCP/IP, UDP, and networking: https://gafferongames.com/post/"
"udp_vs_tcp/"
msgstr ""
"更多关于TCP/IP、UDP和网络的信息，参见： https://gafferongames.com/post/"
"udp_vs_tcp/"

msgid ""
"Gaffer On Games has a lot of useful articles about networking in Games "
"(`here <https://gafferongames.com/categories/game-networking/>`__), "
"including the comprehensive `introduction to networking models in games "
"<https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__."
msgstr ""
"Gaffer On Games有很多关于游戏中网络的有用文章（ `这里 <https://"
"gafferongames.com/categories/game-networking/>`__ ），包括全面的 `游戏中的网"
"络模型介绍 <https://gafferongames.com/post/"
"what_every_programmer_needs_to_know_about_game_networking/>`__ 。"

msgid ""
"Adding networking to your game comes with some responsibility. It can make "
"your application vulnerable if done wrong and may lead to cheats or "
"exploits. It may even allow an attacker to compromise the machines your "
"application runs on and use your servers to send spam, attack others or "
"steal your users' data if they play your game."
msgstr ""
"在你的游戏中，加入网络系统需要承担一定的责任。如果做不好，那么网络系统将会让"
"你的应用程序很容易遭受网络攻击，并可能会造成网络欺骗或远程操纵等不良后果，甚"
"至可能允许攻击者破坏你的应用程序所在的机器设备，并利用你的服务器来发送垃圾邮"
"件，甚至还会窃取你的用户数据，如果有其他用户玩你的游戏，攻击者还会其他用户。"

msgid ""
"This is always the case when networking is involved and has nothing to do "
"with Godot. You can of course experiment, but when you release a networked "
"application, always take care of any possible security concerns."
msgstr ""
"这种情况始终是当涉及到网络且与 Godot 无关时才需要如此考虑的。当然，你也可以进"
"行试验，但是在发布网络应用程序时，请始终注意任何可能存在的安全问题。"

msgid "Mid-level abstraction"
msgstr "中层抽象"

msgid ""
"Before going into how we would like to synchronize a game across the "
"network, it can be helpful to understand how the base network API for "
"synchronization works."
msgstr ""
"在讨论我们希望如何跨网络同步游戏之前，先让我们来了解一下用于同步的基本网络API"
"的运作原理，这样可能会对我们对后续内容的学习有所帮助。"

msgid ""
"Godot uses a mid-level object :ref:`MultiplayerPeer "
"<class_MultiplayerPeer>`. This object is not meant to be created directly, "
"but is designed so that several C++ implementations can provide it."
msgstr ""
"Godot 使用了一个中间层级的 :ref:`MultiplayerPeer <class_MultiplayerPeer>` 对"
"象。不应直接创建这种对象，它被设计为由多个 C++ 实现所提供。"

msgid ""
"This object extends from :ref:`PacketPeer <class_PacketPeer>`, so it "
"inherits all the useful methods for serializing, sending and receiving data. "
"On top of that, it adds methods to set a peer, transfer mode, etc. It also "
"includes signals that will let you know when peers connect or disconnect."
msgstr ""
"这个对象扩展自 :ref:`PacketPeer <class_PacketPeer>` 类，继承了所有用于序列"
"化、发送和接收数据的方法。此外，该对象还添加了设置对等体、传输模式等方法。它"
"还包括让你知道对等体何时连接或断开的信号。"

msgid ""
"This class interface can abstract most types of network layers, topologies "
"and libraries. By default, Godot provides an implementation based on ENet "
"(:ref:`ENetMultiplayerPeer <class_ENetMultiplayerPeer>`), one based on "
"WebRTC (:ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`), and one "
"based on WebSocket (:ref:`WebSocketPeer <class_WebSocketPeer>`), but this "
"could be used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or "
"custom device/console-specific networking APIs."
msgstr ""
"这个类接口可以抽象出大多数类型的网络层、拓扑结构和库。默认情况下，Godot 会提"
"供一个基于 ENet 的实现（\\ :ref:`ENetMultiplayerPeer "
"<class_ENetMultiplayerPeer>`\\ ）、一个基于 WebRTC 的实现"
"（\\ :ref:`WebRTCMultiplayerPeer <class_WebRTCMultiplayerPeer>`\\ ）以及一个"
"基于WebSocket的实现（\\ :ref:`WebSocketPeer <class_WebSocketPeer>`\\ ），而该"
"类接口可以用来实现移动 API（用于特设的 WiFi、蓝牙等）或自定义设备/控制台中特"
"定的网络 API。"

msgid ""
"For most common cases, using this object directly is discouraged, as Godot "
"provides even higher level networking facilities. This object is still made "
"available in case a game has specific needs for a lower-level API."
msgstr ""
"但大多数常见情况下，不鼓励直接使用这个对象，因为 Godot 提供了更高级别的网络使"
"用方法。只有当游戏对较低级别的API有特殊需求的情况下，才使用该对象。"

msgid "Hosting considerations"
msgstr "服务器托管的注意事项"

msgid ""
"When hosting a server, clients on your :abbr:`LAN (Local Area Network)` can "
"connect using the internal IP address which is usually of the form "
"``192.168.*.*``. This internal IP address is **not** reachable by non-LAN/"
"Internet clients."
msgstr ""
"托管服务器时，\\ :abbr:`LAN (局域网)` 上的客户端可以使用内网 IP 地址进行连"
"接，该地址的格式通常是 ``192.168.*.*``\\ 。 非 LAN/Internet 客户端\\ **无法"
"**\\ 访问此内部 IP 地址。"

msgid ""
"On Windows, you can find your internal IP address by opening a command "
"prompt and entering ``ipconfig``. On macOS, open a Terminal and enter "
"``ifconfig``. On Linux, open a terminal and enter ``ip addr``."
msgstr ""
"在 Windows 中， 你可以在命令提示符中输入 ``ipconfig`` 命令， 在 macOS 中，你"
"可以在终端中输入 ``ifconfig`` 命令，在 Linux 中，你可以在终端中输入 ``ip "
"addr`` 命令，来找到你的内网 IP 地址。"

msgid ""
"If you're hosting a server on your own machine and want non-LAN clients to "
"connect to it, you'll probably have to *forward* the server port on your "
"router. This is required to make your server reachable from the Internet "
"since most residential connections use a `NAT <https://en.wikipedia.org/wiki/"
"Network_address_translation>`__. Godot's high-level multiplayer API only "
"uses UDP, so you must forward the port in UDP, not just TCP."
msgstr ""
"如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，那么你可能需要将"
"服务器端口 *转发* 到你的路由器，由于大多数家用网络都使用 `NAT <https://"
"zh.wikipedia.org/wiki/"
"%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2>`__ 技术，因此转发服务"
"器端口是让你的服务器能通过互联网访问的必经步骤。Godot 的高级多人 API 只使用 "
"UDP 协议，所以你的端口转发也必须是 UDP 协议的端口，不能只转发 TCP 协议的端"
"口。"

msgid ""
"After forwarding a UDP port and making sure your server uses that port, you "
"can use `this website <https://icanhazip.com/>`__ to find your public IP "
"address. Then give this public IP address to any Internet clients that wish "
"to connect to your server."
msgstr ""
"在转发了 UDP 端口之后，你需要确保你的服务器使用这个端口。可以前往\\ `这个网"
"站 <https://icanhazip.com/>`\\ 去查询你的公网 IP 地址，然后把这个公网 IP 地址"
"发送给想联机到你服务器的互联网客户端即可。"

msgid ""
"Godot's high-level multiplayer API uses a modified version of ENet which "
"allows for full IPv6 support."
msgstr "Godot 的高级多人联机 API 使用的是一个修改过的 ENet，包含全 IPv6 支持。"

msgid "Initializing the network"
msgstr "网络初始化"

msgid ""
"Each node has a ``multiplayer`` property, which is a reference to the "
"``MultiplayerAPI`` instance configured for it by the scene tree. Initially, "
"every node is configured with the same default ``MultiplayerAPI`` object."
msgstr ""
"每个节点都有一个 ``multiplayer`` 属性，它是对场景树为其配置的 "
"``MultiplayerAPI`` 实例的引用。每个节点在初始化时都会配有相同预设的 "
"``MultiplayerAPI`` 物件。"

msgid ""
"It is possible to create a new ``MultiplayerAPI`` object and assign it to a "
"``NodePath`` in the the scene tree, which will override ``multiplayer`` for "
"the node at that path and all of its descendants. This allows sibling nodes "
"to be configured with different peers, which makes it possible to run a "
"server and a client simultaneously in one instance of Godot."
msgstr ""
"也可以建立一个新的 ``MultiplayerAPI`` 对象，并将其分配给场景树中的 "
"``NodePath``\\ ，该操作将覆盖该路径及其所有后代节点的 ``multiplayer`` 属性，"
"也允许同级节点能够配置不同的对等体，从而可以在一个 Godot 实例中同时运行多个服"
"务端和客户端。"

msgid ""
"To initialize networking, a ``MultiplayerPeer`` object must be created, "
"initialized as a server or client, and passed to the ``MultiplayerAPI``."
msgstr ""
"要想初始化网络， 你必须先创建一个 ``MultiplayerPeer`` 对象，将其初始化为服务"
"器或客户端，然后将其传给 ``MultiplayerAPI``\\ 。"

msgid "To terminate networking:"
msgstr "可以通过下述方法来停止联网功能："

msgid ""
"When exporting to Android, make sure to enable the ``INTERNET`` permission "
"in the Android export preset before exporting the project or using one-click "
"deploy. Otherwise, network communication of any kind will be blocked by "
"Android."
msgstr ""
"导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中启"
"用 ``INTERNET`` 权限。否则，Android 系统会阻止该程序任何形式的网络通信。"

msgid "Managing connections"
msgstr "管理连接"

msgid ""
"Every peer is assigned a unique ID. The server's ID is always 1, and clients "
"are assigned a random positive integer."
msgstr ""
"系统会给每个对等体都分配一个唯一 ID（UID），服务器的 ID 永远为 1，客户端的 "
"ID 则会被分配给一个随机的正整数。"

msgid ""
"Responding to connections or disconnections is possible by connecting to "
"``MultiplayerAPI``'s signals:"
msgstr "可以通过连接到 ``MultiplayerAPI`` 的信号来响应连接或断开连接："

msgid ""
"``peer_connected(id: int)`` This signal is emitted with the newly connected "
"peer's ID on each other peer, and on the new peer multiple times, once with "
"each other peer's ID."
msgstr ""
"``peer_connected(id: int)`` 此信号在每个其他对等体上与新连接的对等体 ID 一起"
"发出，并在新对等点上多次发出，其中一次与每个其他对等点ID一起发出。"

msgid ""
"``peer_disconnected(id: int)`` This signal is emitted on every remaining "
"peer when one disconnects."
msgstr ""
"``peer_disconnected（id:int）`` 当一个对等体断开连接时，剩余的每个对等体都会"
"发出此信号。"

msgid "The rest are only emitted on clients:"
msgstr "以下信号仅在客户端上发送："

msgid "``connected_to_server()``"
msgstr "``connected_to_server()``"

msgid "``connection_failed()``"
msgstr "``connection_failed()``"

msgid "``server_disconnected()``"
msgstr "``server_disconnected()``"

msgid "To get the unique ID of the associated peer:"
msgstr "通过下述方法来取得关联到对等体的UID："

msgid "To check whether the peer is server or client:"
msgstr "通过下述方法来对等体是服务器还是客户端："

msgid "Remote procedure calls"
msgstr "远程过程调用"

msgid ""
"Remote procedure calls, or RPCs, are functions that can be called on other "
"peers. To create one, use the ``@rpc`` annotation before a function "
"definition. To call an RPC, use ``Callable``'s method ``rpc()`` to call in "
"every peer, or ``rpc_id()`` to call in a specific peer."
msgstr ""
"远程过程调用（RPC）是可以在其他对等方上调用的函数。要创建一个 RPC，请在函数定"
"义之前使用 ``@rpc`` 注解。若要调用 RPC，请在每个对等体中通过 ``Callable`` 的 "
"``rpc()`` 方法调用之，或使用 ``rpc_id()`` 在特定对等方中调用之。"

msgid "RPCs will not serialize objects or callables."
msgstr "RPC 既不会序列化对象，也不会序列化可调用体。"

msgid ""
"For a remote call to be successful, the sending and receiving node need to "
"have the same ``NodePath``, which means they must have the same name. When "
"using ``add_child()`` for nodes which are expected to use RPCs, set the "
"argument ``force_readable_name`` to ``true``."
msgstr ""
"要使远程调用成功，发送方节点和接收方节点需要具有相同的 ``NodePath`` ，也就是"
"说，这些节点必须具有相同的节点名称。对预期使用 RPC 的节点调用 "
"``add_child()`` 时，请将参数 ``force_readable_name`` 设置为 ``true``\\ 。"

msgid ""
"If these conditions are not met (if all RPCs do not pass signature "
"matching), the script may print an error or cause unwanted behavior. The "
"error message may be unrelated to the RPC function you are currently "
"building and testing."
msgstr ""
"如果不满足这些条件（即如果所有RPC都没有通过签名匹配），脚本则可能会打印错误，"
"错误消息可能与你当前正在构建和测试的 RPC 函数无关；也可能会导致非预期行为的发"
"生。"

msgid ""
"See further explanation and troubleshooting on `this post <https://"
"github.com/godotengine/godot/issues/57869#issuecomment-1034215138>`__."
msgstr ""
"请参阅本帖的进一步解释和故障排除： `点我前往 <https://github.com/godotengine/"
"godot/issues/57869#issuecomment-1034215138>`__."

msgid ""
"The annotation can take a number of arguments, which have default values. "
"``@rpc`` is equivalent to:"
msgstr "``@rpc`` 注解可以采用多个参数，这些参数具有预设值，相当于："

msgid "The parameters and their functions are as follows:"
msgstr "其参数及作用如下："

msgid "``mode``:"
msgstr "``mode``："

msgid ""
"``\"any_peer\"``: Clients are allowed to call remotely. Useful for "
"transferring user input."
msgstr "``“any_peer”`` ：也允许客户端进行远程调用该函数，用于传输用户输入。"

msgid "``sync``:"
msgstr "``sync`` ："

msgid "``\"call_remote\"``: The function will not be called on the local peer."
msgstr "``\"call_remote\"``: 让该函数不会在本地对等体上调用。"

msgid ""
"``\"call_local\"``: The function can be called on the local peer. Useful "
"when the server is also a player."
msgstr ""
"``“call_local”``\\ ：让该函数也可以在本地对等体上调用，在服务器也是玩家时非常"
"有用。"

msgid "``transfer_mode``:"
msgstr "``transfer_mode`` ："

msgid ""
"``\"unreliable\"`` Packets are not acknowledged, can be lost, and can arrive "
"at any order."
msgstr ""
"``\"unreliable\"`` 数据包不被确认，可能丢失，并且可以按任意顺序到达接收方。"

msgid ""
"``\"unreliable_ordered\"`` Packets are received in the order they were sent "
"in. This is achieved by ignoring packets that arrive later if another that "
"was sent after them has already been received. Can cause packet loss if used "
"incorrectly."
msgstr ""
"``\"unreliable_ordered\"`` 数据包按照发送的顺序接收，透过忽略迟达的数据包（如"
"果已经收到在这些数据包之后发送的另一个数据包）来实现的。使用不当可能会导致丢"
"包。"

msgid ""
"``\"reliable\"`` Resend attempts are sent until packets are acknowledged, "
"and their order is preserved. Has a significant performance penalty."
msgstr ""
"``\"reliable\"`` 发送重新传送尝试，直到数据包被确认为止，且这些数据包的顺序会"
"被保留。具有明显的性能损失。"

msgid "``transfer_channel`` is the channel index."
msgstr "``transfer_channel`` 是信道索引。"

msgid ""
"The first 3 can be passed in any order, but ``transfer_channel`` must always "
"be last."
msgstr ""
"前3个参数在注解中的顺序任意，但 ``transfer_channel`` 参数必须始终位于注解中的"
"最后。"

msgid ""
"The function ``multiplayer.get_remote_sender_id()`` can be used to get the "
"unique id of an rpc sender, when used within the function called by rpc."
msgstr ""
"在 RPC 所调用的函数中，可用函数 ``multiplayer.get_remote_sender_id()`` 来获"
"取 RPC 发送方对等体的 UID。"

msgid "Channels"
msgstr "信道"

msgid ""
"Modern networking protocols support channels, which are separate connections "
"within the connection. This allows for multiple streams of packets that do "
"not interfere with each other."
msgstr ""
"现代网络协定支持信道系统。信道是网络连接内的单独连接，允许多个数据包流互不干"
"扰。"

msgid ""
"For example, game chat related messages and some of the core gameplay "
"messages should all be sent reliably, but a gameplay message should not wait "
"for a chat message to be acknowledged. This can be achieved by using "
"different channels."
msgstr ""
"像是游戏聊天相关信息和一些核心游戏信息等都应该可靠地发送，但游戏信息不应等待"
"聊天信息被确认后在发送，这一点可以通过使用不同的信道来实现。"

msgid ""
"Channels are also useful when used with the unreliable ordered transfer "
"mode. Sending packets of variable size with this transfer mode can cause "
"packet loss, since packets which are slower to arrive are ignored. "
"Separating them into multiple streams of homogeneous packets by using "
"channels allows ordered transfer with little packet loss, and without the "
"latency penalty caused by reliable mode."
msgstr ""
"当与不可靠的有序传输模式一起使用时，信道也十分有用。使用此传输模式发送可变大"
"小的数据包可能会导致丢包，因为迟达的数据包将会被接收方忽略。通过使用信道，将"
"它们拆分成多个同质数据包流，可以实现有序传输，且丢包很少，不会因可靠模式而导"
"致延迟损失。"

msgid ""
"The default channel with index 0 is actually three different channels - one "
"for each transfer mode."
msgstr "索引为 0 的默认信道实际上是三个不同的信道——每个传输模式一个。"

msgid "Example lobby implementation"
msgstr "大厅实现示例"

msgid ""
"This is an example lobby that can handle peers joining and leaving, notify "
"UI scenes through signals, and start the game after all clients have loaded "
"the game scene."
msgstr ""
"下面为一个示例大厅，可以处理对等体的加入和离开，通过信号来通知UI场景，并在所"
"有客户端加载游戏场景后启动游戏。"

msgid ""
"The game scene's root node should be named Game. In the script attached to "
"it:"
msgstr "游戏场景的根节点应命名为 Game，在其所附加的脚本中："

msgid "Exporting for dedicated servers"
msgstr "为专用服务器导出"

msgid ""
"Once you've made a multiplayer game, you may want to export it to run it on "
"a dedicated server with no GPU available. "
"See :ref:`doc_exporting_for_dedicated_servers` for more information."
msgstr ""
"一旦你制作好了一款多人游戏，你可能会想将其导出到一个没有 GPU 的专用服务器上运"
"行，对此可参见 :ref:`doc_exporting_for_dedicated_servers` 来获取更多信息。"

msgid ""
"The code samples on this page aren't designed to run on a dedicated server. "
"You'll have to modify them so the server isn't considered to be a player. "
"You'll also have to modify the game starting mechanism so that the first "
"player who joins can start the game."
msgstr ""
"该页面上的范例代码并不是为了在专用服务器上运行而设计的，你必须修改这些代码来"
"让避免系统将服务器误认为玩家，此外，你还必须修改游戏的启动机制，让第一个加入"
"的玩家可以自行启动游戏。"
