#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Ray-casting"
msgstr "发射射线"

msgid "Introduction"
msgstr "前言"

msgid ""
"One of the most common tasks in game development is casting a ray (or custom "
"shaped object) and checking what it hits. This enables complex behaviors, "
"AI, etc. to take place. This tutorial will explain how to do this in 2D and "
"3D."
msgstr ""
"通过发射射线（和自定义形状的对象）来检测命中的物体是游戏开发中最常见的任务之"
"一。这是 AI 等复杂行为的基础。本教程将介绍在 2D 和 3D 中的实现方法。"

msgid ""
"Godot stores all the low level game information in servers, while the scene "
"is only a frontend. As such, ray casting is generally a lower-level task. "
"For simple raycasts, nodes like :ref:`RayCast3D <class_RayCast3D>` and :ref:"
"`RayCast2D <class_RayCast2D>` will work, as they return every frame what the "
"result of a raycast is."
msgstr ""
"Godot 将所有底层游戏信息存储在服务器中，场景只是一个前端。投射射线本身通常是"
"一项比较底层的任务。简单的射线投射可以使用 :ref:`RayCast3D "
"<class_RayCast3D>` 和 :ref:`RayCast2D <class_RayCast2D>` 等节点实现，它们可以"
"返回每帧投射射线的结果。"

msgid ""
"Many times, though, ray-casting needs to be a more interactive process so a "
"way to do this by code must exist."
msgstr ""
"但是很多时候，射线投射需要更具交互性，因此必须存在通过代码执行此操作的方法。"

msgid "Space"
msgstr "空间"

msgid ""
"In the physics world, Godot stores all the low level collision and physics "
"information in a *space*. The current 2d space (for 2D Physics) can be "
"obtained by accessing :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>`. For 3D, it's :ref:`Node3D."
"get_world_3d().space <class_Node3D_method_get_world_3d>`."
msgstr ""
"在物理世界中，Godot 将所有低级碰撞和物理信息存储在一个\\ *空间*\\ 中。可以通"
"过访问 :ref:`CanvasItem.get_world_2d().space "
"<class_CanvasItem_method_get_world_2d>` 获取当前 2D 空间（用于 2D 物理）。3D "
"则是使用 :ref:`Node3D.get_world_3d().space "
"<class_Node3D_method_get_world_3d>`\\ 。"

msgid ""
"The resulting space :ref:`RID <class_RID>` can be used in :ref:"
"`PhysicsServer3D <class_PhysicsServer3D>` and :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>` respectively for 3D and 2D."
msgstr ""
"对于 3D 和 2D，得到的空间 :ref:`RID <class_RID>` 可分别在 :ref:"
"`PhysicsServer3D <class_PhysicsServer3D>` 和 :ref:`PhysicsServer2D "
"<class_PhysicsServer2D>` 中使用。"

msgid "Accessing space"
msgstr "获取空间"

msgid ""
"Godot physics runs by default in the same thread as game logic, but may be "
"set to run on a separate thread to work more efficiently. Due to this, the "
"only time accessing space is safe is during the :ref:`Node."
"_physics_process() <class_Node_private_method__physics_process>` callback. "
"Accessing it from outside this function may result in an error due to space "
"being *locked*."
msgstr ""
"Godot 物理默认与游戏逻辑在同一个线程中运行，但可以设置为在单独的线程中运行以"
"提高效率。因此，唯一安全访问空间的时间是在 :ref:`Node._physics_process() "
"<class_Node_private_method__physics_process>` 回调期间。从该函数之外访问空间"
"可能会产生一个错误，因为空间会被\\ *锁定*\\ 。"

msgid "Use the following code in 2D:"
msgstr "在 2D 中使用以下代码："

msgid "Or more directly:"
msgstr "或者更直接："

msgid "And in 3D:"
msgstr "在 3D 中："

msgid "Raycast query"
msgstr "Raycast 查询"

msgid ""
"For performing a 2D raycast query, the method :ref:"
"`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` may be used. For "
"example:"
msgstr ""
"要执行 2D 射线查询，可以使用 :ref:`PhysicsDirectSpaceState2D.intersect_ray() "
"<class_PhysicsDirectSpaceState2D_method_intersect_ray>` 方法。例如："

msgid ""
"The result is a dictionary. If the ray didn't hit anything, the dictionary "
"will be empty. If it did hit something, it will contain collision "
"information:"
msgstr ""
"结果是一个字典。如果射线什么都没有击中，那么字典就是空的。如果击中了，就会包"
"含碰撞信息："

msgid ""
"The ``result`` dictionary when a collision occurs contains the following "
"data:"
msgstr "发生碰撞时，\\ ``result`` 字典包含以下数据："

msgid ""
"The data is similar in 3D space, using Vector3 coordinates. Note that to "
"enable collisions with Area3D, the boolean parameter ``collide_with_areas`` "
"must be set to ``true``."
msgstr ""
"3D 空间中的数据也是类似的，只不过使用的是 Vector3 坐标。请注意，要启用与 "
"Area3D 的碰撞，必须将布尔值参数 ``collide_with_areas`` 设置为 ``true``\\ 。"

msgid "Collision exceptions"
msgstr "碰撞例外"

msgid ""
"A common use case for ray casting is to enable a character to gather data "
"about the world around it. One problem with this is that the same character "
"has a collider, so the ray will only detect its parent's collider, as shown "
"in the following image:"
msgstr ""
"光线投射的常见用例是使角色能够收集有关其周围世界的数据。这种情况的一个问题是"
"该角色上有碰撞体，因此光线只会检测到其父节点上的碰撞体，如下图所示："

msgid ""
"To avoid self-intersection, the ``intersect_ray()`` parameters object can "
"take an array of exceptions via its ``exclude`` property. This is an example "
"of how to use it from a CharacterBody2D or any other collision object node:"
msgstr ""
"为了避免自相交，\\ ``intersect_ray()`` 参数对象可以通过其 ``exclude`` 属性获"
"取一个排除数组。这是一个如何从 CharacterBody2D 或任何其他碰撞对象节点使用它的"
"示例："

msgid "The exceptions array can contain objects or RIDs."
msgstr "例外数组可以包含对象或 RID。"

msgid "Collision Mask"
msgstr "碰撞遮罩"

msgid ""
"While the exceptions method works fine for excluding the parent body, it "
"becomes very inconvenient if you need a large and/or dynamic list of "
"exceptions. In this case, it is much more efficient to use the collision "
"layer/mask system."
msgstr ""
"虽然例外方法适用于排除父体, 但如果需要大型和/或动态的例外列表, 则会变得非常不"
"方便. 在这种情况下, 使用碰撞层/遮罩系统要高效得多."

msgid ""
"The ``intersect_ray()`` parameters object can also be supplied a collision "
"mask. For example, to use the same mask as the parent body, use the "
"``collision_mask`` member variable. The array of exceptions can be supplied "
"as the last argument as well:"
msgstr ""
"``intersect_ray()`` 参数对象也可以提供一个碰撞掩码。例如，要使用与父物体相同"
"的掩码，请使用 ``collision_mask`` 成员变量。排除数组也可以作为最后一个参数提"
"供："

msgid ""
"See :ref:`doc_physics_introduction_collision_layer_code_example` for details "
"on how to set the collision mask."
msgstr ""
"关于如何设置碰撞掩码, 请参阅 :ref:"
"`doc_physics_introduction_collision_layer_code_example` ."

msgid "3D ray casting from screen"
msgstr "来自屏幕的 3D 光线投射"

msgid ""
"Casting a ray from screen to 3D physics space is useful for object picking. "
"There is not much need to do this because :ref:`CollisionObject3D "
"<class_CollisionObject3D>` has an \"input_event\" signal that will let you "
"know when it was clicked, but in case there is any desire to do it manually, "
"here's how."
msgstr ""
"将射线从屏幕投射到 3D 物理空间对于拾取对象非常有用。没有必要这样做，因为 :"
"ref:`CollisionObject3D <class_CollisionObject3D>` 有一个“input_event”信号，可"
"以让你知道何时点击它，但如果你希望手动执行该操作，可这样。"

msgid ""
"To cast a ray from the screen, you need a :ref:`Camera3D <class_Camera3D>` "
"node. A ``Camera3D`` can be in two projection modes: perspective and "
"orthogonal. Because of this, both the ray origin and direction must be "
"obtained. This is because ``origin`` changes in orthogonal mode, while "
"``normal`` changes in perspective mode:"
msgstr ""
"要从屏幕投射光线，你需要一个 :ref:`Camera3D <class_Camera3D>` 节点。\\ "
"``Camera3D`` 可以有两种投影模式：透视和正交。因此，必须获取射线原点和方向。这"
"是因为 ``origin`` 在正交模式下会发生变化，而 ``normal`` 在透视模式下会发生变"
"化："

msgid "To obtain it using a camera, the following code can be used:"
msgstr "要使用相机获取它, 可以使用以下代码:"

msgid ""
"Remember that during ``_input()``, the space may be locked, so in practice "
"this query should be run in ``_physics_process()``."
msgstr ""
"请记住，在 ``_input()`` 期间空间可能被锁定，所以实践中应该在 "
"``_physics_process()`` 中运行这个查询。"
