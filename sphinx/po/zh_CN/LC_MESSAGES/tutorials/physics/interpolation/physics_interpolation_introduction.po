#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.4\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Introduction"
msgstr "前言"

msgid "Physics ticks and rendered frames"
msgstr "物理周期与渲染帧"

msgid "What can we do about frames and ticks being out of sync?"
msgstr "渲染帧和物理周期不同步怎么办？"

msgid "Lock the tick / frame rate together?"
msgstr "是否要将物理周期和渲染帧锁定？"

msgid "Adapt the tick rate?"
msgstr "适应物理周期率？"

msgid ""
"Lock the tick rate, but use interpolation to smooth frames in between "
"physics ticks"
msgstr "锁定物理周期率，但在物理周期之间使用插值让渲染帧平滑"

msgid "Linear interpolation"
msgstr "线性插值"

msgid "The physics interpolation fraction"
msgstr "物理插值比例"

msgid ""
"If our physics ticks are happening 10 times per second (for this example), "
"what happens if our rendered frame takes place at time 0.12 seconds? We can "
"do some math to figure out where the object would be to obtain a smooth "
"motion between the two ticks."
msgstr ""
"假设（在这个例子中）物理周期是每秒 10 次，那么渲染帧位于 0.12 秒的话会发生什"
"么呢？要实现两个周期之间的平滑运动，物体所处的位置，我们来解一个数学题就知道"
"了。"

msgid ""
"First of all, we have to calculate how far through the physics tick we want "
"the object to be. If the last physics tick took place at 0.1 seconds, we are "
"0.02 seconds *(0.12 - 0.1)* through a tick that we know will take 0.1 "
"seconds (10 ticks per second). The fraction through the tick is thus:"
msgstr ""
"首先，我们要计算物体在物理周期中经过了多久。如果上一个物理周期在 0.1 秒，那么"
"我们就在物理周期中经过了 *(0.12 - 0.1)* 即 0.02 秒，因为一个周期总共 0.1 秒"
"（每秒 10 个周期）。所以周期中的比例就是："

msgid ""
"This is called the **physics interpolation fraction**, and is handily "
"calculated for you by Godot. It can be retrieved on any frame by "
"calling :ref:`Engine.get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>`."
msgstr ""
"这个值叫做\\ **物理插值比例**\\ ，Godot 会帮你计算好，可以在任何帧中调"
"用 :ref:`Engine.get_physics_interpolation_fraction<class_Engine_method_get_physics_interpolation_fraction>` "
"来获取。"

msgid "Calculating the interpolated position"
msgstr "计算插值位置"

msgid ""
"Once we have the interpolation fraction, we can insert it into a standard "
"linear interpolation equation. The X coordinate would thus be:"
msgstr "得到插值比例后，我们就可以把它代入标准线性插值公式。所以 X 坐标就是："

msgid "So substituting our ``x_prev`` as 10, and ``x_curr`` as 30:"
msgstr "将 ``x_prev`` 替换为 10，将 ``x_curr`` 替换为 30："

msgid "Let's break that down:"
msgstr "让我们来拆解一下："

msgid ""
"We know the X starts from the coordinate on the previous tick (``x_prev``) "
"which is 10 units."
msgstr ""
"我们知道 X 从上一周期的坐标（\\ ``x_prev``\\ ）开始，该坐标为 10 个单位。"

msgid ""
"We know that after the full tick, the difference between the current tick "
"and the previous tick will have been added (``x_curr - x_prev``) (which is "
"20 units)."
msgstr ""
"我们知道在完整的一个周期之后，会加上当前周期与上一周期之间的差值（\\ "
"``x_curr - x_prev``\\ ）（即 20 个单位）。"

msgid "Smoothed transformations between physics ticks?"
msgstr "物理周期之间的平滑变换？"

msgid ""
"But wait, you may have noticed something. If we are interpolating between "
"the current and previous ticks, we are not estimating the position of the "
"object *now*, we are estimating the position of the object in the past. To "
"be exact, we are estimating the position of the object *between 1 and 2 "
"ticks* into the past."
msgstr ""
"但是等等，你可能已经注意到了。如果我们是在当前周期和上一个周期之间进行插值，"
"那我们并不是在估计物体\\ *现在*\\ 的位置，而是在估计物体\\ *过去*\\ 的位置。"
"准确地说，我们是在估计物体在过去的 *1 到 2 个周期之间*\\ 的位置。"

msgid "In the past"
msgstr "过去"

msgid ""
"What does this mean? This scheme does work, but it does mean we are "
"effectively introducing a delay between what we see on the screen, and where "
"the objects *should* be."
msgstr ""
"这是什么意思？这种方案确实可行，但也意味着我们本质上是在屏幕上看到的内容和物"
"体\\ *应该*\\ 在的位置之间引入了一个延迟。"

msgid "Why look into the past? Why not predict the future?"
msgstr "为什么回顾过去？为什么不预测未来？"

msgid "Fixed timestep interpolation"
msgstr "固定时间步长插值"
