#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Collision shapes (2D)"
msgstr "碰撞形状（2D）"

msgid "This guide explains:"
msgstr "本指南解释："

msgid "The types of collision shapes available in 2D in Godot."
msgstr "Godot 2D 中可用的碰撞形状类型。"

msgid "Using an image converted to a polygon as a collision shape."
msgstr "使用转换为多边形的图像作为碰撞形状。"

msgid "Performance considerations regarding 2D collisions."
msgstr "有关 2D 碰撞的性能注意事项。"

msgid ""
"Godot provides many kinds of collision shapes, with different performance "
"and accuracy tradeoffs."
msgstr "Godot提供多种碰撞形状, 具有不同的性能和精度权衡."

msgid ""
"You can define the shape of a :ref:`class_PhysicsBody2D` by adding one or "
"more :ref:`CollisionShape2Ds <class_CollisionShape2D>` or :ref:"
"`CollisionPolygon2Ds <class_CollisionPolygon2D>` as child nodes. Note that "
"you must add a :ref:`class_Shape2D` *resource* to collision shape nodes in "
"the Inspector dock."
msgstr ""
"你可以通过添加一个或多个 :ref:`CollisionShape2Ds <class_CollisionShape2D>` "
"或 :ref:`CollisionPolygon2Ds <class_CollisionPolygon2D>` 作为子节点来定义 :"
"ref:`class_PhysicsBody2D` 的形状。请注意，你必须将 :ref:`class_Shape2D` *资源"
"*\\ 添加到检查器面板内的碰撞形状节点。"

msgid ""
"When you add multiple collision shapes to a single PhysicsBody2D, you don't "
"have to worry about them overlapping. They won't \"collide\" with each other."
msgstr ""
"当你将多个碰撞形状添加到单个 PhysicsBody2D 时，不必担心它们会重叠。它们不会相"
"互“碰撞”。"

msgid "Primitive collision shapes"
msgstr "基本碰撞形状"

msgid "Godot provides the following primitive collision shape types:"
msgstr "Godot提供了以下基本碰撞形状类型:"

msgid ":ref:`class_RectangleShape2D`"
msgstr ":ref:`class_RectangleShape2D`"

msgid ":ref:`class_CircleShape2D`"
msgstr ":ref:`class_CircleShape2D`"

msgid ":ref:`class_CapsuleShape2D`"
msgstr ":ref:`class_CapsuleShape2D`"

msgid ":ref:`class_SegmentShape2D`"
msgstr ":ref:`class_SegmentShape2D`"

msgid ":ref:`class_SeparationRayShape2D` (designed for characters)"
msgstr ":ref:`class_SeparationRayShape2D` （专为角色设计）"

msgid ":ref:`class_WorldBoundaryShape2D` (infinite plane)"
msgstr ":ref:`class_WorldBoundaryShape2D` （无限平面）"

msgid ""
"You can represent the collision of most smaller objects using one or more "
"primitive shapes. However, for more complex objects, such as a large ship or "
"a whole level, you may need convex or concave shapes instead. More on that "
"below."
msgstr ""
"你可以使用一个或多个原始形状来表示大多数较小物体的碰撞. 然而, 对于更复杂的物"
"体, 如大型船舶或整个水平面, 你可能需要凸形或凹形来代替. 下面会有更多的介绍."

msgid ""
"We recommend favoring primitive shapes for dynamic objects such as "
"RigidBodies and CharacterBodies as their behavior is the most reliable. They "
"often provide better performance as well."
msgstr ""
"建议动态对象使用原始图形（如 RigidBodies 和 KinematicBodies），因为它们的行为"
"是可靠的，通常也能提供更好的性能。"

msgid "Convex collision shapes"
msgstr "凸型碰撞形状"

msgid ""
"Godot currently doesn't offer a built-in way to create 2D convex collision "
"shapes. This section is mainly here for reference purposes."
msgstr "Godot 目前没有提供创建 2D 凸形碰撞形状的内置方法。本节内容主要供参考。"

msgid ""
":ref:`Convex collision shapes <class_ConvexPolygonShape2D>` are a compromise "
"between primitive collision shapes and concave collision shapes. They can "
"represent shapes of any complexity, but with an important caveat. As their "
"name implies, an individual shape can only represent a *convex* shape. For "
"instance, a pyramid is *convex*, but a hollow box is *concave*. To define a "
"concave object with a single collision shape, you need to use a concave "
"collision shape."
msgstr ""
":ref:`凸碰撞形状 <class_ConvexPolygonShape2D>` 是图元碰撞形状和凹碰撞形状之间"
"的折衷。它们可以表示任何复杂程度的形状，但有一个重要的注意事项。顾名思义，单"
"个形状只能表示\\ *凸*\\ 形状。例如，金字塔是\\ *凸*\\ 的，而空心盒子是\\ *凹"
"*\\ 的。要用单个碰撞形状定义凹物体，你需要使用凹碰撞形状。"

msgid ""
"Depending on the object's complexity, you may get better performance by "
"using multiple convex shapes instead of a concave collision shape. Godot "
"lets you use *convex decomposition* to generate convex shapes that roughly "
"match a hollow object. Note this performance advantage no longer applies "
"after a certain amount of convex shapes. For large and complex objects such "
"as a whole level, we recommend using concave shapes instead."
msgstr ""
"根据对象的复杂程度, 可能要通过使用多个凸形而不是一个凹形碰撞形状来获得更好的"
"性能.Godot可以使用 *凸分解* 来生成与空心物体大致匹配的凸形. 请注意, 在一定数"
"量的凸形之后, 就没有了这种性能优势, 对于大而复杂的对象, 如整个关卡, 建议使用"
"凹形代替."

msgid "Concave or trimesh collision shapes"
msgstr "凹面或三面体碰撞形状"

msgid ""
"Even though concave shapes offer the most accurate *collision*, contact "
"reporting can be less precise than primitive shapes."
msgstr "即使凹形提供了最准确的 *碰撞*, 但触碰信息的精度可能不如基础形状."

msgid ""
"When not using TileMaps for level design, concave shapes are the best "
"approach for a level's collision."
msgstr "在不使用 TileMap 进行关卡设计时，凹形是关卡碰撞的最佳方法。"

msgid ""
"You can generate a concave collision shape from the editor by selecting a "
"Sprite2D and using the **Sprite2D** menu at the top of the 2D viewport. The "
"Sprite2D menu dropdown exposes an option called **Create CollisionPolygon2D "
"Sibling**. Once you click it, it displays a menu with 3 settings:"
msgstr ""
"你可以通过选择 Sprite2D，并使用 2D 视口顶部的 **Sprite2D** 菜单，从编辑器生成"
"凹碰撞形状。Sprite2D 菜单下拉菜单显示一个名为 **创建 CollisionPolygon2D 同级"
"节点** 的选项。点击它后，它会显示一个包含 3 个设置的菜单："

msgid ""
"**Simplification:** Higher values will result in a less detailed shape, "
"which improves performance at the cost of accuracy."
msgstr ""
"**简化：**\\ 较高的值将导致形状的细节较少，从而以准确性为代价来提高性能。"

msgid ""
"**Shrink (Pixels):** Higher values will shrink the generated collision "
"polygon relative to the sprite's edges."
msgstr ""
"**收缩（像素）：**\\ 较高的值将使生成的碰撞多边形相对于精灵的边缘收缩。"

msgid ""
"**Grow (Pixels):** Higher values will grow the generated collision polygon "
"relative to the sprite's edges. Note that setting Grow and Shrink to equal "
"values may yield different results than leaving both of them on 0."
msgstr ""
"**增长（像素）：**\\ 数值越大，生成的碰撞多边形就越会相对于精灵边缘增长。需要"
"注意的是，将 “增长 ”和 “收缩 ”设置为相等的值，产生的结果可能会与将它们都设置"
"为 0 的结果不同。"

msgid ""
"If you have an image with many small details, it's recommended to create a "
"simplified version and use it to generate the collision polygon. This can "
"result in better performance and game feel, since the player won't be "
"blocked by small, decorative details."
msgstr ""
"如果你的图片包含许多小细节，建议创建一个简化版本并使用它来生成碰撞多边形。这"
"样可以带来更好的性能表现和游戏体验，因为玩家不会被小小的、装饰性的细节阻碍。"

msgid ""
"To use a separate image for collision polygon generation, create another "
"Sprite2D, generate a collision polygon sibling from it then remove the "
"Sprite2D node. This way, you can exclude small details from the generated "
"collision."
msgstr ""
"要使用单独的图像生成碰撞多边形，可创建另一个 Sprite2D，从中生成一个碰撞多边形"
"的同级节点，然后移除 Sprite2D 节点。这样就可以将小细节排除在生成的碰撞之外。"

msgid "Performance caveats"
msgstr "性能方面的注意事项"

msgid ""
"You aren't limited to a single collision shape per PhysicsBody. Still, we "
"recommend keeping the number of shapes as low as possible to improve "
"performance, especially for dynamic objects like RigidBodies and "
"CharacterBodies. On top of that, avoid translating, rotating, or scaling "
"CollisionShapes to benefit from the physics engine's internal optimizations."
msgstr ""
"每个 PhysicsBody（物理体）不限于一个碰撞形状。尽管如此，我们还是建议尽量减少"
"碰撞形状的数量以提高性能。特别是对于像 RigidBody（刚体）和 CharacterBody（角"
"色体）这样的动态对象。除此之外，避免平移、旋转或缩放碰撞形状，以从物理引擎的"
"内部优化中受益。"

msgid ""
"When using a single non-transformed collision shape in a StaticBody, the "
"engine's *broad phase* algorithm can discard inactive PhysicsBodies. The "
"*narrow phase* will then only have to take into account the active bodies' "
"shapes. If a StaticBody has many collision shapes, the broad phase will "
"fail. The narrow phase, which is slower, must then perform a collision check "
"against each shape."
msgstr ""
"在 StaticBody 中使用单个未变换的碰撞形状时，引擎的\\ *宽相位*\\ 算法可以丢弃"
"不活跃的 PhysicsBody。这个\\ *窄相位*\\ 只需考虑到活跃物体的形状。如果一个 "
"StaticBody 有许多碰撞形状， 那么宽相位就会失败。较慢的窄相位必须对每个形状执"
"行碰撞检查。"

msgid ""
"If you run into performance issues, you may have to make tradeoffs in terms "
"of accuracy. Most games out there don't have a 100% accurate collision. They "
"find creative ways to hide it or otherwise make it unnoticeable during "
"normal gameplay."
msgstr ""
"如果遇到性能问题，你可能需要在准确性方面进行权衡。大多数游戏都没有100%的精确"
"碰撞。他们找到了一些具有创造性的方法来隐藏它，或者在正常的游戏中让它变得不被"
"人注意到。"
