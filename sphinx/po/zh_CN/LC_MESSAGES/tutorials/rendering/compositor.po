#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "The Compositor"
msgstr "合成器"

msgid ""
"The compositor is a new feature in Godot 4 that allows control over the "
"rendering pipeline when rendering the contents of a :ref:`Viewport "
"<class_Viewport>`."
msgstr ""
"合成器是 Godot 4 中的新功能，能够用来控制 :ref:`Viewport <class_Viewport>` 渲"
"染内容时所使用的渲染管线。"

msgid ""
"It can be configured on a :ref:`WorldEnvironment <class_WorldEnvironment>` "
"node where it applies to all Viewports, or it can be configured on a :ref:"
"`Camera3D <class_Camera3D>` and apply only to the Viewport using that camera."
msgstr ""
"它可以在 :ref:`WorldEnvironment <class_WorldEnvironment>` 节点上进行配置，并"
"应用于所有视口；也可以在 :ref:`Camera3D <class_Camera3D>` 上进行配置，并仅应"
"用于使用该相机的视口。"

msgid ""
"The compositor is currently a feature that is only supported by the Mobile "
"and Forward+ renderers."
msgstr "目前只有移动渲染器和 Forward+ 渲染器支持合成器功能。"

msgid "Compositor effects"
msgstr "合成器效果"

msgid ""
"Compositor effects allow you to insert additional logic into the rendering "
"pipeline at various stages. This is an advanced feature that requires a high "
"level of understanding of the rendering pipeline to use to its best "
"advantage."
msgstr ""
"合成器效果允许你在渲染管线的各个阶段插入额外逻辑。这是一项高级功能，需要对渲"
"染管线有很高的理解才能充分利用它。"

msgid ""
"As the core logic of the compositor effect is called from the rendering "
"pipeline it is important to note that this logic will thus run within the "
"thread on which rendering takes place. Care needs to be taken to ensure we "
"don't run into threading issues."
msgstr ""
"由于合成器效果的核心逻辑是从渲染管线调用的，因此需要注意的是，该逻辑将在渲染"
"发生的线程内运行。务必小心，以确保我们不会遇到线程问题。"

msgid ""
"To illustrate how to use compositor effects we'll create a simple post "
"processing effect that allows you to write your own shader code and apply "
"this full screen through a compute shader. You can find the finished demo "
"project `here <https://github.com/godotengine/godot-demo-projects/tree/"
"master/compute/post_shader>`_."
msgstr ""
"为了说明如何使用合成器效果，我们将创建一个简单的后期处理效果，让你可以编写自"
"己的着色器代码并通过计算着色器应用该全屏。你可以在\\ `这里 <https://github."
"com/godotengine/godot-demo-projects/tree/master/compute/post_shader>`_\\ 找到"
"完成的演示项目。"

msgid ""
"We start by creating a new script called ``post_process_shader.gd``. We'll "
"make this a tool script so we can see the compositor effect work in the "
"editor. We need to extend our node from :ref:`CompositorEffect "
"<class_CompositorEffect>`. We must also give our script a class name."
msgstr ""
"首先创建一个名为 ``post_process_shader.gd`` 的新脚本。我们将把它作为一个工具"
"脚本，这样就可以在编辑器中看到合成器效果的工作情况。我们需要从 :ref:"
"`CompositorEffect <class_CompositorEffect>` 扩展我们的节点。还必须为脚本指定"
"一个类名。"

msgid ""
"Next we're going to define a constant for our shader template code. This is "
"the boilerplate code that makes our compute shader work."
msgstr ""
"接下来，我们将为着色器模板代码定义一个常量。这是使计算着色器工作的样板代码。"

msgid ""
"For more information on how compute shaders work, please check :ref:`Using "
"compute shaders <doc_compute_shaders>`."
msgstr ""
"有关计算着色器如何工作的更多信息，请查看《\\ :ref:`使用计算着色器 "
"<doc_compute_shaders>`\\ 》。"

msgid ""
"The important bit here is that for every pixel on our screen, our ``main`` "
"function is executed and inside of this we load the current color value of "
"our pixel, execute our user code, and write our modified color back to our "
"color image."
msgstr ""
"这里重要的一点是，对于屏幕上的每个像素，我们的 ``main`` 函数都会被执行，在其"
"中我们加载像素的当前颜色值，执行用户代码，并将修改后的颜色写回到彩色图像中。"

msgid "``#COMPUTE_CODE`` gets replaced by our user code."
msgstr "``#COMPUTE_CODE`` 应被我们的用户代码替换掉。"

msgid ""
"In order to set our user code, we need an export variable. We'll also define "
"a few script variables we'll be using:"
msgstr "为了用户代码，我们需要一个导出变量。我们还将定义一些将使用的脚本变量："

msgid ""
"Note the use of a :ref:`Mutex <class_Mutex>` in our code. Most of our "
"implementation gets called from the rendering engine and thus runs within "
"our rendering thread."
msgstr ""
"请注意我们代码中 :ref:`Mutex <class_Mutex>` 的使用。我们的大多数实现都是从渲"
"染引擎调用的，因此需在我们的渲染线程中运行。"

msgid ""
"We need to ensure that we set our new shader code, and mark our shader code "
"as dirty, without our render thread accessing this data at the same time."
msgstr ""
"我们需要确保设置新的着色器代码，并将着色器代码标记为脏，同时渲染线程不会访问"
"这些数据。"

msgid "Next we initialize our effect."
msgstr "接下来初始化我们的效果。"

msgid ""
"The main thing here is setting our ``effect_callback_type`` which tells the "
"rendering engine at what stage of the render pipeline to call our code."
msgstr ""
"这里最重要的是设置我们的 ``effect_callback_type``\\ ，它告诉渲染引擎在渲染管"
"线的哪个阶段调用我们的代码。"

msgid ""
"Currently we only have access to the stages of the 3D rendering pipeline!"
msgstr "目前我们只能访问 3D 渲染管线的各个阶段！"

msgid ""
"We also get a reference to our rendering device, which will come in very "
"handy."
msgstr "我们还获得了对渲染设备的引用，这将非常方便。"

msgid ""
"We also need to clean up after ourselves, for this we react to the "
"``NOTIFICATION_PREDELETE`` notification:"
msgstr ""
"我们还需要自己进行清理，为此我们对 ``NOTIFICATION_PREDELETE`` 通知做出反应："

msgid ""
"Note that we do not use our mutex here even though we create our shader "
"inside of our render thread. The methods on our rendering server are thread "
"safe and ``free_rid`` will be postponed cleaning up the shader until after "
"any frames currently being rendered are finished."
msgstr ""
"请注意，即使我们在渲染线程内创建了着色器，我们也不会在此处使用互斥锁。我们的"
"渲染服务器上的方法是线程安全的，并且 ``free_rid`` 将推迟清理着色器，将其推迟"
"到当前正在渲染的所有帧都完成之后。"

msgid ""
"Also note that we are not freeing our pipeline. The rendering device does "
"dependency tracking and as the pipeline is dependent on the shader, it will "
"be automatically freed when the shader is destructed."
msgstr ""
"还要注意，我们无需释放管线。渲染设备会进行依赖跟踪，由于管线依赖于着色器，因"
"此当着色器被销毁时，管线会被自动释放。"

msgid "From this point onwards our code will run on the rendering thread."
msgstr "从此刻起，我们的代码将在渲染线程上运行。"

msgid ""
"Our next step is a helper function that will recompile the shader if the "
"user code was changed."
msgstr "我们的下一步是一个辅助函数，它将在用户代码发生更改时重新编译着色器。"

msgid ""
"At the top of this method we again use our mutex to protect accessing our "
"user shader code and our is dirty flag. We make a local copy of the user "
"shader code if our user shader code is dirty."
msgstr ""
"在这个方法的顶部，我们再次使用互斥锁来保护对用户着色器代码和脏标记的访问。如"
"果我们的用户着色器代码脏了，我们会在本地线程中复制用户着色器代码。"

msgid ""
"If we don't have a new code fragment, we return true if we already have a "
"valid pipeline."
msgstr ""
"如果我们没有新的代码片段，并且我们已经有一个有效的管线，我们就返回 true。"

msgid ""
"If we do have a new code fragment we embed it in our template code and then "
"compile it."
msgstr ""
"如果我们确实有新的代码片段，我们会将其嵌入到我们的模板代码中，然后进行编译。"

msgid ""
"The code shown here compiles our new code in runtime. This is great for "
"prototyping as we can immediately see the effect of the changed shader."
msgstr ""
"此处显示的代码将在运行时中编译我们的新代码。这对于原型设计非常有用，因为我们"
"可以立即看到更改后的着色器的效果。"

msgid ""
"This prevents precompiling and caching this shader which may be an issues on "
"some platforms such as consoles. Note that the demo project comes with an "
"alternative example where a ``glsl`` file contains the entire compute shader "
"and this is used. Godot is able to precompile and cache the shader with this "
"approach."
msgstr ""
"这可以防止预编译和缓存此着色器，这在类似主机的某些平台上可能是一个问题。请注"
"意，演示项目附带了一个替代示例，其中 ``glsl`` 文件包含整个计算着色器，并且使"
"用它。Godot 能够使用此方法预编译和缓存着色器。"

msgid ""
"Finally we need to implement our effect callback, the rendering engine will "
"call this at the right stage of rendering."
msgstr "最后我们需要实现我们的效果回调，渲染引擎将在渲染的正确阶段调用它。"

msgid ""
"At the start of this method we check if we have a rendering device, if our "
"callback type is the correct one, and check if we have our shader."
msgstr ""
"在这个方法开始时，我们检查是否有渲染设备，回调类型是否正确，以及检查是否有着"
"色器。"

msgid ""
"The check for the effect type is only a safety mechanism. We've set this in "
"our ``_init`` function, however it is possible for the user to change this "
"in the UI."
msgstr ""
"检查效果类型只是一种安全机制。我们在 ``_init`` 函数中设置了它，但用户可以在 "
"UI 中更改它。"

msgid ""
"Our ``p_render_data`` parameter gives us access to an object that holds data "
"specific to the frame we're currently rendering. We're currently only "
"interested in our render scene buffers, which provide us access to all the "
"internal buffers used by the rendering engine. Note that we cast this to :"
"ref:`RenderSceneBuffersRD <class_RenderSceneBuffersRD>` to expose the full "
"API to this data."
msgstr ""
"我们的 ``p_render_data`` 参数使我们能够访问一个对象，该对象保存了当前正在渲染"
"的帧的特定数据。我们目前只对我们的渲染场景缓冲区感兴趣，它使我们能够访问渲染"
"引擎使用的所有内部缓冲区。请注意，我们将其转换为 :ref:`RenderSceneBuffersRD "
"<class_RenderSceneBuffersRD>` 以公开此数据的完整 API。"

msgid ""
"Next we obtain our ``internal size`` which is the resolution of our 3D "
"render buffers before they are upscaled (if applicable), upscaling happens "
"after our post processes have run."
msgstr ""
"接下来，我们获得我们的\\ ``内部尺寸``\\ ，即我们的 3D 渲染缓冲区在放大之前的"
"分辨率（如果适用），放大发生在我们的后期处理运行之后。"

msgid ""
"From our internal size we calculate our group size, see our local size in "
"our template shader."
msgstr ""
"根据我们的内部大小，我们计算出我们的分组大小，在我们的模板着色器中查看我们的"
"局部大小。"

msgid ""
"We also populate our push constant so our shader knows our size. Godot does "
"not support structs here **yet** so we use a ``PackedFloat32Array`` to store "
"this data into. Note that we have to pad this array with a 16 byte "
"alignment. In other words, the length of our array needs to be a multiple of "
"4."
msgstr ""
"我们还填充了推送常量，以便着色器知道大小。Godot 暂时\\ **不**\\ 支持结构体，"
"因此我们使用 ``PackedFloat32Array`` 来存储这些数据。请注意，我们必须用 16 字"
"节对齐填充该数组。换句话说，我们的数组长度需要是 4 的倍数。"

msgid ""
"Now we loop through our views, this is in case we're using multiview "
"rendering which is applicable for stereo rendering (XR). In most cases we "
"will only have one view."
msgstr ""
"现在我们循环遍历视图，以防我们使用适用于立体渲染（XR）的多视图渲染。大多数情"
"况下，我们只有一个视图。"

msgid ""
"There is no performance benefit to use multiview for post processing here, "
"handling the views separately like this will still enable the GPU to use "
"parallelism if beneficial."
msgstr ""
"此处使用多视图进行后处理并没有性能优势，像这样单独处理视图仍然可以使 GPU 在有"
"利的情况下使用并行性。"

msgid ""
"Next we obtain the color buffer for this view. This is the buffer into which "
"our 3D scene has been rendered."
msgstr "接下来我们获取该视图的颜色缓冲区。这是我们的 3D 场景被渲染到的缓冲区。"

msgid ""
"We then prepare a uniform set so we can communicate the color buffer to our "
"shader."
msgstr ""
"然后我们准备一个统一的集合，以便我们可以将颜色缓冲区传递给我们的着色器。"

msgid ""
"Note the use of our :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` cache "
"which ensures we can check for our uniform set each frame. As our color "
"buffer can change from frame to frame and our uniform cache will "
"automatically clean up uniform sets when buffers are freed, this is the safe "
"way to ensure we do not leak memory or use an outdated set."
msgstr ""
"请注意我们使用 :ref:`UniformSetCacheRD <class_UniformSetCacheRD>` 缓存，以确"
"保我们可以每帧检查 uniform 集。由于我们的颜色缓冲区可以逐帧更改，并且我们的 "
"uniform 缓存会在缓冲区释放时自动清理 uniform 集，因此这是确保我们不泄漏内存或"
"使用过时集的安全方法。"

msgid ""
"Finally we build our compute list by binding our pipeline, binding our "
"uniform set, pushing our push constant data, and calling dispatch for our "
"groups."
msgstr ""
"最后，我们通过绑定管线、绑定 uniform 集、推送推送常量数据、以及为我们的组调用"
"调度，来构建我们的计算列表。"

msgid ""
"With our compositor effect completed, we now need to add it to our "
"compositor."
msgstr "合成器效果完成后，我们现在需要将其添加到合成器中。"

msgid ""
"On our compositor we expand the compositor effects property and press ``Add "
"Element``."
msgstr "在合成器上，我们扩展合成器效果属性并按 ``Add Element``\\ 。"

msgid "Now we can add our compositor effect:"
msgstr "现在我们可以添加合成器效果："

msgid ""
"After selecting our ``PostProcessShader`` we need to set our user shader "
"code:"
msgstr "选择 ``PostProcessShader`` 后，我们需要设置你的用户着色器代码："

msgid "With that all done, our output is in grayscale."
msgstr "完成这一切后，我们的输出是灰度的。"

msgid ""
"For a more advanced example of post effects, check out the `Radial blur "
"based sky rays <https://github.com/BastiaanOlij/RERadialSunRays>`_ example "
"project created by Bastiaan Olij."
msgstr ""
"有关后期效果的更高级示例，请查看由 Bastiaan Olij 创建的\\ `基于径向模糊的天空"
"光线 <https://github.com/BastiaanOlij/RERadialSunRays>`_\\ 示例项目。"
