#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Multiple resolutions"
msgstr "多分辨率"

msgid "The problem of multiple resolutions"
msgstr "多分辨率问题"

msgid ""
"Developers often have trouble understanding how to best support multiple "
"resolutions in their games. For desktop and console games, this is more or "
"less straightforward, as most screen aspect ratios are 16:9 and resolutions "
"are standard (720p, 1080p, 1440p, 4K, …)."
msgstr ""
"开发人员经常会遇到麻烦, 不知道如何在他们的游戏中最好地支持多种分辨率. 对于桌"
"面和控制台游戏, 这或多或少是简单的, 因为大多数屏幕长宽比是16:9, 分辨率是标准"
"的720p, 1080p, 1440p, 4K,......."

msgid ""
"For mobile games, at first, it was easy. For many years, the iPhone and iPad "
"used the same resolution. When *Retina* was implemented, they just doubled "
"the pixel density; most developers had to supply assets in default and "
"double resolutions."
msgstr ""
"对于手机游戏来说，起初，这很容易。许多年来，iPhone 和 iPad 使用相同的分辨率。"
"当实行 *Retina* 后，他们只是将像素密度提高了一倍；大多数开发商不得不以默认和"
"双倍的分辨率提供资产。"

msgid ""
"Nowadays, this is no longer the case, as there are plenty of different "
"screen sizes, densities, and aspect ratios. Non-conventional sizes are also "
"becoming increasingly popular, such as ultrawide displays."
msgstr ""
"如今, 情况已不再如此, 因为有很多不同的屏幕尺寸, 密度和长宽比. 非传统的尺寸也"
"越来越受欢迎, 如超宽显示屏."

msgid ""
"For 3D games, there is not much of a need to support multiple resolutions "
"(from the aesthetic point of view). The 3D geometry will just fill the "
"screen based on the field of view, disregarding the aspect ratio. The main "
"reason one may want to support this, in this case, is for *performance* "
"reasons (running in lower resolution to increase frames per second)."
msgstr ""
"对于3D游戏来说, 没有太大的必要支持多种分辨率(从审美角度来看).3D几何图形将根据"
"视场填充屏幕, 而不考虑长宽比. 在这种情况下, 人们可能想要支持的主要原因是为了 "
"*性能* 的原因(以较低的分辨率运行以增加每秒的帧数)."

msgid ""
"For 2D and game UIs, this is a different matter, as art needs to be created "
"using specific pixel sizes in software such as Photoshop, GIMP or Krita."
msgstr ""
"对于2D和游戏UI, 这是一个不同的问题, 因为设计需要在Photoshop, GIMP或Krita等软"
"件中使用特定的像素尺寸来创建."

msgid ""
"Since layouts, aspect ratios, resolutions, and pixel densities can change so "
"much, it is no longer possible to design UIs for every specific screen. "
"Another method must be used."
msgstr ""
"由于布局, 长宽比, 分辨率和像素密度会有很大的变化, 因此不再可能为每个特定的屏"
"幕设计UI. 必须使用另一种方法."

msgid "One size fits all"
msgstr "万全之策"

msgid ""
"The most common approach is to use a single *base* resolution and then fit "
"it to everything else. This resolution is how most players are expected to "
"play the game (given their hardware). For mobile, Google has useful `stats "
"<https://developer.android.com/about/dashboards>`_ online, and for desktop, "
"Steam `also does <https://store.steampowered.com/hwsurvey/>`_."
msgstr ""
"最常见的方法是使用一个单一的 *基础* 分辨率, 然后将其适用于其他所有情况. 这个"
"分辨率是大多数玩家预期的玩游戏的方式, 鉴于他们的硬件. 对于移动设备, 谷歌在网"
"上有有用的 `统计资料 <https://developer.android.com/about/dashboards>`__ , 对"
"于桌面设备,Steam `也有 <https://store.steampowered.com/hwsurvey/>`__ ."

msgid ""
"As an example, Steam shows that the most common *primary display resolution* "
"is 1920×1080, so a sensible approach is to develop a game for this "
"resolution, then handle scaling for different sizes and aspect ratios."
msgstr ""
"举个例子,Steam显示最常见的 *主要显示分辨率是* 1920×1080, 所以明智的做法是为这"
"个分辨率开发一个游戏, 然后期处理不同尺寸和长宽比的缩放."

msgid "Godot provides several useful tools to do this easily."
msgstr "Godot 还提供了一系列通用的容器."

msgid ""
"You can see how Godot's support for multiple resolutions works in action "
"using the `Multiple Resolutions and Aspect Ratios demo project <https://"
"github.com/godotengine/godot-demo-projects/tree/master/gui/"
"multiple_resolutions>`__."
msgstr ""
"你可以使用\\ `多分辨率和纵横比演示项目 <https://github.com/godotengine/godot-"
"demo-projects/tree/master/gui/multiple_resolutions>`__\\ ，来了解 Godot 对多"
"分辨率的支持如何实际工作。"

msgid "Base size"
msgstr "基本大小"

msgid ""
"A base size for the window can be specified in the Project Settings under "
"**Display → Window**."
msgstr "窗口的基本尺寸可以在项目设置中的 **Display → Window** 下指定."

msgid ""
"However, what it does is not completely obvious; the engine will *not* "
"attempt to switch the monitor to this resolution. Rather, think of this "
"setting as the \"design size\", i.e. the size of the area that you work with "
"in the editor. This setting corresponds directly to the size of the blue "
"rectangle in the 2D editor."
msgstr ""
"然而, 它的作用并不完全明显; 引擎将 *不* 尝试将显示器切换到此分辨率. 相反, 将"
"此设置视为 \"设计大小\", 即你在编辑器中使用的区域的大小. 此设置直接对应于2D编"
"辑器中蓝色矩形的大小."

msgid ""
"There is often a need to support devices with screen and window sizes that "
"are different from this base size. Godot offers many ways to control how the "
"viewport will be resized and stretched to different screen sizes."
msgstr ""
"通常需要支持具有与该基本大小不同的屏幕和窗口大小的设备. Godot提供了许多方法来"
"控制视口的大小调整和拉伸到不同的屏幕大小."

msgid ""
"On this page, *window* refers to the screen area allotted to your game by "
"the system, while *viewport* refers to the root object (accessible from "
"``get_tree().root``) which the game controls to fill this screen area. This "
"viewport is a :ref:`Window <class_Window>` instance. Recall from the :ref:"
"`introduction <doc_viewports>` that *all* Window objects are viewports."
msgstr ""
"在该页面上，\\ *窗口*\\ 指的是系统分配给你的游戏的屏幕区域，而\\ *视口*\\ 指"
"的是游戏控制以填充该屏幕区域的根对象（可从 ``get_tree().root`` 访问）。该视口"
"是一个 :ref:`Window <class_Window>` 实例。回想一下《\\ :ref:`前言 "
"<doc_viewports>`\\ 》，\\ *所有* Window 对象都是视口。"

msgid ""
"Godot follows a modern approach to multiple resolutions. The engine will "
"never change the monitor's resolution on its own. While changing the "
"monitor's resolution is the most efficient approach, it's also the least "
"reliable approach as it can leave the monitor stuck on a low resolution if "
"the game crashes. This is especially common on macOS or Linux which don't "
"handle resolution changes as well as Windows."
msgstr ""
"Godot遵循了现代多种分辨率的方法. 引擎永远不会自行改变显示器的分辨率. 虽然改变"
"显示器的分辨率是最有效的方法, 但这也是最不可靠的方法, 因为如果游戏崩溃, 它可"
"能会让显示器卡在一个低分辨率上. 这在macOS或Linux上很常见, 因为它们对分辨率变"
"化的处理不如Windows."

msgid ""
"Changing the monitor's resolution also removes any control from the game "
"developer over filtering and aspect ratio stretching, which can be important "
"to ensure correct display for pixel art games."
msgstr ""
"更改显示器的分辨率还会取消游戏开发者对过滤和纵横比拉伸的控制, 这对于确保像素"
"游戏的正确显示画面非常重要."

msgid ""
"On top of that, changing the monitor's resolution makes alt-tabbing in and "
"out of a game much slower since the monitor has to change resolutions every "
"time this is done."
msgstr ""
"最重要的是, 更改显示器的分辨率会使游戏的Alt-Tab键切换速度变慢, 因为每次切换时"
"显示器都必须更改分辨率."

msgid "Resizing"
msgstr "调整大小"

msgid ""
"There are several types of devices, with several types of screens, which in "
"turn have different pixel density and resolutions. Handling all of them can "
"be a lot of work, so Godot tries to make the developer's life a little "
"easier. The :ref:`Viewport <class_Viewport>` node has several functions to "
"handle resizing, and the root node of the scene tree is always a viewport "
"(scenes loaded are instanced as a child of it, and it can always be accessed "
"by calling ``get_tree().root`` or ``get_node(\"/root\")``)."
msgstr ""
"设备有多种类型，其屏幕也有多种类型，而屏幕又具有不同的像素密度和分辨率。处理"
"所有这些可能是一项艰巨的工作，因此 Godot 试图让开发人员的生活更轻松一些。\\ :"
"ref:`Viewport <class_Viewport>` 节点有多个函数来处理调整大小，并且场景树的根"
"节点始终是一个视口（加载的场景实例化为其子节点，并且始终可以通过调用 "
"``get_tree().root`` 或 ``get_node(\"/root\")`` 来访问它）。"

msgid ""
"In any case, while changing the root Viewport params is probably the most "
"flexible way to deal with the problem, it can be a lot of work, code and "
"guessing, so Godot provides a set of parameters in the project settings to "
"handle multiple resolutions."
msgstr ""
"无论如何，虽然更改根视口参数可能是解决问题最灵活的方法，但它可能需要大量的工"
"作、代码和猜测，因此 Godot 在项目设置中提供了一组参数来处理多种分辨率。"

msgid "Stretch settings"
msgstr "拉伸设置"

msgid ""
"Stretch settings are located in the project settings and provide several "
"options:"
msgstr "拉伸设置位于项目设置中, 提供了几个选项:"

msgid "Stretch Mode"
msgstr "拉伸模式"

msgid ""
"The **Stretch Mode** setting defines how the base size is stretched to fit "
"the resolution of the window or screen. The animations below use a \"base "
"size\" of just 16×9 pixels to demonstrate the effect of different stretch "
"modes. A single sprite, also 16×9 pixels in size, covers the entire "
"viewport, and a diagonal :ref:`Line2D <class_Line2D>` is added on top of it:"
msgstr ""
"**拉伸模式**\\ 设置定义了如何拉伸基本大小以适应窗口或屏幕的分辨率。下面的动画"
"使用仅 16×9 像素的“基本大小”来演示不同拉伸模式的效果。同样为 16×9 像素的单个"
"精灵覆盖整个视口，并在其上添加一条对角线 :ref:`Line2D <class_Line2D>`："

msgid ""
"**Stretch Mode = Disabled** (default): No stretching happens. One unit in "
"the scene corresponds to one pixel on the screen. In this mode, the "
"**Stretch Aspect** setting has no effect."
msgstr ""
"**Stretch Mode = Disabled**\\ （默认）：不发生拉伸。场景中的一个单位对应屏幕"
"上的一个像素。在这种模式下，\\ **拉伸纵横比**\\ 设置无效。"

msgid ""
"**Stretch Mode = Canvas Items**: In this mode, the base size specified in "
"width and height in the project settings is stretched to cover the whole "
"screen (taking the **Stretch Aspect** setting into account). This means that "
"everything is rendered directly at the target resolution. 3D is unaffected, "
"while in 2D, there is no longer a 1:1 correspondence between sprite pixels "
"and screen pixels, which may result in scaling artifacts."
msgstr ""
"**Stretch Mode = Canvas Items**\\ ：在这种模式下，项目设置中以宽度和高度指定"
"的基本大小将被拉伸以覆盖整个屏幕（会考虑\\ **拉伸纵横比**\\ 设置）。这意味着"
"所有内容都直接以目标分辨率渲染。3D 不受影响，而在 2D 中，精灵像素和屏幕像素之"
"间不再是 1:1 的对应关系，这可能会导致缩放伪影。"

msgid ""
"**Stretch Mode = Viewport**: Viewport scaling means that the size of the "
"root :ref:`Viewport <class_Viewport>` is set precisely to the base size "
"specified in the Project Settings' **Display** section. The scene is "
"rendered to this viewport first. Finally, this viewport is scaled to fit the "
"screen (taking the **Stretch Aspect** setting into account)."
msgstr ""
"**Stretch Mode = Viewport** : 视口缩放意味着根 :ref:`Viewport "
"<class_Viewport>` 的尺寸被精确地设置为在项目设置的 **Display** 部分指定的基本"
"尺寸. 场景首先被渲染到这个视口. 最后, 这个视口被缩放以适应屏幕(考虑 "
"**Stretch Aspect** 的设置)."

msgid ""
"To configure the stretch mode at runtime from a script, use the ``get_tree()."
"root.content_scale_mode`` property (see :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` and the :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` enum)."
msgstr ""
"要在运行时从脚本配置拉伸模式，请使用 ``get_tree().root.content_scale_mode`` "
"属性（参见 :ref:`Window.content_scale_mode "
"<class_Window_property_content_scale_mode>` 和 :ref:`ContentScaleMode "
"<enum_Window_ContentScaleMode>` 枚举）。"

msgid "Stretch Aspect"
msgstr "拉伸比例"

msgid ""
"The second setting is the stretch aspect. Note that this only takes effect "
"if **Stretch Mode** is set to something other than **Disabled**."
msgstr ""
"第二个设置是拉伸纵横比. 请注意, 只有在 **Stretch Mode** 被设置为 "
"**Disabled** 以外的情况下, 这才会生效."

msgid ""
"In the animations below, you will notice gray and black areas. The black "
"areas are added by the engine and cannot be drawn into. The gray areas are "
"part of your scene, and can be drawn to. The gray areas correspond to the "
"region outside the blue frame you see in the 2D editor."
msgstr ""
"在下面的动画中, 你会注意到灰色和黑色区域. 黑色区域由引擎添加, 无法绘制. 灰色"
"区域是场景的一部分, 可以绘制. 灰色区域对应于你在2D编辑器中看到的蓝色框架外的"
"区域."

msgid ""
"**Stretch Aspect = Ignore**: Ignore the aspect ratio when stretching the "
"screen. This means that the original resolution will be stretched to exactly "
"fill the screen, even if it's wider or narrower. This may result in "
"nonuniform stretching: things looking wider or taller than designed."
msgstr ""
"**Stretch Aspect = Ignore** : 在拉伸屏幕时忽略长宽比. 这意味着原始分辨率将被"
"拉伸以完全填满屏幕, 即使它更宽或更窄. 这可能会导致不均匀的拉伸, 事物看起来比"
"设计的更宽或更高."

msgid ""
"**Stretch Aspect = Keep**: Keep aspect ratio when stretching the screen. "
"This means that the viewport retains its original size regardless of the "
"screen resolution, and black bars will be added to the top/bottom of the "
"screen (\"letterboxing\") or the sides (\"pillarboxing\")."
msgstr ""
"**Stretch Aspect = Keep** : 在拉伸屏幕的时候保持长宽比. 这意味着无论屏幕分辨"
"率如何, 视口都会保留原来的尺寸, 黑条会被添加到屏幕的顶部或底部(\"宽屏模式 \")"
"或侧面(\" 竖屏模式\")."

msgid ""
"This is a good option if you know the aspect ratio of your target devices in "
"advance, or if you don't want to handle different aspect ratios."
msgstr ""
"如果你事先知道目标设备的宽高比, 或者你不想处理不同的宽高比, 这是一个不错的选"
"择."

msgid ""
"**Stretch Aspect = Keep Width**: Keep aspect ratio when stretching the "
"screen. If the screen is wider than the base size, black bars are added at "
"the left and right (pillarboxing). But if the screen is taller than the base "
"resolution, the viewport will be grown in the vertical direction (and more "
"content will be visible to the bottom). You can also think of this as "
"\"Expand Vertically\"."
msgstr ""
"**Stretch Aspect = Keep Width** : 在拉伸屏幕时保持长宽比. 如果屏幕比基本尺寸"
"宽, 则会在左右两边添加黑条(竖屏模式). 但如果屏幕比基本分辨率高, 视口将在垂直"
"方向上增长(更多的内容将在底部可见). 你也可以把它看作是 \"垂直扩展\" ."

msgid ""
"This is usually the best option for creating GUIs or HUDs that scale, so "
"some controls can be anchored to the bottom (:ref:`doc_size_and_anchors`)."
msgstr ""
"这通常是创建可扩展的GUI或HUD的最佳选择, 因此一些控件可以锚定到底部( :ref:"
"`doc_size_and_anchors`)."

msgid ""
"**Stretch Aspect = Keep Height**: Keep aspect ratio when stretching the "
"screen. If the screen is taller than the base size, black bars are added at "
"the top and bottom (letterboxing). But if the screen is wider than the base "
"resolution, the viewport will be grown in the horizontal direction (and more "
"content will be visible to the right). You can also think of this as "
"\"Expand Horizontally\"."
msgstr ""
"**Stretch Aspect = Keep Height** : 在拉伸屏幕时保持长宽比. 如果屏幕比基本尺寸"
"高, 则会在顶部和底部添加黑条(宽屏模式). 但如果屏幕比基本分辨率宽, 视口将在水"
"平方向上增长(更多的内容将在右边可见). 你也可以把它看作是 \"水平扩展\" ."

msgid ""
"This is usually the best option for 2D games that scroll horizontally (like "
"runners or platformers)."
msgstr "这通常是水平滚动的2D游戏的最佳选择(如跑步者或平台游戏者)."

msgid ""
"**Stretch Aspect = Expand**: Keep aspect ratio when stretching the screen, "
"but keep neither the base width nor height. Depending on the screen aspect "
"ratio, the viewport will either be larger in the horizontal direction (if "
"the screen is wider than the base size) or in the vertical direction (if the "
"screen is taller than the original size)."
msgstr ""
"**Stretch Aspect = Expand** : 在拉伸屏幕时保持长宽比, 但既不保持基本宽度也不"
"保持高度. 根据屏幕的长宽比, 视口将在水平方向(如果屏幕比基本尺寸宽)或垂直方向"
"上变大(如果屏幕比原始尺寸高)."

msgid ""
"To support both portrait and landscape mode with a similar automatically "
"determined scale factor, set your project's base resolution to be a *square* "
"(1:1 aspect ratio) instead of a rectangle. For instance, if you wish to "
"design for 1280×720 as the base resolution but wish to support both portrait "
"and landscape mode, use 720×720 as the project's base window size in the "
"Project Settings."
msgstr ""
"为了以类似的自动确定的比例系数支持纵向和横向模式，请将你的项目的基本分辨率设"
"置为 *方形* （1:1长宽比）而不是矩形。例如，如果你希望以1280×720为基本分辨率进"
"行设计，但又希望同时支持纵向和横向模式，那么在项目设置中使用720×720作为项目的"
"基本窗口尺寸。"

msgid ""
"To configure the stretch aspect at runtime from a script, use the "
"``get_tree().root.content_scale_aspect`` property (see :ref:`Window."
"content_scale_aspect <class_Window_property_content_scale_aspect>` and the :"
"ref:`ContentScaleAspect <enum_Window_ContentScaleAspect>` enum)."
msgstr ""
"要在运行时从脚本配置拉伸纵横比，请使用 ``get_tree().root."
"content_scale_aspect`` 属性（参见 :ref:`Window.content_scale_aspect "
"<class_Window_property_content_scale_aspect>` 和 :ref:`ContentScaleAspect "
"<enum_Window_ContentScaleAspect>` 枚举）。"

msgid "Stretch Scale"
msgstr "拉伸缩放"

msgid ""
"The **Scale** setting allows you to add an extra scaling factor on top of "
"what the **Stretch** options above already provide. The default value of "
"``1.0`` means that no additional scaling occurs."
msgstr ""
"**设置**\\ 设置允许你在上面\\ **拉伸**\\ 选项已提供的内容之上添加额外的缩放系"
"数。默认值 ``1.0`` 意味着不会发生额外的缩放。"

msgid ""
"For example, if you set **Scale** to ``2.0`` and leave **Stretch Mode** on "
"**Disabled**, each unit in your scene will correspond to 2×2 pixels on the "
"screen. This is a good way to provide scaling options for non-game "
"applications."
msgstr ""
"例如，如果你将 **Scale** 设置为 ``2.0`` 并将 **Stretch Mode** 保留为 "
"**Disabled**\\ ，则场景中的每个单元将对应屏幕上的 2×2 像素。这是为非游戏应用"
"程序提供缩放选项的好方式。"

msgid ""
"If **Stretch Mode** is set to **canvas_items**, 2D elements will be scaled "
"relative to the base window size, then multiplied by the **Scale** setting. "
"This can be exposed to players to allow them to adjust the automatically "
"determined scale to their liking, for better accessibility."
msgstr ""
"如果将 **Stretch Mode** 设置为 **canvas_items**\\ ，2D 元素将相对于基本窗口大"
"小进行缩放，然后乘以 **Scale** 设置。这可以向玩家公开，以允许他们根据自己的喜"
"好调整自动确定的比例，从而获得更好的可访问性。"

msgid ""
"If **Stretch Mode** is set to **viewport**, the viewport's resolution is "
"divided by **Scale**. This makes pixels look larger and reduces rendering "
"resolution (with a given window size), which can improve performance."
msgstr ""
"如果将 **Stretch Mode** 设置为 **viewport**\\ ，则视口的分辨率将除以 "
"**Scale**\\ 。这会使像素看起来更大，并降低渲染分辨率（在给定窗口大小的情况"
"下），从而可以提高性能。"

msgid ""
"To configure the stretch scale at runtime from a script, use the "
"``get_tree().root.content_scale_factor`` property (see :ref:`Window."
"content_scale_factor <class_Window_property_content_scale_factor>`)."
msgstr ""
"要从脚本在运行时配置拉伸比例，请使用 ``get_tree().root."
"content_scale_factor`` 属性（参见 :ref:`Window.content_scale_factor "
"<class_Window_property_content_scale_factor>`\\ ）。"

msgid "Stretch Scale Mode"
msgstr "拉伸缩放模式"

msgid ""
"Since Godot 4.2, the **Stretch Scale Mode** setting allows you to constrain "
"the automatically determined scale factor (as well as the manually specified "
"**Stretch Scale** setting) to integer values. By default, this setting is "
"set to ``fractional``, which allows any scale factor to be applied "
"(including fractional values such as ``2.5``). When set to ``integer``, the "
"value is rounded down to the nearest integer. For example, instead of using "
"a scale factor of ``2.5``, it would be rounded down to ``2.0``. This is "
"useful to prevent distortion when displaying pixel art."
msgstr ""
"自 Godot 4.2 起，\\ **拉伸比例模式**\\ 设置允许你将自动确定的比例系数（以及手"
"动指定的\\ **拉伸比例**\\ 设置）限制为整数值。默认情况下，该设置设置为 "
"``fractional``\\ ，允许应用任何比例系数（包括如 ``2.5`` 等小数值）。设置为 "
"``integer`` 时，该值将向下舍入为最接近的整数。例如，不使用比例系数 "
"``2.5``\\ ，而是向下舍入为 ``2.0``\\ 。这对于防止显示像素艺术时出现失真很有"
"用。"

msgid ""
"Compare this pixel art which is displayed with the ``viewport`` stretch "
"mode, with the stretch scale mode set to ``fractional``:"
msgstr ""
"比较使用 ``viewport`` 拉伸模式显示的像素艺术，其拉伸比例模式设置为 "
"``fractional``\\ ："

msgid "Fractional scaling example (incorrect pixel art appearance)"
msgstr "小数缩放示例（像素画显示异常）"

msgid ""
"Checkerboard doesn't look \"even\". Line widths in the logo and text varies "
"wildly."
msgstr "棋盘看上去并不“均匀”。徽标和文本中的线宽也存在大幅变化。"

msgid ""
"This pixel art is also displayed with the ``viewport`` stretch mode, but the "
"stretch scale mode is set to ``integer`` this time:"
msgstr ""
"该像素艺术也以 ``viewport`` 拉伸模式显示，但这次拉伸比例模式设置为 "
"``integer``\\ ："

msgid "Integer scaling example (correct pixel art appearance)"
msgstr "整数缩放示例（像素画正确显示）"

msgid "Checkerboard looks perfectly even. Line widths are consistent."
msgstr "棋盘看上去就非常均匀了。线宽也是一致的。"

msgid ""
"For example, if your viewport base size is 640×360 and the window size is "
"1366×768:"
msgstr "打个比方，如果视口的基础大小为 640×360 而窗口大小为 1366×768："

msgid ""
"When using ``fractional``, the viewport is displayed at a resolution of "
"1366×768 (scale factor is roughly 2.133×). The entire window space is used. "
"Each pixel in the viewport corresponds to 2.133×2.133 pixels in the "
"displayed area. However, since displays can only display \"whole\" pixels, "
"this will lead to uneven pixel scaling which results in incorrect appearance "
"of pixel art."
msgstr ""
"使用 ``fractional`` 时，视口会以 1366×768 的分辨率显示（缩放系数大约是 "
"2.133×），占用整个屏幕空间。视口中的每个像素都对应 2.133×2.133 像素的显示区"
"域。不过因为显示器只能显示“完整”的像素，就会导致不均匀的像素缩放，造成像素画"
"的显示异常。"

msgid ""
"When using ``integer``, the viewport is displayed at a resolution of "
"1280×720 (scale factor is 2×). The remaining space is filled with black bars "
"on all four sides, so that each pixel in the viewport corresponds to 2×2 "
"pixels in the displayed area."
msgstr ""
"使用 ``integer`` 时，视口会以 1280×720 的分辨率显示（缩放系数为 2×）。四周的"
"剩余空间使用黑条填充，这样视口中的每个像素都对应 2×2 像素的显示区域。"

msgid ""
"This setting is effective with any stretch mode. However, when using the "
"``disabled`` stretch mode, it will only affect the **Stretch Scale** setting "
"by rounding it *down* to the nearest integer value. This can be used for 3D "
"games that have a pixel art UI, so that the visible area in the 3D viewport "
"doesn't reduce in size (which occurs when using ``canvas_items`` or "
"``viewport`` stretch mode with the ``integer`` scale mode)."
msgstr ""
"这个设置在所有拉伸模式下均会生效。不过使用 ``disabled`` 拉伸模式时只会影响\\ "
"**拉伸缩放**\\ 设置，将其\\ **向下**\\ 取整。可用于使用像素风 UI 的 3D 游戏，"
"此时 3D 视口的可见区域并不会减少（而在 ``canvas_items`` 和 ``viewport`` 拉伸"
"模式下启用 ``integer`` 缩放模式时就会减少）。"

msgid ""
"Games should use the **Exclusive Fullscreen** window mode, as opposed to "
"**Fullscreen** which is designed to prevent Windows from automatically "
"treating the window as if it was exclusive fullscreen."
msgstr ""
"游戏应该使用\\ **独占全屏**\\ 窗口模式，而不是\\ **全屏**\\ ，后者旨在防止 "
"Windows 自动将窗口视为独占全屏。"

msgid ""
"**Fullscreen** is meant to be used by GUI applications that want to use per-"
"pixel transparency without a risk of having it disabled by the OS. It "
"achieves this by leaving a 1-pixel line at the bottom of the screen. By "
"contrast, **Exclusive Fullscreen** uses the actual screen size and allows "
"Windows to reduce jitter and input lag for fullscreen games."
msgstr ""
"**全屏**\\ 旨在供想要使用每像素透明度而又不存在被操作系统禁用的风险的 GUI 应"
"用程序使用。它通过在屏幕底部留下一条 1 像素的线来实现这一点。相比之下，\\ **"
"独占全屏**\\ 使用实际屏幕大小，并允许 Windows 减少全屏游戏的抖动和输入延迟。"

msgid ""
"When using integer scaling, this is particularly important as the 1-pixel "
"height reduction from the **Fullscreen** mode can cause integer scaling to "
"use a smaller scale factor than expected."
msgstr ""
"当使用整数缩放时，这一点尤为重要，因为\\ **全屏**\\ 模式下 1 像素的高度减少可"
"能导致整数缩放使用比预期更小的比例系数。"

msgid "Common use case scenarios"
msgstr "常见使用场景"

msgid ""
"The following settings are recommended to support multiple resolutions and "
"aspect ratios well."
msgstr "如果要适配多种分辨率和纵横比，推荐使用以下设置。"

msgid "Desktop game"
msgstr "桌面游戏"

msgid "**Non-pixel art:**"
msgstr "**非像素风：**"

msgid ""
"Set the base window width to ``1920`` and window height to ``1080``. If you "
"have a display smaller than 1920×1080, set **Window Width Override** and "
"**Window Height Override** to lower values to make the window smaller when "
"the project starts."
msgstr ""
"将基础窗口宽度设置为 ``1920``\\ 、窗口高度设置为 ``1080``\\ 。如果你的显示器"
"小于 1920×1080，请将\\ **窗口宽度覆盖**\\ 和\\ **窗口高度覆盖**\\ 设置为较小"
"的值，项目启动时就会将窗口调小。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``3840`` and window height to ``2160``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``3840``\\ 、窗口"
"高度设置为 ``2160``\\ 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占"
"用和文件大小换取更清晰的画面。注意，这样做会让未做 mipmap 的纹理在低分辨率设"
"备上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

msgid "Set the stretch mode to ``canvas_items``."
msgstr "将拉伸模式设置为 ``canvas_items``\\ （画布项）。"

msgid ""
"Set the stretch aspect to ``expand``. This allows for supporting multiple "
"aspect ratios and makes better use of tall smartphone displays (such as 18:9 "
"or 19:9 aspect ratios)."
msgstr ""
"将拉伸比例设置为 ``expand`` （扩展）。这样可以支持多种分辨率，并且能够更好地"
"利用较长的智能手机屏幕（例如 18:9 和 19:9 的长宽比）。"

msgid ""
"Configure Control nodes' anchors to snap to the correct corners using the "
"**Layout** menu."
msgstr "使用\\ **布局**\\ 菜单将 Control 节点的锚点吸附到正确的角落。"

msgid "**Pixel art:**"
msgstr "**像素风：**"

msgid ""
"Set the base window size to the viewport size you intend to use. Most pixel "
"art games use viewport sizes between 256×224 and 640×480. 640×360 is a good "
"baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 "
"without any black bars when using integer scaling. Higher viewport sizes "
"will require using higher resolution artwork, unless you intend to show more "
"of the game world at a given time."
msgstr ""
"将基础窗口大小设置为你想要使用的视口尺寸。大多数像素风游戏使用的视口尺寸在 "
"256×224 和 640×480 之间。640×360 是不错的基准，因为使用整数缩放时无论是缩放"
"到 1280×720、1920×1080、2560×1440 还是 3840×2160 都不会出现黑条。视口尺寸越"
"大，所需资产的分辨率也就越高，除非你想要能够显示更大的游戏世界区域。"

msgid "Set the stretch mode to ``viewport``."
msgstr "将拉伸模式设置为 ``viewport``\\ （视口）。"

msgid ""
"Set the stretch aspect to ``keep`` to enforce a single aspect ratio (with "
"black bars). As an alternative, you can set the stretch aspect to ``expand`` "
"to support multiple aspect ratios."
msgstr ""
"将拉伸比例设置为 ``keep``\\ （保持）可以（通过添加黑条的方式）强制使用固定的"
"长宽比。如果你想支持不同长宽比的话，也可以把拉伸模式设置为 ``expand``\\ （扩"
"展）。"

msgid ""
"If using the ``expand`` stretch aspect, Configure Control nodes' anchors to "
"snap to the correct corners using the **Layout** menu."
msgstr ""
"如果选用 ``expand`` 拉伸比例，使用\\ **布局**\\ 菜单将 Control 节点的锚点吸附"
"到正确的角落。"

msgid ""
"Set the stretch scale mode to ``integer``. This prevents uneven pixel "
"scaling from occurring, which makes pixel art not display as intended."
msgstr ""
"将拉伸缩放模式设置为 ``integer``\\ 。这样就能够防止出现非整数倍的像素缩放，让"
"像素画保持原样显示。"

msgid ""
"The ``viewport`` stretch mode provides low-resolution rendering that is then "
"stretched to the final window size. If you are OK with sprites being able to "
"move or rotate in \"sub-pixel\" positions or wish to have a high resolution "
"3D viewport, you should use the ``canvas_items`` stretch mode instead of the "
"``viewport`` stretch mode."
msgstr ""
"``viewport`` 拉伸模式会先以较低分辨率渲染，然后拉伸到最终窗口的大小。如果你能"
"够接受精灵可以移动或者旋转到“次像素”位置，或者希望有高分辨率的 3D 视图，可以"
"把 ``viewport`` 拉伸模式换成 ``canvas_items`` 模式。"

msgid "Mobile game in landscape mode"
msgstr "横屏的手机游戏"

msgid ""
"Godot is configured to use landscape mode by default. This means you don't "
"need to change the display orientation project setting."
msgstr "Godot 默认使用横屏模式，所以你无需在项目设置中调整显示方向。"

msgid "Set the base window width to ``1280`` and window height to ``720``."
msgstr "将基础窗口宽度设置为 ``1280``\\ ，窗口高度设置为 ``720``\\ 。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1920`` and window height to ``1080``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``1920``\\ 、窗口"
"高度设置为 ``1080``\\ 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占"
"用和文件大小换取更清晰的画面。很多设备拥有更高分辨率的显示屏（1440p），但因为"
"智能手机的屏幕比较小，所以很难看出和 1080p 的区别。注意，这样做会让未做 "
"mipmap 的纹理在低分辨率设备上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 4:3 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``1280`` and the "
"base window height to ``960``."
msgstr ""
"为了更好地支持平板和折叠屏手机（这些设备的显示器纵横比通常接近 4:3），请在按"
"照其他步骤操作时考虑使用纵横比为 4:3 的基础分辨率。例如可以将基础窗口宽度设置"
"为 ``1280``\\ 、基础窗口高度设置为 ``960``\\ 。"

msgid "Mobile game in portrait mode"
msgstr "竖屏的手机游戏"

msgid "Set the base window width to ``720`` and window height to ``1280``."
msgstr "将基础窗口宽度设置为 ``720``\\ 、窗口高度设置为 ``1280``\\ 。"

msgid ""
"Alternatively, if you're targeting high-end devices primarily, set the base "
"window width to ``1080`` and window height to ``1920``. This allows you to "
"provide higher resolution 2D assets, resulting in crisper visuals at the "
"cost of higher memory usage and file sizes. Many devices have even higher "
"resolution displays (1440p), but the difference with 1080p is barely visible "
"given the small size of smartphone displays. Note that this will make non-"
"mipmapped textures grainy on low resolution devices, so make sure to follow "
"the instructions described in :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling`."
msgstr ""
"或者如果你主要针对的是高端设备，那么就把基础窗口宽度设置为 ``1080``\\ 、窗口"
"高度设置为 ``1920``\\ 。这样你就可以提供更高分辨率的 2D 资产，用更高的内存占"
"用和文件大小换取更清晰的画面。很多设备拥有更高分辨率的显示屏（1440p），但因为"
"智能手机的屏幕比较小，所以很难看出和 1080p 的区别。注意，这样做会让未做 "
"mipmap 的纹理在低分辨率设备上具有颗粒感，请参考 :ref:"
"`doc_multiple_resolutions_reducing_aliasing_on_downsampling` 进行操作。"

msgid "Set **Display > Window > Handheld > Orientation** to ``portrait``."
msgstr "将\\ **显示 > 窗口 > 手持 > 朝向**\\ 设置为 ``portrait``\\ （竖屏）。"

msgid ""
"To better support tablets and foldable phones (which frequently feature "
"displays with aspect ratios close to 4:3), consider using a base resolution "
"that has a 3:4 aspect ratio while following the rest of the instructions "
"here. For instance, you can set the base window width to ``960`` and the "
"base window height to ``1280``."
msgstr ""
"为了更好地支持平板和折叠屏手机（这些设备的显示器纵横比通常接近 4:3），请在按"
"照其他步骤操作时考虑使用纵横比为 3:4 的基础分辨率。例如可以将基础窗口宽度设置"
"为 ``960``\\ 、基础窗口高度设置为 ``1280``\\ 。"

msgid "Non-game application"
msgstr "非游戏应用"

msgid ""
"Set the base window width and height to the smallest window size that you "
"intend to target. This is not required, but this ensures that you design "
"your UI with small window sizes in mind."
msgstr ""
"将基础窗口宽高设置为你想要支持的最小窗口尺寸。这不是必须的，但是可以保证你在"
"设计 UI 时考虑较小的窗口尺寸。"

msgid "Keep the stretch mode to its default value, ``disabled``."
msgstr "保持拉伸模式为默认值 ``disabled``\\ （禁用）。"

msgid ""
"Keep the stretch aspect to its default value, ``ignore`` (its value won't be "
"used since the stretch mode is ``disabled``)."
msgstr ""
"保持拉伸比例为默认值 ``ignore``\\ （因为拉伸模式是 ``disabled``\\ ，所以这里"
"的值不会被用到）。"

msgid ""
"You can define a minimum window size by calling ``get_window()."
"set_min_size()`` in a script's ``_ready()`` function. This prevents the user "
"from resizing the application below a certain size, which could break the UI "
"layout."
msgstr ""
"你可以通过在脚本的 ``_ready()`` 函数中调用 ``get_window().set_min_size()`` 来"
"定义最小窗口大小。这可以防止用户将应用程序调整到低于某个大小，否则可能会破坏 "
"UI 布局。"

msgid ""
"Godot doesn't support manually overriding the 2D scale factor yet, so it is "
"not possible to have hiDPI support in non-game applications. Due to this, it "
"is recommended to leave **Allow Hidpi** disabled in non-game applications to "
"allow for the OS to use its low-DPI fallback."
msgstr ""
"Godot 尚未支持手动设置 2D 缩放比例，所以无法在非游戏应用中支持 hiDPI。因此，"
"推荐为非游戏应用禁用 **Allow Hidpi** 选项，操作系统会回退到低 DPI。"

msgid "hiDPI support"
msgstr "支持 hiDPI 高分辨率屏幕"

msgid ""
"By default, Godot projects are considered DPI-aware by the operating system. "
"This is controlled by the **Display > Window > Dpi > Allow Hidpi** project "
"setting, which should be left enabled whenever possible. Disabling DPI "
"awareness can break fullscreen behavior on Windows."
msgstr ""
"默认情况下，操作系统会将 Godot 项目视为 DPI 感知项目。这由\\ **显示 > 窗口 > "
"DPI > 允许 HiDPI**\\ 项目设置控制，该设置应尽可能保持启用状态。禁用 DPI 感知"
"可能会破坏在 Windows 上的全屏行为。"

msgid ""
"Since Godot projects are DPI-aware, they may appear at a very small window "
"size when launching on an hiDPI display (proportionally to the screen "
"resolution). For a game, the most common way to work around this issue is to "
"make them fullscreen by default. Alternatively, you could set the window "
"size in an :ref:`autoload <doc_singletons_autoload>`'s ``_ready()`` function "
"according to the screen size."
msgstr ""
"由于 Godot 项目具有 DPI 感知能力，因此在 hiDPI 显示器上启动时，它们可能会以非"
"常小的窗口大小显示（与屏幕分辨率成比例）。对于游戏，解决该问题的最常见方法是"
"默认将它们设置为全屏。或者，你可以根据屏幕大小在\\ :ref:`自动加载 "
"<doc_singletons_autoload>`\\ 的 ``_ready()`` 函数中设置窗口大小。"

msgid "To ensure 2D elements don't appear too small on hiDPI displays:"
msgstr "为了确保 2D 元素在 hiDPI 显示屏上不会显得太小："

msgid ""
"For games, use the ``canvas_items`` or ``viewport`` stretch modes so that 2D "
"elements are automatically resized according to the current window size."
msgstr ""
"对于游戏，使用 ``canvas_items`` 或 ``viewport`` 拉伸模式，以便 2D 元素根据当"
"前窗口大小自动调整大小。"

msgid ""
"For non-game applications, use the ``disabled`` stretch mode and set the "
"stretch scale to a value corresponding to the display scale factor in an :"
"ref:`autoload <doc_singletons_autoload>`'s ``_ready()`` function. The "
"display scale factor is set in the operating system's settings and can be "
"queried using :ref:"
"`screen_get_scale<class_DisplayServer_method_screen_get_scale>`. This method "
"is currently only implemented on macOS. On other operating systems, you will "
"need to implement a method to guess the display scale factor based on the "
"screen resolution (with a setting to let the user override this if needed). "
"This is the approach currently used by the Godot editor."
msgstr ""
"对于非游戏应用程序，请使用 ``disabled`` 拉伸模式，并在 :ref:`autoload "
"<doc_singletons_autoload>` 的 ``_ready()`` 函数中将拉伸比例设置为与显示比例系"
"数相对应的值。显示比例系数在操作系统的设置中设置，可以使用 :ref:"
"`screen_get_scale<class_DisplayServer_method_screen_get_scale>` 进行查询。该"
"方法目前仅在 macOS 上实现。在其他操作系统上，你需要实现一种方法来根据屏幕分辨"
"率猜测显示比例系数（使用设置让用户在需要时覆盖该设置）。这是 Godot 编辑器当前"
"使用的方法。"

msgid ""
"The **Allow Hidpi** setting is only effective on Windows and macOS. It's "
"ignored on all other platforms."
msgstr ""
"**允许 HiDPI** 设置仅在 Windows 和 macOS 上有效。所有其他平台都会忽略该设置。"

msgid ""
"The Godot editor itself is always marked as DPI-aware. Running the project "
"from the editor will only be DPI-aware if **Allow Hidpi** is enabled in the "
"Project Settings."
msgstr ""
"Godot 编辑器本身是打开了这个选项，与 DPI 相关的。但在编辑器中运行项目时，只有"
"在项目设置里启用 **Allow Hidpi** 才会让项目与 DPI 相关。"

msgid "Reducing aliasing on downsampling"
msgstr "减少缩减取样的混叠"

msgid ""
"If the game has a very high base resolution (e.g. 3840×2160), aliasing might "
"appear when downsampling to something considerably lower like 1280×720."
msgstr ""
"如果游戏的基本分辨率很高（如 3840×2160），当采样降到相当低的分辨率（如 "
"1280×720）时，可能会出现锯齿。"

msgid "Handling aspect ratios"
msgstr "处理纵横比"

msgid ""
"Once scaling for different resolutions is accounted for, make sure that your "
"*user interface* also scales for different aspect ratios. This can be done "
"using :ref:`anchors <doc_size_and_anchors>` and/or :ref:`containers "
"<doc_gui_containers>`."
msgstr ""
"一旦考虑到不同分辨率的缩放, 请确保你的 *user interface* 也能为不同的长宽比进"
"行缩放. 这可以使用 :ref:`anchors <doc_size_and_anchors>` 和/或 :ref:"
"`containers <doc_gui_containers>` 来完成."

msgid "Field of view scaling"
msgstr "视场角缩放"

msgid ""
"The 3D Camera node's **Keep Aspect** property defaults to the **Keep "
"Height** scaling mode (also called *Hor+*). This is usually the best value "
"for desktop games and mobile games in landscape mode, as widescreen displays "
"will automatically use a wider field of view."
msgstr ""
"3D相机节点的 **Keep Aspect** 属性默认为 **Keep Height** 缩放模式(也称为 "
"*Hor+* ). 在横屏模式下, 这通常是桌面游戏和手机游戏的最佳选择, 因为宽屏显示器"
"会自动使用更宽的视野."

msgid ""
"However, if your 3D game is intended to be played in portrait mode, it may "
"make more sense to use **Keep Width** instead (also called *Vert-*). This "
"way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use "
"a *taller* field of view, which is more logical here."
msgstr ""
"然而, 如果你的3D游戏打算使用纵向模式, 那么使用 **Keep Width保持宽度** 称为"
"( *Vert-* )可能会更有意义. 这样, 宽高比大于16:9(例如19:9)的智能手机将使用 *更"
"高* 的视野, 这在这里更符合逻辑."

msgid "Scaling 2D and 3D elements differently using Viewports"
msgstr "使用 Viewport 以不同的方式缩放 2D 和 3D 元素"

msgid ""
"Using multiple Viewport nodes, you can have different scales for various "
"elements. For instance, you can use this to render the 3D world at a low "
"resolution while keeping 2D elements at the native resolution. This can "
"improve performance significantly while keeping the HUD and other 2D "
"elements crisp."
msgstr ""
"使用多个视图窗口节点, 可以对不同的元素使用不同的比例. 例如, 你可以使用此选项"
"以低分辨率渲染3D世界, 同时将2D元素保持在原生分辨率. 这可以显著提高性能, 同时"
"保持HUD和其他2D元素的清晰度."

msgid ""
"This is done by using the root Viewport node only for 2D elements, then "
"creating a Viewport node to display the 3D world and displaying it using a "
"SubViewportContainer or TextureRect node. There will effectively be two "
"viewports in the final project. One upside of using TextureRect over "
"SubViewportContainer is that it allows enable linear filtering. This makes "
"scaled 3D viewports look better in many cases."
msgstr ""
"这是通过仅对 2D 元素使用根 Viewport 节点，然后创建一个 Viewport 节点来显示 "
"3D 世界，并使用 SubViewportContainer 或 TextureRect 节点显示该 Viewport 节点"
"来实现的。最终项目中实际上会有两个视口。使用 TextureRect 而不是 "
"SubViewportContainer 的一个好处是它允许启用线性过滤。这会使缩放的 3D 视口在许"
"多情况下看起来更好。"

msgid ""
"See the `3D viewport scaling demo <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ for examples."
msgstr ""
"有关示例, 请参见 `3D 视口缩放演示 <https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport/3d_scaling>`__ ."
