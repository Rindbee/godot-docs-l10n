#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Using Viewports"
msgstr "使用视口"

msgid "Introduction"
msgstr "前言"

msgid ""
"Think of a :ref:`Viewport <class_Viewport>` as a screen onto which the game "
"is projected. In order to see the game, we need to have a surface on which "
"to draw it. That surface is the Root Viewport."
msgstr ""
"将视口 :ref:`Viewport <class_Viewport>` 想象为展示游戏画面的屏幕。为了看到游"
"戏，我们需要首先在一块表面上绘制游戏。这块表面就是“根视口”。"

msgid ""
":ref:`SubViewports <class_SubViewport>` are a kind of Viewport that can be "
"added to the scene so that there are multiple surfaces to draw on. When we "
"are drawing to a SubViewport, we call it a render target. We can access the "
"contents of a render target by accessing its corresponding :ref:`texture "
"<class_Viewport_method_get_texture>`. By using a SubViewport as render "
"target, we can either render multiple scenes simultaneously or we can render "
"to a :ref:`ViewportTexture <class_ViewportTexture>` which is applied to an "
"object in the scene, for example a dynamic skybox."
msgstr ""
":ref:`SubViewport <class_SubViewport>` 是子视口节点，这也是一种 Viewport，能"
"够在场景中添加，这样我们就有了多个可以用来绘图的表面。如果我们在 SubViewport "
"上绘图，那这个子视口就叫做“渲染目标”。我们可以通过对应的 :ref:`texture "
"<class_Viewport_method_get_texture>` 来访问渲染目标的内容。使用 SubViewport "
"作为渲染目标，我们就可以同时渲染多个场景，也可以将画面渲染到视口纹理 :ref:"
"`ViewportTexture <class_ViewportTexture>` 上，从而在场景中的物体上显示，实现"
"动态天空盒之类的效果。"

msgid ""
":ref:`SubViewports <class_SubViewport>` have a variety of use cases, "
"including:"
msgstr ":ref:`SubViewport <class_SubViewport>` 的用处有很多，包括："

msgid "Rendering 3D objects within a 2D game"
msgstr "在2D游戏中渲染3D物体"

msgid "Rendering 2D elements in a 3D game"
msgstr "在3D游戏中渲染2D元素"

msgid "Rendering dynamic textures"
msgstr "渲染动态纹理"

msgid "Generating procedural textures at runtime"
msgstr "在运行时生成程序式纹理"

msgid "Rendering multiple cameras in the same scene"
msgstr "在同一场景中渲染多个摄像机"

msgid ""
"What all these use cases have in common is that you are given the ability to "
"draw objects to a texture as if it were another screen and can then choose "
"what to do with the resulting texture."
msgstr ""
"所有这些用例的共同点是, 你被赋予了在纹理上绘制物体的能力, 就好像它是另一个屏"
"幕一样, 然后可以选择如何处理产生的纹理."

msgid "Input"
msgstr "输入"

msgid ""
":ref:`Viewports <class_Viewport>` are also responsible for delivering "
"properly adjusted and scaled input events to their children nodes. By "
"default :ref:`SubViewports <class_SubViewport>` don't automatically receive "
"input, unless they receive it from their direct :ref:`SubViewportContainer "
"<class_SubViewportContainer>` parent node. In this case, input can be "
"disabled with the :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` property."
msgstr ""
":ref:`Viewport <class_Viewport>` 还负责向其子节点传递经过适当调整和缩放的输入"
"事件。默认情况下，:ref:`SubViewport <class_SubViewport>` 不会自动接收输入，除"
"非它们从其直接 :ref:`SubViewportContainer <class_SubViewportContainer>` 父节"
"点接收输入。在这种情况下，可以使用 :ref:`Disable Input "
"<class_Viewport_property_gui_disable_input>` 属性来禁用输入。"

msgid ""
"For more information on how Godot handles input, please read the :ref:`Input "
"Event Tutorial <doc_inputevent>`."
msgstr ""
"关于 Godot 如何处理输入的更多信息，请阅读《\\ :ref:`输入事件教程 "
"<doc_inputevent>`\\ 》。"

msgid "Listener"
msgstr "Listener"

msgid "Cameras (2D & 3D)"
msgstr "摄像机（2D 和 3D）"

msgid ""
"When using a :ref:`Camera3D <class_Camera3D>` or :ref:`Camera2D "
"<class_Camera2D>`, it will always display on the closest parent :ref:"
"`Viewport <class_Viewport>` (going towards the root). For example, in the "
"following hierarchy:"
msgstr ""
"当使用 :ref:`Camera3D <class_Camera3D>` 或 :ref:`Camera2D <class_Camera2D>` "
"时，它将始终显示在最近的父级 :ref:`Viewport <class_Viewport>` 上（朝向根节"
"点）。例如，在下面的层次结构中："

msgid ""
"``CameraA`` will display on the Root :ref:`Viewport <class_Viewport>` and it "
"will draw ``MeshA``. ``CameraB`` will be captured by the :ref:`SubViewport "
"<class_SubViewport>` along with ``MeshB``. Even though ``MeshB`` is in the "
"scene hierarchy, it will still not be drawn to the Root Viewport. Similarly, "
"``MeshA`` will not be visible from the SubViewport because SubViewports only "
"capture nodes below them in the hierarchy."
msgstr ""
"``CameraA`` 将显示在根 :ref:`Viewport <class_Viewport>` 上，并且它将绘制 "
"``MeshA``\\ 。\\ ``CameraB`` 将与 ``MeshB`` 一起被 :ref:`SubViewport "
"<class_SubViewport>` 捕获。即使 ``MeshB`` 位于场景层次结构中，它仍然不会被绘"
"制到根视口。同样，\\ ``MeshA`` 在子视口中不可见，因为子视口仅捕获层次结构中位"
"于其下方的节点。"

msgid ""
"There can only be one active camera per :ref:`Viewport <class_Viewport>`, so "
"if there is more than one, make sure that the desired one has the :ref:"
"`current <class_Camera3D_property_current>` property set, or make it the "
"current camera by calling:"
msgstr ""
"一个 :ref:`Viewport <class_Viewport>` 只能有一个活动相机，因此存在多个相机"
"时，请确保所需的那个已经设置了 :ref:`current "
"<class_Camera3D_property_current>` 属性，或通过调用以下命令使其成为当前相机："

msgid ""
"By default, cameras will render all objects in their world. In 3D, cameras "
"can use their :ref:`cull_mask <class_Camera3D_property_cull_mask>` property "
"combined with the :ref:`VisualInstance3D's <class_VisualInstance3D>` :ref:"
"`layer <class_VisualInstance3D_property_layers>` property to restrict which "
"objects are rendered."
msgstr ""
"默认情况下，相机将渲染其世界中的所有对象。在 3D 中，相机可以使用其 :ref:"
"`cull_mask <class_Camera3D_property_cull_mask>` 属性与 :ref:"
"`VisualInstance3D <class_VisualInstance3D>` 的 :ref:`layer "
"<class_VisualInstance3D_property_layers>` 属性结合来限制哪些对象被渲染。"

msgid "Scale & stretching"
msgstr "缩放和拉伸"

msgid ""
":ref:`SubViewports <class_SubViewport>` have a :ref:"
"`size<class_SubViewport_property_size>` property, which represents the size "
"of the SubViewport in pixels. For SubViewports which are children of :ref:"
"`SubViewportContainers <class_SubViewportContainer>`, these values are "
"overridden, but for all others, this sets their resolution."
msgstr ""
":ref:`SubViewports <class_SubViewport>` 有一个 :ref:"
"`size<class_SubViewport_property_size>` 属性，该属性表示 SubViewport 的像素大"
"小。对于 :ref:`SubViewportContainers <class_SubViewportContainer>` 的子级 "
"SubViewport，这些值会被覆盖，但对于所有其他 SubViewport，这会设置它们的分辨"
"率。"

msgid ""
"It is also possible to scale the 2D content and make the :ref:`SubViewport "
"<class_SubViewport>` resolution different from the one specified in size, by "
"calling:"
msgstr ""
"还可以缩放 2D 内容并使 :ref:`SubViewport <class_SubViewport>` 分辨率与大小指"
"定的分辨率不同，可通过调用："

msgid ""
"For information on scaling and stretching with the Root Viewport visit the :"
"ref:`Multiple Resolutions Tutorial <doc_multiple_resolutions>`"
msgstr ""
"有关使用根视口进行缩放和拉伸的信息，请访问《\\ :ref:`多分辨率教程 "
"<doc_multiple_resolutions>`\\ 》"

msgid "Worlds"
msgstr "世界"

msgid ""
"A :ref:`World3D <class_World3D>` can be set in a :ref:`Viewport "
"<class_Viewport>` using the :ref:`World "
"3D<class_Viewport_property_world_3d>` property, that will separate all "
"children nodes of this :ref:`Viewport <class_Viewport>` and will prevent "
"them from interacting with the parent Viewport's World3D. This is especially "
"useful in scenarios where, for example, you might want to show a separate "
"character in 3D imposed over the game (like in StarCraft)."
msgstr ""
"可以使用 :ref:`World 3D<class_Viewport_property_world_3d>` 属性在 :ref:"
"`Viewport <class_Viewport>` 中设置 :ref:`World3D <class_World3D>`，这将分离"
"该 :ref:`Viewport <class_Viewport>` 的所有子节点，并阻止它们与父 Viewport 的 "
"World3D 交互。这在以下场景中特别有用，例如，你可能希望在游戏中以 3D 形式显示"
"单独的角色（像在星际争霸中一样）。"

msgid ""
"As a helper for situations where you want to create :ref:`Viewports "
"<class_Viewport>` that display single objects and don't want to create a :"
"ref:`World3D <class_World3D>`, Viewport has the option to use its :ref:`Own "
"World3D <class_Viewport_property_own_world_3d>`. This is useful when you "
"want to instance 3D characters or objects in :ref:`World2D <class_World2D>`."
msgstr ""
"当你想要创建显示单个对象的 :ref:`Viewport <class_Viewport>` 而不想创建 :ref:"
"`World3D <class_World3D>` 时，作为帮助工具，Viewport 可以选择使用它自己的 :"
"ref:`World3D <class_Viewport_property_own_world_3d>`。当你想要在 :ref:"
"`World2D <class_World2D>` 中实例化 3D 角色或对象时，这很有用。"

msgid ""
"For 2D, each :ref:`Viewport <class_Viewport>` always contains its own :ref:"
"`World2D <class_World2D>`. This suffices in most cases, but in case sharing "
"them may be desired, it is possible to do so by setting :ref:"
"`world_2d<class_Viewport_property_world_2d>` on the Viewport through code."
msgstr ""
"对于 2D，每个 :ref:`Viewport <class_Viewport>` 始终包含它自己的 :ref:"
"`World2D <class_World2D>`。这在大多数情况下就足够了，但如果需要共享它们，可以"
"通过代码在 Viewport 上设置 :ref:`world_2d<class_Viewport_property_world_2d>` "
"来实现。"

msgid ""
"For an example of how this works, see the demo projects `3D in 2D <https://"
"github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ "
"and `2D in 3D <https://github.com/godotengine/godot-demo-projects/tree/"
"master/viewport/2d_in_3d>`_ respectively."
msgstr ""
"关于如何工作的例子, 请分别参阅演示项目 `3D in 2D <https://github.com/"
"godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d>`_ 和 `2D in "
"3D <https://github.com/godotengine/godot-demo-projects/tree/master/"
"viewport/2d_in_3d>`_ ."

msgid "Capture"
msgstr "捕获"

msgid ""
"It is possible to query a capture of the :ref:`Viewport <class_Viewport>` "
"contents. For the Root Viewport, this is effectively a screen capture. This "
"is done with the following code:"
msgstr ""
"可以查询 :ref:`Viewport <class_Viewport>` 内容的捕获。对于根 Viewport，这实际"
"上是一个屏幕截图。这可以通过以下代码完成："

msgid ""
"But if you use this in ``_ready()`` or from the first frame of the :ref:"
"`Viewport's <class_Viewport>` initialization, you will get an empty texture "
"because there is nothing to get as texture. You can deal with it using (for "
"example):"
msgstr ""
"但是如果你在 ``_ready()`` 中使用, 或者从 :ref:`Viewport 的 <class_Viewport>` "
"初始化的第一帧开始使用, 你会得到一个空的纹理, 因为没有什么可以作为纹理获得. "
"你可以用来处理它, 例如:"

msgid "Viewport Container"
msgstr "视口容器"

msgid ""
"If the :ref:`SubViewport <class_SubViewport>` is a child of a :ref:"
"`SubViewportContainer <class_SubViewportContainer>`, it will become active "
"and display anything it has inside. The layout looks like this:"
msgstr ""
"如果 :ref:`SubViewport <class_SubViewport>` 是 :ref:`SubViewportContainer "
"<class_SubViewportContainer>` 的子项，它将变为活动状态并显示其内部的所有内"
"容。布局看起来像这样："

msgid ""
"The :ref:`SubViewport <class_SubViewport>` will cover the area of its "
"parent :ref:`SubViewportContainer <class_SubViewportContainer>` completely "
"if :ref:`Stretch<class_SubViewportContainer_property_stretch>` is set to "
"``true`` in the SubViewportContainer."
msgstr ""
"如果在 SubViewportContainer 中将 :ref:"
"`Stretch<class_SubViewportContainer_property_stretch>` 设置为 ``true``\\ ，"
"则 :ref:`SubViewport <class_SubViewport>` 将完全覆盖其父级 :ref:"
"`SubViewportContainer <class_SubViewportContainer>` 的区域。"

msgid ""
"The size of the :ref:`SubViewportContainer <class_SubViewportContainer>` "
"cannot be smaller than the size of the :ref:`SubViewport "
"<class_SubViewport>`."
msgstr ""
":ref:`SubViewportContainer <class_SubViewportContainer>` 的大小不能小于 :ref:"
"`SubViewport <class_SubViewport>` 的大小。"

msgid "Rendering"
msgstr "渲染"

msgid ""
"Due to the fact that the :ref:`Viewport <class_Viewport>` is an entryway "
"into another rendering surface, it exposes a few rendering properties that "
"can be different from the project settings. You can choose to use a "
"different level of :ref:`MSAA <class_Viewport_property_msaa_2d>` for each "
"Viewport. The default behavior is ``Disabled``."
msgstr ""
"由于 :ref:`Viewport <class_Viewport>` 是进入另一个渲染表面的入口，因此它公开"
"了一些可能与项目设置不同的渲染属性。你可以选择为每个 Viewport 使用不同级别"
"的 :ref:`MSAA <class_Viewport_property_msaa_2d>`。该默认行为是 "
"``Disabled``\\ 。"

msgid ""
"If you need to render 3D shadows in the viewport, make sure to set the "
"viewport's :ref:"
"`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"property to a value higher than ``0``. Otherwise, shadows won't be rendered. "
"By default, the equivalent project setting is set to ``4096`` on desktop "
"platforms and ``2048`` on mobile platforms."
msgstr ""
"如果你需要在视口中渲染 3D 阴影，请确保将视口的 :ref:"
"`positional_shadow_atlas_size<class_Viewport_property_positional_shadow_atlas_size>` "
"属性设置为大于 ``0`` 的值。否则，阴影将不会被渲染。默认情况下，等效项目设置在"
"桌面平台上设置为 ``4096``\\ ，在移动平台上设置为 ``2048``\\ 。"

msgid ""
"Godot also provides a way of customizing how everything is drawn inside :ref:"
"`Viewports <class_Viewport>` using :ref:`Debug "
"Draw<class_Viewport_property_debug_draw>`. Debug Draw allows you to specify "
"a mode which determines how the Viewport will display things drawn inside "
"it. Debug Draw is ``Disabled`` by default. Some other options are "
"``Unshaded``, ``Overdraw``, and ``Wireframe``. For a full list, refer to "
"the :ref:`Viewport Documentation<class_Viewport_property_debug_draw>`."
msgstr ""
"Godot 还提供了一种使用 :ref:`Debug Draw<class_Viewport_property_debug_draw>` "
"自定义 :ref:`Viewport <class_Viewport>` 中所有内容绘制方式的方法。Debug Draw "
"允许你指定一种模式，该模式决定了 Viewport 将如何显示其中绘制的内容。默认情况"
"下，Debug Draw 处于 ``Disabled`` 状态。其他一些选项包括 ``Unshaded``\\ 、\\ "
"``Overdraw`` 和 ``Wireframe``\\ 。有关完整列表，请参阅《\\ :ref:`Viewport 文"
"档<class_Viewport_property_debug_draw>`\\ 》。"

msgid "**Debug Draw = Disabled** (default): The scene is drawn normally."
msgstr "**Debug Draw = Disabled**\\ （默认）：场景正常绘制。"

msgid ""
"**Debug Draw = Unshaded**: Unshaded draws the scene without using lighting "
"information so all the objects appear flatly colored in their albedo color."
msgstr ""
"**Debug Draw = Unshaded**\\ ：无阴影绘制场景时不使用照明信息，因此所有物体都"
"以其反照颜色扁平地显示。"

msgid ""
"**Debug Draw = Overdraw**: Overdraw draws the meshes semi-transparent with "
"an additive blend so you can see how the meshes overlap."
msgstr ""
"**Debug Draw = Overdraw**\\ ：过度绘制使用加法混合将网格绘制成半透明的，以便"
"你可以看到网格是如何重叠的。"

msgid ""
"**Debug Draw = Wireframe**: Wireframe draws the scene using only the edges "
"of triangles in the meshes."
msgstr "**Debug Draw = Wireframe**\\ ：线框仅使用网格中三角形的边来绘制场景。"

msgid ""
"Debug Draw modes are currently **not** supported when using the "
"Compatibility rendering method. They will appear as regular draw modes."
msgstr ""
"使用兼容性渲染方法时，目前\\ **不**\\ 支持调试绘制模式。它们将显示为常规绘制"
"模式。"

msgid "Render target"
msgstr "渲染目标"

msgid ""
"Or it can be assigned in the editor by selecting \"New ViewportTexture\""
msgstr "或者可以通过选择\"New ViewportTexture\"在编辑器中指定它"

msgid ""
"and then selecting the :ref:`Viewport <class_Viewport>` you want to use."
msgstr "然后选择你想要使用的 :ref:`Viewport <class_Viewport>`."

msgid ""
"Every frame, the :ref:`Viewport's <class_Viewport>` texture is cleared away "
"with the default clear color (or a transparent color if :ref:`Transparent "
"BG<class_Viewport_property_transparent_bg>` is set to ``true``). This can be "
"changed by setting :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` to ``Never`` or "
"``Next Frame``. As the name implies, Never means the texture will never be "
"cleared, while next frame will clear the texture on the next frame and then "
"set itself to Never."
msgstr ""
"每一帧，\\ :ref:`Viewport <class_Viewport>` 的纹理都会使用默认清除颜色（如"
"果 :ref:`Transparent BG<class_Viewport_property_transparent_bg>` 设置为 "
"``true``\\ ，则使用透明颜色）清除。 这可以通过将 :ref:`Clear "
"Mode<class_SubViewport_property_render_target_clear_mode>` 设置为 ``Never`` "
"或 ``Next Frame`` 来更改。顾名思义，Never 表示纹理永远不会被清除，而 next "
"frame 将在下一帧清除纹理并将自身设置为 Never。"

msgid ""
"By default, re-rendering of the :ref:`SubViewport <class_SubViewport>` "
"happens when its :ref:`ViewportTexture <class_ViewportTexture>` has been "
"drawn in a frame. If visible, it will be rendered, otherwise, it will not. "
"This behavior can be changed by setting :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` to ``Never``, "
"``Once``, ``Always``, or ``When Parent Visible``. Never and Always will "
"never or always re-render respectively. Once will re-render the next frame "
"and change to Never afterwards. This can be used to manually update the "
"Viewport. This flexibility allows users to render an image once and then use "
"the texture without incurring the cost of rendering every frame."
msgstr ""
"默认情况下，\\ :ref:`SubViewport <class_SubViewport>` 的重新渲染发生在其 :"
"ref:`ViewportTexture <class_ViewportTexture>` 被绘制的那一帧之时。可见则会渲"
"染，否则不会。可以通过将 :ref:`Update "
"Mode<class_SubViewport_property_render_target_update_mode>` 设置为 "
"``Never``\\ 、\\ ``Once``\\ 、\\ ``Always`` 或 ``When Parent Visible`` 来更改"
"此行为。Never 和 Always 分别表示永不或始终重新渲染。Once 将重新渲染下一帧，之"
"后更改为 Never。这可用于手动更新视口。这种灵活性允许用户渲染一次图像，然后使"
"用该纹理，而无需承担渲染每一帧的成本。"

msgid ""
"Make sure to check the Viewport demos. They are available in the viewport "
"folder of the demos archive, or at https://github.com/godotengine/godot-demo-"
"projects/tree/master/viewport."
msgstr ""
"请务必查看 Viewport 演示项目。它们位于演示存档的 viewport 文件夹中，或位于 "
"https://github.com/godotengine/godot-demo-projects/tree/master/viewport。"
