#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "场景组织"

msgid ""
"This article covers topics related to the effective organization of scene "
"content. Which nodes should you use? Where should you place them? How should "
"they interact?"
msgstr ""
"本文讨论与有效组织场景内容相关的主题。应该使用哪些节点？应该把它们放在哪里？"
"它们应该如何互动？"

msgid "How to build relationships effectively"
msgstr "如何有效地建立关系"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "当 Godot 用户开始制作自己的场景时，他们经常遇到以下问题："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"他们创建了自己的第一个场景并填满内容，但随着应该把事情分解的烦人感觉开始积"
"累，他们最终把场景的分支保存为单独的场景。可他们接着就注意到之前能够依赖的硬"
"引用不能用了。在多个地方重用场景会出现问题，因为节点路径找不到目标，在编辑器"
"中建立的信号连接也失效了。"

msgid ""
"To fix these problems, you must instantiate the sub-scenes without them "
"requiring details about their environment. You need to be able to trust that "
"the sub-scene will create itself without being picky about how it's used."
msgstr ""
"要解决这些问题，必须实例化子场景，子场景不依赖于所处环境中的详细信息。子场景"
"应该能够保证自身创建的时候，对如何使用它没有苛刻的要求。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"在 OOP 中需要考虑的最大的事情之一是维护目标明确、单一的类，与代码库的其他部分"
"进行\\ `松散的耦合 <https://en.wikipedia.org/wiki/Loose_coupling>`_\\ 。这样"
"可以使对象的大小保持在较小的范围内（便于维护），提高可重用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "这些 OOP 最佳实践对场景结构和脚本使用的有\\ *很多*\\ 意义。"

msgid ""
"**If at all possible, you should design scenes to have no dependencies.** "
"That is, you should create scenes that keep everything they need within "
"themselves."
msgstr ""
"**应该尽可能设计没有依赖的场景。**\\ 也就是说，创建的场景应该将其所需的一切保"
"留在其内部。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"如果场景必须与外部环境交互，经验丰富的开发人员会建议使用\\ `依赖注入 "
"<https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_\\ 。该"
"技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部"
"环境的类可能会无意中触发 Bug 和意外行为。"

msgid ""
"To do this, you must expose data and then rely on a parent context to "
"initialize it:"
msgstr "要做到这一点，就必须暴露数据，然后依靠父级上下文对其进行初始化："

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"连接信号。这样做极其安全，但只能用于“响应”行为，而不是启动行为。按照惯例，信"
"号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进"
"入、已激活技能、已收集道具）。"

msgid "Call a method. Used to start behavior."
msgstr "调用方法。用于启动行为。"

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`Callable <class_Callable>` 属性。比调用方法更安全，因为不需要拥"
"有这个方法的所有权。用于启动行为。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 的引用。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"These options hide the points of access from the child node. This in turn "
"keeps the child **loosely coupled** to its environment. You can reuse it in "
"another context without any extra changes to its API."
msgstr ""
"这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持 **松耦合** "
"（loosely coupled）。人们可以在另外一个上下文中重新使用它，而不需要对API做任"
"何额外的改变。"

msgid ""
"Although the examples above illustrate parent-child relationships, the same "
"principles apply towards all object relations. Nodes which are siblings "
"should only be aware of their own hierarchies while an ancestor mediates "
"their communications and references."
msgstr ""
"虽然上面的例子只说明了父子关系, 但是同样的原则也适用于所有对象之间的关系. 兄"
"弟节点应该关心它们的层次结构, 而先祖节点则负责协调它们的通信和引用."

msgid ""
"The same principles also apply to non-Node objects that maintain "
"dependencies on other objects. Whichever object owns the other objects "
"should manage the relationships between them."
msgstr ""
"同样的原则也适用于维护对其他对象依赖关系的非节点对象。无论哪个对象拥有其他对"
"象，都应该管理它们之间的关系。"

msgid ""
"You should favor keeping data in-house (internal to a scene), though, as "
"placing a dependency on an external context, even a loosely coupled one, "
"still means that the node will expect something in its environment to be "
"true. The project's design philosophies should prevent this from happening. "
"If not, the code's inherent liabilities will force developers to use "
"documentation to keep track of object relations on a microscopic scale; this "
"is otherwise known as development hell. Writing code that relies on external "
"documentation to use it safely is error-prone by default."
msgstr ""
"你应该倾向于将数据保存在内部（场景内部），尽管它对外部内容有一个依赖关系，甚"
"至是一个松散耦合的依赖，仍然意味着节点将期望其环境中的某些内容为真。项目的设"
"计理念应避免这种情况的发生。如果不这样做，代码的继承关系将迫使开发人员使用文"
"档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱。通常情况下，编写依赖于"
"外部文档才能安全使用的代码，是很容易出错的。"

msgid ""
"To avoid creating and maintaining such documentation, you convert the "
"dependent node (\"child\" above) into a tool script that implements "
"``_get_configuration_warnings()``. Returning a non-empty PackedStringArray "
"from it will make the Scene dock generate a warning icon with the string(s) "
"as a tooltip by the node. This is the same icon that appears for nodes such "
"as the :ref:`Area2D <class_Area2D>` node when it has no "
"child :ref:`CollisionShape2D <class_CollisionShape2D>` nodes defined. The "
"editor then self-documents the scene through the script code. No content "
"duplication via documentation is necessary."
msgstr ""
"为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚"
"本实现 ``_get_configuration_warnings()``\\ 。从中返回的一个非空字符串紧缩数组"
"（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点"
"的工具提示。这个警告图标和没有定义 :ref:`CollisionShape2D "
"<class_CollisionShape2D>` 子节点时 :ref:`Area2D <class_Area2D>` 节点旁出现的"
"图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要"
"在文档里记录一些与之重复的内容了。"

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依"
"赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告"
"诉他们如何进行配置."

msgid ""
"So, why does all this complex switcheroo work? Well, because scenes operate "
"best when they operate alone. If unable to work alone, then working with "
"others anonymously (with minimal hard dependencies, i.e. loose coupling) is "
"the next best thing. Inevitably, changes may need to be made to a class, and "
"if these changes cause it to interact with other scenes in unforeseen ways, "
"then things will start to break down. The whole point of all this "
"indirection is to avoid ending up in a situation where changing one class "
"results in adversely affecting other classes dependent on it."
msgstr ""
"那么，为什么所有这些复杂的间接机制能奏效呢？因为场景在独立运行时表现最佳。如"
"果无法独立运行，那么次优选择就是以匿名方式与其他场景协作（保持最小的硬性依"
"赖，即松耦合）。当不可避免地需要修改某个类时，如果这些修改导致该类以不可预见"
"的方式与其他场景交互，系统就会开始崩溃。所有这些间接设计的核心目的，就是避免"
"陷入修改一个类就会对依赖它的其他类造成负面影响的困境。"

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr "脚本和场景作为引擎类的扩展, 应该遵守 *所有* 的OOP原则. 例如..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "选择节点树结构"

msgid ""
"You might start to work on a game but get overwhelmed by the vast "
"possibilities before you. You might know what you want to do, what systems "
"you want to have, but *where* do you put them all? How you go about making "
"your game is always up to you. You can construct node trees in countless "
"ways. If you are unsure, this guide can give you a sample of a decent "
"structure to start with."
msgstr ""
"于是，一个开发者开始着手做游戏，却在广阔的可能性面前停了下来。他可能知道自己"
"想做什么，想要什么样的系统，但是该把这些东西安置在 *哪里* 呢？好吧，自己做的"
"游戏当然自己说了算。构造节点树的方法有无数种。但对于没把握的人而言，这份有用"
"的指南可以给他们一个不错的结构样本作为开始。"

msgid ""
"A game should always have an \"entry point\"; somewhere you can definitively "
"track where things begin so that you can follow the logic as it continues "
"elsewhere. It also serves as a bird's eye view of all other data and logic "
"in the program. For traditional applications, this is normally a \"main\" "
"function. In Godot, it's a Main node."
msgstr ""
"一个游戏总是应该具有某种“入口点”，你能明确地从入口点追踪各种东西从哪里开始，"
"进而能够跟着逻辑的延伸跟踪它们。它也充当着程序中所有其他数据和逻辑的鸟瞰点。"
"对于传统的应用程序而言，这就是“main”函数。而在Godot中，它就是一个 Main 节点。"

msgid "Node \"Main\" (main.gd)"
msgstr "“Main”节点（main.gd）"

msgid ""
"The ``main.gd`` script will serve as the primary controller of your game."
msgstr "``main.gd`` 脚本将作为你的游戏的主要控制器。"

msgid ""
"Then you have an in-game \"World\" (a 2D or 3D one). This can be a child of "
"Main. In addition, you will need a primary GUI for your game that manages "
"the various menus and widgets the project needs."
msgstr ""
"之后你便拥有了真正的游戏“世界”（2D或3D）。它可以是 Main 的子节点。另外，你的"
"游戏需要一个主要GUI，来管理项目所需的各种菜单和部件。"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D “World”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control“GUI”（gui.gd）"

msgid ""
"When changing levels, you can then swap out the children of the \"World\" "
"node. :ref:`Changing scenes manually <doc_change_scenes_manually>` gives you "
"full control over how your game world transitions."
msgstr ""
"当变更关卡时，可以稍后换出“World”节点的子级。\\ :ref:`手动更换场景 "
"<doc_change_scenes_manually>`\\ 让用户完全控制他们的游戏世界如何过渡。"

msgid ""
"The next step is to consider what gameplay systems your project requires. If "
"you have a system that..."
msgstr "下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……"

msgid "tracks all of its data internally"
msgstr "跟踪所有的内部数据"

msgid "should be globally accessible"
msgstr "应该是全局可访问的"

msgid "should exist in isolation"
msgstr "应该是独立存在的"

msgid ""
"... then you should create an :ref:`autoload 'singleton' node "
"<doc_singletons_autoload>`."
msgstr ""
"…接下来他该创建一个\\ :ref:`自动加载“单例”节点 <doc_singletons_autoload>`\\ "
"了。"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls "
"the :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` method to swap out the main "
"scene's content. This structure more or less keeps the \"World\" as the main "
"game node."
msgstr ""
"对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例，简单地调"
"用 :ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 方法，用于置换出主场景的内容。"
"这种结构多少保留了“World”作为主要游戏节点。"

msgid ""
"Any GUI would also need to be either a singleton, a transitory part of the "
"\"World\", or manually added as a direct child of the root. Otherwise, the "
"GUI nodes would also delete themselves during scene transitions."
msgstr ""
"任一 GUI 也需要是一个单例；作为 \"World\" 的临时部分，或被手动添加到根节点作"
"为其直接子节点。否则 GUI 节点也会在场景转换时自行删除。"

msgid ""
"If you have systems that modify other systems' data, you should define those "
"as their own scripts or scenes, rather than autoloads. For more information, "
"see :ref:`Autoloads versus regular nodes "
"<doc_autoloads_versus_internal_nodes>`."
msgstr ""
"如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或"
"者场景，不应该使用自动加载。详情见《\\ :ref:`自动加载与普通节点 "
"<doc_autoloads_versus_internal_nodes>`\\ 》。"

msgid ""
"Each subsystem within your game should have its own section within the "
"SceneTree. You should use parent-child relationships only in cases where "
"nodes are effectively elements of their parents. Does removing the parent "
"reasonably mean that the children should also be removed? If not, then it "
"should have its own place in the hierarchy as a sibling or some other "
"relation."
msgstr ""
"游戏中的每个子系统都应该在 SceneTree 中占有自己的一席之地。只有在节点确实是父"
"节点中的元素时才应当使用父子关系。如果移除父节点的话，同时将这些子节点移除是"
"否说得通？说不通的话，就应该在层级结构中单独列出，两者成为兄弟节点或者其他关"
"系。"

msgid ""
"In some cases, you need these separated nodes to *also* position themselves "
"relative to each other. You can use the :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` nodes for this purpose. They will allow a target "
"node to conditionally inherit selected transform elements from the Remote\\* "
"node. To assign the ``target`` :ref:`NodePath <class_NodePath>`, use one of "
"the following:"
msgstr ""
"某些情况下，我们\\ *仍然*\\ 会需要让这些单独的节点进行相对定位。此时可以使"
"用 :ref:`RemoteTransform "
"<class_RemoteTransform3D>` / :ref:`RemoteTransform2D "
"<class_RemoteTransform2D>` 节点。它们可以让目标节点有条件地从 Remote\\* 节点"
"继承选定的变换元素。要分配 ``target`` 的 :ref:`NodePath "
"<class_NodePath>`\\ ，请使用以下方法之一："

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "一个可靠的第三方, 可能是一个父节点, 来协调分配任务."

msgid ""
"A group, to pull a reference to the desired node (assuming there will only "
"ever be one of the targets)."
msgstr "一个分组, 轻松提取对所需节点的引用(假设只有一个目标)."

msgid ""
"When you should do this is subjective. The dilemma arises when you must "
"micro-manage when a node must move around the SceneTree to preserve itself. "
"For example..."
msgstr ""
"什么时候你该这样做？这个比较主观。当你必须精细管理，且一个节点必须在场景树上"
"来回移动以保留自己时，就会出现两难的局面。例如……"

msgid "Add a \"player\" node to a \"room\"."
msgstr "添加一个“玩家”节点到一个“房间”节点。"

msgid "Need to change rooms, so you must delete the current room."
msgstr "需要改变房间了，所以必须删除当前房间节点。"

msgid ""
"Before the room can be deleted, you must preserve and/or move the player."
msgstr "在房间能被删除前，你必须保留玩家并/或将其移走。"

msgid "If memory is not a concern, you can..."
msgstr "如果不关心内存，你可以……"

msgid "Create the new room."
msgstr "创建新的房间节点。"

msgid "Move the player to the new room."
msgstr "将玩家节点移动到新的房间节点。"

msgid "Delete the old room."
msgstr "删除旧房间。"

msgid "If memory is a concern, instead you will need to..."
msgstr "如果比较关注内存情况，那么就需要这样……"

msgid "Move the player somewhere else in the tree."
msgstr "将玩家节点移动到节点树的其他地方。"

msgid "Delete the room."
msgstr "删除房间节点。"

msgid "Instantiate and add the new room."
msgstr "实例化并添加新的房间节点。"

msgid "Re-add the player to the new room."
msgstr "重新添加玩家节点到新房间中。"

msgid ""
"The issue is that the player here is a \"special case\" where the developers "
"must *know* that they need to handle the player this way for the project. "
"The only way to reliably share this information as a team is to *document* "
"it. Keeping implementation details in documentation is dangerous. It's a "
"maintenance burden, strains code readability, and unnecessarily bloats the "
"intellectual content of a project."
msgstr ""
"问题在于这里的角色是一种“特殊情况”；开发者必须\\ *知道*\\ 需要以这种方式处理"
"项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是\\ *写文档*\\ 。"
"然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，"
"不必要地膨胀项目的知识内容。"

msgid ""
"In a more complex game with larger assets, it can be a better idea to keep "
"the player somewhere else in the SceneTree entirely. This results in:"
msgstr ""
"在拥有更多的资产的，更复杂的游戏中，将整个玩家节点保留在 SceneTree 中的其他地"
"方会更好。这样的好处是："

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "没有“特殊情况”，不必写入文档也不必进行维护。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "因为不需要考虑这些细节，所以也没有出错的机会。"

msgid ""
"In contrast, if you ever need a child node that does *not* inherit the "
"transform of its parent, you have the following options:"
msgstr "相比之下，如果需要子节点\\ *不*\\ 继承父节点的变换，那么就有以下选项："

msgid ""
"The **declarative** solution: place a :ref:`Node <class_Node>` in between "
"them. Since it doesn't have a transform, they won't pass this information to "
"its children."
msgstr ""
"**声明式**\\ 解决方案：在它们之间放置一个 :ref:`Node <class_Node>`\\ 。作为没"
"有变换的节点，Node 不会将这些信息传递给其子节点。"

msgid ""
"The **imperative** solution: Use the ``top_level`` property for "
"the :ref:`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**命令式**\\ 解决方案：对 :ref:`CanvasItem "
"<class_CanvasItem_property_top_level>` 或者 :ref:`Node3D "
"<class_Node3D_property_top_level>` 节点使用 ``top_level`` 属性。这样就会让该"
"节点忽略其继承的变换（transform）。"

msgid ""
"If building a networked game, keep in mind which nodes and gameplay systems "
"are relevant to all players versus those just pertinent to the authoritative "
"server. For example, users do not all need to have a copy of every players' "
"\"PlayerController\" logic - they only need their own. Keeping them in a "
"separate branch from the \"world\" can help simplify the management of game "
"connections and the like."
msgstr ""
"如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威"
"服务器相关。例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的"
"副本。相反，他们只需要自己的。将它们保持在从“世界”分离的独立的分支中，可以帮"
"助简化游戏连接等的管理。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点"
"的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那"
"么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很"
"可能是父节点场景的一部分）。"

msgid ""
"Does this mean nodes themselves are components? Not at all. Godot's node "
"trees form an aggregation relationship, not one of composition. But while "
"you still have the flexibility to move nodes around, it is still best when "
"such moves are unnecessary by default."
msgstr ""
"这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不"
"是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要"
"的。"
