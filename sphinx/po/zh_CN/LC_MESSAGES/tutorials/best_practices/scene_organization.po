#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine 4.3\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Scene organization"
msgstr "场景组织"

msgid "How to build relationships effectively"
msgstr "如何有效地建立关系"

msgid ""
"When Godot users begin crafting their own scenes, they often run into the "
"following problem:"
msgstr "当 Godot 用户开始制作自己的场景时，他们经常遇到以下问题："

msgid ""
"They create their first scene and fill it with content only to eventually "
"end up saving branches of their scene into separate scenes as the nagging "
"feeling that they should split things up starts to accumulate. However, they "
"then notice that the hard references they were able to rely on before are no "
"longer possible. Re-using the scene in multiple places creates issues "
"because the node paths do not find their targets and signal connections "
"established in the editor break."
msgstr ""
"他们创建了自己的第一个场景并填满内容，但随着应该把事情分解的烦人感觉开始积"
"累，他们最终把场景的分支保存为单独的场景。可他们接着就注意到之前能够依赖的硬"
"引用不能用了。在多个地方重用场景会出现问题，因为节点路径找不到目标，在编辑器"
"中建立的信号连接也失效了。"

msgid ""
"One of the biggest things to consider in OOP is maintaining focused, "
"singular-purpose classes with `loose coupling <https://en.wikipedia.org/wiki/"
"Loose_coupling>`_ to other parts of the codebase. This keeps the size of "
"objects small (for maintainability) and improves their reusability."
msgstr ""
"在 OOP 中需要考虑的最大的事情之一是维护目标明确、单一的类，与代码库的其他部分"
"进行\\ `松散的耦合 <https://en.wikipedia.org/wiki/Loose_coupling>`_\\ 。这样"
"可以使对象的大小保持在较小的范围内（便于维护），提高可重用性。"

msgid ""
"These OOP best practices have *several* implications for best practices in "
"scene structure and script usage."
msgstr "这些 OOP 最佳实践对场景结构和脚本使用的有\\ *很多*\\ 意义。"

msgid ""
"If a scene must interact with an external context, experienced developers "
"recommend the use of `Dependency Injection <https://en.wikipedia.org/wiki/"
"Dependency_injection>`_. This technique involves having a high-level API "
"provide the dependencies of the low-level API. Why do this? Because classes "
"which rely on their external environment can inadvertently trigger bugs and "
"unexpected behavior."
msgstr ""
"如果场景必须与外部环境交互，经验丰富的开发人员会建议使用\\ `依赖注入 "
"<https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5>`_\\ 。该"
"技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部"
"环境的类可能会无意中触发 Bug 和意外行为。"

msgid ""
"Connect to a signal. Extremely safe, but should be used only to \"respond\" "
"to behavior, not start it. By convention, signal names are usually past-"
"tense verbs like \"entered\", \"skill_activated\", or \"item_collected\"."
msgstr ""
"连接信号。这样做极其安全，但只能用于“响应”行为，而不是启动行为。按照惯例，信"
"号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进"
"入、已激活技能、已收集道具）。"

msgid "Call a method. Used to start behavior."
msgstr "调用方法。用于启动行为。"

msgid ""
"Initialize a :ref:`Callable <class_Callable>` property. Safer than a method "
"as ownership of the method is unnecessary. Used to start behavior."
msgstr ""
"初始化 :ref:`Callable <class_Callable>` 属性。比调用方法更安全，因为不需要拥"
"有这个方法的所有权。用于启动行为。"

msgid "Initialize a Node or other Object reference."
msgstr "初始化 Node 或其他 Object 的引用。"

msgid "Initialize a NodePath."
msgstr "初始化 NodePath。"

msgid ""
"A GUI like this can better inform project users of critical information "
"about a Node. Does it have external dependencies? Have those dependencies "
"been satisfied? Other programmers, and especially designers and writers, "
"will need clear instructions in the messages telling them what to do to "
"configure it."
msgstr ""
"这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依"
"赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告"
"诉他们如何进行配置."

msgid ""
"Scripts and scenes, as extensions of engine classes, should abide by *all* "
"OOP principles. Examples include..."
msgstr "脚本和场景作为引擎类的扩展, 应该遵守 *所有* 的OOP原则. 例如..."

msgid "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"
msgstr "`SOLID <https://en.wikipedia.org/wiki/SOLID>`_"

msgid "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"
msgstr "`DRY <https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>`_"

msgid "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"
msgstr "`KISS <https://en.wikipedia.org/wiki/KISS_principle>`_"

msgid "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"
msgstr "`YAGNI <https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>`_"

msgid "Choosing a node tree structure"
msgstr "选择节点树结构"

msgid "Node \"Main\" (main.gd)"
msgstr "“Main”节点（main.gd）"

msgid "Node2D/Node3D \"World\" (game_world.gd)"
msgstr "Node2D/Node3D “世界”（game_world.gd）"

msgid "Control \"GUI\" (gui.gd)"
msgstr "Control“GUI”（gui.gd）"

msgid "tracks all of its data internally"
msgstr "跟踪所有的内部数据"

msgid "should be globally accessible"
msgstr "应该是全局可访问的"

msgid "should exist in isolation"
msgstr "应该是独立存在的"

msgid ""
"For smaller games, a simpler alternative with less control would be to have "
"a \"Game\" singleton that simply calls the :ref:`SceneTree."
"change_scene_to_file() <class_SceneTree_method_change_scene_to_file>` method "
"to swap out the main scene's content. This structure more or less keeps the "
"\"World\" as the main game node."
msgstr ""
"对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例，简单地调用 :"
"ref:`SceneTree.change_scene_to_file() "
"<class_SceneTree_method_change_scene_to_file>` 方法，用于置换出主场景的内容。"
"这种结构多少保留了“World”作为主要游戏节点。"

msgid ""
"A reliable third party, likely a parent node, to mediate the assignment."
msgstr "一个可靠的第三方, 可能是一个父节点, 来协调分配任务."

msgid "Add a \"player\" node to a \"room\"."
msgstr "添加一个“玩家”节点到一个“房间”节点。"

msgid "Move the player somewhere else in the tree."
msgstr "将玩家节点移动到节点树的其他地方。"

msgid "Delete the room."
msgstr "删除房间节点。"

msgid "Instantiate and add the new room."
msgstr "实例化并添加新的房间节点。"

msgid "More consistency."
msgstr "一致性更高。"

msgid "No \"special cases\" that must be documented and maintained somewhere."
msgstr "没有“特殊情况”，不必写入文档也不必进行维护。"

msgid ""
"No opportunity for errors to occur because these details are not accounted "
"for."
msgstr "因为不需要考虑这些细节，所以也没有出错的机会。"

msgid ""
"The **imperative** solution: Use the ``top_level`` property for the :ref:"
"`CanvasItem <class_CanvasItem_property_top_level>` or :ref:`Node3D "
"<class_Node3D_property_top_level>` node. This will make the node ignore its "
"inherited transform."
msgstr ""
"**命令式**\\ 解决方案：对 :ref:`CanvasItem "
"<class_CanvasItem_property_top_level>` 或者 :ref:`Node3D "
"<class_Node3D_property_top_level>` 节点使用 ``top_level`` 属性。这样就会让该"
"节点忽略其继承的变换（transform）。"

msgid ""
"The key to scene organization is to consider the SceneTree in relational "
"terms rather than spatial terms. Are the nodes dependent on their parent's "
"existence? If not, then they can thrive all by themselves somewhere else. If "
"they are dependent, then it stands to reason that they should be children of "
"that parent (and likely part of that parent's scene if they aren't already)."
msgstr ""
"场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点"
"的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那"
"么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很"
"可能是父节点场景的一部分）。"
