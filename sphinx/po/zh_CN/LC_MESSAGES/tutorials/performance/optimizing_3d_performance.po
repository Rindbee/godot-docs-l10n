#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "optimization"
msgstr "优化"

msgid "Optimizing 3D performance"
msgstr "优化 3D 性能"

msgid "Culling"
msgstr "剔除"

msgid ""
"Godot will automatically perform view frustum culling in order to prevent "
"rendering objects that are outside the viewport. This works well for games "
"that take place in a small area, however things can quickly become "
"problematic in larger levels."
msgstr ""
"Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游"
"戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦."

msgid "Occlusion culling"
msgstr "遮挡剔除"

msgid ""
"Walking around a town for example, you may only be able to see a few "
"buildings in the street you are in, as well as the sky and a few birds "
"flying overhead. As far as a naive renderer is concerned however, you can "
"still see the entire town. It won't just render the buildings in front of "
"you, it will render the street behind that, with the people on that street, "
"the buildings behind that. You quickly end up in situations where you are "
"attempting to render 10× or 100× more than what is visible."
msgstr ""
"比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞"
"过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染"
"你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会"
"遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西."

msgid ""
"Things aren't quite as bad as they seem, because the Z-buffer usually allows "
"the GPU to only fully shade the objects that are at the front. This is "
"called *depth prepass* and is enabled by default in Godot when using the "
"Forward+ or Compatibility rendering methods. However, unneeded objects are "
"still reducing performance."
msgstr ""
"事情并没有看上去那么糟糕，因为 Z 缓冲区通常允许 GPU 仅完全遮蔽位于前方的物"
"体。这被称为\\ *深度预处理*\\ ，且在使用 Forward+ 或 Compatibility 渲染方法"
"时 Godot 会默认启用。但是，不需要的对象仍然会降低性能。"

msgid ""
"In some cases, you may have to adapt your level design to add more occlusion "
"opportunities. For example, you may have to add more walls to prevent the "
"player from seeing too far away, which would decrease performance due to the "
"lost opportunities for occlusion culling."
msgstr ""
"在某些情况下，你可能需要调整关卡设计以增加更多遮挡机会。例如，你可能需要添加"
"更多墙壁以防止玩家看得太远，否则会因失去遮挡剔除的机会而降低性能。"

msgid "Transparent objects"
msgstr "透明物体"

msgid ""
"Godot sorts objects by :ref:`Material <class_Material>` and :ref:`Shader "
"<class_Shader>` to improve performance. This, however, can not be done with "
"transparent objects. Transparent objects are rendered from back to front to "
"make blending with what is behind work. As a result, **try to use as few "
"transparent objects as possible**. If an object has a small section with "
"transparency, try to make that section a separate surface with its own "
"material."
msgstr ""
"Godot通过 :ref:`Material <class_Material>` 和 :ref:`Shader <class_Shader>` 对"
"对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲"
"染, 以便与后面的物体混合. 因此, **尽量少使用透明对象** . 如果一个物体有一小部"
"分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质."

msgid ""
"For more information, see the :ref:`GPU optimizations "
"<doc_gpu_optimization>` doc."
msgstr "更多信息请参阅 :ref:`GPU 优化 <doc_gpu_optimization>` 文档。"

msgid "Level of detail (LOD)"
msgstr "细节程度（LOD）"

msgid ""
"In some situations, particularly at a distance, it can be a good idea to "
"**replace complex geometry with simpler versions**. The end user will "
"probably not be able to see much difference. Consider looking at a large "
"number of trees in the far distance. There are several strategies for "
"replacing models at varying distance. You could use lower poly models, or "
"use transparency to simulate more complex geometry."
msgstr ""
"在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. "
"最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距"
"离的模型. 你可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体."

msgid "Godot 4 offers several ways to control level of detail:"
msgstr "Godot 4 提供了多种控制细节层次的方法："

msgid "An automatic approach on mesh import using :ref:`doc_mesh_lod`."
msgstr "使用 :ref:`doc_mesh_lod` 进行网格导入的自动方法。"

msgid ""
"A manual approach configured in the 3D node using :ref:"
"`doc_visibility_ranges`."
msgstr "在3D节点中使用 :ref:`doc_visibility_ranges` 配置的手动方法。"

msgid ""
":ref:`Decals <doc_using_decals>` and :ref:`lights <doc_lights_and_shadows>` "
"can also benefit from level of detail using their respective **Distance "
"Fade** properties."
msgstr ""
":ref:`Decals <doc_using_decals>` 和 :ref:`lights <doc_lights_and_shadows>` 也"
"可以使用它们各自的 **Distance Fade** 属性从细节级别中获益。"

msgid ""
"While they can be used independently, these approaches are most effective "
"when used together. For example, you can set up visibility ranges to hide "
"particle effects that are too far away from the player to notice. At the "
"same time, you can rely on mesh LOD to make the particle effect's meshes "
"rendered with less detail at a distance."
msgstr ""
"虽然它们可以单独使用，但一起使用时这些方法最有效。例如，你可以设定可见范围来"
"隐藏距离玩家太远而无法注意到的粒子效果。同时，你可以依靠网格LOD来使粒子效果的"
"网格在远处算绘时细节较少。"

msgid ""
"Visibility ranges are also a good way to set up *impostors* for distant "
"geometry (see below)."
msgstr "可见范围也是为远处几何体设定\\ *冒充者*\\ 的好方法（见下文）。"

msgid "Billboards and imposters"
msgstr "Billboard 和 imposter"

msgid ""
"The simplest version of using transparency to deal with LOD is billboards. "
"For example, you can use a single transparent quad to represent a tree at "
"distance. This can be very cheap to render, unless of course, there are many "
"trees in front of each other. In this case, transparency may start eating "
"into fill rate (for more information on fill rate, see :ref:"
"`doc_gpu_optimization`)."
msgstr ""
"使用透明度处理 LOD 的最简单版本是广告牌。例如，你可以使用单个透明四边形来表示"
"远处的一棵树。除非彼此前面有很多棵树，否则这可以非常便宜地渲染。在这种情况"
"下，透明度可能会开始侵蚀填充率（有关填充率的更多信息，请参阅《\\ :ref:"
"`doc_gpu_optimization`\\ 》）。"

msgid ""
"An alternative is to render not just one tree, but a number of trees "
"together as a group. This can be especially effective if you can see an area "
"but cannot physically approach it in a game."
msgstr ""
"另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区"
"域, 但在游戏中不能实际接近它, 这可能是特别有效的."

msgid ""
"You can make imposters by pre-rendering views of an object at different "
"angles. Or you can even go one step further, and periodically re-render a "
"view of an object onto a texture to be used as an imposter. At a distance, "
"you need to move the viewer a considerable distance for the angle of view to "
"change significantly. This can be complex to get working, but may be worth "
"it depending on the type of project you are making."
msgstr ""
"你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, "
"周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你"
"需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可"
"能是值得的, 这取决于你正在制作的项目类型."

msgid "Use instancing (MultiMesh)"
msgstr "使用实例化（MultiMesh）"

msgid ""
"If several identical objects have to be drawn in the same place or nearby, "
"try using :ref:`MultiMesh <class_MultiMesh>` instead. MultiMesh allows the "
"drawing of many thousands of objects at very little performance cost, making "
"it ideal for flocks, grass, particles, and anything else where you have "
"thousands of identical objects."
msgstr ""
"如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 :ref:`MultiMesh "
"<class_MultiMesh>` 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, "
"这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方."

msgid ""
"See also the :ref:`Using MultiMesh <doc_using_multimesh>` documentation."
msgstr "另请参阅《\\ :ref:`使用 MultiMesh <doc_using_multimesh>`\\ 》文档。"

msgid "Bake lighting"
msgstr "烘焙照明"

msgid ""
"Lighting objects is one of the most costly rendering operations. Realtime "
"lighting, shadows (especially multiple lights), and :ref:`global "
"illumination <doc_introduction_to_global_illumination>` are especially "
"expensive. They may simply be too much for lower power mobile devices to "
"handle."
msgstr ""
"照明对象是最昂贵的渲染操作之一。实时照明、阴影（尤其是多个光源）和\\ :ref:`全"
"局光照 <doc_introduction_to_global_illumination>`\\ 都特别昂贵。对于低功耗的"
"移动设备来说，它们可能简化得太多而无法处理。"

msgid ""
"**Consider using baked lighting**, especially for mobile. This can look "
"fantastic, but has the downside that it will not be dynamic. Sometimes, this "
"is a tradeoff worth making."
msgstr ""
"**考虑使用烘焙照明**\\ ，尤其是移动设备。这看起来很棒，但缺点是它不是动态的。"
"有时，这是值得做出的权衡。"

msgid ""
"See :ref:`doc_using_lightmap_gi` for instructions on using baked lightmaps. "
"For best performance, you should set lights' bake mode to **Static** as "
"opposed to the default **Dynamic**, as this will skip real-time lighting on "
"meshes that have baked lighting."
msgstr ""
"有关使用烘焙光照贴图的说明，请参阅 :ref:`doc_using_lightmap_gi`\\ 。为了获得"
"最佳性能，你应该将灯光的烘焙模式设置为\\ **Static**\\ （静态），而不是默认的"
"\\ **Dynamic**\\ （动态），因为这将跳过具有烘焙光照的网格上的实时光照。"

msgid ""
"The downside of lights with the **Static** bake mode is that they can't cast "
"shadows onto meshes with baked lighting. This can make scenes with outdoor "
"environments and dynamic objects look flat. A good balance between "
"performance and quality is to keep **Dynamic** for the :ref:"
"`class_DirectionalLight3D` node, and use **Static** for most (if not all) "
"omni and spot lights."
msgstr ""
"使用 **Static** 烘焙模式的灯光的缺点是，它们无法将阴影投射到具有烘焙照明的网"
"格上。这可以使具有室外环境和动态对象的场景看起来平坦。性能和质量之间的良好平"
"衡是 :ref:`class_DirectionalLight3D` 节点保持 **Dynamic**\\ ，并对大多数（如"
"果不是全部）泛光灯和聚光灯使用 **Static**\\ 。"

msgid "Animation and skinning"
msgstr "动画和皮肤"

msgid ""
"Animation and vertex animation such as skinning and morphing can be very "
"expensive on some platforms. You may need to lower the polycount "
"considerably for animated models, or limit the number of them on screen at "
"any given time. You can also reduce the animation rate for distant or "
"occluded meshes, or pause the animation entirely if the player is unlikely "
"to notice the animation being stopped."
msgstr ""
"在某些平台上，动画和顶点动画（例如蒙皮和变形）可能非常昂贵。你可能需要大幅降"
"低动画模型的多边形数量，或限制任意时间在屏幕上的模型数量。你还可以降低远处或"
"遮挡网格的动画速率，或者如果玩家不太可能注意到动画被停止时完全暂停动画。"

msgid ""
"The :ref:`class_VisibleOnScreenEnabler3D` and :ref:"
"`class_VisibleOnScreenNotifier3D` nodes can be useful for this purpose."
msgstr ""
":ref:`class_VisibleOnScreenEnabler3D` 和 :ref:"
"`class_VisibleOnScreenNotifier3D` 节点可用于此目的。"

msgid "Large worlds"
msgstr "庞大的世界"

msgid ""
"If you are making large worlds, there are different considerations than what "
"you may be familiar with from smaller games."
msgstr "如果你要制作大型游戏, 则与小型游戏可能会有所不同."

msgid ""
"Large worlds may need to be built in tiles that can be loaded on demand as "
"you move around the world. This can prevent memory use from getting out of "
"hand, and also limit the processing needed to the local area."
msgstr ""
"大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存"
"使用失控, 也可以将所需的处理限制在局部区域."

msgid ""
"There may also be rendering and physics glitches due to floating point error "
"in large worlds. This can be resolved using :ref:"
"`doc_large_world_coordinates`. If using large world coordinates is not an "
"option, you may be able to use techniques such as orienting the world around "
"the player (rather than the other way around), or shifting the origin "
"periodically to keep things centred around ``Vector3(0, 0, 0)``."
msgstr ""
"由于大型世界中的浮点错误，渲染和物理也可能出现故障。可以使用 :ref:"
"`doc_large_world_coordinates` 解决该问题。如果无法使用大型世界坐标，你可以使"
"用一些技术，例如围绕玩家定位世界（而不是相反），或定期移动原点以使事物以 "
"``Vector3(0, 0, 0)`` 为中心。"
