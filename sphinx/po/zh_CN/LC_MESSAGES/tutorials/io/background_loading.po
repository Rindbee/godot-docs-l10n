# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-20 18:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Background loading"
msgstr "后台加载"

msgid ""
"Commonly, games need to load resources asynchronously. When switching the "
"main scene of your game (e.g. going to a new level), you might want to show "
"a loading screen with some indication that progress is being made, or you "
"may want to load additional resources during gameplay."
msgstr ""
"通常，游戏需要异步加载资源。当切换游戏的主场景时（例如，进入新的关卡），你可"
"能想要显示一个加载画面，其中包含一些正在进行的指示，或者你可能希望在游戏过程"
"中加载其他资源。"

msgid ""
"The standard load method (:ref:`ResourceLoader.load "
"<class_ResourceLoader_method_load>` or GDScript's simpler :ref:`load "
"<class_@GDScript_method_load>`) blocks your thread, making your game appear "
"unresponsive while the resource is being loaded."
msgstr ""
"标准加载方法（:ref:`ResourceLoader.load <class_ResourceLoader_method_load>` "
"或 GDScript 更简单的：ref:`load <class_@GDScript_method_load>` ）会阻塞你的线"
"程，让你的游戏在加载资源时显得无响应。"

msgid ""
"One way around this is using ``ResourceLoader`` to load resources "
"asynchronously in background threads."
msgstr ""
"解决这个问题的一种方法是使用「ResourceLoader」在后台线程中非同步加载资源。"

msgid "Using ResourceLoader"
msgstr "使用 ResourceLoader"

msgid ""
"Generally, you queue requests to load resources for a path using :ref:"
"`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>`, which will then be "
"loaded in threads in the background."
msgstr ""
"通常，你使用: ref:`ResourceLoader.load_threaded_request "
"<class_ResourceLoader_method_load_threaded_request>` 对加载路径资源的请求进行"
"排队，然后将在背景的线程中加载。"

msgid ""
"You can check the status with :ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>`. Progress can be "
"obtained by passing an array variable via progress which will return a one "
"element array containing the percentage."
msgstr ""
"你可以使用: ref:`ResourceLoader.load_threaded_get_status "
"<class_ResourceLoader_method_load_threaded_get_status>` 检查状态。可以透过"
"Progress传递一个数组变数来取得进度，该变数将传回一个包含百分比的单元素数组。"

msgid ""
"Finally, you retrieve loaded resources by calling :ref:`ResourceLoader."
"load_threaded_get <class_ResourceLoader_method_load_threaded_get>`."
msgstr ""
"最后，通过调用：ref:`ResourceLoader."
"load_threadd_get<class_ResourceLoader_method_load_threaded_get>` 来检索加载的"
"资源。"

msgid ""
"Once you call ``load_threaded_get()``, either the resource finished loading "
"in the background and will be returned instantly or the load will block at "
"this point like ``load()`` would. If you want to guarantee this does not "
"block, you either need to ensure there is enough time between requesting the "
"load and retrieving the resource or you need to check the status manually."
msgstr ""
"一旦你呼叫 ``load_threaded_get()`` ，资源要么在后台完成加载并立即返回，要么加"
"载将像 ``load()`` 一样在此时阻塞。如果你想保证这不会阻塞，你要么需要确保请求"
"加载和检索资源之间有足够的时间，要么需要手动检查状态。"

msgid "Example"
msgstr "示例"

#, fuzzy
msgid ""
"This example demonstrates how to load a scene in the background. We will "
"have a button spawn an enemy when pressed. The enemy will be ``Enemy.tscn`` "
"which we will load on ``_ready`` and instantiate when pressed. The path will "
"be ``\"Enemy.tscn\"`` which is located at ``res://Enemy.tscn``."
msgstr ""
"此示例示范如何在背景加载场景。我们将有一个按钮，按下时会生成一个敌人。敌人将"
"是``Enemy.tscn``，我们将在“_ready”上传入它并在按下时实例化。路径为``Enemy."
"tscn``，位于``res://Enemy.tscn``。"

msgid ""
"First, we will start a request to load the resource and connect the button:"
msgstr "首先，我们将启动一个请求来加载资源并连接按钮："

msgid ""
"Now ``_on_button_pressed`` will be called when the button is pressed. This "
"method will be used to spawn an enemy."
msgstr "现在按下按钮时将呼叫``_on_button_pressed``。此方法将用于生成敌人。"

msgid "Translation status"
msgstr "翻译状态"
