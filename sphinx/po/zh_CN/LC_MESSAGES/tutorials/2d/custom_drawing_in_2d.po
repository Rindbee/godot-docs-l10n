#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Custom drawing in 2D"
msgstr "2D 中的自定义绘图"

msgid "Introduction"
msgstr "前言"

msgid ""
"Godot has nodes to draw sprites, polygons, particles, text, and many other "
"common game development needs. However, if you need something specific not "
"covered with the standard nodes you can make any 2D node (for "
"example, :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`-"
"based) draw on screen using custom commands."
msgstr ""
"Godot 有用于绘制精灵、多边形、粒子、文本以及其它各种游戏开发所需东西的节点。"
"但是，如果这些标准节点不能满足你的特定需求，你可以通过自定义命令在屏幕上绘制"
"任何 2D 节点（例如，基于 :ref:`Control <class_Control>` 或 :ref:`Node2D "
"<class_Node2D>` ）。"

msgid ""
"Custom drawing in a 2D node is *really* useful. Here are some use cases:"
msgstr "2D 节点中的自定义绘制\\ *非常*\\ 有用。下面是一些用例："

msgid ""
"Drawing shapes or logic that existing nodes can't do, such as an image with "
"trails or a special animated polygon."
msgstr ""
"绘制现有节点类型无法完成的形状或逻辑，例如带有尾迹或特殊动态多边形的图像。"

msgid ""
"Drawing a large number of simple objects, such as a grid or a board for a 2d "
"game. Custom drawing avoids the overhead of using a large number of nodes, "
"possibly lowering memory usage and improving performance."
msgstr ""
"绘制大量简单的对象，例如 2D 游戏中的一个栅格或一个面板。自定义绘制避免了使用"
"大量节点的开销，能降低内存占用，并提高性能。"

msgid ""
"Making a custom UI control. There are plenty of controls available, but when "
"you have unusual needs, you will likely need a custom control."
msgstr "制作自定义的 UI 控件，以满足很多可用的控件之外的特别需求。"

msgid "Drawing"
msgstr "绘制"

msgid ""
"Add a script to any :ref:`CanvasItem <class_CanvasItem>` derived node, "
"like :ref:`Control <class_Control>` or :ref:`Node2D <class_Node2D>`. Then "
"override the :ref:`_draw()<class_CanvasItem_private_method__draw>` function."
msgstr ""
"添加一个脚本到任何 :ref:`CanvasItem <class_CanvasItem>` 的派生节点，"
"如 :ref:`Control <class_Control>` 或 :ref:`Node2D <class_Node2D>`\\ 。然后重"
"载 :ref:`_draw()<class_CanvasItem_private_method__draw>` 函数。"

msgid ""
"Draw commands are described in the :ref:`CanvasItem <class_CanvasItem>` "
"class reference. There are plenty of them and we will see some of them in "
"the examples below."
msgstr ""
"绘制命令在 :ref:`CanvasItem <class_CanvasItem>` 的类参考中有所描述。绘制命令"
"的数量很多，我们将在下面的示例中看到一些。"

msgid "Updating"
msgstr "更新"

msgid ""
"The :ref:`_draw <class_CanvasItem_private_method__draw>` function is only "
"called once, and then the draw commands are cached and remembered, so "
"further calls are unnecessary."
msgstr ""
":ref:`_draw <class_CanvasItem_private_method__draw>` 函数只调用一次，然后绘制"
"命令被缓存并记住，因此不需要进一步调用。"

msgid ""
"If re-drawing is required because a variable or something else changed, "
"call :ref:`CanvasItem.queue_redraw <class_CanvasItem_method_queue_redraw>` "
"in that same node and a new ``_draw()`` call will happen."
msgstr ""
"如果因为状态或其他方面的变化而需要重新绘制，在当前节点中调"
"用 :ref:`CanvasItem.queue_redraw <class_CanvasItem_method_queue_redraw>` ，触"
"发新的 ``_draw()`` 调用。"

msgid ""
"Here is a little more complex example, where we have a texture variable that "
"can be modified at any time, and using "
"a :ref:`setter<doc_gdscript_basics_setters_getters>`, it forces a redraw of "
"the texture when modified:"
msgstr ""
"这是一个稍微复杂一点的例子，我们有一个可以被随时修改的纹理变量，并且使用一"
"个 :ref:`setter<doc_gdscript_basics_setters_getters>`，它在纹理被修改时强制一"
"次该纹理的重绘："

msgid ""
"To see it in action, you can set the texture to be the Godot icon on the "
"editor by dragging and dropping the default ``icon.svg`` from the "
"``FileSystem`` tab to the Texture property on the ``Inspector`` tab. When "
"changing the ``Texture`` property value while the previous script is "
"running, the texture will also change automatically."
msgstr ""
"为了直观地看到这一功能，你可以通过将默认的 ``icon.svg`` 文件从 ``文件系统`` "
"标签拖放到 ``检查器`` 标签上的 ``纹理`` 属性，将编辑器中的纹理设置为 Godot 图"
"标。当先前脚本运行时更改 ``纹理`` 属性值，纹理也将自动更改。"

msgid ""
"In some cases, we may need to redraw every frame. For this, "
"call :ref:`queue_redraw <class_CanvasItem_method_queue_redraw>` from "
"the :ref:`_process <class_Node_private_method__process>` method, like this:"
msgstr ""
"在某些情况下，需要绘制每一帧。 为此，可以像这样从 :ref:`_process "
"<class_Node_private_method__process>` 方法中调用 :ref:`queue_redraw "
"<class_CanvasItem_method_queue_redraw>` 方法："

msgid "Coordinates and line width alignment"
msgstr "坐标和线宽对齐"

msgid ""
"The drawing API uses the CanvasItem's coordinate system, not necessarily "
"pixel coordinates. This means ``_draw()`` uses the coordinate space created "
"after applying the CanvasItem's transform. Additionally, you can apply a "
"custom transform on top of it by "
"using :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"or :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>`."
msgstr ""
"绘图 API 使用的是 CanvasItem 的坐标系，不一定是像素坐标。这意味着 "
"``_draw()`` 使用的是应用 CanvasItem 的变换后创建的坐标空间。此外，你还可以使"
"用 :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"或 :ref:`draw_set_transform_matrix<class_CanvasItem_method_draw_set_transform_matrix>` "
"在其上方应用自定义变换。"

msgid ""
"When using :ref:`draw_line <class_CanvasItem_method_draw_line>`, you should "
"consider the width of the line. When using a width that is an odd size, the "
"position of the start and end points should be shifted by ``0.5`` to keep "
"the line centered, as shown below."
msgstr ""
"当使用 :ref:`draw_line <class_CanvasItem_method_draw_line>` 时，你应该考虑线"
"的宽度。当使用奇数宽度时，为了使线保持居中，起点和终点的位置应该偏移 "
"``0.5`` ，如下所示。"

msgid ""
"The same applies to the :ref:`draw_rect <class_CanvasItem_method_draw_rect>` "
"method with ``filled = false``."
msgstr ""
"与使用 ``filled = false`` 的 :ref:`draw_rect "
"<class_CanvasItem_method_draw_rect>` 方法相同。"

msgid "Antialiased drawing"
msgstr "抗锯齿绘图"

msgid ""
"Godot offers method parameters "
"in :ref:`draw_line<class_CanvasItem_method_draw_line>` to enable "
"antialiasing, but not all custom drawing methods offer this ``antialiased`` "
"parameter."
msgstr ""
"Godot 在 :ref:`draw_line<class_CanvasItem_method_draw_line>` 方法中提供参数来"
"启用抗锯齿功能，但并非所有自定义绘图方法都提供这个 ``抗锯齿（antialiased）`` "
"参数。"

msgid ""
"For custom drawing methods that don't provide an ``antialiased`` parameter, "
"you can enable 2D MSAA instead, which affects rendering in the entire "
"viewport. This provides high-quality antialiasing, but a higher performance "
"cost and only on specific elements. See :ref:`doc_2d_antialiasing` for more "
"information."
msgstr ""
"对于不提供 ``antialiased`` 参数的自定义绘图方法，你可以启用 2D MSAA，这会影响"
"整个视口的渲染。这个功能（2D MSAA）提供了高质量的抗锯齿，但性能成本更高，而且"
"只适用于特定元素。详情见 :ref:`doc_2d_antialiasing`\\ 。"

msgid ""
"Here is a comparison of a line of minimal width (``width=-1``) drawn with "
"``antialiased=false``, ``antialiased=true``, and ``antialiased=false`` with "
"2D MSAA 2x, 4x, and 8x enabled."
msgstr ""
"最小宽度线段 (``width=-1``) 的对比，分别启用 ``antialiased=false`` 、 "
"``antialiased=true`` 以及 ``antialiased=false`` 搭配 2D MSAA 2x、4x 和 8x 抗"
"锯齿。"

msgid "Tools"
msgstr "工具"

msgid ""
"Drawing your own nodes might also be desired while running them in the "
"editor. This can be used as a preview or visualization of some feature or "
"behavior."
msgstr ""
"运行于编辑器中时，也可能需要绘制自己的节点。这可以用于预览或可视化某些特性或"
"行为。"

msgid ""
"To do this, you can use the :ref:`tool annotation<doc_gdscript_tool_mode>` "
"on both GDScript and C#. See :ref:`the example "
"below<doc_draw_show_drawing_while_editing_example>` "
"and :ref:`doc_running_code_in_the_editor` for more information."
msgstr ""
"为此，你可以在 GDScript 和 C# 上使用\\ :ref:`工具注解 "
"<doc_gdscript_tool_mode>`。有关更多信息，请参阅\\ :ref:`下面的示例 "
"<doc_draw_show_drawing_while_editing_example>`\\ "
"和 :ref:`doc_running_code_in_the_editor`。"

msgid "Example 1: drawing a custom shape"
msgstr "示例 1：绘制自定义形状"

msgid ""
"We will now use the custom drawing functionality of the Godot Engine to draw "
"something that Godot doesn't provide functions for. We will recreate the "
"Godot logo but with code- only using drawing functions."
msgstr ""
"我们将使用 Godot 引擎的自定义绘制功能来绘制 Godot 本身没有提供函数的图形。将"
"仅使用绘图函数重新创建 Godot 标志。"

msgid "You will have to code a function to perform this and draw it yourself."
msgstr "你需要编写一个函数来执行此操作并自行绘制。"

msgid ""
"The following instructions use a fixed set of coordinates that could be too "
"small for high resolution screens (larger than 1080p). If that is your case, "
"and the drawing is too small consider increasing your window scale in the "
"project setting :ref:`Display > Window > Stretch > "
"Scale<class_ProjectSettings_property_display/window/stretch/scale>` to "
"adjust the project to a higher resolution (a 2 or 4 scale tends to work "
"well)."
msgstr ""
"以下说明使用了一组固定坐标，该坐标对于高分辨率屏幕（大于 1080p）可能太小。如"
"果是这种情况，并且绘图太小，请考虑在 ``菜单 > 项目 > 项目设置 > 显示/窗口/拉"
"伸/缩放``:ref:`Display > Window > Stretch > "
"Scale<class_ProjectSettings_property_display/window/stretch/scale>` 中增加窗"
"口缩放比例，以将项目调整到更高的分辨率（2 或 4 倍缩放通常效果良好）。"

msgid "Drawing a custom polygon shape"
msgstr "绘制自定义多边形形状"

msgid ""
"While there is a dedicated node to draw custom polygons ( :ref:`Polygon2D "
"<class_Polygon2D>`), we will use in this case exclusively lower level "
"drawing functions to combine them on the same node and be able to create "
"more complex shapes later on."
msgstr ""
"虽然存在用于绘制自定义多边形的专用节点 (:ref:`Polygon2D <class_Polygon2D>`)，"
"但本例中将仅使用更底层的绘制函数，以便将它们组合在同样的节点上，并能够在之后"
"创建更复杂的形状。"

msgid ""
"First, we will define a set of points -or X and Y coordinates- that will "
"form the base of our shape:"
msgstr "我们将首先定义一组点（或 X 和 Y 坐标），它们将构成形状的基础："

msgid ""
"This format, while compact, is not the one that Godot understands to draw a "
"polygon. In a different scenario we could have to load these coordinates "
"from a file or calculate the positions while the application is running, so "
"some transformation may be needed."
msgstr ""
"这是一种简洁的格式，但并不是 Godot 用于绘制多边形所理解的格式。在其他情况下，"
"我们可能需要从文件中加载这些坐标或在应用程序运行时计算它们的位置，因此可能需"
"要进行一些转换。"

msgid ""
"To transform these coordinates into the right format, we will create a new "
"method ``float_array_to_Vector2Array()``. Then we will override the "
"``_ready()`` function, which Godot will call only once -at the start of the "
"execution- to load those coordinates into a variable:"
msgstr ""
"为了将这些坐标转换为正确的格式，我们将创建一个新的方法 "
"``float_array_to_Vector2Array()``\\ 。然后我们将重写 ``_ready()`` 函数，"
"Godot 将仅在执行开始时调用该函数一次，以将这些坐标加载到变量中："

msgid ""
"To finally draw our first shape, we will use the method :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>` and pass the points (as an array of "
"Vector2 coordinates) and its color, like this:"
msgstr ""
"为了最终绘制第一个形状，我们将使用 :ref:`draw_polygon "
"<class_CanvasItem_method_draw_polygon>` 方法，并传递点（ Vector2 坐标数组）及"
"其颜色，如下所示："

msgid "When running it you should see something like this:"
msgstr "运行后，你应该会看到类似以下的图形："

msgid ""
"Note the lower part of the logo looks segmented- this is because a low "
"amount of points were used to define that part. To simulate a smooth curve, "
"we could add more points to our array, or maybe use a mathematical function "
"to interpolate a curve and create a smooth shape from code "
"(see :ref:`example 2<doc_draw_custom_example_2>`)."
msgstr ""
"注意图标的下部看起来像是分段的，这是因为用于定义该部分的点数量较少。为了模拟"
"平滑曲线，可以向数组中添加更多点，或者使用数学函数来插值曲线以从代码中创建平"
"滑形状（参见 :ref:`示例 2<doc_draw_custom_example_2>`）。"

msgid ""
"Polygons will always **connect its last defined point to its first one** in "
"order to have a closed shape."
msgstr ""
"多边形为了形成封闭的形状，总是会将 **最后一个定义的点连接到第一个点** 。"

msgid "Drawing connected lines"
msgstr "绘制连接线"

msgid ""
"Drawing a sequence of connected lines that don't close down to form a "
"polygon is very similar to the previous method. We will use a connected set "
"of lines to draw Godot's logo mouth."
msgstr ""
"绘制一系列不封闭成多边形的连接线与之前的方法非常相似。我们将使用一系列连接的"
"线条来绘制 Godot 图标的嘴巴。"

msgid ""
"First, we will define the list of coordinates that form the mouth shape, "
"like this:"
msgstr "首先，我们将定义构成嘴巴形状的坐标列表，如下所示："

msgid ""
"We will load these coordinates into a variable and define an additional "
"variable with the configurable line thickness:"
msgstr ""
"我们将把这些坐标加载到一个变量中，并定义另一个变量来设置可配置的线条粗细："

msgid ""
"And finally we will use the method :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>` to actually draw the line, like "
"this:"
msgstr ""
"最终我们使用方法 :ref:`draw_polyline "
"<class_CanvasItem_method_draw_polyline>` 来真正绘制这条线，就像这样："

msgid "You should get the following output:"
msgstr "你应当获得如下输出:"

msgid ""
"Unlike ``draw_polygon()``, polylines can only have a single unique color for "
"all its points (the second argument). This method has 2 additional "
"arguments: the width of the line (which is as small as possible by default) "
"and enabling or disabling the antialiasing (it is disabled by default)."
msgstr ""
"与 ``draw_polygon()`` 不同，折线（polyline）的所有点只能有一个唯一的颜色（第"
"二个参数）。此方法有 2 个附加参数：线的宽度（默认情况下尽可能小），和启用或禁"
"用抗锯齿（默认情况下禁用）。"

msgid ""
"The order of the ``_draw`` calls is important- like with the Node positions "
"on the tree hierarchy, the different shapes will be drawn from top to "
"bottom, resulting in the latest shapes hiding earlier ones if they overlap. "
"In this case we want the mouth drawn over the head, so we put it afterwards."
msgstr ""
"``_draw`` 调用的顺序很重要，就像树状层次结构上的节点位置一样，将从上到下绘制"
"不同的形状，这会使得新绘制的形状在重叠时隐藏掉较早绘制的形状。在本例中，我们"
"希望将嘴放在头上，因此我们将其放在后面。"

msgid ""
"Notice how we can define colors in different ways, either with a hexadecimal "
"code or a predefined color name. Check the class :ref:`Color <class_Color>` "
"for other constants and ways to define Colors."
msgstr ""
"请注意我们如何以不同的方式定义颜色，无论是使用十六进制代码还是预定义的颜色名"
"称。请检查类 :ref:`Color <class_Color>` 的其他常量和定义颜色的方法。"

msgid "Drawing circles"
msgstr "绘制圆"

msgid ""
"To create the eyes, we are going to add 4 additional calls to draw the eye "
"shapes, in different sizes, colors and positions."
msgstr ""
"为了创建眼睛，我们将添加 4 个额外的调用来绘制不同大小、颜色和位置的眼睛形状。"

msgid ""
"To draw a circle, you position it based on its center using "
"the :ref:`draw_circle <class_CanvasItem_method_draw_circle>` method. The "
"first parameter is a :ref:`Vector2<class_Vector2>` with the coordinates of "
"its center, the second is its radius, and the third is its color:"
msgstr ""
"为了绘制圆形，请使用 :ref:`draw_circle "
"<class_CanvasItem_method_draw_circle>` 方法根据其圆的中心定位它。第一个参数是"
"以 :ref:`Vector2<class_Vector2>` 形式写下的中心坐标，第二个参数是其半径，第三"
"个参数是其颜色："

msgid "When executing it, you should have something like this:"
msgstr "在执行它时，你应当获得如下所示的图像:"

msgid ""
"For partial, unfilled arcs (portions of a circle shape between certain "
"arbitrary angles), you can use the method :ref:`draw_arc "
"<class_CanvasItem_method_draw_arc>`."
msgstr ""
"对于部分未填充的圆弧（某些任意角度之间的圆形部分），可以使用方"
"法 :ref:`draw_arc <class_CanvasItem_method_draw_arc>`。"

msgid "Drawing lines"
msgstr "绘制线"

msgid ""
"To draw the final shape (the nose) we will use a line to approximate it."
msgstr "为了绘制最终的形状（鼻子），我们将使用一条线来近似模拟它。"

msgid ""
":ref:`draw_line <class_CanvasItem_method_draw_line>` can be used to draw a "
"single segment by providing its start and end coordinates as arguments, like "
"this:"
msgstr ""
"通过提供其开始和结束坐标作为参数，\\ :ref:`draw_line "
"<class_CanvasItem_method_draw_line>` 可用于绘制单个线段，如下所示："

msgid "You should now be able to see the following shape on screen:"
msgstr "你现在应该可以在屏幕上看到如下形状："

msgid ""
"Note that if multiple unconnected lines are going to be drawn at the same "
"time, you may get additional performance by drawing all of them in a single "
"call, using the :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` method."
msgstr ""
"请注意，如果要同时绘制多条未连接的线，可以通过使用 :ref:`draw_multiline "
"<class_CanvasItem_method_draw_multiline>` 方法在一次调用中绘制所有线，来获得"
"额外的性能提升。"

msgid "Drawing text"
msgstr "绘制文本"

msgid ""
"While using the :ref:`Label <class_Label>` Node is the most common way to "
"add text to your application, the low-level `_draw` function includes "
"functionality to add text to your custom Node drawing. We will use it to add "
"the name \"GODOT\" under the robot head."
msgstr ""
"虽然向程序中添加文本的最常见方法是使用 :ref:`Label <class_Label>` 节点，但是"
"低阶的 `_draw` 函数提供了在自定义 Node 绘制时添加文本的功能。我们就用这个方法"
"在机器人的脑袋下面加上它的名字“GODOT”。"

msgid ""
"We will use the :ref:`draw_string <class_CanvasItem_method_draw_string>` "
"method to do it, like this:"
msgstr ""
"具体做法是调用 :ref:`draw_string <class_CanvasItem_method_draw_string>`\\ ，"
"类似于这样："

msgid ""
"Here we first load into the defaultFont variable the configured default "
"theme font (a custom one can be set instead) and then we pass the following "
"parameters: font, position, text, horizontal alignment, width, and font size."
msgstr ""
"我们这里首先将 defaultFont 变量配置为默认的主题字体（也可以设为自定义字体），"
"然后传入字体、位置、文本、水平对齐、宽度、字体大小等参数。"

msgid "You should see the following on your screen:"
msgstr "你应当在屏幕上看到如下所示的图像："

msgid ""
"Additional parameters as well as other methods related to text and "
"characters can be found on the :ref:`CanvasItem <class_CanvasItem>` class "
"reference."
msgstr ""
"其他参数以及其他和文本字符相关的方法都可以在 :ref:`CanvasItem "
"<class_CanvasItem>` 的类参考中找到。"

msgid "Show the drawing while editing"
msgstr "编辑时显示绘制"

msgid ""
"While the code so far is able to draw the logo on a running window, it will "
"not show up on the ``2D view`` on the editor. In certain cases you would "
"also like to show your custom Node2D or control on the editor, to position "
"and scale it appropriately, like most other nodes do."
msgstr ""
"虽然目前这段代码已经可以在运行中的窗口中绘制 Logo，但却并没有在编辑器中的 "
"``2D 视图`` 上显示。在某些特定情况下，你希望自制的 Node2D 或者控件节点能够在"
"编辑器中显示，跟其他绝大多数节点一样，这以便于定位和缩放。"

msgid ""
"To show the logo directly on the editor (without running it), you can use "
"the :ref:`@tool<doc_gdscript_tool_mode>` annotation to request the custom "
"drawing of the node to also appear while editing, like this:"
msgstr ""
"为了能够在编辑器中直接显示 Logo，而不必运行程序，你可以使"
"用 :ref:`@tool<doc_gdscript_tool_mode>` 注解，来要求自制的绘制节点在编辑时显"
"示，就像这样："

msgid ""
"You will need to save your scene, rebuild your project (for C# only) and "
"reload the current scene manually at the menu option ``Scene > Reload Saved "
"Scene`` to refresh the current node in the ``2D`` view the first time you "
"add or remove the ``@tool`` annotation."
msgstr ""
"每当你添加或移除 ``@tool`` 注解时，你需要保存场景，重新构建项目（仅限 C#），"
"并且选择菜单选项 ``场景 > 重载已保存场景`` 来手动重载当前场景，才能刷新 "
"``2D`` 视图中的节点。"

msgid "Animation"
msgstr "动画"

msgid ""
"If we wanted to make the custom shape change at runtime, we could modify the "
"methods called or its arguments at execution time, or apply a transform."
msgstr ""
"如果希望自制图形在运行时改变形状，便需要修改执行时调用的方法或者参数，或者应"
"用一个变换。"

msgid ""
"For example, if we want the custom shape we just designed to rotate, we "
"could add the following variable and code to the ``_ready`` and ``_process`` "
"methods:"
msgstr ""
"举个例子，如果想让我们刚刚设计的自制形状旋转，那么可以先 ``_ready`` 和"
"``_process`` 方法中添加如下变量和代码："

msgid ""
"The problem with the above code is that because we have created the points "
"approximately on a rectangle starting from the upper left corner, the ``(0, "
"0)`` coordinate and extending to the right and down, we see that the "
"rotation is done using the top left corner as pivot. A position transform "
"change on the node won't help us here, as the rotation transform is applied "
"first."
msgstr ""
"上述代码的问题在于，我们所创建的点是差不多是从左上角，即坐标轴的 ``(0, 0)`` "
"处，扩展到右下角，所以看到的旋转才是以左上角为轴心的。对于节点的位置变换并不"
"能帮到我们，因为旋转变化会先作用。"

msgid ""
"While we could rewrite all of the points' coordinates to be centered around "
"``(0, 0)``, including negative coordinates, that would be a lot of work."
msgstr ""
"不过我们可以重写所有点的坐标，使其以 ``(0, 0)`` 点为中心，这就包括了坐标的负"
"半轴，那可是个大工程。"

msgid ""
"One possible way to work around this is to use the lower "
"level :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` "
"method to fix this issue, translating all points in the CanvasItem's own "
"space, and then moving it back to its original place with a regular node "
"transform, either in the editor or in code, like this:"
msgstr ""
"一个可行的方案就是使用更底层"
"的 :ref:`draw_set_transform<class_CanvasItem_method_draw_set_transform>` 方法"
"来解决此问题，这个方法能够平移 CanvasItem 自身空间的所有点，然后再使用常规的"
"节点变换将其移动至原位，用编辑器或代码均可，就像这样："

msgid "This is the result, rotating around a pivot now on ``(60, 60)``:"
msgstr "这就是最终结果，以 ``(60, 60)`` 点为轴心旋转："

msgid ""
"If what we wanted to animate was a property inside the ``_draw()`` call, we "
"must remember to call ``queue_redraw()`` to force a refresh, as otherwise it "
"would not be updated on screen."
msgstr ""
"如果我们在 ``_draw()`` 中调用属性而动画化，必须调用 ``queue_redraw()`` 来强制"
"刷新，否则不会在屏幕上更新内容。"

msgid ""
"For example, this is how we can make the robot appear to open and close its "
"mouth, by changing the width of its mouth line follow a sinusoidal "
"(:ref:`sin<class_@globalscope_method_sin>`) curve:"
msgstr ""
"例如，可以通过改变嘴巴线条的宽度，使机器人“张嘴”和“闭嘴”，宽度的变化遵循正弦 "
"(:ref:`sin<class_@globalscope_method_sin>`) 曲线："

msgid "It will look somewhat like this when run:"
msgstr "当运行时，它看上去会像这样："

msgid ""
"Please note that ``_mouth_width`` is a user defined property like any other "
"and it or any other used as a drawing argument can be animated using more "
"standard and high-level methods such as a :ref:`Tween<class_Tween>` or "
"an :ref:`AnimationPlayer<class_AnimationPlayer>` Node. The only difference "
"is that a ``queue_redraw()`` call is needed to apply those changes so they "
"get shown on screen."
msgstr ""
"请注意， ``_mouth_width`` 与任何其他属性一样，都是用户定义的属性。它或任何其"
"他用作绘图参数的属性，都可以使用更标准的高级方法进行动画处理，例"
"如 :ref:`Tween<class_Tween>` "
"或 :ref:`AnimationPlayer<class_AnimationPlayer>` 节点。唯一区别是需要调用 "
"``queue_redraw()`` 应用更改，使内容在屏幕上显示。"

msgid "Example 2: drawing a dynamic line"
msgstr "示例 2：绘制动态线条"

msgid ""
"The previous example was useful to learn how to draw and modify nodes with "
"custom shapes and animations. This could have some advantages, such as using "
"exact coordinates and vectors for drawing, rather than bitmaps -which means "
"they will scale well when transformed on screen. In some cases, similar "
"results could be achieved composing higher level functionality with nodes "
"such as :ref:`sprites<class_Sprite2D>` "
"or :ref:`AnimatedSprites<class_AnimatedSprite2D>` loading SVG resources "
"(which are also images defined with vectors) and "
"the :ref:`AnimationPlayer<class_AnimationPlayer>` node."
msgstr ""
"先前示例展示了如何使用自定义形状和动画绘制和修改节点。这种方法具有一些优势，"
"如使用精确坐标和向量进行绘制，而不是位图（在屏幕上缩放时仍然清晰）。在某些情"
"况下，也可以通过组合如 :ref:`sprites<class_Sprite2D>` "
"或 :ref:`AnimatedSprites<class_AnimatedSprite2D>` 等高级功能与节点来实现类似"
"的效果，这些节点可以加载 SVG 格式资源，并使"
"用 :ref:`AnimationPlayer<class_AnimationPlayer>` 节点。"

msgid ""
"In other cases that will not be possible because we will not know what the "
"resulting graphical representation will be before running the code. Here we "
"will see how to draw a dynamic line whose coordinates are not known "
"beforehand, and are affected by the user's input."
msgstr ""
"在其他情况下这种方法不可行，因为我们无法预先知道运行代码后图形的表现形式。本"
"节将介绍如何绘制动态线条，其坐标事先未知，并且会受到用户输入的影响。"

msgid "Drawing a straight line between 2 points"
msgstr "在两点之间绘制直线"

msgid ""
"Let's assume we want to draw a straight line between 2 points, the first one "
"will be fixed on the upper left corner ``(0, 0)`` and the second will be "
"defined by the cursor position on screen."
msgstr ""
"假设我们想要绘制一条连接两个点的直线，第一个点固定在屏幕左上角 ``(0, 0)`` ，"
"第二个点由屏幕上的光标位置决定。"

msgid "We could draw a dynamic line between those 2 points like this:"
msgstr "可以像这样绘制这两个点之间的动态的线："

msgid ""
"In this example we obtain the position of the mouse in the default viewport "
"every frame with the method :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>`. If the position has changed "
"since the last draw request (a small optimization to avoid redrawing on "
"every frame)- we will schedule a redraw. Our ``_draw()`` method only has one "
"line: requesting the drawing of a green line of width 10 pixels between the "
"top left corner and that obtained position."
msgstr ""
"在这个例子中，我们在每一帧都使用 :ref:`get_mouse_position "
"<class_Viewport_method_get_mouse_position>` 方法获取鼠标在默认视口中的位置。"
"如果位置与上次绘制请求时相比发生了变化（小优化，避免在每一帧都重新绘制），而"
"进行一次重新绘制。\\ ``_draw()`` 方法只有一行代码：请求绘制一条绿色线条，宽度"
"为 10 像素，左上角和获取到的坐标之间。"

msgid ""
"The width, color, and position of the starting point can be configured with "
"with the corresponding properties."
msgstr "起始点的宽度、颜色和位置可以通过相应的属性进行配置。"

msgid "It should look like this when run:"
msgstr "运行时，它应当看起来像这样："

msgid "Drawing an arc between 2 points"
msgstr "绘制两点之间的弧线"

msgid ""
"The above example works, but we may want to join those 2 points with a "
"different shape or function, other than a straight line."
msgstr ""
"上面的例子可以实现效果，但有时可能想用除直线以外的形状或函数连接这两个点。"

msgid ""
"Let's try now creating an arc (a portion of a circumference) between both "
"points."
msgstr "让我们尝试在两个点之间创建一个弧线（圆周的一部分）。"

msgid ""
"Exporting the line starting point, segments, width, color, and antialiasing "
"will allow us to modify those properties very easily directly from the "
"editor inspector panel:"
msgstr ""
"通过将线段的起始点、段数、宽度、颜色和抗锯齿属性导出为变量，从而可在编辑器检"
"查器面板中方便修改这些属性："

msgid ""
"To draw the arc, we can use the "
"method :ref:`draw_arc<class_CanvasItem_method_draw_arc>`. There are many "
"arcs that pass through 2 points, so we will chose for this example the "
"semicircle that has its center in the middle point between the 2 initial "
"points."
msgstr ""
"为了绘制弧线，可以使用 :ref:`draw_arc<class_CanvasItem_method_draw_arc>` 方"
"法。事实上，穿过两个点的弧线有很多种，在这个例子中，我们将选择一个半圆，它的"
"圆心位于初始两个点之间的中点。"

msgid "Calculating this arc will be more complex than in the case of the line:"
msgstr "确实，计算此弧线要比计算直线复杂得多:"

msgid ""
"The center of the semicircle will be the middle point between both points. "
"The radius will be half the distance between both points. The start and end "
"angles will be the angles of the vector from point1 to point2 and vice-"
"versa. Note we had to normalize the ``end_angle`` in positive values because "
"if ``end_angle`` is less than ``start_angle``, the arc will be drawn counter-"
"clockwise, which we don't want in this case (the arc would be upside-down)."
msgstr ""
"半圆的圆心将是两个点之间的中点。半径将是两个点之间距离的一半。起始角度和结束"
"角度将分别为点 1 到点 2 的向量角度以及点 2 到点 1 的向量角度。需要注意的是，"
"我们需要将 ``end_angle`` 归一化为正值，因为如果 ``end_angle`` 小于 "
"``start_angle`` ，则弧线将逆时针绘制，在这里，并不想要该效果 (弧线会上下颠"
"倒)。"

msgid ""
"The result should be something like this, with the arc going down and "
"between the points:"
msgstr "结果应该像这样，弧线向下延伸并穿过这些点："

msgid ""
"Feel free to play with the parameters in the inspector to obtain different "
"results: change the color, the width, the antialiasing, and increase the "
"number of segments to increase the curve smoothness, at the cost of extra "
"performance."
msgstr ""
"可在检查器中调整参数以获得不同的结果：改变颜色、宽度、抗锯齿，以及增加段数以"
"提高曲线的平滑度，但这样会牺牲部分性能。"
