#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Advanced vector math"
msgstr "高等向量数学"

msgid "Planes"
msgstr "平面"

msgid ""
"The dot product has another interesting property with unit vectors. Imagine "
"that perpendicular to that vector (and through the origin) passes a plane. "
"Planes divide the entire space into positive (over the plane) and negative "
"(under the plane), and (contrary to popular belief) you can also use their "
"math in 2D:"
msgstr ""
"单位向量的点积还有一个有趣的性质。请想象一个垂直于这个向量（且经过原点）的平"
"面。平面会将整个空间划分为正（在平面上方）和负（在平面下方）两部分，并且（与"
"普遍的看法相反）你也可以在 2D 中进行这样的数学运算："

msgid ""
"Unit vectors that are perpendicular to a surface (so, they describe the "
"orientation of the surface) are called **unit normal vectors**. Though, "
"usually they are just abbreviated as *normals*. Normals appear in planes, 3D "
"geometry (to determine where each face or vertex is siding), etc. A "
"**normal** *is* a **unit vector**, but it's called *normal* because of its "
"usage. (Just like we call (0,0) the Origin!)."
msgstr ""
"垂直于表面的单位向量称为\\ **单位法向量**\\ （因此描述的是表面的朝向），不过"
"通常会简称为\\ *法线*\\ 。平面、3D 几何体等场合中都会用到法线（用来确定面或顶"
"点的属于哪一侧）。\\ **法线**\\ 是一种\\ **单位向量**\\ ，因为用途才被称为\\ "
"*法线*\\ 。（就像我们说坐标 (0,0) 是“原点”一样！）。"

msgid "Distance to plane"
msgstr "到平面的距离"

msgid ""
"Now that it's clear what a plane is, let's go back to the dot product. The "
"dot product between a **unit vector** and any **point in space** (yes, this "
"time we do dot product between vector and position), returns the **distance "
"from the point to the plane**:"
msgstr ""
"现在平面是什么就很清楚了，让我们再回到点积上。\\ **单位向量**\\ 和任何\\ **空"
"间点**\\ 之间的点积（是的，这次我们在向量和位置之间进行点乘），将返回\\ **从"
"该点到平面的距离**\\ ："

msgid ""
"But not just the absolute distance, if the point is in the negative half "
"space the distance will be negative, too:"
msgstr "但返回的不止是距离的绝对值，如果点位于负半空间，那么这个距离也是负的："

msgid "This allows us to tell which side of the plane a point is."
msgstr "这样我们就能够知道点位于平面的哪一侧。"

msgid "Away from the origin"
msgstr "脱离原点"

msgid ""
"I know what you are thinking! So far this is nice, but *real* planes are "
"everywhere in space, not only passing through the origin. You want real "
"*plane* action and you want it *now*."
msgstr ""
"我知道你在想什么！到目前为止还算不错，但\\ *真正的*\\ 平面在空间中无处不在，"
"并不一定要经过原点。你想要的是真正\\ *平面*\\ ，你\\ *现在*\\ 就想行动起来。"

msgid ""
"Remember that planes not only split space in two, but they also have "
"*polarity*. This means that it is possible to have perfectly overlapping "
"planes, but their negative and positive half-spaces are swapped."
msgstr ""
"请记住，平面不仅仅是将空间一分为二，这两个空间还有\\ *极性*\\ 。也就是说，如"
"果两个平面完全重合，它们的正负半空间可以相反。"

msgid ""
"With this in mind, let's describe a full plane as a **normal** *N* and a "
"**distance from the origin** scalar *D*. Thus, our plane is represented by N "
"and D. For example:"
msgstr ""
"明确了这一点，我们就可以将完整的平面描述为\\ **法线** *N* 和\\ **与原点的距离"
"**\\ 标量 *D*\\ 。这样用 N 和 D 就可以表示我们的平面了。例如："

msgid ""
"For 3D math, Godot provides a :ref:`Plane <class_Plane>` built-in type that "
"handles this."
msgstr ""
"对于 3D 空间中的平面，Godot 提供了 :ref:`Plane <class_Plane>` 内置类型来处理"
"这些计算。"

msgid ""
"Basically, N and D can represent any plane in space, be it for 2D or 3D "
"(depending on the amount of dimensions of N) and the math is the same for "
"both. It's the same as before, but D is the distance from the origin to the "
"plane, travelling in N direction. As an example, imagine you want to reach a "
"point in the plane, you will just do:"
msgstr ""
"基本上，N 和 D 可以表示空间中的任何平面，无论是 2D 还是 3D（取决于 N 的维"
"数），两者的数学运算相同。它与之前相同，但 D 是从原点到平面的距离，沿 N 方向"
"行进。例如，假设你想要到达平面上的某个点，只需执行以下操作："

msgid ""
"This will stretch (resize) the normal vector and make it touch the plane. "
"This math might seem confusing, but it's actually much simpler than it "
"seems. If we want to tell, again, the distance from the point to the plane, "
"we do the same but adjusting for distance:"
msgstr ""
"这将拉伸（调整大小）法线向量并使其接触平面。这个数学运算可能看起来很混乱，但"
"实际上比看起来要简单得多。如果我们想再次知道从点到平面的距离，可以以相同方"
"法，但要调整距离："

msgid "The same thing, using a built-in function:"
msgstr "也可以用内置函数执行同样的计算："

msgid "This will, again, return either a positive or negative distance."
msgstr "这同样会返回一个正或负的距离。"

msgid ""
"Flipping the polarity of the plane can be done by negating both N and D. "
"This will result in a plane in the same position, but with inverted negative "
"and positive half spaces:"
msgstr ""
"还可以通过同时对 N 和 D 取负来反转平面的极性。这样，平面的位置不变，但正负半"
"空间倒置："

msgid ""
"Godot also implements this operator in :ref:`Plane <class_Plane>`. So, using "
"the format below will work as expected:"
msgstr ""
"Godot 还在 :ref:`Plane <class_Plane>` 中实现了该运算。因此，使用以下格式将按"
"预期工作："

msgid ""
"So, remember, the plane's main practical use is that we can calculate the "
"distance to it. So, when is it useful to calculate the distance from a point "
"to a plane? Let's see some examples."
msgstr ""
"所以，请记住，平面的主要实际用途是我们可以计算到平面的距离。那么，什么时候计"
"算从点到平面的距离有用呢？让我们看一些例子。"

msgid "Constructing a plane in 2D"
msgstr "在 2D 中构造平面"

msgid ""
"Planes clearly don't come out of nowhere, so they must be built. "
"Constructing them in 2D is easy, this can be done from either a normal (unit "
"vector) and a point, or from two points in space."
msgstr ""
"平面不会凭空出现，必须先进行构造。在 2D 空间中构造平面很简单：只需要法线（单"
"位向量）和某一个点，或者空间中任意两点都可以完成。"

msgid ""
"In the case of a normal and a point, most of the work is done, as the normal "
"is already computed, so calculate D from the dot product of the normal and "
"the point."
msgstr ""
"在法线和点的情况下，由于法线已经被计算出来，大部分计算工作都已完成。因此，只"
"需根据法线和点的点积计算 D 即可。"

msgid ""
"The rest is the same as the previous example. Either point_a or point_b will "
"work, as they are in the same plane:"
msgstr ""
"剩余步骤与前例相同。point_a 和 point_b 都可以用于计算，毕竟两者位于同一个平面"
"内："

msgid ""
"Doing the same in 3D is a little more complex and is explained further down."
msgstr "在 3D 空间中构造平面更加复杂，下文会进一步解释。"

msgid "Some examples of planes"
msgstr "平面的一些示例"

msgid ""
"Here is an example of what planes are useful for. Imagine you have a `convex "
"<https://www.mathsisfun.com/definitions/convex.html>`__ polygon. For "
"example, a rectangle, a trapezoid, a triangle, or just any polygon where no "
"faces bend inwards."
msgstr ""
"以下是平面的用途示例。假设有一个\\ `凸 <https://www.mathsisfun.com/"
"definitions/convex.html>`__\\ 多边形。比如矩形、梯形、三角形或任何没有面向内"
"弯曲的多边形。"

msgid ""
"For every segment of the polygon, we compute the plane that passes by that "
"segment. Once we have the list of planes, we can do neat things, for example "
"checking if a point is inside the polygon."
msgstr ""
"对于多边形的每段，我们计算经过该段的平面。一旦我们有了平面列表，我们就可以做"
"一些有趣的事情，例如检查某个点是否在多边形内。"

msgid ""
"We go through all planes, if we can find a plane where the distance to the "
"point is positive, then the point is outside the polygon. If we can't, then "
"the point is inside."
msgstr ""
"我们遍历所有平面，如果我们能找到一个到该点的距离为正的平面，那么该点就在多边"
"形外部。如果我们找不到，那么该点就在多边形内部。"

msgid "Code should be something like this:"
msgstr "代码应该是这样的："

msgid ""
"Pretty cool, huh? But this gets much better! With a little more effort, "
"similar logic will let us know when two convex polygons are overlapping too. "
"This is called the Separating Axis Theorem (or SAT) and most physics engines "
"use this to detect collision."
msgstr ""
"很酷吧？但还会更好！再多花点功夫，类似的逻辑也会让我们知道两个凸多边形何时重"
"叠。这被称为分离轴定理（或 SAT），大多数物理引擎都使用它来检测碰撞。"

msgid ""
"With a point, just checking if a plane returns a positive distance is enough "
"to tell if the point is outside. With another polygon, we must find a plane "
"where *all* *the* *other* *polygon* *points* return a positive distance to "
"it. This check is performed with the planes of A against the points of B, "
"and then with the planes of B against the points of A:"
msgstr ""
"对于一个点，只要检查是否有一个平面返回正距离，就足以判断该点是否在外部。对于"
"另一个多边形，我们必须找到一个平面，使\\ *另一个*\\ *多边形*\\ 的\\ *所有*\\ "
"*点*\\ 到它的距离都返回为正。先使用 A 的平面对 B 的点进行检查，然后使用 B 的"
"平面对 A 的点进行检查："

msgid ""
"As you can see, planes are quite useful, and this is the tip of the iceberg. "
"You might be wondering what happens with non convex polygons. This is "
"usually just handled by splitting the concave polygon into smaller convex "
"polygons, or using a technique such as BSP (which is not used much nowadays)."
msgstr ""
"如你所见，平面非常有用，而这只是冰山一角。你可能想知道非凸多边形会发生什么。"
"通常只需将凹多边形分割成较小的凸多边形，或使用诸如 BSP（现在很少使用）之类的"
"技术即可解决。"

msgid "Collision detection in 3D"
msgstr "3D 碰撞检测"

msgid ""
"This is another bonus bit, a reward for being patient and keeping up with "
"this long tutorial. Here is another piece of wisdom. This might not be "
"something with a direct use case (Godot already does collision detection "
"pretty well) but it's used by almost all physics engines and collision "
"detection libraries :)"
msgstr ""
"这是另一个奖励，是对耐心坚持看完这篇长篇教程的奖励。这是另一条智慧。这可能不"
"是直接使用案例（Godot 已经很好地完成了碰撞检测），但几乎所有物理引擎和碰撞检"
"测库都在使用它 :)"

msgid ""
"Remember that converting a convex shape in 2D to an array of 2D planes was "
"useful for collision detection? You could detect if a point was inside any "
"convex shape, or if two 2D convex shapes were overlapping."
msgstr ""
"还记得将 2D 凸形转换为 2D 平面数组对于碰撞检测很有用吗？你可以检测某个点是否"
"位于任何凸形内，或者两个 2D 凸形是否重叠。"

msgid ""
"Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you "
"won't be able to find a separating plane. If a separating plane is found, "
"then the shapes are definitely not colliding."
msgstr ""
"嗯，这在 3D 中也适用，如果两个 3D 多面体发生碰撞，你将无法找到分离平面。如果"
"找到了分离平面，则这两个形状肯定没有发生碰撞。"

msgid ""
"To refresh a bit a separating plane means that all vertices of polygon A are "
"in one side of the plane, and all vertices of polygon B are in the other "
"side. This plane is always one of the face-planes of either polygon A or "
"polygon B."
msgstr ""
"稍微回顾一下，分离平面意味着多边形 A 的所有顶点都在平面的一侧，而多边形 B 的"
"所有顶点都在另一侧。该平面总是多边形 A 或多边形 B 的面平面之一。"

msgid ""
"In 3D though, there is a problem to this approach, because it is possible "
"that, in some cases a separating plane can't be found. This is an example of "
"such situation:"
msgstr ""
"不过，在 3D 中，这种方法存在问题，因为在某些情况下可能找不到分离平面。以下是"
"这种情况的一个示例："

msgid ""
"To avoid it, some extra planes need to be tested as separators, these planes "
"are the cross product between the edges of polygon A and the edges of "
"polygon B"
msgstr ""
"为了避免这种情况，一些额外的平面需要作为分隔器被测试，这些平面是多边形 A 的边"
"和多边形 B 的边的叉积"

msgid "So the final algorithm is something like:"
msgstr "所以，最终的算法是这样的："

msgid "More information"
msgstr "更多信息"

msgid ""
"For more information on using vector math in Godot, see the following "
"article:"
msgstr "有关在 Godot 中使用向量数学的更多信息，请参阅以下文章："

msgid ":ref:`doc_matrices_and_transforms`"
msgstr ":ref:`doc_matrices_and_transforms`"

msgid ""
"If you would like additional explanation, you should check out 3Blue1Brown's "
"excellent video series `Essence of Linear Algebra <https://www.youtube.com/"
"watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab>`_."
msgstr ""
"如果你需要进一步的解释，你可以看看 3Blue1Brown 的绝佳系列视频 `《线性代数的本"
"质》 <http://www.bilibili.com/video/BV1ys411472E?p=2>`_ 。"
