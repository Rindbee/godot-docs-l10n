# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:4
msgid "OpenXR spatial entities"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:6
msgid "For any sort of augmented reality application you need to access real world information, and be able to track real world locations. OpenXR's spatial entities API was introduced for this exact purpose."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:9
msgid "It has a very modular design. The core of the API defines how real world entities are structured, how they are found, and how information about them is stored and accessed."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:12
msgid "Various extensions are added on top, which implement specific systems such as marker tracking, plane tracking, and anchors. These are referred to as spatial capabilities."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:15
msgid "Each entity that can be handled by the system is broken up into smaller components, which makes it easy to extend the system and add new capabilities."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:18
msgid "Vendors have the ability to implement and expose additional capabilities and component types that can be used with the core API. For Godot these can be implemented in extensions. These implementations however fall outside of the scope of this manual."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:22
msgid "Finally it is important to note that the spatial entity system makes use of asynchronous functions. This means that you can start a process, and then get informed of it finishing later on."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:26
msgid "Setup"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:28
msgid "In order to use spatial entities you need to enable the related project settings. You can find these in the OpenXR section:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:33
msgid "Spatial entity settings"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:36
msgid "Setting"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:37
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:968
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1119
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1284
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1617
msgid "Description"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:38
msgid "Enabled"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:39
msgid "Enables the core of the spatial entities system. This must be enabled for any of the spatial entities systems to work."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:41
msgid "Enable spatial anchors"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:42
msgid "Enables the spatial anchors capability that allow creating and tracking spatial anchors."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:43
msgid "Enable persistent anchors"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:44
msgid "Enables the ability to make spatial anchors persistent. This means that their location is stored and can be retrieved in subsequent sessions."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:46
msgid "Enable built-in anchor detection"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:47
msgid "Enables our built-in anchor detection logic, this will automatically retrieve persistent anchors and adjust the positioning of anchors when tracking is updated."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:49
msgid "Enable plane tracking"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:50
msgid "Enables the plane tracking capability that allows detection of surfaces such as floors, walls, ceilings, and tables."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:52
msgid "Enable built-in plane detection"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:53
msgid "Enables our built-in plane detection logic, this will automatically react to new plane data becoming available."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:55
msgid "Enable marker tracking"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:56
msgid "Enables our marker tracking capability that allows detection of markers such as QR codes, Aruco markers, and April tags."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:58
msgid "Enable built-in marker tracking"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:59
msgid "Enables our built-in marker detection logic, this will automatically react to new markers being found or markers being moved around the player's space."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:64
msgid "Note that various XR devices also require permission flags to be set. These will need to be enabled in the export preset settings."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:67
msgid "Enabling the different capabilities activates the related OpenXR APIs, but additional logic is needed to interact with this data. For each core system we have built-in logic that can be enabled that will do this for you."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:71
msgid "We'll discuss the spatial entities system under the assumption that the built-in logic is enabled first. We will then take a look at the underlying APIs and how you can implement this yourself, however it should be noted that this is often overkill and that the underlying APIs are mostly exposed to allow GDExtension plugins to implement additional capabilities."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:77
msgid "Creating our spatial manager"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:79
msgid "When spatial entities are detected or created an :ref:`OpenXRSpatialEntityTracker<class_OpenXRSpatialEntityTracker>` object is instantiated and registered with the :ref:`XRServer<class_XRServer>`."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:83
msgid "Each type of spatial entity will implement its own subclass and we can thus react differently to each type of entity."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:86
msgid "Generally speaking we will instance different subscenes for each type of entity. As the tracker objects can be used with :ref:`XRAnchor3D<class_XRAnchor3D>` nodes, these subscenes should have such a node as their root node."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:90
msgid "All entity trackers will expose their location through the ``default`` pose."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:92
msgid "We can automate creating these subscenes and adding them to our scene tree by creating a manager object. As all locations are local to the :ref:`XROrigin3D<class_XROrigin3D>` node, we should create our manager as a child node of our origin node."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:96
msgid "Below is the basis of the script that implements our manager logic:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:237
msgid "Spatial anchors"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:239
msgid "Spatial anchors allow us to map real world locations in our virtual world in such a way that the XR runtime will keep track of these locations and adjust them as needed. If supported, anchors can be made persistent which means the anchors will be recreated in the correct location when your application starts again."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:244
msgid "You can think of use cases such as: - placing virtual windows around your space that are recreated when your application restarts - placing virtual objects on your table or on your walls and have them recreated"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:248
msgid "Spatial anchors are tracked using :ref:`OpenXRAnchorTracker<class_OpenXRAnchorTracker>` objects registered with the XRServer."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:251
msgid "When needed, the location of the spatial anchor will be updated automatically; the pose on the related tracker will be updated and thus the :ref:`XRAnchor3D<class_XRAnchor3D>` node will reposition."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:255
msgid "When a spatial anchor has been made persistent, a Universally Unique Identifier (or UUID) is assigned to the anchor. You will need to store this with whatever information you need to reconstruct the scene. In our example code below we'll simply call ``set_scene_path`` and ``get_scene_path``, but you will need to supply your own implementations for these functions."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:261
msgid "In order to create a persistent anchor you need to follow a specific flow: - Create the spatial anchor - Wait until the tracking status changes to ``ENTITY_TRACKING_STATE_TRACKING`` - Make the anchor persistent - Obtain the UUID and save it"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:267
msgid "When an existing persistent anchor is found a new tracker is added that has the UUID already set. It is this difference in workflow that allows us to correctly react to new and existing persistent anchors."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:273
msgid "If you unpersist an anchor, the UUID is destroyed but the anchor is not removed automatically. You will need to react to the completion of unpersisting an anchor and then clean it up. Also you will get an error if you try to destroy an anchor that is still persistent."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:278
msgid "To complete our anchor system we start by creating a scene that we'll set as the scene to instantiate for anchors on our spatial manager node."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:281
msgid "This scene should have an :ref:`XRAnchor3D<class_XRAnchor3D>` node as the root but nothing else. We will add a script to it that will load a subscene that contains the actual visual aspect of our anchor so we can create different anchors in our scene. We'll assume the intention is to make these anchors persistent and save the path to this subscene as metadata for our UUID."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:373
msgid "With our anchor scene in place we can add a couple of functions to our spatial manager script to create or remove anchors:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:449
msgid "There seems to be a bit of magic going on in the code above. Whenever a spatial anchor is created or removed on our anchor capability, the related tracker object is created or destroyed. This results in the spatial manager adding or removing the child scene for this anchor. Hence we can rely on this here."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:456
msgid "Plane tracking"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:458
msgid "Plane tracking allows us to detect surfaces such as walls, floors, ceilings, and tables in the player's vicinity. This data could come from a room capture performed by the user at any time in the past, or detected live by optical sensors. The plane tracking extension doesn't make a distinction here."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:465
msgid "Some XR runtimes do require vendor extensions to enable and/or configure this process but the data will be exposed through this extension."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:468
msgid "The code we wrote up above for the spatial manager will already detect our new planes. We do need to set up a new scene and assign that scene to the spatial manager."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:471
msgid "The root node for this scene must be an :ref:`XRAnchor3D<class_XRAnchor3D>` node. We'll add a :ref:`StaticBody3D<class_StaticBody3D>` node as a child and add a :ref:`CollisionShape3D<class_CollisionShape3D>` and :ref:`MeshInstance3D<class_MeshInstance3D>` node as children of the static body."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:478
msgid "The static body and collision shape will allow us to make the plane interactable."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:480
msgid "The mesh instance node allows us to apply a \"hole punch\" material to the plane, when combined with passthrough this turns our plane into a visual occluder. Alternatively we can assign a material that will visualize the plane for debugging."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:484
msgid "We configure this material as the ``material_override`` material on our MeshInstance3D. For our \"hole punch\" material, create a :ref:`ShaderMaterial<class_ShaderMaterial>` and use the following code as the shader code:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:497
msgid "We also need to add a script to our scene to ensure our collision and mesh are applied."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:525
msgid "If supported by the XR runtime there is additional metadata you can query on the plane tracker object. Of specific note is the ``plane_label`` property that, if available, identifies the type of surface. Please consult the :ref:`OpenXRPlaneTracker<class_OpenXRPlaneTracker>` class documentation for further information."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:532
msgid "Marker tracking"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:534
msgid "Marker tracking detects specific markers in the real world. These are usually printed images such as QR codes."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:537
msgid "The API exposes support for 4 different codes, QR codes, Micro QR codes, Aruco codes, and April tags, however XR runtimes are not required to support them all."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:540
msgid "When markers are detected, :ref:`OpenXRMarkerTracker<class_OpenXRMarkerTracker>` objects are instantiated and registered with the XRServer."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:543
msgid "Our existing spatial manager code already detects these, all we need to do is create a scene with an :ref:`XRAnchor3D<class_XRAnchor3D>` node at the root, save this, and assign it to the spatial manager as the scene to instantiate for markers."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:547
msgid "The marker tracker should be fully configured when assigned, so all that is needed is a ``_ready`` function that reacts to the marker data. Below is a template for the required code:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:584
msgid "As we can see, QR Codes provide a data block that is either a string or a byte array. Aruco and April tags provide an ID that is read from the code."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:587
msgid "It's up to your use case how best to link the marker data to the scene that needs to be loaded. An example would be to encode the name of the asset you wish to display in a QR code."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:591
msgid "Backend access"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:593
msgid "For most purposes the core system, along with any vendor extensions, should be what most users would use as provided."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:596
msgid "For those who are implementing vendor extensions, or those for whom the built-in logic doesn't suffice, backend access is provided through a set of singleton objects."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:599
msgid "These objects can also be used to query what capabilities are supported by the headset in use. We've already added code that checks for these in our spatial manager and spatial anchor code in the sections above."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:605
msgid "The spatial entities system will encapsulate many OpenXR entities in resources that are returned as RIDs."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:609
msgid "Spatial entity core"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:611
msgid "The core spatial entity functionality is exposed through the :ref:`OpenXRSpatialEntityExtension<class_OpenXRSpatialEntityExtension>` singleton."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:614
msgid "Specific logic is exposed through capabilities that introduce specialised component types, and give access to specific types of entities, however they all use the same mechanisms for accessing the entity data managed by the spatial entity system."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:618
msgid "We'll start by having a look at the individual components that make up the core system."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:621
msgid "Spatial contexts"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:623
msgid "A spatial context is the main object through which we query the spatial entities system. Spatial contexts allow us to configure how we interact with one or more capabilities."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:626
msgid "It's recommended to create a spatial context for each capability that you wish to interact with, in fact, this is what Godot does for its built-in logic."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:629
msgid "We start by setting the capability configuration objects for the capabilities we wish to access. Each capability will enable the components we support for that capability. Settings can determine which components will be enabled. We'll look at these configuration objects in more detail as we look at each supported capability."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:635
msgid "Creating a spatial context is an asynchronous action. This means we ask the XR runtime to create a spatial context, and at a point in the future the XR runtime will provide us with the result."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:639
msgid "The following script is the start of our example and can be added as a node to your scene. It shows the creation of a spatial context for plane tracking, and sets up our entity discovery."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:708
msgid "Discovery snapshots"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:710
msgid "Once our spatial context has been created the XR runtime will start managing spatial entities according to the configuration of the specified capabilities."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:713
msgid "In order to find new entities, or to get information about our current entities, we can create a discovery snapshot. This will tell the XR runtime to gather specific data related to all the spatial entities currently managed by the spatial context."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:717
msgid "This function is asynchronous as it may take some time to gather this data and offer its results. Generally speaking you will want to perform a discovery snapshot when new entities are found. OpenXR emits an event when there are new entities to be processed, this results in the ``spatial_discovery_recommended`` signal being emitted by our :ref:`OpenXRSpatialEntityExtension<class_OpenXRSpatialEntityExtension>` singleton."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:723
msgid "Note in the example code shown above, we're already connecting to this signal and calling the ``_on_perform_discovery`` method on our node. Let's implement this:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:764
msgid "Note that when calling ``discover_spatial_entities`` we specify a list of components. The discovery query will find any entity that is managed by the spatial context and has at least one of the specified components."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:769
msgid "Update snapshots"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:771
msgid "Performing an update snapshot allows us to get updated information about entities we already found previously with our discovery snapshot. This function is synchronous, and is mainly meant to obtain status and positioning data and can be run every frame."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:776
msgid "Generally speaking you would only perform update snapshots when it's likely entities change or have a lifetime process. A good example of this are persistent anchors and markers. Consult the documentation about a capability to determine if this is needed."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:780
msgid "It is not needed for plane tracking however to complete our example, here is an example of what an update snapshot would look like for plane tracking if we needed one:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:809
msgid "Note that in our example here we're using the same ``_process_snapshot`` function to process the snapshot. This makes sense in most situations. However if the components you've specified when creating the snapshot are different between your discovery snapshot and your update snapshot, you have to take the different components into account."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:815
msgid "Querying snapshots"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:817
msgid "Once we have a snapshot we can run queries over that snapshot to obtain the data held within. The snapshot is guaranteed to remain unchanged until you free it."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:820
msgid "For each component we've added to our snapshot we have an accompanying data object. This data object has a double function, adding it to your query ensures we query that component type, and it is the object into which the queried data is loaded."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:824
msgid "There is one special data object that must always be added to our request list as the very first entry and that is :ref:`OpenXRSpatialQueryResultData<class_OpenXRSpatialQueryResultData>`. This object will hold an entry for every returned entity with its unique ID and the current state of the entity."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:829
msgid "Completing our discovery logic we add the following:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:896
msgid "In the above example we're relying on ``ENTITY_TRACKING_STATE_STOPPED`` to clean up spatial entities that are no longer being tracked. This is only available with update snapshots."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:899
msgid "For capabilities that only rely on discovery snapshots you may wish to do a cleanup based on entities that are no longer part of the snapshot instead of relying on the state change."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:903
msgid "Spatial entities"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:905
msgid "With the above information we now know how to query our spatial entities and get information about them, but there is a little more we need to look at when it comes to the entities themselves."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:908
msgid "In theory we're getting all our data from our snapshots, however OpenXR has an extra API where we create a spatial entity object from our entity ID. While this object exists the XR runtime knows that we are using this entity and that the entity is not cleaned up early. This is a prerequisite for performing an update query on this entity."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:914
msgid "In our example code we do so by calling ``OpenXRSpatialEntityExtension.make_spatial_entity``."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:916
msgid "Some spatial entity APIs will automatically create the object for us. In this case we need to call ``OpenXRSpatialEntityExtension.add_spatial_entity`` to register the created object with our implementation."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:920
msgid "Both functions return an RID that we can use in further functions that require our entity object."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:922
msgid "When we're done we can call ``OpenXRSpatialEntityExtension.free_spatial_entity``."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:924
msgid "Note that we didn't do so in our example code. This is automatically handled when our :ref:`OpenXRSpatialEntityTracker<class_OpenXRSpatialEntityTracker>` instance is destroyed."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:928
msgid "Spatial anchor capability"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:930
msgid "Spatial anchors are managed by our :ref:`OpenXRSpatialAnchorCapability<class_OpenXRSpatialAnchorCapability>` singleton object. After the OpenXR session has been created you can call ``OpenXRSpatialAnchorCapability.is_spatial_anchor_supported`` to check if the spatial anchor feature is supported on your hardware."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:935
msgid "The spatial anchor capability breaks the mold a little from what we've shown above."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:937
msgid "The spatial anchor system allows us to identify, track, persist, and share a physical location. What makes this different is that we're creating and destroying the anchor and are thus managing its lifecycle."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:941
msgid "We thus only use the discovery system to discover anchors created and persisted in previous sessions, or anchors shared with us."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:946
msgid "Sharing of anchors is currently not supported in the spatial entities specification."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:948
msgid "As we showed in our example before we always start with creating a spatial context but now using the :ref:`OpenXRSpatialCapabilityConfigurationAnchor<class_OpenXRSpatialCapabilityConfigurationAnchor>` configuration object. We'll show an example of this code after we discuss persistence scopes. First we'll look at managing local anchors."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:954
msgid "There is no difference in creating spatial anchors from what we've discussed around the built-in logic. The only important thing is to pass your own spatial context as a parameter to ``OpenXRSpatialAnchorCapability.create_new_anchor``."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:958
msgid "Making an anchor persistent requires you to wait until the anchor is tracking, this means that you must perform update queries for any anchor you create so you can process state changes."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:961
msgid "In order to enable making anchors persistent you also have to set up a persistence scope. In the core of OpenXR two types of persistence scopes are supported:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:964
msgid "Persistence scopes"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:967
msgid "Enum"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:969
msgid "PERSISTENCE_SCOPE_SYSTEM_MANAGED"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:970
msgid "Provides the application with read-only access (i.e. applications cannot modify this store) to spatial entities persisted and managed by the system. The application can use the UUID in the persistence component for this store to correlate entities across spatial contexts and device reboots."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:974
msgid "PERSISTENCE_SCOPE_LOCAL_ANCHORS"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:975
msgid "Persistence operations and data access is limited to spatial anchors, on the same device, for the same user and app (using `persist_anchor` and `unpersist_anchor` functions)"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:979
msgid "We'll start with a new script that handles our spatial anchors. It will be similar to the script presented earlier but with a few differences."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:982
msgid "The first being the creation of our persistence scope."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1064
msgid "With our persistence scope created, we can now create our spatial context."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1105
msgid "Creating our discovery snapshot for our anchors is nearly the same as we did before, however it only makes sense to create our snapshot for persistent anchors. We already know the anchors we created during our session, we just want access to those coming from the XR runtime."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1109
msgid "We also want to perform regular update queries, here we are only interested in the state so we do want to process our snapshot slightly differently."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1112
msgid "The anchor system gives us access to two components:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1114
msgid "Anchor components"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1117
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1282
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1615
msgid "Component"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1118
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1283
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1616
msgid "Data class"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1120
msgid "COMPONENT_TYPE_ANCHOR"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1121
msgid ":ref:`OpenXRSpatialComponentAnchorList<class_OpenXRSpatialComponentAnchorList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1122
msgid "Provides us with the pose (location + orientation) of each anchor"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1123
msgid "COMPONENT_TYPE_PERSISTENCE"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1124
msgid ":ref:`OpenXRSpatialComponentPersistenceList<class_OpenXRSpatialComponentPersistenceList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1125
msgid "Provides us with the persistence state and UUID of each anchor"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1192
msgid "Finally we can process our snapshot. Note that we are using :ref:`OpenXRAnchorTracker<class_OpenXRAnchorTracker>` as our tracker class as this already has all the support for anchors built in."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1264
msgid "Plane tracking capability"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1266
msgid "Plane tracking is handled by the :ref:`OpenXRSpatialPlaneTrackingCapability<class_OpenXRSpatialPlaneTrackingCapability>` singleton class."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1270
msgid "After the OpenXR session has been created you can call ``OpenXRSpatialPlaneTrackingCapability.is_supported`` to check if the plane tracking feature is supported on your hardware."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1273
msgid "While we've provided most of the code for plane tracking up above, we'll present the full implementation below as it has a few small tweaks. There is no need to update snapshots here, we just do our discovery snapshot and implement our process function."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1277
msgid "Plane tracking gives access to two components that are guaranteed to be supported, and three optional components."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1279
msgid "Plane tracking components"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1285
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1621
msgid "COMPONENT_TYPE_BOUNDED_2D"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1286
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1622
msgid ":ref:`OpenXRSpatialComponentBounded2DList<class_OpenXRSpatialComponentBounded2DList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1287
#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1623
msgid "Provides us with the center pose and bounding rectangle for each plane."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1288
msgid "COMPONENT_TYPE_PLANE_ALIGNMENT"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1289
msgid ":ref:`OpenXRSpatialComponentPlaneAlignmentList<class_OpenXRSpatialComponentPlaneAlignmentList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1290
msgid "Provides us with the alignment of each plane"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1291
msgid "COMPONENT_TYPE_MESH_2D"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1292
msgid ":ref:`OpenXRSpatialComponentMesh2DList<class_OpenXRSpatialComponentMesh2DList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1293
msgid "Provides us with a 2D mesh that shapes each plane"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1294
msgid "COMPONENT_TYPE_POLYGON_2D"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1295
msgid ":ref:`OpenXRSpatialComponentPolygon2DList<class_OpenXRSpatialComponentPolygon2DList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1296
msgid "Provides us with a 2D polygon that shapes each plane"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1297
msgid "COMPONENT_TYPE_PLANE_SEMANTIC_LABEL"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1298
msgid ":ref:`OpenXRSpatialComponentPlaneSemanticLabelList<class_OpenXRSpatialComponentPlaneSemanticLabelList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1299
msgid "Provides us with a type identification of each plane"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1301
msgid "Our plane tracking configuration object already enables all supported components, but we'll need to interrogate it so we'll store our instance in a member variable. We can use our :ref:`OpenXRPlaneTracker<class_OpenXRPlaneTracker>` tracker object to store our component data."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1499
msgid "Marker tracking capability"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1501
msgid "Marker tracking is handled by the :ref:`OpenXRSpatialMarkerTrackingCapability<class_OpenXRSpatialMarkerTrackingCapability>` singleton class."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1505
msgid "Marker tracking works similarly to plane tracking, however we're now tracking specific entities in the real world based on some code printed on an object like a piece of paper."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1508
msgid "There are various different marker tracking options. OpenXR supports 4 out of the box, the following table provides more information and the function name with which to check if your headset supports a given option:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1512
msgid "Marker tracking options"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1515
msgid "Option"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1516
msgid "Check for support"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1517
msgid "Configuration object"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1518
msgid "April tag"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1519
msgid "``april_tag_is_supported``"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1520
msgid ":ref:`OpenXRSpatialCapabilityConfigurationAprilTag<class_OpenXRSpatialCapabilityConfigurationAprilTag>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1521
msgid "Aruco"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1522
msgid "``aruco_is_supported``"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1523
msgid ":ref:`OpenXRSpatialCapabilityConfigurationAruco<class_OpenXRSpatialCapabilityConfigurationAruco>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1524
msgid "QR code"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1525
msgid "``qrcode_is_supported``"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1526
msgid ":ref:`OpenXRSpatialCapabilityConfigurationQrCode<class_OpenXRSpatialCapabilityConfigurationQrCode>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1527
msgid "Micro QR code"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1528
msgid "``micro_qrcode_is_supported``"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1529
msgid ":ref:`OpenXRSpatialCapabilityConfigurationMicroQrCode<class_OpenXRSpatialCapabilityConfigurationMicroQrCode>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1531
msgid "Each option has its own configuration object that you can use when creating a spatial entity."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1533
msgid "QR codes allow you to encode a string which is decoded by the XR runtime and accessible when a marker is found. With April tags and Aruco markers, binary data is encoded which you again can access when a marker is found, however you need to configure the detection with the correct decoding format."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1537
msgid "As an example we'll create a spatial context that will find QR codes and Aruco markers."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1610
msgid "Every marker regardless of typer will consist of two components:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1612
msgid "Marker tracking components"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1618
msgid "COMPONENT_TYPE_MARKER"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1619
msgid ":ref:`OpenXRSpatialComponentMarkerList<class_OpenXRSpatialComponentMarkerList>`"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1620
msgid "Provides us with the type, ID (Aruco and April Tag), and/or data (QR Code) for each marker."
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1625
msgid "We add our discovery implementation:"
msgstr ""

#: ../../docs/tutorials/xr/openxr_spatial_entities.rst:1743
msgid "And we add our update functionality:"
msgstr ""
