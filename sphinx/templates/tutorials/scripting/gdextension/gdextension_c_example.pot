# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)
# This file is distributed under the same license as the Godot Engine package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Godot Engine latest\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:4
msgid "GDExtension C example"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:7
msgid "Introduction"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:9
msgid "This is a simple example on how to work with GDExtension directly with C code. Note that the API is not meant to be used directly, so this will definitely be quite verbose and require a lot of steps even for a small example. However, it serves as a reference for creating bindings for a different language. It is still possible to use the API directly if you prefer, which might be convenient when only binding a third-party library."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:16
msgid "In this example we will create a custom node that moves a sprite on the screen based on the user's parameters. While very simple, it serves to show how to do some of the things with GDExtension, like registering custom classes with methods, properties, and signals. It gives an insight on the GDExtension API."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:22
msgid "Setting up the project"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:24
msgid "There are a few prerequisites you'll need:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:26
msgid "a Godot 4.2 (or later) executable,"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:27
msgid "a C compiler,"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:28
msgid "SCons as a build tool."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:30
msgid "Since this is using the API directly, there's no need to use the `godot-cpp repository <https://github.com/godotengine/godot-cpp>`__."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:34
msgid "File structure"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:36
msgid "To organize our files, we're gonna split into mainly two folders:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:46
msgid "We also need a copy of the ``gdextension_interface.h`` header from the Godot source code, which can be obtained directly from the Godot executable by running the following command:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:54
msgid "This creates the header in the current folder, so you can just copy it to the ``src`` folder in the example project."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:57
msgid "Lastly, there's another source of information we need to refer to, which is the JSON file with the Godot API reference. This file won't be used by the code directly, we will only use it to extract some information manually."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:61
msgid "To get this JSON file, just call the Godot executable:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:67
msgid "The resulting ``extension_api.json`` file will be created in the current folder. You can copy this file to the example folder to have it handy."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:71
msgid "This extension is targeting Godot 4.2, but it should work on later versions as well. If you want to target a different minimal version, make sure to get the header and the JSON from the version Godot version you are targeting."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:76
msgid "Buildsystem"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:78
msgid "Using a buildsystem makes our life a lot easier when dealing with C code. For the sake of convenience, we'll use SCons since it's the same as what Godot itself uses."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:82
msgid "The following ``SConstruct`` file is a simple one that will build your extension to the current platform that you are using, be it Linux, macOS, or Windows. This will be a non-optimized build for debugging purposes. It also assumes a 64-bit build, which is relevant for some parts of the example code. Making other build types and cross-compilation is out of the scope of this tutorial. Save this file to the root folder."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:122
msgid "This will include all C files in the ``src`` folder, so we don't need to change this file when adding new source files."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:126
msgid "Initializing the extension"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:128
msgid "The first bit of code will be responsible for initializing the extension. This is what makes Godot aware of what our GDExtension provides, such as classes and plugins."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:132
msgid "Create the file ``init.h`` in the ``src`` folder, with the following contents:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:149
msgid "The functions declared here have the signatures expected by the GDExtension API."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:151
msgid "Note the inclusion of the ``defs.h`` file. This is one of our helpers to simplify writing the extension code. For now it will only contain the definition of ``GDE_EXPORT``, a macro that makes the function public in the shared library so Godot can properly call it. This macro helps abstracting what each compiler expects."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:157
msgid "Create the ``defs.h`` file in the ``src`` folder with the following contents:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:180
msgid "We also include some standard headers to make things easier. Now we only have to include ``defs.h`` and those will come as a bonus."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:183
msgid "Now, let's implement the functions we just declared. Create a file called ``init.c`` in the ``src`` folder and add this code:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:208
msgid "What this does is set up the initialization data that Godot expects. The functions to initialize and deinitialize are set so Godot will call then when needed. It also sets the initialization level which varies per extension. Since we plan to add a custom node, the ``SCENE`` level is enough."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:213
msgid "We will fill the ``initialize_gdexample_module()`` function later to register our custom class."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:216
msgid "A basic class"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:218
msgid "In order to make an actual node, first we'll create a C struct to hold data and functions that will act as methods. The plan is to make this a custom node that inherits from :ref:`Sprite2D <class_Sprite2D>`."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:222
msgid "Create a file called ``gdexample.h`` in the ``src`` folder with the following contents:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:252
msgid "Noteworthy here is the ``object`` field, which holds a pointer to the Godot object, and the ``gdexample_class_bind_methods()`` function, which will register the metadata of our custom class (properties, methods, and signals). The latter is not entirely necessary, as we can do it when registering the class, but it makes clearer to separate the concerns and let our class register its own metadata."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:259
msgid "The ``object`` field is necessary because our class will inherit a Godot class. Since we can't inherit it directly, as we are not interacting with the source code (and C doesn't even have classes), we instead tell Godot to create an object of a type it knows and attach our extension to it. We will need the reference to such objects when calling methods on the parent class, for instance."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:266
msgid "Let's create the source counterpart of this header. Create the file ``gdexample.c`` in the ``src`` folder and add the following code to it:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:286
msgid "As we don't have anything to do with those functions yet, they'll stay empty for a while."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:289
msgid "The next step is registering our class. However, in order to do so we need to create a :ref:`StringName <class_StringName>` and for that we have to get a function from the GDExtension API. Since we'll need this a few times and we'll also need other things, let's create a wrapper API to facilitate this kind of chore."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:296
msgid "A wrapper API"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:298
msgid "We'll start by creating an ``api.h`` file in the ``src`` folder:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:340
msgid "This file will include many other helpers as we fill our extension with something useful. For now it only has a pointer to a function that creates a StringName from a C string (in Latin-1 encoding) and another to destruct a StringName, which we'll need to use to avoid leaking memory, as well as the function to register a class, which is our initial goal."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:346
msgid "We also keep a reference to the ``class_library`` here. This is something that Godot provides to us when initializing the extension and we'll need to use it when registering the things we create so Godot can tell which extension is making the call."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:351
msgid "There's also a function to load those function pointers from the GDExtension API."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:353
msgid "Let's work on the source counterpart of this header. Create the ``api.c`` file in the ``src`` folder, adding the following code:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:377
msgid "The first important thing here is ``p_get_proc_address``. This a function from the GDExtension API that is passed during initialization. You can use this function to request specific functions from the API by their name. Here we are caching the results so we don't have to keep a reference for ``p_get_proc_address`` everywhere and use our wrapper instead."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:383
msgid "At the start we request the ``variant_get_ptr_destructor()`` function. This is not going to be used outside of this function, so we don't add to our wrapper and only cache it locally. The cast is necessary to silence compiler warnings."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:387
msgid "Then we get the function that creates a StringName from a C string, exactly what we mentioned before as a needed function. We store that in our ``constructors`` struct."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:391
msgid "Next, we use the ``variant_get_ptr_destructor()`` function we just got to query for the destructor for StringName, using the enum value from ``gdextension_interface.h`` API as a parameter. We could get destructors for other types in a similar manner, but we'll limit ourselves to what is needed for the example."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:397
msgid "Lastly, we get the ``classdb_register_extension_class2()`` function, which we'll need in order to register our custom class."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:401
msgid "You may wonder why the ``2`` is there in the function name. This means it's the second version of this function. The old version is kept to ensure backwards compatibility with older extensions, but since we have the second version available, it's best to use the new one, because we don't intend to support older Godot versions in this example."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:407
msgid "The ``gdextension_interface.h`` header documents in which Godot version each function was introduced."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:410
msgid "We also define the ``class_library`` variable here, which will be set during initialization."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:413
msgid "Speaking of initialization, now we have to change the ``init.c`` file in order to fill the things we just added:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:425
msgid "Here we set the ``class_library`` as needed and call our new ``load_api()`` function. Don't forget to also include the new headers at the top of this file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:436
msgid "Since we are here, we can register our new custom class. Let's fill the ``initialize_gdexample_module()`` function:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:489
msgid "The struct with the class information is the biggest thing here. None of its fields are required with the exception of ``create_instance_func`` and ``free_instance_func``. We haven't made those functions yet, so we'll have to work on them soon. Note that we skip the initialization if it isn't at the ``SCENE`` level. This function may be called multiple times, once for each level, but we only want to register our class once."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:496
msgid "The other undefined thing here is ``StringName``. This will be an opaque struct meant to hold the data of a Godot StringName in our extension. We'll define it in the appropriately named ``defs.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:519
msgid "As mentioned in the comment, the sizes can be found in the ``extension_api.json`` file that we generated earlier, under the ``builtin_class_sizes`` property. The ``BUILD_32`` is never defined, as we assume we are working with a 64-bits build of Godot here, but if you need it you can add ``env.Append(CPPDEFINES=[\"BUILD_32\"])`` to your ``SConstruct`` file."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:525
msgid "The ``// Types.`` comment foreshadows that we'll be adding more types to this file. Let's leave that for later."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:528
msgid "The ``StringName`` struct here is just to hold Godot data, so we don't really care what is inside of it. Though, in this case, it is just a pointer to the data in the heap. We'll use this struct when we need to allocate data for a StringName ourselves, like we are doing when registering our class."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:533
msgid "Back to registering, we need to work on our create and free functions. Let's include them in ``gdexample.h`` since they're specific to the custom class:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:545
msgid "Before we can implement those function, we'll need a few more things in our API. We need a way to allocate and free memory. While we could do this with good ol' ``malloc()``, we can instead make use of Godot's memory management functions. We'll also need a way to create a Godot object and set it with our custom instance."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:551
msgid "So let's change the ``api.h`` to include these new functions:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:566
msgid "Then we change the ``load_api()`` function in ``api.c`` to grab these new functions:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:583
msgid "Now we can go back to ``gdexample.c`` and define the new functions, without forgetting to include the ``api.h`` header:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:633
msgid "When instantiating an object, first we create a new Sprite2D object, since that's the parent of our class. Then we allocate memory for our custom struct and call its constructor. We save the pointer to the Godot object in the struct as well like we mentioned earlier."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:638
msgid "Then we set our custom struct as the instance data. This will make Godot know that the object is an instance of our custom class and properly call our custom methods for instance, as well as passing this data back."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:642
msgid "Note that we return the Godot object we created, not our custom struct."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:644
msgid "For the ``gdextension_free_instance()`` function, we only call the destructor and free the memory we allocated for the custom data. It is not necessary to destruct the Godot object since that will be taken care of by the engine itself."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:649
msgid "A demo project"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:651
msgid "Now that we can create and free our custom object, we should be able to try it out in an actual project. For this, you need to open Godot and create a new project on the ``demo`` folder. The project manager may warn you the folder isn't empty if you have compiled the extension before, you can safely ignore this warning this time."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:657
msgid "If you didn't compile the extension yet, it is the time to do it now. To do that, open a terminal or command prompt, navigate to the root folder of the extension and run ``scons``. It should compile quickly since the extension is very simple."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:662
msgid "Then, create a file called ``gdexample.gdextension`` inside the ``demo`` folder. This is a Godot resource that describes the extension, allowing the engine to properly load it. Put the following content in this file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:678
msgid "As you can see, ``gdexample_library_init()`` is the same name of the function we defined in our ``init.c`` file. It is important that the names match because it is how Godot calls the entry point of the extension."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:682
msgid "We also set the compatibility minimum to 4.2, since we are targeting this version. It should still work on later versions. If you are using a later Godot version and rely on the new features, you need to increase this value to a version number that has everything you use. See :ref:`doc_what_is_gdextension_version_compatibility` for more information."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:688
msgid "In the ``[libraries]`` section we set up the paths to the shared library on different platforms. Here there's only the debug versions since that's what we are working on for the example. Using :ref:`feature tags <doc_feature_tags>` you can fine tune this to also provide release versions, add more target operating systems, as well as providing 32-bit and 64-bit binaries."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:694
msgid "You can also add library dependencies and custom icons for your classes in this file, but this is out of the scope for this tutorial."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:697
msgid "After saving the file, go back to the editor. Godot should automatically load the extension. Nothing will be seen because our extension only registers a new class. To use this class add a ``Node2D`` as a root of the scene. Move it to the middle of viewport for better visibility. Then add a new child node to the root and in the **Create New Node** dialog search for \"GDExample\", the name of our class, as it should be listed there. If it isn't, it means that Godot didn't load the extension properly, so try restarting the editor and retrace the steps to see if anything went missing."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:706
msgid "Our custom class is derived from ``Sprite2D``, so it has a **Texture** property in the Inspector. Set this to the ``icon.svg`` file that Godot handily created for us when making the project. Save this scene as ``main.tscn`` and run it. You may want to set it as the main scene for convenience."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:713
msgid "Voil√†! We have a custom node running in Godot. However, it does not do anything and has nothing different than a regular ``Sprite2D`` node. We will fix that next by adding custom methods and properties."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:718
msgid "Custom methods"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:720
msgid "A common thing in extensions is creating methods for the custom classes and exposing those to the Godot API. We are going to create a couple of getters and setters which are need for binding the properties afterwards."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:724
msgid "First, let's add the new fields in our struct to hold the values for ``amplitude`` and ``speed``, which we will use later on when creating the behavior for the node. Add them to the ``gdexample.h`` file, changing the ``GDExample`` struct:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:745
msgid "In the same file, add the declaration for the getters and setters, right after the destructor."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:763
msgid "In the ``gdexample.cpp`` file, we will initialize these values in the constructor and add the implementations for those new functions, which are quite trivial:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:794
msgid "To make those simple functions work when called by Godot, we will need some wrappers to help us properly convert the data to and from the engine."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:797
msgid "First, we will create wrappers for ``ptrcall``. This is what Godot uses when the types of the values are known to be exact, which avoids using Variant. We're gonna need two of those: one for the functions that take no arguments and return a ``double`` (for the getters) and another for the functions that take a single ``double`` argument and return nothing (for the setters)."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:803
msgid "Add the declarations to the ``api.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:811
msgid "Those two functions follow the ``GDExtensionClassMethodPtrCall`` type, as defined in the ``gdextension_interface.h``. We use ``float`` as a name here because in Godot the ``float`` type has double precision, so we keep this convention."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:816
msgid "Then we implement those functions in the ``api.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:834
msgid "The ``method_userdata`` argument is a custom value that we give to Godot, in this case we will set as the function pointer for the one we want to call. So first we convert it to the function type, then we just call it by passing the arguments when needed, or setting the return value."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:839
msgid "The ``p_instance`` argument contains the custom instance of our class, which we gave with ``object_set_instance()`` when creating the object."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:842
msgid "``p_args`` is an array of arguments. Note this contains **pointers** to the values. That's why we dereference it when passing to our functions. The number of arguments will be declared when binding the function (which we will do soon) and it will always include default ones if those exist."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:847
msgid "Finally, the ``r_ret`` is a pointer to the variable where the return value needs to be set. Like the arguments, it will be the correct type as declared. For the function that does not return, we have to avoid setting it."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:851
msgid "Note how the type and argument counts are exact, so if we needed different types, for example, we would have to create more wrappers. This could be automated using some code generation, but this is out of the scope for this tutorial."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:856
msgid "While the ``ptrcall`` functions are used when types are exact, sometimes Godot cannot know if that's the case (when the call comes from a dynamically typed language, such as GDScript). In those situations it uses regular ``call`` functions, so we need to provide those as well when binding."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:861
msgid "Let's create two new wrappers in the ``api.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:868
msgid "These follow the ``GDExtensionClassMethodCall`` type, which is a bit different. First, you receive pointers to Variants instead of exact types. There's also the amount of arguments and an error struct that you can set if something goes wrong."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:873
msgid "In order to check the type and also extract interact with Variant, we will need a few more functions from the GDExtension API. So let's expand our wrapper structs:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:893
msgid "The names say all about what those do. We have a couple of constructors to create and extract a floating point value to and from a Variant. We also have a couple of helpers to actually get those constructors, as well as a function to find out the type of a Variant."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:898
msgid "Let's get those from the API, like we did before, by changing the ``load_api()`` function in the ``api.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:921
msgid "Now that we have these set, we can implement our call wrappers in the same file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:977
msgid "These functions are a bit longer but easy to follow. First they check if the argument count is as expected and if not they set the error struct and return. For the one that has one parameter, it also checks if the argument type is correct. This is important because mismatched types when extracting from Variant can cause crashes."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:983
msgid "Then it proceeds to extract the argument using the constructor we setup before. The one with no arguments instead sets the return value after calling the function. Note how they use a pointer to a ``double`` variable, since this is what those constructors expect."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:988
msgid "Before we can actually bind our methods, we need a way to create ``GDExtensionPropertyInfo`` instances. While we could do them inside the binding functions that we'll implement afterwards, it's easier to have a helper for it since we'll need it multiple times, including for when we bind properties."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:993
msgid "Let's create these two functions in the ``api.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1012
msgid "The first one is a simplified version of the second since we usually don't need all the arguments for the property and are okay with the defaults. Then we also have a function to destruct the PropertyInfo since we need to create Strings and StringNames that need to be properly disposed of."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1017
msgid "Speaking of which, we also need a way to create and destruct Strings, so we'll make an addition to existing structs in this same file. We'll also get a new API function for actually binding our custom method."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1041
msgid "Before implementing those, let's do a quick stop in the ``defs.h`` file and include the size of the ``String`` type and a couple of enums:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1077
msgid "While it's the same size as ``StringName``, it is more clear to use a different name for it."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1080
msgid "The enums here are just helpers to give names to the numbers they represent. The information about them is present in the ``extension_api.json`` file. Here we just set up the ones we need for the tutorial, to keep it more concise."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1084
msgid "Going now to the ``api.c``, we need to load the pointers to the new functions we added to the API."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1105
msgid "Then we can also implement the functions to create the ``PropertyInfo`` struct."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1156
msgid "The simple version of ``make_property()`` just calls the more complete one with a some default arguments. What those values mean exactly is out of the scope of this tutorial, check the page about the :ref:`Object class <doc_object_class>` for more details about binding methods and properties."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1161
msgid "The complete version is more involved. First, it creates ``String``'s and ``StringName``'s for the needed fields, by allocating memory and calling their constructors. Then it creates a ``GDExtensionPropertyInfo`` struct and sets all the fields with the arguments provided. Finally it returns this created struct."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1166
msgid "The ``destruct_property()`` function is straightforward, it simply calls the destructors for the created objects and frees their allocated memory."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1169
msgid "Let's go back again to the header ``api.h`` to create the functions that will actually bind the methods:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1189
msgid "Then switch back to the ``api.c`` file to implement these:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1276
msgid "Both functions are very similar. First, they create a ``StringName`` with the method name. This is created in the stack since we don't need to keep it after the function ends. Then they create local variables to hold the ``call_func`` and ``ptrcall_func``, pointing to the helper functions we defined earlier."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1281
msgid "In the next step they diverge a bit. The first one creates a property for the return value, which has an empty name since it's not needed. The other creates an array of properties for the arguments, which in this case has a single element. This one also has an array of metadata, which can be used if there's something special about the argument (e.g. if an ``int`` value is 32 bits long instead of the default of 64 bits)."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1288
msgid "Afterwards, they create the ``GDExtensionClassMethodInfo`` with the required fields for each case. Then they make a ``StringName`` for the class name, in order to associate the method with the class. Next, they call the API function to actually bind this method to the class. Finally, we destruct the objects we created since they aren't needed anymore."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1295
msgid "The bind helpers here use the call helpers we created earlier, so do note that those call helpers only accept the Godot ``FLOAT`` type (which is equivalent to ``double`` in C). If you intend to use this for other types, you would need to check the type of the arguments and return type and select an appropriate function callback. This is avoided here only to keep the example from becoming even longer."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1302
msgid "Now that we have the means to bind methods, we can actually do so in our custom class. Go to the ``gdexample.c`` file and fill up the ``gdexample_class_bind_methods()`` function:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1317
msgid "Since this function is already being called by the initialization process, we can stop here. This function is much more straightforward after we created all the infrastructure to make this work. You can see that implementing the binding functions inline here would take some space and also be quite repetitive. This also makes it easier to add another method in the future."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1323
msgid "If you compile the code and reopen the demo project, nothing will be different at first, since we only added two new methods. To ensure those are registered properly, you can search for ``GDExample`` in the editor help and verify they are present in the documentation page."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1332
msgid "Custom properties"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1334
msgid "Since we now have the getter and setter for our properties already bound, we can move forward to create actual properties that will be displayed in the Godot editor inspector."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1338
msgid "Given our extensive setup in the previous section, there are only a few things needed to enable us to bind properties. First, let's get a new API function in the ``api.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1350
msgid "Let's also declare a function here to bind properties:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1361
msgid "In the ``api.c`` file, we can load the new API function:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1374
msgid "Then we can implement our new helper function in this same file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1402
msgid "This function is similar to the one for binding methods. The main difference is that we don't need an extra struct since we can simply use the ``GDExtensionPropertyInfo`` that is created by our helper function, so it's more straightforward. It only creates the ``StringName`` values from the C strings, creates a property info struct using our helper, calls the API function to register the property in the class and then destructs all the objects we created."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1410
msgid "With this done, we can extend the ``gdexample_class_bind_methods()`` function in the ``gdexample.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1426
msgid "If you build the extension with ``scons``, you'll see in the Godot editor the new property shown not only on the documentation page for the custom class but also in the Inspector dock when the ``GDExample`` node is selected."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1433
msgid "Binding virtual methods"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1435
msgid "Our custom node now has properties to influence how it operates, but it still doesn't do anything. In this section, we will bind the virtual method :ref:`_process() <class_Node_private_method__process>` and make our custom sprite move a little bit."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1440
msgid "In the ``gdexample.h`` file, let's add a function that represents the custom ``_process()`` method:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1448
msgid "We'll also add a \"private\" field to keep track of the time passed in our custom struct. This is \"private\" only in the sense that it won't be bound to the Godot API, even though it is public in the C side, given the language lacks access modifiers."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1462
msgid "On the counterpart source file ``gdexample.c`` we need to initialize the new field in the constructor:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1474
msgid "Then we can create the simplest implementation for the ``_process`` method:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1483
msgid "For now it will do nothing but update the private field we created. We'll come back to this after the method is properly bound."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1486
msgid "Virtual methods are a bit different from the regular bindings. Instead of explicitly registering the method itself, we'll register a special function that Godot will call to ask if a particular virtual method is implemented in our extension. The engine will pass a ``StringName`` as an argument so, following the spirit of this tutorial, we'll create a helper function to check if it is equal to a C string."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1493
msgid "Let's add the declaration to the ``api.h`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1500
msgid "We'll also add a new struct to this file, to hold function pointers for custom operators:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1509
msgid "Then in the ``api.c`` file we'll load the function pointer from the API:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1525
msgid "As you can see we need a new local helper here in order to grab the function pointer for the operator."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1528
msgid "With this handy, we can easily create our comparison function in the same file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1549
msgid "This function creates a ``StringName`` from the argument, compares with the other one using the operator function pointer, and returns the result. Note that the return value for the operator is passed as an out reference, this is a common thing in the API."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1554
msgid "Let's go back to the ``gdexample.h`` file and add a couple of functions that will be used as the callbacks for the Godot API:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1562
msgid "There are actually two ways of registering virtual methods. Only one has the ``get`` part, in which you give Godot a properly crafted function pointer which will be called. For this we would need to create another helper for each virtual method, something that is not very convenient. Instead, we use the second method which allows us to return any data, and then Godot will call a second callback and give us back this data along with the call information. We can simply give our own function pointer as custom data and then have a single callback for all virtual methods. Although in this example we will only use it for one method, this way is simpler to expand."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1572
msgid "So let's implement those two functions in the ``gdexample.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1596
msgid "Those functions are also quite straightforward after making all the helpers previously."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1599
msgid "For the first one, we simply check if the function name requested is ``_process`` and if it is we return a function pointer to our implementation of it. Otherwise we return ``NULL``, signaling that the method is not being overridden. We don't use the ``p_class_userdata`` here since this function is meant only for one class and we don't have any data associated with it."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1605
msgid "The second one is similar. If it is the ``_process()`` method, it uses the given function pointer to call the ``ptrcall`` helper, passing the call arguments forward. Otherwise it simply does nothing, since we don't have any other virtual methods being implemented."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1610
msgid "The only thing missing is using those callbacks when the class is registered. Go to the ``init.c`` file and change the ``class_info`` initialization to include those, replacing the ``NULL`` value used previously:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1630
msgid "This is enough to bind the virtual method. If you build the extension and run the demo project again, the ``_process()`` function will be called. You just won't be able to tell since the function itself does nothing visible. We will solve this now by making the custom node move following a pattern."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1635
msgid "In order to make our node do stuff, we'll need to call Godot methods. Not only the GDExtension API functions as we've being doing so far, but actual engine methods, as we would do with scripting. This naturally requires some extra setup."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1639
msgid "First, let's add :ref:`class_Vector2` to our ``defs.h`` file, so we can use it in our method:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1663
msgid "The ``REAL_T_IS_DOUBLE`` define is only needed if your Godot version was built with double precision support, which is not the default."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1666
msgid "Now, in the ``api.h`` file, we'll add few things to the API structs, including a new one for holding engine methods to call."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1691
msgid "Then in the ``api.c`` file we can grab the function pointers from Godot:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1713
msgid "The only noteworthy part here is the ``Vector2`` constructor, for which we request the index ``3``. Since there are multiple constructors with different kinds of arguments, we need to specify which one we want. In this case we're getting the one that takes two float numbers as the ``x`` and ``y`` coordinates, hence the name. This index can be retrieved from the ``extension_api.json`` file. Note we also need a new local helper to get it."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1720
msgid "Be aware that we don't get anything for the methods struct here. This is because this function is called too early in the initialization process, so classes won't be properly registered yet."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1724
msgid "Instead, we're gonna use the initialization level callback to grab those when we are registering our custom class. Add this to the ``init.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1750
msgid "Here we create ``StringName``'s for the class and method we want to get, then use the GDExtension API to retrieve their ``MethodBind``, which is an object that represents the bound method. We get the ``set_position`` method from ``Node2D`` since this is where it was registered, even though we're going to use it in a ``Sprite2D``, a derived class."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1756
msgid "The seemingly random number for getting the bind is actually a hash of the method signature. This allows Godot to match the method you're requesting even if in a future Godot version this signature changes, by providing a compatibility method that matches what you're asking for. This is one of the systems that allow the engine to load extensions made for previous versions. You can get the value of this hash from the ``extension_api.json`` file."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1763
msgid "With all that, we can finally implement our custom ``_process()`` method in the ``gdexample.c`` file:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1793
msgid "After updating the time passed scaled by the ``speed`` property, it creates ``x`` and ``y`` values based on that, also modulated by the ``amplitude`` property. This is what will give the pattern effect. The ``math.h`` header is needed for the ``sin()`` and ``cos()`` functions used here."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1798
msgid "Then it sets up an array of arguments to construct a ``Vector2``, followed by calling the constructor. It sets up another array of arguments and use it to call the ``set_position()`` method via the bind we acquired previously."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1802
msgid "Since nothing here allocates any memory, there's not a need to cleanup."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1804
msgid "Now we can build the extension again and reopen Godot. Even in the editor you'll see the custom sprite moving."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1809
msgid "Try changing the **Speed** and **Amplitude** properties and see how the sprite react."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1813
msgid "Registering and emitting a signal"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1815
msgid "To complete this tutorial, let's see how you can register a custom signal and emit it when appropriate. As you might have guessed, we'll need a few more function pointers from the API and more helper functions."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1819
msgid "In the ``api.h`` file we're adding two things. One is a an API function to register a signal, the other is a helper function to wrap the signal binding."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1839
msgid "In this case we only have a version for one argument, since it's what we're going to use."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1842
msgid "Moving to the ``api.c`` file, we can load this new function pointer and implement the helper:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1879
msgid "This one is very similar to the function to bind methods. The main difference is that we don't need to fill another struct, we just pass the needed names and the array of arguments. The ``1`` at the end means the amount of arguments the signal provides."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1884
msgid "With this we can bind the signal in ``gdexample.c``:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1894
msgid "In order to emit a signal, we need to call the :ref:`emit_signal() <class_Object_method_emit_signal>` method on our custom node. Since this is a ``vararg`` function (meaning it takes any amount of arguments), we cannot use ``ptrcall``. To do a regular call, we have to create Variants, which require a few more steps of plumbing to get done."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1900
msgid "First, in the ``defs.h`` file we create a definition for Variant:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1928
msgid "We first set the size of Variant together with the size of Vector2 that we added before. Then we use it to create an opaque struct that is enough to hold the Variant data. Again, we set the size for double precision builds as a fallback, since by the official Godot builds use single precision."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1933
msgid "The ``emit_signal()`` function will be called with two arguments. The first is the name of the signal to be emitted and the second is the argument we're passing to the signal connections, which is a Vector2 as we declared when binding it. So we're gonna create a helper function that can call a MethodBind with these types. Even though it does return something (an error code), we don't need to deal with it, so for now we're just going to ignore it."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1940
msgid "In the ``api.h``, we're adding a few things to the existing structs, plus a new helper function for the call:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:1981
msgid "Now let's switch to the ``api.c`` file to load these new function pointers and implement the helper function."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2026
msgid "This helper function has some boilerplate code but is quite straightforward. It sets up the two arguments inside stack allocated Variants, then creates an array with pointers to those. It also sets up another Variant to keep the return value, which we don't need to construct since the call expects it to be uninitialized."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2031
msgid "Then it actually calls the MethodBind using the instance we provided and the arguments. The ``NULL`` at the end would be a pointer to a ``GDExtensionCallError`` struct. This can be used to treat potential errors when calling the functions (such as wrong arguments). For the sake of simplicity we're not gonna handle that here."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2037
msgid "At the end we need to destruct the Variants we created. While technically the Vector2 one does not require destructing, it is clearer to cleanup everything."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2040
msgid "We also need to load the MethodBind, which we'll do in the ``init.c`` file, right after loading the one for the ``set_position`` method we did before:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2059
msgid "Note that we reuse the ``native_class_name`` and ``method_name`` variables here, so we don't need to declare new ones."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2062
msgid "Now go to the ``gdexample.h`` file where we're going to add a couple of fields:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2076
msgid "The first one will store the time passed since the last signal was emitted, since we'll be doing so at regular intervals. The other is just to cache the signal name so we don't need to create a new StringName every time."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2080
msgid "In the source ``gdexample.c`` file we can change the constructor and destructor to deal with the new fields:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2100
msgid "It is important to destruct the StringName to avoid memory leaks."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2102
msgid "Now we can add to the ``gdexample_class_process()`` function to actually emit the signal:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2120
msgid "This updates the time passed for the signal emission and, if it is over one second it calls the ``emit_signal()`` function on the current instance, passing the name of the signal and the new position as arguments."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2124
msgid "Now we're done with our C GDExtension. Build it once more and reopen the demo project in the editor."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2127
msgid "In the documentation page for ``GDExample`` you can see the new signal we bound:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2131
msgid "To check it's working, let's add a small script to the root node, parent of our custom one, that prints the position to the output every time it receives the signal:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2145
msgid "Run the project and you can observe the values being printed in the Output dock in the editor:"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2151
msgid "Conclusion"
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2153
msgid "This tutorial shows a basic extension with custom methods, properties, and signals. While it does require a good amount of boilerplate, it can scale well by creating helper functions to handle the tedious tasks."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2157
msgid "This should serve as a good basis to understand the GDExtension API and as a starting point to create custom binding generators. In fact, it would be possible to create bindings for C using such type of generator, making the actual coding look more like the ``gdexample.c`` file in this example, which is quite straightforward and not very verbose."
msgstr ""

#: ../../docs/tutorials/scripting/gdextension/gdextension_c_example.rst:2163
msgid "If you want to create actual extensions, it is preferred to use the C++ bindings instead, as it takes away all of the boilerplate from your code. Check the :ref:`GDExtension C++ example <doc_gdextension_cpp_example>` to see how you can do this."
msgstr ""
